[
    {
        "rel_file_path": "sympy/combinatorics/partitions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/combinatorics/partitions.py",
        "start": 12,
        "end": 302,
        "class_name": "Partition",
        "method_name": null,
        "code": "12 class Partition(FiniteSet):\n13     \"\"\"\n14     This class represents an abstract partition.\n15 \n16     A partition is a set of disjoint sets whose union equals a given set.\n17 \n18     See Also\n19     ========\n20 \n21     sympy.utilities.iterables.partitions,\n22     sympy.utilities.iterables.multiset_partitions\n23     \"\"\"\n24 \n25     _rank = None\n26     _partition = None\n27 \n28     def __new__(cls, *partition):\n29         \"\"\"\n30         Generates a new partition object.\n31 \n32         This method also verifies if the arguments passed are\n33         valid and raises a ValueError if they are not.\n34 \n35         Examples\n36         ========\n37 \n38         Creating Partition from Python lists:\n39 \n40         >>> from sympy.combinatorics.partitions import Partition\n41         >>> a = Partition([1, 2], [3])\n42         >>> a\n43         Partition(FiniteSet(1, 2), FiniteSet(3))\n44         >>> a.partition\n45         [[1, 2], [3]]\n46         >>> len(a)\n47         2\n48         >>> a.members\n49         (1, 2, 3)\n50 \n51         Creating Partition from Python sets:\n52 \n53         >>> Partition({1, 2, 3}, {4, 5})\n54         Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))\n55 \n56         Creating Partition from SymPy finite sets:\n57 \n58         >>> from sympy.sets.sets import FiniteSet\n59         >>> a = FiniteSet(1, 2, 3)\n60         >>> b = FiniteSet(4, 5)\n61         >>> Partition(a, b)\n62         Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))\n63         \"\"\"\n64         args = []\n65         dups = False\n66         for arg in partition:\n67             if isinstance(arg, list):\n68                 as_set = set(arg)\n69                 if len(as_set) < len(arg):\n70                     dups = True\n71                     break  # error below\n72                 arg = as_set\n73             args.append(_sympify(arg))\n74 \n75         if not all(isinstance(part, FiniteSet) for part in args):\n76             raise ValueError(\n77                 \"Each argument to Partition should be \" \\\n78                 \"a list, set, or a FiniteSet\")\n79 \n80         # sort so we have a canonical reference for RGS\n81         U = Union(*args)\n82         if dups or len(U) < sum(len(arg) for arg in args):\n83             raise ValueError(\"Partition contained duplicate elements.\")\n84 \n85         obj = FiniteSet.__new__(cls, *args)\n86         obj.members = tuple(U)\n87         obj.size = len(U)\n88         return obj\n89 \n90     def sort_key(self, order=None):\n91         \"\"\"Return a canonical key that can be used for sorting.\n92 \n93         Ordering is based on the size and sorted elements of the partition\n94         and ties are broken with the rank.\n95 \n96         Examples\n97         ========\n98 \n99         >>> from sympy.utilities.iterables import default_sort_key\n100         >>> from sympy.combinatorics.partitions import Partition\n101         >>> from sympy.abc import x\n102         >>> a = Partition([1, 2])\n103         >>> b = Partition([3, 4])\n104         >>> c = Partition([1, x])\n105         >>> d = Partition(list(range(4)))\n106         >>> l = [d, b, a + 1, a, c]\n107         >>> l.sort(key=default_sort_key); l\n108         [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]\n109         \"\"\"\n110         if order is None:\n111             members = self.members\n112         else:\n113             members = tuple(sorted(self.members,\n114                              key=lambda w: default_sort_key(w, order)))\n115         return tuple(map(default_sort_key, (self.size, members, self.rank)))\n116 \n117     @property\n118     def partition(self):\n119         \"\"\"Return partition as a sorted list of lists.\n120 \n121         Examples\n122         ========\n123 \n124         >>> from sympy.combinatorics.partitions import Partition\n125         >>> Partition([1], [2, 3]).partition\n126         [[1], [2, 3]]\n127         \"\"\"\n128         if self._partition is None:\n129             self._partition = sorted([sorted(p, key=default_sort_key)\n130                                       for p in self.args])\n131         return self._partition\n132 \n133     def __add__(self, other):\n134         \"\"\"\n135         Return permutation whose rank is ``other`` greater than current rank,\n136         (mod the maximum rank for the set).\n137 \n138         Examples\n139         ========\n140 \n141         >>> from sympy.combinatorics.partitions import Partition\n142         >>> a = Partition([1, 2], [3])\n143         >>> a.rank\n144         1\n145         >>> (a + 1).rank\n146         2\n147         >>> (a + 100).rank\n148         1\n149         \"\"\"\n150         other = as_int(other)\n151         offset = self.rank + other\n152         result = RGS_unrank((offset) %\n153                             RGS_enum(self.size),\n154                             self.size)\n155         return Partition.from_rgs(result, self.members)\n156 \n157     def __sub__(self, other):\n158         \"\"\"\n159         Return permutation whose rank is ``other`` less than current rank,\n160         (mod the maximum rank for the set).\n161 \n162         Examples\n163         ========\n164 \n165         >>> from sympy.combinatorics.partitions import Partition\n166         >>> a = Partition([1, 2], [3])\n167         >>> a.rank\n168         1\n169         >>> (a - 1).rank\n170         0\n171         >>> (a - 100).rank\n172         1\n173         \"\"\"\n174         return self.__add__(-other)\n175 \n176     def __le__(self, other):\n177         \"\"\"\n178         Checks if a partition is less than or equal to\n179         the other based on rank.\n180 \n181         Examples\n182         ========\n183 \n184         >>> from sympy.combinatorics.partitions import Partition\n185         >>> a = Partition([1, 2], [3, 4, 5])\n186         >>> b = Partition([1], [2, 3], [4], [5])\n187         >>> a.rank, b.rank\n188         (9, 34)\n189         >>> a <= a\n190         True\n191         >>> a <= b\n192         True\n193         \"\"\"\n194         return self.sort_key() <= sympify(other).sort_key()\n195 \n196     def __lt__(self, other):\n197         \"\"\"\n198         Checks if a partition is less than the other.\n199 \n200         Examples\n201         ========\n202 \n203         >>> from sympy.combinatorics.partitions import Partition\n204         >>> a = Partition([1, 2], [3, 4, 5])\n205         >>> b = Partition([1], [2, 3], [4], [5])\n206         >>> a.rank, b.rank\n207         (9, 34)\n208         >>> a < b\n209         True\n210         \"\"\"\n211         return self.sort_key() < sympify(other).sort_key()\n212 \n213     @property\n214     def rank(self):\n215         \"\"\"\n216         Gets the rank of a partition.\n217 \n218         Examples\n219         ========\n220 \n221         >>> from sympy.combinatorics.partitions import Partition\n222         >>> a = Partition([1, 2], [3], [4, 5])\n223         >>> a.rank\n224         13\n225         \"\"\"\n226         if self._rank is not None:\n227             return self._rank\n228         self._rank = RGS_rank(self.RGS)\n229         return self._rank\n230 \n231     @property\n232     def RGS(self):\n233         \"\"\"\n234         Returns the \"restricted growth string\" of the partition.\n235 \n236         Explanation\n237         ===========\n238 \n239         The RGS is returned as a list of indices, L, where L[i] indicates\n240         the block in which element i appears. For example, in a partition\n241         of 3 elements (a, b, c) into 2 blocks ([c], [a, b]) the RGS is\n242         [1, 1, 0]: \"a\" is in block 1, \"b\" is in block 1 and \"c\" is in block 0.\n243 \n244         Examples\n245         ========\n246 \n247         >>> from sympy.combinatorics.partitions import Partition\n248         >>> a = Partition([1, 2], [3], [4, 5])\n249         >>> a.members\n250         (1, 2, 3, 4, 5)\n251         >>> a.RGS\n252         (0, 0, 1, 2, 2)\n253         >>> a + 1\n254         Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))\n255         >>> _.RGS\n256         (0, 0, 1, 2, 3)\n257         \"\"\"\n258         rgs = {}\n259         partition = self.partition\n260         for i, part in enumerate(partition):\n261             for j in part:\n262                 rgs[j] = i\n263         return tuple([rgs[i] for i in sorted(\n264             [i for p in partition for i in p], key=default_sort_key)])\n265 \n266     @classmethod\n267     def from_rgs(self, rgs, elements):\n268         \"\"\"\n269         Creates a set partition from a restricted growth string.\n270 \n271         Explanation\n272         ===========\n273 \n274         The indices given in rgs are assumed to be the index\n275         of the element as given in elements *as provided* (the\n276         elements are not sorted by this routine). Block numbering\n277         starts from 0. If any block was not referenced in ``rgs``\n278         an error will be raised.\n279 \n280         Examples\n281         ========\n282 \n283         >>> from sympy.combinatorics.partitions import Partition\n284         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('abcde'))\n285         Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))\n286         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))\n287         Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))\n288         >>> a = Partition([1, 4], [2], [3, 5])\n289         >>> Partition.from_rgs(a.RGS, a.members)\n290         Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))\n291         \"\"\"\n292         if len(rgs) != len(elements):\n293             raise ValueError('mismatch in rgs and element lengths')\n294         max_elem = max(rgs) + 1\n295         partition = [[] for i in range(max_elem)]\n296         j = 0\n297         for i in rgs:\n298             partition[i].append(elements[j])\n299             j += 1\n300         if not all(p for p in partition):\n301             raise ValueError('some blocks of the partition were empty.')\n302         return Partition(*partition)\n",
        "intended_behavior": "A new `__str__` or `__repr__` method should be added or modified to make the string representation of `Partition` instances less verbose, displaying elements as a simple list or set notation (`Partition({1, 2})` or `Partition([1, 2])`) without the unnecessary inclusion of `FiniteSet`."
    },
    {
        "rel_file_path": "sympy/combinatorics/permutations.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/combinatorics/permutations.py",
        "start": 471,
        "end": 3010,
        "class_name": "Permutation",
        "method_name": null,
        "code": "471 class Permutation(Atom):\n472     \"\"\"\n473     A permutation, alternatively known as an 'arrangement number' or 'ordering'\n474     is an arrangement of the elements of an ordered list into a one-to-one\n475     mapping with itself. The permutation of a given arrangement is given by\n476     indicating the positions of the elements after re-arrangement [2]_. For\n477     example, if one started with elements [x, y, a, b] (in that order) and\n478     they were reordered as [x, y, b, a] then the permutation would be\n479     [0, 1, 3, 2]. Notice that (in SymPy) the first element is always referred\n480     to as 0 and the permutation uses the indices of the elements in the\n481     original ordering, not the elements (a, b, etc...) themselves.\n482 \n483     >>> from sympy.combinatorics import Permutation\n484     >>> from sympy.interactive import init_printing\n485     >>> init_printing(perm_cyclic=False, pretty_print=False)\n486 \n487     Permutations Notation\n488     =====================\n489 \n490     Permutations are commonly represented in disjoint cycle or array forms.\n491 \n492     Array Notation and 2-line Form\n493     ------------------------------------\n494 \n495     In the 2-line form, the elements and their final positions are shown\n496     as a matrix with 2 rows:\n497 \n498     [0    1    2     ... n-1]\n499     [p(0) p(1) p(2)  ... p(n-1)]\n500 \n501     Since the first line is always range(n), where n is the size of p,\n502     it is sufficient to represent the permutation by the second line,\n503     referred to as the \"array form\" of the permutation. This is entered\n504     in brackets as the argument to the Permutation class:\n505 \n506     >>> p = Permutation([0, 2, 1]); p\n507     Permutation([0, 2, 1])\n508 \n509     Given i in range(p.size), the permutation maps i to i^p\n510 \n511     >>> [i^p for i in range(p.size)]\n512     [0, 2, 1]\n513 \n514     The composite of two permutations p*q means first apply p, then q, so\n515     i^(p*q) = (i^p)^q which is i^p^q according to Python precedence rules:\n516 \n517     >>> q = Permutation([2, 1, 0])\n518     >>> [i^p^q for i in range(3)]\n519     [2, 0, 1]\n520     >>> [i^(p*q) for i in range(3)]\n521     [2, 0, 1]\n522 \n523     One can use also the notation p(i) = i^p, but then the composition\n524     rule is (p*q)(i) = q(p(i)), not p(q(i)):\n525 \n526     >>> [(p*q)(i) for i in range(p.size)]\n527     [2, 0, 1]\n528     >>> [q(p(i)) for i in range(p.size)]\n529     [2, 0, 1]\n530     >>> [p(q(i)) for i in range(p.size)]\n531     [1, 2, 0]\n532 \n533     Disjoint Cycle Notation\n534     -----------------------\n535 \n536     In disjoint cycle notation, only the elements that have shifted are\n537     indicated. In the above case, the 2 and 1 switched places. This can\n538     be entered in two ways:\n539 \n540     >>> Permutation(1, 2) == Permutation([[1, 2]]) == p\n541     True\n542 \n543     Only the relative ordering of elements in a cycle matter:\n544 \n545     >>> Permutation(1,2,3) == Permutation(2,3,1) == Permutation(3,1,2)\n546     True\n547 \n548     The disjoint cycle notation is convenient when representing\n549     permutations that have several cycles in them:\n550 \n551     >>> Permutation(1, 2)(3, 5) == Permutation([[1, 2], [3, 5]])\n552     True\n553 \n554     It also provides some economy in entry when computing products of\n555     permutations that are written in disjoint cycle notation:\n556 \n557     >>> Permutation(1, 2)(1, 3)(2, 3)\n558     Permutation([0, 3, 2, 1])\n559     >>> _ == Permutation([[1, 2]])*Permutation([[1, 3]])*Permutation([[2, 3]])\n560     True\n561 \n562         Caution: when the cycles have common elements\n563         between them then the order in which the\n564         permutations are applied matters. The\n565         convention is that the permutations are\n566         applied from *right to left*. In the following, the\n567         transposition of elements 2 and 3 is followed\n568         by the transposition of elements 1 and 2:\n569 \n570         >>> Permutation(1, 2)(2, 3) == Permutation([(1, 2), (2, 3)])\n571         True\n572         >>> Permutation(1, 2)(2, 3).list()\n573         [0, 3, 1, 2]\n574 \n575         If the first and second elements had been\n576         swapped first, followed by the swapping of the second\n577         and third, the result would have been [0, 2, 3, 1].\n578         If, for some reason, you want to apply the cycles\n579         in the order they are entered, you can simply reverse\n580         the order of cycles:\n581 \n582         >>> Permutation([(1, 2), (2, 3)][::-1]).list()\n583         [0, 2, 3, 1]\n584 \n585     Entering a singleton in a permutation is a way to indicate the size of the\n586     permutation. The ``size`` keyword can also be used.\n587 \n588     Array-form entry:\n589 \n590     >>> Permutation([[1, 2], [9]])\n591     Permutation([0, 2, 1], size=10)\n592     >>> Permutation([[1, 2]], size=10)\n593     Permutation([0, 2, 1], size=10)\n594 \n595     Cyclic-form entry:\n596 \n597     >>> Permutation(1, 2, size=10)\n598     Permutation([0, 2, 1], size=10)\n599     >>> Permutation(9)(1, 2)\n600     Permutation([0, 2, 1], size=10)\n601 \n602     Caution: no singleton containing an element larger than the largest\n603     in any previous cycle can be entered. This is an important difference\n604     in how Permutation and Cycle handle the __call__ syntax. A singleton\n605     argument at the start of a Permutation performs instantiation of the\n606     Permutation and is permitted:\n607 \n608     >>> Permutation(5)\n609     Permutation([], size=6)\n610 \n611     A singleton entered after instantiation is a call to the permutation\n612     -- a function call -- and if the argument is out of range it will\n613     trigger an error. For this reason, it is better to start the cycle\n614     with the singleton:\n615 \n616     The following fails because there is no element 3:\n617 \n618     >>> Permutation(1, 2)(3)\n619     Traceback (most recent call last):\n620     ...\n621     IndexError: list index out of range\n622 \n623     This is ok: only the call to an out of range singleton is prohibited;\n624     otherwise the permutation autosizes:\n625 \n626     >>> Permutation(3)(1, 2)\n627     Permutation([0, 2, 1, 3])\n628     >>> Permutation(1, 2)(3, 4) == Permutation(3, 4)(1, 2)\n629     True\n630 \n631 \n632     Equality testing\n633     ----------------\n634 \n635     The array forms must be the same in order for permutations to be equal:\n636 \n637     >>> Permutation([1, 0, 2, 3]) == Permutation([1, 0])\n638     False\n639 \n640 \n641     Identity Permutation\n642     --------------------\n643 \n644     The identity permutation is a permutation in which no element is out of\n645     place. It can be entered in a variety of ways. All the following create\n646     an identity permutation of size 4:\n647 \n648     >>> I = Permutation([0, 1, 2, 3])\n649     >>> all(p == I for p in [\n650     ... Permutation(3),\n651     ... Permutation(range(4)),\n652     ... Permutation([], size=4),\n653     ... Permutation(size=4)])\n654     True\n655 \n656     Watch out for entering the range *inside* a set of brackets (which is\n657     cycle notation):\n658 \n659     >>> I == Permutation([range(4)])\n660     False\n661 \n662 \n663     Permutation Printing\n664     ====================\n665 \n666     There are a few things to note about how Permutations are printed.\n667 \n668     1) If you prefer one form (array or cycle) over another, you can set\n669     ``init_printing`` with the ``perm_cyclic`` flag.\n670 \n671     >>> from sympy import init_printing\n672     >>> p = Permutation(1, 2)(4, 5)(3, 4)\n673     >>> p\n674     Permutation([0, 2, 1, 4, 5, 3])\n675 \n676     >>> init_printing(perm_cyclic=True, pretty_print=False)\n677     >>> p\n678     (1 2)(3 4 5)\n679 \n680     2) Regardless of the setting, a list of elements in the array for cyclic\n681     form can be obtained and either of those can be copied and supplied as\n682     the argument to Permutation:\n683 \n684     >>> p.array_form\n685     [0, 2, 1, 4, 5, 3]\n686     >>> p.cyclic_form\n687     [[1, 2], [3, 4, 5]]\n688     >>> Permutation(_) == p\n689     True\n690 \n691     3) Printing is economical in that as little as possible is printed while\n692     retaining all information about the size of the permutation:\n693 \n694     >>> init_printing(perm_cyclic=False, pretty_print=False)\n695     >>> Permutation([1, 0, 2, 3])\n696     Permutation([1, 0, 2, 3])\n697     >>> Permutation([1, 0, 2, 3], size=20)\n698     Permutation([1, 0], size=20)\n699     >>> Permutation([1, 0, 2, 4, 3, 5, 6], size=20)\n700     Permutation([1, 0, 2, 4, 3], size=20)\n701 \n702     >>> p = Permutation([1, 0, 2, 3])\n703     >>> init_printing(perm_cyclic=True, pretty_print=False)\n704     >>> p\n705     (3)(0 1)\n706     >>> init_printing(perm_cyclic=False, pretty_print=False)\n707 \n708     The 2 was not printed but it is still there as can be seen with the\n709     array_form and size methods:\n710 \n711     >>> p.array_form\n712     [1, 0, 2, 3]\n713     >>> p.size\n714     4\n715 \n716     Short introduction to other methods\n717     ===================================\n718 \n719     The permutation can act as a bijective function, telling what element is\n720     located at a given position\n721 \n722     >>> q = Permutation([5, 2, 3, 4, 1, 0])\n723     >>> q.array_form[1] # the hard way\n724     2\n725     >>> q(1) # the easy way\n726     2\n727     >>> {i: q(i) for i in range(q.size)} # showing the bijection\n728     {0: 5, 1: 2, 2: 3, 3: 4, 4: 1, 5: 0}\n729 \n730     The full cyclic form (including singletons) can be obtained:\n731 \n732     >>> p.full_cyclic_form\n733     [[0, 1], [2], [3]]\n734 \n735     Any permutation can be factored into transpositions of pairs of elements:\n736 \n737     >>> Permutation([[1, 2], [3, 4, 5]]).transpositions()\n738     [(1, 2), (3, 5), (3, 4)]\n739     >>> Permutation.rmul(*[Permutation([ti], size=6) for ti in _]).cyclic_form\n740     [[1, 2], [3, 4, 5]]\n741 \n742     The number of permutations on a set of n elements is given by n! and is\n743     called the cardinality.\n744 \n745     >>> p.size\n746     4\n747     >>> p.cardinality\n748     24\n749 \n750     A given permutation has a rank among all the possible permutations of the\n751     same elements, but what that rank is depends on how the permutations are\n752     enumerated. (There are a number of different methods of doing so.) The\n753     lexicographic rank is given by the rank method and this rank is used to\n754     increment a permutation with addition/subtraction:\n755 \n756     >>> p.rank()\n757     6\n758     >>> p + 1\n759     Permutation([1, 0, 3, 2])\n760     >>> p.next_lex()\n761     Permutation([1, 0, 3, 2])\n762     >>> _.rank()\n763     7\n764     >>> p.unrank_lex(p.size, rank=7)\n765     Permutation([1, 0, 3, 2])\n766 \n767     The product of two permutations p and q is defined as their composition as\n768     functions, (p*q)(i) = q(p(i)) [6]_.\n769 \n770     >>> p = Permutation([1, 0, 2, 3])\n771     >>> q = Permutation([2, 3, 1, 0])\n772     >>> list(q*p)\n773     [2, 3, 0, 1]\n774     >>> list(p*q)\n775     [3, 2, 1, 0]\n776     >>> [q(p(i)) for i in range(p.size)]\n777     [3, 2, 1, 0]\n778 \n779     The permutation can be 'applied' to any list-like object, not only\n780     Permutations:\n781 \n782     >>> p(['zero', 'one', 'four', 'two'])\n783     ['one', 'zero', 'four', 'two']\n784     >>> p('zo42')\n785     ['o', 'z', '4', '2']\n786 \n787     If you have a list of arbitrary elements, the corresponding permutation\n788     can be found with the from_sequence method:\n789 \n790     >>> Permutation.from_sequence('SymPy')\n791     Permutation([1, 3, 2, 0, 4])\n792 \n793     Checking if a Permutation is contained in a Group\n794     =================================================\n795 \n796     Generally if you have a group of permutations G on n symbols, and\n797     you're checking if a permutation on less than n symbols is part\n798     of that group, the check will fail.\n799 \n800     Here is an example for n=5 and we check if the cycle\n801     (1,2,3) is in G:\n802 \n803     >>> from sympy import init_printing\n804     >>> init_printing(perm_cyclic=True, pretty_print=False)\n805     >>> from sympy.combinatorics import Cycle, Permutation\n806     >>> from sympy.combinatorics.perm_groups import PermutationGroup\n807     >>> G = PermutationGroup(Cycle(2, 3)(4, 5), Cycle(1, 2, 3, 4, 5))\n808     >>> p1 = Permutation(Cycle(2, 5, 3))\n809     >>> p2 = Permutation(Cycle(1, 2, 3))\n810     >>> a1 = Permutation(Cycle(1, 2, 3).list(6))\n811     >>> a2 = Permutation(Cycle(1, 2, 3)(5))\n812     >>> a3 = Permutation(Cycle(1, 2, 3),size=6)\n813     >>> for p in [p1,p2,a1,a2,a3]: p, G.contains(p)\n814     ((2 5 3), True)\n815     ((1 2 3), False)\n816     ((5)(1 2 3), True)\n817     ((5)(1 2 3), True)\n818     ((5)(1 2 3), True)\n819 \n820     The check for p2 above will fail.\n821 \n822     Checking if p1 is in G works because SymPy knows\n823     G is a group on 5 symbols, and p1 is also on 5 symbols\n824     (its largest element is 5).\n825 \n826     For ``a1``, the ``.list(6)`` call will extend the permutation to 5\n827     symbols, so the test will work as well. In the case of ``a2`` the\n828     permutation is being extended to 5 symbols by using a singleton,\n829     and in the case of ``a3`` it's extended through the constructor\n830     argument ``size=6``.\n831 \n832     There is another way to do this, which is to tell the ``contains``\n833     method that the number of symbols the group is on doesn't need to\n834     match perfectly the number of symbols for the permutation:\n835 \n836     >>> G.contains(p2,strict=False)\n837     True\n838 \n839     This can be via the ``strict`` argument to the ``contains`` method,\n840     and SymPy will try to extend the permutation on its own and then\n841     perform the containment check.\n842 \n843     See Also\n844     ========\n845 \n846     Cycle\n847 \n848     References\n849     ==========\n850 \n851     .. [1] Skiena, S. 'Permutations.' 1.1 in Implementing Discrete Mathematics\n852            Combinatorics and Graph Theory with Mathematica.  Reading, MA:\n853            Addison-Wesley, pp. 3-16, 1990.\n854 \n855     .. [2] Knuth, D. E. The Art of Computer Programming, Vol. 4: Combinatorial\n856            Algorithms, 1st ed. Reading, MA: Addison-Wesley, 2011.\n857 \n858     .. [3] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking\n859            permutations in linear time. Inf. Process. Lett. 79, 6 (September 2001),\n860            281-284. DOI=10.1016/S0020-0190(01)00141-7\n861 \n862     .. [4] D. L. Kreher, D. R. Stinson 'Combinatorial Algorithms'\n863            CRC Press, 1999\n864 \n865     .. [5] Graham, R. L.; Knuth, D. E.; and Patashnik, O.\n866            Concrete Mathematics: A Foundation for Computer Science, 2nd ed.\n867            Reading, MA: Addison-Wesley, 1994.\n868 \n869     .. [6] https://en.wikipedia.org/wiki/Permutation#Product_and_inverse\n870 \n871     .. [7] https://en.wikipedia.org/wiki/Lehmer_code\n872 \n873     \"\"\"\n874 \n875     is_Permutation = True\n876 \n877     _array_form = None\n878     _cyclic_form = None\n879     _cycle_structure = None\n880     _size = None\n881     _rank = None\n882 \n883     def __new__(cls, *args, size=None, **kwargs):\n884         \"\"\"\n885         Constructor for the Permutation object from a list or a\n886         list of lists in which all elements of the permutation may\n887         appear only once.\n888 \n889         Examples\n890         ========\n891 \n892         >>> from sympy.combinatorics.permutations import Permutation\n893         >>> from sympy.interactive import init_printing\n894         >>> init_printing(perm_cyclic=False, pretty_print=False)\n895 \n896         Permutations entered in array-form are left unaltered:\n897 \n898         >>> Permutation([0, 2, 1])\n899         Permutation([0, 2, 1])\n900 \n901         Permutations entered in cyclic form are converted to array form;\n902         singletons need not be entered, but can be entered to indicate the\n903         largest element:\n904 \n905         >>> Permutation([[4, 5, 6], [0, 1]])\n906         Permutation([1, 0, 2, 3, 5, 6, 4])\n907         >>> Permutation([[4, 5, 6], [0, 1], [19]])\n908         Permutation([1, 0, 2, 3, 5, 6, 4], size=20)\n909 \n910         All manipulation of permutations assumes that the smallest element\n911         is 0 (in keeping with 0-based indexing in Python) so if the 0 is\n912         missing when entering a permutation in array form, an error will be\n913         raised:\n914 \n915         >>> Permutation([2, 1])\n916         Traceback (most recent call last):\n917         ...\n918         ValueError: Integers 0 through 2 must be present.\n919 \n920         If a permutation is entered in cyclic form, it can be entered without\n921         singletons and the ``size`` specified so those values can be filled\n922         in, otherwise the array form will only extend to the maximum value\n923         in the cycles:\n924 \n925         >>> Permutation([[1, 4], [3, 5, 2]], size=10)\n926         Permutation([0, 4, 3, 5, 1, 2], size=10)\n927         >>> _.array_form\n928         [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]\n929         \"\"\"\n930         if size is not None:\n931             size = int(size)\n932 \n933         #a) ()\n934         #b) (1) = identity\n935         #c) (1, 2) = cycle\n936         #d) ([1, 2, 3]) = array form\n937         #e) ([[1, 2]]) = cyclic form\n938         #f) (Cycle) = conversion to permutation\n939         #g) (Permutation) = adjust size or return copy\n940         ok = True\n941         if not args:  # a\n942             return cls._af_new(list(range(size or 0)))\n943         elif len(args) > 1:  # c\n944             return cls._af_new(Cycle(*args).list(size))\n945         if len(args) == 1:\n946             a = args[0]\n947             if isinstance(a, cls):  # g\n948                 if size is None or size == a.size:\n949                     return a\n950                 return cls(a.array_form, size=size)\n951             if isinstance(a, Cycle):  # f\n952                 return cls._af_new(a.list(size))\n953             if not is_sequence(a):  # b\n954                 if size is not None and a + 1 > size:\n955                     raise ValueError('size is too small when max is %s' % a)\n956                 return cls._af_new(list(range(a + 1)))\n957             if has_variety(is_sequence(ai) for ai in a):\n958                 ok = False\n959         else:\n960             ok = False\n961         if not ok:\n962             raise ValueError(\"Permutation argument must be a list of ints, \"\n963                              \"a list of lists, Permutation or Cycle.\")\n964 \n965         # safe to assume args are valid; this also makes a copy\n966         # of the args\n967         args = list(args[0])\n968 \n969         is_cycle = args and is_sequence(args[0])\n970         if is_cycle:  # e\n971             args = [[int(i) for i in c] for c in args]\n972         else:  # d\n973             args = [int(i) for i in args]\n974 \n975         # if there are n elements present, 0, 1, ..., n-1 should be present\n976         # unless a cycle notation has been provided. A 0 will be added\n977         # for convenience in case one wants to enter permutations where\n978         # counting starts from 1.\n979 \n980         temp = flatten(args)\n981         if has_dups(temp) and not is_cycle:\n982             raise ValueError('there were repeated elements.')\n983         temp = set(temp)\n984 \n985         if not is_cycle:\n986             if any(i not in temp for i in range(len(temp))):\n987                 raise ValueError('Integers 0 through %s must be present.' %\n988                 max(temp))\n989             if size is not None and temp and max(temp) + 1 > size:\n990                 raise ValueError('max element should not exceed %s' % (size - 1))\n991 \n992         if is_cycle:\n993             # it's not necessarily canonical so we won't store\n994             # it -- use the array form instead\n995             c = Cycle()\n996             for ci in args:\n997                 c = c(*ci)\n998             aform = c.list()\n999         else:\n1000             aform = list(args)\n1001         if size and size > len(aform):\n1002             # don't allow for truncation of permutation which\n1003             # might split a cycle and lead to an invalid aform\n1004             # but do allow the permutation size to be increased\n1005             aform.extend(list(range(len(aform), size)))\n1006 \n1007         return cls._af_new(aform)\n1008 \n1009     @classmethod\n1010     def _af_new(cls, perm):\n1011         \"\"\"A method to produce a Permutation object from a list;\n1012         the list is bound to the _array_form attribute, so it must\n1013         not be modified; this method is meant for internal use only;\n1014         the list ``a`` is supposed to be generated as a temporary value\n1015         in a method, so p = Perm._af_new(a) is the only object\n1016         to hold a reference to ``a``::\n1017 \n1018         Examples\n1019         ========\n1020 \n1021         >>> from sympy.combinatorics.permutations import Perm\n1022         >>> from sympy.interactive import init_printing\n1023         >>> init_printing(perm_cyclic=False, pretty_print=False)\n1024         >>> a = [2, 1, 3, 0]\n1025         >>> p = Perm._af_new(a)\n1026         >>> p\n1027         Permutation([2, 1, 3, 0])\n1028 \n1029         \"\"\"\n1030         p = super().__new__(cls)\n1031         p._array_form = perm\n1032         p._size = len(perm)\n1033         return p\n1034 \n1035     def _hashable_content(self):\n1036         # the array_form (a list) is the Permutation arg, so we need to\n1037         # return a tuple, instead\n1038         return tuple(self.array_form)\n1039 \n1040     @property\n1041     def array_form(self):\n1042         \"\"\"\n1043         Return a copy of the attribute _array_form\n1044         Examples\n1045         ========\n1046 \n1047         >>> from sympy.combinatorics.permutations import Permutation\n1048         >>> p = Permutation([[2, 0], [3, 1]])\n1049         >>> p.array_form\n1050         [2, 3, 0, 1]\n1051         >>> Permutation([[2, 0, 3, 1]]).array_form\n1052         [3, 2, 0, 1]\n1053         >>> Permutation([2, 0, 3, 1]).array_form\n1054         [2, 0, 3, 1]\n1055         >>> Permutation([[1, 2], [4, 5]]).array_form\n1056         [0, 2, 1, 3, 5, 4]\n1057         \"\"\"\n1058         return self._array_form[:]\n1059 \n1060     def list(self, size=None):\n1061         \"\"\"Return the permutation as an explicit list, possibly\n1062         trimming unmoved elements if size is less than the maximum\n1063         element in the permutation; if this is desired, setting\n1064         ``size=-1`` will guarantee such trimming.\n1065 \n1066         Examples\n1067         ========\n1068 \n1069         >>> from sympy.combinatorics.permutations import Permutation\n1070         >>> p = Permutation(2, 3)(4, 5)\n1071         >>> p.list()\n1072         [0, 1, 3, 2, 5, 4]\n1073         >>> p.list(10)\n1074         [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]\n1075 \n1076         Passing a length too small will trim trailing, unchanged elements\n1077         in the permutation:\n1078 \n1079         >>> Permutation(2, 4)(1, 2, 4).list(-1)\n1080         [0, 2, 1]\n1081         >>> Permutation(3).list(-1)\n1082         []\n1083         \"\"\"\n1084         if not self and size is None:\n1085             raise ValueError('must give size for empty Cycle')\n1086         rv = self.array_form\n1087         if size is not None:\n1088             if size > self.size:\n1089                 rv.extend(list(range(self.size, size)))\n1090             else:\n1091                 # find first value from rhs where rv[i] != i\n1092                 i = self.size - 1\n1093                 while rv:\n1094                     if rv[-1] != i:\n1095                         break\n1096                     rv.pop()\n1097                     i -= 1\n1098         return rv\n1099 \n1100     @property\n1101     def cyclic_form(self):\n1102         \"\"\"\n1103         This is used to convert to the cyclic notation\n1104         from the canonical notation. Singletons are omitted.\n1105 \n1106         Examples\n1107         ========\n1108 \n1109         >>> from sympy.combinatorics.permutations import Permutation\n1110         >>> p = Permutation([0, 3, 1, 2])\n1111         >>> p.cyclic_form\n1112         [[1, 3, 2]]\n1113         >>> Permutation([1, 0, 2, 4, 3, 5]).cyclic_form\n1114         [[0, 1], [3, 4]]\n1115 \n1116         See Also\n1117         ========\n1118 \n1119         array_form, full_cyclic_form\n1120         \"\"\"\n1121         if self._cyclic_form is not None:\n1122             return list(self._cyclic_form)\n1123         array_form = self.array_form\n1124         unchecked = [True] * len(array_form)\n1125         cyclic_form = []\n1126         for i in range(len(array_form)):\n1127             if unchecked[i]:\n1128                 cycle = []\n1129                 cycle.append(i)\n1130                 unchecked[i] = False\n1131                 j = i\n1132                 while unchecked[array_form[j]]:\n1133                     j = array_form[j]\n1134                     cycle.append(j)\n1135                     unchecked[j] = False\n1136                 if len(cycle) > 1:\n1137                     cyclic_form.append(cycle)\n1138                     assert cycle == list(minlex(cycle))\n1139         cyclic_form.sort()\n1140         self._cyclic_form = cyclic_form[:]\n1141         return cyclic_form\n1142 \n1143     @property\n1144     def full_cyclic_form(self):\n1145         \"\"\"Return permutation in cyclic form including singletons.\n1146 \n1147         Examples\n1148         ========\n1149 \n1150         >>> from sympy.combinatorics.permutations import Permutation\n1151         >>> Permutation([0, 2, 1]).full_cyclic_form\n1152         [[0], [1, 2]]\n1153         \"\"\"\n1154         need = set(range(self.size)) - set(flatten(self.cyclic_form))\n1155         rv = self.cyclic_form\n1156         rv.extend([[i] for i in need])\n1157         rv.sort()\n1158         return rv\n1159 \n1160     @property\n1161     def size(self):\n1162         \"\"\"\n1163         Returns the number of elements in the permutation.\n1164 \n1165         Examples\n1166         ========\n1167 \n1168         >>> from sympy.combinatorics import Permutation\n1169         >>> Permutation([[3, 2], [0, 1]]).size\n1170         4\n1171 \n1172         See Also\n1173         ========\n1174 \n1175         cardinality, length, order, rank\n1176         \"\"\"\n1177         return self._size\n1178 \n1179     def support(self):\n1180         \"\"\"Return the elements in permutation, P, for which P[i] != i.\n1181 \n1182         Examples\n1183         ========\n1184 \n1185         >>> from sympy.combinatorics import Permutation\n1186         >>> p = Permutation([[3, 2], [0, 1], [4]])\n1187         >>> p.array_form\n1188         [1, 0, 3, 2, 4]\n1189         >>> p.support()\n1190         [0, 1, 2, 3]\n1191         \"\"\"\n1192         a = self.array_form\n1193         return [i for i, e in enumerate(a) if a[i] != i]\n1194 \n1195     def __add__(self, other):\n1196         \"\"\"Return permutation that is other higher in rank than self.\n1197 \n1198         The rank is the lexicographical rank, with the identity permutation\n1199         having rank of 0.\n1200 \n1201         Examples\n1202         ========\n1203 \n1204         >>> from sympy.combinatorics.permutations import Permutation\n1205         >>> I = Permutation([0, 1, 2, 3])\n1206         >>> a = Permutation([2, 1, 3, 0])\n1207         >>> I + a.rank() == a\n1208         True\n1209 \n1210         See Also\n1211         ========\n1212 \n1213         __sub__, inversion_vector\n1214 \n1215         \"\"\"\n1216         rank = (self.rank() + other) % self.cardinality\n1217         rv = self.unrank_lex(self.size, rank)\n1218         rv._rank = rank\n1219         return rv\n1220 \n1221     def __sub__(self, other):\n1222         \"\"\"Return the permutation that is other lower in rank than self.\n1223 \n1224         See Also\n1225         ========\n1226 \n1227         __add__\n1228         \"\"\"\n1229         return self.__add__(-other)\n1230 \n1231     @staticmethod\n1232     def rmul(*args):\n1233         \"\"\"\n1234         Return product of Permutations [a, b, c, ...] as the Permutation whose\n1235         ith value is a(b(c(i))).\n1236 \n1237         a, b, c, ... can be Permutation objects or tuples.\n1238 \n1239         Examples\n1240         ========\n1241 \n1242         >>> from sympy.combinatorics.permutations import Permutation\n1243 \n1244         >>> a, b = [1, 0, 2], [0, 2, 1]\n1245         >>> a = Permutation(a); b = Permutation(b)\n1246         >>> list(Permutation.rmul(a, b))\n1247         [1, 2, 0]\n1248         >>> [a(b(i)) for i in range(3)]\n1249         [1, 2, 0]\n1250 \n1251         This handles the operands in reverse order compared to the ``*`` operator:\n1252 \n1253         >>> a = Permutation(a); b = Permutation(b)\n1254         >>> list(a*b)\n1255         [2, 0, 1]\n1256         >>> [b(a(i)) for i in range(3)]\n1257         [2, 0, 1]\n1258 \n1259         Notes\n1260         =====\n1261 \n1262         All items in the sequence will be parsed by Permutation as\n1263         necessary as long as the first item is a Permutation:\n1264 \n1265         >>> Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)\n1266         True\n1267 \n1268         The reverse order of arguments will raise a TypeError.\n1269 \n1270         \"\"\"\n1271         rv = args[0]\n1272         for i in range(1, len(args)):\n1273             rv = args[i]*rv\n1274         return rv\n1275 \n1276     @classmethod\n1277     def rmul_with_af(cls, *args):\n1278         \"\"\"\n1279         same as rmul, but the elements of args are Permutation objects\n1280         which have _array_form\n1281         \"\"\"\n1282         a = [x._array_form for x in args]\n1283         rv = cls._af_new(_af_rmuln(*a))\n1284         return rv\n1285 \n1286     def mul_inv(self, other):\n1287         \"\"\"\n1288         other*~self, self and other have _array_form\n1289         \"\"\"\n1290         a = _af_invert(self._array_form)\n1291         b = other._array_form\n1292         return self._af_new(_af_rmul(a, b))\n1293 \n1294     def __rmul__(self, other):\n1295         \"\"\"This is needed to coerce other to Permutation in rmul.\"\"\"\n1296         cls = type(self)\n1297         return cls(other)*self\n1298 \n1299     def __mul__(self, other):\n1300         \"\"\"\n1301         Return the product a*b as a Permutation; the ith value is b(a(i)).\n1302 \n1303         Examples\n1304         ========\n1305 \n1306         >>> from sympy.combinatorics.permutations import _af_rmul, Permutation\n1307 \n1308         >>> a, b = [1, 0, 2], [0, 2, 1]\n1309         >>> a = Permutation(a); b = Permutation(b)\n1310         >>> list(a*b)\n1311         [2, 0, 1]\n1312         >>> [b(a(i)) for i in range(3)]\n1313         [2, 0, 1]\n1314 \n1315         This handles operands in reverse order compared to _af_rmul and rmul:\n1316 \n1317         >>> al = list(a); bl = list(b)\n1318         >>> _af_rmul(al, bl)\n1319         [1, 2, 0]\n1320         >>> [al[bl[i]] for i in range(3)]\n1321         [1, 2, 0]\n1322 \n1323         It is acceptable for the arrays to have different lengths; the shorter\n1324         one will be padded to match the longer one:\n1325 \n1326         >>> from sympy.interactive import init_printing\n1327         >>> init_printing(perm_cyclic=False, pretty_print=False)\n1328         >>> b*Permutation([1, 0])\n1329         Permutation([1, 2, 0])\n1330         >>> Permutation([1, 0])*b\n1331         Permutation([2, 0, 1])\n1332 \n1333         It is also acceptable to allow coercion to handle conversion of a\n1334         single list to the left of a Permutation:\n1335 \n1336         >>> [0, 1]*a # no change: 2-element identity\n1337         Permutation([1, 0, 2])\n1338         >>> [[0, 1]]*a # exchange first two elements\n1339         Permutation([0, 1, 2])\n1340 \n1341         You cannot use more than 1 cycle notation in a product of cycles\n1342         since coercion can only handle one argument to the left. To handle\n1343         multiple cycles it is convenient to use Cycle instead of Permutation:\n1344 \n1345         >>> [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP\n1346         >>> from sympy.combinatorics.permutations import Cycle\n1347         >>> Cycle(1, 2)(2, 3)\n1348         (1 3 2)\n1349 \n1350         \"\"\"\n1351         from sympy.combinatorics.perm_groups import PermutationGroup, Coset\n1352         if isinstance(other, PermutationGroup):\n1353             return Coset(self, other, dir='-')\n1354         a = self.array_form\n1355         # __rmul__ makes sure the other is a Permutation\n1356         b = other.array_form\n1357         if not b:\n1358             perm = a\n1359         else:\n1360             b.extend(list(range(len(b), len(a))))\n1361             perm = [b[i] for i in a] + b[len(a):]\n1362         return self._af_new(perm)\n1363 \n1364     def commutes_with(self, other):\n1365         \"\"\"\n1366         Checks if the elements are commuting.\n1367 \n1368         Examples\n1369         ========\n1370 \n1371         >>> from sympy.combinatorics.permutations import Permutation\n1372         >>> a = Permutation([1, 4, 3, 0, 2, 5])\n1373         >>> b = Permutation([0, 1, 2, 3, 4, 5])\n1374         >>> a.commutes_with(b)\n1375         True\n1376         >>> b = Permutation([2, 3, 5, 4, 1, 0])\n1377         >>> a.commutes_with(b)\n1378         False\n1379         \"\"\"\n1380         a = self.array_form\n1381         b = other.array_form\n1382         return _af_commutes_with(a, b)\n1383 \n1384     def __pow__(self, n):\n1385         \"\"\"\n1386         Routine for finding powers of a permutation.\n1387 \n1388         Examples\n1389         ========\n1390 \n1391         >>> from sympy.combinatorics.permutations import Permutation\n1392         >>> from sympy.interactive import init_printing\n1393         >>> init_printing(perm_cyclic=False, pretty_print=False)\n1394         >>> p = Permutation([2, 0, 3, 1])\n1395         >>> p.order()\n1396         4\n1397         >>> p**4\n1398         Permutation([0, 1, 2, 3])\n1399         \"\"\"\n1400         if isinstance(n, Permutation):\n1401             raise NotImplementedError(\n1402                 'p**p is not defined; do you mean p^p (conjugate)?')\n1403         n = int(n)\n1404         return self._af_new(_af_pow(self.array_form, n))\n1405 \n1406     def __rxor__(self, i):\n1407         \"\"\"Return self(i) when ``i`` is an int.\n1408 \n1409         Examples\n1410         ========\n1411 \n1412         >>> from sympy.combinatorics import Permutation\n1413         >>> p = Permutation(1, 2, 9)\n1414         >>> 2^p == p(2) == 9\n1415         True\n1416         \"\"\"\n1417         if int(i) == i:\n1418             return self(i)\n1419         else:\n1420             raise NotImplementedError(\n1421                 \"i^p = p(i) when i is an integer, not %s.\" % i)\n1422 \n1423     def __xor__(self, h):\n1424         \"\"\"Return the conjugate permutation ``~h*self*h` `.\n1425 \n1426         Explanation\n1427         ===========\n1428 \n1429         If ``a`` and ``b`` are conjugates, ``a = h*b*~h`` and\n1430         ``b = ~h*a*h`` and both have the same cycle structure.\n1431 \n1432         Examples\n1433         ========\n1434 \n1435         >>> from sympy.combinatorics.permutations import Permutation\n1436         >>> p = Permutation(1, 2, 9)\n1437         >>> q = Permutation(6, 9, 8)\n1438         >>> p*q != q*p\n1439         True\n1440 \n1441         Calculate and check properties of the conjugate:\n1442 \n1443         >>> c = p^q\n1444         >>> c == ~q*p*q and p == q*c*~q\n1445         True\n1446 \n1447         The expression q^p^r is equivalent to q^(p*r):\n1448 \n1449         >>> r = Permutation(9)(4, 6, 8)\n1450         >>> q^p^r == q^(p*r)\n1451         True\n1452 \n1453         If the term to the left of the conjugate operator, i, is an integer\n1454         then this is interpreted as selecting the ith element from the\n1455         permutation to the right:\n1456 \n1457         >>> all(i^p == p(i) for i in range(p.size))\n1458         True\n1459 \n1460         Note that the * operator as higher precedence than the ^ operator:\n1461 \n1462         >>> q^r*p^r == q^(r*p)^r == Permutation(9)(1, 6, 4)\n1463         True\n1464 \n1465         Notes\n1466         =====\n1467 \n1468         In Python the precedence rule is p^q^r = (p^q)^r which differs\n1469         in general from p^(q^r)\n1470 \n1471         >>> q^p^r\n1472         (9)(1 4 8)\n1473         >>> q^(p^r)\n1474         (9)(1 8 6)\n1475 \n1476         For a given r and p, both of the following are conjugates of p:\n1477         ~r*p*r and r*p*~r. But these are not necessarily the same:\n1478 \n1479         >>> ~r*p*r == r*p*~r\n1480         True\n1481 \n1482         >>> p = Permutation(1, 2, 9)(5, 6)\n1483         >>> ~r*p*r == r*p*~r\n1484         False\n1485 \n1486         The conjugate ~r*p*r was chosen so that ``p^q^r`` would be equivalent\n1487         to ``p^(q*r)`` rather than ``p^(r*q)``. To obtain r*p*~r, pass ~r to\n1488         this method:\n1489 \n1490         >>> p^~r == r*p*~r\n1491         True\n1492         \"\"\"\n1493 \n1494         if self.size != h.size:\n1495             raise ValueError(\"The permutations must be of equal size.\")\n1496         a = [None]*self.size\n1497         h = h._array_form\n1498         p = self._array_form\n1499         for i in range(self.size):\n1500             a[h[i]] = h[p[i]]\n1501         return self._af_new(a)\n1502 \n1503     def transpositions(self):\n1504         \"\"\"\n1505         Return the permutation decomposed into a list of transpositions.\n1506 \n1507         Explanation\n1508         ===========\n1509 \n1510         It is always possible to express a permutation as the product of\n1511         transpositions, see [1]\n1512 \n1513         Examples\n1514         ========\n1515 \n1516         >>> from sympy.combinatorics.permutations import Permutation\n1517         >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])\n1518         >>> t = p.transpositions()\n1519         >>> t\n1520         [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]\n1521         >>> print(''.join(str(c) for c in t))\n1522         (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)\n1523         >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p\n1524         True\n1525 \n1526         References\n1527         ==========\n1528 \n1529         .. [1] https://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties\n1530 \n1531         \"\"\"\n1532         a = self.cyclic_form\n1533         res = []\n1534         for x in a:\n1535             nx = len(x)\n1536             if nx == 2:\n1537                 res.append(tuple(x))\n1538             elif nx > 2:\n1539                 first = x[0]\n1540                 for y in x[nx - 1:0:-1]:\n1541                     res.append((first, y))\n1542         return res\n1543 \n1544     @classmethod\n1545     def from_sequence(self, i, key=None):\n1546         \"\"\"Return the permutation needed to obtain ``i`` from the sorted\n1547         elements of ``i``. If custom sorting is desired, a key can be given.\n1548 \n1549         Examples\n1550         ========\n1551 \n1552         >>> from sympy.combinatorics import Permutation\n1553 \n1554         >>> Permutation.from_sequence('SymPy')\n1555         (4)(0 1 3)\n1556         >>> _(sorted(\"SymPy\"))\n1557         ['S', 'y', 'm', 'P', 'y']\n1558         >>> Permutation.from_sequence('SymPy', key=lambda x: x.lower())\n1559         (4)(0 2)(1 3)\n1560         \"\"\"\n1561         ic = list(zip(i, list(range(len(i)))))\n1562         if key:\n1563             ic.sort(key=lambda x: key(x[0]))\n1564         else:\n1565             ic.sort()\n1566         return ~Permutation([i[1] for i in ic])\n1567 \n1568     def __invert__(self):\n1569         \"\"\"\n1570         Return the inverse of the permutation.\n1571 \n1572         A permutation multiplied by its inverse is the identity permutation.\n1573 \n1574         Examples\n1575         ========\n1576 \n1577         >>> from sympy.combinatorics.permutations import Permutation\n1578         >>> from sympy.interactive import init_printing\n1579         >>> init_printing(perm_cyclic=False, pretty_print=False)\n1580         >>> p = Permutation([[2, 0], [3, 1]])\n1581         >>> ~p\n1582         Permutation([2, 3, 0, 1])\n1583         >>> _ == p**-1\n1584         True\n1585         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])\n1586         True\n1587         \"\"\"\n1588         return self._af_new(_af_invert(self._array_form))\n1589 \n1590     def __iter__(self):\n1591         \"\"\"Yield elements from array form.\n1592 \n1593         Examples\n1594         ========\n1595 \n1596         >>> from sympy.combinatorics import Permutation\n1597         >>> list(Permutation(range(3)))\n1598         [0, 1, 2]\n1599         \"\"\"\n1600         yield from self.array_form\n1601 \n1602     def __repr__(self):\n1603         from sympy.printing.repr import srepr\n1604         return srepr(self)\n1605 \n1606     def __call__(self, *i):\n1607         \"\"\"\n1608         Allows applying a permutation instance as a bijective function.\n1609 \n1610         Examples\n1611         ========\n1612 \n1613         >>> from sympy.combinatorics.permutations import Permutation\n1614         >>> p = Permutation([[2, 0], [3, 1]])\n1615         >>> p.array_form\n1616         [2, 3, 0, 1]\n1617         >>> [p(i) for i in range(4)]\n1618         [2, 3, 0, 1]\n1619 \n1620         If an array is given then the permutation selects the items\n1621         from the array (i.e. the permutation is applied to the array):\n1622 \n1623         >>> from sympy.abc import x\n1624         >>> p([x, 1, 0, x**2])\n1625         [0, x**2, x, 1]\n1626         \"\"\"\n1627         # list indices can be Integer or int; leave this\n1628         # as it is (don't test or convert it) because this\n1629         # gets called a lot and should be fast\n1630         if len(i) == 1:\n1631             i = i[0]\n1632             if not isinstance(i, Iterable):\n1633                 i = as_int(i)\n1634                 if i < 0 or i > self.size:\n1635                     raise TypeError(\n1636                         \"{} should be an integer between 0 and {}\"\n1637                         .format(i, self.size-1))\n1638                 return self._array_form[i]\n1639             # P([a, b, c])\n1640             if len(i) != self.size:\n1641                 raise TypeError(\n1642                     \"{} should have the length {}.\".format(i, self.size))\n1643             return [i[j] for j in self._array_form]\n1644         # P(1, 2, 3)\n1645         return self*Permutation(Cycle(*i), size=self.size)\n1646 \n1647     def atoms(self):\n1648         \"\"\"\n1649         Returns all the elements of a permutation\n1650 \n1651         Examples\n1652         ========\n1653 \n1654         >>> from sympy.combinatorics import Permutation\n1655         >>> Permutation([0, 1, 2, 3, 4, 5]).atoms()\n1656         {0, 1, 2, 3, 4, 5}\n1657         >>> Permutation([[0, 1], [2, 3], [4, 5]]).atoms()\n1658         {0, 1, 2, 3, 4, 5}\n1659         \"\"\"\n1660         return set(self.array_form)\n1661 \n1662     def apply(self, i):\n1663         r\"\"\"Apply the permutation to an expression.\n1664 \n1665         Parameters\n1666         ==========\n1667 \n1668         i : Expr\n1669             It should be an integer between $0$ and $n-1$ where $n$\n1670             is the size of the permutation.\n1671 \n1672             If it is a symbol or a symbolic expression that can\n1673             have integer values, an ``AppliedPermutation`` object\n1674             will be returned which can represent an unevaluated\n1675             function.\n1676 \n1677         Notes\n1678         =====\n1679 \n1680         Any permutation can be defined as a bijective function\n1681         $\\sigma : \\{ 0, 1, ..., n-1 \\} \\rightarrow \\{ 0, 1, ..., n-1 \\}$\n1682         where $n$ denotes the size of the permutation.\n1683 \n1684         The definition may even be extended for any set with distinctive\n1685         elements, such that the permutation can even be applied for\n1686         real numbers or such, however, it is not implemented for now for\n1687         computational reasons and the integrity with the group theory\n1688         module.\n1689 \n1690         This function is similar to the ``__call__`` magic, however,\n1691         ``__call__`` magic already has some other applications like\n1692         permuting an array or attatching new cycles, which would\n1693         not always be mathematically consistent.\n1694 \n1695         This also guarantees that the return type is a SymPy integer,\n1696         which guarantees the safety to use assumptions.\n1697         \"\"\"\n1698         i = _sympify(i)\n1699         if i.is_integer is False:\n1700             raise NotImplementedError(\"{} should be an integer.\".format(i))\n1701 \n1702         n = self.size\n1703         if (i < 0) == True or (i >= n) == True:\n1704             raise NotImplementedError(\n1705                 \"{} should be an integer between 0 and {}\".format(i, n-1))\n1706 \n1707         if i.is_Integer:\n1708             return Integer(self._array_form[i])\n1709         return AppliedPermutation(self, i)\n1710 \n1711     def next_lex(self):\n1712         \"\"\"\n1713         Returns the next permutation in lexicographical order.\n1714         If self is the last permutation in lexicographical order\n1715         it returns None.\n1716         See [4] section 2.4.\n1717 \n1718 \n1719         Examples\n1720         ========\n1721 \n1722         >>> from sympy.combinatorics.permutations import Permutation\n1723         >>> p = Permutation([2, 3, 1, 0])\n1724         >>> p = Permutation([2, 3, 1, 0]); p.rank()\n1725         17\n1726         >>> p = p.next_lex(); p.rank()\n1727         18\n1728 \n1729         See Also\n1730         ========\n1731 \n1732         rank, unrank_lex\n1733         \"\"\"\n1734         perm = self.array_form[:]\n1735         n = len(perm)\n1736         i = n - 2\n1737         while perm[i + 1] < perm[i]:\n1738             i -= 1\n1739         if i == -1:\n1740             return None\n1741         else:\n1742             j = n - 1\n1743             while perm[j] < perm[i]:\n1744                 j -= 1\n1745             perm[j], perm[i] = perm[i], perm[j]\n1746             i += 1\n1747             j = n - 1\n1748             while i < j:\n1749                 perm[j], perm[i] = perm[i], perm[j]\n1750                 i += 1\n1751                 j -= 1\n1752         return self._af_new(perm)\n1753 \n1754     @classmethod\n1755     def unrank_nonlex(self, n, r):\n1756         \"\"\"\n1757         This is a linear time unranking algorithm that does not\n1758         respect lexicographic order [3].\n1759 \n1760         Examples\n1761         ========\n1762 \n1763         >>> from sympy.combinatorics.permutations import Permutation\n1764         >>> from sympy.interactive import init_printing\n1765         >>> init_printing(perm_cyclic=False, pretty_print=False)\n1766         >>> Permutation.unrank_nonlex(4, 5)\n1767         Permutation([2, 0, 3, 1])\n1768         >>> Permutation.unrank_nonlex(4, -1)\n1769         Permutation([0, 1, 2, 3])\n1770 \n1771         See Also\n1772         ========\n1773 \n1774         next_nonlex, rank_nonlex\n1775         \"\"\"\n1776         def _unrank1(n, r, a):\n1777             if n > 0:\n1778                 a[n - 1], a[r % n] = a[r % n], a[n - 1]\n1779                 _unrank1(n - 1, r//n, a)\n1780 \n1781         id_perm = list(range(n))\n1782         n = int(n)\n1783         r = r % ifac(n)\n1784         _unrank1(n, r, id_perm)\n1785         return self._af_new(id_perm)\n1786 \n1787     def rank_nonlex(self, inv_perm=None):\n1788         \"\"\"\n1789         This is a linear time ranking algorithm that does not\n1790         enforce lexicographic order [3].\n1791 \n1792 \n1793         Examples\n1794         ========\n1795 \n1796         >>> from sympy.combinatorics.permutations import Permutation\n1797         >>> p = Permutation([0, 1, 2, 3])\n1798         >>> p.rank_nonlex()\n1799         23\n1800 \n1801         See Also\n1802         ========\n1803 \n1804         next_nonlex, unrank_nonlex\n1805         \"\"\"\n1806         def _rank1(n, perm, inv_perm):\n1807             if n == 1:\n1808                 return 0\n1809             s = perm[n - 1]\n1810             t = inv_perm[n - 1]\n1811             perm[n - 1], perm[t] = perm[t], s\n1812             inv_perm[n - 1], inv_perm[s] = inv_perm[s], t\n1813             return s + n*_rank1(n - 1, perm, inv_perm)\n1814 \n1815         if inv_perm is None:\n1816             inv_perm = (~self).array_form\n1817         if not inv_perm:\n1818             return 0\n1819         perm = self.array_form[:]\n1820         r = _rank1(len(perm), perm, inv_perm)\n1821         return r\n1822 \n1823     def next_nonlex(self):\n1824         \"\"\"\n1825         Returns the next permutation in nonlex order [3].\n1826         If self is the last permutation in this order it returns None.\n1827 \n1828         Examples\n1829         ========\n1830 \n1831         >>> from sympy.combinatorics.permutations import Permutation\n1832         >>> from sympy.interactive import init_printing\n1833         >>> init_printing(perm_cyclic=False, pretty_print=False)\n1834         >>> p = Permutation([2, 0, 3, 1]); p.rank_nonlex()\n1835         5\n1836         >>> p = p.next_nonlex(); p\n1837         Permutation([3, 0, 1, 2])\n1838         >>> p.rank_nonlex()\n1839         6\n1840 \n1841         See Also\n1842         ========\n1843 \n1844         rank_nonlex, unrank_nonlex\n1845         \"\"\"\n1846         r = self.rank_nonlex()\n1847         if r == ifac(self.size) - 1:\n1848             return None\n1849         return self.unrank_nonlex(self.size, r + 1)\n1850 \n1851     def rank(self):\n1852         \"\"\"\n1853         Returns the lexicographic rank of the permutation.\n1854 \n1855         Examples\n1856         ========\n1857 \n1858         >>> from sympy.combinatorics.permutations import Permutation\n1859         >>> p = Permutation([0, 1, 2, 3])\n1860         >>> p.rank()\n1861         0\n1862         >>> p = Permutation([3, 2, 1, 0])\n1863         >>> p.rank()\n1864         23\n1865 \n1866         See Also\n1867         ========\n1868 \n1869         next_lex, unrank_lex, cardinality, length, order, size\n1870         \"\"\"\n1871         if not self._rank is None:\n1872             return self._rank\n1873         rank = 0\n1874         rho = self.array_form[:]\n1875         n = self.size - 1\n1876         size = n + 1\n1877         psize = int(ifac(n))\n1878         for j in range(size - 1):\n1879             rank += rho[j]*psize\n1880             for i in range(j + 1, size):\n1881                 if rho[i] > rho[j]:\n1882                     rho[i] -= 1\n1883             psize //= n\n1884             n -= 1\n1885         self._rank = rank\n1886         return rank\n1887 \n1888     @property\n1889     def cardinality(self):\n1890         \"\"\"\n1891         Returns the number of all possible permutations.\n1892 \n1893         Examples\n1894         ========\n1895 \n1896         >>> from sympy.combinatorics.permutations import Permutation\n1897         >>> p = Permutation([0, 1, 2, 3])\n1898         >>> p.cardinality\n1899         24\n1900 \n1901         See Also\n1902         ========\n1903 \n1904         length, order, rank, size\n1905         \"\"\"\n1906         return int(ifac(self.size))\n1907 \n1908     def parity(self):\n1909         \"\"\"\n1910         Computes the parity of a permutation.\n1911 \n1912         Explanation\n1913         ===========\n1914 \n1915         The parity of a permutation reflects the parity of the\n1916         number of inversions in the permutation, i.e., the\n1917         number of pairs of x and y such that ``x > y`` but ``p[x] < p[y]``.\n1918 \n1919         Examples\n1920         ========\n1921 \n1922         >>> from sympy.combinatorics.permutations import Permutation\n1923         >>> p = Permutation([0, 1, 2, 3])\n1924         >>> p.parity()\n1925         0\n1926         >>> p = Permutation([3, 2, 0, 1])\n1927         >>> p.parity()\n1928         1\n1929 \n1930         See Also\n1931         ========\n1932 \n1933         _af_parity\n1934         \"\"\"\n1935         if self._cyclic_form is not None:\n1936             return (self.size - self.cycles) % 2\n1937 \n1938         return _af_parity(self.array_form)\n1939 \n1940     @property\n1941     def is_even(self):\n1942         \"\"\"\n1943         Checks if a permutation is even.\n1944 \n1945         Examples\n1946         ========\n1947 \n1948         >>> from sympy.combinatorics.permutations import Permutation\n1949         >>> p = Permutation([0, 1, 2, 3])\n1950         >>> p.is_even\n1951         True\n1952         >>> p = Permutation([3, 2, 1, 0])\n1953         >>> p.is_even\n1954         True\n1955 \n1956         See Also\n1957         ========\n1958 \n1959         is_odd\n1960         \"\"\"\n1961         return not self.is_odd\n1962 \n1963     @property\n1964     def is_odd(self):\n1965         \"\"\"\n1966         Checks if a permutation is odd.\n1967 \n1968         Examples\n1969         ========\n1970 \n1971         >>> from sympy.combinatorics.permutations import Permutation\n1972         >>> p = Permutation([0, 1, 2, 3])\n1973         >>> p.is_odd\n1974         False\n1975         >>> p = Permutation([3, 2, 0, 1])\n1976         >>> p.is_odd\n1977         True\n1978 \n1979         See Also\n1980         ========\n1981 \n1982         is_even\n1983         \"\"\"\n1984         return bool(self.parity() % 2)\n1985 \n1986     @property\n1987     def is_Singleton(self):\n1988         \"\"\"\n1989         Checks to see if the permutation contains only one number and is\n1990         thus the only possible permutation of this set of numbers\n1991 \n1992         Examples\n1993         ========\n1994 \n1995         >>> from sympy.combinatorics import Permutation\n1996         >>> Permutation([0]).is_Singleton\n1997         True\n1998         >>> Permutation([0, 1]).is_Singleton\n1999         False\n2000 \n2001         See Also\n2002         ========\n2003 \n2004         is_Empty\n2005         \"\"\"\n2006         return self.size == 1\n2007 \n2008     @property\n2009     def is_Empty(self):\n2010         \"\"\"\n2011         Checks to see if the permutation is a set with zero elements\n2012 \n2013         Examples\n2014         ========\n2015 \n2016         >>> from sympy.combinatorics import Permutation\n2017         >>> Permutation([]).is_Empty\n2018         True\n2019         >>> Permutation([0]).is_Empty\n2020         False\n2021 \n2022         See Also\n2023         ========\n2024 \n2025         is_Singleton\n2026         \"\"\"\n2027         return self.size == 0\n2028 \n2029     @property\n2030     def is_identity(self):\n2031         return self.is_Identity\n2032 \n2033     @property\n2034     def is_Identity(self):\n2035         \"\"\"\n2036         Returns True if the Permutation is an identity permutation.\n2037 \n2038         Examples\n2039         ========\n2040 \n2041         >>> from sympy.combinatorics.permutations import Permutation\n2042         >>> p = Permutation([])\n2043         >>> p.is_Identity\n2044         True\n2045         >>> p = Permutation([[0], [1], [2]])\n2046         >>> p.is_Identity\n2047         True\n2048         >>> p = Permutation([0, 1, 2])\n2049         >>> p.is_Identity\n2050         True\n2051         >>> p = Permutation([0, 2, 1])\n2052         >>> p.is_Identity\n2053         False\n2054 \n2055         See Also\n2056         ========\n2057 \n2058         order\n2059         \"\"\"\n2060         af = self.array_form\n2061         return not af or all(i == af[i] for i in range(self.size))\n2062 \n2063     def ascents(self):\n2064         \"\"\"\n2065         Returns the positions of ascents in a permutation, ie, the location\n2066         where p[i] < p[i+1]\n2067 \n2068         Examples\n2069         ========\n2070 \n2071         >>> from sympy.combinatorics.permutations import Permutation\n2072         >>> p = Permutation([4, 0, 1, 3, 2])\n2073         >>> p.ascents()\n2074         [1, 2]\n2075 \n2076         See Also\n2077         ========\n2078 \n2079         descents, inversions, min, max\n2080         \"\"\"\n2081         a = self.array_form\n2082         pos = [i for i in range(len(a) - 1) if a[i] < a[i + 1]]\n2083         return pos\n2084 \n2085     def descents(self):\n2086         \"\"\"\n2087         Returns the positions of descents in a permutation, ie, the location\n2088         where p[i] > p[i+1]\n2089 \n2090         Examples\n2091         ========\n2092 \n2093         >>> from sympy.combinatorics.permutations import Permutation\n2094         >>> p = Permutation([4, 0, 1, 3, 2])\n2095         >>> p.descents()\n2096         [0, 3]\n2097 \n2098         See Also\n2099         ========\n2100 \n2101         ascents, inversions, min, max\n2102         \"\"\"\n2103         a = self.array_form\n2104         pos = [i for i in range(len(a) - 1) if a[i] > a[i + 1]]\n2105         return pos\n2106 \n2107     def max(self):\n2108         \"\"\"\n2109         The maximum element moved by the permutation.\n2110 \n2111         Examples\n2112         ========\n2113 \n2114         >>> from sympy.combinatorics.permutations import Permutation\n2115         >>> p = Permutation([1, 0, 2, 3, 4])\n2116         >>> p.max()\n2117         1\n2118 \n2119         See Also\n2120         ========\n2121 \n2122         min, descents, ascents, inversions\n2123         \"\"\"\n2124         max = 0\n2125         a = self.array_form\n2126         for i in range(len(a)):\n2127             if a[i] != i and a[i] > max:\n2128                 max = a[i]\n2129         return max\n2130 \n2131     def min(self):\n2132         \"\"\"\n2133         The minimum element moved by the permutation.\n2134 \n2135         Examples\n2136         ========\n2137 \n2138         >>> from sympy.combinatorics.permutations import Permutation\n2139         >>> p = Permutation([0, 1, 4, 3, 2])\n2140         >>> p.min()\n2141         2\n2142 \n2143         See Also\n2144         ========\n2145 \n2146         max, descents, ascents, inversions\n2147         \"\"\"\n2148         a = self.array_form\n2149         min = len(a)\n2150         for i in range(len(a)):\n2151             if a[i] != i and a[i] < min:\n2152                 min = a[i]\n2153         return min\n2154 \n2155     def inversions(self):\n2156         \"\"\"\n2157         Computes the number of inversions of a permutation.\n2158 \n2159         Explanation\n2160         ===========\n2161 \n2162         An inversion is where i > j but p[i] < p[j].\n2163 \n2164         For small length of p, it iterates over all i and j\n2165         values and calculates the number of inversions.\n2166         For large length of p, it uses a variation of merge\n2167         sort to calculate the number of inversions.\n2168 \n2169         Examples\n2170         ========\n2171 \n2172         >>> from sympy.combinatorics.permutations import Permutation\n2173         >>> p = Permutation([0, 1, 2, 3, 4, 5])\n2174         >>> p.inversions()\n2175         0\n2176         >>> Permutation([3, 2, 1, 0]).inversions()\n2177         6\n2178 \n2179         See Also\n2180         ========\n2181 \n2182         descents, ascents, min, max\n2183 \n2184         References\n2185         ==========\n2186 \n2187         .. [1] http://www.cp.eng.chula.ac.th/~piak/teaching/algo/algo2008/count-inv.htm\n2188 \n2189         \"\"\"\n2190         inversions = 0\n2191         a = self.array_form\n2192         n = len(a)\n2193         if n < 130:\n2194             for i in range(n - 1):\n2195                 b = a[i]\n2196                 for c in a[i + 1:]:\n2197                     if b > c:\n2198                         inversions += 1\n2199         else:\n2200             k = 1\n2201             right = 0\n2202             arr = a[:]\n2203             temp = a[:]\n2204             while k < n:\n2205                 i = 0\n2206                 while i + k < n:\n2207                     right = i + k * 2 - 1\n2208                     if right >= n:\n2209                         right = n - 1\n2210                     inversions += _merge(arr, temp, i, i + k, right)\n2211                     i = i + k * 2\n2212                 k = k * 2\n2213         return inversions\n2214 \n2215     def commutator(self, x):\n2216         \"\"\"Return the commutator of ``self`` and ``x``: ``~x*~self*x*self``\n2217 \n2218         If f and g are part of a group, G, then the commutator of f and g\n2219         is the group identity iff f and g commute, i.e. fg == gf.\n2220 \n2221         Examples\n2222         ========\n2223 \n2224         >>> from sympy.combinatorics.permutations import Permutation\n2225         >>> from sympy.interactive import init_printing\n2226         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2227         >>> p = Permutation([0, 2, 3, 1])\n2228         >>> x = Permutation([2, 0, 3, 1])\n2229         >>> c = p.commutator(x); c\n2230         Permutation([2, 1, 3, 0])\n2231         >>> c == ~x*~p*x*p\n2232         True\n2233 \n2234         >>> I = Permutation(3)\n2235         >>> p = [I + i for i in range(6)]\n2236         >>> for i in range(len(p)):\n2237         ...     for j in range(len(p)):\n2238         ...         c = p[i].commutator(p[j])\n2239         ...         if p[i]*p[j] == p[j]*p[i]:\n2240         ...             assert c == I\n2241         ...         else:\n2242         ...             assert c != I\n2243         ...\n2244 \n2245         References\n2246         ==========\n2247 \n2248         https://en.wikipedia.org/wiki/Commutator\n2249         \"\"\"\n2250 \n2251         a = self.array_form\n2252         b = x.array_form\n2253         n = len(a)\n2254         if len(b) != n:\n2255             raise ValueError(\"The permutations must be of equal size.\")\n2256         inva = [None]*n\n2257         for i in range(n):\n2258             inva[a[i]] = i\n2259         invb = [None]*n\n2260         for i in range(n):\n2261             invb[b[i]] = i\n2262         return self._af_new([a[b[inva[i]]] for i in invb])\n2263 \n2264     def signature(self):\n2265         \"\"\"\n2266         Gives the signature of the permutation needed to place the\n2267         elements of the permutation in canonical order.\n2268 \n2269         The signature is calculated as (-1)^<number of inversions>\n2270 \n2271         Examples\n2272         ========\n2273 \n2274         >>> from sympy.combinatorics.permutations import Permutation\n2275         >>> p = Permutation([0, 1, 2])\n2276         >>> p.inversions()\n2277         0\n2278         >>> p.signature()\n2279         1\n2280         >>> q = Permutation([0,2,1])\n2281         >>> q.inversions()\n2282         1\n2283         >>> q.signature()\n2284         -1\n2285 \n2286         See Also\n2287         ========\n2288 \n2289         inversions\n2290         \"\"\"\n2291         if self.is_even:\n2292             return 1\n2293         return -1\n2294 \n2295     def order(self):\n2296         \"\"\"\n2297         Computes the order of a permutation.\n2298 \n2299         When the permutation is raised to the power of its\n2300         order it equals the identity permutation.\n2301 \n2302         Examples\n2303         ========\n2304 \n2305         >>> from sympy.combinatorics.permutations import Permutation\n2306         >>> from sympy.interactive import init_printing\n2307         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2308         >>> p = Permutation([3, 1, 5, 2, 4, 0])\n2309         >>> p.order()\n2310         4\n2311         >>> (p**(p.order()))\n2312         Permutation([], size=6)\n2313 \n2314         See Also\n2315         ========\n2316 \n2317         identity, cardinality, length, rank, size\n2318         \"\"\"\n2319 \n2320         return reduce(lcm, [len(cycle) for cycle in self.cyclic_form], 1)\n2321 \n2322     def length(self):\n2323         \"\"\"\n2324         Returns the number of integers moved by a permutation.\n2325 \n2326         Examples\n2327         ========\n2328 \n2329         >>> from sympy.combinatorics import Permutation\n2330         >>> Permutation([0, 3, 2, 1]).length()\n2331         2\n2332         >>> Permutation([[0, 1], [2, 3]]).length()\n2333         4\n2334 \n2335         See Also\n2336         ========\n2337 \n2338         min, max, support, cardinality, order, rank, size\n2339         \"\"\"\n2340 \n2341         return len(self.support())\n2342 \n2343     @property\n2344     def cycle_structure(self):\n2345         \"\"\"Return the cycle structure of the permutation as a dictionary\n2346         indicating the multiplicity of each cycle length.\n2347 \n2348         Examples\n2349         ========\n2350 \n2351         >>> from sympy.combinatorics import Permutation\n2352         >>> Permutation(3).cycle_structure\n2353         {1: 4}\n2354         >>> Permutation(0, 4, 3)(1, 2)(5, 6).cycle_structure\n2355         {2: 2, 3: 1}\n2356         \"\"\"\n2357         if self._cycle_structure:\n2358             rv = self._cycle_structure\n2359         else:\n2360             rv = defaultdict(int)\n2361             singletons = self.size\n2362             for c in self.cyclic_form:\n2363                 rv[len(c)] += 1\n2364                 singletons -= len(c)\n2365             if singletons:\n2366                 rv[1] = singletons\n2367             self._cycle_structure = rv\n2368         return dict(rv)  # make a copy\n2369 \n2370     @property\n2371     def cycles(self):\n2372         \"\"\"\n2373         Returns the number of cycles contained in the permutation\n2374         (including singletons).\n2375 \n2376         Examples\n2377         ========\n2378 \n2379         >>> from sympy.combinatorics import Permutation\n2380         >>> Permutation([0, 1, 2]).cycles\n2381         3\n2382         >>> Permutation([0, 1, 2]).full_cyclic_form\n2383         [[0], [1], [2]]\n2384         >>> Permutation(0, 1)(2, 3).cycles\n2385         2\n2386 \n2387         See Also\n2388         ========\n2389         sympy.functions.combinatorial.numbers.stirling\n2390         \"\"\"\n2391         return len(self.full_cyclic_form)\n2392 \n2393     def index(self):\n2394         \"\"\"\n2395         Returns the index of a permutation.\n2396 \n2397         The index of a permutation is the sum of all subscripts j such\n2398         that p[j] is greater than p[j+1].\n2399 \n2400         Examples\n2401         ========\n2402 \n2403         >>> from sympy.combinatorics.permutations import Permutation\n2404         >>> p = Permutation([3, 0, 2, 1, 4])\n2405         >>> p.index()\n2406         2\n2407         \"\"\"\n2408         a = self.array_form\n2409 \n2410         return sum([j for j in range(len(a) - 1) if a[j] > a[j + 1]])\n2411 \n2412     def runs(self):\n2413         \"\"\"\n2414         Returns the runs of a permutation.\n2415 \n2416         An ascending sequence in a permutation is called a run [5].\n2417 \n2418 \n2419         Examples\n2420         ========\n2421 \n2422         >>> from sympy.combinatorics.permutations import Permutation\n2423         >>> p = Permutation([2, 5, 7, 3, 6, 0, 1, 4, 8])\n2424         >>> p.runs()\n2425         [[2, 5, 7], [3, 6], [0, 1, 4, 8]]\n2426         >>> q = Permutation([1,3,2,0])\n2427         >>> q.runs()\n2428         [[1, 3], [2], [0]]\n2429         \"\"\"\n2430         return runs(self.array_form)\n2431 \n2432     def inversion_vector(self):\n2433         \"\"\"Return the inversion vector of the permutation.\n2434 \n2435         The inversion vector consists of elements whose value\n2436         indicates the number of elements in the permutation\n2437         that are lesser than it and lie on its right hand side.\n2438 \n2439         The inversion vector is the same as the Lehmer encoding of a\n2440         permutation.\n2441 \n2442         Examples\n2443         ========\n2444 \n2445         >>> from sympy.combinatorics.permutations import Permutation\n2446         >>> p = Permutation([4, 8, 0, 7, 1, 5, 3, 6, 2])\n2447         >>> p.inversion_vector()\n2448         [4, 7, 0, 5, 0, 2, 1, 1]\n2449         >>> p = Permutation([3, 2, 1, 0])\n2450         >>> p.inversion_vector()\n2451         [3, 2, 1]\n2452 \n2453         The inversion vector increases lexicographically with the rank\n2454         of the permutation, the -ith element cycling through 0..i.\n2455 \n2456         >>> p = Permutation(2)\n2457         >>> while p:\n2458         ...     print('%s %s %s' % (p, p.inversion_vector(), p.rank()))\n2459         ...     p = p.next_lex()\n2460         (2) [0, 0] 0\n2461         (1 2) [0, 1] 1\n2462         (2)(0 1) [1, 0] 2\n2463         (0 1 2) [1, 1] 3\n2464         (0 2 1) [2, 0] 4\n2465         (0 2) [2, 1] 5\n2466 \n2467         See Also\n2468         ========\n2469 \n2470         from_inversion_vector\n2471         \"\"\"\n2472         self_array_form = self.array_form\n2473         n = len(self_array_form)\n2474         inversion_vector = [0] * (n - 1)\n2475 \n2476         for i in range(n - 1):\n2477             val = 0\n2478             for j in range(i + 1, n):\n2479                 if self_array_form[j] < self_array_form[i]:\n2480                     val += 1\n2481             inversion_vector[i] = val\n2482         return inversion_vector\n2483 \n2484     def rank_trotterjohnson(self):\n2485         \"\"\"\n2486         Returns the Trotter Johnson rank, which we get from the minimal\n2487         change algorithm. See [4] section 2.4.\n2488 \n2489         Examples\n2490         ========\n2491 \n2492         >>> from sympy.combinatorics.permutations import Permutation\n2493         >>> p = Permutation([0, 1, 2, 3])\n2494         >>> p.rank_trotterjohnson()\n2495         0\n2496         >>> p = Permutation([0, 2, 1, 3])\n2497         >>> p.rank_trotterjohnson()\n2498         7\n2499 \n2500         See Also\n2501         ========\n2502 \n2503         unrank_trotterjohnson, next_trotterjohnson\n2504         \"\"\"\n2505         if self.array_form == [] or self.is_Identity:\n2506             return 0\n2507         if self.array_form == [1, 0]:\n2508             return 1\n2509         perm = self.array_form\n2510         n = self.size\n2511         rank = 0\n2512         for j in range(1, n):\n2513             k = 1\n2514             i = 0\n2515             while perm[i] != j:\n2516                 if perm[i] < j:\n2517                     k += 1\n2518                 i += 1\n2519             j1 = j + 1\n2520             if rank % 2 == 0:\n2521                 rank = j1*rank + j1 - k\n2522             else:\n2523                 rank = j1*rank + k - 1\n2524         return rank\n2525 \n2526     @classmethod\n2527     def unrank_trotterjohnson(cls, size, rank):\n2528         \"\"\"\n2529         Trotter Johnson permutation unranking. See [4] section 2.4.\n2530 \n2531         Examples\n2532         ========\n2533 \n2534         >>> from sympy.combinatorics.permutations import Permutation\n2535         >>> from sympy.interactive import init_printing\n2536         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2537         >>> Permutation.unrank_trotterjohnson(5, 10)\n2538         Permutation([0, 3, 1, 2, 4])\n2539 \n2540         See Also\n2541         ========\n2542 \n2543         rank_trotterjohnson, next_trotterjohnson\n2544         \"\"\"\n2545         perm = [0]*size\n2546         r2 = 0\n2547         n = ifac(size)\n2548         pj = 1\n2549         for j in range(2, size + 1):\n2550             pj *= j\n2551             r1 = (rank * pj) // n\n2552             k = r1 - j*r2\n2553             if r2 % 2 == 0:\n2554                 for i in range(j - 1, j - k - 1, -1):\n2555                     perm[i] = perm[i - 1]\n2556                 perm[j - k - 1] = j - 1\n2557             else:\n2558                 for i in range(j - 1, k, -1):\n2559                     perm[i] = perm[i - 1]\n2560                 perm[k] = j - 1\n2561             r2 = r1\n2562         return cls._af_new(perm)\n2563 \n2564     def next_trotterjohnson(self):\n2565         \"\"\"\n2566         Returns the next permutation in Trotter-Johnson order.\n2567         If self is the last permutation it returns None.\n2568         See [4] section 2.4. If it is desired to generate all such\n2569         permutations, they can be generated in order more quickly\n2570         with the ``generate_bell`` function.\n2571 \n2572         Examples\n2573         ========\n2574 \n2575         >>> from sympy.combinatorics.permutations import Permutation\n2576         >>> from sympy.interactive import init_printing\n2577         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2578         >>> p = Permutation([3, 0, 2, 1])\n2579         >>> p.rank_trotterjohnson()\n2580         4\n2581         >>> p = p.next_trotterjohnson(); p\n2582         Permutation([0, 3, 2, 1])\n2583         >>> p.rank_trotterjohnson()\n2584         5\n2585 \n2586         See Also\n2587         ========\n2588 \n2589         rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell\n2590         \"\"\"\n2591         pi = self.array_form[:]\n2592         n = len(pi)\n2593         st = 0\n2594         rho = pi[:]\n2595         done = False\n2596         m = n-1\n2597         while m > 0 and not done:\n2598             d = rho.index(m)\n2599             for i in range(d, m):\n2600                 rho[i] = rho[i + 1]\n2601             par = _af_parity(rho[:m])\n2602             if par == 1:\n2603                 if d == m:\n2604                     m -= 1\n2605                 else:\n2606                     pi[st + d], pi[st + d + 1] = pi[st + d + 1], pi[st + d]\n2607                     done = True\n2608             else:\n2609                 if d == 0:\n2610                     m -= 1\n2611                     st += 1\n2612                 else:\n2613                     pi[st + d], pi[st + d - 1] = pi[st + d - 1], pi[st + d]\n2614                     done = True\n2615         if m == 0:\n2616             return None\n2617         return self._af_new(pi)\n2618 \n2619     def get_precedence_matrix(self):\n2620         \"\"\"\n2621         Gets the precedence matrix. This is used for computing the\n2622         distance between two permutations.\n2623 \n2624         Examples\n2625         ========\n2626 \n2627         >>> from sympy.combinatorics.permutations import Permutation\n2628         >>> from sympy.interactive import init_printing\n2629         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2630         >>> p = Permutation.josephus(3, 6, 1)\n2631         >>> p\n2632         Permutation([2, 5, 3, 1, 4, 0])\n2633         >>> p.get_precedence_matrix()\n2634         Matrix([\n2635         [0, 0, 0, 0, 0, 0],\n2636         [1, 0, 0, 0, 1, 0],\n2637         [1, 1, 0, 1, 1, 1],\n2638         [1, 1, 0, 0, 1, 0],\n2639         [1, 0, 0, 0, 0, 0],\n2640         [1, 1, 0, 1, 1, 0]])\n2641 \n2642         See Also\n2643         ========\n2644 \n2645         get_precedence_distance, get_adjacency_matrix, get_adjacency_distance\n2646         \"\"\"\n2647         m = zeros(self.size)\n2648         perm = self.array_form\n2649         for i in range(m.rows):\n2650             for j in range(i + 1, m.cols):\n2651                 m[perm[i], perm[j]] = 1\n2652         return m\n2653 \n2654     def get_precedence_distance(self, other):\n2655         \"\"\"\n2656         Computes the precedence distance between two permutations.\n2657 \n2658         Explanation\n2659         ===========\n2660 \n2661         Suppose p and p' represent n jobs. The precedence metric\n2662         counts the number of times a job j is preceded by job i\n2663         in both p and p'. This metric is commutative.\n2664 \n2665         Examples\n2666         ========\n2667 \n2668         >>> from sympy.combinatorics.permutations import Permutation\n2669         >>> p = Permutation([2, 0, 4, 3, 1])\n2670         >>> q = Permutation([3, 1, 2, 4, 0])\n2671         >>> p.get_precedence_distance(q)\n2672         7\n2673         >>> q.get_precedence_distance(p)\n2674         7\n2675 \n2676         See Also\n2677         ========\n2678 \n2679         get_precedence_matrix, get_adjacency_matrix, get_adjacency_distance\n2680         \"\"\"\n2681         if self.size != other.size:\n2682             raise ValueError(\"The permutations must be of equal size.\")\n2683         self_prec_mat = self.get_precedence_matrix()\n2684         other_prec_mat = other.get_precedence_matrix()\n2685         n_prec = 0\n2686         for i in range(self.size):\n2687             for j in range(self.size):\n2688                 if i == j:\n2689                     continue\n2690                 if self_prec_mat[i, j] * other_prec_mat[i, j] == 1:\n2691                     n_prec += 1\n2692         d = self.size * (self.size - 1)//2 - n_prec\n2693         return d\n2694 \n2695     def get_adjacency_matrix(self):\n2696         \"\"\"\n2697         Computes the adjacency matrix of a permutation.\n2698 \n2699         Explanation\n2700         ===========\n2701 \n2702         If job i is adjacent to job j in a permutation p\n2703         then we set m[i, j] = 1 where m is the adjacency\n2704         matrix of p.\n2705 \n2706         Examples\n2707         ========\n2708 \n2709         >>> from sympy.combinatorics.permutations import Permutation\n2710         >>> p = Permutation.josephus(3, 6, 1)\n2711         >>> p.get_adjacency_matrix()\n2712         Matrix([\n2713         [0, 0, 0, 0, 0, 0],\n2714         [0, 0, 0, 0, 1, 0],\n2715         [0, 0, 0, 0, 0, 1],\n2716         [0, 1, 0, 0, 0, 0],\n2717         [1, 0, 0, 0, 0, 0],\n2718         [0, 0, 0, 1, 0, 0]])\n2719         >>> q = Permutation([0, 1, 2, 3])\n2720         >>> q.get_adjacency_matrix()\n2721         Matrix([\n2722         [0, 1, 0, 0],\n2723         [0, 0, 1, 0],\n2724         [0, 0, 0, 1],\n2725         [0, 0, 0, 0]])\n2726 \n2727         See Also\n2728         ========\n2729 \n2730         get_precedence_matrix, get_precedence_distance, get_adjacency_distance\n2731         \"\"\"\n2732         m = zeros(self.size)\n2733         perm = self.array_form\n2734         for i in range(self.size - 1):\n2735             m[perm[i], perm[i + 1]] = 1\n2736         return m\n2737 \n2738     def get_adjacency_distance(self, other):\n2739         \"\"\"\n2740         Computes the adjacency distance between two permutations.\n2741 \n2742         Explanation\n2743         ===========\n2744 \n2745         This metric counts the number of times a pair i,j of jobs is\n2746         adjacent in both p and p'. If n_adj is this quantity then\n2747         the adjacency distance is n - n_adj - 1 [1]\n2748 \n2749         [1] Reeves, Colin R. Landscapes, Operators and Heuristic search, Annals\n2750         of Operational Research, 86, pp 473-490. (1999)\n2751 \n2752 \n2753         Examples\n2754         ========\n2755 \n2756         >>> from sympy.combinatorics.permutations import Permutation\n2757         >>> p = Permutation([0, 3, 1, 2, 4])\n2758         >>> q = Permutation.josephus(4, 5, 2)\n2759         >>> p.get_adjacency_distance(q)\n2760         3\n2761         >>> r = Permutation([0, 2, 1, 4, 3])\n2762         >>> p.get_adjacency_distance(r)\n2763         4\n2764 \n2765         See Also\n2766         ========\n2767 \n2768         get_precedence_matrix, get_precedence_distance, get_adjacency_matrix\n2769         \"\"\"\n2770         if self.size != other.size:\n2771             raise ValueError(\"The permutations must be of the same size.\")\n2772         self_adj_mat = self.get_adjacency_matrix()\n2773         other_adj_mat = other.get_adjacency_matrix()\n2774         n_adj = 0\n2775         for i in range(self.size):\n2776             for j in range(self.size):\n2777                 if i == j:\n2778                     continue\n2779                 if self_adj_mat[i, j] * other_adj_mat[i, j] == 1:\n2780                     n_adj += 1\n2781         d = self.size - n_adj - 1\n2782         return d\n2783 \n2784     def get_positional_distance(self, other):\n2785         \"\"\"\n2786         Computes the positional distance between two permutations.\n2787 \n2788         Examples\n2789         ========\n2790 \n2791         >>> from sympy.combinatorics.permutations import Permutation\n2792         >>> p = Permutation([0, 3, 1, 2, 4])\n2793         >>> q = Permutation.josephus(4, 5, 2)\n2794         >>> r = Permutation([3, 1, 4, 0, 2])\n2795         >>> p.get_positional_distance(q)\n2796         12\n2797         >>> p.get_positional_distance(r)\n2798         12\n2799 \n2800         See Also\n2801         ========\n2802 \n2803         get_precedence_distance, get_adjacency_distance\n2804         \"\"\"\n2805         a = self.array_form\n2806         b = other.array_form\n2807         if len(a) != len(b):\n2808             raise ValueError(\"The permutations must be of the same size.\")\n2809         return sum([abs(a[i] - b[i]) for i in range(len(a))])\n2810 \n2811     @classmethod\n2812     def josephus(cls, m, n, s=1):\n2813         \"\"\"Return as a permutation the shuffling of range(n) using the Josephus\n2814         scheme in which every m-th item is selected until all have been chosen.\n2815         The returned permutation has elements listed by the order in which they\n2816         were selected.\n2817 \n2818         The parameter ``s`` stops the selection process when there are ``s``\n2819         items remaining and these are selected by continuing the selection,\n2820         counting by 1 rather than by ``m``.\n2821 \n2822         Consider selecting every 3rd item from 6 until only 2 remain::\n2823 \n2824             choices    chosen\n2825             ========   ======\n2826               012345\n2827               01 345   2\n2828               01 34    25\n2829               01  4    253\n2830               0   4    2531\n2831               0        25314\n2832                        253140\n2833 \n2834         Examples\n2835         ========\n2836 \n2837         >>> from sympy.combinatorics import Permutation\n2838         >>> Permutation.josephus(3, 6, 2).array_form\n2839         [2, 5, 3, 1, 4, 0]\n2840 \n2841         References\n2842         ==========\n2843 \n2844         .. [1] https://en.wikipedia.org/wiki/Flavius_Josephus\n2845         .. [2] https://en.wikipedia.org/wiki/Josephus_problem\n2846         .. [3] http://www.wou.edu/~burtonl/josephus.html\n2847 \n2848         \"\"\"\n2849         from collections import deque\n2850         m -= 1\n2851         Q = deque(list(range(n)))\n2852         perm = []\n2853         while len(Q) > max(s, 1):\n2854             for dp in range(m):\n2855                 Q.append(Q.popleft())\n2856             perm.append(Q.popleft())\n2857         perm.extend(list(Q))\n2858         return cls(perm)\n2859 \n2860     @classmethod\n2861     def from_inversion_vector(cls, inversion):\n2862         \"\"\"\n2863         Calculates the permutation from the inversion vector.\n2864 \n2865         Examples\n2866         ========\n2867 \n2868         >>> from sympy.combinatorics.permutations import Permutation\n2869         >>> from sympy.interactive import init_printing\n2870         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2871         >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])\n2872         Permutation([3, 2, 1, 0, 4, 5])\n2873 \n2874         \"\"\"\n2875         size = len(inversion)\n2876         N = list(range(size + 1))\n2877         perm = []\n2878         try:\n2879             for k in range(size):\n2880                 val = N[inversion[k]]\n2881                 perm.append(val)\n2882                 N.remove(val)\n2883         except IndexError:\n2884             raise ValueError(\"The inversion vector is not valid.\")\n2885         perm.extend(N)\n2886         return cls._af_new(perm)\n2887 \n2888     @classmethod\n2889     def random(cls, n):\n2890         \"\"\"\n2891         Generates a random permutation of length ``n``.\n2892 \n2893         Uses the underlying Python pseudo-random number generator.\n2894 \n2895         Examples\n2896         ========\n2897 \n2898         >>> from sympy.combinatorics.permutations import Permutation\n2899         >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))\n2900         True\n2901 \n2902         \"\"\"\n2903         perm_array = list(range(n))\n2904         random.shuffle(perm_array)\n2905         return cls._af_new(perm_array)\n2906 \n2907     @classmethod\n2908     def unrank_lex(cls, size, rank):\n2909         \"\"\"\n2910         Lexicographic permutation unranking.\n2911 \n2912         Examples\n2913         ========\n2914 \n2915         >>> from sympy.combinatorics.permutations import Permutation\n2916         >>> from sympy.interactive import init_printing\n2917         >>> init_printing(perm_cyclic=False, pretty_print=False)\n2918         >>> a = Permutation.unrank_lex(5, 10)\n2919         >>> a.rank()\n2920         10\n2921         >>> a\n2922         Permutation([0, 2, 4, 1, 3])\n2923 \n2924         See Also\n2925         ========\n2926 \n2927         rank, next_lex\n2928         \"\"\"\n2929         perm_array = [0] * size\n2930         psize = 1\n2931         for i in range(size):\n2932             new_psize = psize*(i + 1)\n2933             d = (rank % new_psize) // psize\n2934             rank -= d*psize\n2935             perm_array[size - i - 1] = d\n2936             for j in range(size - i, size):\n2937                 if perm_array[j] > d - 1:\n2938                     perm_array[j] += 1\n2939             psize = new_psize\n2940         return cls._af_new(perm_array)\n2941 \n2942     def resize(self, n):\n2943         \"\"\"Resize the permutation to the new size ``n``.\n2944 \n2945         Parameters\n2946         ==========\n2947 \n2948         n : int\n2949             The new size of the permutation.\n2950 \n2951         Raises\n2952         ======\n2953 \n2954         ValueError\n2955             If the permutation cannot be resized to the given size.\n2956             This may only happen when resized to a smaller size than\n2957             the original.\n2958 \n2959         Examples\n2960         ========\n2961 \n2962         >>> from sympy.combinatorics.permutations import Permutation\n2963 \n2964         Increasing the size of a permutation:\n2965 \n2966         >>> p = Permutation(0, 1, 2)\n2967         >>> p = p.resize(5)\n2968         >>> p\n2969         (4)(0 1 2)\n2970 \n2971         Decreasing the size of the permutation:\n2972 \n2973         >>> p = p.resize(4)\n2974         >>> p\n2975         (3)(0 1 2)\n2976 \n2977         If resizing to the specific size breaks the cycles:\n2978 \n2979         >>> p.resize(2)\n2980         Traceback (most recent call last):\n2981         ...\n2982         ValueError: The permutation can not be resized to 2 because the\n2983         cycle (0, 1, 2) may break.\n2984         \"\"\"\n2985         aform = self.array_form\n2986         l = len(aform)\n2987         if n > l:\n2988             aform += list(range(l, n))\n2989             return Permutation._af_new(aform)\n2990 \n2991         elif n < l:\n2992             cyclic_form = self.full_cyclic_form\n2993             new_cyclic_form = []\n2994             for cycle in cyclic_form:\n2995                 cycle_min = min(cycle)\n2996                 cycle_max = max(cycle)\n2997                 if cycle_min <= n-1:\n2998                     if cycle_max > n-1:\n2999                         raise ValueError(\n3000                             \"The permutation can not be resized to {} \"\n3001                             \"because the cycle {} may break.\"\n3002                             .format(n, tuple(cycle)))\n3003 \n3004                     new_cyclic_form.append(cycle)\n3005             return Permutation(new_cyclic_form)\n3006 \n3007         return self\n3008 \n3009     # XXX Deprecated flag\n3010     print_cyclic = None\n",
        "intended_behavior": "The `__repr__` method might need modifications, and a `__str__` method could be added or modified to make the string representation of `Permutation` instances more user-friendly and less verbose, clearly conveying the permutation in a concise and understandable way."
    }
]