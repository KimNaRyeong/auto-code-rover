2025-10-18 07:36:35.515 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 07:36:40.698 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=494, output_tokens=12, cost=0.005300
2025-10-18 07:36:55.128 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=674, output_tokens=693, cost=0.027530
2025-10-18 07:36:56.392 | INFO     | registered non reproducing test 0
2025-10-18 07:37:07.918 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1831, output_tokens=545, cost=0.034660
2025-10-18 07:37:09.115 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:37:16.467 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=795, output_tokens=338, cost=0.018090
2025-10-18 07:37:16.474 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:37:19.598 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=75, cost=0.009170
2025-10-18 07:37:19.600 | DEBUG    | Extracted a valid json.
2025-10-18 07:37:19.600 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Mul\")",
        "search_method(\"extract_multiplicatively\")",
        "search_method(\"primitive\")",
        "search_code_in_file(\"Mul(2, -x, evaluate=False).extract_multiplicatively(-2)\", \"core/expr.py\")"
    ],
    "bug_locations": []
}
2025-10-18 07:37:19.679 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 07:37:19.680 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 07:37:38.412 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4315, output_tokens=779, cost=0.066520
2025-10-18 07:37:38.427 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:37:45.174 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5310, output_tokens=272, cost=0.061260
2025-10-18 07:37:45.181 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:37:52.536 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=626, output_tokens=258, cost=0.014000
2025-10-18 07:37:52.537 | DEBUG    | Extracted a valid json.
2025-10-18 07:37:52.537 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/expr.py",
            "class": "Expr",
            "method": "extract_multiplicatively",
            "intended_behavior": "The issue appears to arise because the method cannot correctly handle the extraction when faced with expressions that are assembled using Mul with evaluate=False, particularly when trying to extract a factor from a product that is negated or involves negation. The intended behavior is for extract_multiplicatively to: - Properly recognize and facilitate the extraction of multiplicatively inverse elements especially in cases where the expression and the factor share a negation, such as attempting to extract -2 from (-2*x - 4*y - 8). - Preserve existing functionality for all other use cases, ensuring no regression or unintended side effects on the current capabilities of the method. This involves possibly addressing how non-evaluated Mul expressions are treated by the method, ensuring that factors can be extracted whether or not the expression has been evaluated. - Consider enhancing the method to handle cases where the common factor is spread across terms in the expression, possibly by improving the logic that interacts with primitive or the handling of evaluated vs. non-evaluated expressions."
        }
    ]
}
2025-10-18 07:37:52.550 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/expr.py</file>
<class>Expr</class>
<method>extract_multiplicatively</method>
<code>
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)

</code><intended_behavior>The issue appears to arise because the method cannot correctly handle the extraction when faced with expressions that are assembled using Mul with evaluate=False, particularly when trying to extract a factor from a product that is negated or involves negation. The intended behavior is for extract_multiplicatively to: - Properly recognize and facilitate the extraction of multiplicatively inverse elements especially in cases where the expression and the factor share a negation, such as attempting to extract -2 from (-2*x - 4*y - 8). - Preserve existing functionality for all other use cases, ensuring no regression or unintended side effects on the current capabilities of the method. This involves possibly addressing how non-evaluated Mul expressions are treated by the method, ensuring that factors can be extracted whether or not the expression has been evaluated. - Consider enhancing the method to handle cases where the common factor is spread across terms in the expression, possibly by improving the logic that interacts with primitive or the handling of evaluated vs. non-evaluated expressions.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     @property
33     def _diff_wrt(self):
34         """Is it allowed to take derivative wrt to this instance.
35 
36         This determines if it is allowed to take derivatives wrt this object.
37         Subclasses such as Symbol, Function and Derivative should return True
38         to enable derivatives wrt them. The implementation in Derivative
39         separates the Symbol and non-Symbol _diff_wrt=True variables and
40         temporarily converts the non-Symbol vars in Symbols when performing
41         the differentiation.
42 
43         Note, see the docstring of Derivative for how this should work
44         mathematically. In particular, note that expr.subs(yourclass, Symbol)
45         should be well-defined on a structural level, or this will lead to
46         inconsistent results.
47 
48         Examples
49         ========
50 
51         >>> from sympy import Expr
52         >>> e = Expr()
53         >>> e._diff_wrt
54         False
55         >>> class MyClass(Expr):
56         ...     _diff_wrt = True
57         ...
58         >>> (2*MyClass()).diff(MyClass())
59         2
60         """
61         return False
62 
63     @cacheit
64     def sort_key(self, order=None):
65 
66         coeff, expr = self.as_coeff_Mul()
67 
68         if expr.is_Pow:
69             expr, exp = expr.args
70         else:
71             expr, exp = expr, S.One
72 
73         if expr.is_Dummy:
74             args = (expr.sort_key(),)
75         elif expr.is_Atom:
76             args = (str(expr),)
77         else:
78             if expr.is_Add:
79                 args = expr.as_ordered_terms(order=order)
80             elif expr.is_Mul:
81                 args = expr.as_ordered_factors(order=order)
82             else:
83                 args = expr.args
84 
85             args = tuple(
86                 [ default_sort_key(arg, order=order) for arg in args ])
87 
88         args = (len(args), tuple(args))
89         exp = exp.sort_key(order=order)
90 
91         return expr.class_key(), args, exp, coeff
92 
93     # ***************
94     # * Arithmetics *
95     # ***************
96     # Expr and its sublcasses use _op_priority to determine which object
97     # passed to a binary special method (__mul__, etc.) will handle the
98     # operation. In general, the 'call_highest_priority' decorator will choose
99     # the object with the highest _op_priority to handle the call.
100     # Custom subclasses that want to define their own binary special methods
101     # should set an _op_priority value that is higher than the default.
102     #
103     # **NOTE**:
104     # This is a temporary fix, and will eventually be replaced with
105     # something better and more powerful.  See issue 5510.
106     _op_priority = 10.0
107 
108     def __pos__(self):
109         return self
110 
111     def __neg__(self):
112         return Mul(S.NegativeOne, self)
113 
114     def __abs__(self):
115         from sympy import Abs
116         return Abs(self)
117 
118     @_sympifyit('other', NotImplemented)
119     @call_highest_priority('__radd__')
120     def __add__(self, other):
121         return Add(self, other)
122 
123     @_sympifyit('other', NotImplemented)
124     @call_highest_priority('__add__')
125     def __radd__(self, other):
126         return Add(other, self)
127 
128     @_sympifyit('other', NotImplemented)
129     @call_highest_priority('__rsub__')
130     def __sub__(self, other):
131         return Add(self, -other)
132 
133     @_sympifyit('other', NotImplemented)
134     @call_highest_priority('__sub__')
135     def __rsub__(self, other):
136         return Add(other, -self)
137 
138     @_sympifyit('other', NotImplemented)
139     @call_highest_priority('__rmul__')
140     def __mul__(self, other):
141         return Mul(self, other)
142 
143     @_sympifyit('other', NotImplemented)
144     @call_highest_priority('__mul__')
145     def __rmul__(self, other):
146         return Mul(other, self)
147 
148     @_sympifyit('other', NotImplemented)
149     @call_highest_priority('__rpow__')
150     def __pow__(self, other):
151         return Pow(self, other)
152 
153     @_sympifyit('other', NotImplemented)
154     @call_highest_priority('__pow__')
155     def __rpow__(self, other):
156         return Pow(other, self)
157 
158     @_sympifyit('other', NotImplemented)
159     @call_highest_priority('__rdiv__')
160     def __div__(self, other):
161         return Mul(self, Pow(other, S.NegativeOne))
162 
163     @_sympifyit('other', NotImplemented)
164     @call_highest_priority('__div__')
165     def __rdiv__(self, other):
166         return Mul(other, Pow(self, S.NegativeOne))
167 
168     __truediv__ = __div__
169     __rtruediv__ = __rdiv__
170 
171     @_sympifyit('other', NotImplemented)
172     @call_highest_priority('__rmod__')
173     def __mod__(self, other):
174         return Mod(self, other)
175 
176     @_sympifyit('other', NotImplemented)
177     @call_highest_priority('__mod__')
178     def __rmod__(self, other):
179         return Mod(other, self)
180 
181     @_sympifyit('other', NotImplemented)
182     @call_highest_priority('__rfloordiv__')
183     def __floordiv__(self, other):
184         from sympy.functions.elementary.integers import floor
185         return floor(self / other)
186 
187     @_sympifyit('other', NotImplemented)
188     @call_highest_priority('__floordiv__')
189     def __rfloordiv__(self, other):
190         from sympy.functions.elementary.integers import floor
191         return floor(self / other)
192 
193     def __int__(self):
194         # Although we only need to round to the units position, we'll
195         # get one more digit so the extra testing below can be avoided
196         # unless the rounded value rounded to an integer, e.g. if an
197         # expression were equal to 1.9 and we rounded to the unit position
198         # we would get a 2 and would not know if this rounded up or not
199         # without doing a test (as done below). But if we keep an extra
200         # digit we know that 1.9 is not the same as 1 and there is no
201         # need for further testing: our int value is correct. If the value
202         # were 1.99, however, this would round to 2.0 and our int value is
203         # off by one. So...if our round value is the same as the int value
204         # (regardless of how much extra work we do to calculate extra decimal
205         # places) we need to test whether we are off by one.
206         from sympy import Dummy
207         if not self.is_number:
208             raise TypeError("can't convert symbols to int")
209         r = self.round(2)
210         if not r.is_Number:
211             raise TypeError("can't convert complex to int")
212         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
213             raise TypeError("can't convert %s to int" % r)
214         i = int(r)
215         if not i:
216             return 0
217         # off-by-one check
218         if i == r and not (self - i).equals(0):
219             isign = 1 if i > 0 else -1
220             x = Dummy()
221             # in the following (self - i).evalf(2) will not always work while
222             # (self - r).evalf(2) and the use of subs does; if the test that
223             # was added when this comment was added passes, it might be safe
224             # to simply use sign to compute this rather than doing this by hand:
225             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
226             if diff_sign != isign:
227                 i -= isign
228         return i
229     __long__ = __int__
230 
231     def __float__(self):
232         # Don't bother testing if it's a number; if it's not this is going
233         # to fail, and if it is we still need to check that it evalf'ed to
234         # a number.
235         result = self.evalf()
236         if result.is_Number:
237             return float(result)
238         if result.is_number and result.as_real_imag()[1]:
239             raise TypeError("can't convert complex to float")
240         raise TypeError("can't convert expression to float")
241 
242     def __complex__(self):
243         result = self.evalf()
244         re, im = result.as_real_imag()
245         return complex(float(re), float(im))
246 
247     def __ge__(self, other):
248         from sympy import GreaterThan
249         try:
250             other = _sympify(other)
251         except SympifyError:
252             raise TypeError("Invalid comparison %s >= %s" % (self, other))
253         for me in (self, other):
254             if (me.is_complex and me.is_real is False) or \
255                     me.has(S.ComplexInfinity):
256                 raise TypeError("Invalid comparison of complex %s" % me)
257             if me is S.NaN:
258                 raise TypeError("Invalid NaN comparison")
259         if self.is_real or other.is_real:
260             dif = self - other
261             if dif.is_nonnegative is not None and \
262                     dif.is_nonnegative is not dif.is_negative:
263                 return sympify(dif.is_nonnegative)
264         return GreaterThan(self, other, evaluate=False)
265 
266     def __le__(self, other):
267         from sympy import LessThan
268         try:
269             other = _sympify(other)
270         except SympifyError:
271             raise TypeError("Invalid comparison %s <= %s" % (self, other))
272         for me in (self, other):
273             if (me.is_complex and me.is_real is False) or \
274                     me.has(S.ComplexInfinity):
275                 raise TypeError("Invalid comparison of complex %s" % me)
276             if me is S.NaN:
277                 raise TypeError("Invalid NaN comparison")
278         if self.is_real or other.is_real:
279             dif = self - other
280             if dif.is_nonpositive is not None and \
281                     dif.is_nonpositive is not dif.is_positive:
282                 return sympify(dif.is_nonpositive)
283         return LessThan(self, other, evaluate=False)
284 
285     def __gt__(self, other):
286         from sympy import StrictGreaterThan
287         try:
288             other = _sympify(other)
289         except SympifyError:
290             raise TypeError("Invalid comparison %s > %s" % (self, other))
291         for me in (self, other):
292             if (me.is_complex and me.is_real is False) or \
293                     me.has(S.ComplexInfinity):
294                 raise TypeError("Invalid comparison of complex %s" % me)
295             if me is S.NaN:
296                 raise TypeError("Invalid NaN comparison")
297         if self.is_real or other.is_real:
298             dif = self - other
299             if dif.is_positive is not None and \
300                     dif.is_positive is not dif.is_nonpositive:
301                 return sympify(dif.is_positive)
302         return StrictGreaterThan(self, other, evaluate=False)
303 
304     def __lt__(self, other):
305         from sympy import StrictLessThan
306         try:
307             other = _sympify(other)
308         except SympifyError:
309             raise TypeError("Invalid comparison %s < %s" % (self, other))
310         for me in (self, other):
311             if (me.is_complex and me.is_real is False) or \
312                     me.has(S.ComplexInfinity):
313                 raise TypeError("Invalid comparison of complex %s" % me)
314             if me is S.NaN:
315                 raise TypeError("Invalid NaN comparison")
316         if self.is_real or other.is_real:
317             dif = self - other
318             if dif.is_negative is not None and \
319                     dif.is_negative is not dif.is_nonnegative:
320                 return sympify(dif.is_negative)
321         return StrictLessThan(self, other, evaluate=False)
322 
323     @staticmethod
324     def _from_mpmath(x, prec):
325         from sympy import Float
326         if hasattr(x, "_mpf_"):
327             return Float._new(x._mpf_, prec)
328         elif hasattr(x, "_mpc_"):
329             re, im = x._mpc_
330             re = Float._new(re, prec)
331             im = Float._new(im, prec)*S.ImaginaryUnit
332             return re + im
333         else:
334             raise TypeError("expected mpmath number (mpf or mpc)")
335 
336     @property
337     def is_number(self):
338         """Returns True if 'self' has no free symbols.
339         It will be faster than `if not self.free_symbols`, however, since
340         `is_number` will fail as soon as it hits a free symbol.
341 
342         Examples
343         ========
344 
345         >>> from sympy import log, Integral
346         >>> from sympy.abc import x
347 
348         >>> x.is_number
349         False
350         >>> (2*x).is_number
351         False
352         >>> (2 + log(2)).is_number
353         True
354         >>> (2 + Integral(2, x)).is_number
355         False
356         >>> (2 + Integral(2, (x, 1, 2))).is_number
357         True
358 
359         """
360         return all(obj.is_number for obj in self.args)
361 
362     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
363         """Return self evaluated, if possible, replacing free symbols with
364         random complex values, if necessary.
365 
366         The random complex value for each free symbol is generated
367         by the random_complex_number routine giving real and imaginary
368         parts in the range given by the re_min, re_max, im_min, and im_max
369         values. The returned value is evaluated to a precision of n
370         (if given) else the maximum of 15 and the precision needed
371         to get more than 1 digit of precision. If the expression
372         could not be evaluated to a number, or could not be evaluated
373         to more than 1 digit of precision, then None is returned.
374 
375         Examples
376         ========
377 
378         >>> from sympy import sqrt
379         >>> from sympy.abc import x, y
380         >>> x._random()                         # doctest: +SKIP
381         0.0392918155679172 + 0.916050214307199*I
382         >>> x._random(2)                        # doctest: +SKIP
383         -0.77 - 0.87*I
384         >>> (x + y/2)._random(2)                # doctest: +SKIP
385         -0.57 + 0.16*I
386         >>> sqrt(2)._random(2)
387         1.4
388 
389         See Also
390         ========
391 
392         sympy.utilities.randtest.random_complex_number
393         """
394 
395         free = self.free_symbols
396         prec = 1
397         if free:
398             from sympy.utilities.randtest import random_complex_number
399             a, c, b, d = re_min, re_max, im_min, im_max
400             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
401                            for zi in free])))
402             try:
403                 nmag = abs(self.evalf(2, subs=reps))
404             except (ValueError, TypeError):
405                 # if an out of range value resulted in evalf problems
406                 # then return None -- XXX is there a way to know how to
407                 # select a good random number for a given expression?
408                 # e.g. when calculating n! negative values for n should not
409                 # be used
410                 return None
411         else:
412             reps = {}
413             nmag = abs(self.evalf(2))
414 
415         if not hasattr(nmag, '_prec'):
416             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
417             return None
418 
419         if nmag._prec == 1:
420             # increase the precision up to the default maximum
421             # precision to see if we can get any significance
422 
423             from mpmath.libmp.libintmath import giant_steps
424             from sympy.core.evalf import DEFAULT_MAXPREC as target
425 
426             # evaluate
427             for prec in giant_steps(2, target):
428                 nmag = abs(self.evalf(prec, subs=reps))
429                 if nmag._prec != 1:
430                     break
431 
432         if nmag._prec != 1:
433             if n is None:
434                 n = max(prec, 15)
435             return self.evalf(n, subs=reps)
436 
437         # never got any significance
438         return None
439 
440     def is_constant(self, *wrt, **flags):
441         """Return True if self is constant, False if not, or None if
442         the constancy could not be determined conclusively.
443 
444         If an expression has no free symbols then it is a constant. If
445         there are free symbols it is possible that the expression is a
446         constant, perhaps (but not necessarily) zero. To test such
447         expressions, two strategies are tried:
448 
449         1) numerical evaluation at two random points. If two such evaluations
450         give two different values and the values have a precision greater than
451         1 then self is not constant. If the evaluations agree or could not be
452         obtained with any precision, no decision is made. The numerical testing
453         is done only if ``wrt`` is different than the free symbols.
454 
455         2) differentiation with respect to variables in 'wrt' (or all free
456         symbols if omitted) to see if the expression is constant or not. This
457         will not always lead to an expression that is zero even though an
458         expression is constant (see added test in test_expr.py). If
459         all derivatives are zero then self is constant with respect to the
460         given symbols.
461 
462         If neither evaluation nor differentiation can prove the expression is
463         constant, None is returned unless two numerical values happened to be
464         the same and the flag ``failing_number`` is True -- in that case the
465         numerical value will be returned.
466 
467         If flag simplify=False is passed, self will not be simplified;
468         the default is True since self should be simplified before testing.
469 
470         Examples
471         ========
472 
473         >>> from sympy import cos, sin, Sum, S, pi
474         >>> from sympy.abc import a, n, x, y
475         >>> x.is_constant()
476         False
477         >>> S(2).is_constant()
478         True
479         >>> Sum(x, (x, 1, 10)).is_constant()
480         True
481         >>> Sum(x, (x, 1, n)).is_constant()
482         False
483         >>> Sum(x, (x, 1, n)).is_constant(y)
484         True
485         >>> Sum(x, (x, 1, n)).is_constant(n)
486         False
487         >>> Sum(x, (x, 1, n)).is_constant(x)
488         True
489         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
490         >>> eq.is_constant()
491         True
492         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
493         True
494 
495         >>> (0**x).is_constant()
496         False
497         >>> x.is_constant()
498         False
499         >>> (x**x).is_constant()
500         False
501         >>> one = cos(x)**2 + sin(x)**2
502         >>> one.is_constant()
503         True
504         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
505         True
506         """
507 
508         simplify = flags.get('simplify', True)
509 
510         # Except for expressions that contain units, only one of these should
511         # be necessary since if something is
512         # known to be a number it should also know that there are no
513         # free symbols. But is_number quits as soon as it hits a non-number
514         # whereas free_symbols goes until all free symbols have been collected,
515         # thus is_number should be faster. But a double check on free symbols
516         # is made just in case there is a discrepancy between the two.
517         free = self.free_symbols
518         if self.is_number or not free:
519             # if the following assertion fails then that object's free_symbols
520             # method needs attention: if an expression is a number it cannot
521             # have free symbols
522             assert not free
523             return True
524 
525         # if we are only interested in some symbols and they are not in the
526         # free symbols then this expression is constant wrt those symbols
527         wrt = set(wrt)
528         if wrt and not wrt & free:
529             return True
530         wrt = wrt or free
531 
532         # simplify unless this has already been done
533         expr = self
534         if simplify:
535             expr = expr.simplify()
536 
537         # is_zero should be a quick assumptions check; it can be wrong for
538         # numbers (see test_is_not_constant test), giving False when it
539         # shouldn't, but hopefully it will never give True unless it is sure.
540         if expr.is_zero:
541             return True
542 
543         # try numerical evaluation to see if we get two different values
544         failing_number = None
545         if wrt == free:
546             # try 0 (for a) and 1 (for b)
547             try:
548                 a = expr.subs(list(zip(free, [0]*len(free))),
549                     simultaneous=True)
550                 if a is S.NaN:
551                     # evaluation may succeed when substitution fails
552                     a = expr._random(None, 0, 0, 0, 0)
553             except ZeroDivisionError:
554                 a = None
555             if a is not None and a is not S.NaN:
556                 try:
557                     b = expr.subs(list(zip(free, [1]*len(free))),
558                         simultaneous=True)
559                     if b is S.NaN:
560                         # evaluation may succeed when substitution fails
561                         b = expr._random(None, 1, 0, 1, 0)
562                 except ZeroDivisionError:
563                     b = None
564                 if b is not None and b is not S.NaN and b.equals(a) is False:
565                     return False
566                 # try random real
567                 b = expr._random(None, -1, 0, 1, 0)
568                 if b is not None and b is not S.NaN and b.equals(a) is False:
569                     return False
570                 # try random complex
571                 b = expr._random()
572                 if b is not None and b is not S.NaN:
573                     if b.equals(a) is False:
574                         return False
575                     failing_number = a if a.is_number else b
576 
577         # now we will test each wrt symbol (or all free symbols) to see if the
578         # expression depends on them or not using differentiation. This is
579         # not sufficient for all expressions, however, so we don't return
580         # False if we get a derivative other than 0 with free symbols.
581         for w in wrt:
582             deriv = expr.diff(w)
583             if simplify:
584                 deriv = deriv.simplify()
585             if deriv != 0:
586                 if not (pure_complex(deriv, or_real=True)):
587                     if flags.get('failing_number', False):
588                         return failing_number
589                     elif deriv.free_symbols:
590                         # dead line provided _random returns None in such cases
591                         return None
592                 return False
593         return True
594 
595     def equals(self, other, failing_expression=False):
596         """Return True if self == other, False if it doesn't, or None. If
597         failing_expression is True then the expression which did not simplify
598         to a 0 will be returned instead of None.
599 
600         If ``self`` is a Number (or complex number) that is not zero, then
601         the result is False.
602 
603         If ``self`` is a number and has not evaluated to zero, evalf will be
604         used to test whether the expression evaluates to zero. If it does so
605         and the result has significance (i.e. the precision is either -1, for
606         a Rational result, or is greater than 1) then the evalf value will be
607         used to return True or False.
608 
609         """
610         from sympy.simplify.simplify import nsimplify, simplify
611         from sympy.solvers.solveset import solveset
612         from sympy.polys.polyerrors import NotAlgebraic
613         from sympy.polys.numberfields import minimal_polynomial
614 
615         other = sympify(other)
616         if self == other:
617             return True
618 
619         # they aren't the same so see if we can make the difference 0;
620         # don't worry about doing simplification steps one at a time
621         # because if the expression ever goes to 0 then the subsequent
622         # simplification steps that are done will be very fast.
623         diff = factor_terms(simplify(self - other), radical=True)
624 
625         if not diff:
626             return True
627 
628         if not diff.has(Add, Mod):
629             # if there is no expanding to be done after simplifying
630             # then this can't be a zero
631             return False
632 
633         constant = diff.is_constant(simplify=False, failing_number=True)
634 
635         if constant is False:
636             return False
637 
638         if constant is None and (diff.free_symbols or not diff.is_number):
639             # e.g. unless the right simplification is done, a symbolic
640             # zero is possible (see expression of issue 6829: without
641             # simplification constant will be None).
642             return
643 
644         if constant is True:
645             ndiff = diff._random()
646             if ndiff:
647                 return False
648 
649         # sometimes we can use a simplified result to give a clue as to
650         # what the expression should be; if the expression is *not* zero
651         # then we should have been able to compute that and so now
652         # we can just consider the cases where the approximation appears
653         # to be zero -- we try to prove it via minimal_polynomial.
654         if diff.is_number:
655             approx = diff.nsimplify()
656             if not approx:
657                 # try to prove via self-consistency
658                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
659                 # it seems to work better to try big ones first
660                 surds.sort(key=lambda x: -x.args[0])
661                 for s in surds:
662                     try:
663                         # simplify is False here -- this expression has already
664                         # been identified as being hard to identify as zero;
665                         # we will handle the checking ourselves using nsimplify
666                         # to see if we are in the right ballpark or not and if so
667                         # *then* the simplification will be attempted.
668                         if s.is_Symbol:
669                             sol = list(solveset(diff, s))
670                         else:
671                             sol = [s]
672                         if sol:
673                             if s in sol:
674                                 return True
675                             if s.is_real:
676                                 if any(nsimplify(si, [s]) == s and simplify(si) == s
677                                         for si in sol):
678                                     return True
679                     except NotImplementedError:
680                         pass
681 
682                 # try to prove with minimal_polynomial but know when
683                 # *not* to use this or else it can take a long time. e.g. issue 8354
684                 if True:  # change True to condition that assures non-hang
685                     try:
686                         mp = minimal_polynomial(diff)
687                         if mp.is_Symbol:
688                             return True
689                         return False
690                     except (NotAlgebraic, NotImplementedError):
691                         pass
692 
693         # diff has not simplified to zero; constant is either None, True
694         # or the number with significance (prec != 1) that was randomly
695         # calculated twice as the same value.
696         if constant not in (True, None) and constant != 0:
697             return False
698 
699         if failing_expression:
700             return diff
701         return None
702 
703     def _eval_is_positive(self):
704         from sympy.polys.numberfields import minimal_polynomial
705         from sympy.polys.polyerrors import NotAlgebraic
706         if self.is_number:
707             if self.is_real is False:
708                 return False
709             try:
710                 # check to see that we can get a value
711                 n2 = self._eval_evalf(2)
712                 if n2 is None:
713                     raise AttributeError
714                 if n2._prec == 1:  # no significance
715                     raise AttributeError
716                 if n2 == S.NaN:
717                     raise AttributeError
718             except (AttributeError, ValueError):
719                 return None
720             n, i = self.evalf(2).as_real_imag()
721             if not i.is_Number or not n.is_Number:
722                 return False
723             if n._prec != 1 and i._prec != 1:
724                 return bool(not i and n > 0)
725             elif n._prec == 1 and (not i or i._prec == 1) and \
726                     self.is_algebraic and not self.has(Function):
727                 try:
728                     if minimal_polynomial(self).is_Symbol:
729                         return False
730                 except (NotAlgebraic, NotImplementedError):
731                     pass
732 
733     def _eval_is_negative(self):
734         from sympy.polys.numberfields import minimal_polynomial
735         from sympy.polys.polyerrors import NotAlgebraic
736         if self.is_number:
737             if self.is_real is False:
738                 return False
739             try:
740                 # check to see that we can get a value
741                 n2 = self._eval_evalf(2)
742                 if n2 is None:
743                     raise AttributeError
744                 if n2._prec == 1:  # no significance
745                     raise AttributeError
746                 if n2 == S.NaN:
747                     raise AttributeError
748             except (AttributeError, ValueError):
749                 return None
750             n, i = self.evalf(2).as_real_imag()
751             if not i.is_Number or not n.is_Number:
752                 return False
753             if n._prec != 1 and i._prec != 1:
754                 return bool(not i and n < 0)
755             elif n._prec == 1 and (not i or i._prec == 1) and \
756                     self.is_algebraic and not self.has(Function):
757                 try:
758                     if minimal_polynomial(self).is_Symbol:
759                         return False
760                 except (NotAlgebraic, NotImplementedError):
761                     pass
762 
763     def _eval_interval(self, x, a, b):
764         """
765         Returns evaluation over an interval.  For most functions this is:
766 
767         self.subs(x, b) - self.subs(x, a),
768 
769         possibly using limit() if NaN is returned from subs.
770 
771         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
772         respectively.
773 
774         """
775         from sympy.series import limit, Limit
776         from sympy.solvers.solveset import solveset
777 
778         if (a is None and b is None):
779             raise ValueError('Both interval ends cannot be None.')
780 
781         if a == b:
782             return 0;
783 
784         if a is None:
785             A = 0
786         else:
787             A = self.subs(x, a)
788             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
789                 if (a < b) != False:
790                     A = limit(self, x, a,"+")
791                 else:
792                     A = limit(self, x, a,"-")
793 
794                 if A is S.NaN:
795                     return A
796                 if isinstance(A, Limit):
797                     raise NotImplementedError("Could not compute limit")
798 
799         if b is None:
800             B = 0
801         else:
802             B = self.subs(x, b)
803             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
804                 if (a < b) != False:
805                     B = limit(self, x, b,"-")
806                 else:
807                     B = limit(self, x, b,"+")
808 
809                 if isinstance(B, Limit):
810                     raise NotImplementedError("Could not compute limit")
811 
812         if (a and b) is None:
813             return B - A
814 
815         value = B - A
816 
817         if a.is_comparable and b.is_comparable:
818             singularities = list(solveset(self.cancel().as_numer_denom()[1], x))
819             for s in singularities:
820                 if a < s < b:
821                     value += -limit(self, x, s, "+") + limit(self, x, s, "-")
822                 elif b < s < a:
823                     value += limit(self, x, s, "+") - limit(self, x, s, "-")
824 
825         return value
826 
827     def _eval_power(self, other):
828         # subclass to compute self**other for cases when
829         # other is not NaN, 0, or 1
830         return None
831 
832     def _eval_conjugate(self):
833         if self.is_real:
834             return self
835         elif self.is_imaginary:
836             return -self
837 
838     def conjugate(self):
839         from sympy.functions.elementary.complexes import conjugate as c
840         return c(self)
841 
842     def _eval_transpose(self):
843         from sympy.functions.elementary.complexes import conjugate
844         if self.is_complex:
845             return self
846         elif self.is_hermitian:
847             return conjugate(self)
848         elif self.is_antihermitian:
849             return -conjugate(self)
850 
851     def transpose(self):
852         from sympy.functions.elementary.complexes import transpose
853         return transpose(self)
854 
855     def _eval_adjoint(self):
856         from sympy.functions.elementary.complexes import conjugate, transpose
857         if self.is_hermitian:
858             return self
859         elif self.is_antihermitian:
860             return -self
861         obj = self._eval_conjugate()
862         if obj is not None:
863             return transpose(obj)
864         obj = self._eval_transpose()
865         if obj is not None:
866             return conjugate(obj)
867 
868     def adjoint(self):
869         from sympy.functions.elementary.complexes import adjoint
870         return adjoint(self)
871 
872     @classmethod
873     def _parse_order(cls, order):
874         """Parse and configure the ordering of terms. """
875         from sympy.polys.orderings import monomial_key
876 
877         try:
878             reverse = order.startswith('rev-')
879         except AttributeError:
880             reverse = False
881         else:
882             if reverse:
883                 order = order[4:]
884 
885         monom_key = monomial_key(order)
886 
887         def neg(monom):
888             result = []
889 
890             for m in monom:
891                 if isinstance(m, tuple):
892                     result.append(neg(m))
893                 else:
894                     result.append(-m)
895 
896             return tuple(result)
897 
898         def key(term):
899             _, ((re, im), monom, ncpart) = term
900 
901             monom = neg(monom_key(monom))
902             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
903             coeff = ((bool(im), im), (re, im))
904 
905             return monom, ncpart, coeff
906 
907         return key, reverse
908 
909     def as_ordered_factors(self, order=None):
910         """Return list of ordered factors (if Mul) else [self]."""
911         return [self]
912 
913     def as_ordered_terms(self, order=None, data=False):
914         """
915         Transform an expression to an ordered list of terms.
916 
917         Examples
918         ========
919 
920         >>> from sympy import sin, cos
921         >>> from sympy.abc import x
922 
923         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
924         [sin(x)**2*cos(x), sin(x)**2, 1]
925 
926         """
927         key, reverse = self._parse_order(order)
928         terms, gens = self.as_terms()
929 
930         if not any(term.is_Order for term, _ in terms):
931             ordered = sorted(terms, key=key, reverse=reverse)
932         else:
933             _terms, _order = [], []
934 
935             for term, repr in terms:
936                 if not term.is_Order:
937                     _terms.append((term, repr))
938                 else:
939                     _order.append((term, repr))
940 
941             ordered = sorted(_terms, key=key, reverse=True) \
942                 + sorted(_order, key=key, reverse=True)
943 
944         if data:
945             return ordered, gens
946         else:
947             return [term for term, _ in ordered]
948 
949     def as_terms(self):
950         """Transform an expression to a list of terms. """
951         from .add import Add
952         from .mul import Mul
953         from .exprtools import decompose_power
954 
955         gens, terms = set([]), []
956 
957         for term in Add.make_args(self):
958             coeff, _term = term.as_coeff_Mul()
959 
960             coeff = complex(coeff)
961             cpart, ncpart = {}, []
962 
963             if _term is not S.One:
964                 for factor in Mul.make_args(_term):
965                     if factor.is_number:
966                         try:
967                             coeff *= complex(factor)
968                         except TypeError:
969                             pass
970                         else:
971                             continue
972 
973                     if factor.is_commutative:
974                         base, exp = decompose_power(factor)
975 
976                         cpart[base] = exp
977                         gens.add(base)
978                     else:
979                         ncpart.append(factor)
980 
981             coeff = coeff.real, coeff.imag
982             ncpart = tuple(ncpart)
983 
984             terms.append((term, (coeff, cpart, ncpart)))
985 
986         gens = sorted(gens, key=default_sort_key)
987 
988         k, indices = len(gens), {}
989 
990         for i, g in enumerate(gens):
991             indices[g] = i
992 
993         result = []
994 
995         for term, (coeff, cpart, ncpart) in terms:
996             monom = [0]*k
997 
998             for base, exp in cpart.items():
999                 monom[indices[base]] = exp
1000 
1001             result.append((term, (coeff, tuple(monom), ncpart)))
1002 
1003         return result, gens
1004 
1005     def removeO(self):
1006         """Removes the additive O(..) symbol if there is one"""
1007         return self
1008 
1009     def getO(self):
1010         """Returns the additive O(..) symbol if there is one, else None."""
1011         return None
1012 
1013     def getn(self):
1014         """
1015         Returns the order of the expression.
1016 
1017         The order is determined either from the O(...) term. If there
1018         is no O(...) term, it returns None.
1019 
1020         Examples
1021         ========
1022 
1023         >>> from sympy import O
1024         >>> from sympy.abc import x
1025         >>> (1 + x + O(x**2)).getn()
1026         2
1027         >>> (1 + x).getn()
1028 
1029         """
1030         from sympy import Dummy, Symbol
1031         o = self.getO()
1032         if o is None:
1033             return None
1034         elif o.is_Order:
1035             o = o.expr
1036             if o is S.One:
1037                 return S.Zero
1038             if o.is_Symbol:
1039                 return S.One
1040             if o.is_Pow:
1041                 return o.args[1]
1042             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1043                 for oi in o.args:
1044                     if oi.is_Symbol:
1045                         return S.One
1046                     if oi.is_Pow:
1047                         syms = oi.atoms(Symbol)
1048                         if len(syms) == 1:
1049                             x = syms.pop()
1050                             oi = oi.subs(x, Dummy('x', positive=True))
1051                             if oi.base.is_Symbol and oi.exp.is_Rational:
1052                                 return abs(oi.exp)
1053 
1054         raise NotImplementedError('not sure of order of %s' % o)
1055 
1056     def count_ops(self, visual=None):
1057         """wrapper for count_ops that returns the operation count."""
1058         from .function import count_ops
1059         return count_ops(self, visual)
1060 
1061     def args_cnc(self, cset=False, warn=True, split_1=True):
1062         """Return [commutative factors, non-commutative factors] of self.
1063 
1064         self is treated as a Mul and the ordering of the factors is maintained.
1065         If ``cset`` is True the commutative factors will be returned in a set.
1066         If there were repeated factors (as may happen with an unevaluated Mul)
1067         then an error will be raised unless it is explicitly supressed by
1068         setting ``warn`` to False.
1069 
1070         Note: -1 is always separated from a Number unless split_1 is False.
1071 
1072         >>> from sympy import symbols, oo
1073         >>> A, B = symbols('A B', commutative=False)
1074         >>> x, y = symbols('x y')
1075         >>> (-2*x*y).args_cnc()
1076         [[-1, 2, x, y], []]
1077         >>> (-2.5*x).args_cnc()
1078         [[-1, 2.5, x], []]
1079         >>> (-2*x*A*B*y).args_cnc()
1080         [[-1, 2, x, y], [A, B]]
1081         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1082         [[-2, x, y], [A, B]]
1083         >>> (-2*x*y).args_cnc(cset=True)
1084         [{-1, 2, x, y}, []]
1085 
1086         The arg is always treated as a Mul:
1087 
1088         >>> (-2 + x + A).args_cnc()
1089         [[], [x - 2 + A]]
1090         >>> (-oo).args_cnc() # -oo is a singleton
1091         [[-1, oo], []]
1092         """
1093 
1094         if self.is_Mul:
1095             args = list(self.args)
1096         else:
1097             args = [self]
1098         for i, mi in enumerate(args):
1099             if not mi.is_commutative:
1100                 c = args[:i]
1101                 nc = args[i:]
1102                 break
1103         else:
1104             c = args
1105             nc = []
1106 
1107         if c and split_1 and (
1108             c[0].is_Number and
1109             c[0].is_negative and
1110                 c[0] is not S.NegativeOne):
1111             c[:1] = [S.NegativeOne, -c[0]]
1112 
1113         if cset:
1114             clen = len(c)
1115             c = set(c)
1116             if clen and warn and len(c) != clen:
1117                 raise ValueError('repeated commutative arguments: %s' %
1118                                  [ci for ci in c if list(self.args).count(ci) > 1])
1119         return [c, nc]
1120 
1121     def coeff(self, x, n=1, right=False):
1122         """
1123         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1124         is zero then all terms independent of ``x`` will be returned.
1125 
1126         When ``x`` is noncommutative, the coefficient to the left (default) or
1127         right of ``x`` can be returned. The keyword 'right' is ignored when
1128         ``x`` is commutative.
1129 
1130         See Also
1131         ========
1132 
1133         as_coefficient: separate the expression into a coefficient and factor
1134         as_coeff_Add: separate the additive constant from an expression
1135         as_coeff_Mul: separate the multiplicative constant from an expression
1136         as_independent: separate x-dependent terms/factors from others
1137         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1138         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1139 
1140         Examples
1141         ========
1142 
1143         >>> from sympy import symbols
1144         >>> from sympy.abc import x, y, z
1145 
1146         You can select terms that have an explicit negative in front of them:
1147 
1148         >>> (-x + 2*y).coeff(-1)
1149         x
1150         >>> (x - 2*y).coeff(-1)
1151         2*y
1152 
1153         You can select terms with no Rational coefficient:
1154 
1155         >>> (x + 2*y).coeff(1)
1156         x
1157         >>> (3 + 2*x + 4*x**2).coeff(1)
1158         0
1159 
1160         You can select terms independent of x by making n=0; in this case
1161         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1162         of None):
1163 
1164         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1165         3
1166         >>> eq = ((x + 1)**3).expand() + 1
1167         >>> eq
1168         x**3 + 3*x**2 + 3*x + 2
1169         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1170         [1, 3, 3, 2]
1171         >>> eq -= 2
1172         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1173         [1, 3, 3, 0]
1174 
1175         You can select terms that have a numerical term in front of them:
1176 
1177         >>> (-x - 2*y).coeff(2)
1178         -y
1179         >>> from sympy import sqrt
1180         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1181         x
1182 
1183         The matching is exact:
1184 
1185         >>> (3 + 2*x + 4*x**2).coeff(x)
1186         2
1187         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1188         4
1189         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1190         0
1191         >>> (z*(x + y)**2).coeff((x + y)**2)
1192         z
1193         >>> (z*(x + y)**2).coeff(x + y)
1194         0
1195 
1196         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1197         from the following:
1198 
1199         >>> (x + z*(x + x*y)).coeff(x)
1200         1
1201 
1202         If such factoring is desired, factor_terms can be used first:
1203 
1204         >>> from sympy import factor_terms
1205         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1206         z*(y + 1) + 1
1207 
1208         >>> n, m, o = symbols('n m o', commutative=False)
1209         >>> n.coeff(n)
1210         1
1211         >>> (3*n).coeff(n)
1212         3
1213         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1214         1 + m
1215         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1216         m
1217 
1218         If there is more than one possible coefficient 0 is returned:
1219 
1220         >>> (n*m + m*n).coeff(n)
1221         0
1222 
1223         If there is only one possible coefficient, it is returned:
1224 
1225         >>> (n*m + x*m*n).coeff(m*n)
1226         x
1227         >>> (n*m + x*m*n).coeff(m*n, right=1)
1228         1
1229 
1230         """
1231         x = sympify(x)
1232         if not isinstance(x, Basic):
1233             return S.Zero
1234 
1235         n = as_int(n)
1236 
1237         if not x:
1238             return S.Zero
1239 
1240         if x == self:
1241             if n == 1:
1242                 return S.One
1243             return S.Zero
1244 
1245         if x is S.One:
1246             co = [a for a in Add.make_args(self)
1247                   if a.as_coeff_Mul()[0] is S.One]
1248             if not co:
1249                 return S.Zero
1250             return Add(*co)
1251 
1252         if n == 0:
1253             if x.is_Add and self.is_Add:
1254                 c = self.coeff(x, right=right)
1255                 if not c:
1256                     return S.Zero
1257                 if not right:
1258                     return self - Add(*[a*x for a in Add.make_args(c)])
1259                 return self - Add(*[x*a for a in Add.make_args(c)])
1260             return self.as_independent(x, as_Add=True)[0]
1261 
1262         # continue with the full method, looking for this power of x:
1263         x = x**n
1264 
1265         def incommon(l1, l2):
1266             if not l1 or not l2:
1267                 return []
1268             n = min(len(l1), len(l2))
1269             for i in range(n):
1270                 if l1[i] != l2[i]:
1271                     return l1[:i]
1272             return l1[:]
1273 
1274         def find(l, sub, first=True):
1275             """ Find where list sub appears in list l. When ``first`` is True
1276             the first occurance from the left is returned, else the last
1277             occurance is returned. Return None if sub is not in l.
1278 
1279             >> l = range(5)*2
1280             >> find(l, [2, 3])
1281             2
1282             >> find(l, [2, 3], first=0)
1283             7
1284             >> find(l, [2, 4])
1285             None
1286 
1287             """
1288             if not sub or not l or len(sub) > len(l):
1289                 return None
1290             n = len(sub)
1291             if not first:
1292                 l.reverse()
1293                 sub.reverse()
1294             for i in range(0, len(l) - n + 1):
1295                 if all(l[i + j] == sub[j] for j in range(n)):
1296                     break
1297             else:
1298                 i = None
1299             if not first:
1300                 l.reverse()
1301                 sub.reverse()
1302             if i is not None and not first:
1303                 i = len(l) - (i + n)
1304             return i
1305 
1306         co = []
1307         args = Add.make_args(self)
1308         self_c = self.is_commutative
1309         x_c = x.is_commutative
1310         if self_c and not x_c:
1311             return S.Zero
1312 
1313         if self_c:
1314             xargs = x.args_cnc(cset=True, warn=False)[0]
1315             for a in args:
1316                 margs = a.args_cnc(cset=True, warn=False)[0]
1317                 if len(xargs) > len(margs):
1318                     continue
1319                 resid = margs.difference(xargs)
1320                 if len(resid) + len(xargs) == len(margs):
1321                     co.append(Mul(*resid))
1322             if co == []:
1323                 return S.Zero
1324             elif co:
1325                 return Add(*co)
1326         elif x_c:
1327             xargs = x.args_cnc(cset=True, warn=False)[0]
1328             for a in args:
1329                 margs, nc = a.args_cnc(cset=True)
1330                 if len(xargs) > len(margs):
1331                     continue
1332                 resid = margs.difference(xargs)
1333                 if len(resid) + len(xargs) == len(margs):
1334                     co.append(Mul(*(list(resid) + nc)))
1335             if co == []:
1336                 return S.Zero
1337             elif co:
1338                 return Add(*co)
1339         else:  # both nc
1340             xargs, nx = x.args_cnc(cset=True)
1341             # find the parts that pass the commutative terms
1342             for a in args:
1343                 margs, nc = a.args_cnc(cset=True)
1344                 if len(xargs) > len(margs):
1345                     continue
1346                 resid = margs.difference(xargs)
1347                 if len(resid) + len(xargs) == len(margs):
1348                     co.append((resid, nc))
1349             # now check the non-comm parts
1350             if not co:
1351                 return S.Zero
1352             if all(n == co[0][1] for r, n in co):
1353                 ii = find(co[0][1], nx, right)
1354                 if ii is not None:
1355                     if not right:
1356                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1357                     else:
1358                         return Mul(*co[0][1][ii + len(nx):])
1359             beg = reduce(incommon, (n[1] for n in co))
1360             if beg:
1361                 ii = find(beg, nx, right)
1362                 if ii is not None:
1363                     if not right:
1364                         gcdc = co[0][0]
1365                         for i in range(1, len(co)):
1366                             gcdc = gcdc.intersection(co[i][0])
1367                             if not gcdc:
1368                                 break
1369                         return Mul(*(list(gcdc) + beg[:ii]))
1370                     else:
1371                         m = ii + len(nx)
1372                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1373             end = list(reversed(
1374                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1375             if end:
1376                 ii = find(end, nx, right)
1377                 if ii is not None:
1378                     if not right:
1379                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1380                     else:
1381                         return Mul(*end[ii + len(nx):])
1382             # look for single match
1383             hit = None
1384             for i, (r, n) in enumerate(co):
1385                 ii = find(n, nx, right)
1386                 if ii is not None:
1387                     if not hit:
1388                         hit = ii, r, n
1389                     else:
1390                         break
1391             else:
1392                 if hit:
1393                     ii, r, n = hit
1394                     if not right:
1395                         return Mul(*(list(r) + n[:ii]))
1396                     else:
1397                         return Mul(*n[ii + len(nx):])
1398 
1399             return S.Zero
1400 
1401     def as_expr(self, *gens):
1402         """
1403         Convert a polynomial to a SymPy expression.
1404 
1405         Examples
1406         ========
1407 
1408         >>> from sympy import sin
1409         >>> from sympy.abc import x, y
1410 
1411         >>> f = (x**2 + x*y).as_poly(x, y)
1412         >>> f.as_expr()
1413         x**2 + x*y
1414 
1415         >>> sin(x).as_expr()
1416         sin(x)
1417 
1418         """
1419         return self
1420 
1421     def as_coefficient(self, expr):
1422         """
1423         Extracts symbolic coefficient at the given expression. In
1424         other words, this functions separates 'self' into the product
1425         of 'expr' and 'expr'-free coefficient. If such separation
1426         is not possible it will return None.
1427 
1428         Examples
1429         ========
1430 
1431         >>> from sympy import E, pi, sin, I, Poly
1432         >>> from sympy.abc import x
1433 
1434         >>> E.as_coefficient(E)
1435         1
1436         >>> (2*E).as_coefficient(E)
1437         2
1438         >>> (2*sin(E)*E).as_coefficient(E)
1439 
1440         Two terms have E in them so a sum is returned. (If one were
1441         desiring the coefficient of the term exactly matching E then
1442         the constant from the returned expression could be selected.
1443         Or, for greater precision, a method of Poly can be used to
1444         indicate the desired term from which the coefficient is
1445         desired.)
1446 
1447         >>> (2*E + x*E).as_coefficient(E)
1448         x + 2
1449         >>> _.args[0]  # just want the exact match
1450         2
1451         >>> p = Poly(2*E + x*E); p
1452         Poly(x*E + 2*E, x, E, domain='ZZ')
1453         >>> p.coeff_monomial(E)
1454         2
1455         >>> p.nth(0, 1)
1456         2
1457 
1458         Since the following cannot be written as a product containing
1459         E as a factor, None is returned. (If the coefficient ``2*x`` is
1460         desired then the ``coeff`` method should be used.)
1461 
1462         >>> (2*E*x + x).as_coefficient(E)
1463         >>> (2*E*x + x).coeff(E)
1464         2*x
1465 
1466         >>> (E*(x + 1) + x).as_coefficient(E)
1467 
1468         >>> (2*pi*I).as_coefficient(pi*I)
1469         2
1470         >>> (2*I).as_coefficient(pi*I)
1471 
1472         See Also
1473         ========
1474 
1475         coeff: return sum of terms have a given factor
1476         as_coeff_Add: separate the additive constant from an expression
1477         as_coeff_Mul: separate the multiplicative constant from an expression
1478         as_independent: separate x-dependent terms/factors from others
1479         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1480         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1481 
1482 
1483         """
1484 
1485         r = self.extract_multiplicatively(expr)
1486         if r and not r.has(expr):
1487             return r
1488 
1489     def as_independent(self, *deps, **hint):
1490         """
1491         A mostly naive separation of a Mul or Add into arguments that are not
1492         are dependent on deps. To obtain as complete a separation of variables
1493         as possible, use a separation method first, e.g.:
1494 
1495         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1496         * .expand(mul=True) to change Add or Mul into Add
1497         * .expand(log=True) to change log expr into an Add
1498 
1499         The only non-naive thing that is done here is to respect noncommutative
1500         ordering of variables and to always return (0, 0) for `self` of zero
1501         regardless of hints.
1502 
1503         For nonzero `self`, the returned tuple (i, d) has the
1504         following interpretation:
1505 
1506         * i will has no variable that appears in deps
1507         * d will be 1 or else have terms that contain variables that are in deps
1508         * if self is an Add then self = i + d
1509         * if self is a Mul then self = i*d
1510         * otherwise (self, S.One) or (S.One, self) is returned.
1511 
1512         To force the expression to be treated as an Add, use the hint as_Add=True
1513 
1514         Examples
1515         ========
1516 
1517         -- self is an Add
1518 
1519         >>> from sympy import sin, cos, exp
1520         >>> from sympy.abc import x, y, z
1521 
1522         >>> (x + x*y).as_independent(x)
1523         (0, x*y + x)
1524         >>> (x + x*y).as_independent(y)
1525         (x, x*y)
1526         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1527         (y + z, 2*x*sin(x) + x)
1528         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1529         (z, 2*x*sin(x) + x + y)
1530 
1531         -- self is a Mul
1532 
1533         >>> (x*sin(x)*cos(y)).as_independent(x)
1534         (cos(y), x*sin(x))
1535 
1536         non-commutative terms cannot always be separated out when self is a Mul
1537 
1538         >>> from sympy import symbols
1539         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1540         >>> (n1 + n1*n2).as_independent(n2)
1541         (n1, n1*n2)
1542         >>> (n2*n1 + n1*n2).as_independent(n2)
1543         (0, n1*n2 + n2*n1)
1544         >>> (n1*n2*n3).as_independent(n1)
1545         (1, n1*n2*n3)
1546         >>> (n1*n2*n3).as_independent(n2)
1547         (n1, n2*n3)
1548         >>> ((x-n1)*(x-y)).as_independent(x)
1549         (1, (x - y)*(x - n1))
1550 
1551         -- self is anything else:
1552 
1553         >>> (sin(x)).as_independent(x)
1554         (1, sin(x))
1555         >>> (sin(x)).as_independent(y)
1556         (sin(x), 1)
1557         >>> exp(x+y).as_independent(x)
1558         (1, exp(x + y))
1559 
1560         -- force self to be treated as an Add:
1561 
1562         >>> (3*x).as_independent(x, as_Add=True)
1563         (0, 3*x)
1564 
1565         -- force self to be treated as a Mul:
1566 
1567         >>> (3+x).as_independent(x, as_Add=False)
1568         (1, x + 3)
1569         >>> (-3+x).as_independent(x, as_Add=False)
1570         (1, x - 3)
1571 
1572         Note how the below differs from the above in making the
1573         constant on the dep term positive.
1574 
1575         >>> (y*(-3+x)).as_independent(x)
1576         (y, x - 3)
1577 
1578         -- use .as_independent() for true independence testing instead
1579            of .has(). The former considers only symbols in the free
1580            symbols while the latter considers all symbols
1581 
1582         >>> from sympy import Integral
1583         >>> I = Integral(x, (x, 1, 2))
1584         >>> I.has(x)
1585         True
1586         >>> x in I.free_symbols
1587         False
1588         >>> I.as_independent(x) == (I, 1)
1589         True
1590         >>> (I + x).as_independent(x) == (I, x)
1591         True
1592 
1593         Note: when trying to get independent terms, a separation method
1594         might need to be used first. In this case, it is important to keep
1595         track of what you send to this routine so you know how to interpret
1596         the returned values
1597 
1598         >>> from sympy import separatevars, log
1599         >>> separatevars(exp(x+y)).as_independent(x)
1600         (exp(y), exp(x))
1601         >>> (x + x*y).as_independent(y)
1602         (x, x*y)
1603         >>> separatevars(x + x*y).as_independent(y)
1604         (x, y + 1)
1605         >>> (x*(1 + y)).as_independent(y)
1606         (x, y + 1)
1607         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1608         (x, x*y)
1609         >>> a, b=symbols('a b', positive=True)
1610         >>> (log(a*b).expand(log=True)).as_independent(b)
1611         (log(a), log(b))
1612 
1613         See Also
1614         ========
1615         .separatevars(), .expand(log=True), Add.as_two_terms(),
1616         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1617         """
1618         from .symbol import Symbol
1619         from .add import _unevaluated_Add
1620         from .mul import _unevaluated_Mul
1621         from sympy.utilities.iterables import sift
1622 
1623         if self.is_zero:
1624             return S.Zero, S.Zero
1625 
1626         func = self.func
1627         if hint.get('as_Add', func is Add):
1628             want = Add
1629         else:
1630             want = Mul
1631 
1632         # sift out deps into symbolic and other and ignore
1633         # all symbols but those that are in the free symbols
1634         sym = set()
1635         other = []
1636         for d in deps:
1637             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1638                 sym.add(d)
1639             else:
1640                 other.append(d)
1641 
1642         def has(e):
1643             """return the standard has() if there are no literal symbols, else
1644             check to see that symbol-deps are in the free symbols."""
1645             has_other = e.has(*other)
1646             if not sym:
1647                 return has_other
1648             return has_other or e.has(*(e.free_symbols & sym))
1649 
1650         if (want is not func or
1651                 func is not Add and func is not Mul):
1652             if has(self):
1653                 return (want.identity, self)
1654             else:
1655                 return (self, want.identity)
1656         else:
1657             if func is Add:
1658                 args = list(self.args)
1659             else:
1660                 args, nc = self.args_cnc()
1661 
1662         d = sift(args, lambda x: has(x))
1663         depend = d[True]
1664         indep = d[False]
1665         if func is Add:  # all terms were treated as commutative
1666             return (Add(*indep), _unevaluated_Add(*depend))
1667         else:  # handle noncommutative by stopping at first dependent term
1668             for i, n in enumerate(nc):
1669                 if has(n):
1670                     depend.extend(nc[i:])
1671                     break
1672                 indep.append(n)
1673             return Mul(*indep), (
1674                 Mul(*depend, evaluate=False) if nc else
1675                 _unevaluated_Mul(*depend))
1676 
1677     def as_real_imag(self, deep=True, **hints):
1678         """Performs complex expansion on 'self' and returns a tuple
1679            containing collected both real and imaginary parts. This
1680            method can't be confused with re() and im() functions,
1681            which does not perform complex expansion at evaluation.
1682 
1683            However it is possible to expand both re() and im()
1684            functions and get exactly the same results as with
1685            a single call to this function.
1686 
1687            >>> from sympy import symbols, I
1688 
1689            >>> x, y = symbols('x,y', real=True)
1690 
1691            >>> (x + y*I).as_real_imag()
1692            (x, y)
1693 
1694            >>> from sympy.abc import z, w
1695 
1696            >>> (z + w*I).as_real_imag()
1697            (re(z) - im(w), re(w) + im(z))
1698 
1699         """
1700         from sympy import im, re
1701         if hints.get('ignore') == self:
1702             return None
1703         else:
1704             return (re(self), im(self))
1705 
1706     def as_powers_dict(self):
1707         """Return self as a dictionary of factors with each factor being
1708         treated as a power. The keys are the bases of the factors and the
1709         values, the corresponding exponents. The resulting dictionary should
1710         be used with caution if the expression is a Mul and contains non-
1711         commutative factors since the order that they appeared will be lost in
1712         the dictionary."""
1713         d = defaultdict(int)
1714         d.update(dict([self.as_base_exp()]))
1715         return d
1716 
1717     def as_coefficients_dict(self):
1718         """Return a dictionary mapping terms to their Rational coefficient.
1719         Since the dictionary is a defaultdict, inquiries about terms which
1720         were not present will return a coefficient of 0. If an expression is
1721         not an Add it is considered to have a single term.
1722 
1723         Examples
1724         ========
1725 
1726         >>> from sympy.abc import a, x
1727         >>> (3*x + a*x + 4).as_coefficients_dict()
1728         {1: 4, x: 3, a*x: 1}
1729         >>> _[a]
1730         0
1731         >>> (3*a*x).as_coefficients_dict()
1732         {a*x: 3}
1733 
1734         """
1735         c, m = self.as_coeff_Mul()
1736         if not c.is_Rational:
1737             c = S.One
1738             m = self
1739         d = defaultdict(int)
1740         d.update({m: c})
1741         return d
1742 
1743     def as_base_exp(self):
1744         # a -> b ** e
1745         return self, S.One
1746 
1747     def as_coeff_mul(self, *deps, **kwargs):
1748         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1749 
1750         c should be a Rational multiplied by any terms of the Mul that are
1751         independent of deps.
1752 
1753         args should be a tuple of all other terms of m; args is empty
1754         if self is a Number or if self is independent of deps (when given).
1755 
1756         This should be used when you don't know if self is a Mul or not but
1757         you want to treat self as a Mul or if you want to process the
1758         individual arguments of the tail of self as a Mul.
1759 
1760         - if you know self is a Mul and want only the head, use self.args[0];
1761         - if you don't want to process the arguments of the tail but need the
1762           tail then use self.as_two_terms() which gives the head and tail;
1763         - if you want to split self into an independent and dependent parts
1764           use ``self.as_independent(*deps)``
1765 
1766         >>> from sympy import S
1767         >>> from sympy.abc import x, y
1768         >>> (S(3)).as_coeff_mul()
1769         (3, ())
1770         >>> (3*x*y).as_coeff_mul()
1771         (3, (x, y))
1772         >>> (3*x*y).as_coeff_mul(x)
1773         (3*y, (x,))
1774         >>> (3*y).as_coeff_mul(x)
1775         (3*y, ())
1776         """
1777         if deps:
1778             if not self.has(*deps):
1779                 return self, tuple()
1780         return S.One, (self,)
1781 
1782     def as_coeff_add(self, *deps):
1783         """Return the tuple (c, args) where self is written as an Add, ``a``.
1784 
1785         c should be a Rational added to any terms of the Add that are
1786         independent of deps.
1787 
1788         args should be a tuple of all other terms of ``a``; args is empty
1789         if self is a Number or if self is independent of deps (when given).
1790 
1791         This should be used when you don't know if self is an Add or not but
1792         you want to treat self as an Add or if you want to process the
1793         individual arguments of the tail of self as an Add.
1794 
1795         - if you know self is an Add and want only the head, use self.args[0];
1796         - if you don't want to process the arguments of the tail but need the
1797           tail then use self.as_two_terms() which gives the head and tail.
1798         - if you want to split self into an independent and dependent parts
1799           use ``self.as_independent(*deps)``
1800 
1801         >>> from sympy import S
1802         >>> from sympy.abc import x, y
1803         >>> (S(3)).as_coeff_add()
1804         (3, ())
1805         >>> (3 + x).as_coeff_add()
1806         (3, (x,))
1807         >>> (3 + x + y).as_coeff_add(x)
1808         (y + 3, (x,))
1809         >>> (3 + y).as_coeff_add(x)
1810         (y + 3, ())
1811 
1812         """
1813         if deps:
1814             if not self.has(*deps):
1815                 return self, tuple()
1816         return S.Zero, (self,)
1817 
1818     def primitive(self):
1819         """Return the positive Rational that can be extracted non-recursively
1820         from every term of self (i.e., self is treated like an Add). This is
1821         like the as_coeff_Mul() method but primitive always extracts a positive
1822         Rational (never a negative or a Float).
1823 
1824         Examples
1825         ========
1826 
1827         >>> from sympy.abc import x
1828         >>> (3*(x + 1)**2).primitive()
1829         (3, (x + 1)**2)
1830         >>> a = (6*x + 2); a.primitive()
1831         (2, 3*x + 1)
1832         >>> b = (x/2 + 3); b.primitive()
1833         (1/2, x + 6)
1834         >>> (a*b).primitive() == (1, a*b)
1835         True
1836         """
1837         if not self:
1838             return S.One, S.Zero
1839         c, r = self.as_coeff_Mul(rational=True)
1840         if c.is_negative:
1841             c, r = -c, -r
1842         return c, r
1843 
1844     def as_content_primitive(self, radical=False, clear=True):
1845         """This method should recursively remove a Rational from all arguments
1846         and return that (content) and the new self (primitive). The content
1847         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
1848         The primitive need no be in canonical form and should try to preserve
1849         the underlying structure if possible (i.e. expand_mul should not be
1850         applied to self).
1851 
1852         Examples
1853         ========
1854 
1855         >>> from sympy import sqrt
1856         >>> from sympy.abc import x, y, z
1857 
1858         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
1859 
1860         The as_content_primitive function is recursive and retains structure:
1861 
1862         >>> eq.as_content_primitive()
1863         (2, x + 3*y*(y + 1) + 1)
1864 
1865         Integer powers will have Rationals extracted from the base:
1866 
1867         >>> ((2 + 6*x)**2).as_content_primitive()
1868         (4, (3*x + 1)**2)
1869         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
1870         (1, (2*(3*x + 1))**(2*y))
1871 
1872         Terms may end up joining once their as_content_primitives are added:
1873 
1874         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1875         (11, x*(y + 1))
1876         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1877         (9, x*(y + 1))
1878         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
1879         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
1880         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
1881         (121, x**2*(y + 1)**2)
1882         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
1883         (1, 121.0*x**2*(y + 1)**2)
1884 
1885         Radical content can also be factored out of the primitive:
1886 
1887         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
1888         (2, sqrt(2)*(1 + 2*sqrt(5)))
1889 
1890         If clear=False (default is True) then content will not be removed
1891         from an Add if it can be distributed to leave one or more
1892         terms with integer coefficients.
1893 
1894         >>> (x/2 + y).as_content_primitive()
1895         (1/2, x + 2*y)
1896         >>> (x/2 + y).as_content_primitive(clear=False)
1897         (1, x/2 + y)
1898         """
1899         return S.One, self
1900 
1901     def as_numer_denom(self):
1902         """ expression -> a/b -> a, b
1903 
1904         This is just a stub that should be defined by
1905         an object's class methods to get anything else.
1906 
1907         See Also
1908         ========
1909         normal: return a/b instead of a, b
1910         """
1911 
1912         return self, S.One
1913 
1914     def normal(self):
1915         n, d = self.as_numer_denom()
1916         if d is S.One:
1917             return n
1918         return n/d
1919 
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)
2027 
2028     def extract_additively(self, c):
2029         """Return self - c if it's possible to subtract c from self and
2030         make all matching coefficients move towards zero, else return None.
2031 
2032         Examples
2033         ========
2034 
2035         >>> from sympy.abc import x, y
2036         >>> e = 2*x + 3
2037         >>> e.extract_additively(x + 1)
2038         x + 2
2039         >>> e.extract_additively(3*x)
2040         >>> e.extract_additively(4)
2041         >>> (y*(x + 1)).extract_additively(x + 1)
2042         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2043         (x + 1)*(x + 2*y) + 3
2044 
2045         Sometimes auto-expansion will return a less simplified result
2046         than desired; gcd_terms might be used in such cases:
2047 
2048         >>> from sympy import gcd_terms
2049         >>> (4*x*(y + 1) + y).extract_additively(x)
2050         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2051         >>> gcd_terms(_)
2052         x*(4*y + 3) + y
2053 
2054         See Also
2055         ========
2056         extract_multiplicatively
2057         coeff
2058         as_coefficient
2059 
2060         """
2061 
2062         c = sympify(c)
2063         if self is S.NaN:
2064             return None
2065         if c is S.Zero:
2066             return self
2067         elif c == self:
2068             return S.Zero
2069         elif self is S.Zero:
2070             return None
2071 
2072         if self.is_Number:
2073             if not c.is_Number:
2074                 return None
2075             co = self
2076             diff = co - c
2077             # XXX should we match types? i.e should 3 - .1 succeed?
2078             if (co > 0 and diff > 0 and diff < co or
2079                     co < 0 and diff < 0 and diff > co):
2080                 return diff
2081             return None
2082 
2083         if c.is_Number:
2084             co, t = self.as_coeff_Add()
2085             xa = co.extract_additively(c)
2086             if xa is None:
2087                 return None
2088             return xa + t
2089 
2090         # handle the args[0].is_Number case separately
2091         # since we will have trouble looking for the coeff of
2092         # a number.
2093         if c.is_Add and c.args[0].is_Number:
2094             # whole term as a term factor
2095             co = self.coeff(c)
2096             xa0 = (co.extract_additively(1) or 0)*c
2097             if xa0:
2098                 diff = self - co*c
2099                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2100             # term-wise
2101             h, t = c.as_coeff_Add()
2102             sh, st = self.as_coeff_Add()
2103             xa = sh.extract_additively(h)
2104             if xa is None:
2105                 return None
2106             xa2 = st.extract_additively(t)
2107             if xa2 is None:
2108                 return None
2109             return xa + xa2
2110 
2111         # whole term as a term factor
2112         co = self.coeff(c)
2113         xa0 = (co.extract_additively(1) or 0)*c
2114         if xa0:
2115             diff = self - co*c
2116             return (xa0 + (diff.extract_additively(c) or diff)) or None
2117         # term-wise
2118         coeffs = []
2119         for a in Add.make_args(c):
2120             ac, at = a.as_coeff_Mul()
2121             co = self.coeff(at)
2122             if not co:
2123                 return None
2124             coc, cot = co.as_coeff_Add()
2125             xa = coc.extract_additively(ac)
2126             if xa is None:
2127                 return None
2128             self -= co*at
2129             coeffs.append((cot + xa)*at)
2130         coeffs.append(self)
2131         return Add(*coeffs)
2132 
2133     def could_extract_minus_sign(self):
2134         """Canonical way to choose an element in the set {e, -e} where
2135            e is any expression. If the canonical element is e, we have
2136            e.could_extract_minus_sign() == True, else
2137            e.could_extract_minus_sign() == False.
2138 
2139            For any expression, the set ``{e.could_extract_minus_sign(),
2140            (-e).could_extract_minus_sign()}`` must be ``{True, False}``.
2141 
2142            >>> from sympy.abc import x, y
2143            >>> (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()
2144            True
2145 
2146         """
2147         negative_self = -self
2148         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2149         negative_self_has_minus = (
2150             (negative_self).extract_multiplicatively(-1) is not None)
2151         if self_has_minus != negative_self_has_minus:
2152             return self_has_minus
2153         else:
2154             if self.is_Add:
2155                 # We choose the one with less arguments with minus signs
2156                 all_args = len(self.args)
2157                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2158                 positive_args = all_args - negative_args
2159                 if positive_args > negative_args:
2160                     return False
2161                 elif positive_args < negative_args:
2162                     return True
2163             elif self.is_Mul:
2164                 # We choose the one with an odd number of minus signs
2165                 num, den = self.as_numer_denom()
2166                 args = Mul.make_args(num) + Mul.make_args(den)
2167                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2168                 negative_args = list(filter(None, arg_signs))
2169                 return len(negative_args) % 2 == 1
2170 
2171             # As a last resort, we choose the one with greater value of .sort_key()
2172             return bool(self.sort_key() < negative_self.sort_key())
2173 
2174     def extract_branch_factor(self, allow_half=False):
2175         """
2176         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2177         Return (z, n).
2178 
2179         >>> from sympy import exp_polar, I, pi
2180         >>> from sympy.abc import x, y
2181         >>> exp_polar(I*pi).extract_branch_factor()
2182         (exp_polar(I*pi), 0)
2183         >>> exp_polar(2*I*pi).extract_branch_factor()
2184         (1, 1)
2185         >>> exp_polar(-pi*I).extract_branch_factor()
2186         (exp_polar(I*pi), -1)
2187         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2188         (exp_polar(x + I*pi), 1)
2189         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2190         (y*exp_polar(2*pi*x), -1)
2191         >>> exp_polar(-I*pi/2).extract_branch_factor()
2192         (exp_polar(-I*pi/2), 0)
2193 
2194         If allow_half is True, also extract exp_polar(I*pi):
2195 
2196         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2197         (1, 1/2)
2198         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2199         (1, 1)
2200         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2201         (1, 3/2)
2202         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2203         (1, -1/2)
2204         """
2205         from sympy import exp_polar, pi, I, ceiling, Add
2206         n = S(0)
2207         res = S(1)
2208         args = Mul.make_args(self)
2209         exps = []
2210         for arg in args:
2211             if arg.func is exp_polar:
2212                 exps += [arg.exp]
2213             else:
2214                 res *= arg
2215         piimult = S(0)
2216         extras = []
2217         while exps:
2218             exp = exps.pop()
2219             if exp.is_Add:
2220                 exps += exp.args
2221                 continue
2222             if exp.is_Mul:
2223                 coeff = exp.as_coefficient(pi*I)
2224                 if coeff is not None:
2225                     piimult += coeff
2226                     continue
2227             extras += [exp]
2228         if not piimult.free_symbols:
2229             coeff = piimult
2230             tail = ()
2231         else:
2232             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2233         # round down to nearest multiple of 2
2234         branchfact = ceiling(coeff/2 - S(1)/2)*2
2235         n += branchfact/2
2236         c = coeff - branchfact
2237         if allow_half:
2238             nc = c.extract_additively(1)
2239             if nc is not None:
2240                 n += S(1)/2
2241                 c = nc
2242         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2243         if newexp != 0:
2244             res *= exp_polar(newexp)
2245         return res, n
2246 
2247     def _eval_is_polynomial(self, syms):
2248         if self.free_symbols.intersection(syms) == set([]):
2249             return True
2250         return False
2251 
2252     def is_polynomial(self, *syms):
2253         """
2254         Return True if self is a polynomial in syms and False otherwise.
2255 
2256         This checks if self is an exact polynomial in syms.  This function
2257         returns False for expressions that are "polynomials" with symbolic
2258         exponents.  Thus, you should be able to apply polynomial algorithms to
2259         expressions for which this returns True, and Poly(expr, \*syms) should
2260         work if and only if expr.is_polynomial(\*syms) returns True. The
2261         polynomial does not have to be in expanded form.  If no symbols are
2262         given, all free symbols in the expression will be used.
2263 
2264         This is not part of the assumptions system.  You cannot do
2265         Symbol('z', polynomial=True).
2266 
2267         Examples
2268         ========
2269 
2270         >>> from sympy import Symbol
2271         >>> x = Symbol('x')
2272         >>> ((x**2 + 1)**4).is_polynomial(x)
2273         True
2274         >>> ((x**2 + 1)**4).is_polynomial()
2275         True
2276         >>> (2**x + 1).is_polynomial(x)
2277         False
2278 
2279 
2280         >>> n = Symbol('n', nonnegative=True, integer=True)
2281         >>> (x**n + 1).is_polynomial(x)
2282         False
2283 
2284         This function does not attempt any nontrivial simplifications that may
2285         result in an expression that does not appear to be a polynomial to
2286         become one.
2287 
2288         >>> from sympy import sqrt, factor, cancel
2289         >>> y = Symbol('y', positive=True)
2290         >>> a = sqrt(y**2 + 2*y + 1)
2291         >>> a.is_polynomial(y)
2292         False
2293         >>> factor(a)
2294         y + 1
2295         >>> factor(a).is_polynomial(y)
2296         True
2297 
2298         >>> b = (y**2 + 2*y + 1)/(y + 1)
2299         >>> b.is_polynomial(y)
2300         False
2301         >>> cancel(b)
2302         y + 1
2303         >>> cancel(b).is_polynomial(y)
2304         True
2305 
2306         See also .is_rational_function()
2307 
2308         """
2309         if syms:
2310             syms = set(map(sympify, syms))
2311         else:
2312             syms = self.free_symbols
2313 
2314         if syms.intersection(self.free_symbols) == set([]):
2315             # constant polynomial
2316             return True
2317         else:
2318             return self._eval_is_polynomial(syms)
2319 
2320     def _eval_is_rational_function(self, syms):
2321         if self.free_symbols.intersection(syms) == set([]):
2322             return True
2323         return False
2324 
2325     def is_rational_function(self, *syms):
2326         """
2327         Test whether function is a ratio of two polynomials in the given
2328         symbols, syms. When syms is not given, all free symbols will be used.
2329         The rational function does not have to be in expanded or in any kind of
2330         canonical form.
2331 
2332         This function returns False for expressions that are "rational
2333         functions" with symbolic exponents.  Thus, you should be able to call
2334         .as_numer_denom() and apply polynomial algorithms to the result for
2335         expressions for which this returns True.
2336 
2337         This is not part of the assumptions system.  You cannot do
2338         Symbol('z', rational_function=True).
2339 
2340         Examples
2341         ========
2342 
2343         >>> from sympy import Symbol, sin
2344         >>> from sympy.abc import x, y
2345 
2346         >>> (x/y).is_rational_function()
2347         True
2348 
2349         >>> (x**2).is_rational_function()
2350         True
2351 
2352         >>> (x/sin(y)).is_rational_function(y)
2353         False
2354 
2355         >>> n = Symbol('n', integer=True)
2356         >>> (x**n + 1).is_rational_function(x)
2357         False
2358 
2359         This function does not attempt any nontrivial simplifications that may
2360         result in an expression that does not appear to be a rational function
2361         to become one.
2362 
2363         >>> from sympy import sqrt, factor
2364         >>> y = Symbol('y', positive=True)
2365         >>> a = sqrt(y**2 + 2*y + 1)/y
2366         >>> a.is_rational_function(y)
2367         False
2368         >>> factor(a)
2369         (y + 1)/y
2370         >>> factor(a).is_rational_function(y)
2371         True
2372 
2373         See also is_algebraic_expr().
2374 
2375         """
2376         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2377             return False
2378 
2379         if syms:
2380             syms = set(map(sympify, syms))
2381         else:
2382             syms = self.free_symbols
2383 
2384         if syms.intersection(self.free_symbols) == set([]):
2385             # constant rational function
2386             return True
2387         else:
2388             return self._eval_is_rational_function(syms)
2389 
2390     def _eval_is_algebraic_expr(self, syms):
2391         if self.free_symbols.intersection(syms) == set([]):
2392             return True
2393         return False
2394 
2395     def is_algebraic_expr(self, *syms):
2396         """
2397         This tests whether a given expression is algebraic or not, in the
2398         given symbols, syms. When syms is not given, all free symbols
2399         will be used. The rational function does not have to be in expanded
2400         or in any kind of canonical form.
2401 
2402         This function returns False for expressions that are "algebraic
2403         expressions" with symbolic exponents. This is a simple extension to the
2404         is_rational_function, including rational exponentiation.
2405 
2406         Examples
2407         ========
2408 
2409         >>> from sympy import Symbol, sqrt
2410         >>> x = Symbol('x', real=True)
2411         >>> sqrt(1 + x).is_rational_function()
2412         False
2413         >>> sqrt(1 + x).is_algebraic_expr()
2414         True
2415 
2416         This function does not attempt any nontrivial simplifications that may
2417         result in an expression that does not appear to be an algebraic
2418         expression to become one.
2419 
2420         >>> from sympy import exp, factor
2421         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2422         >>> a.is_algebraic_expr(x)
2423         False
2424         >>> factor(a).is_algebraic_expr()
2425         True
2426 
2427         See Also
2428         ========
2429         is_rational_function()
2430 
2431         References
2432         ==========
2433 
2434         - http://en.wikipedia.org/wiki/Algebraic_expression
2435 
2436         """
2437         if syms:
2438             syms = set(map(sympify, syms))
2439         else:
2440             syms = self.free_symbols
2441 
2442         if syms.intersection(self.free_symbols) == set([]):
2443             # constant algebraic expression
2444             return True
2445         else:
2446             return self._eval_is_algebraic_expr(syms)
2447 
2448     ###################################################################################
2449     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2450     ###################################################################################
2451 
2452     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2453         """
2454         Series expansion of "self" around ``x = x0`` yielding either terms of
2455         the series one by one (the lazy series given when n=None), else
2456         all the terms at once when n != None.
2457 
2458         Returns the series expansion of "self" around the point ``x = x0``
2459         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2460 
2461         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2462         be supplied, otherwise an error will be raised.
2463 
2464         >>> from sympy import cos, exp
2465         >>> from sympy.abc import x, y
2466         >>> cos(x).series()
2467         1 - x**2/2 + x**4/24 + O(x**6)
2468         >>> cos(x).series(n=4)
2469         1 - x**2/2 + O(x**4)
2470         >>> cos(x).series(x, x0=1, n=2)
2471         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2472         >>> e = cos(x + exp(y))
2473         >>> e.series(y, n=2)
2474         cos(x + 1) - y*sin(x + 1) + O(y**2)
2475         >>> e.series(x, n=2)
2476         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2477 
2478         If ``n=None`` then a generator of the series terms will be returned.
2479 
2480         >>> term=cos(x).series(n=None)
2481         >>> [next(term) for i in range(2)]
2482         [1, -x**2/2]
2483 
2484         For ``dir=+`` (default) the series is calculated from the right and
2485         for ``dir=-`` the series from the left. For smooth functions this
2486         flag will not alter the results.
2487 
2488         >>> abs(x).series(dir="+")
2489         x
2490         >>> abs(x).series(dir="-")
2491         -x
2492 
2493         """
2494         from sympy import collect, Dummy, Order, Rational, Symbol
2495         if x is None:
2496             syms = self.atoms(Symbol)
2497             if not syms:
2498                 return self
2499             elif len(syms) > 1:
2500                 raise ValueError('x must be given for multivariate functions.')
2501             x = syms.pop()
2502 
2503         if not self.has(x):
2504             if n is None:
2505                 return (s for s in [self])
2506             else:
2507                 return self
2508 
2509         if len(dir) != 1 or dir not in '+-':
2510             raise ValueError("Dir must be '+' or '-'")
2511 
2512         if x0 in [S.Infinity, S.NegativeInfinity]:
2513             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]
2514             s = self.subs(x, 1/x).series(x, n=n, dir=dir)
2515             if n is None:
2516                 return (si.subs(x, 1/x) for si in s)
2517             return s.subs(x, 1/x)
2518 
2519         # use rep to shift origin to x0 and change sign (if dir is negative)
2520         # and undo the process with rep2
2521         if x0 or dir == '-':
2522             if dir == '-':
2523                 rep = -x + x0
2524                 rep2 = -x
2525                 rep2b = x0
2526             else:
2527                 rep = x + x0
2528                 rep2 = x
2529                 rep2b = -x0
2530             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2531             if n is None:  # lseries...
2532                 return (si.subs(x, rep2 + rep2b) for si in s)
2533             return s.subs(x, rep2 + rep2b)
2534 
2535         # from here on it's x0=0 and dir='+' handling
2536 
2537         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2538             # replace x with an x that has a positive assumption
2539             xpos = Dummy('x', positive=True, finite=True)
2540             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2541             if n is None:
2542                 return (s.subs(xpos, x) for s in rv)
2543             else:
2544                 return rv.subs(xpos, x)
2545 
2546         if n is not None:  # nseries handling
2547             s1 = self._eval_nseries(x, n=n, logx=logx)
2548             o = s1.getO() or S.Zero
2549             if o:
2550                 # make sure the requested order is returned
2551                 ngot = o.getn()
2552                 if ngot > n:
2553                     # leave o in its current form (e.g. with x*log(x)) so
2554                     # it eats terms properly, then replace it below
2555                     if n != 0:
2556                         s1 += o.subs(x, x**Rational(n, ngot))
2557                     else:
2558                         s1 += Order(1, x)
2559                 elif ngot < n:
2560                     # increase the requested number of terms to get the desired
2561                     # number keep increasing (up to 9) until the received order
2562                     # is different than the original order and then predict how
2563                     # many additional terms are needed
2564                     for more in range(1, 9):
2565                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2566                         newn = s1.getn()
2567                         if newn != ngot:
2568                             ndo = n + (n - ngot)*more/(newn - ngot)
2569                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2570                             while s1.getn() < n:
2571                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2572                                 ndo += 1
2573                             break
2574                     else:
2575                         raise ValueError('Could not calculate %s terms for %s'
2576                                          % (str(n), self))
2577                     s1 += Order(x**n, x)
2578                 o = s1.getO()
2579                 s1 = s1.removeO()
2580             else:
2581                 o = Order(x**n, x)
2582                 s1done = s1.doit()
2583                 if (s1done + o).removeO() == s1done:
2584                     o = S.Zero
2585 
2586             try:
2587                 return collect(s1, x) + o
2588             except NotImplementedError:
2589                 return s1 + o
2590 
2591         else:  # lseries handling
2592             def yield_lseries(s):
2593                 """Return terms of lseries one at a time."""
2594                 for si in s:
2595                     if not si.is_Add:
2596                         yield si
2597                         continue
2598                     # yield terms 1 at a time if possible
2599                     # by increasing order until all the
2600                     # terms have been returned
2601                     yielded = 0
2602                     o = Order(si, x)*x
2603                     ndid = 0
2604                     ndo = len(si.args)
2605                     while 1:
2606                         do = (si - yielded + o).removeO()
2607                         o *= x
2608                         if not do or do.is_Order:
2609                             continue
2610                         if do.is_Add:
2611                             ndid += len(do.args)
2612                         else:
2613                             ndid += 1
2614                         yield do
2615                         if ndid == ndo:
2616                             break
2617                         yielded += do
2618 
2619             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2620 
2621     def taylor_term(self, n, x, *previous_terms):
2622         """General method for the taylor term.
2623 
2624         This method is slow, because it differentiates n-times. Subclasses can
2625         redefine it to make it faster by using the "previous_terms".
2626         """
2627         from sympy import Dummy, factorial
2628         x = sympify(x)
2629         _x = Dummy('x')
2630         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2631 
2632     def lseries(self, x=None, x0=0, dir='+', logx=None):
2633         """
2634         Wrapper for series yielding an iterator of the terms of the series.
2635 
2636         Note: an infinite series will yield an infinite iterator. The following,
2637         for exaxmple, will never terminate. It will just keep printing terms
2638         of the sin(x) series::
2639 
2640           for term in sin(x).lseries(x):
2641               print term
2642 
2643         The advantage of lseries() over nseries() is that many times you are
2644         just interested in the next term in the series (i.e. the first term for
2645         example), but you don't know how many you should ask for in nseries()
2646         using the "n" parameter.
2647 
2648         See also nseries().
2649         """
2650         return self.series(x, x0, n=None, dir=dir, logx=logx)
2651 
2652     def _eval_lseries(self, x, logx=None):
2653         # default implementation of lseries is using nseries(), and adaptively
2654         # increasing the "n". As you can see, it is not very efficient, because
2655         # we are calculating the series over and over again. Subclasses should
2656         # override this method and implement much more efficient yielding of
2657         # terms.
2658         n = 0
2659         series = self._eval_nseries(x, n=n, logx=logx)
2660         if not series.is_Order:
2661             if series.is_Add:
2662                 yield series.removeO()
2663             else:
2664                 yield series
2665             return
2666 
2667         while series.is_Order:
2668             n += 1
2669             series = self._eval_nseries(x, n=n, logx=logx)
2670         e = series.removeO()
2671         yield e
2672         while 1:
2673             while 1:
2674                 n += 1
2675                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2676                 if e != series:
2677                     break
2678             yield series - e
2679             e = series
2680 
2681     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2682         """
2683         Wrapper to _eval_nseries if assumptions allow, else to series.
2684 
2685         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2686         called. This calculates "n" terms in the innermost expressions and
2687         then builds up the final series just by "cross-multiplying" everything
2688         out.
2689 
2690         The optional ``logx`` parameter can be used to replace any log(x) in the
2691         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2692         symbol to use in place of log(x) should be provided.
2693 
2694         Advantage -- it's fast, because we don't have to determine how many
2695         terms we need to calculate in advance.
2696 
2697         Disadvantage -- you may end up with less terms than you may have
2698         expected, but the O(x**n) term appended will always be correct and
2699         so the result, though perhaps shorter, will also be correct.
2700 
2701         If any of those assumptions is not met, this is treated like a
2702         wrapper to series which will try harder to return the correct
2703         number of terms.
2704 
2705         See also lseries().
2706 
2707         Examples
2708         ========
2709 
2710         >>> from sympy import sin, log, Symbol
2711         >>> from sympy.abc import x, y
2712         >>> sin(x).nseries(x, 0, 6)
2713         x - x**3/6 + x**5/120 + O(x**6)
2714         >>> log(x+1).nseries(x, 0, 5)
2715         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2716 
2717         Handling of the ``logx`` parameter --- in the following example the
2718         expansion fails since ``sin`` does not have an asymptotic expansion
2719         at -oo (the limit of log(x) as x approaches 0):
2720 
2721         >>> e = sin(log(x))
2722         >>> e.nseries(x, 0, 6)
2723         Traceback (most recent call last):
2724         ...
2725         PoleError: ...
2726         ...
2727         >>> logx = Symbol('logx')
2728         >>> e.nseries(x, 0, 6, logx=logx)
2729         sin(logx)
2730 
2731         In the following example, the expansion works but gives only an Order term
2732         unless the ``logx`` parameter is used:
2733 
2734         >>> e = x**y
2735         >>> e.nseries(x, 0, 2)
2736         O(log(x)**2)
2737         >>> e.nseries(x, 0, 2, logx=logx)
2738         exp(logx*y)
2739 
2740         """
2741         if x and not x in self.free_symbols:
2742             return self
2743         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2744             return self.series(x, x0, n, dir)
2745         else:
2746             return self._eval_nseries(x, n=n, logx=logx)
2747 
2748     def _eval_nseries(self, x, n, logx):
2749         """
2750         Return terms of series for self up to O(x**n) at x=0
2751         from the positive direction.
2752 
2753         This is a method that should be overridden in subclasses. Users should
2754         never call this method directly (use .nseries() instead), so you don't
2755         have to write docstrings for _eval_nseries().
2756         """
2757         from sympy.utilities.misc import filldedent
2758         raise NotImplementedError(filldedent("""
2759                      The _eval_nseries method should be added to
2760                      %s to give terms up to O(x**n) at x=0
2761                      from the positive direction so it is available when
2762                      nseries calls it.""" % self.func)
2763                      )
2764 
2765     def limit(self, x, xlim, dir='+'):
2766         """ Compute limit x->xlim.
2767         """
2768         from sympy.series.limits import limit
2769         return limit(self, x, xlim, dir)
2770 
2771     def compute_leading_term(self, x, logx=None):
2772         """
2773         as_leading_term is only allowed for results of .series()
2774         This is a wrapper to compute a series first.
2775         """
2776         from sympy import Dummy, log
2777         from sympy.series.gruntz import calculate_series
2778 
2779         if self.removeO() == 0:
2780             return self
2781 
2782         if logx is None:
2783             d = Dummy('logx')
2784             s = calculate_series(self, x, d).subs(d, log(x))
2785         else:
2786             s = calculate_series(self, x, logx)
2787 
2788         return s.as_leading_term(x)
2789 
2790     @cacheit
2791     def as_leading_term(self, *symbols):
2792         """
2793         Returns the leading (nonzero) term of the series expansion of self.
2794 
2795         The _eval_as_leading_term routines are used to do this, and they must
2796         always return a non-zero value.
2797 
2798         Examples
2799         ========
2800 
2801         >>> from sympy.abc import x
2802         >>> (1 + x + x**2).as_leading_term(x)
2803         1
2804         >>> (1/x**2 + x + x**2).as_leading_term(x)
2805         x**(-2)
2806 
2807         """
2808         from sympy import powsimp
2809         if len(symbols) > 1:
2810             c = self
2811             for x in symbols:
2812                 c = c.as_leading_term(x)
2813             return c
2814         elif not symbols:
2815             return self
2816         x = sympify(symbols[0])
2817         if not x.is_Symbol:
2818             raise ValueError('expecting a Symbol but got %s' % x)
2819         if x not in self.free_symbols:
2820             return self
2821         obj = self._eval_as_leading_term(x)
2822         if obj is not None:
2823             return powsimp(obj, deep=True, combine='exp')
2824         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
2825 
2826     def _eval_as_leading_term(self, x):
2827         return self
2828 
2829     def as_coeff_exponent(self, x):
2830         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
2831         """
2832         from sympy import collect
2833         s = collect(self, x)
2834         c, p = s.as_coeff_mul(x)
2835         if len(p) == 1:
2836             b, e = p[0].as_base_exp()
2837             if b == x:
2838                 return c, e
2839         return s, S.Zero
2840 
2841     def leadterm(self, x):
2842         """
2843         Returns the leading term a*x**b as a tuple (a, b).
2844 
2845         Examples
2846         ========
2847 
2848         >>> from sympy.abc import x
2849         >>> (1+x+x**2).leadterm(x)
2850         (1, 0)
2851         >>> (1/x**2+x+x**2).leadterm(x)
2852         (1, -2)
2853 
2854         """
2855         from sympy import Dummy, log
2856         l = self.as_leading_term(x)
2857         d = Dummy('logx')
2858         if l.has(log(x)):
2859             l = l.subs(log(x), d)
2860         c, e = l.as_coeff_exponent(x)
2861         if x in c.free_symbols:
2862             from sympy.utilities.misc import filldedent
2863             raise ValueError(filldedent("""
2864                 cannot compute leadterm(%s, %s). The coefficient
2865                 should have been free of x but got %s""" % (self, x, c)))
2866         c = c.subs(d, log(x))
2867         return c, e
2868 
2869     def as_coeff_Mul(self, rational=False):
2870         """Efficiently extract the coefficient of a product. """
2871         return S.One, self
2872 
2873     def as_coeff_Add(self, rational=False):
2874         """Efficiently extract the coefficient of a summation. """
2875         return S.Zero, self
2876 
2877     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
2878             full=False):
2879         """
2880         Compute formal power power series of self.
2881 
2882         See the docstring of the :func:`fps` function in sympy.series.formal for
2883         more information.
2884         """
2885         from sympy.series.formal import fps
2886 
2887         return fps(self, x, x0, dir, hyper, order, rational, full)
2888 
2889     def fourier_series(self, limits=None):
2890         """Compute fourier sine/cosine series of self.
2891 
2892         See the docstring of the :func:`fourier_series` in sympy.series.fourier
2893         for more information.
2894         """
2895         from sympy.series.fourier import fourier_series
2896 
2897         return fourier_series(self, limits)
2898 
2899     ###################################################################################
2900     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
2901     ###################################################################################
2902 
2903     def diff(self, *symbols, **assumptions):
2904         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z
2905         assumptions.setdefault("evaluate", True)
2906         return Derivative(self, *new_symbols, **assumptions)
2907 
2908     ###########################################################################
2909     ###################### EXPRESSION EXPANSION METHODS #######################
2910     ###########################################################################
2911 
2912     # Relevant subclasses should override _eval_expand_hint() methods.  See
2913     # the docstring of expand() for more info.
2914 
2915     def _eval_expand_complex(self, **hints):
2916         real, imag = self.as_real_imag(**hints)
2917         return real + S.ImaginaryUnit*imag
2918 
2919     @staticmethod
2920     def _expand_hint(expr, hint, deep=True, **hints):
2921         """
2922         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
2923 
2924         Returns ``(expr, hit)``, where expr is the (possibly) expanded
2925         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
2926         ``False`` otherwise.
2927         """
2928         hit = False
2929         # XXX: Hack to support non-Basic args
2930         #              |
2931         #              V
2932         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
2933             sargs = []
2934             for arg in expr.args:
2935                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
2936                 hit |= arghit
2937                 sargs.append(arg)
2938 
2939             if hit:
2940                 expr = expr.func(*sargs)
2941 
2942         if hasattr(expr, hint):
2943             newexpr = getattr(expr, hint)(**hints)
2944             if newexpr != expr:
2945                 return (newexpr, True)
2946 
2947         return (expr, hit)
2948 
2949     @cacheit
2950     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
2951             mul=True, log=True, multinomial=True, basic=True, **hints):
2952         """
2953         Expand an expression using hints.
2954 
2955         See the docstring of the expand() function in sympy.core.function for
2956         more information.
2957 
2958         """
2959         from sympy.simplify.radsimp import fraction
2960 
2961         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
2962            log=log, multinomial=multinomial, basic=basic)
2963 
2964         expr = self
2965         if hints.pop('frac', False):
2966             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
2967                     for a in fraction(self)]
2968             return n/d
2969         elif hints.pop('denom', False):
2970             n, d = fraction(self)
2971             return n/d.expand(deep=deep, modulus=modulus, **hints)
2972         elif hints.pop('numer', False):
2973             n, d = fraction(self)
2974             return n.expand(deep=deep, modulus=modulus, **hints)/d
2975 
2976         # Although the hints are sorted here, an earlier hint may get applied
2977         # at a given node in the expression tree before another because of how
2978         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
2979         # x*z) because while applying log at the top level, log and mul are
2980         # applied at the deeper level in the tree so that when the log at the
2981         # upper level gets applied, the mul has already been applied at the
2982         # lower level.
2983 
2984         # Additionally, because hints are only applied once, the expression
2985         # may not be expanded all the way.   For example, if mul is applied
2986         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
2987         # now, we just use a special case to make multinomial run before mul,
2988         # so that at least polynomials will be expanded all the way.  In the
2989         # future, smarter heuristics should be applied.
2990         # TODO: Smarter heuristics
2991 
2992         def _expand_hint_key(hint):
2993             """Make multinomial come before mul"""
2994             if hint == 'mul':
2995                 return 'mulz'
2996             return hint
2997 
2998         for hint in sorted(hints.keys(), key=_expand_hint_key):
2999             use_hint = hints[hint]
3000             if use_hint:
3001                 hint = '_eval_expand_' + hint
3002                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3003 
3004         while True:
3005             was = expr
3006             if hints.get('multinomial', False):
3007                 expr, _ = Expr._expand_hint(
3008                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3009             if hints.get('mul', False):
3010                 expr, _ = Expr._expand_hint(
3011                     expr, '_eval_expand_mul', deep=deep, **hints)
3012             if hints.get('log', False):
3013                 expr, _ = Expr._expand_hint(
3014                     expr, '_eval_expand_log', deep=deep, **hints)
3015             if expr == was:
3016                 break
3017 
3018         if modulus is not None:
3019             modulus = sympify(modulus)
3020 
3021             if not modulus.is_Integer or modulus <= 0:
3022                 raise ValueError(
3023                     "modulus must be a positive integer, got %s" % modulus)
3024 
3025             terms = []
3026 
3027             for term in Add.make_args(expr):
3028                 coeff, tail = term.as_coeff_Mul(rational=True)
3029 
3030                 coeff %= modulus
3031 
3032                 if coeff:
3033                     terms.append(coeff*tail)
3034 
3035             expr = Add(*terms)
3036 
3037         return expr
3038 
3039     ###########################################################################
3040     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3041     ###########################################################################
3042 
3043     def integrate(self, *args, **kwargs):
3044         """See the integrate function in sympy.integrals"""
3045         from sympy.integrals import integrate
3046         return integrate(self, *args, **kwargs)
3047 
3048     def simplify(self, ratio=1.7, measure=None):
3049         """See the simplify function in sympy.simplify"""
3050         from sympy.simplify import simplify
3051         from sympy.core.function import count_ops
3052         measure = measure or count_ops
3053         return simplify(self, ratio, measure)
3054 
3055     def nsimplify(self, constants=[], tolerance=None, full=False):
3056         """See the nsimplify function in sympy.simplify"""
3057         from sympy.simplify import nsimplify
3058         return nsimplify(self, constants, tolerance, full)
3059 
3060     def separate(self, deep=False, force=False):
3061         """See the separate function in sympy.simplify"""
3062         from sympy.core.function import expand_power_base
3063         return expand_power_base(self, deep=deep, force=force)
3064 
3065     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3066         """See the collect function in sympy.simplify"""
3067         from sympy.simplify import collect
3068         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3069 
3070     def together(self, *args, **kwargs):
3071         """See the together function in sympy.polys"""
3072         from sympy.polys import together
3073         return together(self, *args, **kwargs)
3074 
3075     def apart(self, x=None, **args):
3076         """See the apart function in sympy.polys"""
3077         from sympy.polys import apart
3078         return apart(self, x, **args)
3079 
3080     def ratsimp(self):
3081         """See the ratsimp function in sympy.simplify"""
3082         from sympy.simplify import ratsimp
3083         return ratsimp(self)
3084 
3085     def trigsimp(self, **args):
3086         """See the trigsimp function in sympy.simplify"""
3087         from sympy.simplify import trigsimp
3088         return trigsimp(self, **args)
3089 
3090     def radsimp(self, **kwargs):
3091         """See the radsimp function in sympy.simplify"""
3092         from sympy.simplify import radsimp
3093         return radsimp(self, **kwargs)
3094 
3095     def powsimp(self, *args, **kwargs):
3096         """See the powsimp function in sympy.simplify"""
3097         from sympy.simplify import powsimp
3098         return powsimp(self, *args, **kwargs)
3099 
3100     def combsimp(self):
3101         """See the combsimp function in sympy.simplify"""
3102         from sympy.simplify import combsimp
3103         return combsimp(self)
3104 
3105     def factor(self, *gens, **args):
3106         """See the factor() function in sympy.polys.polytools"""
3107         from sympy.polys import factor
3108         return factor(self, *gens, **args)
3109 
3110     def refine(self, assumption=True):
3111         """See the refine function in sympy.assumptions"""
3112         from sympy.assumptions import refine
3113         return refine(self, assumption)
3114 
3115     def cancel(self, *gens, **args):
3116         """See the cancel function in sympy.polys"""
3117         from sympy.polys import cancel
3118         return cancel(self, *gens, **args)
3119 
3120     def invert(self, g, *gens, **args):
3121         """Return the multiplicative inverse of ``self`` mod ``g``
3122         where ``self`` (and ``g``) may be symbolic expressions).
3123 
3124         See Also
3125         ========
3126         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3127         """
3128         from sympy.polys.polytools import invert
3129         from sympy.core.numbers import mod_inverse
3130         if self.is_number and getattr(g, 'is_number', True):
3131             return mod_inverse(self, g)
3132         return invert(self, g, *gens, **args)
3133 
3134     def round(self, p=0):
3135         """Return x rounded to the given decimal place.
3136 
3137         If a complex number would results, apply round to the real
3138         and imaginary components of the number.
3139 
3140         Examples
3141         ========
3142 
3143         >>> from sympy import pi, E, I, S, Add, Mul, Number
3144         >>> S(10.5).round()
3145         11.
3146         >>> pi.round()
3147         3.
3148         >>> pi.round(2)
3149         3.14
3150         >>> (2*pi + E*I).round()
3151         6. + 3.*I
3152 
3153         The round method has a chopping effect:
3154 
3155         >>> (2*pi + I/10).round()
3156         6.
3157         >>> (pi/10 + 2*I).round()
3158         2.*I
3159         >>> (pi/10 + E*I).round(2)
3160         0.31 + 2.72*I
3161 
3162         Notes
3163         =====
3164 
3165         Do not confuse the Python builtin function, round, with the
3166         SymPy method of the same name. The former always returns a float
3167         (or raises an error if applied to a complex value) while the
3168         latter returns either a Number or a complex number:
3169 
3170         >>> isinstance(round(S(123), -2), Number)
3171         False
3172         >>> isinstance(S(123).round(-2), Number)
3173         True
3174         >>> isinstance((3*I).round(), Mul)
3175         True
3176         >>> isinstance((1 + 3*I).round(), Add)
3177         True
3178 
3179         """
3180         from sympy import Float
3181         x = self
3182         if not x.is_number:
3183             raise TypeError("can't round symbolic expression")
3184         if not x.is_Atom:
3185             xn = x.n(2)
3186             if not pure_complex(xn, or_real=True):
3187                 raise TypeError('Expected a number but got %s:' %
3188                     getattr(getattr(x,'func', x), '__name__', type(x)))
3189         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3190             return x
3191         if not x.is_real:
3192             i, r = x.as_real_imag()
3193             return i.round(p) + S.ImaginaryUnit*r.round(p)
3194         if not x:
3195             return x
3196         p = int(p)
3197 
3198         precs = [f._prec for f in x.atoms(Float)]
3199         dps = prec_to_dps(max(precs)) if precs else None
3200 
3201         mag_first_dig = _mag(x)
3202         allow = digits_needed = mag_first_dig + p
3203         if dps is not None and allow > dps:
3204             allow = dps
3205         mag = Pow(10, p)  # magnitude needed to bring digit p to units place
3206         xwas = x
3207         x += 1/(2*mag)  # add the half for rounding
3208         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3209         if i10.is_negative:
3210             x = xwas - 1/(2*mag)  # should have gone the other way
3211             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3212             rv = -(Integer(-i10)//10)
3213         else:
3214             rv = Integer(i10)//10
3215         q = 1
3216         if p > 0:
3217             q = mag
3218         elif p < 0:
3219             rv /= mag
3220         rv = Rational(rv, q)
3221         if rv.is_Integer:
3222             # use str or else it won't be a float
3223             return Float(str(rv), digits_needed)
3224         else:
3225             if not allow and rv > self:
3226                 allow += 1
3227             return Float(rv, allow)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 07:37:52.550 | INFO     | Search completed. Bug locations: [<file>sympy/core/expr.py</file>
<class>Expr</class>
<method>extract_multiplicatively</method>
<code>
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)

</code><intended_behavior>The issue appears to arise because the method cannot correctly handle the extraction when faced with expressions that are assembled using Mul with evaluate=False, particularly when trying to extract a factor from a product that is negated or involves negation. The intended behavior is for extract_multiplicatively to: - Properly recognize and facilitate the extraction of multiplicatively inverse elements especially in cases where the expression and the factor share a negation, such as attempting to extract -2 from (-2*x - 4*y - 8). - Preserve existing functionality for all other use cases, ensuring no regression or unintended side effects on the current capabilities of the method. This involves possibly addressing how non-evaluated Mul expressions are treated by the method, ensuring that factors can be extracted whether or not the expression has been evaluated. - Consider enhancing the method to handle cases where the common factor is spread across terms in the expression, possibly by improving the logic that interacts with primitive or the handling of evaluated vs. non-evaluated expressions.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     @property
33     def _diff_wrt(self):
34         """Is it allowed to take derivative wrt to this instance.
35 
36         This determines if it is allowed to take derivatives wrt this object.
37         Subclasses such as Symbol, Function and Derivative should return True
38         to enable derivatives wrt them. The implementation in Derivative
39         separates the Symbol and non-Symbol _diff_wrt=True variables and
40         temporarily converts the non-Symbol vars in Symbols when performing
41         the differentiation.
42 
43         Note, see the docstring of Derivative for how this should work
44         mathematically. In particular, note that expr.subs(yourclass, Symbol)
45         should be well-defined on a structural level, or this will lead to
46         inconsistent results.
47 
48         Examples
49         ========
50 
51         >>> from sympy import Expr
52         >>> e = Expr()
53         >>> e._diff_wrt
54         False
55         >>> class MyClass(Expr):
56         ...     _diff_wrt = True
57         ...
58         >>> (2*MyClass()).diff(MyClass())
59         2
60         """
61         return False
62 
63     @cacheit
64     def sort_key(self, order=None):
65 
66         coeff, expr = self.as_coeff_Mul()
67 
68         if expr.is_Pow:
69             expr, exp = expr.args
70         else:
71             expr, exp = expr, S.One
72 
73         if expr.is_Dummy:
74             args = (expr.sort_key(),)
75         elif expr.is_Atom:
76             args = (str(expr),)
77         else:
78             if expr.is_Add:
79                 args = expr.as_ordered_terms(order=order)
80             elif expr.is_Mul:
81                 args = expr.as_ordered_factors(order=order)
82             else:
83                 args = expr.args
84 
85             args = tuple(
86                 [ default_sort_key(arg, order=order) for arg in args ])
87 
88         args = (len(args), tuple(args))
89         exp = exp.sort_key(order=order)
90 
91         return expr.class_key(), args, exp, coeff
92 
93     # ***************
94     # * Arithmetics *
95     # ***************
96     # Expr and its sublcasses use _op_priority to determine which object
97     # passed to a binary special method (__mul__, etc.) will handle the
98     # operation. In general, the 'call_highest_priority' decorator will choose
99     # the object with the highest _op_priority to handle the call.
100     # Custom subclasses that want to define their own binary special methods
101     # should set an _op_priority value that is higher than the default.
102     #
103     # **NOTE**:
104     # This is a temporary fix, and will eventually be replaced with
105     # something better and more powerful.  See issue 5510.
106     _op_priority = 10.0
107 
108     def __pos__(self):
109         return self
110 
111     def __neg__(self):
112         return Mul(S.NegativeOne, self)
113 
114     def __abs__(self):
115         from sympy import Abs
116         return Abs(self)
117 
118     @_sympifyit('other', NotImplemented)
119     @call_highest_priority('__radd__')
120     def __add__(self, other):
121         return Add(self, other)
122 
123     @_sympifyit('other', NotImplemented)
124     @call_highest_priority('__add__')
125     def __radd__(self, other):
126         return Add(other, self)
127 
128     @_sympifyit('other', NotImplemented)
129     @call_highest_priority('__rsub__')
130     def __sub__(self, other):
131         return Add(self, -other)
132 
133     @_sympifyit('other', NotImplemented)
134     @call_highest_priority('__sub__')
135     def __rsub__(self, other):
136         return Add(other, -self)
137 
138     @_sympifyit('other', NotImplemented)
139     @call_highest_priority('__rmul__')
140     def __mul__(self, other):
141         return Mul(self, other)
142 
143     @_sympifyit('other', NotImplemented)
144     @call_highest_priority('__mul__')
145     def __rmul__(self, other):
146         return Mul(other, self)
147 
148     @_sympifyit('other', NotImplemented)
149     @call_highest_priority('__rpow__')
150     def __pow__(self, other):
151         return Pow(self, other)
152 
153     @_sympifyit('other', NotImplemented)
154     @call_highest_priority('__pow__')
155     def __rpow__(self, other):
156         return Pow(other, self)
157 
158     @_sympifyit('other', NotImplemented)
159     @call_highest_priority('__rdiv__')
160     def __div__(self, other):
161         return Mul(self, Pow(other, S.NegativeOne))
162 
163     @_sympifyit('other', NotImplemented)
164     @call_highest_priority('__div__')
165     def __rdiv__(self, other):
166         return Mul(other, Pow(self, S.NegativeOne))
167 
168     __truediv__ = __div__
169     __rtruediv__ = __rdiv__
170 
171     @_sympifyit('other', NotImplemented)
172     @call_highest_priority('__rmod__')
173     def __mod__(self, other):
174         return Mod(self, other)
175 
176     @_sympifyit('other', NotImplemented)
177     @call_highest_priority('__mod__')
178     def __rmod__(self, other):
179         return Mod(other, self)
180 
181     @_sympifyit('other', NotImplemented)
182     @call_highest_priority('__rfloordiv__')
183     def __floordiv__(self, other):
184         from sympy.functions.elementary.integers import floor
185         return floor(self / other)
186 
187     @_sympifyit('other', NotImplemented)
188     @call_highest_priority('__floordiv__')
189     def __rfloordiv__(self, other):
190         from sympy.functions.elementary.integers import floor
191         return floor(self / other)
192 
193     def __int__(self):
194         # Although we only need to round to the units position, we'll
195         # get one more digit so the extra testing below can be avoided
196         # unless the rounded value rounded to an integer, e.g. if an
197         # expression were equal to 1.9 and we rounded to the unit position
198         # we would get a 2 and would not know if this rounded up or not
199         # without doing a test (as done below). But if we keep an extra
200         # digit we know that 1.9 is not the same as 1 and there is no
201         # need for further testing: our int value is correct. If the value
202         # were 1.99, however, this would round to 2.0 and our int value is
203         # off by one. So...if our round value is the same as the int value
204         # (regardless of how much extra work we do to calculate extra decimal
205         # places) we need to test whether we are off by one.
206         from sympy import Dummy
207         if not self.is_number:
208             raise TypeError("can't convert symbols to int")
209         r = self.round(2)
210         if not r.is_Number:
211             raise TypeError("can't convert complex to int")
212         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
213             raise TypeError("can't convert %s to int" % r)
214         i = int(r)
215         if not i:
216             return 0
217         # off-by-one check
218         if i == r and not (self - i).equals(0):
219             isign = 1 if i > 0 else -1
220             x = Dummy()
221             # in the following (self - i).evalf(2) will not always work while
222             # (self - r).evalf(2) and the use of subs does; if the test that
223             # was added when this comment was added passes, it might be safe
224             # to simply use sign to compute this rather than doing this by hand:
225             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
226             if diff_sign != isign:
227                 i -= isign
228         return i
229     __long__ = __int__
230 
231     def __float__(self):
232         # Don't bother testing if it's a number; if it's not this is going
233         # to fail, and if it is we still need to check that it evalf'ed to
234         # a number.
235         result = self.evalf()
236         if result.is_Number:
237             return float(result)
238         if result.is_number and result.as_real_imag()[1]:
239             raise TypeError("can't convert complex to float")
240         raise TypeError("can't convert expression to float")
241 
242     def __complex__(self):
243         result = self.evalf()
244         re, im = result.as_real_imag()
245         return complex(float(re), float(im))
246 
247     def __ge__(self, other):
248         from sympy import GreaterThan
249         try:
250             other = _sympify(other)
251         except SympifyError:
252             raise TypeError("Invalid comparison %s >= %s" % (self, other))
253         for me in (self, other):
254             if (me.is_complex and me.is_real is False) or \
255                     me.has(S.ComplexInfinity):
256                 raise TypeError("Invalid comparison of complex %s" % me)
257             if me is S.NaN:
258                 raise TypeError("Invalid NaN comparison")
259         if self.is_real or other.is_real:
260             dif = self - other
261             if dif.is_nonnegative is not None and \
262                     dif.is_nonnegative is not dif.is_negative:
263                 return sympify(dif.is_nonnegative)
264         return GreaterThan(self, other, evaluate=False)
265 
266     def __le__(self, other):
267         from sympy import LessThan
268         try:
269             other = _sympify(other)
270         except SympifyError:
271             raise TypeError("Invalid comparison %s <= %s" % (self, other))
272         for me in (self, other):
273             if (me.is_complex and me.is_real is False) or \
274                     me.has(S.ComplexInfinity):
275                 raise TypeError("Invalid comparison of complex %s" % me)
276             if me is S.NaN:
277                 raise TypeError("Invalid NaN comparison")
278         if self.is_real or other.is_real:
279             dif = self - other
280             if dif.is_nonpositive is not None and \
281                     dif.is_nonpositive is not dif.is_positive:
282                 return sympify(dif.is_nonpositive)
283         return LessThan(self, other, evaluate=False)
284 
285     def __gt__(self, other):
286         from sympy import StrictGreaterThan
287         try:
288             other = _sympify(other)
289         except SympifyError:
290             raise TypeError("Invalid comparison %s > %s" % (self, other))
291         for me in (self, other):
292             if (me.is_complex and me.is_real is False) or \
293                     me.has(S.ComplexInfinity):
294                 raise TypeError("Invalid comparison of complex %s" % me)
295             if me is S.NaN:
296                 raise TypeError("Invalid NaN comparison")
297         if self.is_real or other.is_real:
298             dif = self - other
299             if dif.is_positive is not None and \
300                     dif.is_positive is not dif.is_nonpositive:
301                 return sympify(dif.is_positive)
302         return StrictGreaterThan(self, other, evaluate=False)
303 
304     def __lt__(self, other):
305         from sympy import StrictLessThan
306         try:
307             other = _sympify(other)
308         except SympifyError:
309             raise TypeError("Invalid comparison %s < %s" % (self, other))
310         for me in (self, other):
311             if (me.is_complex and me.is_real is False) or \
312                     me.has(S.ComplexInfinity):
313                 raise TypeError("Invalid comparison of complex %s" % me)
314             if me is S.NaN:
315                 raise TypeError("Invalid NaN comparison")
316         if self.is_real or other.is_real:
317             dif = self - other
318             if dif.is_negative is not None and \
319                     dif.is_negative is not dif.is_nonnegative:
320                 return sympify(dif.is_negative)
321         return StrictLessThan(self, other, evaluate=False)
322 
323     @staticmethod
324     def _from_mpmath(x, prec):
325         from sympy import Float
326         if hasattr(x, "_mpf_"):
327             return Float._new(x._mpf_, prec)
328         elif hasattr(x, "_mpc_"):
329             re, im = x._mpc_
330             re = Float._new(re, prec)
331             im = Float._new(im, prec)*S.ImaginaryUnit
332             return re + im
333         else:
334             raise TypeError("expected mpmath number (mpf or mpc)")
335 
336     @property
337     def is_number(self):
338         """Returns True if 'self' has no free symbols.
339         It will be faster than `if not self.free_symbols`, however, since
340         `is_number` will fail as soon as it hits a free symbol.
341 
342         Examples
343         ========
344 
345         >>> from sympy import log, Integral
346         >>> from sympy.abc import x
347 
348         >>> x.is_number
349         False
350         >>> (2*x).is_number
351         False
352         >>> (2 + log(2)).is_number
353         True
354         >>> (2 + Integral(2, x)).is_number
355         False
356         >>> (2 + Integral(2, (x, 1, 2))).is_number
357         True
358 
359         """
360         return all(obj.is_number for obj in self.args)
361 
362     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
363         """Return self evaluated, if possible, replacing free symbols with
364         random complex values, if necessary.
365 
366         The random complex value for each free symbol is generated
367         by the random_complex_number routine giving real and imaginary
368         parts in the range given by the re_min, re_max, im_min, and im_max
369         values. The returned value is evaluated to a precision of n
370         (if given) else the maximum of 15 and the precision needed
371         to get more than 1 digit of precision. If the expression
372         could not be evaluated to a number, or could not be evaluated
373         to more than 1 digit of precision, then None is returned.
374 
375         Examples
376         ========
377 
378         >>> from sympy import sqrt
379         >>> from sympy.abc import x, y
380         >>> x._random()                         # doctest: +SKIP
381         0.0392918155679172 + 0.916050214307199*I
382         >>> x._random(2)                        # doctest: +SKIP
383         -0.77 - 0.87*I
384         >>> (x + y/2)._random(2)                # doctest: +SKIP
385         -0.57 + 0.16*I
386         >>> sqrt(2)._random(2)
387         1.4
388 
389         See Also
390         ========
391 
392         sympy.utilities.randtest.random_complex_number
393         """
394 
395         free = self.free_symbols
396         prec = 1
397         if free:
398             from sympy.utilities.randtest import random_complex_number
399             a, c, b, d = re_min, re_max, im_min, im_max
400             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
401                            for zi in free])))
402             try:
403                 nmag = abs(self.evalf(2, subs=reps))
404             except (ValueError, TypeError):
405                 # if an out of range value resulted in evalf problems
406                 # then return None -- XXX is there a way to know how to
407                 # select a good random number for a given expression?
408                 # e.g. when calculating n! negative values for n should not
409                 # be used
410                 return None
411         else:
412             reps = {}
413             nmag = abs(self.evalf(2))
414 
415         if not hasattr(nmag, '_prec'):
416             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
417             return None
418 
419         if nmag._prec == 1:
420             # increase the precision up to the default maximum
421             # precision to see if we can get any significance
422 
423             from mpmath.libmp.libintmath import giant_steps
424             from sympy.core.evalf import DEFAULT_MAXPREC as target
425 
426             # evaluate
427             for prec in giant_steps(2, target):
428                 nmag = abs(self.evalf(prec, subs=reps))
429                 if nmag._prec != 1:
430                     break
431 
432         if nmag._prec != 1:
433             if n is None:
434                 n = max(prec, 15)
435             return self.evalf(n, subs=reps)
436 
437         # never got any significance
438         return None
439 
440     def is_constant(self, *wrt, **flags):
441         """Return True if self is constant, False if not, or None if
442         the constancy could not be determined conclusively.
443 
444         If an expression has no free symbols then it is a constant. If
445         there are free symbols it is possible that the expression is a
446         constant, perhaps (but not necessarily) zero. To test such
447         expressions, two strategies are tried:
448 
449         1) numerical evaluation at two random points. If two such evaluations
450         give two different values and the values have a precision greater than
451         1 then self is not constant. If the evaluations agree or could not be
452         obtained with any precision, no decision is made. The numerical testing
453         is done only if ``wrt`` is different than the free symbols.
454 
455         2) differentiation with respect to variables in 'wrt' (or all free
456         symbols if omitted) to see if the expression is constant or not. This
457         will not always lead to an expression that is zero even though an
458         expression is constant (see added test in test_expr.py). If
459         all derivatives are zero then self is constant with respect to the
460         given symbols.
461 
462         If neither evaluation nor differentiation can prove the expression is
463         constant, None is returned unless two numerical values happened to be
464         the same and the flag ``failing_number`` is True -- in that case the
465         numerical value will be returned.
466 
467         If flag simplify=False is passed, self will not be simplified;
468         the default is True since self should be simplified before testing.
469 
470         Examples
471         ========
472 
473         >>> from sympy import cos, sin, Sum, S, pi
474         >>> from sympy.abc import a, n, x, y
475         >>> x.is_constant()
476         False
477         >>> S(2).is_constant()
478         True
479         >>> Sum(x, (x, 1, 10)).is_constant()
480         True
481         >>> Sum(x, (x, 1, n)).is_constant()
482         False
483         >>> Sum(x, (x, 1, n)).is_constant(y)
484         True
485         >>> Sum(x, (x, 1, n)).is_constant(n)
486         False
487         >>> Sum(x, (x, 1, n)).is_constant(x)
488         True
489         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
490         >>> eq.is_constant()
491         True
492         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
493         True
494 
495         >>> (0**x).is_constant()
496         False
497         >>> x.is_constant()
498         False
499         >>> (x**x).is_constant()
500         False
501         >>> one = cos(x)**2 + sin(x)**2
502         >>> one.is_constant()
503         True
504         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
505         True
506         """
507 
508         simplify = flags.get('simplify', True)
509 
510         # Except for expressions that contain units, only one of these should
511         # be necessary since if something is
512         # known to be a number it should also know that there are no
513         # free symbols. But is_number quits as soon as it hits a non-number
514         # whereas free_symbols goes until all free symbols have been collected,
515         # thus is_number should be faster. But a double check on free symbols
516         # is made just in case there is a discrepancy between the two.
517         free = self.free_symbols
518         if self.is_number or not free:
519             # if the following assertion fails then that object's free_symbols
520             # method needs attention: if an expression is a number it cannot
521             # have free symbols
522             assert not free
523             return True
524 
525         # if we are only interested in some symbols and they are not in the
526         # free symbols then this expression is constant wrt those symbols
527         wrt = set(wrt)
528         if wrt and not wrt & free:
529             return True
530         wrt = wrt or free
531 
532         # simplify unless this has already been done
533         expr = self
534         if simplify:
535             expr = expr.simplify()
536 
537         # is_zero should be a quick assumptions check; it can be wrong for
538         # numbers (see test_is_not_constant test), giving False when it
539         # shouldn't, but hopefully it will never give True unless it is sure.
540         if expr.is_zero:
541             return True
542 
543         # try numerical evaluation to see if we get two different values
544         failing_number = None
545         if wrt == free:
546             # try 0 (for a) and 1 (for b)
547             try:
548                 a = expr.subs(list(zip(free, [0]*len(free))),
549                     simultaneous=True)
550                 if a is S.NaN:
551                     # evaluation may succeed when substitution fails
552                     a = expr._random(None, 0, 0, 0, 0)
553             except ZeroDivisionError:
554                 a = None
555             if a is not None and a is not S.NaN:
556                 try:
557                     b = expr.subs(list(zip(free, [1]*len(free))),
558                         simultaneous=True)
559                     if b is S.NaN:
560                         # evaluation may succeed when substitution fails
561                         b = expr._random(None, 1, 0, 1, 0)
562                 except ZeroDivisionError:
563                     b = None
564                 if b is not None and b is not S.NaN and b.equals(a) is False:
565                     return False
566                 # try random real
567                 b = expr._random(None, -1, 0, 1, 0)
568                 if b is not None and b is not S.NaN and b.equals(a) is False:
569                     return False
570                 # try random complex
571                 b = expr._random()
572                 if b is not None and b is not S.NaN:
573                     if b.equals(a) is False:
574                         return False
575                     failing_number = a if a.is_number else b
576 
577         # now we will test each wrt symbol (or all free symbols) to see if the
578         # expression depends on them or not using differentiation. This is
579         # not sufficient for all expressions, however, so we don't return
580         # False if we get a derivative other than 0 with free symbols.
581         for w in wrt:
582             deriv = expr.diff(w)
583             if simplify:
584                 deriv = deriv.simplify()
585             if deriv != 0:
586                 if not (pure_complex(deriv, or_real=True)):
587                     if flags.get('failing_number', False):
588                         return failing_number
589                     elif deriv.free_symbols:
590                         # dead line provided _random returns None in such cases
591                         return None
592                 return False
593         return True
594 
595     def equals(self, other, failing_expression=False):
596         """Return True if self == other, False if it doesn't, or None. If
597         failing_expression is True then the expression which did not simplify
598         to a 0 will be returned instead of None.
599 
600         If ``self`` is a Number (or complex number) that is not zero, then
601         the result is False.
602 
603         If ``self`` is a number and has not evaluated to zero, evalf will be
604         used to test whether the expression evaluates to zero. If it does so
605         and the result has significance (i.e. the precision is either -1, for
606         a Rational result, or is greater than 1) then the evalf value will be
607         used to return True or False.
608 
609         """
610         from sympy.simplify.simplify import nsimplify, simplify
611         from sympy.solvers.solveset import solveset
612         from sympy.polys.polyerrors import NotAlgebraic
613         from sympy.polys.numberfields import minimal_polynomial
614 
615         other = sympify(other)
616         if self == other:
617             return True
618 
619         # they aren't the same so see if we can make the difference 0;
620         # don't worry about doing simplification steps one at a time
621         # because if the expression ever goes to 0 then the subsequent
622         # simplification steps that are done will be very fast.
623         diff = factor_terms(simplify(self - other), radical=True)
624 
625         if not diff:
626             return True
627 
628         if not diff.has(Add, Mod):
629             # if there is no expanding to be done after simplifying
630             # then this can't be a zero
631             return False
632 
633         constant = diff.is_constant(simplify=False, failing_number=True)
634 
635         if constant is False:
636             return False
637 
638         if constant is None and (diff.free_symbols or not diff.is_number):
639             # e.g. unless the right simplification is done, a symbolic
640             # zero is possible (see expression of issue 6829: without
641             # simplification constant will be None).
642             return
643 
644         if constant is True:
645             ndiff = diff._random()
646             if ndiff:
647                 return False
648 
649         # sometimes we can use a simplified result to give a clue as to
650         # what the expression should be; if the expression is *not* zero
651         # then we should have been able to compute that and so now
652         # we can just consider the cases where the approximation appears
653         # to be zero -- we try to prove it via minimal_polynomial.
654         if diff.is_number:
655             approx = diff.nsimplify()
656             if not approx:
657                 # try to prove via self-consistency
658                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
659                 # it seems to work better to try big ones first
660                 surds.sort(key=lambda x: -x.args[0])
661                 for s in surds:
662                     try:
663                         # simplify is False here -- this expression has already
664                         # been identified as being hard to identify as zero;
665                         # we will handle the checking ourselves using nsimplify
666                         # to see if we are in the right ballpark or not and if so
667                         # *then* the simplification will be attempted.
668                         if s.is_Symbol:
669                             sol = list(solveset(diff, s))
670                         else:
671                             sol = [s]
672                         if sol:
673                             if s in sol:
674                                 return True
675                             if s.is_real:
676                                 if any(nsimplify(si, [s]) == s and simplify(si) == s
677                                         for si in sol):
678                                     return True
679                     except NotImplementedError:
680                         pass
681 
682                 # try to prove with minimal_polynomial but know when
683                 # *not* to use this or else it can take a long time. e.g. issue 8354
684                 if True:  # change True to condition that assures non-hang
685                     try:
686                         mp = minimal_polynomial(diff)
687                         if mp.is_Symbol:
688                             return True
689                         return False
690                     except (NotAlgebraic, NotImplementedError):
691                         pass
692 
693         # diff has not simplified to zero; constant is either None, True
694         # or the number with significance (prec != 1) that was randomly
695         # calculated twice as the same value.
696         if constant not in (True, None) and constant != 0:
697             return False
698 
699         if failing_expression:
700             return diff
701         return None
702 
703     def _eval_is_positive(self):
704         from sympy.polys.numberfields import minimal_polynomial
705         from sympy.polys.polyerrors import NotAlgebraic
706         if self.is_number:
707             if self.is_real is False:
708                 return False
709             try:
710                 # check to see that we can get a value
711                 n2 = self._eval_evalf(2)
712                 if n2 is None:
713                     raise AttributeError
714                 if n2._prec == 1:  # no significance
715                     raise AttributeError
716                 if n2 == S.NaN:
717                     raise AttributeError
718             except (AttributeError, ValueError):
719                 return None
720             n, i = self.evalf(2).as_real_imag()
721             if not i.is_Number or not n.is_Number:
722                 return False
723             if n._prec != 1 and i._prec != 1:
724                 return bool(not i and n > 0)
725             elif n._prec == 1 and (not i or i._prec == 1) and \
726                     self.is_algebraic and not self.has(Function):
727                 try:
728                     if minimal_polynomial(self).is_Symbol:
729                         return False
730                 except (NotAlgebraic, NotImplementedError):
731                     pass
732 
733     def _eval_is_negative(self):
734         from sympy.polys.numberfields import minimal_polynomial
735         from sympy.polys.polyerrors import NotAlgebraic
736         if self.is_number:
737             if self.is_real is False:
738                 return False
739             try:
740                 # check to see that we can get a value
741                 n2 = self._eval_evalf(2)
742                 if n2 is None:
743                     raise AttributeError
744                 if n2._prec == 1:  # no significance
745                     raise AttributeError
746                 if n2 == S.NaN:
747                     raise AttributeError
748             except (AttributeError, ValueError):
749                 return None
750             n, i = self.evalf(2).as_real_imag()
751             if not i.is_Number or not n.is_Number:
752                 return False
753             if n._prec != 1 and i._prec != 1:
754                 return bool(not i and n < 0)
755             elif n._prec == 1 and (not i or i._prec == 1) and \
756                     self.is_algebraic and not self.has(Function):
757                 try:
758                     if minimal_polynomial(self).is_Symbol:
759                         return False
760                 except (NotAlgebraic, NotImplementedError):
761                     pass
762 
763     def _eval_interval(self, x, a, b):
764         """
765         Returns evaluation over an interval.  For most functions this is:
766 
767         self.subs(x, b) - self.subs(x, a),
768 
769         possibly using limit() if NaN is returned from subs.
770 
771         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
772         respectively.
773 
774         """
775         from sympy.series import limit, Limit
776         from sympy.solvers.solveset import solveset
777 
778         if (a is None and b is None):
779             raise ValueError('Both interval ends cannot be None.')
780 
781         if a == b:
782             return 0;
783 
784         if a is None:
785             A = 0
786         else:
787             A = self.subs(x, a)
788             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
789                 if (a < b) != False:
790                     A = limit(self, x, a,"+")
791                 else:
792                     A = limit(self, x, a,"-")
793 
794                 if A is S.NaN:
795                     return A
796                 if isinstance(A, Limit):
797                     raise NotImplementedError("Could not compute limit")
798 
799         if b is None:
800             B = 0
801         else:
802             B = self.subs(x, b)
803             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
804                 if (a < b) != False:
805                     B = limit(self, x, b,"-")
806                 else:
807                     B = limit(self, x, b,"+")
808 
809                 if isinstance(B, Limit):
810                     raise NotImplementedError("Could not compute limit")
811 
812         if (a and b) is None:
813             return B - A
814 
815         value = B - A
816 
817         if a.is_comparable and b.is_comparable:
818             singularities = list(solveset(self.cancel().as_numer_denom()[1], x))
819             for s in singularities:
820                 if a < s < b:
821                     value += -limit(self, x, s, "+") + limit(self, x, s, "-")
822                 elif b < s < a:
823                     value += limit(self, x, s, "+") - limit(self, x, s, "-")
824 
825         return value
826 
827     def _eval_power(self, other):
828         # subclass to compute self**other for cases when
829         # other is not NaN, 0, or 1
830         return None
831 
832     def _eval_conjugate(self):
833         if self.is_real:
834             return self
835         elif self.is_imaginary:
836             return -self
837 
838     def conjugate(self):
839         from sympy.functions.elementary.complexes import conjugate as c
840         return c(self)
841 
842     def _eval_transpose(self):
843         from sympy.functions.elementary.complexes import conjugate
844         if self.is_complex:
845             return self
846         elif self.is_hermitian:
847             return conjugate(self)
848         elif self.is_antihermitian:
849             return -conjugate(self)
850 
851     def transpose(self):
852         from sympy.functions.elementary.complexes import transpose
853         return transpose(self)
854 
855     def _eval_adjoint(self):
856         from sympy.functions.elementary.complexes import conjugate, transpose
857         if self.is_hermitian:
858             return self
859         elif self.is_antihermitian:
860             return -self
861         obj = self._eval_conjugate()
862         if obj is not None:
863             return transpose(obj)
864         obj = self._eval_transpose()
865         if obj is not None:
866             return conjugate(obj)
867 
868     def adjoint(self):
869         from sympy.functions.elementary.complexes import adjoint
870         return adjoint(self)
871 
872     @classmethod
873     def _parse_order(cls, order):
874         """Parse and configure the ordering of terms. """
875         from sympy.polys.orderings import monomial_key
876 
877         try:
878             reverse = order.startswith('rev-')
879         except AttributeError:
880             reverse = False
881         else:
882             if reverse:
883                 order = order[4:]
884 
885         monom_key = monomial_key(order)
886 
887         def neg(monom):
888             result = []
889 
890             for m in monom:
891                 if isinstance(m, tuple):
892                     result.append(neg(m))
893                 else:
894                     result.append(-m)
895 
896             return tuple(result)
897 
898         def key(term):
899             _, ((re, im), monom, ncpart) = term
900 
901             monom = neg(monom_key(monom))
902             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
903             coeff = ((bool(im), im), (re, im))
904 
905             return monom, ncpart, coeff
906 
907         return key, reverse
908 
909     def as_ordered_factors(self, order=None):
910         """Return list of ordered factors (if Mul) else [self]."""
911         return [self]
912 
913     def as_ordered_terms(self, order=None, data=False):
914         """
915         Transform an expression to an ordered list of terms.
916 
917         Examples
918         ========
919 
920         >>> from sympy import sin, cos
921         >>> from sympy.abc import x
922 
923         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
924         [sin(x)**2*cos(x), sin(x)**2, 1]
925 
926         """
927         key, reverse = self._parse_order(order)
928         terms, gens = self.as_terms()
929 
930         if not any(term.is_Order for term, _ in terms):
931             ordered = sorted(terms, key=key, reverse=reverse)
932         else:
933             _terms, _order = [], []
934 
935             for term, repr in terms:
936                 if not term.is_Order:
937                     _terms.append((term, repr))
938                 else:
939                     _order.append((term, repr))
940 
941             ordered = sorted(_terms, key=key, reverse=True) \
942                 + sorted(_order, key=key, reverse=True)
943 
944         if data:
945             return ordered, gens
946         else:
947             return [term for term, _ in ordered]
948 
949     def as_terms(self):
950         """Transform an expression to a list of terms. """
951         from .add import Add
952         from .mul import Mul
953         from .exprtools import decompose_power
954 
955         gens, terms = set([]), []
956 
957         for term in Add.make_args(self):
958             coeff, _term = term.as_coeff_Mul()
959 
960             coeff = complex(coeff)
961             cpart, ncpart = {}, []
962 
963             if _term is not S.One:
964                 for factor in Mul.make_args(_term):
965                     if factor.is_number:
966                         try:
967                             coeff *= complex(factor)
968                         except TypeError:
969                             pass
970                         else:
971                             continue
972 
973                     if factor.is_commutative:
974                         base, exp = decompose_power(factor)
975 
976                         cpart[base] = exp
977                         gens.add(base)
978                     else:
979                         ncpart.append(factor)
980 
981             coeff = coeff.real, coeff.imag
982             ncpart = tuple(ncpart)
983 
984             terms.append((term, (coeff, cpart, ncpart)))
985 
986         gens = sorted(gens, key=default_sort_key)
987 
988         k, indices = len(gens), {}
989 
990         for i, g in enumerate(gens):
991             indices[g] = i
992 
993         result = []
994 
995         for term, (coeff, cpart, ncpart) in terms:
996             monom = [0]*k
997 
998             for base, exp in cpart.items():
999                 monom[indices[base]] = exp
1000 
1001             result.append((term, (coeff, tuple(monom), ncpart)))
1002 
1003         return result, gens
1004 
1005     def removeO(self):
1006         """Removes the additive O(..) symbol if there is one"""
1007         return self
1008 
1009     def getO(self):
1010         """Returns the additive O(..) symbol if there is one, else None."""
1011         return None
1012 
1013     def getn(self):
1014         """
1015         Returns the order of the expression.
1016 
1017         The order is determined either from the O(...) term. If there
1018         is no O(...) term, it returns None.
1019 
1020         Examples
1021         ========
1022 
1023         >>> from sympy import O
1024         >>> from sympy.abc import x
1025         >>> (1 + x + O(x**2)).getn()
1026         2
1027         >>> (1 + x).getn()
1028 
1029         """
1030         from sympy import Dummy, Symbol
1031         o = self.getO()
1032         if o is None:
1033             return None
1034         elif o.is_Order:
1035             o = o.expr
1036             if o is S.One:
1037                 return S.Zero
1038             if o.is_Symbol:
1039                 return S.One
1040             if o.is_Pow:
1041                 return o.args[1]
1042             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1043                 for oi in o.args:
1044                     if oi.is_Symbol:
1045                         return S.One
1046                     if oi.is_Pow:
1047                         syms = oi.atoms(Symbol)
1048                         if len(syms) == 1:
1049                             x = syms.pop()
1050                             oi = oi.subs(x, Dummy('x', positive=True))
1051                             if oi.base.is_Symbol and oi.exp.is_Rational:
1052                                 return abs(oi.exp)
1053 
1054         raise NotImplementedError('not sure of order of %s' % o)
1055 
1056     def count_ops(self, visual=None):
1057         """wrapper for count_ops that returns the operation count."""
1058         from .function import count_ops
1059         return count_ops(self, visual)
1060 
1061     def args_cnc(self, cset=False, warn=True, split_1=True):
1062         """Return [commutative factors, non-commutative factors] of self.
1063 
1064         self is treated as a Mul and the ordering of the factors is maintained.
1065         If ``cset`` is True the commutative factors will be returned in a set.
1066         If there were repeated factors (as may happen with an unevaluated Mul)
1067         then an error will be raised unless it is explicitly supressed by
1068         setting ``warn`` to False.
1069 
1070         Note: -1 is always separated from a Number unless split_1 is False.
1071 
1072         >>> from sympy import symbols, oo
1073         >>> A, B = symbols('A B', commutative=False)
1074         >>> x, y = symbols('x y')
1075         >>> (-2*x*y).args_cnc()
1076         [[-1, 2, x, y], []]
1077         >>> (-2.5*x).args_cnc()
1078         [[-1, 2.5, x], []]
1079         >>> (-2*x*A*B*y).args_cnc()
1080         [[-1, 2, x, y], [A, B]]
1081         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1082         [[-2, x, y], [A, B]]
1083         >>> (-2*x*y).args_cnc(cset=True)
1084         [{-1, 2, x, y}, []]
1085 
1086         The arg is always treated as a Mul:
1087 
1088         >>> (-2 + x + A).args_cnc()
1089         [[], [x - 2 + A]]
1090         >>> (-oo).args_cnc() # -oo is a singleton
1091         [[-1, oo], []]
1092         """
1093 
1094         if self.is_Mul:
1095             args = list(self.args)
1096         else:
1097             args = [self]
1098         for i, mi in enumerate(args):
1099             if not mi.is_commutative:
1100                 c = args[:i]
1101                 nc = args[i:]
1102                 break
1103         else:
1104             c = args
1105             nc = []
1106 
1107         if c and split_1 and (
1108             c[0].is_Number and
1109             c[0].is_negative and
1110                 c[0] is not S.NegativeOne):
1111             c[:1] = [S.NegativeOne, -c[0]]
1112 
1113         if cset:
1114             clen = len(c)
1115             c = set(c)
1116             if clen and warn and len(c) != clen:
1117                 raise ValueError('repeated commutative arguments: %s' %
1118                                  [ci for ci in c if list(self.args).count(ci) > 1])
1119         return [c, nc]
1120 
1121     def coeff(self, x, n=1, right=False):
1122         """
1123         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1124         is zero then all terms independent of ``x`` will be returned.
1125 
1126         When ``x`` is noncommutative, the coefficient to the left (default) or
1127         right of ``x`` can be returned. The keyword 'right' is ignored when
1128         ``x`` is commutative.
1129 
1130         See Also
1131         ========
1132 
1133         as_coefficient: separate the expression into a coefficient and factor
1134         as_coeff_Add: separate the additive constant from an expression
1135         as_coeff_Mul: separate the multiplicative constant from an expression
1136         as_independent: separate x-dependent terms/factors from others
1137         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1138         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1139 
1140         Examples
1141         ========
1142 
1143         >>> from sympy import symbols
1144         >>> from sympy.abc import x, y, z
1145 
1146         You can select terms that have an explicit negative in front of them:
1147 
1148         >>> (-x + 2*y).coeff(-1)
1149         x
1150         >>> (x - 2*y).coeff(-1)
1151         2*y
1152 
1153         You can select terms with no Rational coefficient:
1154 
1155         >>> (x + 2*y).coeff(1)
1156         x
1157         >>> (3 + 2*x + 4*x**2).coeff(1)
1158         0
1159 
1160         You can select terms independent of x by making n=0; in this case
1161         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1162         of None):
1163 
1164         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1165         3
1166         >>> eq = ((x + 1)**3).expand() + 1
1167         >>> eq
1168         x**3 + 3*x**2 + 3*x + 2
1169         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1170         [1, 3, 3, 2]
1171         >>> eq -= 2
1172         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1173         [1, 3, 3, 0]
1174 
1175         You can select terms that have a numerical term in front of them:
1176 
1177         >>> (-x - 2*y).coeff(2)
1178         -y
1179         >>> from sympy import sqrt
1180         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1181         x
1182 
1183         The matching is exact:
1184 
1185         >>> (3 + 2*x + 4*x**2).coeff(x)
1186         2
1187         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1188         4
1189         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1190         0
1191         >>> (z*(x + y)**2).coeff((x + y)**2)
1192         z
1193         >>> (z*(x + y)**2).coeff(x + y)
1194         0
1195 
1196         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1197         from the following:
1198 
1199         >>> (x + z*(x + x*y)).coeff(x)
1200         1
1201 
1202         If such factoring is desired, factor_terms can be used first:
1203 
1204         >>> from sympy import factor_terms
1205         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1206         z*(y + 1) + 1
1207 
1208         >>> n, m, o = symbols('n m o', commutative=False)
1209         >>> n.coeff(n)
1210         1
1211         >>> (3*n).coeff(n)
1212         3
1213         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1214         1 + m
1215         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1216         m
1217 
1218         If there is more than one possible coefficient 0 is returned:
1219 
1220         >>> (n*m + m*n).coeff(n)
1221         0
1222 
1223         If there is only one possible coefficient, it is returned:
1224 
1225         >>> (n*m + x*m*n).coeff(m*n)
1226         x
1227         >>> (n*m + x*m*n).coeff(m*n, right=1)
1228         1
1229 
1230         """
1231         x = sympify(x)
1232         if not isinstance(x, Basic):
1233             return S.Zero
1234 
1235         n = as_int(n)
1236 
1237         if not x:
1238             return S.Zero
1239 
1240         if x == self:
1241             if n == 1:
1242                 return S.One
1243             return S.Zero
1244 
1245         if x is S.One:
1246             co = [a for a in Add.make_args(self)
1247                   if a.as_coeff_Mul()[0] is S.One]
1248             if not co:
1249                 return S.Zero
1250             return Add(*co)
1251 
1252         if n == 0:
1253             if x.is_Add and self.is_Add:
1254                 c = self.coeff(x, right=right)
1255                 if not c:
1256                     return S.Zero
1257                 if not right:
1258                     return self - Add(*[a*x for a in Add.make_args(c)])
1259                 return self - Add(*[x*a for a in Add.make_args(c)])
1260             return self.as_independent(x, as_Add=True)[0]
1261 
1262         # continue with the full method, looking for this power of x:
1263         x = x**n
1264 
1265         def incommon(l1, l2):
1266             if not l1 or not l2:
1267                 return []
1268             n = min(len(l1), len(l2))
1269             for i in range(n):
1270                 if l1[i] != l2[i]:
1271                     return l1[:i]
1272             return l1[:]
1273 
1274         def find(l, sub, first=True):
1275             """ Find where list sub appears in list l. When ``first`` is True
1276             the first occurance from the left is returned, else the last
1277             occurance is returned. Return None if sub is not in l.
1278 
1279             >> l = range(5)*2
1280             >> find(l, [2, 3])
1281             2
1282             >> find(l, [2, 3], first=0)
1283             7
1284             >> find(l, [2, 4])
1285             None
1286 
1287             """
1288             if not sub or not l or len(sub) > len(l):
1289                 return None
1290             n = len(sub)
1291             if not first:
1292                 l.reverse()
1293                 sub.reverse()
1294             for i in range(0, len(l) - n + 1):
1295                 if all(l[i + j] == sub[j] for j in range(n)):
1296                     break
1297             else:
1298                 i = None
1299             if not first:
1300                 l.reverse()
1301                 sub.reverse()
1302             if i is not None and not first:
1303                 i = len(l) - (i + n)
1304             return i
1305 
1306         co = []
1307         args = Add.make_args(self)
1308         self_c = self.is_commutative
1309         x_c = x.is_commutative
1310         if self_c and not x_c:
1311             return S.Zero
1312 
1313         if self_c:
1314             xargs = x.args_cnc(cset=True, warn=False)[0]
1315             for a in args:
1316                 margs = a.args_cnc(cset=True, warn=False)[0]
1317                 if len(xargs) > len(margs):
1318                     continue
1319                 resid = margs.difference(xargs)
1320                 if len(resid) + len(xargs) == len(margs):
1321                     co.append(Mul(*resid))
1322             if co == []:
1323                 return S.Zero
1324             elif co:
1325                 return Add(*co)
1326         elif x_c:
1327             xargs = x.args_cnc(cset=True, warn=False)[0]
1328             for a in args:
1329                 margs, nc = a.args_cnc(cset=True)
1330                 if len(xargs) > len(margs):
1331                     continue
1332                 resid = margs.difference(xargs)
1333                 if len(resid) + len(xargs) == len(margs):
1334                     co.append(Mul(*(list(resid) + nc)))
1335             if co == []:
1336                 return S.Zero
1337             elif co:
1338                 return Add(*co)
1339         else:  # both nc
1340             xargs, nx = x.args_cnc(cset=True)
1341             # find the parts that pass the commutative terms
1342             for a in args:
1343                 margs, nc = a.args_cnc(cset=True)
1344                 if len(xargs) > len(margs):
1345                     continue
1346                 resid = margs.difference(xargs)
1347                 if len(resid) + len(xargs) == len(margs):
1348                     co.append((resid, nc))
1349             # now check the non-comm parts
1350             if not co:
1351                 return S.Zero
1352             if all(n == co[0][1] for r, n in co):
1353                 ii = find(co[0][1], nx, right)
1354                 if ii is not None:
1355                     if not right:
1356                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1357                     else:
1358                         return Mul(*co[0][1][ii + len(nx):])
1359             beg = reduce(incommon, (n[1] for n in co))
1360             if beg:
1361                 ii = find(beg, nx, right)
1362                 if ii is not None:
1363                     if not right:
1364                         gcdc = co[0][0]
1365                         for i in range(1, len(co)):
1366                             gcdc = gcdc.intersection(co[i][0])
1367                             if not gcdc:
1368                                 break
1369                         return Mul(*(list(gcdc) + beg[:ii]))
1370                     else:
1371                         m = ii + len(nx)
1372                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1373             end = list(reversed(
1374                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1375             if end:
1376                 ii = find(end, nx, right)
1377                 if ii is not None:
1378                     if not right:
1379                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1380                     else:
1381                         return Mul(*end[ii + len(nx):])
1382             # look for single match
1383             hit = None
1384             for i, (r, n) in enumerate(co):
1385                 ii = find(n, nx, right)
1386                 if ii is not None:
1387                     if not hit:
1388                         hit = ii, r, n
1389                     else:
1390                         break
1391             else:
1392                 if hit:
1393                     ii, r, n = hit
1394                     if not right:
1395                         return Mul(*(list(r) + n[:ii]))
1396                     else:
1397                         return Mul(*n[ii + len(nx):])
1398 
1399             return S.Zero
1400 
1401     def as_expr(self, *gens):
1402         """
1403         Convert a polynomial to a SymPy expression.
1404 
1405         Examples
1406         ========
1407 
1408         >>> from sympy import sin
1409         >>> from sympy.abc import x, y
1410 
1411         >>> f = (x**2 + x*y).as_poly(x, y)
1412         >>> f.as_expr()
1413         x**2 + x*y
1414 
1415         >>> sin(x).as_expr()
1416         sin(x)
1417 
1418         """
1419         return self
1420 
1421     def as_coefficient(self, expr):
1422         """
1423         Extracts symbolic coefficient at the given expression. In
1424         other words, this functions separates 'self' into the product
1425         of 'expr' and 'expr'-free coefficient. If such separation
1426         is not possible it will return None.
1427 
1428         Examples
1429         ========
1430 
1431         >>> from sympy import E, pi, sin, I, Poly
1432         >>> from sympy.abc import x
1433 
1434         >>> E.as_coefficient(E)
1435         1
1436         >>> (2*E).as_coefficient(E)
1437         2
1438         >>> (2*sin(E)*E).as_coefficient(E)
1439 
1440         Two terms have E in them so a sum is returned. (If one were
1441         desiring the coefficient of the term exactly matching E then
1442         the constant from the returned expression could be selected.
1443         Or, for greater precision, a method of Poly can be used to
1444         indicate the desired term from which the coefficient is
1445         desired.)
1446 
1447         >>> (2*E + x*E).as_coefficient(E)
1448         x + 2
1449         >>> _.args[0]  # just want the exact match
1450         2
1451         >>> p = Poly(2*E + x*E); p
1452         Poly(x*E + 2*E, x, E, domain='ZZ')
1453         >>> p.coeff_monomial(E)
1454         2
1455         >>> p.nth(0, 1)
1456         2
1457 
1458         Since the following cannot be written as a product containing
1459         E as a factor, None is returned. (If the coefficient ``2*x`` is
1460         desired then the ``coeff`` method should be used.)
1461 
1462         >>> (2*E*x + x).as_coefficient(E)
1463         >>> (2*E*x + x).coeff(E)
1464         2*x
1465 
1466         >>> (E*(x + 1) + x).as_coefficient(E)
1467 
1468         >>> (2*pi*I).as_coefficient(pi*I)
1469         2
1470         >>> (2*I).as_coefficient(pi*I)
1471 
1472         See Also
1473         ========
1474 
1475         coeff: return sum of terms have a given factor
1476         as_coeff_Add: separate the additive constant from an expression
1477         as_coeff_Mul: separate the multiplicative constant from an expression
1478         as_independent: separate x-dependent terms/factors from others
1479         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1480         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1481 
1482 
1483         """
1484 
1485         r = self.extract_multiplicatively(expr)
1486         if r and not r.has(expr):
1487             return r
1488 
1489     def as_independent(self, *deps, **hint):
1490         """
1491         A mostly naive separation of a Mul or Add into arguments that are not
1492         are dependent on deps. To obtain as complete a separation of variables
1493         as possible, use a separation method first, e.g.:
1494 
1495         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1496         * .expand(mul=True) to change Add or Mul into Add
1497         * .expand(log=True) to change log expr into an Add
1498 
1499         The only non-naive thing that is done here is to respect noncommutative
1500         ordering of variables and to always return (0, 0) for `self` of zero
1501         regardless of hints.
1502 
1503         For nonzero `self`, the returned tuple (i, d) has the
1504         following interpretation:
1505 
1506         * i will has no variable that appears in deps
1507         * d will be 1 or else have terms that contain variables that are in deps
1508         * if self is an Add then self = i + d
1509         * if self is a Mul then self = i*d
1510         * otherwise (self, S.One) or (S.One, self) is returned.
1511 
1512         To force the expression to be treated as an Add, use the hint as_Add=True
1513 
1514         Examples
1515         ========
1516 
1517         -- self is an Add
1518 
1519         >>> from sympy import sin, cos, exp
1520         >>> from sympy.abc import x, y, z
1521 
1522         >>> (x + x*y).as_independent(x)
1523         (0, x*y + x)
1524         >>> (x + x*y).as_independent(y)
1525         (x, x*y)
1526         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1527         (y + z, 2*x*sin(x) + x)
1528         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1529         (z, 2*x*sin(x) + x + y)
1530 
1531         -- self is a Mul
1532 
1533         >>> (x*sin(x)*cos(y)).as_independent(x)
1534         (cos(y), x*sin(x))
1535 
1536         non-commutative terms cannot always be separated out when self is a Mul
1537 
1538         >>> from sympy import symbols
1539         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1540         >>> (n1 + n1*n2).as_independent(n2)
1541         (n1, n1*n2)
1542         >>> (n2*n1 + n1*n2).as_independent(n2)
1543         (0, n1*n2 + n2*n1)
1544         >>> (n1*n2*n3).as_independent(n1)
1545         (1, n1*n2*n3)
1546         >>> (n1*n2*n3).as_independent(n2)
1547         (n1, n2*n3)
1548         >>> ((x-n1)*(x-y)).as_independent(x)
1549         (1, (x - y)*(x - n1))
1550 
1551         -- self is anything else:
1552 
1553         >>> (sin(x)).as_independent(x)
1554         (1, sin(x))
1555         >>> (sin(x)).as_independent(y)
1556         (sin(x), 1)
1557         >>> exp(x+y).as_independent(x)
1558         (1, exp(x + y))
1559 
1560         -- force self to be treated as an Add:
1561 
1562         >>> (3*x).as_independent(x, as_Add=True)
1563         (0, 3*x)
1564 
1565         -- force self to be treated as a Mul:
1566 
1567         >>> (3+x).as_independent(x, as_Add=False)
1568         (1, x + 3)
1569         >>> (-3+x).as_independent(x, as_Add=False)
1570         (1, x - 3)
1571 
1572         Note how the below differs from the above in making the
1573         constant on the dep term positive.
1574 
1575         >>> (y*(-3+x)).as_independent(x)
1576         (y, x - 3)
1577 
1578         -- use .as_independent() for true independence testing instead
1579            of .has(). The former considers only symbols in the free
1580            symbols while the latter considers all symbols
1581 
1582         >>> from sympy import Integral
1583         >>> I = Integral(x, (x, 1, 2))
1584         >>> I.has(x)
1585         True
1586         >>> x in I.free_symbols
1587         False
1588         >>> I.as_independent(x) == (I, 1)
1589         True
1590         >>> (I + x).as_independent(x) == (I, x)
1591         True
1592 
1593         Note: when trying to get independent terms, a separation method
1594         might need to be used first. In this case, it is important to keep
1595         track of what you send to this routine so you know how to interpret
1596         the returned values
1597 
1598         >>> from sympy import separatevars, log
1599         >>> separatevars(exp(x+y)).as_independent(x)
1600         (exp(y), exp(x))
1601         >>> (x + x*y).as_independent(y)
1602         (x, x*y)
1603         >>> separatevars(x + x*y).as_independent(y)
1604         (x, y + 1)
1605         >>> (x*(1 + y)).as_independent(y)
1606         (x, y + 1)
1607         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1608         (x, x*y)
1609         >>> a, b=symbols('a b', positive=True)
1610         >>> (log(a*b).expand(log=True)).as_independent(b)
1611         (log(a), log(b))
1612 
1613         See Also
1614         ========
1615         .separatevars(), .expand(log=True), Add.as_two_terms(),
1616         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1617         """
1618         from .symbol import Symbol
1619         from .add import _unevaluated_Add
1620         from .mul import _unevaluated_Mul
1621         from sympy.utilities.iterables import sift
1622 
1623         if self.is_zero:
1624             return S.Zero, S.Zero
1625 
1626         func = self.func
1627         if hint.get('as_Add', func is Add):
1628             want = Add
1629         else:
1630             want = Mul
1631 
1632         # sift out deps into symbolic and other and ignore
1633         # all symbols but those that are in the free symbols
1634         sym = set()
1635         other = []
1636         for d in deps:
1637             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1638                 sym.add(d)
1639             else:
1640                 other.append(d)
1641 
1642         def has(e):
1643             """return the standard has() if there are no literal symbols, else
1644             check to see that symbol-deps are in the free symbols."""
1645             has_other = e.has(*other)
1646             if not sym:
1647                 return has_other
1648             return has_other or e.has(*(e.free_symbols & sym))
1649 
1650         if (want is not func or
1651                 func is not Add and func is not Mul):
1652             if has(self):
1653                 return (want.identity, self)
1654             else:
1655                 return (self, want.identity)
1656         else:
1657             if func is Add:
1658                 args = list(self.args)
1659             else:
1660                 args, nc = self.args_cnc()
1661 
1662         d = sift(args, lambda x: has(x))
1663         depend = d[True]
1664         indep = d[False]
1665         if func is Add:  # all terms were treated as commutative
1666             return (Add(*indep), _unevaluated_Add(*depend))
1667         else:  # handle noncommutative by stopping at first dependent term
1668             for i, n in enumerate(nc):
1669                 if has(n):
1670                     depend.extend(nc[i:])
1671                     break
1672                 indep.append(n)
1673             return Mul(*indep), (
1674                 Mul(*depend, evaluate=False) if nc else
1675                 _unevaluated_Mul(*depend))
1676 
1677     def as_real_imag(self, deep=True, **hints):
1678         """Performs complex expansion on 'self' and returns a tuple
1679            containing collected both real and imaginary parts. This
1680            method can't be confused with re() and im() functions,
1681            which does not perform complex expansion at evaluation.
1682 
1683            However it is possible to expand both re() and im()
1684            functions and get exactly the same results as with
1685            a single call to this function.
1686 
1687            >>> from sympy import symbols, I
1688 
1689            >>> x, y = symbols('x,y', real=True)
1690 
1691            >>> (x + y*I).as_real_imag()
1692            (x, y)
1693 
1694            >>> from sympy.abc import z, w
1695 
1696            >>> (z + w*I).as_real_imag()
1697            (re(z) - im(w), re(w) + im(z))
1698 
1699         """
1700         from sympy import im, re
1701         if hints.get('ignore') == self:
1702             return None
1703         else:
1704             return (re(self), im(self))
1705 
1706     def as_powers_dict(self):
1707         """Return self as a dictionary of factors with each factor being
1708         treated as a power. The keys are the bases of the factors and the
1709         values, the corresponding exponents. The resulting dictionary should
1710         be used with caution if the expression is a Mul and contains non-
1711         commutative factors since the order that they appeared will be lost in
1712         the dictionary."""
1713         d = defaultdict(int)
1714         d.update(dict([self.as_base_exp()]))
1715         return d
1716 
1717     def as_coefficients_dict(self):
1718         """Return a dictionary mapping terms to their Rational coefficient.
1719         Since the dictionary is a defaultdict, inquiries about terms which
1720         were not present will return a coefficient of 0. If an expression is
1721         not an Add it is considered to have a single term.
1722 
1723         Examples
1724         ========
1725 
1726         >>> from sympy.abc import a, x
1727         >>> (3*x + a*x + 4).as_coefficients_dict()
1728         {1: 4, x: 3, a*x: 1}
1729         >>> _[a]
1730         0
1731         >>> (3*a*x).as_coefficients_dict()
1732         {a*x: 3}
1733 
1734         """
1735         c, m = self.as_coeff_Mul()
1736         if not c.is_Rational:
1737             c = S.One
1738             m = self
1739         d = defaultdict(int)
1740         d.update({m: c})
1741         return d
1742 
1743     def as_base_exp(self):
1744         # a -> b ** e
1745         return self, S.One
1746 
1747     def as_coeff_mul(self, *deps, **kwargs):
1748         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1749 
1750         c should be a Rational multiplied by any terms of the Mul that are
1751         independent of deps.
1752 
1753         args should be a tuple of all other terms of m; args is empty
1754         if self is a Number or if self is independent of deps (when given).
1755 
1756         This should be used when you don't know if self is a Mul or not but
1757         you want to treat self as a Mul or if you want to process the
1758         individual arguments of the tail of self as a Mul.
1759 
1760         - if you know self is a Mul and want only the head, use self.args[0];
1761         - if you don't want to process the arguments of the tail but need the
1762           tail then use self.as_two_terms() which gives the head and tail;
1763         - if you want to split self into an independent and dependent parts
1764           use ``self.as_independent(*deps)``
1765 
1766         >>> from sympy import S
1767         >>> from sympy.abc import x, y
1768         >>> (S(3)).as_coeff_mul()
1769         (3, ())
1770         >>> (3*x*y).as_coeff_mul()
1771         (3, (x, y))
1772         >>> (3*x*y).as_coeff_mul(x)
1773         (3*y, (x,))
1774         >>> (3*y).as_coeff_mul(x)
1775         (3*y, ())
1776         """
1777         if deps:
1778             if not self.has(*deps):
1779                 return self, tuple()
1780         return S.One, (self,)
1781 
1782     def as_coeff_add(self, *deps):
1783         """Return the tuple (c, args) where self is written as an Add, ``a``.
1784 
1785         c should be a Rational added to any terms of the Add that are
1786         independent of deps.
1787 
1788         args should be a tuple of all other terms of ``a``; args is empty
1789         if self is a Number or if self is independent of deps (when given).
1790 
1791         This should be used when you don't know if self is an Add or not but
1792         you want to treat self as an Add or if you want to process the
1793         individual arguments of the tail of self as an Add.
1794 
1795         - if you know self is an Add and want only the head, use self.args[0];
1796         - if you don't want to process the arguments of the tail but need the
1797           tail then use self.as_two_terms() which gives the head and tail.
1798         - if you want to split self into an independent and dependent parts
1799           use ``self.as_independent(*deps)``
1800 
1801         >>> from sympy import S
1802         >>> from sympy.abc import x, y
1803         >>> (S(3)).as_coeff_add()
1804         (3, ())
1805         >>> (3 + x).as_coeff_add()
1806         (3, (x,))
1807         >>> (3 + x + y).as_coeff_add(x)
1808         (y + 3, (x,))
1809         >>> (3 + y).as_coeff_add(x)
1810         (y + 3, ())
1811 
1812         """
1813         if deps:
1814             if not self.has(*deps):
1815                 return self, tuple()
1816         return S.Zero, (self,)
1817 
1818     def primitive(self):
1819         """Return the positive Rational that can be extracted non-recursively
1820         from every term of self (i.e., self is treated like an Add). This is
1821         like the as_coeff_Mul() method but primitive always extracts a positive
1822         Rational (never a negative or a Float).
1823 
1824         Examples
1825         ========
1826 
1827         >>> from sympy.abc import x
1828         >>> (3*(x + 1)**2).primitive()
1829         (3, (x + 1)**2)
1830         >>> a = (6*x + 2); a.primitive()
1831         (2, 3*x + 1)
1832         >>> b = (x/2 + 3); b.primitive()
1833         (1/2, x + 6)
1834         >>> (a*b).primitive() == (1, a*b)
1835         True
1836         """
1837         if not self:
1838             return S.One, S.Zero
1839         c, r = self.as_coeff_Mul(rational=True)
1840         if c.is_negative:
1841             c, r = -c, -r
1842         return c, r
1843 
1844     def as_content_primitive(self, radical=False, clear=True):
1845         """This method should recursively remove a Rational from all arguments
1846         and return that (content) and the new self (primitive). The content
1847         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
1848         The primitive need no be in canonical form and should try to preserve
1849         the underlying structure if possible (i.e. expand_mul should not be
1850         applied to self).
1851 
1852         Examples
1853         ========
1854 
1855         >>> from sympy import sqrt
1856         >>> from sympy.abc import x, y, z
1857 
1858         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
1859 
1860         The as_content_primitive function is recursive and retains structure:
1861 
1862         >>> eq.as_content_primitive()
1863         (2, x + 3*y*(y + 1) + 1)
1864 
1865         Integer powers will have Rationals extracted from the base:
1866 
1867         >>> ((2 + 6*x)**2).as_content_primitive()
1868         (4, (3*x + 1)**2)
1869         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
1870         (1, (2*(3*x + 1))**(2*y))
1871 
1872         Terms may end up joining once their as_content_primitives are added:
1873 
1874         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1875         (11, x*(y + 1))
1876         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1877         (9, x*(y + 1))
1878         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
1879         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
1880         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
1881         (121, x**2*(y + 1)**2)
1882         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
1883         (1, 121.0*x**2*(y + 1)**2)
1884 
1885         Radical content can also be factored out of the primitive:
1886 
1887         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
1888         (2, sqrt(2)*(1 + 2*sqrt(5)))
1889 
1890         If clear=False (default is True) then content will not be removed
1891         from an Add if it can be distributed to leave one or more
1892         terms with integer coefficients.
1893 
1894         >>> (x/2 + y).as_content_primitive()
1895         (1/2, x + 2*y)
1896         >>> (x/2 + y).as_content_primitive(clear=False)
1897         (1, x/2 + y)
1898         """
1899         return S.One, self
1900 
1901     def as_numer_denom(self):
1902         """ expression -> a/b -> a, b
1903 
1904         This is just a stub that should be defined by
1905         an object's class methods to get anything else.
1906 
1907         See Also
1908         ========
1909         normal: return a/b instead of a, b
1910         """
1911 
1912         return self, S.One
1913 
1914     def normal(self):
1915         n, d = self.as_numer_denom()
1916         if d is S.One:
1917             return n
1918         return n/d
1919 
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)
2027 
2028     def extract_additively(self, c):
2029         """Return self - c if it's possible to subtract c from self and
2030         make all matching coefficients move towards zero, else return None.
2031 
2032         Examples
2033         ========
2034 
2035         >>> from sympy.abc import x, y
2036         >>> e = 2*x + 3
2037         >>> e.extract_additively(x + 1)
2038         x + 2
2039         >>> e.extract_additively(3*x)
2040         >>> e.extract_additively(4)
2041         >>> (y*(x + 1)).extract_additively(x + 1)
2042         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2043         (x + 1)*(x + 2*y) + 3
2044 
2045         Sometimes auto-expansion will return a less simplified result
2046         than desired; gcd_terms might be used in such cases:
2047 
2048         >>> from sympy import gcd_terms
2049         >>> (4*x*(y + 1) + y).extract_additively(x)
2050         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2051         >>> gcd_terms(_)
2052         x*(4*y + 3) + y
2053 
2054         See Also
2055         ========
2056         extract_multiplicatively
2057         coeff
2058         as_coefficient
2059 
2060         """
2061 
2062         c = sympify(c)
2063         if self is S.NaN:
2064             return None
2065         if c is S.Zero:
2066             return self
2067         elif c == self:
2068             return S.Zero
2069         elif self is S.Zero:
2070             return None
2071 
2072         if self.is_Number:
2073             if not c.is_Number:
2074                 return None
2075             co = self
2076             diff = co - c
2077             # XXX should we match types? i.e should 3 - .1 succeed?
2078             if (co > 0 and diff > 0 and diff < co or
2079                     co < 0 and diff < 0 and diff > co):
2080                 return diff
2081             return None
2082 
2083         if c.is_Number:
2084             co, t = self.as_coeff_Add()
2085             xa = co.extract_additively(c)
2086             if xa is None:
2087                 return None
2088             return xa + t
2089 
2090         # handle the args[0].is_Number case separately
2091         # since we will have trouble looking for the coeff of
2092         # a number.
2093         if c.is_Add and c.args[0].is_Number:
2094             # whole term as a term factor
2095             co = self.coeff(c)
2096             xa0 = (co.extract_additively(1) or 0)*c
2097             if xa0:
2098                 diff = self - co*c
2099                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2100             # term-wise
2101             h, t = c.as_coeff_Add()
2102             sh, st = self.as_coeff_Add()
2103             xa = sh.extract_additively(h)
2104             if xa is None:
2105                 return None
2106             xa2 = st.extract_additively(t)
2107             if xa2 is None:
2108                 return None
2109             return xa + xa2
2110 
2111         # whole term as a term factor
2112         co = self.coeff(c)
2113         xa0 = (co.extract_additively(1) or 0)*c
2114         if xa0:
2115             diff = self - co*c
2116             return (xa0 + (diff.extract_additively(c) or diff)) or None
2117         # term-wise
2118         coeffs = []
2119         for a in Add.make_args(c):
2120             ac, at = a.as_coeff_Mul()
2121             co = self.coeff(at)
2122             if not co:
2123                 return None
2124             coc, cot = co.as_coeff_Add()
2125             xa = coc.extract_additively(ac)
2126             if xa is None:
2127                 return None
2128             self -= co*at
2129             coeffs.append((cot + xa)*at)
2130         coeffs.append(self)
2131         return Add(*coeffs)
2132 
2133     def could_extract_minus_sign(self):
2134         """Canonical way to choose an element in the set {e, -e} where
2135            e is any expression. If the canonical element is e, we have
2136            e.could_extract_minus_sign() == True, else
2137            e.could_extract_minus_sign() == False.
2138 
2139            For any expression, the set ``{e.could_extract_minus_sign(),
2140            (-e).could_extract_minus_sign()}`` must be ``{True, False}``.
2141 
2142            >>> from sympy.abc import x, y
2143            >>> (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()
2144            True
2145 
2146         """
2147         negative_self = -self
2148         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2149         negative_self_has_minus = (
2150             (negative_self).extract_multiplicatively(-1) is not None)
2151         if self_has_minus != negative_self_has_minus:
2152             return self_has_minus
2153         else:
2154             if self.is_Add:
2155                 # We choose the one with less arguments with minus signs
2156                 all_args = len(self.args)
2157                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2158                 positive_args = all_args - negative_args
2159                 if positive_args > negative_args:
2160                     return False
2161                 elif positive_args < negative_args:
2162                     return True
2163             elif self.is_Mul:
2164                 # We choose the one with an odd number of minus signs
2165                 num, den = self.as_numer_denom()
2166                 args = Mul.make_args(num) + Mul.make_args(den)
2167                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2168                 negative_args = list(filter(None, arg_signs))
2169                 return len(negative_args) % 2 == 1
2170 
2171             # As a last resort, we choose the one with greater value of .sort_key()
2172             return bool(self.sort_key() < negative_self.sort_key())
2173 
2174     def extract_branch_factor(self, allow_half=False):
2175         """
2176         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2177         Return (z, n).
2178 
2179         >>> from sympy import exp_polar, I, pi
2180         >>> from sympy.abc import x, y
2181         >>> exp_polar(I*pi).extract_branch_factor()
2182         (exp_polar(I*pi), 0)
2183         >>> exp_polar(2*I*pi).extract_branch_factor()
2184         (1, 1)
2185         >>> exp_polar(-pi*I).extract_branch_factor()
2186         (exp_polar(I*pi), -1)
2187         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2188         (exp_polar(x + I*pi), 1)
2189         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2190         (y*exp_polar(2*pi*x), -1)
2191         >>> exp_polar(-I*pi/2).extract_branch_factor()
2192         (exp_polar(-I*pi/2), 0)
2193 
2194         If allow_half is True, also extract exp_polar(I*pi):
2195 
2196         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2197         (1, 1/2)
2198         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2199         (1, 1)
2200         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2201         (1, 3/2)
2202         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2203         (1, -1/2)
2204         """
2205         from sympy import exp_polar, pi, I, ceiling, Add
2206         n = S(0)
2207         res = S(1)
2208         args = Mul.make_args(self)
2209         exps = []
2210         for arg in args:
2211             if arg.func is exp_polar:
2212                 exps += [arg.exp]
2213             else:
2214                 res *= arg
2215         piimult = S(0)
2216         extras = []
2217         while exps:
2218             exp = exps.pop()
2219             if exp.is_Add:
2220                 exps += exp.args
2221                 continue
2222             if exp.is_Mul:
2223                 coeff = exp.as_coefficient(pi*I)
2224                 if coeff is not None:
2225                     piimult += coeff
2226                     continue
2227             extras += [exp]
2228         if not piimult.free_symbols:
2229             coeff = piimult
2230             tail = ()
2231         else:
2232             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2233         # round down to nearest multiple of 2
2234         branchfact = ceiling(coeff/2 - S(1)/2)*2
2235         n += branchfact/2
2236         c = coeff - branchfact
2237         if allow_half:
2238             nc = c.extract_additively(1)
2239             if nc is not None:
2240                 n += S(1)/2
2241                 c = nc
2242         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2243         if newexp != 0:
2244             res *= exp_polar(newexp)
2245         return res, n
2246 
2247     def _eval_is_polynomial(self, syms):
2248         if self.free_symbols.intersection(syms) == set([]):
2249             return True
2250         return False
2251 
2252     def is_polynomial(self, *syms):
2253         """
2254         Return True if self is a polynomial in syms and False otherwise.
2255 
2256         This checks if self is an exact polynomial in syms.  This function
2257         returns False for expressions that are "polynomials" with symbolic
2258         exponents.  Thus, you should be able to apply polynomial algorithms to
2259         expressions for which this returns True, and Poly(expr, \*syms) should
2260         work if and only if expr.is_polynomial(\*syms) returns True. The
2261         polynomial does not have to be in expanded form.  If no symbols are
2262         given, all free symbols in the expression will be used.
2263 
2264         This is not part of the assumptions system.  You cannot do
2265         Symbol('z', polynomial=True).
2266 
2267         Examples
2268         ========
2269 
2270         >>> from sympy import Symbol
2271         >>> x = Symbol('x')
2272         >>> ((x**2 + 1)**4).is_polynomial(x)
2273         True
2274         >>> ((x**2 + 1)**4).is_polynomial()
2275         True
2276         >>> (2**x + 1).is_polynomial(x)
2277         False
2278 
2279 
2280         >>> n = Symbol('n', nonnegative=True, integer=True)
2281         >>> (x**n + 1).is_polynomial(x)
2282         False
2283 
2284         This function does not attempt any nontrivial simplifications that may
2285         result in an expression that does not appear to be a polynomial to
2286         become one.
2287 
2288         >>> from sympy import sqrt, factor, cancel
2289         >>> y = Symbol('y', positive=True)
2290         >>> a = sqrt(y**2 + 2*y + 1)
2291         >>> a.is_polynomial(y)
2292         False
2293         >>> factor(a)
2294         y + 1
2295         >>> factor(a).is_polynomial(y)
2296         True
2297 
2298         >>> b = (y**2 + 2*y + 1)/(y + 1)
2299         >>> b.is_polynomial(y)
2300         False
2301         >>> cancel(b)
2302         y + 1
2303         >>> cancel(b).is_polynomial(y)
2304         True
2305 
2306         See also .is_rational_function()
2307 
2308         """
2309         if syms:
2310             syms = set(map(sympify, syms))
2311         else:
2312             syms = self.free_symbols
2313 
2314         if syms.intersection(self.free_symbols) == set([]):
2315             # constant polynomial
2316             return True
2317         else:
2318             return self._eval_is_polynomial(syms)
2319 
2320     def _eval_is_rational_function(self, syms):
2321         if self.free_symbols.intersection(syms) == set([]):
2322             return True
2323         return False
2324 
2325     def is_rational_function(self, *syms):
2326         """
2327         Test whether function is a ratio of two polynomials in the given
2328         symbols, syms. When syms is not given, all free symbols will be used.
2329         The rational function does not have to be in expanded or in any kind of
2330         canonical form.
2331 
2332         This function returns False for expressions that are "rational
2333         functions" with symbolic exponents.  Thus, you should be able to call
2334         .as_numer_denom() and apply polynomial algorithms to the result for
2335         expressions for which this returns True.
2336 
2337         This is not part of the assumptions system.  You cannot do
2338         Symbol('z', rational_function=True).
2339 
2340         Examples
2341         ========
2342 
2343         >>> from sympy import Symbol, sin
2344         >>> from sympy.abc import x, y
2345 
2346         >>> (x/y).is_rational_function()
2347         True
2348 
2349         >>> (x**2).is_rational_function()
2350         True
2351 
2352         >>> (x/sin(y)).is_rational_function(y)
2353         False
2354 
2355         >>> n = Symbol('n', integer=True)
2356         >>> (x**n + 1).is_rational_function(x)
2357         False
2358 
2359         This function does not attempt any nontrivial simplifications that may
2360         result in an expression that does not appear to be a rational function
2361         to become one.
2362 
2363         >>> from sympy import sqrt, factor
2364         >>> y = Symbol('y', positive=True)
2365         >>> a = sqrt(y**2 + 2*y + 1)/y
2366         >>> a.is_rational_function(y)
2367         False
2368         >>> factor(a)
2369         (y + 1)/y
2370         >>> factor(a).is_rational_function(y)
2371         True
2372 
2373         See also is_algebraic_expr().
2374 
2375         """
2376         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2377             return False
2378 
2379         if syms:
2380             syms = set(map(sympify, syms))
2381         else:
2382             syms = self.free_symbols
2383 
2384         if syms.intersection(self.free_symbols) == set([]):
2385             # constant rational function
2386             return True
2387         else:
2388             return self._eval_is_rational_function(syms)
2389 
2390     def _eval_is_algebraic_expr(self, syms):
2391         if self.free_symbols.intersection(syms) == set([]):
2392             return True
2393         return False
2394 
2395     def is_algebraic_expr(self, *syms):
2396         """
2397         This tests whether a given expression is algebraic or not, in the
2398         given symbols, syms. When syms is not given, all free symbols
2399         will be used. The rational function does not have to be in expanded
2400         or in any kind of canonical form.
2401 
2402         This function returns False for expressions that are "algebraic
2403         expressions" with symbolic exponents. This is a simple extension to the
2404         is_rational_function, including rational exponentiation.
2405 
2406         Examples
2407         ========
2408 
2409         >>> from sympy import Symbol, sqrt
2410         >>> x = Symbol('x', real=True)
2411         >>> sqrt(1 + x).is_rational_function()
2412         False
2413         >>> sqrt(1 + x).is_algebraic_expr()
2414         True
2415 
2416         This function does not attempt any nontrivial simplifications that may
2417         result in an expression that does not appear to be an algebraic
2418         expression to become one.
2419 
2420         >>> from sympy import exp, factor
2421         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2422         >>> a.is_algebraic_expr(x)
2423         False
2424         >>> factor(a).is_algebraic_expr()
2425         True
2426 
2427         See Also
2428         ========
2429         is_rational_function()
2430 
2431         References
2432         ==========
2433 
2434         - http://en.wikipedia.org/wiki/Algebraic_expression
2435 
2436         """
2437         if syms:
2438             syms = set(map(sympify, syms))
2439         else:
2440             syms = self.free_symbols
2441 
2442         if syms.intersection(self.free_symbols) == set([]):
2443             # constant algebraic expression
2444             return True
2445         else:
2446             return self._eval_is_algebraic_expr(syms)
2447 
2448     ###################################################################################
2449     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2450     ###################################################################################
2451 
2452     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2453         """
2454         Series expansion of "self" around ``x = x0`` yielding either terms of
2455         the series one by one (the lazy series given when n=None), else
2456         all the terms at once when n != None.
2457 
2458         Returns the series expansion of "self" around the point ``x = x0``
2459         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2460 
2461         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2462         be supplied, otherwise an error will be raised.
2463 
2464         >>> from sympy import cos, exp
2465         >>> from sympy.abc import x, y
2466         >>> cos(x).series()
2467         1 - x**2/2 + x**4/24 + O(x**6)
2468         >>> cos(x).series(n=4)
2469         1 - x**2/2 + O(x**4)
2470         >>> cos(x).series(x, x0=1, n=2)
2471         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2472         >>> e = cos(x + exp(y))
2473         >>> e.series(y, n=2)
2474         cos(x + 1) - y*sin(x + 1) + O(y**2)
2475         >>> e.series(x, n=2)
2476         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2477 
2478         If ``n=None`` then a generator of the series terms will be returned.
2479 
2480         >>> term=cos(x).series(n=None)
2481         >>> [next(term) for i in range(2)]
2482         [1, -x**2/2]
2483 
2484         For ``dir=+`` (default) the series is calculated from the right and
2485         for ``dir=-`` the series from the left. For smooth functions this
2486         flag will not alter the results.
2487 
2488         >>> abs(x).series(dir="+")
2489         x
2490         >>> abs(x).series(dir="-")
2491         -x
2492 
2493         """
2494         from sympy import collect, Dummy, Order, Rational, Symbol
2495         if x is None:
2496             syms = self.atoms(Symbol)
2497             if not syms:
2498                 return self
2499             elif len(syms) > 1:
2500                 raise ValueError('x must be given for multivariate functions.')
2501             x = syms.pop()
2502 
2503         if not self.has(x):
2504             if n is None:
2505                 return (s for s in [self])
2506             else:
2507                 return self
2508 
2509         if len(dir) != 1 or dir not in '+-':
2510             raise ValueError("Dir must be '+' or '-'")
2511 
2512         if x0 in [S.Infinity, S.NegativeInfinity]:
2513             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]
2514             s = self.subs(x, 1/x).series(x, n=n, dir=dir)
2515             if n is None:
2516                 return (si.subs(x, 1/x) for si in s)
2517             return s.subs(x, 1/x)
2518 
2519         # use rep to shift origin to x0 and change sign (if dir is negative)
2520         # and undo the process with rep2
2521         if x0 or dir == '-':
2522             if dir == '-':
2523                 rep = -x + x0
2524                 rep2 = -x
2525                 rep2b = x0
2526             else:
2527                 rep = x + x0
2528                 rep2 = x
2529                 rep2b = -x0
2530             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2531             if n is None:  # lseries...
2532                 return (si.subs(x, rep2 + rep2b) for si in s)
2533             return s.subs(x, rep2 + rep2b)
2534 
2535         # from here on it's x0=0 and dir='+' handling
2536 
2537         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2538             # replace x with an x that has a positive assumption
2539             xpos = Dummy('x', positive=True, finite=True)
2540             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2541             if n is None:
2542                 return (s.subs(xpos, x) for s in rv)
2543             else:
2544                 return rv.subs(xpos, x)
2545 
2546         if n is not None:  # nseries handling
2547             s1 = self._eval_nseries(x, n=n, logx=logx)
2548             o = s1.getO() or S.Zero
2549             if o:
2550                 # make sure the requested order is returned
2551                 ngot = o.getn()
2552                 if ngot > n:
2553                     # leave o in its current form (e.g. with x*log(x)) so
2554                     # it eats terms properly, then replace it below
2555                     if n != 0:
2556                         s1 += o.subs(x, x**Rational(n, ngot))
2557                     else:
2558                         s1 += Order(1, x)
2559                 elif ngot < n:
2560                     # increase the requested number of terms to get the desired
2561                     # number keep increasing (up to 9) until the received order
2562                     # is different than the original order and then predict how
2563                     # many additional terms are needed
2564                     for more in range(1, 9):
2565                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2566                         newn = s1.getn()
2567                         if newn != ngot:
2568                             ndo = n + (n - ngot)*more/(newn - ngot)
2569                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2570                             while s1.getn() < n:
2571                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2572                                 ndo += 1
2573                             break
2574                     else:
2575                         raise ValueError('Could not calculate %s terms for %s'
2576                                          % (str(n), self))
2577                     s1 += Order(x**n, x)
2578                 o = s1.getO()
2579                 s1 = s1.removeO()
2580             else:
2581                 o = Order(x**n, x)
2582                 s1done = s1.doit()
2583                 if (s1done + o).removeO() == s1done:
2584                     o = S.Zero
2585 
2586             try:
2587                 return collect(s1, x) + o
2588             except NotImplementedError:
2589                 return s1 + o
2590 
2591         else:  # lseries handling
2592             def yield_lseries(s):
2593                 """Return terms of lseries one at a time."""
2594                 for si in s:
2595                     if not si.is_Add:
2596                         yield si
2597                         continue
2598                     # yield terms 1 at a time if possible
2599                     # by increasing order until all the
2600                     # terms have been returned
2601                     yielded = 0
2602                     o = Order(si, x)*x
2603                     ndid = 0
2604                     ndo = len(si.args)
2605                     while 1:
2606                         do = (si - yielded + o).removeO()
2607                         o *= x
2608                         if not do or do.is_Order:
2609                             continue
2610                         if do.is_Add:
2611                             ndid += len(do.args)
2612                         else:
2613                             ndid += 1
2614                         yield do
2615                         if ndid == ndo:
2616                             break
2617                         yielded += do
2618 
2619             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2620 
2621     def taylor_term(self, n, x, *previous_terms):
2622         """General method for the taylor term.
2623 
2624         This method is slow, because it differentiates n-times. Subclasses can
2625         redefine it to make it faster by using the "previous_terms".
2626         """
2627         from sympy import Dummy, factorial
2628         x = sympify(x)
2629         _x = Dummy('x')
2630         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2631 
2632     def lseries(self, x=None, x0=0, dir='+', logx=None):
2633         """
2634         Wrapper for series yielding an iterator of the terms of the series.
2635 
2636         Note: an infinite series will yield an infinite iterator. The following,
2637         for exaxmple, will never terminate. It will just keep printing terms
2638         of the sin(x) series::
2639 
2640           for term in sin(x).lseries(x):
2641               print term
2642 
2643         The advantage of lseries() over nseries() is that many times you are
2644         just interested in the next term in the series (i.e. the first term for
2645         example), but you don't know how many you should ask for in nseries()
2646         using the "n" parameter.
2647 
2648         See also nseries().
2649         """
2650         return self.series(x, x0, n=None, dir=dir, logx=logx)
2651 
2652     def _eval_lseries(self, x, logx=None):
2653         # default implementation of lseries is using nseries(), and adaptively
2654         # increasing the "n". As you can see, it is not very efficient, because
2655         # we are calculating the series over and over again. Subclasses should
2656         # override this method and implement much more efficient yielding of
2657         # terms.
2658         n = 0
2659         series = self._eval_nseries(x, n=n, logx=logx)
2660         if not series.is_Order:
2661             if series.is_Add:
2662                 yield series.removeO()
2663             else:
2664                 yield series
2665             return
2666 
2667         while series.is_Order:
2668             n += 1
2669             series = self._eval_nseries(x, n=n, logx=logx)
2670         e = series.removeO()
2671         yield e
2672         while 1:
2673             while 1:
2674                 n += 1
2675                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2676                 if e != series:
2677                     break
2678             yield series - e
2679             e = series
2680 
2681     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2682         """
2683         Wrapper to _eval_nseries if assumptions allow, else to series.
2684 
2685         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2686         called. This calculates "n" terms in the innermost expressions and
2687         then builds up the final series just by "cross-multiplying" everything
2688         out.
2689 
2690         The optional ``logx`` parameter can be used to replace any log(x) in the
2691         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2692         symbol to use in place of log(x) should be provided.
2693 
2694         Advantage -- it's fast, because we don't have to determine how many
2695         terms we need to calculate in advance.
2696 
2697         Disadvantage -- you may end up with less terms than you may have
2698         expected, but the O(x**n) term appended will always be correct and
2699         so the result, though perhaps shorter, will also be correct.
2700 
2701         If any of those assumptions is not met, this is treated like a
2702         wrapper to series which will try harder to return the correct
2703         number of terms.
2704 
2705         See also lseries().
2706 
2707         Examples
2708         ========
2709 
2710         >>> from sympy import sin, log, Symbol
2711         >>> from sympy.abc import x, y
2712         >>> sin(x).nseries(x, 0, 6)
2713         x - x**3/6 + x**5/120 + O(x**6)
2714         >>> log(x+1).nseries(x, 0, 5)
2715         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2716 
2717         Handling of the ``logx`` parameter --- in the following example the
2718         expansion fails since ``sin`` does not have an asymptotic expansion
2719         at -oo (the limit of log(x) as x approaches 0):
2720 
2721         >>> e = sin(log(x))
2722         >>> e.nseries(x, 0, 6)
2723         Traceback (most recent call last):
2724         ...
2725         PoleError: ...
2726         ...
2727         >>> logx = Symbol('logx')
2728         >>> e.nseries(x, 0, 6, logx=logx)
2729         sin(logx)
2730 
2731         In the following example, the expansion works but gives only an Order term
2732         unless the ``logx`` parameter is used:
2733 
2734         >>> e = x**y
2735         >>> e.nseries(x, 0, 2)
2736         O(log(x)**2)
2737         >>> e.nseries(x, 0, 2, logx=logx)
2738         exp(logx*y)
2739 
2740         """
2741         if x and not x in self.free_symbols:
2742             return self
2743         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2744             return self.series(x, x0, n, dir)
2745         else:
2746             return self._eval_nseries(x, n=n, logx=logx)
2747 
2748     def _eval_nseries(self, x, n, logx):
2749         """
2750         Return terms of series for self up to O(x**n) at x=0
2751         from the positive direction.
2752 
2753         This is a method that should be overridden in subclasses. Users should
2754         never call this method directly (use .nseries() instead), so you don't
2755         have to write docstrings for _eval_nseries().
2756         """
2757         from sympy.utilities.misc import filldedent
2758         raise NotImplementedError(filldedent("""
2759                      The _eval_nseries method should be added to
2760                      %s to give terms up to O(x**n) at x=0
2761                      from the positive direction so it is available when
2762                      nseries calls it.""" % self.func)
2763                      )
2764 
2765     def limit(self, x, xlim, dir='+'):
2766         """ Compute limit x->xlim.
2767         """
2768         from sympy.series.limits import limit
2769         return limit(self, x, xlim, dir)
2770 
2771     def compute_leading_term(self, x, logx=None):
2772         """
2773         as_leading_term is only allowed for results of .series()
2774         This is a wrapper to compute a series first.
2775         """
2776         from sympy import Dummy, log
2777         from sympy.series.gruntz import calculate_series
2778 
2779         if self.removeO() == 0:
2780             return self
2781 
2782         if logx is None:
2783             d = Dummy('logx')
2784             s = calculate_series(self, x, d).subs(d, log(x))
2785         else:
2786             s = calculate_series(self, x, logx)
2787 
2788         return s.as_leading_term(x)
2789 
2790     @cacheit
2791     def as_leading_term(self, *symbols):
2792         """
2793         Returns the leading (nonzero) term of the series expansion of self.
2794 
2795         The _eval_as_leading_term routines are used to do this, and they must
2796         always return a non-zero value.
2797 
2798         Examples
2799         ========
2800 
2801         >>> from sympy.abc import x
2802         >>> (1 + x + x**2).as_leading_term(x)
2803         1
2804         >>> (1/x**2 + x + x**2).as_leading_term(x)
2805         x**(-2)
2806 
2807         """
2808         from sympy import powsimp
2809         if len(symbols) > 1:
2810             c = self
2811             for x in symbols:
2812                 c = c.as_leading_term(x)
2813             return c
2814         elif not symbols:
2815             return self
2816         x = sympify(symbols[0])
2817         if not x.is_Symbol:
2818             raise ValueError('expecting a Symbol but got %s' % x)
2819         if x not in self.free_symbols:
2820             return self
2821         obj = self._eval_as_leading_term(x)
2822         if obj is not None:
2823             return powsimp(obj, deep=True, combine='exp')
2824         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
2825 
2826     def _eval_as_leading_term(self, x):
2827         return self
2828 
2829     def as_coeff_exponent(self, x):
2830         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
2831         """
2832         from sympy import collect
2833         s = collect(self, x)
2834         c, p = s.as_coeff_mul(x)
2835         if len(p) == 1:
2836             b, e = p[0].as_base_exp()
2837             if b == x:
2838                 return c, e
2839         return s, S.Zero
2840 
2841     def leadterm(self, x):
2842         """
2843         Returns the leading term a*x**b as a tuple (a, b).
2844 
2845         Examples
2846         ========
2847 
2848         >>> from sympy.abc import x
2849         >>> (1+x+x**2).leadterm(x)
2850         (1, 0)
2851         >>> (1/x**2+x+x**2).leadterm(x)
2852         (1, -2)
2853 
2854         """
2855         from sympy import Dummy, log
2856         l = self.as_leading_term(x)
2857         d = Dummy('logx')
2858         if l.has(log(x)):
2859             l = l.subs(log(x), d)
2860         c, e = l.as_coeff_exponent(x)
2861         if x in c.free_symbols:
2862             from sympy.utilities.misc import filldedent
2863             raise ValueError(filldedent("""
2864                 cannot compute leadterm(%s, %s). The coefficient
2865                 should have been free of x but got %s""" % (self, x, c)))
2866         c = c.subs(d, log(x))
2867         return c, e
2868 
2869     def as_coeff_Mul(self, rational=False):
2870         """Efficiently extract the coefficient of a product. """
2871         return S.One, self
2872 
2873     def as_coeff_Add(self, rational=False):
2874         """Efficiently extract the coefficient of a summation. """
2875         return S.Zero, self
2876 
2877     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
2878             full=False):
2879         """
2880         Compute formal power power series of self.
2881 
2882         See the docstring of the :func:`fps` function in sympy.series.formal for
2883         more information.
2884         """
2885         from sympy.series.formal import fps
2886 
2887         return fps(self, x, x0, dir, hyper, order, rational, full)
2888 
2889     def fourier_series(self, limits=None):
2890         """Compute fourier sine/cosine series of self.
2891 
2892         See the docstring of the :func:`fourier_series` in sympy.series.fourier
2893         for more information.
2894         """
2895         from sympy.series.fourier import fourier_series
2896 
2897         return fourier_series(self, limits)
2898 
2899     ###################################################################################
2900     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
2901     ###################################################################################
2902 
2903     def diff(self, *symbols, **assumptions):
2904         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z
2905         assumptions.setdefault("evaluate", True)
2906         return Derivative(self, *new_symbols, **assumptions)
2907 
2908     ###########################################################################
2909     ###################### EXPRESSION EXPANSION METHODS #######################
2910     ###########################################################################
2911 
2912     # Relevant subclasses should override _eval_expand_hint() methods.  See
2913     # the docstring of expand() for more info.
2914 
2915     def _eval_expand_complex(self, **hints):
2916         real, imag = self.as_real_imag(**hints)
2917         return real + S.ImaginaryUnit*imag
2918 
2919     @staticmethod
2920     def _expand_hint(expr, hint, deep=True, **hints):
2921         """
2922         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
2923 
2924         Returns ``(expr, hit)``, where expr is the (possibly) expanded
2925         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
2926         ``False`` otherwise.
2927         """
2928         hit = False
2929         # XXX: Hack to support non-Basic args
2930         #              |
2931         #              V
2932         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
2933             sargs = []
2934             for arg in expr.args:
2935                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
2936                 hit |= arghit
2937                 sargs.append(arg)
2938 
2939             if hit:
2940                 expr = expr.func(*sargs)
2941 
2942         if hasattr(expr, hint):
2943             newexpr = getattr(expr, hint)(**hints)
2944             if newexpr != expr:
2945                 return (newexpr, True)
2946 
2947         return (expr, hit)
2948 
2949     @cacheit
2950     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
2951             mul=True, log=True, multinomial=True, basic=True, **hints):
2952         """
2953         Expand an expression using hints.
2954 
2955         See the docstring of the expand() function in sympy.core.function for
2956         more information.
2957 
2958         """
2959         from sympy.simplify.radsimp import fraction
2960 
2961         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
2962            log=log, multinomial=multinomial, basic=basic)
2963 
2964         expr = self
2965         if hints.pop('frac', False):
2966             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
2967                     for a in fraction(self)]
2968             return n/d
2969         elif hints.pop('denom', False):
2970             n, d = fraction(self)
2971             return n/d.expand(deep=deep, modulus=modulus, **hints)
2972         elif hints.pop('numer', False):
2973             n, d = fraction(self)
2974             return n.expand(deep=deep, modulus=modulus, **hints)/d
2975 
2976         # Although the hints are sorted here, an earlier hint may get applied
2977         # at a given node in the expression tree before another because of how
2978         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
2979         # x*z) because while applying log at the top level, log and mul are
2980         # applied at the deeper level in the tree so that when the log at the
2981         # upper level gets applied, the mul has already been applied at the
2982         # lower level.
2983 
2984         # Additionally, because hints are only applied once, the expression
2985         # may not be expanded all the way.   For example, if mul is applied
2986         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
2987         # now, we just use a special case to make multinomial run before mul,
2988         # so that at least polynomials will be expanded all the way.  In the
2989         # future, smarter heuristics should be applied.
2990         # TODO: Smarter heuristics
2991 
2992         def _expand_hint_key(hint):
2993             """Make multinomial come before mul"""
2994             if hint == 'mul':
2995                 return 'mulz'
2996             return hint
2997 
2998         for hint in sorted(hints.keys(), key=_expand_hint_key):
2999             use_hint = hints[hint]
3000             if use_hint:
3001                 hint = '_eval_expand_' + hint
3002                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3003 
3004         while True:
3005             was = expr
3006             if hints.get('multinomial', False):
3007                 expr, _ = Expr._expand_hint(
3008                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3009             if hints.get('mul', False):
3010                 expr, _ = Expr._expand_hint(
3011                     expr, '_eval_expand_mul', deep=deep, **hints)
3012             if hints.get('log', False):
3013                 expr, _ = Expr._expand_hint(
3014                     expr, '_eval_expand_log', deep=deep, **hints)
3015             if expr == was:
3016                 break
3017 
3018         if modulus is not None:
3019             modulus = sympify(modulus)
3020 
3021             if not modulus.is_Integer or modulus <= 0:
3022                 raise ValueError(
3023                     "modulus must be a positive integer, got %s" % modulus)
3024 
3025             terms = []
3026 
3027             for term in Add.make_args(expr):
3028                 coeff, tail = term.as_coeff_Mul(rational=True)
3029 
3030                 coeff %= modulus
3031 
3032                 if coeff:
3033                     terms.append(coeff*tail)
3034 
3035             expr = Add(*terms)
3036 
3037         return expr
3038 
3039     ###########################################################################
3040     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3041     ###########################################################################
3042 
3043     def integrate(self, *args, **kwargs):
3044         """See the integrate function in sympy.integrals"""
3045         from sympy.integrals import integrate
3046         return integrate(self, *args, **kwargs)
3047 
3048     def simplify(self, ratio=1.7, measure=None):
3049         """See the simplify function in sympy.simplify"""
3050         from sympy.simplify import simplify
3051         from sympy.core.function import count_ops
3052         measure = measure or count_ops
3053         return simplify(self, ratio, measure)
3054 
3055     def nsimplify(self, constants=[], tolerance=None, full=False):
3056         """See the nsimplify function in sympy.simplify"""
3057         from sympy.simplify import nsimplify
3058         return nsimplify(self, constants, tolerance, full)
3059 
3060     def separate(self, deep=False, force=False):
3061         """See the separate function in sympy.simplify"""
3062         from sympy.core.function import expand_power_base
3063         return expand_power_base(self, deep=deep, force=force)
3064 
3065     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3066         """See the collect function in sympy.simplify"""
3067         from sympy.simplify import collect
3068         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3069 
3070     def together(self, *args, **kwargs):
3071         """See the together function in sympy.polys"""
3072         from sympy.polys import together
3073         return together(self, *args, **kwargs)
3074 
3075     def apart(self, x=None, **args):
3076         """See the apart function in sympy.polys"""
3077         from sympy.polys import apart
3078         return apart(self, x, **args)
3079 
3080     def ratsimp(self):
3081         """See the ratsimp function in sympy.simplify"""
3082         from sympy.simplify import ratsimp
3083         return ratsimp(self)
3084 
3085     def trigsimp(self, **args):
3086         """See the trigsimp function in sympy.simplify"""
3087         from sympy.simplify import trigsimp
3088         return trigsimp(self, **args)
3089 
3090     def radsimp(self, **kwargs):
3091         """See the radsimp function in sympy.simplify"""
3092         from sympy.simplify import radsimp
3093         return radsimp(self, **kwargs)
3094 
3095     def powsimp(self, *args, **kwargs):
3096         """See the powsimp function in sympy.simplify"""
3097         from sympy.simplify import powsimp
3098         return powsimp(self, *args, **kwargs)
3099 
3100     def combsimp(self):
3101         """See the combsimp function in sympy.simplify"""
3102         from sympy.simplify import combsimp
3103         return combsimp(self)
3104 
3105     def factor(self, *gens, **args):
3106         """See the factor() function in sympy.polys.polytools"""
3107         from sympy.polys import factor
3108         return factor(self, *gens, **args)
3109 
3110     def refine(self, assumption=True):
3111         """See the refine function in sympy.assumptions"""
3112         from sympy.assumptions import refine
3113         return refine(self, assumption)
3114 
3115     def cancel(self, *gens, **args):
3116         """See the cancel function in sympy.polys"""
3117         from sympy.polys import cancel
3118         return cancel(self, *gens, **args)
3119 
3120     def invert(self, g, *gens, **args):
3121         """Return the multiplicative inverse of ``self`` mod ``g``
3122         where ``self`` (and ``g``) may be symbolic expressions).
3123 
3124         See Also
3125         ========
3126         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3127         """
3128         from sympy.polys.polytools import invert
3129         from sympy.core.numbers import mod_inverse
3130         if self.is_number and getattr(g, 'is_number', True):
3131             return mod_inverse(self, g)
3132         return invert(self, g, *gens, **args)
3133 
3134     def round(self, p=0):
3135         """Return x rounded to the given decimal place.
3136 
3137         If a complex number would results, apply round to the real
3138         and imaginary components of the number.
3139 
3140         Examples
3141         ========
3142 
3143         >>> from sympy import pi, E, I, S, Add, Mul, Number
3144         >>> S(10.5).round()
3145         11.
3146         >>> pi.round()
3147         3.
3148         >>> pi.round(2)
3149         3.14
3150         >>> (2*pi + E*I).round()
3151         6. + 3.*I
3152 
3153         The round method has a chopping effect:
3154 
3155         >>> (2*pi + I/10).round()
3156         6.
3157         >>> (pi/10 + 2*I).round()
3158         2.*I
3159         >>> (pi/10 + E*I).round(2)
3160         0.31 + 2.72*I
3161 
3162         Notes
3163         =====
3164 
3165         Do not confuse the Python builtin function, round, with the
3166         SymPy method of the same name. The former always returns a float
3167         (or raises an error if applied to a complex value) while the
3168         latter returns either a Number or a complex number:
3169 
3170         >>> isinstance(round(S(123), -2), Number)
3171         False
3172         >>> isinstance(S(123).round(-2), Number)
3173         True
3174         >>> isinstance((3*I).round(), Mul)
3175         True
3176         >>> isinstance((1 + 3*I).round(), Add)
3177         True
3178 
3179         """
3180         from sympy import Float
3181         x = self
3182         if not x.is_number:
3183             raise TypeError("can't round symbolic expression")
3184         if not x.is_Atom:
3185             xn = x.n(2)
3186             if not pure_complex(xn, or_real=True):
3187                 raise TypeError('Expected a number but got %s:' %
3188                     getattr(getattr(x,'func', x), '__name__', type(x)))
3189         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3190             return x
3191         if not x.is_real:
3192             i, r = x.as_real_imag()
3193             return i.round(p) + S.ImaginaryUnit*r.round(p)
3194         if not x:
3195             return x
3196         p = int(p)
3197 
3198         precs = [f._prec for f in x.atoms(Float)]
3199         dps = prec_to_dps(max(precs)) if precs else None
3200 
3201         mag_first_dig = _mag(x)
3202         allow = digits_needed = mag_first_dig + p
3203         if dps is not None and allow > dps:
3204             allow = dps
3205         mag = Pow(10, p)  # magnitude needed to bring digit p to units place
3206         xwas = x
3207         x += 1/(2*mag)  # add the half for rounding
3208         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3209         if i10.is_negative:
3210             x = xwas - 1/(2*mag)  # should have gone the other way
3211             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3212             rv = -(Integer(-i10)//10)
3213         else:
3214             rv = Integer(i10)//10
3215         q = 1
3216         if p > 0:
3217             q = mag
3218         elif p < 0:
3219             rv /= mag
3220         rv = Rational(rv, q)
3221         if rv.is_Integer:
3222             # use str or else it won't be a float
3223             return Float(str(rv), digits_needed)
3224         else:
3225             if not allow and rv > self:
3226                 allow += 1
3227             return Float(rv, allow)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 07:37:52.550 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 07:37:52.551 | INFO     | Search-only: skipping patch selection
2025-10-18 07:37:52.625 | INFO     | Task sympy__sympy-12270 completed successfully.
2025-10-18 07:37:52.626 | INFO     | No patch generated. You can try running ACR again.
