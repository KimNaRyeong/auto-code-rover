2025-10-18 06:46:33.549 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:46:36.993 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=397, output_tokens=12, cost=0.004330
2025-10-18 06:46:55.235 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=577, output_tokens=621, cost=0.024400
2025-10-18 06:46:56.432 | INFO     | registered non reproducing test 0
2025-10-18 06:47:08.066 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1972, output_tokens=595, cost=0.037570
2025-10-18 06:47:09.210 | INFO     | registered non reproducing test 1
2025-10-18 06:47:21.291 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1985, output_tokens=564, cost=0.036770
2025-10-18 06:47:22.258 | INFO     | registered non reproducing test 2
2025-10-18 06:47:22.258 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 06:47:22.261 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:47:28.377 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=282, cost=0.015520
2025-10-18 06:47:28.383 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:47:30.739 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=636, output_tokens=37, cost=0.007470
2025-10-18 06:47:30.739 | DEBUG    | Extracted a valid json.
2025-10-18 06:47:30.740 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"TypeVar\")",
        "search_code(\"mock._make_subclass\")"
    ],
    "bug_locations": []
}
2025-10-18 06:47:30.767 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:47:30.768 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:47:46.785 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1246, output_tokens=734, cost=0.034480
2025-10-18 06:47:46.792 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:47:48.612 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2196, output_tokens=48, cost=0.023400
2025-10-18 06:47:48.632 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:47:51.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=402, output_tokens=59, cost=0.005790
2025-10-18 06:47:51.243 | DEBUG    | Extracted a valid json.
2025-10-18 06:47:51.243 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"TypeVar\", \"sphinx/util/typing.py\")",
        "search_code_in_file(\"TypeVar\", \"sphinx/ext/autodoc/__init__.py\")"
    ],
    "bug_locations": []
}
2025-10-18 06:47:51.272 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:47:51.272 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:48:05.387 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2688, output_tokens=691, cost=0.047610
2025-10-18 06:48:05.402 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:48:13.417 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3595, output_tokens=330, cost=0.045850
2025-10-18 06:48:13.425 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:48:21.508 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=296, cost=0.015720
2025-10-18 06:48:21.509 | DEBUG    | Extracted a valid json.
2025-10-18 06:48:21.509 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/util/typing.py",
            "class": "",
            "method": "stringify, _stringify_py37",
            "intended_behavior": "These methods should ensure that when handling `TypeVar` objects, they convert these to their string representations safely without attempting to directly concatenate them with strings or perform other operations that could lead to `TypeError`. This involves checking the type of the object being stringified and applying an appropriate conversion method to handle `TypeVar` objects, thus preserving the functionality of documenting generic types accurately."
        },
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "can_document_member, get_doc, add_content",
            "intended_behavior": "These methods must be refined to handle generically typed classes and members correctly. Specifically, they should properly interpret and document `TypeVar` and generic types without resulting in `TypeError`. This means when extracting and adding documentation content, any `TypeVar` related to a member should be processed to display its defined constrains or bound types accurately in the documentation. Additionally, enhancing the conditional logic in `can_document_member` to detect and affirm the documentability of members with generic types would ensure that all relevant parts of generically-typed classes are included in the Sphinx documentation output."
        }
    ]
}
2025-10-18 06:48:21.520 | DEBUG    | Bug location extracted successfully: [<file>sphinx/util/typing.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.typing
3     ~~~~~~~~~~~~~~~~~~
4 
5     The composit types for Sphinx.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import sys
12 import typing
13 from typing import Any, Callable, Dict, List, Tuple, TypeVar, Union
14 
15 from docutils import nodes
16 from docutils.parsers.rst.states import Inliner
17 
18 
19 # An entry of Directive.option_spec
20 DirectiveOption = Callable[[str], Any]
21 
22 # Text like nodes which are initialized with text and rawsource
23 TextlikeNode = Union[nodes.Text, nodes.TextElement]
24 
25 # type of None
26 NoneType = type(None)
27 
28 # path matcher
29 PathMatcher = Callable[[str], bool]
30 
31 # common role functions
32 RoleFunction = Callable[[str, str, str, int, Inliner, Dict[str, Any], List[str]],
33                         Tuple[List[nodes.Node], List[nodes.system_message]]]
34 
35 # title getter functions for enumerable nodes (see sphinx.domains.std)
36 TitleGetter = Callable[[nodes.Node], str]
37 
38 # inventory data on memory
39 Inventory = Dict[str, Dict[str, Tuple[str, str, str, str]]]
40 
41 
42 def is_system_TypeVar(typ: Any) -> bool:
43     """Check *typ* is system defined TypeVar."""
44     modname = getattr(typ, '__module__', '')
45     return modname == 'typing' and isinstance(typ, TypeVar)  # type: ignore
46 
47 
48 def stringify(annotation: Any) -> str:
49     """Stringify type annotation object."""
50     if isinstance(annotation, str):
51         return annotation
52     elif isinstance(annotation, TypeVar):  # type: ignore
53         return annotation.__name__
54     elif not annotation:
55         return repr(annotation)
56     elif annotation is NoneType:
57         return 'None'
58     elif (getattr(annotation, '__module__', None) == 'builtins' and
59           hasattr(annotation, '__qualname__')):
60         return annotation.__qualname__
61     elif annotation is Ellipsis:
62         return '...'
63 
64     if sys.version_info >= (3, 7):  # py37+
65         return _stringify_py37(annotation)
66     else:
67         return _stringify_py36(annotation)
68 
69 
70 def _stringify_py37(annotation: Any) -> str:
71     """stringify() for py37+."""
72     module = getattr(annotation, '__module__', None)
73     if module == 'typing':
74         if getattr(annotation, '_name', None):
75             qualname = annotation._name
76         elif getattr(annotation, '__qualname__', None):
77             qualname = annotation.__qualname__
78         elif getattr(annotation, '__forward_arg__', None):
79             qualname = annotation.__forward_arg__
80         else:
81             qualname = stringify(annotation.__origin__)  # ex. Union
82     elif hasattr(annotation, '__qualname__'):
83         qualname = '%s.%s' % (module, annotation.__qualname__)
84     elif hasattr(annotation, '__origin__'):
85         # instantiated generic provided by a user
86         qualname = stringify(annotation.__origin__)
87     else:
88         # we weren't able to extract the base type, appending arguments would
89         # only make them appear twice
90         return repr(annotation)
91 
92     if getattr(annotation, '__args__', None):
93         if qualname == 'Union':
94             if len(annotation.__args__) > 1 and annotation.__args__[-1] is NoneType:
95                 if len(annotation.__args__) > 2:
96                     args = ', '.join(stringify(a) for a in annotation.__args__[:-1])
97                     return 'Optional[Union[%s]]' % args
98                 else:
99                     return 'Optional[%s]' % stringify(annotation.__args__[0])
100             else:
101                 args = ', '.join(stringify(a) for a in annotation.__args__)
102                 return 'Union[%s]' % args
103         elif qualname == 'Callable':
104             args = ', '.join(stringify(a) for a in annotation.__args__[:-1])
105             returns = stringify(annotation.__args__[-1])
106             return '%s[[%s], %s]' % (qualname, args, returns)
107         elif str(annotation).startswith('typing.Annotated'):  # for py39+
108             return stringify(annotation.__args__[0])
109         elif all(is_system_TypeVar(a) for a in annotation.__args__):
110             # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])
111             return qualname
112         else:
113             args = ', '.join(stringify(a) for a in annotation.__args__)
114             return '%s[%s]' % (qualname, args)
115 
116     return qualname
117 
118 
119 def _stringify_py36(annotation: Any) -> str:
120     """stringify() for py35 and py36."""
121     module = getattr(annotation, '__module__', None)
122     if module == 'typing':
123         if getattr(annotation, '_name', None):
124             qualname = annotation._name
125         elif getattr(annotation, '__qualname__', None):
126             qualname = annotation.__qualname__
127         elif getattr(annotation, '__forward_arg__', None):
128             qualname = annotation.__forward_arg__
129         elif getattr(annotation, '__origin__', None):
130             qualname = stringify(annotation.__origin__)  # ex. Union
131         else:
132             qualname = repr(annotation).replace('typing.', '')
133     elif hasattr(annotation, '__qualname__'):
134         qualname = '%s.%s' % (module, annotation.__qualname__)
135     else:
136         qualname = repr(annotation)
137 
138     if (isinstance(annotation, typing.TupleMeta) and  # type: ignore
139             not hasattr(annotation, '__tuple_params__')):  # for Python 3.6
140         params = annotation.__args__
141         if params:
142             param_str = ', '.join(stringify(p) for p in params)
143             return '%s[%s]' % (qualname, param_str)
144         else:
145             return qualname
146     elif isinstance(annotation, typing.GenericMeta):
147         params = None
148         if hasattr(annotation, '__args__'):
149             # for Python 3.5.2+
150             if annotation.__args__ is None or len(annotation.__args__) <= 2:  # type: ignore  # NOQA
151                 params = annotation.__args__  # type: ignore
152             else:  # typing.Callable
153                 args = ', '.join(stringify(arg) for arg
154                                  in annotation.__args__[:-1])  # type: ignore
155                 result = stringify(annotation.__args__[-1])  # type: ignore
156                 return '%s[[%s], %s]' % (qualname, args, result)
157         elif hasattr(annotation, '__parameters__'):
158             # for Python 3.5.0 and 3.5.1
159             params = annotation.__parameters__  # type: ignore
160         if params is not None:
161             param_str = ', '.join(stringify(p) for p in params)
162             return '%s[%s]' % (qualname, param_str)
163     elif (hasattr(typing, 'UnionMeta') and
164           isinstance(annotation, typing.UnionMeta) and  # type: ignore
165           hasattr(annotation, '__union_params__')):  # for Python 3.5
166         params = annotation.__union_params__
167         if params is not None:
168             if len(params) == 2 and params[1] is NoneType:
169                 return 'Optional[%s]' % stringify(params[0])
170             else:
171                 param_str = ', '.join(stringify(p) for p in params)
172                 return '%s[%s]' % (qualname, param_str)
173     elif (hasattr(annotation, '__origin__') and
174           annotation.__origin__ is typing.Union):  # for Python 3.5.2+
175         params = annotation.__args__
176         if params is not None:
177             if len(params) > 1 and params[-1] is NoneType:
178                 if len(params) > 2:
179                     param_str = ", ".join(stringify(p) for p in params[:-1])
180                     return 'Optional[Union[%s]]' % param_str
181                 else:
182                     return 'Optional[%s]' % stringify(params[0])
183             else:
184                 param_str = ', '.join(stringify(p) for p in params)
185                 return 'Union[%s]' % param_str
186     elif (isinstance(annotation, typing.CallableMeta) and  # type: ignore
187           getattr(annotation, '__args__', None) is not None and
188           hasattr(annotation, '__result__')):  # for Python 3.5
189         # Skipped in the case of plain typing.Callable
190         args = annotation.__args__
191         if args is None:
192             return qualname
193         elif args is Ellipsis:
194             args_str = '...'
195         else:
196             formatted_args = (stringify(a) for a in args)
197             args_str = '[%s]' % ', '.join(formatted_args)
198         return '%s[%s, %s]' % (qualname,
199                                args_str,
200                                stringify(annotation.__result__))
201     elif (isinstance(annotation, typing.TupleMeta) and  # type: ignore
202           hasattr(annotation, '__tuple_params__') and
203           hasattr(annotation, '__tuple_use_ellipsis__')):  # for Python 3.5
204         params = annotation.__tuple_params__
205         if params is not None:
206             param_strings = [stringify(p) for p in params]
207             if annotation.__tuple_use_ellipsis__:
208                 param_strings.append('...')
209             return '%s[%s]' % (qualname,
210                                ', '.join(param_strings))
211 
212     return qualname

</code><intended_behavior>These methods should ensure that when handling `TypeVar` objects, they convert these to their string representations safely without attempting to directly concatenate them with strings or perform other operations that could lead to `TypeError`. This involves checking the type of the object being stringified and applying an appropriate conversion method to handle `TypeVar` objects, thus preserving the functionality of documenting generic types accurately.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
20 )
21 
22 from docutils.statemachine import StringList
23 
24 import sphinx
25 from sphinx.application import Sphinx
26 from sphinx.config import Config, ENUM
27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
28 from sphinx.environment import BuildEnvironment
29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
30 from sphinx.ext.autodoc.mock import mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect
34 from sphinx.util import logging
35 from sphinx.util import split_full_qualified_name
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43     from sphinx.ext.autodoc.directive import DocumenterBridge
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 
49 # This type isn't exposed directly in any modules, but can be found
50 # here in most Python versions
51 MethodDescriptorType = type(type.__subclasses__)
52 
53 
54 #: extended signature RE: with explicit module name separated by ::
55 py_ext_sig_re = re.compile(
56     r'''^ ([\w.]+::)?            # explicit module name
57           ([\w.]+\.)?            # module and/or class name(s)
58           (\w+)  \s*             # thing name
59           (?: \((.*)\)           # optional: arguments
60            (?:\s* -> \s* (.*))?  #           return annotation
61           )? $                   # and nothing more
62           ''', re.VERBOSE)
63 
64 
65 def identity(x: Any) -> Any:
66     return x
67 
68 
69 ALL = object()
70 UNINITIALIZED_ATTR = object()
71 INSTANCEATTR = object()
72 SLOTSATTR = object()
73 
74 
75 def members_option(arg: Any) -> Union[object, List[str]]:
76     """Used to convert the :members: option to auto directives."""
77     if arg is None or arg is True:
78         return ALL
79     return [x.strip() for x in arg.split(',') if x.strip()]
80 
81 
82 def members_set_option(arg: Any) -> Union[object, Set[str]]:
83     """Used to convert the :members: option to auto directives."""
84     if arg is None:
85         return ALL
86     return {x.strip() for x in arg.split(',') if x.strip()}
87 
88 
89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
90     """Used to convert the :members: option to auto directives."""
91     if arg is None:
92         return 'object'
93     else:
94         return arg
95 
96 
97 def member_order_option(arg: Any) -> Optional[str]:
98     """Used to convert the :members: option to auto directives."""
99     if arg is None:
100         return None
101     elif arg in ('alphabetical', 'bysource', 'groupwise'):
102         return arg
103     else:
104         raise ValueError(__('invalid value for member-order option: %s') % arg)
105 
106 
107 SUPPRESS = object()
108 
109 
110 def annotation_option(arg: Any) -> Any:
111     if arg is None:
112         # suppress showing the representation of the object
113         return SUPPRESS
114     else:
115         return arg
116 
117 
118 def bool_option(arg: Any) -> bool:
119     """Used to convert flag options to auto directives.  (Instead of
120     directives.flag(), which returns None).
121     """
122     return True
123 
124 
125 def merge_special_members_option(options: Dict) -> None:
126     """Merge :special-members: option to :members: option."""
127     if 'special-members' in options and options['special-members'] is not ALL:
128         if options.get('members') is ALL:
129             pass
130         elif options.get('members'):
131             for member in options['special-members']:
132                 if member not in options['members']:
133                     options['members'].append(member)
134         else:
135             options['members'] = options['special-members']
136 
137 
138 # Some useful event listener factories for autodoc-process-docstring.
139 
140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
141     """Return a listener that removes the first *pre* and last *post*
142     lines of every docstring.  If *what* is a sequence of strings,
143     only docstrings of a type in *what* will be processed.
144 
145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
146 
147        from sphinx.ext.autodoc import cut_lines
148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
149 
150     This can (and should) be used in place of :confval:`automodule_skip_lines`.
151     """
152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
153                 ) -> None:
154         if what and what_ not in what:
155             return
156         del lines[:pre]
157         if post:
158             # remove one trailing blank line.
159             if lines and not lines[-1]:
160                 lines.pop(-1)
161             del lines[-post:]
162         # make sure there is a blank line at the end
163         if lines and lines[-1]:
164             lines.append('')
165     return process
166 
167 
168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
169             exclude: bool = False) -> Callable:
170     """Return a listener that either keeps, or if *exclude* is True excludes,
171     lines between lines that match the *marker* regular expression.  If no line
172     matches, the resulting docstring would be empty, so no change will be made
173     unless *keepempty* is true.
174 
175     If *what* is a sequence of strings, only docstrings of a type in *what* will
176     be processed.
177     """
178     marker_re = re.compile(marker)
179 
180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
181                 ) -> None:
182         if what and what_ not in what:
183             return
184         deleted = 0
185         delete = not exclude
186         orig_lines = lines[:]
187         for i, line in enumerate(orig_lines):
188             if delete:
189                 lines.pop(i - deleted)
190                 deleted += 1
191             if marker_re.match(line):
192                 delete = not delete
193                 if delete:
194                     lines.pop(i - deleted)
195                     deleted += 1
196         if not lines and not keepempty:
197             lines[:] = orig_lines
198         # make sure there is a blank line at the end
199         if lines and lines[-1]:
200             lines.append('')
201     return process
202 
203 
204 # This class is used only in ``sphinx.ext.autodoc.directive``,
205 # But we define this class here to keep compatibility (see #4538)
206 class Options(dict):
207     """A dict/attribute hybrid that returns None on nonexisting keys."""
208     def __getattr__(self, name: str) -> Any:
209         try:
210             return self[name.replace('_', '-')]
211         except KeyError:
212             return None
213 
214 
215 class Documenter:
216     """
217     A Documenter knows how to autodocument a single object type.  When
218     registered with the AutoDirective, it will be used to document objects
219     of that type when needed by autodoc.
220 
221     Its *objtype* attribute selects what auto directive it is assigned to
222     (the directive name is 'auto' + objtype), and what directive it generates
223     by default, though that can be overridden by an attribute called
224     *directivetype*.
225 
226     A Documenter has an *option_spec* that works like a docutils directive's;
227     in fact, it will be used to parse an auto directive's options that matches
228     the documenter.
229     """
230     #: name by which the directive is called (auto...) and the default
231     #: generated directive name
232     objtype = 'object'
233     #: indentation by which to indent the directive content
234     content_indent = '   '
235     #: priority if multiple documenters return True from can_document_member
236     priority = 0
237     #: order if autodoc_member_order is set to 'groupwise'
238     member_order = 0
239     #: true if the generated content may contain titles
240     titles_allowed = False
241 
242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
243 
244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
245         """getattr() override for types such as Zope interfaces."""
246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
247 
248     @classmethod
249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
250                             ) -> bool:
251         """Called to see if a member can be documented by this documenter."""
252         raise NotImplementedError('must be implemented in subclasses')
253 
254     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
255         self.directive = directive
256         self.env = directive.env    # type: BuildEnvironment
257         self.options = directive.genopt
258         self.name = name
259         self.indent = indent
260         # the module and object path within the module, and the fully
261         # qualified name (all set after resolve_name succeeds)
262         self.modname = None         # type: str
263         self.module = None          # type: ModuleType
264         self.objpath = None         # type: List[str]
265         self.fullname = None        # type: str
266         # extra signature items (arguments and return annotation,
267         # also set after resolve_name succeeds)
268         self.args = None            # type: str
269         self.retann = None          # type: str
270         # the object to document (set after import_object succeeds)
271         self.object = None          # type: Any
272         self.object_name = None     # type: str
273         # the parent/owner of the object to document
274         self.parent = None          # type: Any
275         # the module analyzer to get at attribute docs, or None
276         self.analyzer = None        # type: ModuleAnalyzer
277 
278     @property
279     def documenters(self) -> Dict[str, "Type[Documenter]"]:
280         """Returns registered Documenter classes"""
281         return self.env.app.registry.documenters
282 
283     def add_line(self, line: str, source: str, *lineno: int) -> None:
284         """Append one line of generated reST to the output."""
285         if line.strip():  # not a blank line
286             self.directive.result.append(self.indent + line, source, *lineno)
287         else:
288             self.directive.result.append('', source, *lineno)
289 
290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
291                      ) -> Tuple[str, List[str]]:
292         """Resolve the module and name of the object to document given by the
293         arguments and the current module/class.
294 
295         Must return a pair of the module name and a chain of attributes; for
296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
297         ``zipfile.ZipFile.open`` method.
298         """
299         raise NotImplementedError('must be implemented in subclasses')
300 
301     def parse_name(self) -> bool:
302         """Determine what module to import and what attribute to document.
303 
304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
305         *self.args* and *self.retann* if parsing and resolving was successful.
306         """
307         # first, parse the definition -- auto directives for classes and
308         # functions can contain a signature which is then used instead of
309         # an autogenerated one
310         try:
311             explicit_modname, path, base, args, retann = \
312                 py_ext_sig_re.match(self.name).groups()
313         except AttributeError:
314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
315                            type='autodoc')
316             return False
317 
318         # support explicit module and class name separation via ::
319         if explicit_modname is not None:
320             modname = explicit_modname[:-2]
321             parents = path.rstrip('.').split('.') if path else []
322         else:
323             modname = None
324             parents = []
325 
326         with mock(self.env.config.autodoc_mock_imports):
327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
328 
329         if not self.modname:
330             return False
331 
332         self.args = args
333         self.retann = retann
334         self.fullname = (self.modname or '') + \
335                         ('.' + '.'.join(self.objpath) if self.objpath else '')
336         return True
337 
338     def import_object(self) -> bool:
339         """Import the object given by *self.modname* and *self.objpath* and set
340         it as *self.object*.
341 
342         Returns True if successful, False if an error occurred.
343         """
344         with mock(self.env.config.autodoc_mock_imports):
345             try:
346                 ret = import_object(self.modname, self.objpath, self.objtype,
347                                     attrgetter=self.get_attr,
348                                     warningiserror=self.env.config.autodoc_warningiserror)
349                 self.module, self.parent, self.object_name, self.object = ret
350                 return True
351             except ImportError as exc:
352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
353                 self.env.note_reread()
354                 return False
355 
356     def get_real_modname(self) -> str:
357         """Get the real module name of an object to document.
358 
359         It can differ from the name of the module through which the object was
360         imported.
361         """
362         return self.get_attr(self.object, '__module__', None) or self.modname
363 
364     def check_module(self) -> bool:
365         """Check if *self.object* is really defined in the module given by
366         *self.modname*.
367         """
368         if self.options.imported_members:
369             return True
370 
371         subject = inspect.unpartial(self.object)
372         modname = self.get_attr(subject, '__module__', None)
373         if modname and modname != self.modname:
374             return False
375         return True
376 
377     def format_args(self, **kwargs: Any) -> str:
378         """Format the argument signature of *self.object*.
379 
380         Should return None if the object does not have a signature.
381         """
382         return None
383 
384     def format_name(self) -> str:
385         """Format the name of *self.object*.
386 
387         This normally should be something that can be parsed by the generated
388         directive, but doesn't need to be (Sphinx will display it unparsed
389         then).
390         """
391         # normally the name doesn't contain the module (except for module
392         # directives of course)
393         return '.'.join(self.objpath) or self.modname
394 
395     def _call_format_args(self, **kwargs: Any) -> str:
396         if kwargs:
397             try:
398                 return self.format_args(**kwargs)
399             except TypeError:
400                 # avoid chaining exceptions, by putting nothing here
401                 pass
402 
403         # retry without arguments for old documenters
404         return self.format_args()
405 
406     def format_signature(self, **kwargs: Any) -> str:
407         """Format the signature (arguments and return annotation) of the object.
408 
409         Let the user process it via the ``autodoc-process-signature`` event.
410         """
411         if self.args is not None:
412             # signature given explicitly
413             args = "(%s)" % self.args
414             retann = self.retann
415         else:
416             # try to introspect the signature
417             try:
418                 retann = None
419                 args = self._call_format_args(**kwargs)
420                 if args:
421                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
422                     if matched:
423                         args = matched.group(1)
424                         retann = matched.group(2)
425             except Exception as exc:
426                 logger.warning(__('error while formatting arguments for %s: %s'),
427                                self.fullname, exc, type='autodoc')
428                 args = None
429 
430         result = self.env.events.emit_firstresult('autodoc-process-signature',
431                                                   self.objtype, self.fullname,
432                                                   self.object, self.options, args, retann)
433         if result:
434             args, retann = result
435 
436         if args is not None:
437             return args + ((' -> %s' % retann) if retann else '')
438         else:
439             return ''
440 
441     def add_directive_header(self, sig: str) -> None:
442         """Add the directive header and options to the generated content."""
443         domain = getattr(self, 'domain', 'py')
444         directive = getattr(self, 'directivetype', self.objtype)
445         name = self.format_name()
446         sourcename = self.get_sourcename()
447 
448         # one signature per line, indented by column
449         prefix = '.. %s:%s:: ' % (domain, directive)
450         for i, sig_line in enumerate(sig.split("\n")):
451             self.add_line('%s%s%s' % (prefix, name, sig_line),
452                           sourcename)
453             if i == 0:
454                 prefix = " " * len(prefix)
455 
456         if self.options.noindex:
457             self.add_line('   :noindex:', sourcename)
458         if self.objpath:
459             # Be explicit about the module, this is necessary since .. class::
460             # etc. don't support a prepended module name
461             self.add_line('   :module: %s' % self.modname, sourcename)
462 
463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
464         """Decode and return lines of the docstring(s) for the object."""
465         if encoding is not None:
466             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
467                           % self.__class__.__name__,
468                           RemovedInSphinx40Warning, stacklevel=2)
469         if ignore is not None:
470             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
471                           % self.__class__.__name__,
472                           RemovedInSphinx50Warning, stacklevel=2)
473         docstring = getdoc(self.object, self.get_attr,
474                            self.env.config.autodoc_inherit_docstrings,
475                            self.parent, self.object_name)
476         if docstring:
477             tab_width = self.directive.state.document.settings.tab_width
478             return [prepare_docstring(docstring, ignore, tab_width)]
479         return []
480 
481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
482         """Let the user process the docstrings before adding them."""
483         for docstringlines in docstrings:
484             if self.env.app:
485                 # let extensions preprocess docstrings
486                 self.env.app.emit('autodoc-process-docstring',
487                                   self.objtype, self.fullname, self.object,
488                                   self.options, docstringlines)
489             yield from docstringlines
490 
491     def get_sourcename(self) -> str:
492         if self.analyzer:
493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
494         return 'docstring of %s' % self.fullname
495 
496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
497         """Add content from docstrings, attribute documentation and user."""
498         # set sourcename and add content from attribute documentation
499         sourcename = self.get_sourcename()
500         if self.analyzer:
501             attr_docs = self.analyzer.find_attr_docs()
502             if self.objpath:
503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
504                 if key in attr_docs:
505                     no_docstring = True
506                     # make a copy of docstring for attributes to avoid cache
507                     # the change of autodoc-process-docstring event.
508                     docstrings = [list(attr_docs[key])]
509 
510                     for i, line in enumerate(self.process_doc(docstrings)):
511                         self.add_line(line, sourcename, i)
512 
513         # add content from docstrings
514         if not no_docstring:
515             docstrings = self.get_doc()
516             if not docstrings:
517                 # append at least a dummy docstring, so that the event
518                 # autodoc-process-docstring is fired and can add some
519                 # content if desired
520                 docstrings.append([])
521             for i, line in enumerate(self.process_doc(docstrings)):
522                 self.add_line(line, sourcename, i)
523 
524         # add additional content (e.g. from document), if present
525         if more_content:
526             for line, src in zip(more_content.data, more_content.items):
527                 self.add_line(line, src[0], src[1])
528 
529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
530         """Return `(members_check_module, members)` where `members` is a
531         list of `(membername, member)` pairs of the members of *self.object*.
532 
533         If *want_all* is True, return all members.  Else, only return those
534         members given by *self.options.members* (which may also be none).
535         """
536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
537         if not want_all:
538             if not self.options.members:
539                 return False, []
540             # specific members given
541             selected = []
542             for name in self.options.members:
543                 if name in members:
544                     selected.append((name, members[name].value))
545                 else:
546                     logger.warning(__('missing attribute %s in object %s') %
547                                    (name, self.fullname), type='autodoc')
548             return False, selected
549         elif self.options.inherited_members:
550             return False, [(m.name, m.value) for m in members.values()]
551         else:
552             return False, [(m.name, m.value) for m in members.values()
553                            if m.directly_defined]
554 
555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
556                        ) -> List[Tuple[str, Any, bool]]:
557         """Filter the given member list.
558 
559         Members are skipped if
560 
561         - they are private (except if given explicitly or the private-members
562           option is set)
563         - they are special methods (except if given explicitly or the
564           special-members option is set)
565         - they are undocumented (except if the undoc-members option is set)
566 
567         The user can override the skipping decision by connecting to the
568         ``autodoc-skip-member`` event.
569         """
570         def is_filtered_inherited_member(name: str) -> bool:
571             if inspect.isclass(self.object):
572                 for cls in self.object.__mro__:
573                     if cls.__name__ == self.options.inherited_members and cls != self.object:
574                         # given member is a member of specified *super class*
575                         return True
576                     elif name in cls.__dict__:
577                         return False
578 
579             return False
580 
581         ret = []
582 
583         # search for members in source code too
584         namespace = '.'.join(self.objpath)  # will be empty for modules
585 
586         if self.analyzer:
587             attr_docs = self.analyzer.find_attr_docs()
588         else:
589             attr_docs = {}
590 
591         # process members and determine which to skip
592         for (membername, member) in members:
593             # if isattr is True, the member is documented as an attribute
594             if member is INSTANCEATTR:
595                 isattr = True
596             else:
597                 isattr = False
598 
599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
600                          self.parent, self.object_name)
601             if not isinstance(doc, str):
602                 # Ignore non-string __doc__
603                 doc = None
604 
605             # if the member __doc__ is the same as self's __doc__, it's just
606             # inherited and therefore not the member's doc
607             cls = self.get_attr(member, '__class__', None)
608             if cls:
609                 cls_doc = self.get_attr(cls, '__doc__', None)
610                 if cls_doc == doc:
611                     doc = None
612             has_doc = bool(doc)
613 
614             metadata = extract_metadata(doc)
615             if 'private' in metadata:
616                 # consider a member private if docstring has "private" metadata
617                 isprivate = True
618             elif 'public' in metadata:
619                 # consider a member public if docstring has "public" metadata
620                 isprivate = False
621             else:
622                 isprivate = membername.startswith('_')
623 
624             keep = False
625             if safe_getattr(member, '__sphinx_mock__', False):
626                 # mocked module or object
627                 pass
628             elif want_all and membername.startswith('__') and \
629                     membername.endswith('__') and len(membername) > 4:
630                 # special __methods__
631                 if self.options.special_members is ALL:
632                     if membername == '__doc__':
633                         keep = False
634                     elif is_filtered_inherited_member(membername):
635                         keep = False
636                     else:
637                         keep = has_doc or self.options.undoc_members
638                 elif self.options.special_members:
639                     if membername in self.options.special_members:
640                         keep = has_doc or self.options.undoc_members
641             elif (namespace, membername) in attr_docs:
642                 if want_all and isprivate:
643                     # ignore members whose name starts with _ by default
644                     keep = self.options.private_members
645                 else:
646                     # keep documented attributes
647                     keep = True
648                 isattr = True
649             elif want_all and isprivate:
650                 # ignore members whose name starts with _ by default
651                 keep = self.options.private_members and \
652                     (has_doc or self.options.undoc_members)
653             else:
654                 if self.options.members is ALL and is_filtered_inherited_member(membername):
655                     keep = False
656                 else:
657                     # ignore undocumented members if :undoc-members: is not given
658                     keep = has_doc or self.options.undoc_members
659 
660             # give the user a chance to decide whether this member
661             # should be skipped
662             if self.env.app:
663                 # let extensions preprocess docstrings
664                 try:
665                     skip_user = self.env.app.emit_firstresult(
666                         'autodoc-skip-member', self.objtype, membername, member,
667                         not keep, self.options)
668                     if skip_user is not None:
669                         keep = not skip_user
670                 except Exception as exc:
671                     logger.warning(__('autodoc: failed to determine %r to be documented, '
672                                       'the following exception was raised:\n%s'),
673                                    member, exc, type='autodoc')
674                     keep = False
675 
676             if keep:
677                 ret.append((membername, member, isattr))
678 
679         return ret
680 
681     def document_members(self, all_members: bool = False) -> None:
682         """Generate reST for member documentation.
683 
684         If *all_members* is True, do all members, else those given by
685         *self.options.members*.
686         """
687         # set current namespace for finding members
688         self.env.temp_data['autodoc:module'] = self.modname
689         if self.objpath:
690             self.env.temp_data['autodoc:class'] = self.objpath[0]
691 
692         want_all = all_members or self.options.inherited_members or \
693             self.options.members is ALL
694         # find out which members are documentable
695         members_check_module, members = self.get_object_members(want_all)
696 
697         # remove members given by exclude-members
698         if self.options.exclude_members:
699             members = [
700                 (membername, member) for (membername, member) in members
701                 if (
702                     self.options.exclude_members is ALL or
703                     membername not in self.options.exclude_members
704                 )
705             ]
706 
707         # document non-skipped members
708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
709         for (mname, member, isattr) in self.filter_members(members, want_all):
710             classes = [cls for cls in self.documenters.values()
711                        if cls.can_document_member(member, mname, isattr, self)]
712             if not classes:
713                 # don't know how to document this member
714                 continue
715             # prefer the documenter with the highest priority
716             classes.sort(key=lambda cls: cls.priority)
717             # give explicitly separated module name, so that members
718             # of inner classes can be documented
719             full_mname = self.modname + '::' + \
720                 '.'.join(self.objpath + [mname])
721             documenter = classes[-1](self.directive, full_mname, self.indent)
722             memberdocumenters.append((documenter, isattr))
723 
724         member_order = self.options.member_order or self.env.config.autodoc_member_order
725         memberdocumenters = self.sort_members(memberdocumenters, member_order)
726 
727         for documenter, isattr in memberdocumenters:
728             documenter.generate(
729                 all_members=True, real_modname=self.real_modname,
730                 check_module=members_check_module and not isattr)
731 
732         # reset current objects
733         self.env.temp_data['autodoc:module'] = None
734         self.env.temp_data['autodoc:class'] = None
735 
736     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
737                      order: str) -> List[Tuple["Documenter", bool]]:
738         """Sort the given member list."""
739         if order == 'groupwise':
740             # sort by group; alphabetically within groups
741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
742         elif order == 'bysource':
743             if self.analyzer:
744                 # sort by source order, by virtue of the module analyzer
745                 tagorder = self.analyzer.tagorder
746 
747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
748                     fullname = entry[0].name.split('::')[1]
749                     return tagorder.get(fullname, len(tagorder))
750                 documenters.sort(key=keyfunc)
751             else:
752                 # Assume that member discovery order matches source order.
753                 # This is a reasonable assumption in Python 3.6 and up, where
754                 # module.__dict__ is insertion-ordered.
755                 pass
756         else:  # alphabetical
757             documenters.sort(key=lambda e: e[0].name)
758 
759         return documenters
760 
761     def generate(self, more_content: Any = None, real_modname: str = None,
762                  check_module: bool = False, all_members: bool = False) -> None:
763         """Generate reST for the object given by *self.name*, and possibly for
764         its members.
765 
766         If *more_content* is given, include that content. If *real_modname* is
767         given, use that module name to find attribute docs. If *check_module* is
768         True, only generate if the object is defined in the module name it is
769         imported from. If *all_members* is True, document all members.
770         """
771         if not self.parse_name():
772             # need a module to import
773             logger.warning(
774                 __('don\'t know which module to import for autodocumenting '
775                    '%r (try placing a "module" or "currentmodule" directive '
776                    'in the document, or giving an explicit module name)') %
777                 self.name, type='autodoc')
778             return
779 
780         # now, import the module and get object to document
781         if not self.import_object():
782             return
783 
784         # If there is no real module defined, figure out which to use.
785         # The real module is used in the module analyzer to look up the module
786         # where the attribute documentation would actually be found in.
787         # This is used for situations where you have a module that collects the
788         # functions and classes of internal submodules.
789         guess_modname = self.get_real_modname()
790         self.real_modname = real_modname or guess_modname
791 
792         # try to also get a source code analyzer for attribute docs
793         try:
794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
795             # parse right now, to get PycodeErrors on parsing (results will
796             # be cached anyway)
797             self.analyzer.find_attr_docs()
798         except PycodeError as exc:
799             logger.debug('[autodoc] module analyzer failed: %s', exc)
800             # no source file -- e.g. for builtin and C modules
801             self.analyzer = None
802             # at least add the module.__file__ as a dependency
803             if hasattr(self.module, '__file__') and self.module.__file__:
804                 self.directive.filename_set.add(self.module.__file__)
805         else:
806             self.directive.filename_set.add(self.analyzer.srcname)
807 
808         if self.real_modname != guess_modname:
809             # Add module to dependency list if target object is defined in other module.
810             try:
811                 analyzer = ModuleAnalyzer.for_module(guess_modname)
812                 self.directive.filename_set.add(analyzer.srcname)
813             except PycodeError:
814                 pass
815 
816         # check __module__ of object (for members not given explicitly)
817         if check_module:
818             if not self.check_module():
819                 return
820 
821         sourcename = self.get_sourcename()
822 
823         # make sure that the result starts with an empty line.  This is
824         # necessary for some situations where another directive preprocesses
825         # reST and no starting newline is present
826         self.add_line('', sourcename)
827 
828         # format the object's signature, if any
829         sig = self.format_signature()
830 
831         # generate the directive header and options, if applicable
832         self.add_directive_header(sig)
833         self.add_line('', sourcename)
834 
835         # e.g. the module directive doesn't have content
836         self.indent += self.content_indent
837 
838         # add all content (from docstrings, attribute docs etc.)
839         self.add_content(more_content)
840 
841         # document members, if possible
842         self.document_members(all_members)
843 
844 
845 class ModuleDocumenter(Documenter):
846     """
847     Specialized Documenter subclass for modules.
848     """
849     objtype = 'module'
850     content_indent = ''
851     titles_allowed = True
852 
853     option_spec = {
854         'members': members_option, 'undoc-members': bool_option,
855         'noindex': bool_option, 'inherited-members': inherited_members_option,
856         'show-inheritance': bool_option, 'synopsis': identity,
857         'platform': identity, 'deprecated': bool_option,
858         'member-order': member_order_option, 'exclude-members': members_set_option,
859         'private-members': bool_option, 'special-members': members_option,
860         'imported-members': bool_option, 'ignore-module-all': bool_option
861     }  # type: Dict[str, Callable]
862 
863     def __init__(self, *args: Any) -> None:
864         super().__init__(*args)
865         merge_special_members_option(self.options)
866         self.__all__ = None
867 
868     @classmethod
869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
870                             ) -> bool:
871         # don't document submodules automatically
872         return False
873 
874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
875                      ) -> Tuple[str, List[str]]:
876         if modname is not None:
877             logger.warning(__('"::" in automodule name doesn\'t make sense'),
878                            type='autodoc')
879         return (path or '') + base, []
880 
881     def parse_name(self) -> bool:
882         ret = super().parse_name()
883         if self.args or self.retann:
884             logger.warning(__('signature arguments or return annotation '
885                               'given for automodule %s') % self.fullname,
886                            type='autodoc')
887         return ret
888 
889     def import_object(self) -> Any:
890         def is_valid_module_all(__all__: Any) -> bool:
891             """Check the given *__all__* is valid for a module."""
892             if (isinstance(__all__, (list, tuple)) and
893                     all(isinstance(e, str) for e in __all__)):
894                 return True
895             else:
896                 return False
897 
898         ret = super().import_object()
899 
900         if not self.options.ignore_module_all:
901             __all__ = getattr(self.object, '__all__', None)
902             if is_valid_module_all(__all__):
903                 # valid __all__ found. copy it to self.__all__
904                 self.__all__ = __all__
905             elif __all__:
906                 # invalid __all__ found.
907                 logger.warning(__('__all__ should be a list of strings, not %r '
908                                   '(in module %s) -- ignoring __all__') %
909                                (__all__, self.fullname), type='autodoc')
910 
911         return ret
912 
913     def add_directive_header(self, sig: str) -> None:
914         Documenter.add_directive_header(self, sig)
915 
916         sourcename = self.get_sourcename()
917 
918         # add some module-specific options
919         if self.options.synopsis:
920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
921         if self.options.platform:
922             self.add_line('   :platform: ' + self.options.platform, sourcename)
923         if self.options.deprecated:
924             self.add_line('   :deprecated:', sourcename)
925 
926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
927         if want_all:
928             if self.__all__:
929                 memberlist = self.__all__
930             else:
931                 # for implicit module members, check __module__ to avoid
932                 # documenting imported objects
933                 return True, get_module_members(self.object)
934         else:
935             memberlist = self.options.members or []
936         ret = []
937         for mname in memberlist:
938             try:
939                 ret.append((mname, safe_getattr(self.object, mname)))
940             except AttributeError:
941                 logger.warning(
942                     __('missing attribute mentioned in :members: or __all__: '
943                        'module %s, attribute %s') %
944                     (safe_getattr(self.object, '__name__', '???'), mname),
945                     type='autodoc'
946                 )
947         return False, ret
948 
949     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
950                      order: str) -> List[Tuple["Documenter", bool]]:
951         if order == 'bysource' and self.__all__:
952             # Sort alphabetically first (for members not listed on the __all__)
953             documenters.sort(key=lambda e: e[0].name)
954 
955             # Sort by __all__
956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
957                 name = entry[0].name.split('::')[1]
958                 if name in self.__all__:
959                     return self.__all__.index(name)
960                 else:
961                     return len(self.__all__)
962             documenters.sort(key=keyfunc)
963 
964             return documenters
965         else:
966             return super().sort_members(documenters, order)
967 
968 
969 class ModuleLevelDocumenter(Documenter):
970     """
971     Specialized Documenter subclass for objects on module level (functions,
972     classes, data/constants).
973     """
974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
975                      ) -> Tuple[str, List[str]]:
976         if modname is None:
977             if path:
978                 stripped = path.rstrip('.')
979                 modname, qualname = split_full_qualified_name(stripped)
980                 if qualname:
981                     parents = qualname.split(".")
982                 else:
983                     parents = []
984 
985             if modname is None:
986                 # if documenting a toplevel object without explicit module,
987                 # it can be contained in another auto directive ...
988                 modname = self.env.temp_data.get('autodoc:module')
989                 # ... or in the scope of a module directive
990                 if not modname:
991                     modname = self.env.ref_context.get('py:module')
992                 # ... else, it stays None, which means invalid
993         return modname, parents + [base]
994 
995 
996 class ClassLevelDocumenter(Documenter):
997     """
998     Specialized Documenter subclass for objects on class level (methods,
999     attributes).
1000     """
1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1002                      ) -> Tuple[str, List[str]]:
1003         if modname is None:
1004             if path:
1005                 mod_cls = path.rstrip('.')
1006             else:
1007                 mod_cls = None
1008                 # if documenting a class-level object without path,
1009                 # there must be a current class, either from a parent
1010                 # auto directive ...
1011                 mod_cls = self.env.temp_data.get('autodoc:class')
1012                 # ... or from a class directive
1013                 if mod_cls is None:
1014                     mod_cls = self.env.ref_context.get('py:class')
1015                 # ... if still None, there's no way to know
1016                 if mod_cls is None:
1017                     return None, []
1018 
1019             try:
1020                 modname, qualname = split_full_qualified_name(mod_cls)
1021                 parents = qualname.split(".") if qualname else []
1022             except ImportError:
1023                 parents = mod_cls.split(".")
1024 
1025             # if the module name is still missing, get it like above
1026             if not modname:
1027                 modname = self.env.temp_data.get('autodoc:module')
1028             if not modname:
1029                 modname = self.env.ref_context.get('py:module')
1030             # ... else, it stays None, which means invalid
1031         return modname, parents + [base]
1032 
1033 
1034 class DocstringSignatureMixin:
1035     """
1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1037     feature of reading the signature from the docstring.
1038     """
1039     _new_docstrings = None  # type: List[List[str]]
1040     _signatures = None      # type: List[str]
1041 
1042     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1043         if encoding is not None:
1044             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1045                           "deprecated." % self.__class__.__name__,
1046                           RemovedInSphinx40Warning, stacklevel=2)
1047 
1048         # candidates of the object name
1049         valid_names = [self.objpath[-1]]  # type: ignore
1050         if isinstance(self, ClassDocumenter):
1051             valid_names.append('__init__')
1052             if hasattr(self.object, '__mro__'):
1053                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1054 
1055         docstrings = self.get_doc()
1056         self._new_docstrings = docstrings[:]
1057         self._signatures = []
1058         result = None
1059         for i, doclines in enumerate(docstrings):
1060             for j, line in enumerate(doclines):
1061                 if not line:
1062                     # no lines in docstring, no match
1063                     break
1064 
1065                 if line.endswith('\\'):
1066                     multiline = True
1067                     line = line.rstrip('\\').rstrip()
1068                 else:
1069                     multiline = False
1070 
1071                 # match first line of docstring against signature RE
1072                 match = py_ext_sig_re.match(line)
1073                 if not match:
1074                     continue
1075                 exmod, path, base, args, retann = match.groups()
1076 
1077                 # the base name must match ours
1078                 if base not in valid_names:
1079                     continue
1080 
1081                 # re-prepare docstring to ignore more leading indentation
1082                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1083                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1084                                                             tabsize=tab_width)
1085 
1086                 if result is None:
1087                     # first signature
1088                     result = args, retann
1089                 else:
1090                     # subsequent signatures
1091                     self._signatures.append("(%s) -> %s" % (args, retann))
1092 
1093                 if multiline:
1094                     # the signature have multiple signatures on docstring
1095                     continue
1096                 else:
1097                     # don't look any further
1098                     break
1099 
1100             if result:
1101                 # finish the loop when signature found
1102                 break
1103 
1104         return result
1105 
1106     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1107         if encoding is not None:
1108             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1109                           % self.__class__.__name__,
1110                           RemovedInSphinx40Warning, stacklevel=2)
1111         if self._new_docstrings is not None:
1112             return self._new_docstrings
1113         return super().get_doc(None, ignore)  # type: ignore
1114 
1115     def format_signature(self, **kwargs: Any) -> str:
1116         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1117             # only act if a signature is not explicitly given already, and if
1118             # the feature is enabled
1119             result = self._find_signature()
1120             if result is not None:
1121                 self.args, self.retann = result
1122         sig = super().format_signature(**kwargs)  # type: ignore
1123         if self._signatures:
1124             return "\n".join([sig] + self._signatures)
1125         else:
1126             return sig
1127 
1128 
1129 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1130     """
1131     Mixin for AttributeDocumenter to provide the
1132     feature of stripping any function signature from the docstring.
1133     """
1134     def format_signature(self, **kwargs: Any) -> str:
1135         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1136             # only act if a signature is not explicitly given already, and if
1137             # the feature is enabled
1138             result = self._find_signature()
1139             if result is not None:
1140                 # Discarding _args is a only difference with
1141                 # DocstringSignatureMixin.format_signature.
1142                 # Documenter.format_signature use self.args value to format.
1143                 _args, self.retann = result
1144         return super().format_signature(**kwargs)
1145 
1146 
1147 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1148     """
1149     Specialized Documenter subclass for functions.
1150     """
1151     objtype = 'function'
1152     member_order = 30
1153 
1154     @classmethod
1155     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1156                             ) -> bool:
1157         # supports functions, builtins and bound methods exported at the module level
1158         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1159                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1160 
1161     def format_args(self, **kwargs: Any) -> str:
1162         if self.env.config.autodoc_typehints in ('none', 'description'):
1163             kwargs.setdefault('show_annotation', False)
1164 
1165         try:
1166             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1167             if inspect.is_singledispatch_function(self.object):
1168                 sig = inspect.signature(self.object, follow_wrapped=True)
1169             else:
1170                 sig = inspect.signature(self.object)
1171             args = stringify_signature(sig, **kwargs)
1172         except TypeError as exc:
1173             logger.warning(__("Failed to get a function signature for %s: %s"),
1174                            self.fullname, exc)
1175             return None
1176         except ValueError:
1177             args = ''
1178 
1179         if self.env.config.strip_signature_backslash:
1180             # escape backslashes for reST
1181             args = args.replace('\\', '\\\\')
1182         return args
1183 
1184     def document_members(self, all_members: bool = False) -> None:
1185         pass
1186 
1187     def add_directive_header(self, sig: str) -> None:
1188         sourcename = self.get_sourcename()
1189         super().add_directive_header(sig)
1190 
1191         if inspect.iscoroutinefunction(self.object):
1192             self.add_line('   :async:', sourcename)
1193 
1194     def format_signature(self, **kwargs: Any) -> str:
1195         sigs = []
1196         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1197             # Use signatures for overloaded functions instead of the implementation function.
1198             overloaded = True
1199         else:
1200             overloaded = False
1201             sig = super().format_signature(**kwargs)
1202             sigs.append(sig)
1203 
1204         if inspect.is_singledispatch_function(self.object):
1205             # append signature of singledispatch'ed functions
1206             for typ, func in self.object.registry.items():
1207                 if typ is object:
1208                     pass  # default implementation. skipped.
1209                 else:
1210                     self.annotate_to_first_argument(func, typ)
1211 
1212                     documenter = FunctionDocumenter(self.directive, '')
1213                     documenter.object = func
1214                     documenter.objpath = [None]
1215                     sigs.append(documenter.format_signature())
1216         if overloaded:
1217             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1218                 sig = stringify_signature(overload, **kwargs)
1219                 sigs.append(sig)
1220 
1221         return "\n".join(sigs)
1222 
1223     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1224         """Annotate type hint to the first argument of function if needed."""
1225         try:
1226             sig = inspect.signature(func)
1227         except TypeError as exc:
1228             logger.warning(__("Failed to get a function signature for %s: %s"),
1229                            self.fullname, exc)
1230             return
1231         except ValueError:
1232             return
1233 
1234         if len(sig.parameters) == 0:
1235             return
1236 
1237         params = list(sig.parameters.values())
1238         if params[0].annotation is Parameter.empty:
1239             params[0] = params[0].replace(annotation=typ)
1240             try:
1241                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1242             except TypeError:
1243                 # failed to update signature (ex. built-in or extension types)
1244                 return
1245 
1246 
1247 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1248     """
1249     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1250 
1251     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1252     """
1253 
1254 
1255 class DecoratorDocumenter(FunctionDocumenter):
1256     """
1257     Specialized Documenter subclass for decorator functions.
1258     """
1259     objtype = 'decorator'
1260 
1261     # must be lower than FunctionDocumenter
1262     priority = -1
1263 
1264     def format_args(self, **kwargs: Any) -> Any:
1265         args = super().format_args(**kwargs)
1266         if ',' in args:
1267             return args
1268         else:
1269             return None
1270 
1271 
1272 # Types which have confusing metaclass signatures it would be best not to show.
1273 # These are listed by name, rather than storing the objects themselves, to avoid
1274 # needing to import the modules.
1275 _METACLASS_CALL_BLACKLIST = [
1276     'enum.EnumMeta.__call__',
1277 ]
1278 
1279 
1280 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1281     """
1282     Specialized Documenter subclass for classes.
1283     """
1284     objtype = 'class'
1285     member_order = 20
1286     option_spec = {
1287         'members': members_option, 'undoc-members': bool_option,
1288         'noindex': bool_option, 'inherited-members': inherited_members_option,
1289         'show-inheritance': bool_option, 'member-order': member_order_option,
1290         'exclude-members': members_set_option,
1291         'private-members': bool_option, 'special-members': members_option,
1292     }  # type: Dict[str, Callable]
1293 
1294     _signature_class = None  # type: Any
1295     _signature_method_name = None  # type: str
1296 
1297     def __init__(self, *args: Any) -> None:
1298         super().__init__(*args)
1299         merge_special_members_option(self.options)
1300 
1301     @classmethod
1302     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1303                             ) -> bool:
1304         return isinstance(member, type)
1305 
1306     def import_object(self) -> Any:
1307         ret = super().import_object()
1308         # if the class is documented under another name, document it
1309         # as data/attribute
1310         if ret:
1311             if hasattr(self.object, '__name__'):
1312                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1313             else:
1314                 self.doc_as_attr = True
1315         return ret
1316 
1317     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1318         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1319             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1320             if inspect.is_builtin_class_method(obj, attr):
1321                 return None
1322             attr = self.get_attr(obj, attr, None)
1323             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1324                 return None
1325             return attr
1326 
1327         # This sequence is copied from inspect._signature_from_callable.
1328         # ValueError means that no signature could be found, so we keep going.
1329 
1330         # First, let's see if it has an overloaded __call__ defined
1331         # in its metaclass
1332         call = get_user_defined_function_or_method(type(self.object), '__call__')
1333 
1334         if call is not None:
1335             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1336                 call = None
1337 
1338         if call is not None:
1339             self.env.app.emit('autodoc-before-process-signature', call, True)
1340             try:
1341                 sig = inspect.signature(call, bound_method=True)
1342                 return type(self.object), '__call__', sig
1343             except ValueError:
1344                 pass
1345 
1346         # Now we check if the 'obj' class has a '__new__' method
1347         new = get_user_defined_function_or_method(self.object, '__new__')
1348         if new is not None:
1349             self.env.app.emit('autodoc-before-process-signature', new, True)
1350             try:
1351                 sig = inspect.signature(new, bound_method=True)
1352                 return self.object, '__new__', sig
1353             except ValueError:
1354                 pass
1355 
1356         # Finally, we should have at least __init__ implemented
1357         init = get_user_defined_function_or_method(self.object, '__init__')
1358         if init is not None:
1359             self.env.app.emit('autodoc-before-process-signature', init, True)
1360             try:
1361                 sig = inspect.signature(init, bound_method=True)
1362                 return self.object, '__init__', sig
1363             except ValueError:
1364                 pass
1365 
1366         # None of the attributes are user-defined, so fall back to let inspect
1367         # handle it.
1368         # We don't know the exact method that inspect.signature will read
1369         # the signature from, so just pass the object itself to our hook.
1370         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1371         try:
1372             sig = inspect.signature(self.object, bound_method=False)
1373             return None, None, sig
1374         except ValueError:
1375             pass
1376 
1377         # Still no signature: happens e.g. for old-style classes
1378         # with __init__ in C and no `__text_signature__`.
1379         return None, None, None
1380 
1381     def format_args(self, **kwargs: Any) -> str:
1382         if self.env.config.autodoc_typehints in ('none', 'description'):
1383             kwargs.setdefault('show_annotation', False)
1384 
1385         try:
1386             self._signature_class, self._signature_method_name, sig = self._get_signature()
1387         except TypeError as exc:
1388             # __signature__ attribute contained junk
1389             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1390                            self.fullname, exc)
1391             return None
1392 
1393         if sig is None:
1394             return None
1395 
1396         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1397 
1398     def format_signature(self, **kwargs: Any) -> str:
1399         if self.doc_as_attr:
1400             return ''
1401 
1402         sig = super().format_signature()
1403 
1404         overloaded = False
1405         qualname = None
1406         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)
1407         if self._signature_class and self._signature_method_name and self.analyzer:
1408             qualname = '.'.join([self._signature_class.__qualname__,
1409                                  self._signature_method_name])
1410             if qualname in self.analyzer.overloads:
1411                 overloaded = True
1412 
1413         sigs = []
1414         if overloaded:
1415             # Use signatures for overloaded methods instead of the implementation method.
1416             for overload in self.analyzer.overloads.get(qualname):
1417                 parameters = list(overload.parameters.values())
1418                 overload = overload.replace(parameters=parameters[1:],
1419                                             return_annotation=Parameter.empty)
1420                 sig = stringify_signature(overload, **kwargs)
1421                 sigs.append(sig)
1422         else:
1423             sigs.append(sig)
1424 
1425         return "\n".join(sigs)
1426 
1427     def add_directive_header(self, sig: str) -> None:
1428         sourcename = self.get_sourcename()
1429 
1430         if self.doc_as_attr:
1431             self.directivetype = 'attribute'
1432         super().add_directive_header(sig)
1433 
1434         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1435             self.add_line('   :final:', sourcename)
1436 
1437         # add inheritance info, if wanted
1438         if not self.doc_as_attr and self.options.show_inheritance:
1439             sourcename = self.get_sourcename()
1440             self.add_line('', sourcename)
1441             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1442                 bases = [':class:`%s`' % b.__name__
1443                          if b.__module__ in ('__builtin__', 'builtins')
1444                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1445                          for b in self.object.__bases__]
1446                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1447                               sourcename)
1448 
1449     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1450         if encoding is not None:
1451             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1452                           % self.__class__.__name__,
1453                           RemovedInSphinx40Warning, stacklevel=2)
1454         lines = getattr(self, '_new_docstrings', None)
1455         if lines is not None:
1456             return lines
1457 
1458         content = self.env.config.autoclass_content
1459 
1460         docstrings = []
1461         attrdocstring = self.get_attr(self.object, '__doc__', None)
1462         if attrdocstring:
1463             docstrings.append(attrdocstring)
1464 
1465         # for classes, what the "docstring" is can be controlled via a
1466         # config value; the default is only the class docstring
1467         if content in ('both', 'init'):
1468             __init__ = self.get_attr(self.object, '__init__', None)
1469             initdocstring = getdoc(__init__, self.get_attr,
1470                                    self.env.config.autodoc_inherit_docstrings,
1471                                    self.parent, self.object_name)
1472             # for new-style classes, no __init__ means default __init__
1473             if (initdocstring is not None and
1474                 (initdocstring == object.__init__.__doc__ or  # for pypy
1475                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1476                 initdocstring = None
1477             if not initdocstring:
1478                 # try __new__
1479                 __new__ = self.get_attr(self.object, '__new__', None)
1480                 initdocstring = getdoc(__new__, self.get_attr,
1481                                        self.env.config.autodoc_inherit_docstrings,
1482                                        self.parent, self.object_name)
1483                 # for new-style classes, no __new__ means default __new__
1484                 if (initdocstring is not None and
1485                     (initdocstring == object.__new__.__doc__ or  # for pypy
1486                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1487                     initdocstring = None
1488             if initdocstring:
1489                 if content == 'init':
1490                     docstrings = [initdocstring]
1491                 else:
1492                     docstrings.append(initdocstring)
1493 
1494         tab_width = self.directive.state.document.settings.tab_width
1495         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1496 
1497     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1498         if self.doc_as_attr:
1499             classname = safe_getattr(self.object, '__qualname__', None)
1500             if not classname:
1501                 classname = safe_getattr(self.object, '__name__', None)
1502             if classname:
1503                 module = safe_getattr(self.object, '__module__', None)
1504                 parentmodule = safe_getattr(self.parent, '__module__', None)
1505                 if module and module != parentmodule:
1506                     classname = str(module) + '.' + str(classname)
1507                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1508                 super().add_content(content, no_docstring=True)
1509         else:
1510             super().add_content(more_content)
1511 
1512     def document_members(self, all_members: bool = False) -> None:
1513         if self.doc_as_attr:
1514             return
1515         super().document_members(all_members)
1516 
1517     def generate(self, more_content: Any = None, real_modname: str = None,
1518                  check_module: bool = False, all_members: bool = False) -> None:
1519         # Do not pass real_modname and use the name from the __module__
1520         # attribute of the class.
1521         # If a class gets imported into the module real_modname
1522         # the analyzer won't find the source of the class, if
1523         # it looks in real_modname.
1524         return super().generate(more_content=more_content,
1525                                 check_module=check_module,
1526                                 all_members=all_members)
1527 
1528 
1529 class ExceptionDocumenter(ClassDocumenter):
1530     """
1531     Specialized ClassDocumenter subclass for exceptions.
1532     """
1533     objtype = 'exception'
1534     member_order = 10
1535 
1536     # needs a higher priority than ClassDocumenter
1537     priority = 10
1538 
1539     @classmethod
1540     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1541                             ) -> bool:
1542         return isinstance(member, type) and issubclass(member, BaseException)
1543 
1544 
1545 class DataDocumenter(ModuleLevelDocumenter):
1546     """
1547     Specialized Documenter subclass for data items.
1548     """
1549     objtype = 'data'
1550     member_order = 40
1551     priority = -10
1552     option_spec = dict(ModuleLevelDocumenter.option_spec)
1553     option_spec["annotation"] = annotation_option
1554 
1555     @classmethod
1556     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1557                             ) -> bool:
1558         return isinstance(parent, ModuleDocumenter) and isattr
1559 
1560     def add_directive_header(self, sig: str) -> None:
1561         super().add_directive_header(sig)
1562         sourcename = self.get_sourcename()
1563         if not self.options.annotation:
1564             # obtain annotation for this data
1565             annotations = getattr(self.parent, '__annotations__', {})
1566             if annotations and self.objpath[-1] in annotations:
1567                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1568                 self.add_line('   :type: ' + objrepr, sourcename)
1569             else:
1570                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1571                 if self.analyzer and key in self.analyzer.annotations:
1572                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1573                                   sourcename)
1574 
1575             try:
1576                 if self.object is UNINITIALIZED_ATTR:
1577                     pass
1578                 else:
1579                     objrepr = object_description(self.object)
1580                     self.add_line('   :value: ' + objrepr, sourcename)
1581             except ValueError:
1582                 pass
1583         elif self.options.annotation is SUPPRESS:
1584             pass
1585         else:
1586             self.add_line('   :annotation: %s' % self.options.annotation,
1587                           sourcename)
1588 
1589     def document_members(self, all_members: bool = False) -> None:
1590         pass
1591 
1592     def get_real_modname(self) -> str:
1593         return self.get_attr(self.parent or self.object, '__module__', None) \
1594             or self.modname
1595 
1596 
1597 class DataDeclarationDocumenter(DataDocumenter):
1598     """
1599     Specialized Documenter subclass for data that cannot be imported
1600     because they are declared without initial value (refs: PEP-526).
1601     """
1602     objtype = 'datadecl'
1603     directivetype = 'data'
1604     member_order = 60
1605 
1606     # must be higher than AttributeDocumenter
1607     priority = 11
1608 
1609     @classmethod
1610     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1611                             ) -> bool:
1612         """This documents only INSTANCEATTR members."""
1613         return (isinstance(parent, ModuleDocumenter) and
1614                 isattr and
1615                 member is INSTANCEATTR)
1616 
1617     def import_object(self) -> bool:
1618         """Never import anything."""
1619         # disguise as a data
1620         self.objtype = 'data'
1621         self.object = UNINITIALIZED_ATTR
1622         try:
1623             # import module to obtain type annotation
1624             self.parent = importlib.import_module(self.modname)
1625         except ImportError:
1626             pass
1627 
1628         return True
1629 
1630     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1631         """Never try to get a docstring from the object."""
1632         super().add_content(more_content, no_docstring=True)
1633 
1634 
1635 class GenericAliasDocumenter(DataDocumenter):
1636     """
1637     Specialized Documenter subclass for GenericAliases.
1638     """
1639 
1640     objtype = 'genericalias'
1641     directivetype = 'data'
1642     priority = DataDocumenter.priority + 1
1643 
1644     @classmethod
1645     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1646                             ) -> bool:
1647         return inspect.isgenericalias(member)
1648 
1649     def add_directive_header(self, sig: str) -> None:
1650         self.options.annotation = SUPPRESS  # type: ignore
1651         super().add_directive_header(sig)
1652 
1653     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1654         name = stringify_typehint(self.object)
1655         content = StringList([_('alias of %s') % name], source='')
1656         super().add_content(content)
1657 
1658 
1659 class TypeVarDocumenter(DataDocumenter):
1660     """
1661     Specialized Documenter subclass for TypeVars.
1662     """
1663 
1664     objtype = 'typevar'
1665     directivetype = 'data'
1666     priority = DataDocumenter.priority + 1
1667 
1668     @classmethod
1669     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1670                             ) -> bool:
1671         return isinstance(member, TypeVar) and isattr  # type: ignore
1672 
1673     def add_directive_header(self, sig: str) -> None:
1674         self.options.annotation = SUPPRESS  # type: ignore
1675         super().add_directive_header(sig)
1676 
1677     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1678         if ignore is not None:
1679             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1680                           % self.__class__.__name__,
1681                           RemovedInSphinx50Warning, stacklevel=2)
1682 
1683         if self.object.__doc__ != TypeVar.__doc__:
1684             return super().get_doc()
1685         else:
1686             return []
1687 
1688     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1689         attrs = [repr(self.object.__name__)]
1690         for constraint in self.object.__constraints__:
1691             attrs.append(stringify_typehint(constraint))
1692         if self.object.__covariant__:
1693             attrs.append("covariant=True")
1694         if self.object.__contravariant__:
1695             attrs.append("contravariant=True")
1696 
1697         content = StringList([_('alias of TypeVar(%s)') % ", ".join(attrs)], source='')
1698         super().add_content(content)
1699 
1700 
1701 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1702     """
1703     Specialized Documenter subclass for methods (normal, static and class).
1704     """
1705     objtype = 'method'
1706     directivetype = 'method'
1707     member_order = 50
1708     priority = 1  # must be more than FunctionDocumenter
1709 
1710     @classmethod
1711     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1712                             ) -> bool:
1713         return inspect.isroutine(member) and \
1714             not isinstance(parent, ModuleDocumenter)
1715 
1716     def import_object(self) -> Any:
1717         ret = super().import_object()
1718         if not ret:
1719             return ret
1720 
1721         # to distinguish classmethod/staticmethod
1722         obj = self.parent.__dict__.get(self.object_name)
1723         if obj is None:
1724             obj = self.object
1725 
1726         if (inspect.isclassmethod(obj) or
1727                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1728             # document class and static members before ordinary ones
1729             self.member_order = self.member_order - 1
1730 
1731         return ret
1732 
1733     def format_args(self, **kwargs: Any) -> str:
1734         if self.env.config.autodoc_typehints in ('none', 'description'):
1735             kwargs.setdefault('show_annotation', False)
1736 
1737         try:
1738             if self.object == object.__init__ and self.parent != object:
1739                 # Classes not having own __init__() method are shown as no arguments.
1740                 #
1741                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1742                 #       But it makes users confused.
1743                 args = '()'
1744             else:
1745                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1746                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1747                     sig = inspect.signature(self.object, bound_method=False)
1748                 else:
1749                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1750 
1751                     meth = self.parent.__dict__.get(self.objpath[-1], None)
1752                     if meth and inspect.is_singledispatch_method(meth):
1753                         sig = inspect.signature(self.object, bound_method=True,
1754                                                 follow_wrapped=True)
1755                     else:
1756                         sig = inspect.signature(self.object, bound_method=True)
1757                 args = stringify_signature(sig, **kwargs)
1758         except TypeError as exc:
1759             logger.warning(__("Failed to get a method signature for %s: %s"),
1760                            self.fullname, exc)
1761             return None
1762         except ValueError:
1763             args = ''
1764 
1765         if self.env.config.strip_signature_backslash:
1766             # escape backslashes for reST
1767             args = args.replace('\\', '\\\\')
1768         return args
1769 
1770     def add_directive_header(self, sig: str) -> None:
1771         super().add_directive_header(sig)
1772 
1773         sourcename = self.get_sourcename()
1774         obj = self.parent.__dict__.get(self.object_name, self.object)
1775         if inspect.isabstractmethod(obj):
1776             self.add_line('   :abstractmethod:', sourcename)
1777         if inspect.iscoroutinefunction(obj):
1778             self.add_line('   :async:', sourcename)
1779         if inspect.isclassmethod(obj):
1780             self.add_line('   :classmethod:', sourcename)
1781         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1782             self.add_line('   :staticmethod:', sourcename)
1783         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1784             self.add_line('   :final:', sourcename)
1785 
1786     def document_members(self, all_members: bool = False) -> None:
1787         pass
1788 
1789     def format_signature(self, **kwargs: Any) -> str:
1790         sigs = []
1791         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1792             # Use signatures for overloaded methods instead of the implementation method.
1793             overloaded = True
1794         else:
1795             overloaded = False
1796             sig = super().format_signature(**kwargs)
1797             sigs.append(sig)
1798 
1799         meth = self.parent.__dict__.get(self.objpath[-1])
1800         if inspect.is_singledispatch_method(meth):
1801             # append signature of singledispatch'ed functions
1802             for typ, func in meth.dispatcher.registry.items():
1803                 if typ is object:
1804                     pass  # default implementation. skipped.
1805                 else:
1806                     self.annotate_to_first_argument(func, typ)
1807 
1808                     documenter = MethodDocumenter(self.directive, '')
1809                     documenter.parent = self.parent
1810                     documenter.object = func
1811                     documenter.objpath = [None]
1812                     sigs.append(documenter.format_signature())
1813         if overloaded:
1814             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1815                 if not inspect.isstaticmethod(self.object, cls=self.parent,
1816                                               name=self.object_name):
1817                     parameters = list(overload.parameters.values())
1818                     overload = overload.replace(parameters=parameters[1:])
1819                 sig = stringify_signature(overload, **kwargs)
1820                 sigs.append(sig)
1821 
1822         return "\n".join(sigs)
1823 
1824     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1825         """Annotate type hint to the first argument of function if needed."""
1826         try:
1827             sig = inspect.signature(func)
1828         except TypeError as exc:
1829             logger.warning(__("Failed to get a method signature for %s: %s"),
1830                            self.fullname, exc)
1831             return
1832         except ValueError:
1833             return
1834         if len(sig.parameters) == 1:
1835             return
1836 
1837         params = list(sig.parameters.values())
1838         if params[1].annotation is Parameter.empty:
1839             params[1] = params[1].replace(annotation=typ)
1840             try:
1841                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1842             except TypeError:
1843                 # failed to update signature (ex. built-in or extension types)
1844                 return
1845 
1846 
1847 class SingledispatchMethodDocumenter(MethodDocumenter):
1848     """
1849     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1850 
1851     Retained for backwards compatibility, now does the same as the MethodDocumenter
1852     """
1853 
1854 
1855 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1856     """
1857     Specialized Documenter subclass for attributes.
1858     """
1859     objtype = 'attribute'
1860     member_order = 60
1861     option_spec = dict(ModuleLevelDocumenter.option_spec)
1862     option_spec["annotation"] = annotation_option
1863 
1864     # must be higher than the MethodDocumenter, else it will recognize
1865     # some non-data descriptors as methods
1866     priority = 10
1867 
1868     @staticmethod
1869     def is_function_or_method(obj: Any) -> bool:
1870         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1871 
1872     @classmethod
1873     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1874                             ) -> bool:
1875         if inspect.isattributedescriptor(member):
1876             return True
1877         elif (not isinstance(parent, ModuleDocumenter) and
1878               not inspect.isroutine(member) and
1879               not isinstance(member, type)):
1880             return True
1881         else:
1882             return False
1883 
1884     def document_members(self, all_members: bool = False) -> None:
1885         pass
1886 
1887     def import_object(self) -> Any:
1888         ret = super().import_object()
1889         if inspect.isenumattribute(self.object):
1890             self.object = self.object.value
1891         if inspect.isattributedescriptor(self.object):
1892             self._datadescriptor = True
1893         else:
1894             # if it's not a data descriptor
1895             self._datadescriptor = False
1896         return ret
1897 
1898     def get_real_modname(self) -> str:
1899         return self.get_attr(self.parent or self.object, '__module__', None) \
1900             or self.modname
1901 
1902     def add_directive_header(self, sig: str) -> None:
1903         super().add_directive_header(sig)
1904         sourcename = self.get_sourcename()
1905         if not self.options.annotation:
1906             # obtain type annotation for this attribute
1907             annotations = getattr(self.parent, '__annotations__', {})
1908             if annotations and self.objpath[-1] in annotations:
1909                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1910                 self.add_line('   :type: ' + objrepr, sourcename)
1911             else:
1912                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1913                 if self.analyzer and key in self.analyzer.annotations:
1914                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1915                                   sourcename)
1916 
1917             # data descriptors do not have useful values
1918             if not self._datadescriptor:
1919                 try:
1920                     if self.object is INSTANCEATTR:
1921                         pass
1922                     else:
1923                         objrepr = object_description(self.object)
1924                         self.add_line('   :value: ' + objrepr, sourcename)
1925                 except ValueError:
1926                     pass
1927         elif self.options.annotation is SUPPRESS:
1928             pass
1929         else:
1930             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
1931 
1932     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1933         try:
1934             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
1935             # a docstring from the value which descriptor returns unexpectedly.
1936             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
1937             orig = self.env.config.autodoc_inherit_docstrings
1938             self.env.config.autodoc_inherit_docstrings = False  # type: ignore
1939             return super().get_doc(encoding, ignore)
1940         finally:
1941             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore
1942 
1943     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1944         if not self._datadescriptor:
1945             # if it's not a data descriptor, its docstring is very probably the
1946             # wrong thing to display
1947             no_docstring = True
1948         super().add_content(more_content, no_docstring)
1949 
1950 
1951 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1952     """
1953     Specialized Documenter subclass for properties.
1954     """
1955     objtype = 'property'
1956     directivetype = 'method'
1957     member_order = 60
1958 
1959     # before AttributeDocumenter
1960     priority = AttributeDocumenter.priority + 1
1961 
1962     @classmethod
1963     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1964                             ) -> bool:
1965         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
1966 
1967     def document_members(self, all_members: bool = False) -> None:
1968         pass
1969 
1970     def get_real_modname(self) -> str:
1971         return self.get_attr(self.parent or self.object, '__module__', None) \
1972             or self.modname
1973 
1974     def add_directive_header(self, sig: str) -> None:
1975         super().add_directive_header(sig)
1976         sourcename = self.get_sourcename()
1977         if inspect.isabstractmethod(self.object):
1978             self.add_line('   :abstractmethod:', sourcename)
1979         self.add_line('   :property:', sourcename)
1980 
1981 
1982 class InstanceAttributeDocumenter(AttributeDocumenter):
1983     """
1984     Specialized Documenter subclass for attributes that cannot be imported
1985     because they are instance attributes (e.g. assigned in __init__).
1986     """
1987     objtype = 'instanceattribute'
1988     directivetype = 'attribute'
1989     member_order = 60
1990 
1991     # must be higher than AttributeDocumenter
1992     priority = 11
1993 
1994     @classmethod
1995     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1996                             ) -> bool:
1997         """This documents only INSTANCEATTR members."""
1998         return (not isinstance(parent, ModuleDocumenter) and
1999                 isattr and
2000                 member is INSTANCEATTR)
2001 
2002     def import_object(self) -> bool:
2003         """Never import anything."""
2004         # disguise as an attribute
2005         self.objtype = 'attribute'
2006         self.object = INSTANCEATTR
2007         self._datadescriptor = False
2008         return True
2009 
2010     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2011         """Never try to get a docstring from the object."""
2012         super().add_content(more_content, no_docstring=True)
2013 
2014 
2015 class SlotsAttributeDocumenter(AttributeDocumenter):
2016     """
2017     Specialized Documenter subclass for attributes that cannot be imported
2018     because they are attributes in __slots__.
2019     """
2020     objtype = 'slotsattribute'
2021     directivetype = 'attribute'
2022     member_order = 60
2023 
2024     # must be higher than AttributeDocumenter
2025     priority = 11
2026 
2027     @classmethod
2028     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2029                             ) -> bool:
2030         """This documents only SLOTSATTR members."""
2031         return member is SLOTSATTR
2032 
2033     def import_object(self) -> Any:
2034         """Never import anything."""
2035         # disguise as an attribute
2036         self.objtype = 'attribute'
2037         self._datadescriptor = True
2038 
2039         with mock(self.env.config.autodoc_mock_imports):
2040             try:
2041                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2042                                     attrgetter=self.get_attr,
2043                                     warningiserror=self.env.config.autodoc_warningiserror)
2044                 self.module, _, _, self.parent = ret
2045                 return True
2046             except ImportError as exc:
2047                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2048                 self.env.note_reread()
2049                 return False
2050 
2051     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2052         """Decode and return lines of the docstring(s) for the object."""
2053         if ignore is not None:
2054             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
2055                           % self.__class__.__name__,
2056                           RemovedInSphinx50Warning, stacklevel=2)
2057         name = self.objpath[-1]
2058         __slots__ = safe_getattr(self.parent, '__slots__', [])
2059         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
2060             docstring = prepare_docstring(__slots__[name])
2061             return [docstring]
2062         else:
2063             return []
2064 
2065 
2066 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2067     """Returns registered Documenter classes"""
2068     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2069     return app.registry.documenters
2070 
2071 
2072 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2073     """Alternative getattr() for types"""
2074     for typ, func in app.registry.autodoc_attrgettrs.items():
2075         if isinstance(obj, typ):
2076             return func(obj, name, *defargs)
2077 
2078     return safe_getattr(obj, name, *defargs)
2079 
2080 
2081 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2082     if config.autodoc_member_order == 'alphabetic':
2083         # RemovedInSphinx50Warning
2084         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2085                           'instead of "alphabetic". Please update your setting.'))
2086         config.autodoc_member_order = 'alphabetical'  # type: ignore
2087 
2088 
2089 def setup(app: Sphinx) -> Dict[str, Any]:
2090     app.add_autodocumenter(ModuleDocumenter)
2091     app.add_autodocumenter(ClassDocumenter)
2092     app.add_autodocumenter(ExceptionDocumenter)
2093     app.add_autodocumenter(DataDocumenter)
2094     app.add_autodocumenter(DataDeclarationDocumenter)
2095     app.add_autodocumenter(GenericAliasDocumenter)
2096     app.add_autodocumenter(TypeVarDocumenter)
2097     app.add_autodocumenter(FunctionDocumenter)
2098     app.add_autodocumenter(DecoratorDocumenter)
2099     app.add_autodocumenter(MethodDocumenter)
2100     app.add_autodocumenter(AttributeDocumenter)
2101     app.add_autodocumenter(PropertyDocumenter)
2102     app.add_autodocumenter(InstanceAttributeDocumenter)
2103     app.add_autodocumenter(SlotsAttributeDocumenter)
2104 
2105     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2106     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2107                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2108     app.add_config_value('autodoc_default_options', {}, True)
2109     app.add_config_value('autodoc_docstring_signature', True, True)
2110     app.add_config_value('autodoc_mock_imports', [], True)
2111     app.add_config_value('autodoc_typehints', "signature", True,
2112                          ENUM("signature", "description", "none"))
2113     app.add_config_value('autodoc_warningiserror', True, True)
2114     app.add_config_value('autodoc_inherit_docstrings', True, True)
2115     app.add_event('autodoc-before-process-signature')
2116     app.add_event('autodoc-process-docstring')
2117     app.add_event('autodoc-process-signature')
2118     app.add_event('autodoc-skip-member')
2119 
2120     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2121 
2122     app.setup_extension('sphinx.ext.autodoc.type_comment')
2123     app.setup_extension('sphinx.ext.autodoc.typehints')
2124 
2125     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>These methods must be refined to handle generically typed classes and members correctly. Specifically, they should properly interpret and document `TypeVar` and generic types without resulting in `TypeError`. This means when extracting and adding documentation content, any `TypeVar` related to a member should be processed to display its defined constrains or bound types accurately in the documentation. Additionally, enhancing the conditional logic in `can_document_member` to detect and affirm the documentability of members with generic types would ensure that all relevant parts of generically-typed classes are included in the Sphinx documentation output.</intended_behavior>]
2025-10-18 06:48:21.521 | INFO     | Search completed. Bug locations: [<file>sphinx/util/typing.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.typing
3     ~~~~~~~~~~~~~~~~~~
4 
5     The composit types for Sphinx.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import sys
12 import typing
13 from typing import Any, Callable, Dict, List, Tuple, TypeVar, Union
14 
15 from docutils import nodes
16 from docutils.parsers.rst.states import Inliner
17 
18 
19 # An entry of Directive.option_spec
20 DirectiveOption = Callable[[str], Any]
21 
22 # Text like nodes which are initialized with text and rawsource
23 TextlikeNode = Union[nodes.Text, nodes.TextElement]
24 
25 # type of None
26 NoneType = type(None)
27 
28 # path matcher
29 PathMatcher = Callable[[str], bool]
30 
31 # common role functions
32 RoleFunction = Callable[[str, str, str, int, Inliner, Dict[str, Any], List[str]],
33                         Tuple[List[nodes.Node], List[nodes.system_message]]]
34 
35 # title getter functions for enumerable nodes (see sphinx.domains.std)
36 TitleGetter = Callable[[nodes.Node], str]
37 
38 # inventory data on memory
39 Inventory = Dict[str, Dict[str, Tuple[str, str, str, str]]]
40 
41 
42 def is_system_TypeVar(typ: Any) -> bool:
43     """Check *typ* is system defined TypeVar."""
44     modname = getattr(typ, '__module__', '')
45     return modname == 'typing' and isinstance(typ, TypeVar)  # type: ignore
46 
47 
48 def stringify(annotation: Any) -> str:
49     """Stringify type annotation object."""
50     if isinstance(annotation, str):
51         return annotation
52     elif isinstance(annotation, TypeVar):  # type: ignore
53         return annotation.__name__
54     elif not annotation:
55         return repr(annotation)
56     elif annotation is NoneType:
57         return 'None'
58     elif (getattr(annotation, '__module__', None) == 'builtins' and
59           hasattr(annotation, '__qualname__')):
60         return annotation.__qualname__
61     elif annotation is Ellipsis:
62         return '...'
63 
64     if sys.version_info >= (3, 7):  # py37+
65         return _stringify_py37(annotation)
66     else:
67         return _stringify_py36(annotation)
68 
69 
70 def _stringify_py37(annotation: Any) -> str:
71     """stringify() for py37+."""
72     module = getattr(annotation, '__module__', None)
73     if module == 'typing':
74         if getattr(annotation, '_name', None):
75             qualname = annotation._name
76         elif getattr(annotation, '__qualname__', None):
77             qualname = annotation.__qualname__
78         elif getattr(annotation, '__forward_arg__', None):
79             qualname = annotation.__forward_arg__
80         else:
81             qualname = stringify(annotation.__origin__)  # ex. Union
82     elif hasattr(annotation, '__qualname__'):
83         qualname = '%s.%s' % (module, annotation.__qualname__)
84     elif hasattr(annotation, '__origin__'):
85         # instantiated generic provided by a user
86         qualname = stringify(annotation.__origin__)
87     else:
88         # we weren't able to extract the base type, appending arguments would
89         # only make them appear twice
90         return repr(annotation)
91 
92     if getattr(annotation, '__args__', None):
93         if qualname == 'Union':
94             if len(annotation.__args__) > 1 and annotation.__args__[-1] is NoneType:
95                 if len(annotation.__args__) > 2:
96                     args = ', '.join(stringify(a) for a in annotation.__args__[:-1])
97                     return 'Optional[Union[%s]]' % args
98                 else:
99                     return 'Optional[%s]' % stringify(annotation.__args__[0])
100             else:
101                 args = ', '.join(stringify(a) for a in annotation.__args__)
102                 return 'Union[%s]' % args
103         elif qualname == 'Callable':
104             args = ', '.join(stringify(a) for a in annotation.__args__[:-1])
105             returns = stringify(annotation.__args__[-1])
106             return '%s[[%s], %s]' % (qualname, args, returns)
107         elif str(annotation).startswith('typing.Annotated'):  # for py39+
108             return stringify(annotation.__args__[0])
109         elif all(is_system_TypeVar(a) for a in annotation.__args__):
110             # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])
111             return qualname
112         else:
113             args = ', '.join(stringify(a) for a in annotation.__args__)
114             return '%s[%s]' % (qualname, args)
115 
116     return qualname
117 
118 
119 def _stringify_py36(annotation: Any) -> str:
120     """stringify() for py35 and py36."""
121     module = getattr(annotation, '__module__', None)
122     if module == 'typing':
123         if getattr(annotation, '_name', None):
124             qualname = annotation._name
125         elif getattr(annotation, '__qualname__', None):
126             qualname = annotation.__qualname__
127         elif getattr(annotation, '__forward_arg__', None):
128             qualname = annotation.__forward_arg__
129         elif getattr(annotation, '__origin__', None):
130             qualname = stringify(annotation.__origin__)  # ex. Union
131         else:
132             qualname = repr(annotation).replace('typing.', '')
133     elif hasattr(annotation, '__qualname__'):
134         qualname = '%s.%s' % (module, annotation.__qualname__)
135     else:
136         qualname = repr(annotation)
137 
138     if (isinstance(annotation, typing.TupleMeta) and  # type: ignore
139             not hasattr(annotation, '__tuple_params__')):  # for Python 3.6
140         params = annotation.__args__
141         if params:
142             param_str = ', '.join(stringify(p) for p in params)
143             return '%s[%s]' % (qualname, param_str)
144         else:
145             return qualname
146     elif isinstance(annotation, typing.GenericMeta):
147         params = None
148         if hasattr(annotation, '__args__'):
149             # for Python 3.5.2+
150             if annotation.__args__ is None or len(annotation.__args__) <= 2:  # type: ignore  # NOQA
151                 params = annotation.__args__  # type: ignore
152             else:  # typing.Callable
153                 args = ', '.join(stringify(arg) for arg
154                                  in annotation.__args__[:-1])  # type: ignore
155                 result = stringify(annotation.__args__[-1])  # type: ignore
156                 return '%s[[%s], %s]' % (qualname, args, result)
157         elif hasattr(annotation, '__parameters__'):
158             # for Python 3.5.0 and 3.5.1
159             params = annotation.__parameters__  # type: ignore
160         if params is not None:
161             param_str = ', '.join(stringify(p) for p in params)
162             return '%s[%s]' % (qualname, param_str)
163     elif (hasattr(typing, 'UnionMeta') and
164           isinstance(annotation, typing.UnionMeta) and  # type: ignore
165           hasattr(annotation, '__union_params__')):  # for Python 3.5
166         params = annotation.__union_params__
167         if params is not None:
168             if len(params) == 2 and params[1] is NoneType:
169                 return 'Optional[%s]' % stringify(params[0])
170             else:
171                 param_str = ', '.join(stringify(p) for p in params)
172                 return '%s[%s]' % (qualname, param_str)
173     elif (hasattr(annotation, '__origin__') and
174           annotation.__origin__ is typing.Union):  # for Python 3.5.2+
175         params = annotation.__args__
176         if params is not None:
177             if len(params) > 1 and params[-1] is NoneType:
178                 if len(params) > 2:
179                     param_str = ", ".join(stringify(p) for p in params[:-1])
180                     return 'Optional[Union[%s]]' % param_str
181                 else:
182                     return 'Optional[%s]' % stringify(params[0])
183             else:
184                 param_str = ', '.join(stringify(p) for p in params)
185                 return 'Union[%s]' % param_str
186     elif (isinstance(annotation, typing.CallableMeta) and  # type: ignore
187           getattr(annotation, '__args__', None) is not None and
188           hasattr(annotation, '__result__')):  # for Python 3.5
189         # Skipped in the case of plain typing.Callable
190         args = annotation.__args__
191         if args is None:
192             return qualname
193         elif args is Ellipsis:
194             args_str = '...'
195         else:
196             formatted_args = (stringify(a) for a in args)
197             args_str = '[%s]' % ', '.join(formatted_args)
198         return '%s[%s, %s]' % (qualname,
199                                args_str,
200                                stringify(annotation.__result__))
201     elif (isinstance(annotation, typing.TupleMeta) and  # type: ignore
202           hasattr(annotation, '__tuple_params__') and
203           hasattr(annotation, '__tuple_use_ellipsis__')):  # for Python 3.5
204         params = annotation.__tuple_params__
205         if params is not None:
206             param_strings = [stringify(p) for p in params]
207             if annotation.__tuple_use_ellipsis__:
208                 param_strings.append('...')
209             return '%s[%s]' % (qualname,
210                                ', '.join(param_strings))
211 
212     return qualname

</code><intended_behavior>These methods should ensure that when handling `TypeVar` objects, they convert these to their string representations safely without attempting to directly concatenate them with strings or perform other operations that could lead to `TypeError`. This involves checking the type of the object being stringified and applying an appropriate conversion method to handle `TypeVar` objects, thus preserving the functionality of documenting generic types accurately.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
20 )
21 
22 from docutils.statemachine import StringList
23 
24 import sphinx
25 from sphinx.application import Sphinx
26 from sphinx.config import Config, ENUM
27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
28 from sphinx.environment import BuildEnvironment
29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
30 from sphinx.ext.autodoc.mock import mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect
34 from sphinx.util import logging
35 from sphinx.util import split_full_qualified_name
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43     from sphinx.ext.autodoc.directive import DocumenterBridge
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 
49 # This type isn't exposed directly in any modules, but can be found
50 # here in most Python versions
51 MethodDescriptorType = type(type.__subclasses__)
52 
53 
54 #: extended signature RE: with explicit module name separated by ::
55 py_ext_sig_re = re.compile(
56     r'''^ ([\w.]+::)?            # explicit module name
57           ([\w.]+\.)?            # module and/or class name(s)
58           (\w+)  \s*             # thing name
59           (?: \((.*)\)           # optional: arguments
60            (?:\s* -> \s* (.*))?  #           return annotation
61           )? $                   # and nothing more
62           ''', re.VERBOSE)
63 
64 
65 def identity(x: Any) -> Any:
66     return x
67 
68 
69 ALL = object()
70 UNINITIALIZED_ATTR = object()
71 INSTANCEATTR = object()
72 SLOTSATTR = object()
73 
74 
75 def members_option(arg: Any) -> Union[object, List[str]]:
76     """Used to convert the :members: option to auto directives."""
77     if arg is None or arg is True:
78         return ALL
79     return [x.strip() for x in arg.split(',') if x.strip()]
80 
81 
82 def members_set_option(arg: Any) -> Union[object, Set[str]]:
83     """Used to convert the :members: option to auto directives."""
84     if arg is None:
85         return ALL
86     return {x.strip() for x in arg.split(',') if x.strip()}
87 
88 
89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
90     """Used to convert the :members: option to auto directives."""
91     if arg is None:
92         return 'object'
93     else:
94         return arg
95 
96 
97 def member_order_option(arg: Any) -> Optional[str]:
98     """Used to convert the :members: option to auto directives."""
99     if arg is None:
100         return None
101     elif arg in ('alphabetical', 'bysource', 'groupwise'):
102         return arg
103     else:
104         raise ValueError(__('invalid value for member-order option: %s') % arg)
105 
106 
107 SUPPRESS = object()
108 
109 
110 def annotation_option(arg: Any) -> Any:
111     if arg is None:
112         # suppress showing the representation of the object
113         return SUPPRESS
114     else:
115         return arg
116 
117 
118 def bool_option(arg: Any) -> bool:
119     """Used to convert flag options to auto directives.  (Instead of
120     directives.flag(), which returns None).
121     """
122     return True
123 
124 
125 def merge_special_members_option(options: Dict) -> None:
126     """Merge :special-members: option to :members: option."""
127     if 'special-members' in options and options['special-members'] is not ALL:
128         if options.get('members') is ALL:
129             pass
130         elif options.get('members'):
131             for member in options['special-members']:
132                 if member not in options['members']:
133                     options['members'].append(member)
134         else:
135             options['members'] = options['special-members']
136 
137 
138 # Some useful event listener factories for autodoc-process-docstring.
139 
140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
141     """Return a listener that removes the first *pre* and last *post*
142     lines of every docstring.  If *what* is a sequence of strings,
143     only docstrings of a type in *what* will be processed.
144 
145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
146 
147        from sphinx.ext.autodoc import cut_lines
148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
149 
150     This can (and should) be used in place of :confval:`automodule_skip_lines`.
151     """
152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
153                 ) -> None:
154         if what and what_ not in what:
155             return
156         del lines[:pre]
157         if post:
158             # remove one trailing blank line.
159             if lines and not lines[-1]:
160                 lines.pop(-1)
161             del lines[-post:]
162         # make sure there is a blank line at the end
163         if lines and lines[-1]:
164             lines.append('')
165     return process
166 
167 
168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
169             exclude: bool = False) -> Callable:
170     """Return a listener that either keeps, or if *exclude* is True excludes,
171     lines between lines that match the *marker* regular expression.  If no line
172     matches, the resulting docstring would be empty, so no change will be made
173     unless *keepempty* is true.
174 
175     If *what* is a sequence of strings, only docstrings of a type in *what* will
176     be processed.
177     """
178     marker_re = re.compile(marker)
179 
180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
181                 ) -> None:
182         if what and what_ not in what:
183             return
184         deleted = 0
185         delete = not exclude
186         orig_lines = lines[:]
187         for i, line in enumerate(orig_lines):
188             if delete:
189                 lines.pop(i - deleted)
190                 deleted += 1
191             if marker_re.match(line):
192                 delete = not delete
193                 if delete:
194                     lines.pop(i - deleted)
195                     deleted += 1
196         if not lines and not keepempty:
197             lines[:] = orig_lines
198         # make sure there is a blank line at the end
199         if lines and lines[-1]:
200             lines.append('')
201     return process
202 
203 
204 # This class is used only in ``sphinx.ext.autodoc.directive``,
205 # But we define this class here to keep compatibility (see #4538)
206 class Options(dict):
207     """A dict/attribute hybrid that returns None on nonexisting keys."""
208     def __getattr__(self, name: str) -> Any:
209         try:
210             return self[name.replace('_', '-')]
211         except KeyError:
212             return None
213 
214 
215 class Documenter:
216     """
217     A Documenter knows how to autodocument a single object type.  When
218     registered with the AutoDirective, it will be used to document objects
219     of that type when needed by autodoc.
220 
221     Its *objtype* attribute selects what auto directive it is assigned to
222     (the directive name is 'auto' + objtype), and what directive it generates
223     by default, though that can be overridden by an attribute called
224     *directivetype*.
225 
226     A Documenter has an *option_spec* that works like a docutils directive's;
227     in fact, it will be used to parse an auto directive's options that matches
228     the documenter.
229     """
230     #: name by which the directive is called (auto...) and the default
231     #: generated directive name
232     objtype = 'object'
233     #: indentation by which to indent the directive content
234     content_indent = '   '
235     #: priority if multiple documenters return True from can_document_member
236     priority = 0
237     #: order if autodoc_member_order is set to 'groupwise'
238     member_order = 0
239     #: true if the generated content may contain titles
240     titles_allowed = False
241 
242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
243 
244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
245         """getattr() override for types such as Zope interfaces."""
246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
247 
248     @classmethod
249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
250                             ) -> bool:
251         """Called to see if a member can be documented by this documenter."""
252         raise NotImplementedError('must be implemented in subclasses')
253 
254     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
255         self.directive = directive
256         self.env = directive.env    # type: BuildEnvironment
257         self.options = directive.genopt
258         self.name = name
259         self.indent = indent
260         # the module and object path within the module, and the fully
261         # qualified name (all set after resolve_name succeeds)
262         self.modname = None         # type: str
263         self.module = None          # type: ModuleType
264         self.objpath = None         # type: List[str]
265         self.fullname = None        # type: str
266         # extra signature items (arguments and return annotation,
267         # also set after resolve_name succeeds)
268         self.args = None            # type: str
269         self.retann = None          # type: str
270         # the object to document (set after import_object succeeds)
271         self.object = None          # type: Any
272         self.object_name = None     # type: str
273         # the parent/owner of the object to document
274         self.parent = None          # type: Any
275         # the module analyzer to get at attribute docs, or None
276         self.analyzer = None        # type: ModuleAnalyzer
277 
278     @property
279     def documenters(self) -> Dict[str, "Type[Documenter]"]:
280         """Returns registered Documenter classes"""
281         return self.env.app.registry.documenters
282 
283     def add_line(self, line: str, source: str, *lineno: int) -> None:
284         """Append one line of generated reST to the output."""
285         if line.strip():  # not a blank line
286             self.directive.result.append(self.indent + line, source, *lineno)
287         else:
288             self.directive.result.append('', source, *lineno)
289 
290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
291                      ) -> Tuple[str, List[str]]:
292         """Resolve the module and name of the object to document given by the
293         arguments and the current module/class.
294 
295         Must return a pair of the module name and a chain of attributes; for
296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
297         ``zipfile.ZipFile.open`` method.
298         """
299         raise NotImplementedError('must be implemented in subclasses')
300 
301     def parse_name(self) -> bool:
302         """Determine what module to import and what attribute to document.
303 
304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
305         *self.args* and *self.retann* if parsing and resolving was successful.
306         """
307         # first, parse the definition -- auto directives for classes and
308         # functions can contain a signature which is then used instead of
309         # an autogenerated one
310         try:
311             explicit_modname, path, base, args, retann = \
312                 py_ext_sig_re.match(self.name).groups()
313         except AttributeError:
314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
315                            type='autodoc')
316             return False
317 
318         # support explicit module and class name separation via ::
319         if explicit_modname is not None:
320             modname = explicit_modname[:-2]
321             parents = path.rstrip('.').split('.') if path else []
322         else:
323             modname = None
324             parents = []
325 
326         with mock(self.env.config.autodoc_mock_imports):
327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
328 
329         if not self.modname:
330             return False
331 
332         self.args = args
333         self.retann = retann
334         self.fullname = (self.modname or '') + \
335                         ('.' + '.'.join(self.objpath) if self.objpath else '')
336         return True
337 
338     def import_object(self) -> bool:
339         """Import the object given by *self.modname* and *self.objpath* and set
340         it as *self.object*.
341 
342         Returns True if successful, False if an error occurred.
343         """
344         with mock(self.env.config.autodoc_mock_imports):
345             try:
346                 ret = import_object(self.modname, self.objpath, self.objtype,
347                                     attrgetter=self.get_attr,
348                                     warningiserror=self.env.config.autodoc_warningiserror)
349                 self.module, self.parent, self.object_name, self.object = ret
350                 return True
351             except ImportError as exc:
352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
353                 self.env.note_reread()
354                 return False
355 
356     def get_real_modname(self) -> str:
357         """Get the real module name of an object to document.
358 
359         It can differ from the name of the module through which the object was
360         imported.
361         """
362         return self.get_attr(self.object, '__module__', None) or self.modname
363 
364     def check_module(self) -> bool:
365         """Check if *self.object* is really defined in the module given by
366         *self.modname*.
367         """
368         if self.options.imported_members:
369             return True
370 
371         subject = inspect.unpartial(self.object)
372         modname = self.get_attr(subject, '__module__', None)
373         if modname and modname != self.modname:
374             return False
375         return True
376 
377     def format_args(self, **kwargs: Any) -> str:
378         """Format the argument signature of *self.object*.
379 
380         Should return None if the object does not have a signature.
381         """
382         return None
383 
384     def format_name(self) -> str:
385         """Format the name of *self.object*.
386 
387         This normally should be something that can be parsed by the generated
388         directive, but doesn't need to be (Sphinx will display it unparsed
389         then).
390         """
391         # normally the name doesn't contain the module (except for module
392         # directives of course)
393         return '.'.join(self.objpath) or self.modname
394 
395     def _call_format_args(self, **kwargs: Any) -> str:
396         if kwargs:
397             try:
398                 return self.format_args(**kwargs)
399             except TypeError:
400                 # avoid chaining exceptions, by putting nothing here
401                 pass
402 
403         # retry without arguments for old documenters
404         return self.format_args()
405 
406     def format_signature(self, **kwargs: Any) -> str:
407         """Format the signature (arguments and return annotation) of the object.
408 
409         Let the user process it via the ``autodoc-process-signature`` event.
410         """
411         if self.args is not None:
412             # signature given explicitly
413             args = "(%s)" % self.args
414             retann = self.retann
415         else:
416             # try to introspect the signature
417             try:
418                 retann = None
419                 args = self._call_format_args(**kwargs)
420                 if args:
421                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
422                     if matched:
423                         args = matched.group(1)
424                         retann = matched.group(2)
425             except Exception as exc:
426                 logger.warning(__('error while formatting arguments for %s: %s'),
427                                self.fullname, exc, type='autodoc')
428                 args = None
429 
430         result = self.env.events.emit_firstresult('autodoc-process-signature',
431                                                   self.objtype, self.fullname,
432                                                   self.object, self.options, args, retann)
433         if result:
434             args, retann = result
435 
436         if args is not None:
437             return args + ((' -> %s' % retann) if retann else '')
438         else:
439             return ''
440 
441     def add_directive_header(self, sig: str) -> None:
442         """Add the directive header and options to the generated content."""
443         domain = getattr(self, 'domain', 'py')
444         directive = getattr(self, 'directivetype', self.objtype)
445         name = self.format_name()
446         sourcename = self.get_sourcename()
447 
448         # one signature per line, indented by column
449         prefix = '.. %s:%s:: ' % (domain, directive)
450         for i, sig_line in enumerate(sig.split("\n")):
451             self.add_line('%s%s%s' % (prefix, name, sig_line),
452                           sourcename)
453             if i == 0:
454                 prefix = " " * len(prefix)
455 
456         if self.options.noindex:
457             self.add_line('   :noindex:', sourcename)
458         if self.objpath:
459             # Be explicit about the module, this is necessary since .. class::
460             # etc. don't support a prepended module name
461             self.add_line('   :module: %s' % self.modname, sourcename)
462 
463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
464         """Decode and return lines of the docstring(s) for the object."""
465         if encoding is not None:
466             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
467                           % self.__class__.__name__,
468                           RemovedInSphinx40Warning, stacklevel=2)
469         if ignore is not None:
470             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
471                           % self.__class__.__name__,
472                           RemovedInSphinx50Warning, stacklevel=2)
473         docstring = getdoc(self.object, self.get_attr,
474                            self.env.config.autodoc_inherit_docstrings,
475                            self.parent, self.object_name)
476         if docstring:
477             tab_width = self.directive.state.document.settings.tab_width
478             return [prepare_docstring(docstring, ignore, tab_width)]
479         return []
480 
481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
482         """Let the user process the docstrings before adding them."""
483         for docstringlines in docstrings:
484             if self.env.app:
485                 # let extensions preprocess docstrings
486                 self.env.app.emit('autodoc-process-docstring',
487                                   self.objtype, self.fullname, self.object,
488                                   self.options, docstringlines)
489             yield from docstringlines
490 
491     def get_sourcename(self) -> str:
492         if self.analyzer:
493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
494         return 'docstring of %s' % self.fullname
495 
496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
497         """Add content from docstrings, attribute documentation and user."""
498         # set sourcename and add content from attribute documentation
499         sourcename = self.get_sourcename()
500         if self.analyzer:
501             attr_docs = self.analyzer.find_attr_docs()
502             if self.objpath:
503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
504                 if key in attr_docs:
505                     no_docstring = True
506                     # make a copy of docstring for attributes to avoid cache
507                     # the change of autodoc-process-docstring event.
508                     docstrings = [list(attr_docs[key])]
509 
510                     for i, line in enumerate(self.process_doc(docstrings)):
511                         self.add_line(line, sourcename, i)
512 
513         # add content from docstrings
514         if not no_docstring:
515             docstrings = self.get_doc()
516             if not docstrings:
517                 # append at least a dummy docstring, so that the event
518                 # autodoc-process-docstring is fired and can add some
519                 # content if desired
520                 docstrings.append([])
521             for i, line in enumerate(self.process_doc(docstrings)):
522                 self.add_line(line, sourcename, i)
523 
524         # add additional content (e.g. from document), if present
525         if more_content:
526             for line, src in zip(more_content.data, more_content.items):
527                 self.add_line(line, src[0], src[1])
528 
529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
530         """Return `(members_check_module, members)` where `members` is a
531         list of `(membername, member)` pairs of the members of *self.object*.
532 
533         If *want_all* is True, return all members.  Else, only return those
534         members given by *self.options.members* (which may also be none).
535         """
536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
537         if not want_all:
538             if not self.options.members:
539                 return False, []
540             # specific members given
541             selected = []
542             for name in self.options.members:
543                 if name in members:
544                     selected.append((name, members[name].value))
545                 else:
546                     logger.warning(__('missing attribute %s in object %s') %
547                                    (name, self.fullname), type='autodoc')
548             return False, selected
549         elif self.options.inherited_members:
550             return False, [(m.name, m.value) for m in members.values()]
551         else:
552             return False, [(m.name, m.value) for m in members.values()
553                            if m.directly_defined]
554 
555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
556                        ) -> List[Tuple[str, Any, bool]]:
557         """Filter the given member list.
558 
559         Members are skipped if
560 
561         - they are private (except if given explicitly or the private-members
562           option is set)
563         - they are special methods (except if given explicitly or the
564           special-members option is set)
565         - they are undocumented (except if the undoc-members option is set)
566 
567         The user can override the skipping decision by connecting to the
568         ``autodoc-skip-member`` event.
569         """
570         def is_filtered_inherited_member(name: str) -> bool:
571             if inspect.isclass(self.object):
572                 for cls in self.object.__mro__:
573                     if cls.__name__ == self.options.inherited_members and cls != self.object:
574                         # given member is a member of specified *super class*
575                         return True
576                     elif name in cls.__dict__:
577                         return False
578 
579             return False
580 
581         ret = []
582 
583         # search for members in source code too
584         namespace = '.'.join(self.objpath)  # will be empty for modules
585 
586         if self.analyzer:
587             attr_docs = self.analyzer.find_attr_docs()
588         else:
589             attr_docs = {}
590 
591         # process members and determine which to skip
592         for (membername, member) in members:
593             # if isattr is True, the member is documented as an attribute
594             if member is INSTANCEATTR:
595                 isattr = True
596             else:
597                 isattr = False
598 
599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
600                          self.parent, self.object_name)
601             if not isinstance(doc, str):
602                 # Ignore non-string __doc__
603                 doc = None
604 
605             # if the member __doc__ is the same as self's __doc__, it's just
606             # inherited and therefore not the member's doc
607             cls = self.get_attr(member, '__class__', None)
608             if cls:
609                 cls_doc = self.get_attr(cls, '__doc__', None)
610                 if cls_doc == doc:
611                     doc = None
612             has_doc = bool(doc)
613 
614             metadata = extract_metadata(doc)
615             if 'private' in metadata:
616                 # consider a member private if docstring has "private" metadata
617                 isprivate = True
618             elif 'public' in metadata:
619                 # consider a member public if docstring has "public" metadata
620                 isprivate = False
621             else:
622                 isprivate = membername.startswith('_')
623 
624             keep = False
625             if safe_getattr(member, '__sphinx_mock__', False):
626                 # mocked module or object
627                 pass
628             elif want_all and membername.startswith('__') and \
629                     membername.endswith('__') and len(membername) > 4:
630                 # special __methods__
631                 if self.options.special_members is ALL:
632                     if membername == '__doc__':
633                         keep = False
634                     elif is_filtered_inherited_member(membername):
635                         keep = False
636                     else:
637                         keep = has_doc or self.options.undoc_members
638                 elif self.options.special_members:
639                     if membername in self.options.special_members:
640                         keep = has_doc or self.options.undoc_members
641             elif (namespace, membername) in attr_docs:
642                 if want_all and isprivate:
643                     # ignore members whose name starts with _ by default
644                     keep = self.options.private_members
645                 else:
646                     # keep documented attributes
647                     keep = True
648                 isattr = True
649             elif want_all and isprivate:
650                 # ignore members whose name starts with _ by default
651                 keep = self.options.private_members and \
652                     (has_doc or self.options.undoc_members)
653             else:
654                 if self.options.members is ALL and is_filtered_inherited_member(membername):
655                     keep = False
656                 else:
657                     # ignore undocumented members if :undoc-members: is not given
658                     keep = has_doc or self.options.undoc_members
659 
660             # give the user a chance to decide whether this member
661             # should be skipped
662             if self.env.app:
663                 # let extensions preprocess docstrings
664                 try:
665                     skip_user = self.env.app.emit_firstresult(
666                         'autodoc-skip-member', self.objtype, membername, member,
667                         not keep, self.options)
668                     if skip_user is not None:
669                         keep = not skip_user
670                 except Exception as exc:
671                     logger.warning(__('autodoc: failed to determine %r to be documented, '
672                                       'the following exception was raised:\n%s'),
673                                    member, exc, type='autodoc')
674                     keep = False
675 
676             if keep:
677                 ret.append((membername, member, isattr))
678 
679         return ret
680 
681     def document_members(self, all_members: bool = False) -> None:
682         """Generate reST for member documentation.
683 
684         If *all_members* is True, do all members, else those given by
685         *self.options.members*.
686         """
687         # set current namespace for finding members
688         self.env.temp_data['autodoc:module'] = self.modname
689         if self.objpath:
690             self.env.temp_data['autodoc:class'] = self.objpath[0]
691 
692         want_all = all_members or self.options.inherited_members or \
693             self.options.members is ALL
694         # find out which members are documentable
695         members_check_module, members = self.get_object_members(want_all)
696 
697         # remove members given by exclude-members
698         if self.options.exclude_members:
699             members = [
700                 (membername, member) for (membername, member) in members
701                 if (
702                     self.options.exclude_members is ALL or
703                     membername not in self.options.exclude_members
704                 )
705             ]
706 
707         # document non-skipped members
708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
709         for (mname, member, isattr) in self.filter_members(members, want_all):
710             classes = [cls for cls in self.documenters.values()
711                        if cls.can_document_member(member, mname, isattr, self)]
712             if not classes:
713                 # don't know how to document this member
714                 continue
715             # prefer the documenter with the highest priority
716             classes.sort(key=lambda cls: cls.priority)
717             # give explicitly separated module name, so that members
718             # of inner classes can be documented
719             full_mname = self.modname + '::' + \
720                 '.'.join(self.objpath + [mname])
721             documenter = classes[-1](self.directive, full_mname, self.indent)
722             memberdocumenters.append((documenter, isattr))
723 
724         member_order = self.options.member_order or self.env.config.autodoc_member_order
725         memberdocumenters = self.sort_members(memberdocumenters, member_order)
726 
727         for documenter, isattr in memberdocumenters:
728             documenter.generate(
729                 all_members=True, real_modname=self.real_modname,
730                 check_module=members_check_module and not isattr)
731 
732         # reset current objects
733         self.env.temp_data['autodoc:module'] = None
734         self.env.temp_data['autodoc:class'] = None
735 
736     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
737                      order: str) -> List[Tuple["Documenter", bool]]:
738         """Sort the given member list."""
739         if order == 'groupwise':
740             # sort by group; alphabetically within groups
741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
742         elif order == 'bysource':
743             if self.analyzer:
744                 # sort by source order, by virtue of the module analyzer
745                 tagorder = self.analyzer.tagorder
746 
747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
748                     fullname = entry[0].name.split('::')[1]
749                     return tagorder.get(fullname, len(tagorder))
750                 documenters.sort(key=keyfunc)
751             else:
752                 # Assume that member discovery order matches source order.
753                 # This is a reasonable assumption in Python 3.6 and up, where
754                 # module.__dict__ is insertion-ordered.
755                 pass
756         else:  # alphabetical
757             documenters.sort(key=lambda e: e[0].name)
758 
759         return documenters
760 
761     def generate(self, more_content: Any = None, real_modname: str = None,
762                  check_module: bool = False, all_members: bool = False) -> None:
763         """Generate reST for the object given by *self.name*, and possibly for
764         its members.
765 
766         If *more_content* is given, include that content. If *real_modname* is
767         given, use that module name to find attribute docs. If *check_module* is
768         True, only generate if the object is defined in the module name it is
769         imported from. If *all_members* is True, document all members.
770         """
771         if not self.parse_name():
772             # need a module to import
773             logger.warning(
774                 __('don\'t know which module to import for autodocumenting '
775                    '%r (try placing a "module" or "currentmodule" directive '
776                    'in the document, or giving an explicit module name)') %
777                 self.name, type='autodoc')
778             return
779 
780         # now, import the module and get object to document
781         if not self.import_object():
782             return
783 
784         # If there is no real module defined, figure out which to use.
785         # The real module is used in the module analyzer to look up the module
786         # where the attribute documentation would actually be found in.
787         # This is used for situations where you have a module that collects the
788         # functions and classes of internal submodules.
789         guess_modname = self.get_real_modname()
790         self.real_modname = real_modname or guess_modname
791 
792         # try to also get a source code analyzer for attribute docs
793         try:
794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
795             # parse right now, to get PycodeErrors on parsing (results will
796             # be cached anyway)
797             self.analyzer.find_attr_docs()
798         except PycodeError as exc:
799             logger.debug('[autodoc] module analyzer failed: %s', exc)
800             # no source file -- e.g. for builtin and C modules
801             self.analyzer = None
802             # at least add the module.__file__ as a dependency
803             if hasattr(self.module, '__file__') and self.module.__file__:
804                 self.directive.filename_set.add(self.module.__file__)
805         else:
806             self.directive.filename_set.add(self.analyzer.srcname)
807 
808         if self.real_modname != guess_modname:
809             # Add module to dependency list if target object is defined in other module.
810             try:
811                 analyzer = ModuleAnalyzer.for_module(guess_modname)
812                 self.directive.filename_set.add(analyzer.srcname)
813             except PycodeError:
814                 pass
815 
816         # check __module__ of object (for members not given explicitly)
817         if check_module:
818             if not self.check_module():
819                 return
820 
821         sourcename = self.get_sourcename()
822 
823         # make sure that the result starts with an empty line.  This is
824         # necessary for some situations where another directive preprocesses
825         # reST and no starting newline is present
826         self.add_line('', sourcename)
827 
828         # format the object's signature, if any
829         sig = self.format_signature()
830 
831         # generate the directive header and options, if applicable
832         self.add_directive_header(sig)
833         self.add_line('', sourcename)
834 
835         # e.g. the module directive doesn't have content
836         self.indent += self.content_indent
837 
838         # add all content (from docstrings, attribute docs etc.)
839         self.add_content(more_content)
840 
841         # document members, if possible
842         self.document_members(all_members)
843 
844 
845 class ModuleDocumenter(Documenter):
846     """
847     Specialized Documenter subclass for modules.
848     """
849     objtype = 'module'
850     content_indent = ''
851     titles_allowed = True
852 
853     option_spec = {
854         'members': members_option, 'undoc-members': bool_option,
855         'noindex': bool_option, 'inherited-members': inherited_members_option,
856         'show-inheritance': bool_option, 'synopsis': identity,
857         'platform': identity, 'deprecated': bool_option,
858         'member-order': member_order_option, 'exclude-members': members_set_option,
859         'private-members': bool_option, 'special-members': members_option,
860         'imported-members': bool_option, 'ignore-module-all': bool_option
861     }  # type: Dict[str, Callable]
862 
863     def __init__(self, *args: Any) -> None:
864         super().__init__(*args)
865         merge_special_members_option(self.options)
866         self.__all__ = None
867 
868     @classmethod
869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
870                             ) -> bool:
871         # don't document submodules automatically
872         return False
873 
874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
875                      ) -> Tuple[str, List[str]]:
876         if modname is not None:
877             logger.warning(__('"::" in automodule name doesn\'t make sense'),
878                            type='autodoc')
879         return (path or '') + base, []
880 
881     def parse_name(self) -> bool:
882         ret = super().parse_name()
883         if self.args or self.retann:
884             logger.warning(__('signature arguments or return annotation '
885                               'given for automodule %s') % self.fullname,
886                            type='autodoc')
887         return ret
888 
889     def import_object(self) -> Any:
890         def is_valid_module_all(__all__: Any) -> bool:
891             """Check the given *__all__* is valid for a module."""
892             if (isinstance(__all__, (list, tuple)) and
893                     all(isinstance(e, str) for e in __all__)):
894                 return True
895             else:
896                 return False
897 
898         ret = super().import_object()
899 
900         if not self.options.ignore_module_all:
901             __all__ = getattr(self.object, '__all__', None)
902             if is_valid_module_all(__all__):
903                 # valid __all__ found. copy it to self.__all__
904                 self.__all__ = __all__
905             elif __all__:
906                 # invalid __all__ found.
907                 logger.warning(__('__all__ should be a list of strings, not %r '
908                                   '(in module %s) -- ignoring __all__') %
909                                (__all__, self.fullname), type='autodoc')
910 
911         return ret
912 
913     def add_directive_header(self, sig: str) -> None:
914         Documenter.add_directive_header(self, sig)
915 
916         sourcename = self.get_sourcename()
917 
918         # add some module-specific options
919         if self.options.synopsis:
920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
921         if self.options.platform:
922             self.add_line('   :platform: ' + self.options.platform, sourcename)
923         if self.options.deprecated:
924             self.add_line('   :deprecated:', sourcename)
925 
926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
927         if want_all:
928             if self.__all__:
929                 memberlist = self.__all__
930             else:
931                 # for implicit module members, check __module__ to avoid
932                 # documenting imported objects
933                 return True, get_module_members(self.object)
934         else:
935             memberlist = self.options.members or []
936         ret = []
937         for mname in memberlist:
938             try:
939                 ret.append((mname, safe_getattr(self.object, mname)))
940             except AttributeError:
941                 logger.warning(
942                     __('missing attribute mentioned in :members: or __all__: '
943                        'module %s, attribute %s') %
944                     (safe_getattr(self.object, '__name__', '???'), mname),
945                     type='autodoc'
946                 )
947         return False, ret
948 
949     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
950                      order: str) -> List[Tuple["Documenter", bool]]:
951         if order == 'bysource' and self.__all__:
952             # Sort alphabetically first (for members not listed on the __all__)
953             documenters.sort(key=lambda e: e[0].name)
954 
955             # Sort by __all__
956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
957                 name = entry[0].name.split('::')[1]
958                 if name in self.__all__:
959                     return self.__all__.index(name)
960                 else:
961                     return len(self.__all__)
962             documenters.sort(key=keyfunc)
963 
964             return documenters
965         else:
966             return super().sort_members(documenters, order)
967 
968 
969 class ModuleLevelDocumenter(Documenter):
970     """
971     Specialized Documenter subclass for objects on module level (functions,
972     classes, data/constants).
973     """
974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
975                      ) -> Tuple[str, List[str]]:
976         if modname is None:
977             if path:
978                 stripped = path.rstrip('.')
979                 modname, qualname = split_full_qualified_name(stripped)
980                 if qualname:
981                     parents = qualname.split(".")
982                 else:
983                     parents = []
984 
985             if modname is None:
986                 # if documenting a toplevel object without explicit module,
987                 # it can be contained in another auto directive ...
988                 modname = self.env.temp_data.get('autodoc:module')
989                 # ... or in the scope of a module directive
990                 if not modname:
991                     modname = self.env.ref_context.get('py:module')
992                 # ... else, it stays None, which means invalid
993         return modname, parents + [base]
994 
995 
996 class ClassLevelDocumenter(Documenter):
997     """
998     Specialized Documenter subclass for objects on class level (methods,
999     attributes).
1000     """
1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1002                      ) -> Tuple[str, List[str]]:
1003         if modname is None:
1004             if path:
1005                 mod_cls = path.rstrip('.')
1006             else:
1007                 mod_cls = None
1008                 # if documenting a class-level object without path,
1009                 # there must be a current class, either from a parent
1010                 # auto directive ...
1011                 mod_cls = self.env.temp_data.get('autodoc:class')
1012                 # ... or from a class directive
1013                 if mod_cls is None:
1014                     mod_cls = self.env.ref_context.get('py:class')
1015                 # ... if still None, there's no way to know
1016                 if mod_cls is None:
1017                     return None, []
1018 
1019             try:
1020                 modname, qualname = split_full_qualified_name(mod_cls)
1021                 parents = qualname.split(".") if qualname else []
1022             except ImportError:
1023                 parents = mod_cls.split(".")
1024 
1025             # if the module name is still missing, get it like above
1026             if not modname:
1027                 modname = self.env.temp_data.get('autodoc:module')
1028             if not modname:
1029                 modname = self.env.ref_context.get('py:module')
1030             # ... else, it stays None, which means invalid
1031         return modname, parents + [base]
1032 
1033 
1034 class DocstringSignatureMixin:
1035     """
1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1037     feature of reading the signature from the docstring.
1038     """
1039     _new_docstrings = None  # type: List[List[str]]
1040     _signatures = None      # type: List[str]
1041 
1042     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1043         if encoding is not None:
1044             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1045                           "deprecated." % self.__class__.__name__,
1046                           RemovedInSphinx40Warning, stacklevel=2)
1047 
1048         # candidates of the object name
1049         valid_names = [self.objpath[-1]]  # type: ignore
1050         if isinstance(self, ClassDocumenter):
1051             valid_names.append('__init__')
1052             if hasattr(self.object, '__mro__'):
1053                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1054 
1055         docstrings = self.get_doc()
1056         self._new_docstrings = docstrings[:]
1057         self._signatures = []
1058         result = None
1059         for i, doclines in enumerate(docstrings):
1060             for j, line in enumerate(doclines):
1061                 if not line:
1062                     # no lines in docstring, no match
1063                     break
1064 
1065                 if line.endswith('\\'):
1066                     multiline = True
1067                     line = line.rstrip('\\').rstrip()
1068                 else:
1069                     multiline = False
1070 
1071                 # match first line of docstring against signature RE
1072                 match = py_ext_sig_re.match(line)
1073                 if not match:
1074                     continue
1075                 exmod, path, base, args, retann = match.groups()
1076 
1077                 # the base name must match ours
1078                 if base not in valid_names:
1079                     continue
1080 
1081                 # re-prepare docstring to ignore more leading indentation
1082                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1083                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1084                                                             tabsize=tab_width)
1085 
1086                 if result is None:
1087                     # first signature
1088                     result = args, retann
1089                 else:
1090                     # subsequent signatures
1091                     self._signatures.append("(%s) -> %s" % (args, retann))
1092 
1093                 if multiline:
1094                     # the signature have multiple signatures on docstring
1095                     continue
1096                 else:
1097                     # don't look any further
1098                     break
1099 
1100             if result:
1101                 # finish the loop when signature found
1102                 break
1103 
1104         return result
1105 
1106     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1107         if encoding is not None:
1108             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1109                           % self.__class__.__name__,
1110                           RemovedInSphinx40Warning, stacklevel=2)
1111         if self._new_docstrings is not None:
1112             return self._new_docstrings
1113         return super().get_doc(None, ignore)  # type: ignore
1114 
1115     def format_signature(self, **kwargs: Any) -> str:
1116         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1117             # only act if a signature is not explicitly given already, and if
1118             # the feature is enabled
1119             result = self._find_signature()
1120             if result is not None:
1121                 self.args, self.retann = result
1122         sig = super().format_signature(**kwargs)  # type: ignore
1123         if self._signatures:
1124             return "\n".join([sig] + self._signatures)
1125         else:
1126             return sig
1127 
1128 
1129 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1130     """
1131     Mixin for AttributeDocumenter to provide the
1132     feature of stripping any function signature from the docstring.
1133     """
1134     def format_signature(self, **kwargs: Any) -> str:
1135         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1136             # only act if a signature is not explicitly given already, and if
1137             # the feature is enabled
1138             result = self._find_signature()
1139             if result is not None:
1140                 # Discarding _args is a only difference with
1141                 # DocstringSignatureMixin.format_signature.
1142                 # Documenter.format_signature use self.args value to format.
1143                 _args, self.retann = result
1144         return super().format_signature(**kwargs)
1145 
1146 
1147 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1148     """
1149     Specialized Documenter subclass for functions.
1150     """
1151     objtype = 'function'
1152     member_order = 30
1153 
1154     @classmethod
1155     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1156                             ) -> bool:
1157         # supports functions, builtins and bound methods exported at the module level
1158         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1159                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1160 
1161     def format_args(self, **kwargs: Any) -> str:
1162         if self.env.config.autodoc_typehints in ('none', 'description'):
1163             kwargs.setdefault('show_annotation', False)
1164 
1165         try:
1166             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1167             if inspect.is_singledispatch_function(self.object):
1168                 sig = inspect.signature(self.object, follow_wrapped=True)
1169             else:
1170                 sig = inspect.signature(self.object)
1171             args = stringify_signature(sig, **kwargs)
1172         except TypeError as exc:
1173             logger.warning(__("Failed to get a function signature for %s: %s"),
1174                            self.fullname, exc)
1175             return None
1176         except ValueError:
1177             args = ''
1178 
1179         if self.env.config.strip_signature_backslash:
1180             # escape backslashes for reST
1181             args = args.replace('\\', '\\\\')
1182         return args
1183 
1184     def document_members(self, all_members: bool = False) -> None:
1185         pass
1186 
1187     def add_directive_header(self, sig: str) -> None:
1188         sourcename = self.get_sourcename()
1189         super().add_directive_header(sig)
1190 
1191         if inspect.iscoroutinefunction(self.object):
1192             self.add_line('   :async:', sourcename)
1193 
1194     def format_signature(self, **kwargs: Any) -> str:
1195         sigs = []
1196         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1197             # Use signatures for overloaded functions instead of the implementation function.
1198             overloaded = True
1199         else:
1200             overloaded = False
1201             sig = super().format_signature(**kwargs)
1202             sigs.append(sig)
1203 
1204         if inspect.is_singledispatch_function(self.object):
1205             # append signature of singledispatch'ed functions
1206             for typ, func in self.object.registry.items():
1207                 if typ is object:
1208                     pass  # default implementation. skipped.
1209                 else:
1210                     self.annotate_to_first_argument(func, typ)
1211 
1212                     documenter = FunctionDocumenter(self.directive, '')
1213                     documenter.object = func
1214                     documenter.objpath = [None]
1215                     sigs.append(documenter.format_signature())
1216         if overloaded:
1217             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1218                 sig = stringify_signature(overload, **kwargs)
1219                 sigs.append(sig)
1220 
1221         return "\n".join(sigs)
1222 
1223     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1224         """Annotate type hint to the first argument of function if needed."""
1225         try:
1226             sig = inspect.signature(func)
1227         except TypeError as exc:
1228             logger.warning(__("Failed to get a function signature for %s: %s"),
1229                            self.fullname, exc)
1230             return
1231         except ValueError:
1232             return
1233 
1234         if len(sig.parameters) == 0:
1235             return
1236 
1237         params = list(sig.parameters.values())
1238         if params[0].annotation is Parameter.empty:
1239             params[0] = params[0].replace(annotation=typ)
1240             try:
1241                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1242             except TypeError:
1243                 # failed to update signature (ex. built-in or extension types)
1244                 return
1245 
1246 
1247 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1248     """
1249     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1250 
1251     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1252     """
1253 
1254 
1255 class DecoratorDocumenter(FunctionDocumenter):
1256     """
1257     Specialized Documenter subclass for decorator functions.
1258     """
1259     objtype = 'decorator'
1260 
1261     # must be lower than FunctionDocumenter
1262     priority = -1
1263 
1264     def format_args(self, **kwargs: Any) -> Any:
1265         args = super().format_args(**kwargs)
1266         if ',' in args:
1267             return args
1268         else:
1269             return None
1270 
1271 
1272 # Types which have confusing metaclass signatures it would be best not to show.
1273 # These are listed by name, rather than storing the objects themselves, to avoid
1274 # needing to import the modules.
1275 _METACLASS_CALL_BLACKLIST = [
1276     'enum.EnumMeta.__call__',
1277 ]
1278 
1279 
1280 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1281     """
1282     Specialized Documenter subclass for classes.
1283     """
1284     objtype = 'class'
1285     member_order = 20
1286     option_spec = {
1287         'members': members_option, 'undoc-members': bool_option,
1288         'noindex': bool_option, 'inherited-members': inherited_members_option,
1289         'show-inheritance': bool_option, 'member-order': member_order_option,
1290         'exclude-members': members_set_option,
1291         'private-members': bool_option, 'special-members': members_option,
1292     }  # type: Dict[str, Callable]
1293 
1294     _signature_class = None  # type: Any
1295     _signature_method_name = None  # type: str
1296 
1297     def __init__(self, *args: Any) -> None:
1298         super().__init__(*args)
1299         merge_special_members_option(self.options)
1300 
1301     @classmethod
1302     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1303                             ) -> bool:
1304         return isinstance(member, type)
1305 
1306     def import_object(self) -> Any:
1307         ret = super().import_object()
1308         # if the class is documented under another name, document it
1309         # as data/attribute
1310         if ret:
1311             if hasattr(self.object, '__name__'):
1312                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1313             else:
1314                 self.doc_as_attr = True
1315         return ret
1316 
1317     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1318         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1319             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1320             if inspect.is_builtin_class_method(obj, attr):
1321                 return None
1322             attr = self.get_attr(obj, attr, None)
1323             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1324                 return None
1325             return attr
1326 
1327         # This sequence is copied from inspect._signature_from_callable.
1328         # ValueError means that no signature could be found, so we keep going.
1329 
1330         # First, let's see if it has an overloaded __call__ defined
1331         # in its metaclass
1332         call = get_user_defined_function_or_method(type(self.object), '__call__')
1333 
1334         if call is not None:
1335             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1336                 call = None
1337 
1338         if call is not None:
1339             self.env.app.emit('autodoc-before-process-signature', call, True)
1340             try:
1341                 sig = inspect.signature(call, bound_method=True)
1342                 return type(self.object), '__call__', sig
1343             except ValueError:
1344                 pass
1345 
1346         # Now we check if the 'obj' class has a '__new__' method
1347         new = get_user_defined_function_or_method(self.object, '__new__')
1348         if new is not None:
1349             self.env.app.emit('autodoc-before-process-signature', new, True)
1350             try:
1351                 sig = inspect.signature(new, bound_method=True)
1352                 return self.object, '__new__', sig
1353             except ValueError:
1354                 pass
1355 
1356         # Finally, we should have at least __init__ implemented
1357         init = get_user_defined_function_or_method(self.object, '__init__')
1358         if init is not None:
1359             self.env.app.emit('autodoc-before-process-signature', init, True)
1360             try:
1361                 sig = inspect.signature(init, bound_method=True)
1362                 return self.object, '__init__', sig
1363             except ValueError:
1364                 pass
1365 
1366         # None of the attributes are user-defined, so fall back to let inspect
1367         # handle it.
1368         # We don't know the exact method that inspect.signature will read
1369         # the signature from, so just pass the object itself to our hook.
1370         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1371         try:
1372             sig = inspect.signature(self.object, bound_method=False)
1373             return None, None, sig
1374         except ValueError:
1375             pass
1376 
1377         # Still no signature: happens e.g. for old-style classes
1378         # with __init__ in C and no `__text_signature__`.
1379         return None, None, None
1380 
1381     def format_args(self, **kwargs: Any) -> str:
1382         if self.env.config.autodoc_typehints in ('none', 'description'):
1383             kwargs.setdefault('show_annotation', False)
1384 
1385         try:
1386             self._signature_class, self._signature_method_name, sig = self._get_signature()
1387         except TypeError as exc:
1388             # __signature__ attribute contained junk
1389             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1390                            self.fullname, exc)
1391             return None
1392 
1393         if sig is None:
1394             return None
1395 
1396         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1397 
1398     def format_signature(self, **kwargs: Any) -> str:
1399         if self.doc_as_attr:
1400             return ''
1401 
1402         sig = super().format_signature()
1403 
1404         overloaded = False
1405         qualname = None
1406         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)
1407         if self._signature_class and self._signature_method_name and self.analyzer:
1408             qualname = '.'.join([self._signature_class.__qualname__,
1409                                  self._signature_method_name])
1410             if qualname in self.analyzer.overloads:
1411                 overloaded = True
1412 
1413         sigs = []
1414         if overloaded:
1415             # Use signatures for overloaded methods instead of the implementation method.
1416             for overload in self.analyzer.overloads.get(qualname):
1417                 parameters = list(overload.parameters.values())
1418                 overload = overload.replace(parameters=parameters[1:],
1419                                             return_annotation=Parameter.empty)
1420                 sig = stringify_signature(overload, **kwargs)
1421                 sigs.append(sig)
1422         else:
1423             sigs.append(sig)
1424 
1425         return "\n".join(sigs)
1426 
1427     def add_directive_header(self, sig: str) -> None:
1428         sourcename = self.get_sourcename()
1429 
1430         if self.doc_as_attr:
1431             self.directivetype = 'attribute'
1432         super().add_directive_header(sig)
1433 
1434         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1435             self.add_line('   :final:', sourcename)
1436 
1437         # add inheritance info, if wanted
1438         if not self.doc_as_attr and self.options.show_inheritance:
1439             sourcename = self.get_sourcename()
1440             self.add_line('', sourcename)
1441             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1442                 bases = [':class:`%s`' % b.__name__
1443                          if b.__module__ in ('__builtin__', 'builtins')
1444                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1445                          for b in self.object.__bases__]
1446                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1447                               sourcename)
1448 
1449     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1450         if encoding is not None:
1451             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1452                           % self.__class__.__name__,
1453                           RemovedInSphinx40Warning, stacklevel=2)
1454         lines = getattr(self, '_new_docstrings', None)
1455         if lines is not None:
1456             return lines
1457 
1458         content = self.env.config.autoclass_content
1459 
1460         docstrings = []
1461         attrdocstring = self.get_attr(self.object, '__doc__', None)
1462         if attrdocstring:
1463             docstrings.append(attrdocstring)
1464 
1465         # for classes, what the "docstring" is can be controlled via a
1466         # config value; the default is only the class docstring
1467         if content in ('both', 'init'):
1468             __init__ = self.get_attr(self.object, '__init__', None)
1469             initdocstring = getdoc(__init__, self.get_attr,
1470                                    self.env.config.autodoc_inherit_docstrings,
1471                                    self.parent, self.object_name)
1472             # for new-style classes, no __init__ means default __init__
1473             if (initdocstring is not None and
1474                 (initdocstring == object.__init__.__doc__ or  # for pypy
1475                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1476                 initdocstring = None
1477             if not initdocstring:
1478                 # try __new__
1479                 __new__ = self.get_attr(self.object, '__new__', None)
1480                 initdocstring = getdoc(__new__, self.get_attr,
1481                                        self.env.config.autodoc_inherit_docstrings,
1482                                        self.parent, self.object_name)
1483                 # for new-style classes, no __new__ means default __new__
1484                 if (initdocstring is not None and
1485                     (initdocstring == object.__new__.__doc__ or  # for pypy
1486                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1487                     initdocstring = None
1488             if initdocstring:
1489                 if content == 'init':
1490                     docstrings = [initdocstring]
1491                 else:
1492                     docstrings.append(initdocstring)
1493 
1494         tab_width = self.directive.state.document.settings.tab_width
1495         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1496 
1497     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1498         if self.doc_as_attr:
1499             classname = safe_getattr(self.object, '__qualname__', None)
1500             if not classname:
1501                 classname = safe_getattr(self.object, '__name__', None)
1502             if classname:
1503                 module = safe_getattr(self.object, '__module__', None)
1504                 parentmodule = safe_getattr(self.parent, '__module__', None)
1505                 if module and module != parentmodule:
1506                     classname = str(module) + '.' + str(classname)
1507                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1508                 super().add_content(content, no_docstring=True)
1509         else:
1510             super().add_content(more_content)
1511 
1512     def document_members(self, all_members: bool = False) -> None:
1513         if self.doc_as_attr:
1514             return
1515         super().document_members(all_members)
1516 
1517     def generate(self, more_content: Any = None, real_modname: str = None,
1518                  check_module: bool = False, all_members: bool = False) -> None:
1519         # Do not pass real_modname and use the name from the __module__
1520         # attribute of the class.
1521         # If a class gets imported into the module real_modname
1522         # the analyzer won't find the source of the class, if
1523         # it looks in real_modname.
1524         return super().generate(more_content=more_content,
1525                                 check_module=check_module,
1526                                 all_members=all_members)
1527 
1528 
1529 class ExceptionDocumenter(ClassDocumenter):
1530     """
1531     Specialized ClassDocumenter subclass for exceptions.
1532     """
1533     objtype = 'exception'
1534     member_order = 10
1535 
1536     # needs a higher priority than ClassDocumenter
1537     priority = 10
1538 
1539     @classmethod
1540     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1541                             ) -> bool:
1542         return isinstance(member, type) and issubclass(member, BaseException)
1543 
1544 
1545 class DataDocumenter(ModuleLevelDocumenter):
1546     """
1547     Specialized Documenter subclass for data items.
1548     """
1549     objtype = 'data'
1550     member_order = 40
1551     priority = -10
1552     option_spec = dict(ModuleLevelDocumenter.option_spec)
1553     option_spec["annotation"] = annotation_option
1554 
1555     @classmethod
1556     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1557                             ) -> bool:
1558         return isinstance(parent, ModuleDocumenter) and isattr
1559 
1560     def add_directive_header(self, sig: str) -> None:
1561         super().add_directive_header(sig)
1562         sourcename = self.get_sourcename()
1563         if not self.options.annotation:
1564             # obtain annotation for this data
1565             annotations = getattr(self.parent, '__annotations__', {})
1566             if annotations and self.objpath[-1] in annotations:
1567                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1568                 self.add_line('   :type: ' + objrepr, sourcename)
1569             else:
1570                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1571                 if self.analyzer and key in self.analyzer.annotations:
1572                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1573                                   sourcename)
1574 
1575             try:
1576                 if self.object is UNINITIALIZED_ATTR:
1577                     pass
1578                 else:
1579                     objrepr = object_description(self.object)
1580                     self.add_line('   :value: ' + objrepr, sourcename)
1581             except ValueError:
1582                 pass
1583         elif self.options.annotation is SUPPRESS:
1584             pass
1585         else:
1586             self.add_line('   :annotation: %s' % self.options.annotation,
1587                           sourcename)
1588 
1589     def document_members(self, all_members: bool = False) -> None:
1590         pass
1591 
1592     def get_real_modname(self) -> str:
1593         return self.get_attr(self.parent or self.object, '__module__', None) \
1594             or self.modname
1595 
1596 
1597 class DataDeclarationDocumenter(DataDocumenter):
1598     """
1599     Specialized Documenter subclass for data that cannot be imported
1600     because they are declared without initial value (refs: PEP-526).
1601     """
1602     objtype = 'datadecl'
1603     directivetype = 'data'
1604     member_order = 60
1605 
1606     # must be higher than AttributeDocumenter
1607     priority = 11
1608 
1609     @classmethod
1610     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1611                             ) -> bool:
1612         """This documents only INSTANCEATTR members."""
1613         return (isinstance(parent, ModuleDocumenter) and
1614                 isattr and
1615                 member is INSTANCEATTR)
1616 
1617     def import_object(self) -> bool:
1618         """Never import anything."""
1619         # disguise as a data
1620         self.objtype = 'data'
1621         self.object = UNINITIALIZED_ATTR
1622         try:
1623             # import module to obtain type annotation
1624             self.parent = importlib.import_module(self.modname)
1625         except ImportError:
1626             pass
1627 
1628         return True
1629 
1630     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1631         """Never try to get a docstring from the object."""
1632         super().add_content(more_content, no_docstring=True)
1633 
1634 
1635 class GenericAliasDocumenter(DataDocumenter):
1636     """
1637     Specialized Documenter subclass for GenericAliases.
1638     """
1639 
1640     objtype = 'genericalias'
1641     directivetype = 'data'
1642     priority = DataDocumenter.priority + 1
1643 
1644     @classmethod
1645     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1646                             ) -> bool:
1647         return inspect.isgenericalias(member)
1648 
1649     def add_directive_header(self, sig: str) -> None:
1650         self.options.annotation = SUPPRESS  # type: ignore
1651         super().add_directive_header(sig)
1652 
1653     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1654         name = stringify_typehint(self.object)
1655         content = StringList([_('alias of %s') % name], source='')
1656         super().add_content(content)
1657 
1658 
1659 class TypeVarDocumenter(DataDocumenter):
1660     """
1661     Specialized Documenter subclass for TypeVars.
1662     """
1663 
1664     objtype = 'typevar'
1665     directivetype = 'data'
1666     priority = DataDocumenter.priority + 1
1667 
1668     @classmethod
1669     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1670                             ) -> bool:
1671         return isinstance(member, TypeVar) and isattr  # type: ignore
1672 
1673     def add_directive_header(self, sig: str) -> None:
1674         self.options.annotation = SUPPRESS  # type: ignore
1675         super().add_directive_header(sig)
1676 
1677     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1678         if ignore is not None:
1679             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1680                           % self.__class__.__name__,
1681                           RemovedInSphinx50Warning, stacklevel=2)
1682 
1683         if self.object.__doc__ != TypeVar.__doc__:
1684             return super().get_doc()
1685         else:
1686             return []
1687 
1688     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1689         attrs = [repr(self.object.__name__)]
1690         for constraint in self.object.__constraints__:
1691             attrs.append(stringify_typehint(constraint))
1692         if self.object.__covariant__:
1693             attrs.append("covariant=True")
1694         if self.object.__contravariant__:
1695             attrs.append("contravariant=True")
1696 
1697         content = StringList([_('alias of TypeVar(%s)') % ", ".join(attrs)], source='')
1698         super().add_content(content)
1699 
1700 
1701 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1702     """
1703     Specialized Documenter subclass for methods (normal, static and class).
1704     """
1705     objtype = 'method'
1706     directivetype = 'method'
1707     member_order = 50
1708     priority = 1  # must be more than FunctionDocumenter
1709 
1710     @classmethod
1711     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1712                             ) -> bool:
1713         return inspect.isroutine(member) and \
1714             not isinstance(parent, ModuleDocumenter)
1715 
1716     def import_object(self) -> Any:
1717         ret = super().import_object()
1718         if not ret:
1719             return ret
1720 
1721         # to distinguish classmethod/staticmethod
1722         obj = self.parent.__dict__.get(self.object_name)
1723         if obj is None:
1724             obj = self.object
1725 
1726         if (inspect.isclassmethod(obj) or
1727                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1728             # document class and static members before ordinary ones
1729             self.member_order = self.member_order - 1
1730 
1731         return ret
1732 
1733     def format_args(self, **kwargs: Any) -> str:
1734         if self.env.config.autodoc_typehints in ('none', 'description'):
1735             kwargs.setdefault('show_annotation', False)
1736 
1737         try:
1738             if self.object == object.__init__ and self.parent != object:
1739                 # Classes not having own __init__() method are shown as no arguments.
1740                 #
1741                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1742                 #       But it makes users confused.
1743                 args = '()'
1744             else:
1745                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1746                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1747                     sig = inspect.signature(self.object, bound_method=False)
1748                 else:
1749                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1750 
1751                     meth = self.parent.__dict__.get(self.objpath[-1], None)
1752                     if meth and inspect.is_singledispatch_method(meth):
1753                         sig = inspect.signature(self.object, bound_method=True,
1754                                                 follow_wrapped=True)
1755                     else:
1756                         sig = inspect.signature(self.object, bound_method=True)
1757                 args = stringify_signature(sig, **kwargs)
1758         except TypeError as exc:
1759             logger.warning(__("Failed to get a method signature for %s: %s"),
1760                            self.fullname, exc)
1761             return None
1762         except ValueError:
1763             args = ''
1764 
1765         if self.env.config.strip_signature_backslash:
1766             # escape backslashes for reST
1767             args = args.replace('\\', '\\\\')
1768         return args
1769 
1770     def add_directive_header(self, sig: str) -> None:
1771         super().add_directive_header(sig)
1772 
1773         sourcename = self.get_sourcename()
1774         obj = self.parent.__dict__.get(self.object_name, self.object)
1775         if inspect.isabstractmethod(obj):
1776             self.add_line('   :abstractmethod:', sourcename)
1777         if inspect.iscoroutinefunction(obj):
1778             self.add_line('   :async:', sourcename)
1779         if inspect.isclassmethod(obj):
1780             self.add_line('   :classmethod:', sourcename)
1781         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1782             self.add_line('   :staticmethod:', sourcename)
1783         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1784             self.add_line('   :final:', sourcename)
1785 
1786     def document_members(self, all_members: bool = False) -> None:
1787         pass
1788 
1789     def format_signature(self, **kwargs: Any) -> str:
1790         sigs = []
1791         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1792             # Use signatures for overloaded methods instead of the implementation method.
1793             overloaded = True
1794         else:
1795             overloaded = False
1796             sig = super().format_signature(**kwargs)
1797             sigs.append(sig)
1798 
1799         meth = self.parent.__dict__.get(self.objpath[-1])
1800         if inspect.is_singledispatch_method(meth):
1801             # append signature of singledispatch'ed functions
1802             for typ, func in meth.dispatcher.registry.items():
1803                 if typ is object:
1804                     pass  # default implementation. skipped.
1805                 else:
1806                     self.annotate_to_first_argument(func, typ)
1807 
1808                     documenter = MethodDocumenter(self.directive, '')
1809                     documenter.parent = self.parent
1810                     documenter.object = func
1811                     documenter.objpath = [None]
1812                     sigs.append(documenter.format_signature())
1813         if overloaded:
1814             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1815                 if not inspect.isstaticmethod(self.object, cls=self.parent,
1816                                               name=self.object_name):
1817                     parameters = list(overload.parameters.values())
1818                     overload = overload.replace(parameters=parameters[1:])
1819                 sig = stringify_signature(overload, **kwargs)
1820                 sigs.append(sig)
1821 
1822         return "\n".join(sigs)
1823 
1824     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1825         """Annotate type hint to the first argument of function if needed."""
1826         try:
1827             sig = inspect.signature(func)
1828         except TypeError as exc:
1829             logger.warning(__("Failed to get a method signature for %s: %s"),
1830                            self.fullname, exc)
1831             return
1832         except ValueError:
1833             return
1834         if len(sig.parameters) == 1:
1835             return
1836 
1837         params = list(sig.parameters.values())
1838         if params[1].annotation is Parameter.empty:
1839             params[1] = params[1].replace(annotation=typ)
1840             try:
1841                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1842             except TypeError:
1843                 # failed to update signature (ex. built-in or extension types)
1844                 return
1845 
1846 
1847 class SingledispatchMethodDocumenter(MethodDocumenter):
1848     """
1849     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1850 
1851     Retained for backwards compatibility, now does the same as the MethodDocumenter
1852     """
1853 
1854 
1855 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1856     """
1857     Specialized Documenter subclass for attributes.
1858     """
1859     objtype = 'attribute'
1860     member_order = 60
1861     option_spec = dict(ModuleLevelDocumenter.option_spec)
1862     option_spec["annotation"] = annotation_option
1863 
1864     # must be higher than the MethodDocumenter, else it will recognize
1865     # some non-data descriptors as methods
1866     priority = 10
1867 
1868     @staticmethod
1869     def is_function_or_method(obj: Any) -> bool:
1870         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1871 
1872     @classmethod
1873     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1874                             ) -> bool:
1875         if inspect.isattributedescriptor(member):
1876             return True
1877         elif (not isinstance(parent, ModuleDocumenter) and
1878               not inspect.isroutine(member) and
1879               not isinstance(member, type)):
1880             return True
1881         else:
1882             return False
1883 
1884     def document_members(self, all_members: bool = False) -> None:
1885         pass
1886 
1887     def import_object(self) -> Any:
1888         ret = super().import_object()
1889         if inspect.isenumattribute(self.object):
1890             self.object = self.object.value
1891         if inspect.isattributedescriptor(self.object):
1892             self._datadescriptor = True
1893         else:
1894             # if it's not a data descriptor
1895             self._datadescriptor = False
1896         return ret
1897 
1898     def get_real_modname(self) -> str:
1899         return self.get_attr(self.parent or self.object, '__module__', None) \
1900             or self.modname
1901 
1902     def add_directive_header(self, sig: str) -> None:
1903         super().add_directive_header(sig)
1904         sourcename = self.get_sourcename()
1905         if not self.options.annotation:
1906             # obtain type annotation for this attribute
1907             annotations = getattr(self.parent, '__annotations__', {})
1908             if annotations and self.objpath[-1] in annotations:
1909                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1910                 self.add_line('   :type: ' + objrepr, sourcename)
1911             else:
1912                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1913                 if self.analyzer and key in self.analyzer.annotations:
1914                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1915                                   sourcename)
1916 
1917             # data descriptors do not have useful values
1918             if not self._datadescriptor:
1919                 try:
1920                     if self.object is INSTANCEATTR:
1921                         pass
1922                     else:
1923                         objrepr = object_description(self.object)
1924                         self.add_line('   :value: ' + objrepr, sourcename)
1925                 except ValueError:
1926                     pass
1927         elif self.options.annotation is SUPPRESS:
1928             pass
1929         else:
1930             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
1931 
1932     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1933         try:
1934             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
1935             # a docstring from the value which descriptor returns unexpectedly.
1936             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
1937             orig = self.env.config.autodoc_inherit_docstrings
1938             self.env.config.autodoc_inherit_docstrings = False  # type: ignore
1939             return super().get_doc(encoding, ignore)
1940         finally:
1941             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore
1942 
1943     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1944         if not self._datadescriptor:
1945             # if it's not a data descriptor, its docstring is very probably the
1946             # wrong thing to display
1947             no_docstring = True
1948         super().add_content(more_content, no_docstring)
1949 
1950 
1951 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1952     """
1953     Specialized Documenter subclass for properties.
1954     """
1955     objtype = 'property'
1956     directivetype = 'method'
1957     member_order = 60
1958 
1959     # before AttributeDocumenter
1960     priority = AttributeDocumenter.priority + 1
1961 
1962     @classmethod
1963     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1964                             ) -> bool:
1965         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
1966 
1967     def document_members(self, all_members: bool = False) -> None:
1968         pass
1969 
1970     def get_real_modname(self) -> str:
1971         return self.get_attr(self.parent or self.object, '__module__', None) \
1972             or self.modname
1973 
1974     def add_directive_header(self, sig: str) -> None:
1975         super().add_directive_header(sig)
1976         sourcename = self.get_sourcename()
1977         if inspect.isabstractmethod(self.object):
1978             self.add_line('   :abstractmethod:', sourcename)
1979         self.add_line('   :property:', sourcename)
1980 
1981 
1982 class InstanceAttributeDocumenter(AttributeDocumenter):
1983     """
1984     Specialized Documenter subclass for attributes that cannot be imported
1985     because they are instance attributes (e.g. assigned in __init__).
1986     """
1987     objtype = 'instanceattribute'
1988     directivetype = 'attribute'
1989     member_order = 60
1990 
1991     # must be higher than AttributeDocumenter
1992     priority = 11
1993 
1994     @classmethod
1995     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1996                             ) -> bool:
1997         """This documents only INSTANCEATTR members."""
1998         return (not isinstance(parent, ModuleDocumenter) and
1999                 isattr and
2000                 member is INSTANCEATTR)
2001 
2002     def import_object(self) -> bool:
2003         """Never import anything."""
2004         # disguise as an attribute
2005         self.objtype = 'attribute'
2006         self.object = INSTANCEATTR
2007         self._datadescriptor = False
2008         return True
2009 
2010     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2011         """Never try to get a docstring from the object."""
2012         super().add_content(more_content, no_docstring=True)
2013 
2014 
2015 class SlotsAttributeDocumenter(AttributeDocumenter):
2016     """
2017     Specialized Documenter subclass for attributes that cannot be imported
2018     because they are attributes in __slots__.
2019     """
2020     objtype = 'slotsattribute'
2021     directivetype = 'attribute'
2022     member_order = 60
2023 
2024     # must be higher than AttributeDocumenter
2025     priority = 11
2026 
2027     @classmethod
2028     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2029                             ) -> bool:
2030         """This documents only SLOTSATTR members."""
2031         return member is SLOTSATTR
2032 
2033     def import_object(self) -> Any:
2034         """Never import anything."""
2035         # disguise as an attribute
2036         self.objtype = 'attribute'
2037         self._datadescriptor = True
2038 
2039         with mock(self.env.config.autodoc_mock_imports):
2040             try:
2041                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2042                                     attrgetter=self.get_attr,
2043                                     warningiserror=self.env.config.autodoc_warningiserror)
2044                 self.module, _, _, self.parent = ret
2045                 return True
2046             except ImportError as exc:
2047                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2048                 self.env.note_reread()
2049                 return False
2050 
2051     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2052         """Decode and return lines of the docstring(s) for the object."""
2053         if ignore is not None:
2054             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
2055                           % self.__class__.__name__,
2056                           RemovedInSphinx50Warning, stacklevel=2)
2057         name = self.objpath[-1]
2058         __slots__ = safe_getattr(self.parent, '__slots__', [])
2059         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
2060             docstring = prepare_docstring(__slots__[name])
2061             return [docstring]
2062         else:
2063             return []
2064 
2065 
2066 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2067     """Returns registered Documenter classes"""
2068     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2069     return app.registry.documenters
2070 
2071 
2072 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2073     """Alternative getattr() for types"""
2074     for typ, func in app.registry.autodoc_attrgettrs.items():
2075         if isinstance(obj, typ):
2076             return func(obj, name, *defargs)
2077 
2078     return safe_getattr(obj, name, *defargs)
2079 
2080 
2081 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2082     if config.autodoc_member_order == 'alphabetic':
2083         # RemovedInSphinx50Warning
2084         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2085                           'instead of "alphabetic". Please update your setting.'))
2086         config.autodoc_member_order = 'alphabetical'  # type: ignore
2087 
2088 
2089 def setup(app: Sphinx) -> Dict[str, Any]:
2090     app.add_autodocumenter(ModuleDocumenter)
2091     app.add_autodocumenter(ClassDocumenter)
2092     app.add_autodocumenter(ExceptionDocumenter)
2093     app.add_autodocumenter(DataDocumenter)
2094     app.add_autodocumenter(DataDeclarationDocumenter)
2095     app.add_autodocumenter(GenericAliasDocumenter)
2096     app.add_autodocumenter(TypeVarDocumenter)
2097     app.add_autodocumenter(FunctionDocumenter)
2098     app.add_autodocumenter(DecoratorDocumenter)
2099     app.add_autodocumenter(MethodDocumenter)
2100     app.add_autodocumenter(AttributeDocumenter)
2101     app.add_autodocumenter(PropertyDocumenter)
2102     app.add_autodocumenter(InstanceAttributeDocumenter)
2103     app.add_autodocumenter(SlotsAttributeDocumenter)
2104 
2105     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2106     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2107                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2108     app.add_config_value('autodoc_default_options', {}, True)
2109     app.add_config_value('autodoc_docstring_signature', True, True)
2110     app.add_config_value('autodoc_mock_imports', [], True)
2111     app.add_config_value('autodoc_typehints', "signature", True,
2112                          ENUM("signature", "description", "none"))
2113     app.add_config_value('autodoc_warningiserror', True, True)
2114     app.add_config_value('autodoc_inherit_docstrings', True, True)
2115     app.add_event('autodoc-before-process-signature')
2116     app.add_event('autodoc-process-docstring')
2117     app.add_event('autodoc-process-signature')
2118     app.add_event('autodoc-skip-member')
2119 
2120     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2121 
2122     app.setup_extension('sphinx.ext.autodoc.type_comment')
2123     app.setup_extension('sphinx.ext.autodoc.typehints')
2124 
2125     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>These methods must be refined to handle generically typed classes and members correctly. Specifically, they should properly interpret and document `TypeVar` and generic types without resulting in `TypeError`. This means when extracting and adding documentation content, any `TypeVar` related to a member should be processed to display its defined constrains or bound types accurately in the documentation. Additionally, enhancing the conditional logic in `can_document_member` to detect and affirm the documentability of members with generic types would ensure that all relevant parts of generically-typed classes are included in the Sphinx documentation output.</intended_behavior>]
2025-10-18 06:48:21.521 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:48:21.521 | INFO     | Search-only: skipping patch selection
2025-10-18 06:48:21.613 | INFO     | Task sphinx-doc__sphinx-7889 completed successfully.
2025-10-18 06:48:21.614 | INFO     | No patch generated. You can try running ACR again.
