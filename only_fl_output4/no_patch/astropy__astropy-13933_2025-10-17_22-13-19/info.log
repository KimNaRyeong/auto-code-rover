2025-10-17 22:13:20.124 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 22:13:23.378 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=690, output_tokens=12, cost=0.007260
2025-10-17 22:13:33.637 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=870, output_tokens=396, cost=0.020580
2025-10-17 22:13:34.674 | INFO     | registered non reproducing test 0
2025-10-17 22:13:46.273 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2059, output_tokens=527, cost=0.036400
2025-10-17 22:13:47.283 | INFO     | registered non reproducing test 1
2025-10-17 22:14:00.377 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2193, output_tokens=602, cost=0.039990
2025-10-17 22:14:01.371 | INFO     | registered non reproducing test 2
2025-10-17 22:14:01.371 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 22:14:01.377 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:14:05.160 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=165, cost=0.011280
2025-10-17 22:14:05.162 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:14:07.033 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=519, output_tokens=51, cost=0.006720
2025-10-17 22:14:07.034 | DEBUG    | Extracted a valid json.
2025-10-17 22:14:07.034 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Angle\")",
        "search_method_in_class(\"to_string\", \"Angle\")",
        "search_code(\"pickle.loads(pickle.dumps(\")"
    ],
    "bug_locations": []
}
2025-10-17 22:14:07.077 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 22:14:07.077 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 22:14:22.185 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3009, output_tokens=713, cost=0.051480
2025-10-17 22:14:22.196 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:14:27.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3938, output_tokens=216, cost=0.045860
2025-10-17 22:14:27.809 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:14:34.820 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=570, output_tokens=211, cost=0.012030
2025-10-17 22:14:34.821 | DEBUG    | Extracted a valid json.
2025-10-17 22:14:34.821 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "astropy/coordinates/angles.py", "class": "Angle", "method": "to_string", "intended_behavior": "The `to_string` method should correctly interpret and convert the unit of an `Angle` object into a string representation, regardless of the object being pickled and unpickled. To resolve the issue, the method must ensure that the unit (whether `hourangle`, `degree`, or any other angular unit) retains its full functionality and identification for sexagesimal notation conversion post-deserialization. This might involve either fixing how units are restored during the unpickling process or adding a verification step within `to_string` to correctly re-interpret or set the unit based on the angle's value if it's found to be compromised after unpickling. This fix should preserve the existing functionality, allowing for both decimal and sexagesimal representations with various formatting options, without introducing regressions for non-pickled `Angle` objects."}]
}
2025-10-17 22:14:34.828 | DEBUG    | Bug location extracted successfully: [<file>astropy/coordinates/angles.py</file>
<class>Angle</class>
<method>to_string</method>
<code>
201     def to_string(self, unit=None, decimal=False, sep='fromunit',
202                   precision=None, alwayssign=False, pad=False,
203                   fields=3, format=None):
204         """ A string representation of the angle.
205 
206         Parameters
207         ----------
208         unit : `~astropy.units.UnitBase`, optional
209             Specifies the unit.  Must be an angular unit.  If not
210             provided, the unit used to initialize the angle will be
211             used.
212 
213         decimal : bool, optional
214             If `True`, a decimal representation will be used, otherwise
215             the returned string will be in sexagesimal form.
216 
217         sep : str, optional
218             The separator between numbers in a sexagesimal
219             representation.  E.g., if it is ':', the result is
220             ``'12:41:11.1241'``. Also accepts 2 or 3 separators. E.g.,
221             ``sep='hms'`` would give the result ``'12h41m11.1241s'``, or
222             sep='-:' would yield ``'11-21:17.124'``.  Alternatively, the
223             special string 'fromunit' means 'dms' if the unit is
224             degrees, or 'hms' if the unit is hours.
225 
226         precision : int, optional
227             The level of decimal precision.  If ``decimal`` is `True`,
228             this is the raw precision, otherwise it gives the
229             precision of the last place of the sexagesimal
230             representation (seconds).  If `None`, or not provided, the
231             number of decimal places is determined by the value, and
232             will be between 0-8 decimal places as required.
233 
234         alwayssign : bool, optional
235             If `True`, include the sign no matter what.  If `False`,
236             only include the sign if it is negative.
237 
238         pad : bool, optional
239             If `True`, include leading zeros when needed to ensure a
240             fixed number of characters for sexagesimal representation.
241 
242         fields : int, optional
243             Specifies the number of fields to display when outputting
244             sexagesimal notation.  For example:
245 
246                 - fields == 1: ``'5d'``
247                 - fields == 2: ``'5d45m'``
248                 - fields == 3: ``'5d45m32.5s'``
249 
250             By default, all fields are displayed.
251 
252         format : str, optional
253             The format of the result.  If not provided, an unadorned
254             string is returned.  Supported values are:
255 
256             - 'latex': Return a LaTeX-formatted string
257 
258             - 'latex_inline': Return a LaTeX-formatted string which is the
259               same as with ``format='latex'`` for |Angle| instances
260 
261             - 'unicode': Return a string containing non-ASCII unicode
262               characters, such as the degree symbol
263 
264         Returns
265         -------
266         strrepr : str or array
267             A string representation of the angle. If the angle is an array, this
268             will be an array with a unicode dtype.
269 
270         """
271         if unit is None:
272             unit = self.unit
273         else:
274             unit = self._convert_unit_to_angle_unit(u.Unit(unit))
275 
276         separators = {
277             None: {
278                 u.degree: 'dms',
279                 u.hourangle: 'hms'},
280             'latex': {
281                 u.degree: [r'^\circ', r'{}^\prime', r'{}^{\prime\prime}'],
282                 u.hourangle: [r'^{\mathrm{h}}', r'^{\mathrm{m}}', r'^{\mathrm{s}}']},
283             'unicode': {
284                 u.degree: '°′″',
285                 u.hourangle: 'ʰᵐˢ'}
286         }
287         # 'latex_inline' provides no functionality beyond what 'latex' offers,
288         # but it should be implemented to avoid ValueErrors in user code.
289         separators['latex_inline'] = separators['latex']
290 
291         if sep == 'fromunit':
292             if format not in separators:
293                 raise ValueError(f"Unknown format '{format}'")
294             seps = separators[format]
295             if unit in seps:
296                 sep = seps[unit]
297 
298         # Create an iterator so we can format each element of what
299         # might be an array.
300         if unit is u.degree:
301             if decimal:
302                 values = self.degree
303                 if precision is not None:
304                     func = ("{0:0." + str(precision) + "f}").format
305                 else:
306                     func = '{:g}'.format
307             else:
308                 if sep == 'fromunit':
309                     sep = 'dms'
310                 values = self.degree
311                 func = lambda x: form.degrees_to_string(
312                     x, precision=precision, sep=sep, pad=pad,
313                     fields=fields)
314 
315         elif unit is u.hourangle:
316             if decimal:
317                 values = self.hour
318                 if precision is not None:
319                     func = ("{0:0." + str(precision) + "f}").format
320                 else:
321                     func = '{:g}'.format
322             else:
323                 if sep == 'fromunit':
324                     sep = 'hms'
325                 values = self.hour
326                 func = lambda x: form.hours_to_string(
327                     x, precision=precision, sep=sep, pad=pad,
328                     fields=fields)
329 
330         elif unit.is_equivalent(u.radian):
331             if decimal:
332                 values = self.to_value(unit)
333                 if precision is not None:
334                     func = ("{0:1." + str(precision) + "f}").format
335                 else:
336                     func = "{:g}".format
337             elif sep == 'fromunit':
338                 values = self.to_value(unit)
339                 unit_string = unit.to_string(format=format)
340                 if format == 'latex' or format == 'latex_inline':
341                     unit_string = unit_string[1:-1]
342 
343                 if precision is not None:
344                     def plain_unit_format(val):
345                         return ("{0:0." + str(precision) + "f}{1}").format(
346                             val, unit_string)
347                     func = plain_unit_format
348                 else:
349                     def plain_unit_format(val):
350                         return f"{val:g}{unit_string}"
351                     func = plain_unit_format
352             else:
353                 raise ValueError(
354                     f"'{unit.name}' can not be represented in sexagesimal notation")
355 
356         else:
357             raise u.UnitsError(
358                 "The unit value provided is not an angular unit.")
359 
360         def do_format(val):
361             # Check if value is not nan to avoid ValueErrors when turning it into
362             # a hexagesimal string.
363             if not np.isnan(val):
364                 s = func(float(val))
365                 if alwayssign and not s.startswith('-'):
366                     s = '+' + s
367                 if format == 'latex' or format == 'latex_inline':
368                     s = f'${s}$'
369                 return s
370             s = f"{val}"
371             return s
372 
373         format_ufunc = np.vectorize(do_format, otypes=['U'])
374         result = format_ufunc(values)
375 
376         if result.ndim == 0:
377             result = result[()]
378         return result

</code><intended_behavior>The `to_string` method should correctly interpret and convert the unit of an `Angle` object into a string representation, regardless of the object being pickled and unpickled. To resolve the issue, the method must ensure that the unit (whether `hourangle`, `degree`, or any other angular unit) retains its full functionality and identification for sexagesimal notation conversion post-deserialization. This might involve either fixing how units are restored during the unpickling process or adding a verification step within `to_string` to correctly re-interpret or set the unit based on the angle's value if it's found to be compromised after unpickling. This fix should preserve the existing functionality, allowing for both decimal and sexagesimal representations with various formatting options, without introducing regressions for non-pickled `Angle` objects.</intended_behavior>, <file>astropy/coordinates/angles.py</file>
<class>Angle</class>
<method>None</method>
<code>
26 class Angle(u.SpecificTypeQuantity):
27     """
28     One or more angular value(s) with units equivalent to radians or degrees.
29 
30     An angle can be specified either as an array, scalar, tuple (see
31     below), string, `~astropy.units.Quantity` or another
32     :class:`~astropy.coordinates.Angle`.
33 
34     The input parser is flexible and supports a variety of formats.
35     The examples below illustrate common ways of initializing an `Angle`
36     object. First some imports::
37 
38       >>> from astropy.coordinates import Angle
39       >>> from astropy import units as u
40 
41     The angle values can now be provided::
42 
43       >>> Angle('10.2345d')
44       <Angle 10.2345 deg>
45       >>> Angle(['10.2345d', '-20d'])
46       <Angle [ 10.2345, -20.    ] deg>
47       >>> Angle('1:2:30.43 degrees')
48       <Angle 1.04178611 deg>
49       >>> Angle('1 2 0 hours')
50       <Angle 1.03333333 hourangle>
51       >>> Angle(np.arange(1, 8), unit=u.deg)
52       <Angle [1., 2., 3., 4., 5., 6., 7.] deg>
53       >>> Angle('1°2′3″')
54       <Angle 1.03416667 deg>
55       >>> Angle('1°2′3″N')
56       <Angle 1.03416667 deg>
57       >>> Angle('1d2m3.4s')
58       <Angle 1.03427778 deg>
59       >>> Angle('1d2m3.4sS')
60       <Angle -1.03427778 deg>
61       >>> Angle('-1h2m3s')
62       <Angle -1.03416667 hourangle>
63       >>> Angle('-1h2m3sE')
64       <Angle -1.03416667 hourangle>
65       >>> Angle('-1h2.5m')
66       <Angle -1.04166667 hourangle>
67       >>> Angle('-1h2.5mW')
68       <Angle 1.04166667 hourangle>
69       >>> Angle('-1:2.5', unit=u.deg)
70       <Angle -1.04166667 deg>
71       >>> Angle(10.2345 * u.deg)
72       <Angle 10.2345 deg>
73       >>> Angle(Angle(10.2345 * u.deg))
74       <Angle 10.2345 deg>
75 
76     Parameters
77     ----------
78     angle : `~numpy.array`, scalar, `~astropy.units.Quantity`, :class:`~astropy.coordinates.Angle`
79         The angle value. If a tuple, will be interpreted as ``(h, m,
80         s)`` or ``(d, m, s)`` depending on ``unit``. If a string, it
81         will be interpreted following the rules described above.
82 
83         If ``angle`` is a sequence or array of strings, the resulting
84         values will be in the given ``unit``, or if `None` is provided,
85         the unit will be taken from the first given value.
86 
87     unit : unit-like, optional
88         The unit of the value specified for the angle.  This may be
89         any string that `~astropy.units.Unit` understands, but it is
90         better to give an actual unit object.  Must be an angular
91         unit.
92 
93     dtype : `~numpy.dtype`, optional
94         See `~astropy.units.Quantity`.
95 
96     copy : bool, optional
97         See `~astropy.units.Quantity`.
98 
99     Raises
100     ------
101     `~astropy.units.UnitsError`
102         If a unit is not provided or it is not an angular unit.
103     """
104     _equivalent_unit = u.radian
105     _include_easy_conversion_members = True
106 
107     def __new__(cls, angle, unit=None, dtype=np.inexact, copy=True, **kwargs):
108 
109         if not isinstance(angle, u.Quantity):
110             if unit is not None:
111                 unit = cls._convert_unit_to_angle_unit(u.Unit(unit))
112 
113             if isinstance(angle, tuple):
114                 angle = cls._tuple_to_float(angle, unit)
115 
116             elif isinstance(angle, str):
117                 angle, angle_unit = form.parse_angle(angle, unit)
118                 if angle_unit is None:
119                     angle_unit = unit
120 
121                 if isinstance(angle, tuple):
122                     if angle_unit == u.hourangle:
123                         form._check_hour_range(angle[0])
124                     form._check_minute_range(angle[1])
125                     a = np.abs(angle[0]) + angle[1] / 60.
126                     if len(angle) == 3:
127                         form._check_second_range(angle[2])
128                         a += angle[2] / 3600.
129 
130                     angle = np.copysign(a, angle[0])
131 
132                 if angle_unit is not unit:
133                     # Possible conversion to `unit` will be done below.
134                     angle = u.Quantity(angle, angle_unit, copy=False)
135 
136             elif (isiterable(angle) and
137                   not (isinstance(angle, np.ndarray) and
138                        angle.dtype.kind not in 'SUVO')):
139                 angle = [Angle(x, unit, copy=False) for x in angle]
140 
141         return super().__new__(cls, angle, unit, dtype=dtype, copy=copy,
142                                **kwargs)
143 
144     @staticmethod
145     def _tuple_to_float(angle, unit):
146         """
147         Converts an angle represented as a 3-tuple or 2-tuple into a floating
148         point number in the given unit.
149         """
150         # TODO: Numpy array of tuples?
151         if unit == u.hourangle:
152             return form.hms_to_hours(*angle)
153         elif unit == u.degree:
154             return form.dms_to_degrees(*angle)
155         else:
156             raise u.UnitsError(f"Can not parse '{angle}' as unit '{unit}'")
157 
158     @staticmethod
159     def _convert_unit_to_angle_unit(unit):
160         return u.hourangle if unit is u.hour else unit
161 
162     def _set_unit(self, unit):
163         super()._set_unit(self._convert_unit_to_angle_unit(unit))
164 
165     @property
166     def hour(self):
167         """
168         The angle's value in hours (read-only property).
169         """
170         return self.hourangle
171 
172     @property
173     def hms(self):
174         """
175         The angle's value in hours, as a named tuple with ``(h, m, s)``
176         members.  (This is a read-only property.)
177         """
178         return hms_tuple(*form.hours_to_hms(self.hourangle))
179 
180     @property
181     def dms(self):
182         """
183         The angle's value in degrees, as a named tuple with ``(d, m, s)``
184         members.  (This is a read-only property.)
185         """
186         return dms_tuple(*form.degrees_to_dms(self.degree))
187 
188     @property
189     def signed_dms(self):
190         """
191         The angle's value in degrees, as a named tuple with ``(sign, d, m, s)``
192         members.  The ``d``, ``m``, ``s`` are thus always positive, and the sign of
193         the angle is given by ``sign``. (This is a read-only property.)
194 
195         This is primarily intended for use with `dms` to generate string
196         representations of coordinates that are correct for negative angles.
197         """
198         return signed_dms_tuple(np.sign(self.degree),
199                                 *form.degrees_to_dms(np.abs(self.degree)))
200 
201     def to_string(self, unit=None, decimal=False, sep='fromunit',
202                   precision=None, alwayssign=False, pad=False,
203                   fields=3, format=None):
204         """ A string representation of the angle.
205 
206         Parameters
207         ----------
208         unit : `~astropy.units.UnitBase`, optional
209             Specifies the unit.  Must be an angular unit.  If not
210             provided, the unit used to initialize the angle will be
211             used.
212 
213         decimal : bool, optional
214             If `True`, a decimal representation will be used, otherwise
215             the returned string will be in sexagesimal form.
216 
217         sep : str, optional
218             The separator between numbers in a sexagesimal
219             representation.  E.g., if it is ':', the result is
220             ``'12:41:11.1241'``. Also accepts 2 or 3 separators. E.g.,
221             ``sep='hms'`` would give the result ``'12h41m11.1241s'``, or
222             sep='-:' would yield ``'11-21:17.124'``.  Alternatively, the
223             special string 'fromunit' means 'dms' if the unit is
224             degrees, or 'hms' if the unit is hours.
225 
226         precision : int, optional
227             The level of decimal precision.  If ``decimal`` is `True`,
228             this is the raw precision, otherwise it gives the
229             precision of the last place of the sexagesimal
230             representation (seconds).  If `None`, or not provided, the
231             number of decimal places is determined by the value, and
232             will be between 0-8 decimal places as required.
233 
234         alwayssign : bool, optional
235             If `True`, include the sign no matter what.  If `False`,
236             only include the sign if it is negative.
237 
238         pad : bool, optional
239             If `True`, include leading zeros when needed to ensure a
240             fixed number of characters for sexagesimal representation.
241 
242         fields : int, optional
243             Specifies the number of fields to display when outputting
244             sexagesimal notation.  For example:
245 
246                 - fields == 1: ``'5d'``
247                 - fields == 2: ``'5d45m'``
248                 - fields == 3: ``'5d45m32.5s'``
249 
250             By default, all fields are displayed.
251 
252         format : str, optional
253             The format of the result.  If not provided, an unadorned
254             string is returned.  Supported values are:
255 
256             - 'latex': Return a LaTeX-formatted string
257 
258             - 'latex_inline': Return a LaTeX-formatted string which is the
259               same as with ``format='latex'`` for |Angle| instances
260 
261             - 'unicode': Return a string containing non-ASCII unicode
262               characters, such as the degree symbol
263 
264         Returns
265         -------
266         strrepr : str or array
267             A string representation of the angle. If the angle is an array, this
268             will be an array with a unicode dtype.
269 
270         """
271         if unit is None:
272             unit = self.unit
273         else:
274             unit = self._convert_unit_to_angle_unit(u.Unit(unit))
275 
276         separators = {
277             None: {
278                 u.degree: 'dms',
279                 u.hourangle: 'hms'},
280             'latex': {
281                 u.degree: [r'^\circ', r'{}^\prime', r'{}^{\prime\prime}'],
282                 u.hourangle: [r'^{\mathrm{h}}', r'^{\mathrm{m}}', r'^{\mathrm{s}}']},
283             'unicode': {
284                 u.degree: '°′″',
285                 u.hourangle: 'ʰᵐˢ'}
286         }
287         # 'latex_inline' provides no functionality beyond what 'latex' offers,
288         # but it should be implemented to avoid ValueErrors in user code.
289         separators['latex_inline'] = separators['latex']
290 
291         if sep == 'fromunit':
292             if format not in separators:
293                 raise ValueError(f"Unknown format '{format}'")
294             seps = separators[format]
295             if unit in seps:
296                 sep = seps[unit]
297 
298         # Create an iterator so we can format each element of what
299         # might be an array.
300         if unit is u.degree:
301             if decimal:
302                 values = self.degree
303                 if precision is not None:
304                     func = ("{0:0." + str(precision) + "f}").format
305                 else:
306                     func = '{:g}'.format
307             else:
308                 if sep == 'fromunit':
309                     sep = 'dms'
310                 values = self.degree
311                 func = lambda x: form.degrees_to_string(
312                     x, precision=precision, sep=sep, pad=pad,
313                     fields=fields)
314 
315         elif unit is u.hourangle:
316             if decimal:
317                 values = self.hour
318                 if precision is not None:
319                     func = ("{0:0." + str(precision) + "f}").format
320                 else:
321                     func = '{:g}'.format
322             else:
323                 if sep == 'fromunit':
324                     sep = 'hms'
325                 values = self.hour
326                 func = lambda x: form.hours_to_string(
327                     x, precision=precision, sep=sep, pad=pad,
328                     fields=fields)
329 
330         elif unit.is_equivalent(u.radian):
331             if decimal:
332                 values = self.to_value(unit)
333                 if precision is not None:
334                     func = ("{0:1." + str(precision) + "f}").format
335                 else:
336                     func = "{:g}".format
337             elif sep == 'fromunit':
338                 values = self.to_value(unit)
339                 unit_string = unit.to_string(format=format)
340                 if format == 'latex' or format == 'latex_inline':
341                     unit_string = unit_string[1:-1]
342 
343                 if precision is not None:
344                     def plain_unit_format(val):
345                         return ("{0:0." + str(precision) + "f}{1}").format(
346                             val, unit_string)
347                     func = plain_unit_format
348                 else:
349                     def plain_unit_format(val):
350                         return f"{val:g}{unit_string}"
351                     func = plain_unit_format
352             else:
353                 raise ValueError(
354                     f"'{unit.name}' can not be represented in sexagesimal notation")
355 
356         else:
357             raise u.UnitsError(
358                 "The unit value provided is not an angular unit.")
359 
360         def do_format(val):
361             # Check if value is not nan to avoid ValueErrors when turning it into
362             # a hexagesimal string.
363             if not np.isnan(val):
364                 s = func(float(val))
365                 if alwayssign and not s.startswith('-'):
366                     s = '+' + s
367                 if format == 'latex' or format == 'latex_inline':
368                     s = f'${s}$'
369                 return s
370             s = f"{val}"
371             return s
372 
373         format_ufunc = np.vectorize(do_format, otypes=['U'])
374         result = format_ufunc(values)
375 
376         if result.ndim == 0:
377             result = result[()]
378         return result
379 
380     def _wrap_at(self, wrap_angle):
381         """
382         Implementation that assumes ``angle`` is already validated
383         and that wrapping is inplace.
384         """
385         # Convert the wrap angle and 360 degrees to the native unit of
386         # this Angle, then do all the math on raw Numpy arrays rather
387         # than Quantity objects for speed.
388         a360 = u.degree.to(self.unit, 360.0)
389         wrap_angle = wrap_angle.to_value(self.unit)
390         wrap_angle_floor = wrap_angle - a360
391         self_angle = self.view(np.ndarray)
392         # Do the wrapping, but only if any angles need to be wrapped
393         #
394         # Catch any invalid warnings from the floor division.
395         with np.errstate(invalid='ignore'):
396             wraps = (self_angle - wrap_angle_floor) // a360
397         valid = np.isfinite(wraps) & (wraps != 0)
398         if np.any(valid):
399             self_angle -= wraps * a360
400             # Rounding errors can cause problems.
401             self_angle[self_angle >= wrap_angle] -= a360
402             self_angle[self_angle < wrap_angle_floor] += a360
403 
404     def wrap_at(self, wrap_angle, inplace=False):
405         """
406         Wrap the `~astropy.coordinates.Angle` object at the given ``wrap_angle``.
407 
408         This method forces all the angle values to be within a contiguous
409         360 degree range so that ``wrap_angle - 360d <= angle <
410         wrap_angle``. By default a new Angle object is returned, but if the
411         ``inplace`` argument is `True` then the `~astropy.coordinates.Angle`
412         object is wrapped in place and nothing is returned.
413 
414         For instance::
415 
416           >>> from astropy.coordinates import Angle
417           >>> import astropy.units as u
418           >>> a = Angle([-20.0, 150.0, 350.0] * u.deg)
419 
420           >>> a.wrap_at(360 * u.deg).degree  # Wrap into range 0 to 360 degrees  # doctest: +FLOAT_CMP
421           array([340., 150., 350.])
422 
423           >>> a.wrap_at('180d', inplace=True)  # Wrap into range -180 to 180 degrees  # doctest: +FLOAT_CMP
424           >>> a.degree  # doctest: +FLOAT_CMP
425           array([-20., 150., -10.])
426 
427         Parameters
428         ----------
429         wrap_angle : angle-like
430             Specifies a single value for the wrap angle.  This can be any
431             object that can initialize an `~astropy.coordinates.Angle` object,
432             e.g. ``'180d'``, ``180 * u.deg``, or ``Angle(180, unit=u.deg)``.
433 
434         inplace : bool
435             If `True` then wrap the object in place instead of returning
436             a new `~astropy.coordinates.Angle`
437 
438         Returns
439         -------
440         out : Angle or None
441             If ``inplace is False`` (default), return new
442             `~astropy.coordinates.Angle` object with angles wrapped accordingly.
443             Otherwise wrap in place and return `None`.
444         """
445         wrap_angle = Angle(wrap_angle, copy=False)  # Convert to an Angle
446         if not inplace:
447             self = self.copy()
448         self._wrap_at(wrap_angle)
449         return None if inplace else self
450 
451     def is_within_bounds(self, lower=None, upper=None):
452         """
453         Check if all angle(s) satisfy ``lower <= angle < upper``
454 
455         If ``lower`` is not specified (or `None`) then no lower bounds check is
456         performed.  Likewise ``upper`` can be left unspecified.  For example::
457 
458           >>> from astropy.coordinates import Angle
459           >>> import astropy.units as u
460           >>> a = Angle([-20, 150, 350] * u.deg)
461           >>> a.is_within_bounds('0d', '360d')
462           False
463           >>> a.is_within_bounds(None, '360d')
464           True
465           >>> a.is_within_bounds(-30 * u.deg, None)
466           True
467 
468         Parameters
469         ----------
470         lower : angle-like or None
471             Specifies lower bound for checking.  This can be any object
472             that can initialize an `~astropy.coordinates.Angle` object, e.g. ``'180d'``,
473             ``180 * u.deg``, or ``Angle(180, unit=u.deg)``.
474         upper : angle-like or None
475             Specifies upper bound for checking.  This can be any object
476             that can initialize an `~astropy.coordinates.Angle` object, e.g. ``'180d'``,
477             ``180 * u.deg``, or ``Angle(180, unit=u.deg)``.
478 
479         Returns
480         -------
481         is_within_bounds : bool
482             `True` if all angles satisfy ``lower <= angle < upper``
483         """
484         ok = True
485         if lower is not None:
486             ok &= np.all(Angle(lower) <= self)
487         if ok and upper is not None:
488             ok &= np.all(self < Angle(upper))
489         return bool(ok)
490 
491     def _str_helper(self, format=None):
492         if self.isscalar:
493             return self.to_string(format=format)
494 
495         def formatter(x):
496             return x.to_string(format=format)
497 
498         return np.array2string(self, formatter={'all': formatter})
499 
500     def __str__(self):
501         return self._str_helper()
502 
503     def _repr_latex_(self):
504         return self._str_helper(format='latex')

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 22:14:34.828 | INFO     | Search completed. Bug locations: [<file>astropy/coordinates/angles.py</file>
<class>Angle</class>
<method>to_string</method>
<code>
201     def to_string(self, unit=None, decimal=False, sep='fromunit',
202                   precision=None, alwayssign=False, pad=False,
203                   fields=3, format=None):
204         """ A string representation of the angle.
205 
206         Parameters
207         ----------
208         unit : `~astropy.units.UnitBase`, optional
209             Specifies the unit.  Must be an angular unit.  If not
210             provided, the unit used to initialize the angle will be
211             used.
212 
213         decimal : bool, optional
214             If `True`, a decimal representation will be used, otherwise
215             the returned string will be in sexagesimal form.
216 
217         sep : str, optional
218             The separator between numbers in a sexagesimal
219             representation.  E.g., if it is ':', the result is
220             ``'12:41:11.1241'``. Also accepts 2 or 3 separators. E.g.,
221             ``sep='hms'`` would give the result ``'12h41m11.1241s'``, or
222             sep='-:' would yield ``'11-21:17.124'``.  Alternatively, the
223             special string 'fromunit' means 'dms' if the unit is
224             degrees, or 'hms' if the unit is hours.
225 
226         precision : int, optional
227             The level of decimal precision.  If ``decimal`` is `True`,
228             this is the raw precision, otherwise it gives the
229             precision of the last place of the sexagesimal
230             representation (seconds).  If `None`, or not provided, the
231             number of decimal places is determined by the value, and
232             will be between 0-8 decimal places as required.
233 
234         alwayssign : bool, optional
235             If `True`, include the sign no matter what.  If `False`,
236             only include the sign if it is negative.
237 
238         pad : bool, optional
239             If `True`, include leading zeros when needed to ensure a
240             fixed number of characters for sexagesimal representation.
241 
242         fields : int, optional
243             Specifies the number of fields to display when outputting
244             sexagesimal notation.  For example:
245 
246                 - fields == 1: ``'5d'``
247                 - fields == 2: ``'5d45m'``
248                 - fields == 3: ``'5d45m32.5s'``
249 
250             By default, all fields are displayed.
251 
252         format : str, optional
253             The format of the result.  If not provided, an unadorned
254             string is returned.  Supported values are:
255 
256             - 'latex': Return a LaTeX-formatted string
257 
258             - 'latex_inline': Return a LaTeX-formatted string which is the
259               same as with ``format='latex'`` for |Angle| instances
260 
261             - 'unicode': Return a string containing non-ASCII unicode
262               characters, such as the degree symbol
263 
264         Returns
265         -------
266         strrepr : str or array
267             A string representation of the angle. If the angle is an array, this
268             will be an array with a unicode dtype.
269 
270         """
271         if unit is None:
272             unit = self.unit
273         else:
274             unit = self._convert_unit_to_angle_unit(u.Unit(unit))
275 
276         separators = {
277             None: {
278                 u.degree: 'dms',
279                 u.hourangle: 'hms'},
280             'latex': {
281                 u.degree: [r'^\circ', r'{}^\prime', r'{}^{\prime\prime}'],
282                 u.hourangle: [r'^{\mathrm{h}}', r'^{\mathrm{m}}', r'^{\mathrm{s}}']},
283             'unicode': {
284                 u.degree: '°′″',
285                 u.hourangle: 'ʰᵐˢ'}
286         }
287         # 'latex_inline' provides no functionality beyond what 'latex' offers,
288         # but it should be implemented to avoid ValueErrors in user code.
289         separators['latex_inline'] = separators['latex']
290 
291         if sep == 'fromunit':
292             if format not in separators:
293                 raise ValueError(f"Unknown format '{format}'")
294             seps = separators[format]
295             if unit in seps:
296                 sep = seps[unit]
297 
298         # Create an iterator so we can format each element of what
299         # might be an array.
300         if unit is u.degree:
301             if decimal:
302                 values = self.degree
303                 if precision is not None:
304                     func = ("{0:0." + str(precision) + "f}").format
305                 else:
306                     func = '{:g}'.format
307             else:
308                 if sep == 'fromunit':
309                     sep = 'dms'
310                 values = self.degree
311                 func = lambda x: form.degrees_to_string(
312                     x, precision=precision, sep=sep, pad=pad,
313                     fields=fields)
314 
315         elif unit is u.hourangle:
316             if decimal:
317                 values = self.hour
318                 if precision is not None:
319                     func = ("{0:0." + str(precision) + "f}").format
320                 else:
321                     func = '{:g}'.format
322             else:
323                 if sep == 'fromunit':
324                     sep = 'hms'
325                 values = self.hour
326                 func = lambda x: form.hours_to_string(
327                     x, precision=precision, sep=sep, pad=pad,
328                     fields=fields)
329 
330         elif unit.is_equivalent(u.radian):
331             if decimal:
332                 values = self.to_value(unit)
333                 if precision is not None:
334                     func = ("{0:1." + str(precision) + "f}").format
335                 else:
336                     func = "{:g}".format
337             elif sep == 'fromunit':
338                 values = self.to_value(unit)
339                 unit_string = unit.to_string(format=format)
340                 if format == 'latex' or format == 'latex_inline':
341                     unit_string = unit_string[1:-1]
342 
343                 if precision is not None:
344                     def plain_unit_format(val):
345                         return ("{0:0." + str(precision) + "f}{1}").format(
346                             val, unit_string)
347                     func = plain_unit_format
348                 else:
349                     def plain_unit_format(val):
350                         return f"{val:g}{unit_string}"
351                     func = plain_unit_format
352             else:
353                 raise ValueError(
354                     f"'{unit.name}' can not be represented in sexagesimal notation")
355 
356         else:
357             raise u.UnitsError(
358                 "The unit value provided is not an angular unit.")
359 
360         def do_format(val):
361             # Check if value is not nan to avoid ValueErrors when turning it into
362             # a hexagesimal string.
363             if not np.isnan(val):
364                 s = func(float(val))
365                 if alwayssign and not s.startswith('-'):
366                     s = '+' + s
367                 if format == 'latex' or format == 'latex_inline':
368                     s = f'${s}$'
369                 return s
370             s = f"{val}"
371             return s
372 
373         format_ufunc = np.vectorize(do_format, otypes=['U'])
374         result = format_ufunc(values)
375 
376         if result.ndim == 0:
377             result = result[()]
378         return result

</code><intended_behavior>The `to_string` method should correctly interpret and convert the unit of an `Angle` object into a string representation, regardless of the object being pickled and unpickled. To resolve the issue, the method must ensure that the unit (whether `hourangle`, `degree`, or any other angular unit) retains its full functionality and identification for sexagesimal notation conversion post-deserialization. This might involve either fixing how units are restored during the unpickling process or adding a verification step within `to_string` to correctly re-interpret or set the unit based on the angle's value if it's found to be compromised after unpickling. This fix should preserve the existing functionality, allowing for both decimal and sexagesimal representations with various formatting options, without introducing regressions for non-pickled `Angle` objects.</intended_behavior>, <file>astropy/coordinates/angles.py</file>
<class>Angle</class>
<method>None</method>
<code>
26 class Angle(u.SpecificTypeQuantity):
27     """
28     One or more angular value(s) with units equivalent to radians or degrees.
29 
30     An angle can be specified either as an array, scalar, tuple (see
31     below), string, `~astropy.units.Quantity` or another
32     :class:`~astropy.coordinates.Angle`.
33 
34     The input parser is flexible and supports a variety of formats.
35     The examples below illustrate common ways of initializing an `Angle`
36     object. First some imports::
37 
38       >>> from astropy.coordinates import Angle
39       >>> from astropy import units as u
40 
41     The angle values can now be provided::
42 
43       >>> Angle('10.2345d')
44       <Angle 10.2345 deg>
45       >>> Angle(['10.2345d', '-20d'])
46       <Angle [ 10.2345, -20.    ] deg>
47       >>> Angle('1:2:30.43 degrees')
48       <Angle 1.04178611 deg>
49       >>> Angle('1 2 0 hours')
50       <Angle 1.03333333 hourangle>
51       >>> Angle(np.arange(1, 8), unit=u.deg)
52       <Angle [1., 2., 3., 4., 5., 6., 7.] deg>
53       >>> Angle('1°2′3″')
54       <Angle 1.03416667 deg>
55       >>> Angle('1°2′3″N')
56       <Angle 1.03416667 deg>
57       >>> Angle('1d2m3.4s')
58       <Angle 1.03427778 deg>
59       >>> Angle('1d2m3.4sS')
60       <Angle -1.03427778 deg>
61       >>> Angle('-1h2m3s')
62       <Angle -1.03416667 hourangle>
63       >>> Angle('-1h2m3sE')
64       <Angle -1.03416667 hourangle>
65       >>> Angle('-1h2.5m')
66       <Angle -1.04166667 hourangle>
67       >>> Angle('-1h2.5mW')
68       <Angle 1.04166667 hourangle>
69       >>> Angle('-1:2.5', unit=u.deg)
70       <Angle -1.04166667 deg>
71       >>> Angle(10.2345 * u.deg)
72       <Angle 10.2345 deg>
73       >>> Angle(Angle(10.2345 * u.deg))
74       <Angle 10.2345 deg>
75 
76     Parameters
77     ----------
78     angle : `~numpy.array`, scalar, `~astropy.units.Quantity`, :class:`~astropy.coordinates.Angle`
79         The angle value. If a tuple, will be interpreted as ``(h, m,
80         s)`` or ``(d, m, s)`` depending on ``unit``. If a string, it
81         will be interpreted following the rules described above.
82 
83         If ``angle`` is a sequence or array of strings, the resulting
84         values will be in the given ``unit``, or if `None` is provided,
85         the unit will be taken from the first given value.
86 
87     unit : unit-like, optional
88         The unit of the value specified for the angle.  This may be
89         any string that `~astropy.units.Unit` understands, but it is
90         better to give an actual unit object.  Must be an angular
91         unit.
92 
93     dtype : `~numpy.dtype`, optional
94         See `~astropy.units.Quantity`.
95 
96     copy : bool, optional
97         See `~astropy.units.Quantity`.
98 
99     Raises
100     ------
101     `~astropy.units.UnitsError`
102         If a unit is not provided or it is not an angular unit.
103     """
104     _equivalent_unit = u.radian
105     _include_easy_conversion_members = True
106 
107     def __new__(cls, angle, unit=None, dtype=np.inexact, copy=True, **kwargs):
108 
109         if not isinstance(angle, u.Quantity):
110             if unit is not None:
111                 unit = cls._convert_unit_to_angle_unit(u.Unit(unit))
112 
113             if isinstance(angle, tuple):
114                 angle = cls._tuple_to_float(angle, unit)
115 
116             elif isinstance(angle, str):
117                 angle, angle_unit = form.parse_angle(angle, unit)
118                 if angle_unit is None:
119                     angle_unit = unit
120 
121                 if isinstance(angle, tuple):
122                     if angle_unit == u.hourangle:
123                         form._check_hour_range(angle[0])
124                     form._check_minute_range(angle[1])
125                     a = np.abs(angle[0]) + angle[1] / 60.
126                     if len(angle) == 3:
127                         form._check_second_range(angle[2])
128                         a += angle[2] / 3600.
129 
130                     angle = np.copysign(a, angle[0])
131 
132                 if angle_unit is not unit:
133                     # Possible conversion to `unit` will be done below.
134                     angle = u.Quantity(angle, angle_unit, copy=False)
135 
136             elif (isiterable(angle) and
137                   not (isinstance(angle, np.ndarray) and
138                        angle.dtype.kind not in 'SUVO')):
139                 angle = [Angle(x, unit, copy=False) for x in angle]
140 
141         return super().__new__(cls, angle, unit, dtype=dtype, copy=copy,
142                                **kwargs)
143 
144     @staticmethod
145     def _tuple_to_float(angle, unit):
146         """
147         Converts an angle represented as a 3-tuple or 2-tuple into a floating
148         point number in the given unit.
149         """
150         # TODO: Numpy array of tuples?
151         if unit == u.hourangle:
152             return form.hms_to_hours(*angle)
153         elif unit == u.degree:
154             return form.dms_to_degrees(*angle)
155         else:
156             raise u.UnitsError(f"Can not parse '{angle}' as unit '{unit}'")
157 
158     @staticmethod
159     def _convert_unit_to_angle_unit(unit):
160         return u.hourangle if unit is u.hour else unit
161 
162     def _set_unit(self, unit):
163         super()._set_unit(self._convert_unit_to_angle_unit(unit))
164 
165     @property
166     def hour(self):
167         """
168         The angle's value in hours (read-only property).
169         """
170         return self.hourangle
171 
172     @property
173     def hms(self):
174         """
175         The angle's value in hours, as a named tuple with ``(h, m, s)``
176         members.  (This is a read-only property.)
177         """
178         return hms_tuple(*form.hours_to_hms(self.hourangle))
179 
180     @property
181     def dms(self):
182         """
183         The angle's value in degrees, as a named tuple with ``(d, m, s)``
184         members.  (This is a read-only property.)
185         """
186         return dms_tuple(*form.degrees_to_dms(self.degree))
187 
188     @property
189     def signed_dms(self):
190         """
191         The angle's value in degrees, as a named tuple with ``(sign, d, m, s)``
192         members.  The ``d``, ``m``, ``s`` are thus always positive, and the sign of
193         the angle is given by ``sign``. (This is a read-only property.)
194 
195         This is primarily intended for use with `dms` to generate string
196         representations of coordinates that are correct for negative angles.
197         """
198         return signed_dms_tuple(np.sign(self.degree),
199                                 *form.degrees_to_dms(np.abs(self.degree)))
200 
201     def to_string(self, unit=None, decimal=False, sep='fromunit',
202                   precision=None, alwayssign=False, pad=False,
203                   fields=3, format=None):
204         """ A string representation of the angle.
205 
206         Parameters
207         ----------
208         unit : `~astropy.units.UnitBase`, optional
209             Specifies the unit.  Must be an angular unit.  If not
210             provided, the unit used to initialize the angle will be
211             used.
212 
213         decimal : bool, optional
214             If `True`, a decimal representation will be used, otherwise
215             the returned string will be in sexagesimal form.
216 
217         sep : str, optional
218             The separator between numbers in a sexagesimal
219             representation.  E.g., if it is ':', the result is
220             ``'12:41:11.1241'``. Also accepts 2 or 3 separators. E.g.,
221             ``sep='hms'`` would give the result ``'12h41m11.1241s'``, or
222             sep='-:' would yield ``'11-21:17.124'``.  Alternatively, the
223             special string 'fromunit' means 'dms' if the unit is
224             degrees, or 'hms' if the unit is hours.
225 
226         precision : int, optional
227             The level of decimal precision.  If ``decimal`` is `True`,
228             this is the raw precision, otherwise it gives the
229             precision of the last place of the sexagesimal
230             representation (seconds).  If `None`, or not provided, the
231             number of decimal places is determined by the value, and
232             will be between 0-8 decimal places as required.
233 
234         alwayssign : bool, optional
235             If `True`, include the sign no matter what.  If `False`,
236             only include the sign if it is negative.
237 
238         pad : bool, optional
239             If `True`, include leading zeros when needed to ensure a
240             fixed number of characters for sexagesimal representation.
241 
242         fields : int, optional
243             Specifies the number of fields to display when outputting
244             sexagesimal notation.  For example:
245 
246                 - fields == 1: ``'5d'``
247                 - fields == 2: ``'5d45m'``
248                 - fields == 3: ``'5d45m32.5s'``
249 
250             By default, all fields are displayed.
251 
252         format : str, optional
253             The format of the result.  If not provided, an unadorned
254             string is returned.  Supported values are:
255 
256             - 'latex': Return a LaTeX-formatted string
257 
258             - 'latex_inline': Return a LaTeX-formatted string which is the
259               same as with ``format='latex'`` for |Angle| instances
260 
261             - 'unicode': Return a string containing non-ASCII unicode
262               characters, such as the degree symbol
263 
264         Returns
265         -------
266         strrepr : str or array
267             A string representation of the angle. If the angle is an array, this
268             will be an array with a unicode dtype.
269 
270         """
271         if unit is None:
272             unit = self.unit
273         else:
274             unit = self._convert_unit_to_angle_unit(u.Unit(unit))
275 
276         separators = {
277             None: {
278                 u.degree: 'dms',
279                 u.hourangle: 'hms'},
280             'latex': {
281                 u.degree: [r'^\circ', r'{}^\prime', r'{}^{\prime\prime}'],
282                 u.hourangle: [r'^{\mathrm{h}}', r'^{\mathrm{m}}', r'^{\mathrm{s}}']},
283             'unicode': {
284                 u.degree: '°′″',
285                 u.hourangle: 'ʰᵐˢ'}
286         }
287         # 'latex_inline' provides no functionality beyond what 'latex' offers,
288         # but it should be implemented to avoid ValueErrors in user code.
289         separators['latex_inline'] = separators['latex']
290 
291         if sep == 'fromunit':
292             if format not in separators:
293                 raise ValueError(f"Unknown format '{format}'")
294             seps = separators[format]
295             if unit in seps:
296                 sep = seps[unit]
297 
298         # Create an iterator so we can format each element of what
299         # might be an array.
300         if unit is u.degree:
301             if decimal:
302                 values = self.degree
303                 if precision is not None:
304                     func = ("{0:0." + str(precision) + "f}").format
305                 else:
306                     func = '{:g}'.format
307             else:
308                 if sep == 'fromunit':
309                     sep = 'dms'
310                 values = self.degree
311                 func = lambda x: form.degrees_to_string(
312                     x, precision=precision, sep=sep, pad=pad,
313                     fields=fields)
314 
315         elif unit is u.hourangle:
316             if decimal:
317                 values = self.hour
318                 if precision is not None:
319                     func = ("{0:0." + str(precision) + "f}").format
320                 else:
321                     func = '{:g}'.format
322             else:
323                 if sep == 'fromunit':
324                     sep = 'hms'
325                 values = self.hour
326                 func = lambda x: form.hours_to_string(
327                     x, precision=precision, sep=sep, pad=pad,
328                     fields=fields)
329 
330         elif unit.is_equivalent(u.radian):
331             if decimal:
332                 values = self.to_value(unit)
333                 if precision is not None:
334                     func = ("{0:1." + str(precision) + "f}").format
335                 else:
336                     func = "{:g}".format
337             elif sep == 'fromunit':
338                 values = self.to_value(unit)
339                 unit_string = unit.to_string(format=format)
340                 if format == 'latex' or format == 'latex_inline':
341                     unit_string = unit_string[1:-1]
342 
343                 if precision is not None:
344                     def plain_unit_format(val):
345                         return ("{0:0." + str(precision) + "f}{1}").format(
346                             val, unit_string)
347                     func = plain_unit_format
348                 else:
349                     def plain_unit_format(val):
350                         return f"{val:g}{unit_string}"
351                     func = plain_unit_format
352             else:
353                 raise ValueError(
354                     f"'{unit.name}' can not be represented in sexagesimal notation")
355 
356         else:
357             raise u.UnitsError(
358                 "The unit value provided is not an angular unit.")
359 
360         def do_format(val):
361             # Check if value is not nan to avoid ValueErrors when turning it into
362             # a hexagesimal string.
363             if not np.isnan(val):
364                 s = func(float(val))
365                 if alwayssign and not s.startswith('-'):
366                     s = '+' + s
367                 if format == 'latex' or format == 'latex_inline':
368                     s = f'${s}$'
369                 return s
370             s = f"{val}"
371             return s
372 
373         format_ufunc = np.vectorize(do_format, otypes=['U'])
374         result = format_ufunc(values)
375 
376         if result.ndim == 0:
377             result = result[()]
378         return result
379 
380     def _wrap_at(self, wrap_angle):
381         """
382         Implementation that assumes ``angle`` is already validated
383         and that wrapping is inplace.
384         """
385         # Convert the wrap angle and 360 degrees to the native unit of
386         # this Angle, then do all the math on raw Numpy arrays rather
387         # than Quantity objects for speed.
388         a360 = u.degree.to(self.unit, 360.0)
389         wrap_angle = wrap_angle.to_value(self.unit)
390         wrap_angle_floor = wrap_angle - a360
391         self_angle = self.view(np.ndarray)
392         # Do the wrapping, but only if any angles need to be wrapped
393         #
394         # Catch any invalid warnings from the floor division.
395         with np.errstate(invalid='ignore'):
396             wraps = (self_angle - wrap_angle_floor) // a360
397         valid = np.isfinite(wraps) & (wraps != 0)
398         if np.any(valid):
399             self_angle -= wraps * a360
400             # Rounding errors can cause problems.
401             self_angle[self_angle >= wrap_angle] -= a360
402             self_angle[self_angle < wrap_angle_floor] += a360
403 
404     def wrap_at(self, wrap_angle, inplace=False):
405         """
406         Wrap the `~astropy.coordinates.Angle` object at the given ``wrap_angle``.
407 
408         This method forces all the angle values to be within a contiguous
409         360 degree range so that ``wrap_angle - 360d <= angle <
410         wrap_angle``. By default a new Angle object is returned, but if the
411         ``inplace`` argument is `True` then the `~astropy.coordinates.Angle`
412         object is wrapped in place and nothing is returned.
413 
414         For instance::
415 
416           >>> from astropy.coordinates import Angle
417           >>> import astropy.units as u
418           >>> a = Angle([-20.0, 150.0, 350.0] * u.deg)
419 
420           >>> a.wrap_at(360 * u.deg).degree  # Wrap into range 0 to 360 degrees  # doctest: +FLOAT_CMP
421           array([340., 150., 350.])
422 
423           >>> a.wrap_at('180d', inplace=True)  # Wrap into range -180 to 180 degrees  # doctest: +FLOAT_CMP
424           >>> a.degree  # doctest: +FLOAT_CMP
425           array([-20., 150., -10.])
426 
427         Parameters
428         ----------
429         wrap_angle : angle-like
430             Specifies a single value for the wrap angle.  This can be any
431             object that can initialize an `~astropy.coordinates.Angle` object,
432             e.g. ``'180d'``, ``180 * u.deg``, or ``Angle(180, unit=u.deg)``.
433 
434         inplace : bool
435             If `True` then wrap the object in place instead of returning
436             a new `~astropy.coordinates.Angle`
437 
438         Returns
439         -------
440         out : Angle or None
441             If ``inplace is False`` (default), return new
442             `~astropy.coordinates.Angle` object with angles wrapped accordingly.
443             Otherwise wrap in place and return `None`.
444         """
445         wrap_angle = Angle(wrap_angle, copy=False)  # Convert to an Angle
446         if not inplace:
447             self = self.copy()
448         self._wrap_at(wrap_angle)
449         return None if inplace else self
450 
451     def is_within_bounds(self, lower=None, upper=None):
452         """
453         Check if all angle(s) satisfy ``lower <= angle < upper``
454 
455         If ``lower`` is not specified (or `None`) then no lower bounds check is
456         performed.  Likewise ``upper`` can be left unspecified.  For example::
457 
458           >>> from astropy.coordinates import Angle
459           >>> import astropy.units as u
460           >>> a = Angle([-20, 150, 350] * u.deg)
461           >>> a.is_within_bounds('0d', '360d')
462           False
463           >>> a.is_within_bounds(None, '360d')
464           True
465           >>> a.is_within_bounds(-30 * u.deg, None)
466           True
467 
468         Parameters
469         ----------
470         lower : angle-like or None
471             Specifies lower bound for checking.  This can be any object
472             that can initialize an `~astropy.coordinates.Angle` object, e.g. ``'180d'``,
473             ``180 * u.deg``, or ``Angle(180, unit=u.deg)``.
474         upper : angle-like or None
475             Specifies upper bound for checking.  This can be any object
476             that can initialize an `~astropy.coordinates.Angle` object, e.g. ``'180d'``,
477             ``180 * u.deg``, or ``Angle(180, unit=u.deg)``.
478 
479         Returns
480         -------
481         is_within_bounds : bool
482             `True` if all angles satisfy ``lower <= angle < upper``
483         """
484         ok = True
485         if lower is not None:
486             ok &= np.all(Angle(lower) <= self)
487         if ok and upper is not None:
488             ok &= np.all(self < Angle(upper))
489         return bool(ok)
490 
491     def _str_helper(self, format=None):
492         if self.isscalar:
493             return self.to_string(format=format)
494 
495         def formatter(x):
496             return x.to_string(format=format)
497 
498         return np.array2string(self, formatter={'all': formatter})
499 
500     def __str__(self):
501         return self._str_helper()
502 
503     def _repr_latex_(self):
504         return self._str_helper(format='latex')

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 22:14:34.829 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 22:14:34.829 | INFO     | Search-only: skipping patch selection
2025-10-17 22:14:34.902 | INFO     | Task astropy__astropy-13933 completed successfully.
2025-10-17 22:14:34.903 | INFO     | No patch generated. You can try running ACR again.
