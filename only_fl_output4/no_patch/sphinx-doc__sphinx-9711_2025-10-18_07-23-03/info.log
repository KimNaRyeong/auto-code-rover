2025-10-18 07:23:03.353 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 07:23:06.557 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=479, output_tokens=12, cost=0.005150
2025-10-18 07:23:23.105 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=659, output_tokens=793, cost=0.030380
2025-10-18 07:23:24.399 | INFO     | registered non reproducing test 0
2025-10-18 07:23:35.261 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1951, output_tokens=520, cost=0.035110
2025-10-18 07:23:36.239 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:23:42.555 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=788, output_tokens=286, cost=0.016460
2025-10-18 07:23:42.561 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:23:44.387 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=640, output_tokens=46, cost=0.007780
2025-10-18 07:23:44.389 | DEBUG    | Extracted a valid json.
2025-10-18 07:23:44.394 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"needs_extensions\")",
        "search_code(\"sphinx_gallery.gen_gallery\")",
        "search_method(\"compare_versions\")"
    ],
    "bug_locations": []
}
2025-10-18 07:23:44.409 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 07:23:44.410 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 07:23:53.074 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1251, output_tokens=407, cost=0.024720
2025-10-18 07:23:53.084 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:23:56.522 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1874, output_tokens=134, cost=0.022760
2025-10-18 07:23:56.526 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:23:59.586 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 07:23:59.587 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 07:23:59.587 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 07:24:02.437 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 07:24:02.438 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 07:24:02.438 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 07:24:05.841 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 07:24:05.842 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 07:24:05.842 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 07:24:07.263 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 07:24:07.264 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 07:24:07.264 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 07:24:08.418 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 07:24:08.419 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 07:24:08.419 | DEBUG    | Agent proxy return the following json: None
2025-10-18 07:24:08.420 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 07:24:08.421 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 07:24:08.421 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:24:20.370 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2035, output_tokens=457, cost=0.034060
2025-10-18 07:24:20.378 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:24:23.520 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=811, output_tokens=68, cost=0.010150
2025-10-18 07:24:23.521 | DEBUG    | Extracted a valid json.
2025-10-18 07:24:23.521 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"setup_extension\")",
        "search_code(\"add_extension\")",
        "search_code(\"requirements\")",
        "search_code(\"dependency\")",
        "search_code(\"parse_version\")",
        "search_code(\"version_compare\")"
    ],
    "bug_locations": []
}
2025-10-18 07:24:23.606 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 07:24:23.606 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 07:24:40.412 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3600, output_tokens=587, cost=0.053610
2025-10-18 07:24:40.422 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:24:51.673 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4403, output_tokens=476, cost=0.058310
2025-10-18 07:24:51.682 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:24:55.885 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=830, output_tokens=70, cost=0.010400
2025-10-18 07:24:55.887 | INFO     | Refactored invocation argument parsing failed on 'get_code_around_line("sphinx/application.py", line_number, 10)': malformed node or string on line 1: <ast.Name object at 0x73f5a37edc90>
2025-10-18 07:24:55.888 | DEBUG    | Extracted a valid json.
2025-10-18 07:24:55.888 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "get_code_around_line(\"sphinx/application.py\", line_number, 10)",
        "search_code_in_file(\"version\", \"sphinx/application.py\")",
        "search_code_in_file(\">=0.\", \"sphinx/application.py\")"
    ],
    "bug_locations": []
}
2025-10-18 07:24:55.890 | INFO     | Refactored invocation argument parsing failed on 'get_code_around_line("sphinx/application.py", line_number, 10)': malformed node or string on line 1: <ast.Name object at 0x73f5a3896010>
2025-10-18 07:24:55.891 | ERROR    | invalid literal for int() with base 10: 'line_number'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x73f694322c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x73f5a1d2b260>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x73f5a404e3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x73f5a1d2b260>, <app.raw_tasks.RawSweTask object at 0x73f5a1d2b290>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x73f5a404e480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x73f5a1c706e0>
    └ <function run_task_in_subprocess at 0x73f5a404e660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x73f5a1c706e0>
    │        │      └ <function run_raw_task at 0x73f5a404e700>
    │        └ <function ProcessPoolExecutor.submit at 0x73f693c4a020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x73f5a42be0c0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x73f693c49da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x73f5a42be0c0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x73f693c49ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x73f5a42be0c0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x73f693c49f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x73f5a42be0c0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x73f693e10ea0>
    └ <ForkProcess name='ForkProcess-408' parent=401374 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-408' parent=401374 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x73f693e820c0>)>
    │    │        └ <ForkProcess name='ForkProcess-408' parent=401374 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-408' parent=401374 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-408' parent=401374 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-408' parent=401374 started>
    │    └ <function Popen._launch at 0x73f5a204f7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x73f5a3321eb0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x73f693e118a0>
           └ <ForkProcess name='ForkProcess-408' parent=401374 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x73f693e10e00>
    └ <ForkProcess name='ForkProcess-408' parent=401374 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-408' parent=401374 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x73f5a424e8d0>, <multiprocessing.queues.SimpleQueue object at 0x73f5a254f2...
    │    │        └ <ForkProcess name='ForkProcess-408' parent=401374 started>
    │    └ <function _process_worker at 0x73f693c491c0>
    └ <ForkProcess name='ForkProcess-408' parent=401374 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x73f5a254f950>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x73f5a33217f0>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x73f5a254f950>
        │         └ <function run_raw_task at 0x73f5a404e700>
        └ <concurrent.futures.process._CallItem object at 0x73f5a254f950>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output4/sphinx-doc__sphinx-9711_2025-10-18_07-23-03'
             │            │    └ <function RawSweTask.to_task at 0x73f5a404d6c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x73f5a33217f0>
             └ <function do_inference at 0x73f5a404e8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x73f5a42c8400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x73f5a48f04a0>
       │                 │         │            └ SweTask(task_id='sphinx-doc__sphinx-9711', problem_statement='needs_extensions checks versions using strings\n### Describe th...
       │                 │         └ <app.manage.ProjectApiManager object at 0x73f5a2c629f0>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output4/sphinx-doc__sphinx-9711_2025-10-18_07-23-03/output_0')
       └ <function _run_one_task at 0x73f5a42c98a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x73f5a436dbc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x73f5a2c62300>
                                  └ <app.manage.ProjectApiManager object at 0x73f5a2c629f0>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 178, in search_iterative
    result_str, _, call_ok = function(**kwargs)
    │           │            │          └ {'file_name': 'sphinx/application.py', 'line_no_str': 'line_number', 'window_size_str': '10'}
    │           │            └ <bound method SearchBackend.get_code_around_line of <app.search.search_backend.SearchBackend object at 0x73f5a4201580>>
    │           └ []
    └ 'Could not find code version_compare in the codebase.'

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {'file_name': 'sphinx/application.py', 'line_no_str': 'line_number', 'window_size_str': '10'}
           │     └ (<app.search.search_backend.SearchBackend object at 0x73f5a4201580>,)
           └ <function SearchBackend.get_code_around_line at 0x73f5a436d4e0>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 600, in get_code_around_line
    line_no = int(line_no_str)
                  └ 'line_number'

ValueError: invalid literal for int() with base 10: 'line_number'
2025-10-18 07:24:55.923 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 07:24:55.924 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 07:25:11.047 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5876, output_tokens=565, cost=0.075710
2025-10-18 07:25:11.061 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:25:23.928 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6657, output_tokens=474, cost=0.080790
2025-10-18 07:25:23.937 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:25:27.429 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=828, output_tokens=106, cost=0.011460
2025-10-18 07:25:27.430 | DEBUG    | Extracted a valid json.
2025-10-18 07:25:27.430 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/application.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code responsible for comparing extension versions should accurately perform semantic version comparison, ensuring proper interpretation of version numbers. Modifications should include parsing version strings into numerically comparable parts or utilizing libraries designed for semantic version comparison, such as Python's pkg_resources.parse_version or the packaging library, without compromising existing functionality."
        }
    ]
}
2025-10-18 07:25:27.435 | DEBUG    | Bug location extracted successfully: [<file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import IO, TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Type, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers import Parser
26 from docutils.parsers.rst import Directive, roles
27 from docutils.transforms import Transform
28 from pygments.lexer import Lexer
29 
30 import sphinx
31 from sphinx import locale, package_dir
32 from sphinx.config import Config
33 from sphinx.deprecation import RemovedInSphinx60Warning
34 from sphinx.domains import Domain, Index
35 from sphinx.environment import BuildEnvironment
36 from sphinx.environment.collectors import EnvironmentCollector
37 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
38 from sphinx.events import EventManager
39 from sphinx.extension import Extension
40 from sphinx.highlighting import lexer_classes
41 from sphinx.locale import __
42 from sphinx.project import Project
43 from sphinx.registry import SphinxComponentRegistry
44 from sphinx.roles import XRefRole
45 from sphinx.theming import Theme
46 from sphinx.util import docutils, logging, progress_message
47 from sphinx.util.build_phase import BuildPhase
48 from sphinx.util.console import bold  # type: ignore
49 from sphinx.util.i18n import CatalogRepository
50 from sphinx.util.logging import prefixed_warnings
51 from sphinx.util.osutil import abspath, ensuredir, relpath
52 from sphinx.util.tags import Tags
53 from sphinx.util.typing import RoleFunction, TitleGetter
54 
55 if TYPE_CHECKING:
56     from docutils.nodes import Node  # NOQA
57 
58     from sphinx.builders import Builder
59 
60 
61 builtin_extensions = (
62     'sphinx.addnodes',
63     'sphinx.builders.changes',
64     'sphinx.builders.epub3',
65     'sphinx.builders.dirhtml',
66     'sphinx.builders.dummy',
67     'sphinx.builders.gettext',
68     'sphinx.builders.html',
69     'sphinx.builders.latex',
70     'sphinx.builders.linkcheck',
71     'sphinx.builders.manpage',
72     'sphinx.builders.singlehtml',
73     'sphinx.builders.texinfo',
74     'sphinx.builders.text',
75     'sphinx.builders.xml',
76     'sphinx.config',
77     'sphinx.domains.c',
78     'sphinx.domains.changeset',
79     'sphinx.domains.citation',
80     'sphinx.domains.cpp',
81     'sphinx.domains.index',
82     'sphinx.domains.javascript',
83     'sphinx.domains.math',
84     'sphinx.domains.python',
85     'sphinx.domains.rst',
86     'sphinx.domains.std',
87     'sphinx.directives',
88     'sphinx.directives.code',
89     'sphinx.directives.other',
90     'sphinx.directives.patches',
91     'sphinx.extension',
92     'sphinx.parsers',
93     'sphinx.registry',
94     'sphinx.roles',
95     'sphinx.transforms',
96     'sphinx.transforms.compact_bullet_list',
97     'sphinx.transforms.i18n',
98     'sphinx.transforms.references',
99     'sphinx.transforms.post_transforms',
100     'sphinx.transforms.post_transforms.code',
101     'sphinx.transforms.post_transforms.images',
102     'sphinx.util.compat',
103     'sphinx.versioning',
104     # collectors should be loaded by specific order
105     'sphinx.environment.collectors.dependencies',
106     'sphinx.environment.collectors.asset',
107     'sphinx.environment.collectors.metadata',
108     'sphinx.environment.collectors.title',
109     'sphinx.environment.collectors.toctree',
110     # 1st party extensions
111     'sphinxcontrib.applehelp',
112     'sphinxcontrib.devhelp',
113     'sphinxcontrib.htmlhelp',
114     'sphinxcontrib.serializinghtml',
115     'sphinxcontrib.qthelp',
116     # Strictly, alabaster theme is not a builtin extension,
117     # but it is loaded automatically to use it as default theme.
118     'alabaster',
119 )
120 
121 ENV_PICKLE_FILENAME = 'environment.pickle'
122 
123 logger = logging.getLogger(__name__)
124 
125 
126 class Sphinx:
127     """The main application class and extensibility interface.
128 
129     :ivar srcdir: Directory containing source.
130     :ivar confdir: Directory containing ``conf.py``.
131     :ivar doctreedir: Directory for storing pickled doctrees.
132     :ivar outdir: Directory for storing build documents.
133     """
134 
135     warningiserror: bool
136     _warncount: int
137 
138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,
139                  buildername: str, confoverrides: Dict = None,
140                  status: IO = sys.stdout, warning: IO = sys.stderr,
141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
143         self.phase = BuildPhase.INITIALIZATION
144         self.verbosity = verbosity
145         self.extensions: Dict[str, Extension] = {}
146         self.builder: Optional[Builder] = None
147         self.env: Optional[BuildEnvironment] = None
148         self.project: Optional[Project] = None
149         self.registry = SphinxComponentRegistry()
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155 
156         if not path.isdir(self.srcdir):
157             raise ApplicationError(__('Cannot find source directory (%s)') %
158                                    self.srcdir)
159 
160         if path.exists(self.outdir) and not path.isdir(self.outdir):
161             raise ApplicationError(__('Output directory (%s) is not a directory') %
162                                    self.outdir)
163 
164         if self.srcdir == self.outdir:
165             raise ApplicationError(__('Source directory and destination '
166                                       'directory cannot be identical'))
167 
168         self.parallel = parallel
169 
170         if status is None:
171             self._status: IO = StringIO()
172             self.quiet: bool = True
173         else:
174             self._status = status
175             self.quiet = False
176 
177         if warning is None:
178             self._warning: IO = StringIO()
179         else:
180             self._warning = warning
181         self._warncount = 0
182         self.keep_going = warningiserror and keep_going
183         if self.keep_going:
184             self.warningiserror = False
185         else:
186             self.warningiserror = warningiserror
187         logging.setup(self, self._status, self._warning)
188 
189         self.events = EventManager(self)
190 
191         # keep last few messages for traceback
192         # This will be filled by sphinx.util.logging.LastMessagesWriter
193         self.messagelog: deque = deque(maxlen=10)
194 
195         # say hello to the world
196         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
197 
198         # notice for parallel build on macOS and py38+
199         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
200             logger.info(bold(__("For security reasons, parallel mode is disabled on macOS and "
201                                 "python3.8 and above. For more details, please read "
202                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
203 
204         # status code for command-line application
205         self.statuscode = 0
206 
207         # read config
208         self.tags = Tags(tags)
209         if confdir is None:
210             # set confdir to srcdir if -C given (!= no confdir); a few pieces
211             # of code expect a confdir to be set
212             self.confdir = self.srcdir
213             self.config = Config({}, confoverrides or {})
214         else:
215             self.confdir = abspath(confdir)
216             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
217 
218         # initialize some limited config variables before initialize i18n and loading
219         # extensions
220         self.config.pre_init_values()
221 
222         # set up translation infrastructure
223         self._init_i18n()
224 
225         # check the Sphinx version if requested
226         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
227             raise VersionRequirementError(
228                 __('This project needs at least Sphinx v%s and therefore cannot '
229                    'be built with this version.') % self.config.needs_sphinx)
230 
231         # load all built-in extension modules
232         for extension in builtin_extensions:
233             self.setup_extension(extension)
234 
235         # load all user-given extension modules
236         for extension in self.config.extensions:
237             self.setup_extension(extension)
238 
239         # preload builder module (before init config values)
240         self.preload_builder(buildername)
241 
242         if not path.isdir(outdir):
243             with progress_message(__('making output directory')):
244                 ensuredir(outdir)
245 
246         # the config file itself can be an extension
247         if self.config.setup:
248             prefix = __('while setting up extension %s:') % "conf.py"
249             with prefixed_warnings(prefix):
250                 if callable(self.config.setup):
251                     self.config.setup(self)
252                 else:
253                     raise ConfigError(
254                         __("'setup' as currently defined in conf.py isn't a Python callable. "
255                            "Please modify its definition to make it a callable function. "
256                            "This is needed for conf.py to behave as a Sphinx extension.")
257                     )
258 
259         # now that we know all config values, collect them from conf.py
260         self.config.init_values()
261         self.events.emit('config-inited', self.config)
262 
263         # create the project
264         self.project = Project(self.srcdir, self.config.source_suffix)
265         # create the builder
266         self.builder = self.create_builder(buildername)
267         # set up the build environment
268         self._init_env(freshenv)
269         # set up the builder
270         self._init_builder()
271 
272     def _init_i18n(self) -> None:
273         """Load translated strings from the configured localedirs if enabled in
274         the configuration.
275         """
276         if self.config.language is None:
277             self.translator, has_translation = locale.init([], None)
278         else:
279             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
280                         nonl=True)
281 
282             # compile mo files if sphinx.po file in user locale directories are updated
283             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
284                                      self.config.language, self.config.source_encoding)
285             for catalog in repo.catalogs:
286                 if catalog.domain == 'sphinx' and catalog.is_outdated():
287                     catalog.write_mo(self.config.language)
288 
289             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)
290             locale_dirs += [None]
291             locale_dirs += [path.join(package_dir, 'locale')]
292 
293             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
294             if has_translation or self.config.language == 'en':
295                 # "en" never needs to be translated
296                 logger.info(__('done'))
297             else:
298                 logger.info(__('not available for built-in messages'))
299 
300     def _init_env(self, freshenv: bool) -> None:
301         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
302         if freshenv or not os.path.exists(filename):
303             self.env = BuildEnvironment(self)
304             self.env.find_files(self.config, self.builder)
305         else:
306             try:
307                 with progress_message(__('loading pickled environment')):
308                     with open(filename, 'rb') as f:
309                         self.env = pickle.load(f)
310                         self.env.setup(self)
311             except Exception as err:
312                 logger.info(__('failed: %s'), err)
313                 self._init_env(freshenv=True)
314 
315     def preload_builder(self, name: str) -> None:
316         self.registry.preload_builder(self, name)
317 
318     def create_builder(self, name: str) -> "Builder":
319         if name is None:
320             logger.info(__('No builder selected, using default: html'))
321             name = 'html'
322 
323         return self.registry.create_builder(self, name)
324 
325     def _init_builder(self) -> None:
326         self.builder.set_environment(self.env)
327         self.builder.init()
328         self.events.emit('builder-inited')
329 
330     # ---- main "build" method -------------------------------------------------
331 
332     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
333         self.phase = BuildPhase.READING
334         try:
335             if force_all:
336                 self.builder.compile_all_catalogs()
337                 self.builder.build_all()
338             elif filenames:
339                 self.builder.compile_specific_catalogs(filenames)
340                 self.builder.build_specific(filenames)
341             else:
342                 self.builder.compile_update_catalogs()
343                 self.builder.build_update()
344 
345             if self._warncount and self.keep_going:
346                 self.statuscode = 1
347 
348             status = (__('succeeded') if self.statuscode == 0
349                       else __('finished with problems'))
350             if self._warncount:
351                 if self.warningiserror:
352                     if self._warncount == 1:
353                         msg = __('build %s, %s warning (with warnings treated as errors).')
354                     else:
355                         msg = __('build %s, %s warnings (with warnings treated as errors).')
356                 else:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning.')
359                     else:
360                         msg = __('build %s, %s warnings.')
361 
362                 logger.info(bold(msg % (status, self._warncount)))
363             else:
364                 logger.info(bold(__('build %s.') % status))
365 
366             if self.statuscode == 0 and self.builder.epilog:
367                 logger.info('')
368                 logger.info(self.builder.epilog % {
369                     'outdir': relpath(self.outdir),
370                     'project': self.config.project
371                 })
372         except Exception as err:
373             # delete the saved env to force a fresh build next time
374             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
375             if path.isfile(envfile):
376                 os.unlink(envfile)
377             self.events.emit('build-finished', err)
378             raise
379         else:
380             self.events.emit('build-finished', None)
381         self.builder.cleanup()
382 
383     # ---- general extensibility interface -------------------------------------
384 
385     def setup_extension(self, extname: str) -> None:
386         """Import and setup a Sphinx extension module.
387 
388         Load the extension given by the module *name*.  Use this if your
389         extension needs the features provided by another extension.  No-op if
390         called twice.
391         """
392         logger.debug('[app] setting up extension: %r', extname)
393         self.registry.load_extension(self, extname)
394 
395     def require_sphinx(self, version: str) -> None:
396         """Check the Sphinx version if requested.
397 
398         Compare *version* with the version of the running Sphinx, and abort the
399         build when it is too old.
400 
401         :param version: The required version in the form of ``major.minor``.
402 
403         .. versionadded:: 1.0
404         """
405         if version > sphinx.__display_version__[:3]:
406             raise VersionRequirementError(version)
407 
408     # event interface
409     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
410         """Register *callback* to be called when *event* is emitted.
411 
412         For details on available core events and the arguments of callback
413         functions, please see :ref:`events`.
414 
415         :param event: The name of target event
416         :param callback: Callback function for the event
417         :param priority: The priority of the callback.  The callbacks will be invoked
418                          in order of *priority* (ascending).
419         :return: A listener ID.  It can be used for :meth:`disconnect`.
420 
421         .. versionchanged:: 3.0
422 
423            Support *priority*
424         """
425         listener_id = self.events.connect(event, callback, priority)
426         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
427                      event, priority, callback, listener_id)
428         return listener_id
429 
430     def disconnect(self, listener_id: int) -> None:
431         """Unregister callback by *listener_id*.
432 
433         :param listener_id: A listener_id that :meth:`connect` returns
434         """
435         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
436         self.events.disconnect(listener_id)
437 
438     def emit(self, event: str, *args: Any,
439              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:
440         """Emit *event* and pass *arguments* to the callback functions.
441 
442         Return the return values of all callbacks as a list.  Do not emit core
443         Sphinx events in extensions!
444 
445         :param event: The name of event that will be emitted
446         :param args: The arguments for the event
447         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
448 
449         .. versionchanged:: 3.1
450 
451            Added *allowed_exceptions* to specify path-through exceptions
452         """
453         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
454 
455     def emit_firstresult(self, event: str, *args: Any,
456                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:
457         """Emit *event* and pass *arguments* to the callback functions.
458 
459         Return the result of the first callback that doesn't return ``None``.
460 
461         :param event: The name of event that will be emitted
462         :param args: The arguments for the event
463         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
464 
465         .. versionadded:: 0.5
466         .. versionchanged:: 3.1
467 
468            Added *allowed_exceptions* to specify path-through exceptions
469         """
470         return self.events.emit_firstresult(event, *args,
471                                             allowed_exceptions=allowed_exceptions)
472 
473     # registering addon parts
474 
475     def add_builder(self, builder: Type["Builder"], override: bool = False) -> None:
476         """Register a new builder.
477 
478         :param builder: A builder class
479         :param override: If true, install the builder forcedly even if another builder
480                          is already installed as the same name
481 
482         .. versionchanged:: 1.8
483            Add *override* keyword.
484         """
485         self.registry.add_builder(builder, override=override)
486 
487     # TODO(stephenfin): Describe 'types' parameter
488     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
489                          types: Any = ()) -> None:
490         """Register a configuration value.
491 
492         This is necessary for Sphinx to recognize new values and set default
493         values accordingly.
494 
495 
496         :param name: The name of the configuration value.  It is recommended to be prefixed
497                      with the extension name (ex. ``html_logo``, ``epub_title``)
498         :param default: The default value of the configuration.
499         :param rebuild: The condition of rebuild.  It must be one of those values:
500 
501                         * ``'env'`` if a change in the setting only takes effect when a
502                           document is parsed -- this means that the whole environment must be
503                           rebuilt.
504                         * ``'html'`` if a change in the setting needs a full rebuild of HTML
505                           documents.
506                         * ``''`` if a change in the setting will not need any special rebuild.
507         :param types: The type of configuration value.  A list of types can be specified.  For
508                       example, ``[str]`` is used to describe a configuration that takes string
509                       value.
510 
511         .. versionchanged:: 0.4
512            If the *default* value is a callable, it will be called with the
513            config object as its argument in order to get the default value.
514            This can be used to implement config values whose default depends on
515            other values.
516 
517         .. versionchanged:: 0.6
518            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
519            ``'env'``) to a string.  However, booleans are still accepted and
520            converted internally.
521         """
522         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))
523         if rebuild in (False, True):
524             rebuild = 'env' if rebuild else ''
525         self.config.add(name, default, rebuild, types)
526 
527     def add_event(self, name: str) -> None:
528         """Register an event called *name*.
529 
530         This is needed to be able to emit it.
531 
532         :param name: The name of the event
533         """
534         logger.debug('[app] adding event: %r', name)
535         self.events.add(name)
536 
537     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],
538                        override: bool = False) -> None:
539         """Register or override a Docutils translator class.
540 
541         This is used to register a custom output translator or to replace a
542         builtin translator.  This allows extensions to use a custom translator
543         and define custom nodes for the translator (see :meth:`add_node`).
544 
545         :param name: The name of the builder for the translator
546         :param translator_class: A translator class
547         :param override: If true, install the translator forcedly even if another translator
548                          is already installed as the same name
549 
550         .. versionadded:: 1.3
551         .. versionchanged:: 1.8
552            Add *override* keyword.
553         """
554         self.registry.add_translator(name, translator_class, override=override)
555 
556     def add_node(self, node: Type[Element], override: bool = False,
557                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:
558         """Register a Docutils node class.
559 
560         This is necessary for Docutils internals.  It may also be used in the
561         future to validate nodes in the parsed documents.
562 
563         :param node: A node class
564         :param kwargs: Visitor functions for each builder (see below)
565         :param override: If true, install the node forcedly even if another node is already
566                          installed as the same name
567 
568         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
569         writers can be given as keyword arguments: the keyword should be one or
570         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
571         or any other supported translators, the value a 2-tuple of ``(visit,
572         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
573         function raises :exc:`docutils.nodes.SkipNode`.  Example:
574 
575         .. code-block:: python
576 
577            class math(docutils.nodes.Element): pass
578 
579            def visit_math_html(self, node):
580                self.body.append(self.starttag(node, 'math'))
581            def depart_math_html(self, node):
582                self.body.append('</math>')
583 
584            app.add_node(math, html=(visit_math_html, depart_math_html))
585 
586         Obviously, translators for which you don't specify visitor methods will
587         choke on the node when encountered in a document to translate.
588 
589         .. versionchanged:: 0.5
590            Added the support for keyword arguments giving visit functions.
591         """
592         logger.debug('[app] adding node: %r', (node, kwargs))
593         if not override and docutils.is_node_registered(node):
594             logger.warning(__('node class %r is already registered, '
595                               'its visitors will be overridden'),
596                            node.__name__, type='app', subtype='add_node')
597         docutils.register_node(node)
598         self.registry.add_translation_handlers(node, **kwargs)
599 
600     def add_enumerable_node(self, node: Type[Element], figtype: str,
601                             title_getter: TitleGetter = None, override: bool = False,
602                             **kwargs: Tuple[Callable, Callable]) -> None:
603         """Register a Docutils node class as a numfig target.
604 
605         Sphinx numbers the node automatically. And then the users can refer it
606         using :rst:role:`numref`.
607 
608         :param node: A node class
609         :param figtype: The type of enumerable nodes.  Each figtype has individual numbering
610                         sequences.  As system figtypes, ``figure``, ``table`` and
611                         ``code-block`` are defined.  It is possible to add custom nodes to
612                         these default figtypes.  It is also possible to define new custom
613                         figtype if a new figtype is given.
614         :param title_getter: A getter function to obtain the title of node.  It takes an
615                              instance of the enumerable node, and it must return its title as
616                              string.  The title is used to the default title of references for
617                              :rst:role:`ref`.  By default, Sphinx searches
618                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the
619                              node as a title.
620         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)
621         :param override: If true, install the node forcedly even if another node is already
622                          installed as the same name
623 
624         .. versionadded:: 1.4
625         """
626         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
627         self.add_node(node, override=override, **kwargs)
628 
629     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:
630         """Register a Docutils directive.
631 
632         :param name: The name of the directive
633         :param cls: A directive class
634         :param override: If true, install the directive forcedly even if another directive
635                          is already installed as the same name
636 
637         For example, a custom directive named ``my-directive`` would be added
638         like this:
639 
640         .. code-block:: python
641 
642            from docutils.parsers.rst import Directive, directives
643 
644            class MyDirective(Directive):
645                has_content = True
646                required_arguments = 1
647                optional_arguments = 0
648                final_argument_whitespace = True
649                option_spec = {
650                    'class': directives.class_option,
651                    'name': directives.unchanged,
652                }
653 
654                def run(self):
655                    ...
656 
657            def setup(app):
658                app.add_directive('my-directive', MyDirective)
659 
660         For more details, see `the Docutils docs
661         <https://docutils.sourceforge.io/docs/howto/rst-directives.html>`__ .
662 
663         .. versionchanged:: 0.6
664            Docutils 0.5-style directive classes are now supported.
665         .. deprecated:: 1.8
666            Docutils 0.4-style (function based) directives support is deprecated.
667         .. versionchanged:: 1.8
668            Add *override* keyword.
669         """
670         logger.debug('[app] adding directive: %r', (name, cls))
671         if not override and docutils.is_directive_registered(name):
672             logger.warning(__('directive %r is already registered, it will be overridden'),
673                            name, type='app', subtype='add_directive')
674 
675         docutils.register_directive(name, cls)
676 
677     def add_role(self, name: str, role: Any, override: bool = False) -> None:
678         """Register a Docutils role.
679 
680         :param name: The name of role
681         :param role: A role function
682         :param override: If true, install the role forcedly even if another role is already
683                          installed as the same name
684 
685         For more details about role functions, see `the Docutils docs
686         <https://docutils.sourceforge.io/docs/howto/rst-roles.html>`__ .
687 
688         .. versionchanged:: 1.8
689            Add *override* keyword.
690         """
691         logger.debug('[app] adding role: %r', (name, role))
692         if not override and docutils.is_role_registered(name):
693             logger.warning(__('role %r is already registered, it will be overridden'),
694                            name, type='app', subtype='add_role')
695         docutils.register_role(name, role)
696 
697     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
698         """Register a generic Docutils role.
699 
700         Register a Docutils role that does nothing but wrap its contents in the
701         node given by *nodeclass*.
702 
703         If *override* is True, the given *nodeclass* is forcedly installed even if
704         a role named as *name* is already installed.
705 
706         .. versionadded:: 0.6
707         .. versionchanged:: 1.8
708            Add *override* keyword.
709         """
710         # Don't use ``roles.register_generic_role`` because it uses
711         # ``register_canonical_role``.
712         logger.debug('[app] adding generic role: %r', (name, nodeclass))
713         if not override and docutils.is_role_registered(name):
714             logger.warning(__('role %r is already registered, it will be overridden'),
715                            name, type='app', subtype='add_generic_role')
716         role = roles.GenericRole(name, nodeclass)
717         docutils.register_role(name, role)
718 
719     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
720         """Register a domain.
721 
722         :param domain: A domain class
723         :param override: If true, install the domain forcedly even if another domain
724                          is already installed as the same name
725 
726         .. versionadded:: 1.0
727         .. versionchanged:: 1.8
728            Add *override* keyword.
729         """
730         self.registry.add_domain(domain, override=override)
731 
732     def add_directive_to_domain(self, domain: str, name: str,
733                                 cls: Type[Directive], override: bool = False) -> None:
734         """Register a Docutils directive in a domain.
735 
736         Like :meth:`add_directive`, but the directive is added to the domain
737         named *domain*.
738 
739         :param domain: The name of target domain
740         :param name: A name of directive
741         :param cls: A directive class
742         :param override: If true, install the directive forcedly even if another directive
743                          is already installed as the same name
744 
745         .. versionadded:: 1.0
746         .. versionchanged:: 1.8
747            Add *override* keyword.
748         """
749         self.registry.add_directive_to_domain(domain, name, cls, override=override)
750 
751     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
752                            override: bool = False) -> None:
753         """Register a Docutils role in a domain.
754 
755         Like :meth:`add_role`, but the role is added to the domain named
756         *domain*.
757 
758         :param domain: The name of the target domain
759         :param name: The name of the role
760         :param role: The role function
761         :param override: If true, install the role forcedly even if another role is already
762                          installed as the same name
763 
764         .. versionadded:: 1.0
765         .. versionchanged:: 1.8
766            Add *override* keyword.
767         """
768         self.registry.add_role_to_domain(domain, name, role, override=override)
769 
770     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False
771                             ) -> None:
772         """Register a custom index for a domain.
773 
774         Add a custom *index* class to the domain named *domain*.
775 
776         :param domain: The name of the target domain
777         :param index: The index class
778         :param override: If true, install the index forcedly even if another index is
779                          already installed as the same name
780 
781         .. versionadded:: 1.0
782         .. versionchanged:: 1.8
783            Add *override* keyword.
784         """
785         self.registry.add_index_to_domain(domain, index)
786 
787     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
788                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
789                         objname: str = '', doc_field_types: List = [], override: bool = False
790                         ) -> None:
791         """Register a new object type.
792 
793         This method is a very convenient way to add a new :term:`object` type
794         that can be cross-referenced.  It will do this:
795 
796         - Create a new directive (called *directivename*) for documenting an
797           object.  It will automatically add index entries if *indextemplate*
798           is nonempty; if given, it must contain exactly one instance of
799           ``%s``.  See the example below for how the template will be
800           interpreted.
801         - Create a new role (called *rolename*) to cross-reference to these
802           object descriptions.
803         - If you provide *parse_node*, it must be a function that takes a
804           string and a docutils node, and it must populate the node with
805           children parsed from the string.  It must then return the name of the
806           item to be used in cross-referencing and index entries.  See the
807           :file:`conf.py` file in the source for this documentation for an
808           example.
809         - The *objname* (if not given, will default to *directivename*) names
810           the type of object.  It is used when listing objects, e.g. in search
811           results.
812 
813         For example, if you have this call in a custom Sphinx extension::
814 
815            app.add_object_type('directive', 'dir', 'pair: %s; directive')
816 
817         you can use this markup in your documents::
818 
819            .. rst:directive:: function
820 
821               Document a function.
822 
823            <...>
824 
825            See also the :rst:dir:`function` directive.
826 
827         For the directive, an index entry will be generated as if you had prepended ::
828 
829            .. index:: pair: function; directive
830 
831         The reference node will be of class ``literal`` (so it will be rendered
832         in a proportional font, as appropriate for code) unless you give the
833         *ref_nodeclass* argument, which must be a docutils node class.  Most
834         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
835         you can also use ``docutils.nodes.generated`` if you want no further
836         text decoration.  If the text should be treated as literal (e.g. no
837         smart quote replacement), but not have typewriter styling, use
838         ``sphinx.addnodes.literal_emphasis`` or
839         ``sphinx.addnodes.literal_strong``.
840 
841         For the role content, you have the same syntactical possibilities as
842         for standard Sphinx roles (see :ref:`xref-syntax`).
843 
844         If *override* is True, the given object_type is forcedly installed even if
845         an object_type having the same name is already installed.
846 
847         .. versionchanged:: 1.8
848            Add *override* keyword.
849         """
850         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
851                                       ref_nodeclass, objname, doc_field_types,
852                                       override=override)
853 
854     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
855                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
856                           override: bool = False) -> None:
857         """Register a new crossref object type.
858 
859         This method is very similar to :meth:`add_object_type` except that the
860         directive it generates must be empty, and will produce no output.
861 
862         That means that you can add semantic targets to your sources, and refer
863         to them using custom roles instead of generic ones (like
864         :rst:role:`ref`).  Example call::
865 
866            app.add_crossref_type('topic', 'topic', 'single: %s',
867                                  docutils.nodes.emphasis)
868 
869         Example usage::
870 
871            .. topic:: application API
872 
873            The application API
874            -------------------
875 
876            Some random text here.
877 
878            See also :topic:`this section <application API>`.
879 
880         (Of course, the element following the ``topic`` directive needn't be a
881         section.)
882 
883         If *override* is True, the given crossref_type is forcedly installed even if
884         a crossref_type having the same name is already installed.
885 
886         .. versionchanged:: 1.8
887            Add *override* keyword.
888         """
889         self.registry.add_crossref_type(directivename, rolename,
890                                         indextemplate, ref_nodeclass, objname,
891                                         override=override)
892 
893     def add_transform(self, transform: Type[Transform]) -> None:
894         """Register a Docutils transform to be applied after parsing.
895 
896         Add the standard docutils :class:`Transform` subclass *transform* to
897         the list of transforms that are applied after Sphinx parses a reST
898         document.
899 
900         :param transform: A transform class
901 
902         .. list-table:: priority range categories for Sphinx transforms
903            :widths: 20,80
904 
905            * - Priority
906              - Main purpose in Sphinx
907            * - 0-99
908              - Fix invalid nodes by docutils. Translate a doctree.
909            * - 100-299
910              - Preparation
911            * - 300-399
912              - early
913            * - 400-699
914              - main
915            * - 700-799
916              - Post processing. Deadline to modify text and referencing.
917            * - 800-899
918              - Collect referencing and referenced nodes. Domain processing.
919            * - 900-999
920              - Finalize and clean up.
921 
922         refs: `Transform Priority Range Categories`__
923 
924         __ https://docutils.sourceforge.io/docs/ref/transforms.html#transform-priority-range-categories
925         """  # NOQA
926         self.registry.add_transform(transform)
927 
928     def add_post_transform(self, transform: Type[Transform]) -> None:
929         """Register a Docutils transform to be applied before writing.
930 
931         Add the standard docutils :class:`Transform` subclass *transform* to
932         the list of transforms that are applied before Sphinx writes a
933         document.
934 
935         :param transform: A transform class
936         """
937         self.registry.add_post_transform(transform)
938 
939     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
940         """Register a JavaScript file to include in the HTML output.
941 
942         Add *filename* to the list of JavaScript files that the default HTML
943         template will include in order of *priority* (ascending).  The filename
944         must be relative to the HTML static path , or a full URI with scheme.
945         If the priority of the JavaScript file is the same as others, the JavaScript
946         files will be included in order of registration.  If the keyword
947         argument ``body`` is given, its value will be added between the
948         ``<script>`` tags. Extra keyword arguments are included as attributes of
949         the ``<script>`` tag.
950 
951         Example::
952 
953             app.add_js_file('example.js')
954             # => <script src="_static/example.js"></script>
955 
956             app.add_js_file('example.js', async="async")
957             # => <script src="_static/example.js" async="async"></script>
958 
959             app.add_js_file(None, body="var myVariable = 'foo';")
960             # => <script>var myVariable = 'foo';</script>
961 
962         .. list-table:: priority range for JavaScript files
963            :widths: 20,80
964 
965            * - Priority
966              - Main purpose in Sphinx
967            * - 200
968              - default priority for built-in JavaScript files
969            * - 500
970              - default priority for extensions
971            * - 800
972              - default priority for :confval:`html_js_files`
973 
974         A JavaScript file can be added to the specific HTML page when an extension
975         calls this method on :event:`html-page-context` event.
976 
977         .. versionadded:: 0.5
978 
979         .. versionchanged:: 1.8
980            Renamed from ``app.add_javascript()``.
981            And it allows keyword arguments as attributes of script tag.
982 
983         .. versionchanged:: 3.5
984            Take priority argument.  Allow to add a JavaScript file to the specific page.
985         """
986         self.registry.add_js_file(filename, priority=priority, **kwargs)
987         if hasattr(self.builder, 'add_js_file'):
988             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore
989 
990     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
991         """Register a stylesheet to include in the HTML output.
992 
993         Add *filename* to the list of CSS files that the default HTML template
994         will include in order of *priority* (ascending).  The filename must be
995         relative to the HTML static path, or a full URI with scheme.  If the
996         priority of the CSS file is the same as others, the CSS files will be
997         included in order of registration.  The keyword arguments are also
998         accepted for attributes of ``<link>`` tag.
999 
1000         Example::
1001 
1002             app.add_css_file('custom.css')
1003             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
1004 
1005             app.add_css_file('print.css', media='print')
1006             # => <link rel="stylesheet" href="_static/print.css"
1007             #          type="text/css" media="print" />
1008 
1009             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
1010             # => <link rel="alternate stylesheet" href="_static/fancy.css"
1011             #          type="text/css" title="fancy" />
1012 
1013         .. list-table:: priority range for CSS files
1014            :widths: 20,80
1015 
1016            * - Priority
1017              - Main purpose in Sphinx
1018            * - 200
1019              - default priority for built-in CSS files
1020            * - 500
1021              - default priority for extensions
1022            * - 800
1023              - default priority for :confval:`html_css_files`
1024 
1025         A CSS file can be added to the specific HTML page when an extension calls
1026         this method on :event:`html-page-context` event.
1027 
1028         .. versionadded:: 1.0
1029 
1030         .. versionchanged:: 1.6
1031            Optional ``alternate`` and/or ``title`` attributes can be supplied
1032            with the arguments *alternate* (a Boolean) and *title* (a string).
1033            The default is no title and *alternate* = ``False``. For
1034            more information, refer to the `documentation
1035            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
1036 
1037         .. versionchanged:: 1.8
1038            Renamed from ``app.add_stylesheet()``.
1039            And it allows keyword arguments as attributes of link tag.
1040 
1041         .. versionchanged:: 3.5
1042            Take priority argument.  Allow to add a CSS file to the specific page.
1043         """
1044         logger.debug('[app] adding stylesheet: %r', filename)
1045         self.registry.add_css_files(filename, priority=priority, **kwargs)
1046         if hasattr(self.builder, 'add_css_file'):
1047             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore
1048 
1049     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
1050                        ) -> None:
1051         """An alias of :meth:`add_css_file`.
1052 
1053         .. deprecated:: 1.8
1054         """
1055         logger.warning('The app.add_stylesheet() is deprecated. '
1056                        'Please use app.add_css_file() instead.')
1057 
1058         attributes = {}  # type: Dict[str, Any]
1059         if alternate:
1060             attributes['rel'] = 'alternate stylesheet'
1061         else:
1062             attributes['rel'] = 'stylesheet'
1063 
1064         if title:
1065             attributes['title'] = title
1066 
1067         self.add_css_file(filename, **attributes)
1068 
1069     def add_latex_package(self, packagename: str, options: str = None,
1070                           after_hyperref: bool = False) -> None:
1071         r"""Register a package to include in the LaTeX source code.
1072 
1073         Add *packagename* to the list of packages that LaTeX source code will
1074         include.  If you provide *options*, it will be taken to the `\usepackage`
1075         declaration.  If you set *after_hyperref* truthy, the package will be
1076         loaded after ``hyperref`` package.
1077 
1078         .. code-block:: python
1079 
1080            app.add_latex_package('mypackage')
1081            # => \usepackage{mypackage}
1082            app.add_latex_package('mypackage', 'foo,bar')
1083            # => \usepackage[foo,bar]{mypackage}
1084 
1085         .. versionadded:: 1.3
1086         .. versionadded:: 3.1
1087 
1088            *after_hyperref* option.
1089         """
1090         self.registry.add_latex_package(packagename, options, after_hyperref)
1091 
1092     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:
1093         """Register a new lexer for source code.
1094 
1095         Use *lexer* to highlight code blocks with the given language *alias*.
1096 
1097         .. versionadded:: 0.6
1098         .. versionchanged:: 2.1
1099            Take a lexer class as an argument.  An instance of lexers are
1100            still supported until Sphinx-3.x.
1101         """
1102         logger.debug('[app] adding lexer: %r', (alias, lexer))
1103         lexer_classes[alias] = lexer
1104 
1105     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1106         """Register a new documenter class for the autodoc extension.
1107 
1108         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1109         extension.  It must be a subclass of
1110         :class:`sphinx.ext.autodoc.Documenter`.  This allows auto-documenting
1111         new types of objects.  See the source of the autodoc module for
1112         examples on how to subclass :class:`Documenter`.
1113 
1114         If *override* is True, the given *cls* is forcedly installed even if
1115         a documenter having the same name is already installed.
1116 
1117         See :ref:`autodoc_ext_tutorial`.
1118 
1119         .. versionadded:: 0.6
1120         .. versionchanged:: 2.2
1121            Add *override* keyword.
1122         """
1123         logger.debug('[app] adding autodocumenter: %r', cls)
1124         from sphinx.ext.autodoc.directive import AutodocDirective
1125         self.registry.add_documenter(cls.objtype, cls)
1126         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1127 
1128     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]
1129                                ) -> None:
1130         """Register a new ``getattr``-like function for the autodoc extension.
1131 
1132         Add *getter*, which must be a function with an interface compatible to
1133         the :func:`getattr` builtin, as the autodoc attribute getter for
1134         objects that are instances of *typ*.  All cases where autodoc needs to
1135         get an attribute of a type are then handled by this function instead of
1136         :func:`getattr`.
1137 
1138         .. versionadded:: 0.6
1139         """
1140         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1141         self.registry.add_autodoc_attrgetter(typ, getter)
1142 
1143     def add_search_language(self, cls: Any) -> None:
1144         """Register a new language for the HTML search index.
1145 
1146         Add *cls*, which must be a subclass of
1147         :class:`sphinx.search.SearchLanguage`, as a support language for
1148         building the HTML full-text search index.  The class must have a *lang*
1149         attribute that indicates the language it should be used for.  See
1150         :confval:`html_search_language`.
1151 
1152         .. versionadded:: 1.1
1153         """
1154         logger.debug('[app] adding search language: %r', cls)
1155         from sphinx.search import SearchLanguage, languages
1156         assert issubclass(cls, SearchLanguage)
1157         languages[cls.lang] = cls
1158 
1159     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1160         """Register a suffix of source files.
1161 
1162         Same as :confval:`source_suffix`.  The users can override this
1163         using the config setting.
1164 
1165         If *override* is True, the given *suffix* is forcedly installed even if
1166         the same suffix is already installed.
1167 
1168         .. versionadded:: 1.8
1169         """
1170         self.registry.add_source_suffix(suffix, filetype, override=override)
1171 
1172     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
1173         """Register a parser class.
1174 
1175         If *override* is True, the given *parser* is forcedly installed even if
1176         a parser for the same suffix is already installed.
1177 
1178         .. versionadded:: 1.4
1179         .. versionchanged:: 1.8
1180            *suffix* argument is deprecated.  It only accepts *parser* argument.
1181            Use :meth:`add_source_suffix` API to register suffix instead.
1182         .. versionchanged:: 1.8
1183            Add *override* keyword.
1184         """
1185         self.registry.add_source_parser(parser, override=override)
1186 
1187     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:
1188         """Register an environment collector class.
1189 
1190         Refer to :ref:`collector-api`.
1191 
1192         .. versionadded:: 1.6
1193         """
1194         logger.debug('[app] adding environment collector: %r', collector)
1195         collector().enable(self)
1196 
1197     def add_html_theme(self, name: str, theme_path: str) -> None:
1198         """Register a HTML Theme.
1199 
1200         The *name* is a name of theme, and *theme_path* is a full path to the
1201         theme (refs: :ref:`distribute-your-theme`).
1202 
1203         .. versionadded:: 1.6
1204         """
1205         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1206         self.registry.add_html_theme(name, theme_path)
1207 
1208     def add_html_math_renderer(self, name: str,
1209                                inline_renderers: Tuple[Callable, Callable] = None,
1210                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1211         """Register a math renderer for HTML.
1212 
1213         The *name* is a name of math renderer.  Both *inline_renderers* and
1214         *block_renderers* are used as visitor functions for the HTML writer:
1215         the former for inline math node (``nodes.math``), the latter for
1216         block math node (``nodes.math_block``).  Regarding visitor functions,
1217         see :meth:`add_node` for details.
1218 
1219         .. versionadded:: 1.8
1220 
1221         """
1222         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1223 
1224     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1225         """Register a message catalog.
1226 
1227         :param catalog: The name of the catalog
1228         :param locale_dir: The base path of the message catalog
1229 
1230         For more details, see :func:`sphinx.locale.get_translation()`.
1231 
1232         .. versionadded:: 1.8
1233         """
1234         locale.init([locale_dir], self.config.language, catalog)
1235         locale.init_console(locale_dir, catalog)
1236 
1237     # ---- other methods -------------------------------------------------
1238     def is_parallel_allowed(self, typ: str) -> bool:
1239         """Check whether parallel processing is allowed or not.
1240 
1241         :param typ: A type of processing; ``'read'`` or ``'write'``.
1242         """
1243         if typ == 'read':
1244             attrname = 'parallel_read_safe'
1245             message_not_declared = __("the %s extension does not declare if it "
1246                                       "is safe for parallel reading, assuming "
1247                                       "it isn't - please ask the extension author "
1248                                       "to check and make it explicit")
1249             message_not_safe = __("the %s extension is not safe for parallel reading")
1250         elif typ == 'write':
1251             attrname = 'parallel_write_safe'
1252             message_not_declared = __("the %s extension does not declare if it "
1253                                       "is safe for parallel writing, assuming "
1254                                       "it isn't - please ask the extension author "
1255                                       "to check and make it explicit")
1256             message_not_safe = __("the %s extension is not safe for parallel writing")
1257         else:
1258             raise ValueError('parallel type %s is not supported' % typ)
1259 
1260         for ext in self.extensions.values():
1261             allowed = getattr(ext, attrname, None)
1262             if allowed is None:
1263                 logger.warning(message_not_declared, ext.name)
1264                 logger.warning(__('doing serial %s'), typ)
1265                 return False
1266             elif not allowed:
1267                 logger.warning(message_not_safe, ext.name)
1268                 logger.warning(__('doing serial %s'), typ)
1269                 return False
1270 
1271         return True
1272 
1273     def set_html_assets_policy(self, policy):
1274         """Set the policy to include assets in HTML pages.
1275 
1276         - always: include the assets in all the pages
1277         - per_page: include the assets only in pages where they are used
1278 
1279         .. versionadded: 4.1
1280         """
1281         if policy not in ('always', 'per_page'):
1282             raise ValueError('policy %s is not supported' % policy)
1283         self.registry.html_assets_policy = policy
1284 
1285     @property
1286     def html_themes(self) -> Dict[str, str]:
1287         warnings.warn('app.html_themes is deprecated.',
1288                       RemovedInSphinx60Warning)
1289         return self.registry.html_themes
1290 
1291 
1292 class TemplateBridge:
1293     """
1294     This class defines the interface for a "template bridge", that is, a class
1295     that renders templates given a template name and a context.
1296     """
1297 
1298     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1299         """Called by the builder to initialize the template system.
1300 
1301         *builder* is the builder object; you'll probably want to look at the
1302         value of ``builder.config.templates_path``.
1303 
1304         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1305         case, *dirs* can be list of fixed directories to look for templates.
1306         """
1307         raise NotImplementedError('must be implemented in subclasses')
1308 
1309     def newest_template_mtime(self) -> float:
1310         """Called by the builder to determine if output files are outdated
1311         because of template changes.  Return the mtime of the newest template
1312         file that was changed.  The default implementation returns ``0``.
1313         """
1314         return 0
1315 
1316     def render(self, template: str, context: Dict) -> None:
1317         """Called by the builder to render a template given as a filename with
1318         a specified context (a Python dictionary).
1319         """
1320         raise NotImplementedError('must be implemented in subclasses')
1321 
1322     def render_string(self, template: str, context: Dict) -> str:
1323         """Called by the builder to render a template given as a string with a
1324         specified context (a Python dictionary).
1325         """
1326         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>The code responsible for comparing extension versions should accurately perform semantic version comparison, ensuring proper interpretation of version numbers. Modifications should include parsing version strings into numerically comparable parts or utilizing libraries designed for semantic version comparison, such as Python's pkg_resources.parse_version or the packaging library, without compromising existing functionality.</intended_behavior>]
2025-10-18 07:25:27.436 | INFO     | Search completed. Bug locations: [<file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import IO, TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Type, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers import Parser
26 from docutils.parsers.rst import Directive, roles
27 from docutils.transforms import Transform
28 from pygments.lexer import Lexer
29 
30 import sphinx
31 from sphinx import locale, package_dir
32 from sphinx.config import Config
33 from sphinx.deprecation import RemovedInSphinx60Warning
34 from sphinx.domains import Domain, Index
35 from sphinx.environment import BuildEnvironment
36 from sphinx.environment.collectors import EnvironmentCollector
37 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
38 from sphinx.events import EventManager
39 from sphinx.extension import Extension
40 from sphinx.highlighting import lexer_classes
41 from sphinx.locale import __
42 from sphinx.project import Project
43 from sphinx.registry import SphinxComponentRegistry
44 from sphinx.roles import XRefRole
45 from sphinx.theming import Theme
46 from sphinx.util import docutils, logging, progress_message
47 from sphinx.util.build_phase import BuildPhase
48 from sphinx.util.console import bold  # type: ignore
49 from sphinx.util.i18n import CatalogRepository
50 from sphinx.util.logging import prefixed_warnings
51 from sphinx.util.osutil import abspath, ensuredir, relpath
52 from sphinx.util.tags import Tags
53 from sphinx.util.typing import RoleFunction, TitleGetter
54 
55 if TYPE_CHECKING:
56     from docutils.nodes import Node  # NOQA
57 
58     from sphinx.builders import Builder
59 
60 
61 builtin_extensions = (
62     'sphinx.addnodes',
63     'sphinx.builders.changes',
64     'sphinx.builders.epub3',
65     'sphinx.builders.dirhtml',
66     'sphinx.builders.dummy',
67     'sphinx.builders.gettext',
68     'sphinx.builders.html',
69     'sphinx.builders.latex',
70     'sphinx.builders.linkcheck',
71     'sphinx.builders.manpage',
72     'sphinx.builders.singlehtml',
73     'sphinx.builders.texinfo',
74     'sphinx.builders.text',
75     'sphinx.builders.xml',
76     'sphinx.config',
77     'sphinx.domains.c',
78     'sphinx.domains.changeset',
79     'sphinx.domains.citation',
80     'sphinx.domains.cpp',
81     'sphinx.domains.index',
82     'sphinx.domains.javascript',
83     'sphinx.domains.math',
84     'sphinx.domains.python',
85     'sphinx.domains.rst',
86     'sphinx.domains.std',
87     'sphinx.directives',
88     'sphinx.directives.code',
89     'sphinx.directives.other',
90     'sphinx.directives.patches',
91     'sphinx.extension',
92     'sphinx.parsers',
93     'sphinx.registry',
94     'sphinx.roles',
95     'sphinx.transforms',
96     'sphinx.transforms.compact_bullet_list',
97     'sphinx.transforms.i18n',
98     'sphinx.transforms.references',
99     'sphinx.transforms.post_transforms',
100     'sphinx.transforms.post_transforms.code',
101     'sphinx.transforms.post_transforms.images',
102     'sphinx.util.compat',
103     'sphinx.versioning',
104     # collectors should be loaded by specific order
105     'sphinx.environment.collectors.dependencies',
106     'sphinx.environment.collectors.asset',
107     'sphinx.environment.collectors.metadata',
108     'sphinx.environment.collectors.title',
109     'sphinx.environment.collectors.toctree',
110     # 1st party extensions
111     'sphinxcontrib.applehelp',
112     'sphinxcontrib.devhelp',
113     'sphinxcontrib.htmlhelp',
114     'sphinxcontrib.serializinghtml',
115     'sphinxcontrib.qthelp',
116     # Strictly, alabaster theme is not a builtin extension,
117     # but it is loaded automatically to use it as default theme.
118     'alabaster',
119 )
120 
121 ENV_PICKLE_FILENAME = 'environment.pickle'
122 
123 logger = logging.getLogger(__name__)
124 
125 
126 class Sphinx:
127     """The main application class and extensibility interface.
128 
129     :ivar srcdir: Directory containing source.
130     :ivar confdir: Directory containing ``conf.py``.
131     :ivar doctreedir: Directory for storing pickled doctrees.
132     :ivar outdir: Directory for storing build documents.
133     """
134 
135     warningiserror: bool
136     _warncount: int
137 
138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,
139                  buildername: str, confoverrides: Dict = None,
140                  status: IO = sys.stdout, warning: IO = sys.stderr,
141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
143         self.phase = BuildPhase.INITIALIZATION
144         self.verbosity = verbosity
145         self.extensions: Dict[str, Extension] = {}
146         self.builder: Optional[Builder] = None
147         self.env: Optional[BuildEnvironment] = None
148         self.project: Optional[Project] = None
149         self.registry = SphinxComponentRegistry()
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155 
156         if not path.isdir(self.srcdir):
157             raise ApplicationError(__('Cannot find source directory (%s)') %
158                                    self.srcdir)
159 
160         if path.exists(self.outdir) and not path.isdir(self.outdir):
161             raise ApplicationError(__('Output directory (%s) is not a directory') %
162                                    self.outdir)
163 
164         if self.srcdir == self.outdir:
165             raise ApplicationError(__('Source directory and destination '
166                                       'directory cannot be identical'))
167 
168         self.parallel = parallel
169 
170         if status is None:
171             self._status: IO = StringIO()
172             self.quiet: bool = True
173         else:
174             self._status = status
175             self.quiet = False
176 
177         if warning is None:
178             self._warning: IO = StringIO()
179         else:
180             self._warning = warning
181         self._warncount = 0
182         self.keep_going = warningiserror and keep_going
183         if self.keep_going:
184             self.warningiserror = False
185         else:
186             self.warningiserror = warningiserror
187         logging.setup(self, self._status, self._warning)
188 
189         self.events = EventManager(self)
190 
191         # keep last few messages for traceback
192         # This will be filled by sphinx.util.logging.LastMessagesWriter
193         self.messagelog: deque = deque(maxlen=10)
194 
195         # say hello to the world
196         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
197 
198         # notice for parallel build on macOS and py38+
199         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
200             logger.info(bold(__("For security reasons, parallel mode is disabled on macOS and "
201                                 "python3.8 and above. For more details, please read "
202                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
203 
204         # status code for command-line application
205         self.statuscode = 0
206 
207         # read config
208         self.tags = Tags(tags)
209         if confdir is None:
210             # set confdir to srcdir if -C given (!= no confdir); a few pieces
211             # of code expect a confdir to be set
212             self.confdir = self.srcdir
213             self.config = Config({}, confoverrides or {})
214         else:
215             self.confdir = abspath(confdir)
216             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
217 
218         # initialize some limited config variables before initialize i18n and loading
219         # extensions
220         self.config.pre_init_values()
221 
222         # set up translation infrastructure
223         self._init_i18n()
224 
225         # check the Sphinx version if requested
226         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
227             raise VersionRequirementError(
228                 __('This project needs at least Sphinx v%s and therefore cannot '
229                    'be built with this version.') % self.config.needs_sphinx)
230 
231         # load all built-in extension modules
232         for extension in builtin_extensions:
233             self.setup_extension(extension)
234 
235         # load all user-given extension modules
236         for extension in self.config.extensions:
237             self.setup_extension(extension)
238 
239         # preload builder module (before init config values)
240         self.preload_builder(buildername)
241 
242         if not path.isdir(outdir):
243             with progress_message(__('making output directory')):
244                 ensuredir(outdir)
245 
246         # the config file itself can be an extension
247         if self.config.setup:
248             prefix = __('while setting up extension %s:') % "conf.py"
249             with prefixed_warnings(prefix):
250                 if callable(self.config.setup):
251                     self.config.setup(self)
252                 else:
253                     raise ConfigError(
254                         __("'setup' as currently defined in conf.py isn't a Python callable. "
255                            "Please modify its definition to make it a callable function. "
256                            "This is needed for conf.py to behave as a Sphinx extension.")
257                     )
258 
259         # now that we know all config values, collect them from conf.py
260         self.config.init_values()
261         self.events.emit('config-inited', self.config)
262 
263         # create the project
264         self.project = Project(self.srcdir, self.config.source_suffix)
265         # create the builder
266         self.builder = self.create_builder(buildername)
267         # set up the build environment
268         self._init_env(freshenv)
269         # set up the builder
270         self._init_builder()
271 
272     def _init_i18n(self) -> None:
273         """Load translated strings from the configured localedirs if enabled in
274         the configuration.
275         """
276         if self.config.language is None:
277             self.translator, has_translation = locale.init([], None)
278         else:
279             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
280                         nonl=True)
281 
282             # compile mo files if sphinx.po file in user locale directories are updated
283             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
284                                      self.config.language, self.config.source_encoding)
285             for catalog in repo.catalogs:
286                 if catalog.domain == 'sphinx' and catalog.is_outdated():
287                     catalog.write_mo(self.config.language)
288 
289             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)
290             locale_dirs += [None]
291             locale_dirs += [path.join(package_dir, 'locale')]
292 
293             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
294             if has_translation or self.config.language == 'en':
295                 # "en" never needs to be translated
296                 logger.info(__('done'))
297             else:
298                 logger.info(__('not available for built-in messages'))
299 
300     def _init_env(self, freshenv: bool) -> None:
301         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
302         if freshenv or not os.path.exists(filename):
303             self.env = BuildEnvironment(self)
304             self.env.find_files(self.config, self.builder)
305         else:
306             try:
307                 with progress_message(__('loading pickled environment')):
308                     with open(filename, 'rb') as f:
309                         self.env = pickle.load(f)
310                         self.env.setup(self)
311             except Exception as err:
312                 logger.info(__('failed: %s'), err)
313                 self._init_env(freshenv=True)
314 
315     def preload_builder(self, name: str) -> None:
316         self.registry.preload_builder(self, name)
317 
318     def create_builder(self, name: str) -> "Builder":
319         if name is None:
320             logger.info(__('No builder selected, using default: html'))
321             name = 'html'
322 
323         return self.registry.create_builder(self, name)
324 
325     def _init_builder(self) -> None:
326         self.builder.set_environment(self.env)
327         self.builder.init()
328         self.events.emit('builder-inited')
329 
330     # ---- main "build" method -------------------------------------------------
331 
332     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
333         self.phase = BuildPhase.READING
334         try:
335             if force_all:
336                 self.builder.compile_all_catalogs()
337                 self.builder.build_all()
338             elif filenames:
339                 self.builder.compile_specific_catalogs(filenames)
340                 self.builder.build_specific(filenames)
341             else:
342                 self.builder.compile_update_catalogs()
343                 self.builder.build_update()
344 
345             if self._warncount and self.keep_going:
346                 self.statuscode = 1
347 
348             status = (__('succeeded') if self.statuscode == 0
349                       else __('finished with problems'))
350             if self._warncount:
351                 if self.warningiserror:
352                     if self._warncount == 1:
353                         msg = __('build %s, %s warning (with warnings treated as errors).')
354                     else:
355                         msg = __('build %s, %s warnings (with warnings treated as errors).')
356                 else:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning.')
359                     else:
360                         msg = __('build %s, %s warnings.')
361 
362                 logger.info(bold(msg % (status, self._warncount)))
363             else:
364                 logger.info(bold(__('build %s.') % status))
365 
366             if self.statuscode == 0 and self.builder.epilog:
367                 logger.info('')
368                 logger.info(self.builder.epilog % {
369                     'outdir': relpath(self.outdir),
370                     'project': self.config.project
371                 })
372         except Exception as err:
373             # delete the saved env to force a fresh build next time
374             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
375             if path.isfile(envfile):
376                 os.unlink(envfile)
377             self.events.emit('build-finished', err)
378             raise
379         else:
380             self.events.emit('build-finished', None)
381         self.builder.cleanup()
382 
383     # ---- general extensibility interface -------------------------------------
384 
385     def setup_extension(self, extname: str) -> None:
386         """Import and setup a Sphinx extension module.
387 
388         Load the extension given by the module *name*.  Use this if your
389         extension needs the features provided by another extension.  No-op if
390         called twice.
391         """
392         logger.debug('[app] setting up extension: %r', extname)
393         self.registry.load_extension(self, extname)
394 
395     def require_sphinx(self, version: str) -> None:
396         """Check the Sphinx version if requested.
397 
398         Compare *version* with the version of the running Sphinx, and abort the
399         build when it is too old.
400 
401         :param version: The required version in the form of ``major.minor``.
402 
403         .. versionadded:: 1.0
404         """
405         if version > sphinx.__display_version__[:3]:
406             raise VersionRequirementError(version)
407 
408     # event interface
409     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
410         """Register *callback* to be called when *event* is emitted.
411 
412         For details on available core events and the arguments of callback
413         functions, please see :ref:`events`.
414 
415         :param event: The name of target event
416         :param callback: Callback function for the event
417         :param priority: The priority of the callback.  The callbacks will be invoked
418                          in order of *priority* (ascending).
419         :return: A listener ID.  It can be used for :meth:`disconnect`.
420 
421         .. versionchanged:: 3.0
422 
423            Support *priority*
424         """
425         listener_id = self.events.connect(event, callback, priority)
426         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
427                      event, priority, callback, listener_id)
428         return listener_id
429 
430     def disconnect(self, listener_id: int) -> None:
431         """Unregister callback by *listener_id*.
432 
433         :param listener_id: A listener_id that :meth:`connect` returns
434         """
435         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
436         self.events.disconnect(listener_id)
437 
438     def emit(self, event: str, *args: Any,
439              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:
440         """Emit *event* and pass *arguments* to the callback functions.
441 
442         Return the return values of all callbacks as a list.  Do not emit core
443         Sphinx events in extensions!
444 
445         :param event: The name of event that will be emitted
446         :param args: The arguments for the event
447         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
448 
449         .. versionchanged:: 3.1
450 
451            Added *allowed_exceptions* to specify path-through exceptions
452         """
453         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
454 
455     def emit_firstresult(self, event: str, *args: Any,
456                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:
457         """Emit *event* and pass *arguments* to the callback functions.
458 
459         Return the result of the first callback that doesn't return ``None``.
460 
461         :param event: The name of event that will be emitted
462         :param args: The arguments for the event
463         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
464 
465         .. versionadded:: 0.5
466         .. versionchanged:: 3.1
467 
468            Added *allowed_exceptions* to specify path-through exceptions
469         """
470         return self.events.emit_firstresult(event, *args,
471                                             allowed_exceptions=allowed_exceptions)
472 
473     # registering addon parts
474 
475     def add_builder(self, builder: Type["Builder"], override: bool = False) -> None:
476         """Register a new builder.
477 
478         :param builder: A builder class
479         :param override: If true, install the builder forcedly even if another builder
480                          is already installed as the same name
481 
482         .. versionchanged:: 1.8
483            Add *override* keyword.
484         """
485         self.registry.add_builder(builder, override=override)
486 
487     # TODO(stephenfin): Describe 'types' parameter
488     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
489                          types: Any = ()) -> None:
490         """Register a configuration value.
491 
492         This is necessary for Sphinx to recognize new values and set default
493         values accordingly.
494 
495 
496         :param name: The name of the configuration value.  It is recommended to be prefixed
497                      with the extension name (ex. ``html_logo``, ``epub_title``)
498         :param default: The default value of the configuration.
499         :param rebuild: The condition of rebuild.  It must be one of those values:
500 
501                         * ``'env'`` if a change in the setting only takes effect when a
502                           document is parsed -- this means that the whole environment must be
503                           rebuilt.
504                         * ``'html'`` if a change in the setting needs a full rebuild of HTML
505                           documents.
506                         * ``''`` if a change in the setting will not need any special rebuild.
507         :param types: The type of configuration value.  A list of types can be specified.  For
508                       example, ``[str]`` is used to describe a configuration that takes string
509                       value.
510 
511         .. versionchanged:: 0.4
512            If the *default* value is a callable, it will be called with the
513            config object as its argument in order to get the default value.
514            This can be used to implement config values whose default depends on
515            other values.
516 
517         .. versionchanged:: 0.6
518            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
519            ``'env'``) to a string.  However, booleans are still accepted and
520            converted internally.
521         """
522         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))
523         if rebuild in (False, True):
524             rebuild = 'env' if rebuild else ''
525         self.config.add(name, default, rebuild, types)
526 
527     def add_event(self, name: str) -> None:
528         """Register an event called *name*.
529 
530         This is needed to be able to emit it.
531 
532         :param name: The name of the event
533         """
534         logger.debug('[app] adding event: %r', name)
535         self.events.add(name)
536 
537     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],
538                        override: bool = False) -> None:
539         """Register or override a Docutils translator class.
540 
541         This is used to register a custom output translator or to replace a
542         builtin translator.  This allows extensions to use a custom translator
543         and define custom nodes for the translator (see :meth:`add_node`).
544 
545         :param name: The name of the builder for the translator
546         :param translator_class: A translator class
547         :param override: If true, install the translator forcedly even if another translator
548                          is already installed as the same name
549 
550         .. versionadded:: 1.3
551         .. versionchanged:: 1.8
552            Add *override* keyword.
553         """
554         self.registry.add_translator(name, translator_class, override=override)
555 
556     def add_node(self, node: Type[Element], override: bool = False,
557                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:
558         """Register a Docutils node class.
559 
560         This is necessary for Docutils internals.  It may also be used in the
561         future to validate nodes in the parsed documents.
562 
563         :param node: A node class
564         :param kwargs: Visitor functions for each builder (see below)
565         :param override: If true, install the node forcedly even if another node is already
566                          installed as the same name
567 
568         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
569         writers can be given as keyword arguments: the keyword should be one or
570         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
571         or any other supported translators, the value a 2-tuple of ``(visit,
572         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
573         function raises :exc:`docutils.nodes.SkipNode`.  Example:
574 
575         .. code-block:: python
576 
577            class math(docutils.nodes.Element): pass
578 
579            def visit_math_html(self, node):
580                self.body.append(self.starttag(node, 'math'))
581            def depart_math_html(self, node):
582                self.body.append('</math>')
583 
584            app.add_node(math, html=(visit_math_html, depart_math_html))
585 
586         Obviously, translators for which you don't specify visitor methods will
587         choke on the node when encountered in a document to translate.
588 
589         .. versionchanged:: 0.5
590            Added the support for keyword arguments giving visit functions.
591         """
592         logger.debug('[app] adding node: %r', (node, kwargs))
593         if not override and docutils.is_node_registered(node):
594             logger.warning(__('node class %r is already registered, '
595                               'its visitors will be overridden'),
596                            node.__name__, type='app', subtype='add_node')
597         docutils.register_node(node)
598         self.registry.add_translation_handlers(node, **kwargs)
599 
600     def add_enumerable_node(self, node: Type[Element], figtype: str,
601                             title_getter: TitleGetter = None, override: bool = False,
602                             **kwargs: Tuple[Callable, Callable]) -> None:
603         """Register a Docutils node class as a numfig target.
604 
605         Sphinx numbers the node automatically. And then the users can refer it
606         using :rst:role:`numref`.
607 
608         :param node: A node class
609         :param figtype: The type of enumerable nodes.  Each figtype has individual numbering
610                         sequences.  As system figtypes, ``figure``, ``table`` and
611                         ``code-block`` are defined.  It is possible to add custom nodes to
612                         these default figtypes.  It is also possible to define new custom
613                         figtype if a new figtype is given.
614         :param title_getter: A getter function to obtain the title of node.  It takes an
615                              instance of the enumerable node, and it must return its title as
616                              string.  The title is used to the default title of references for
617                              :rst:role:`ref`.  By default, Sphinx searches
618                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the
619                              node as a title.
620         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)
621         :param override: If true, install the node forcedly even if another node is already
622                          installed as the same name
623 
624         .. versionadded:: 1.4
625         """
626         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
627         self.add_node(node, override=override, **kwargs)
628 
629     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:
630         """Register a Docutils directive.
631 
632         :param name: The name of the directive
633         :param cls: A directive class
634         :param override: If true, install the directive forcedly even if another directive
635                          is already installed as the same name
636 
637         For example, a custom directive named ``my-directive`` would be added
638         like this:
639 
640         .. code-block:: python
641 
642            from docutils.parsers.rst import Directive, directives
643 
644            class MyDirective(Directive):
645                has_content = True
646                required_arguments = 1
647                optional_arguments = 0
648                final_argument_whitespace = True
649                option_spec = {
650                    'class': directives.class_option,
651                    'name': directives.unchanged,
652                }
653 
654                def run(self):
655                    ...
656 
657            def setup(app):
658                app.add_directive('my-directive', MyDirective)
659 
660         For more details, see `the Docutils docs
661         <https://docutils.sourceforge.io/docs/howto/rst-directives.html>`__ .
662 
663         .. versionchanged:: 0.6
664            Docutils 0.5-style directive classes are now supported.
665         .. deprecated:: 1.8
666            Docutils 0.4-style (function based) directives support is deprecated.
667         .. versionchanged:: 1.8
668            Add *override* keyword.
669         """
670         logger.debug('[app] adding directive: %r', (name, cls))
671         if not override and docutils.is_directive_registered(name):
672             logger.warning(__('directive %r is already registered, it will be overridden'),
673                            name, type='app', subtype='add_directive')
674 
675         docutils.register_directive(name, cls)
676 
677     def add_role(self, name: str, role: Any, override: bool = False) -> None:
678         """Register a Docutils role.
679 
680         :param name: The name of role
681         :param role: A role function
682         :param override: If true, install the role forcedly even if another role is already
683                          installed as the same name
684 
685         For more details about role functions, see `the Docutils docs
686         <https://docutils.sourceforge.io/docs/howto/rst-roles.html>`__ .
687 
688         .. versionchanged:: 1.8
689            Add *override* keyword.
690         """
691         logger.debug('[app] adding role: %r', (name, role))
692         if not override and docutils.is_role_registered(name):
693             logger.warning(__('role %r is already registered, it will be overridden'),
694                            name, type='app', subtype='add_role')
695         docutils.register_role(name, role)
696 
697     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
698         """Register a generic Docutils role.
699 
700         Register a Docutils role that does nothing but wrap its contents in the
701         node given by *nodeclass*.
702 
703         If *override* is True, the given *nodeclass* is forcedly installed even if
704         a role named as *name* is already installed.
705 
706         .. versionadded:: 0.6
707         .. versionchanged:: 1.8
708            Add *override* keyword.
709         """
710         # Don't use ``roles.register_generic_role`` because it uses
711         # ``register_canonical_role``.
712         logger.debug('[app] adding generic role: %r', (name, nodeclass))
713         if not override and docutils.is_role_registered(name):
714             logger.warning(__('role %r is already registered, it will be overridden'),
715                            name, type='app', subtype='add_generic_role')
716         role = roles.GenericRole(name, nodeclass)
717         docutils.register_role(name, role)
718 
719     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
720         """Register a domain.
721 
722         :param domain: A domain class
723         :param override: If true, install the domain forcedly even if another domain
724                          is already installed as the same name
725 
726         .. versionadded:: 1.0
727         .. versionchanged:: 1.8
728            Add *override* keyword.
729         """
730         self.registry.add_domain(domain, override=override)
731 
732     def add_directive_to_domain(self, domain: str, name: str,
733                                 cls: Type[Directive], override: bool = False) -> None:
734         """Register a Docutils directive in a domain.
735 
736         Like :meth:`add_directive`, but the directive is added to the domain
737         named *domain*.
738 
739         :param domain: The name of target domain
740         :param name: A name of directive
741         :param cls: A directive class
742         :param override: If true, install the directive forcedly even if another directive
743                          is already installed as the same name
744 
745         .. versionadded:: 1.0
746         .. versionchanged:: 1.8
747            Add *override* keyword.
748         """
749         self.registry.add_directive_to_domain(domain, name, cls, override=override)
750 
751     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
752                            override: bool = False) -> None:
753         """Register a Docutils role in a domain.
754 
755         Like :meth:`add_role`, but the role is added to the domain named
756         *domain*.
757 
758         :param domain: The name of the target domain
759         :param name: The name of the role
760         :param role: The role function
761         :param override: If true, install the role forcedly even if another role is already
762                          installed as the same name
763 
764         .. versionadded:: 1.0
765         .. versionchanged:: 1.8
766            Add *override* keyword.
767         """
768         self.registry.add_role_to_domain(domain, name, role, override=override)
769 
770     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False
771                             ) -> None:
772         """Register a custom index for a domain.
773 
774         Add a custom *index* class to the domain named *domain*.
775 
776         :param domain: The name of the target domain
777         :param index: The index class
778         :param override: If true, install the index forcedly even if another index is
779                          already installed as the same name
780 
781         .. versionadded:: 1.0
782         .. versionchanged:: 1.8
783            Add *override* keyword.
784         """
785         self.registry.add_index_to_domain(domain, index)
786 
787     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
788                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
789                         objname: str = '', doc_field_types: List = [], override: bool = False
790                         ) -> None:
791         """Register a new object type.
792 
793         This method is a very convenient way to add a new :term:`object` type
794         that can be cross-referenced.  It will do this:
795 
796         - Create a new directive (called *directivename*) for documenting an
797           object.  It will automatically add index entries if *indextemplate*
798           is nonempty; if given, it must contain exactly one instance of
799           ``%s``.  See the example below for how the template will be
800           interpreted.
801         - Create a new role (called *rolename*) to cross-reference to these
802           object descriptions.
803         - If you provide *parse_node*, it must be a function that takes a
804           string and a docutils node, and it must populate the node with
805           children parsed from the string.  It must then return the name of the
806           item to be used in cross-referencing and index entries.  See the
807           :file:`conf.py` file in the source for this documentation for an
808           example.
809         - The *objname* (if not given, will default to *directivename*) names
810           the type of object.  It is used when listing objects, e.g. in search
811           results.
812 
813         For example, if you have this call in a custom Sphinx extension::
814 
815            app.add_object_type('directive', 'dir', 'pair: %s; directive')
816 
817         you can use this markup in your documents::
818 
819            .. rst:directive:: function
820 
821               Document a function.
822 
823            <...>
824 
825            See also the :rst:dir:`function` directive.
826 
827         For the directive, an index entry will be generated as if you had prepended ::
828 
829            .. index:: pair: function; directive
830 
831         The reference node will be of class ``literal`` (so it will be rendered
832         in a proportional font, as appropriate for code) unless you give the
833         *ref_nodeclass* argument, which must be a docutils node class.  Most
834         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
835         you can also use ``docutils.nodes.generated`` if you want no further
836         text decoration.  If the text should be treated as literal (e.g. no
837         smart quote replacement), but not have typewriter styling, use
838         ``sphinx.addnodes.literal_emphasis`` or
839         ``sphinx.addnodes.literal_strong``.
840 
841         For the role content, you have the same syntactical possibilities as
842         for standard Sphinx roles (see :ref:`xref-syntax`).
843 
844         If *override* is True, the given object_type is forcedly installed even if
845         an object_type having the same name is already installed.
846 
847         .. versionchanged:: 1.8
848            Add *override* keyword.
849         """
850         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
851                                       ref_nodeclass, objname, doc_field_types,
852                                       override=override)
853 
854     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
855                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
856                           override: bool = False) -> None:
857         """Register a new crossref object type.
858 
859         This method is very similar to :meth:`add_object_type` except that the
860         directive it generates must be empty, and will produce no output.
861 
862         That means that you can add semantic targets to your sources, and refer
863         to them using custom roles instead of generic ones (like
864         :rst:role:`ref`).  Example call::
865 
866            app.add_crossref_type('topic', 'topic', 'single: %s',
867                                  docutils.nodes.emphasis)
868 
869         Example usage::
870 
871            .. topic:: application API
872 
873            The application API
874            -------------------
875 
876            Some random text here.
877 
878            See also :topic:`this section <application API>`.
879 
880         (Of course, the element following the ``topic`` directive needn't be a
881         section.)
882 
883         If *override* is True, the given crossref_type is forcedly installed even if
884         a crossref_type having the same name is already installed.
885 
886         .. versionchanged:: 1.8
887            Add *override* keyword.
888         """
889         self.registry.add_crossref_type(directivename, rolename,
890                                         indextemplate, ref_nodeclass, objname,
891                                         override=override)
892 
893     def add_transform(self, transform: Type[Transform]) -> None:
894         """Register a Docutils transform to be applied after parsing.
895 
896         Add the standard docutils :class:`Transform` subclass *transform* to
897         the list of transforms that are applied after Sphinx parses a reST
898         document.
899 
900         :param transform: A transform class
901 
902         .. list-table:: priority range categories for Sphinx transforms
903            :widths: 20,80
904 
905            * - Priority
906              - Main purpose in Sphinx
907            * - 0-99
908              - Fix invalid nodes by docutils. Translate a doctree.
909            * - 100-299
910              - Preparation
911            * - 300-399
912              - early
913            * - 400-699
914              - main
915            * - 700-799
916              - Post processing. Deadline to modify text and referencing.
917            * - 800-899
918              - Collect referencing and referenced nodes. Domain processing.
919            * - 900-999
920              - Finalize and clean up.
921 
922         refs: `Transform Priority Range Categories`__
923 
924         __ https://docutils.sourceforge.io/docs/ref/transforms.html#transform-priority-range-categories
925         """  # NOQA
926         self.registry.add_transform(transform)
927 
928     def add_post_transform(self, transform: Type[Transform]) -> None:
929         """Register a Docutils transform to be applied before writing.
930 
931         Add the standard docutils :class:`Transform` subclass *transform* to
932         the list of transforms that are applied before Sphinx writes a
933         document.
934 
935         :param transform: A transform class
936         """
937         self.registry.add_post_transform(transform)
938 
939     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
940         """Register a JavaScript file to include in the HTML output.
941 
942         Add *filename* to the list of JavaScript files that the default HTML
943         template will include in order of *priority* (ascending).  The filename
944         must be relative to the HTML static path , or a full URI with scheme.
945         If the priority of the JavaScript file is the same as others, the JavaScript
946         files will be included in order of registration.  If the keyword
947         argument ``body`` is given, its value will be added between the
948         ``<script>`` tags. Extra keyword arguments are included as attributes of
949         the ``<script>`` tag.
950 
951         Example::
952 
953             app.add_js_file('example.js')
954             # => <script src="_static/example.js"></script>
955 
956             app.add_js_file('example.js', async="async")
957             # => <script src="_static/example.js" async="async"></script>
958 
959             app.add_js_file(None, body="var myVariable = 'foo';")
960             # => <script>var myVariable = 'foo';</script>
961 
962         .. list-table:: priority range for JavaScript files
963            :widths: 20,80
964 
965            * - Priority
966              - Main purpose in Sphinx
967            * - 200
968              - default priority for built-in JavaScript files
969            * - 500
970              - default priority for extensions
971            * - 800
972              - default priority for :confval:`html_js_files`
973 
974         A JavaScript file can be added to the specific HTML page when an extension
975         calls this method on :event:`html-page-context` event.
976 
977         .. versionadded:: 0.5
978 
979         .. versionchanged:: 1.8
980            Renamed from ``app.add_javascript()``.
981            And it allows keyword arguments as attributes of script tag.
982 
983         .. versionchanged:: 3.5
984            Take priority argument.  Allow to add a JavaScript file to the specific page.
985         """
986         self.registry.add_js_file(filename, priority=priority, **kwargs)
987         if hasattr(self.builder, 'add_js_file'):
988             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore
989 
990     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
991         """Register a stylesheet to include in the HTML output.
992 
993         Add *filename* to the list of CSS files that the default HTML template
994         will include in order of *priority* (ascending).  The filename must be
995         relative to the HTML static path, or a full URI with scheme.  If the
996         priority of the CSS file is the same as others, the CSS files will be
997         included in order of registration.  The keyword arguments are also
998         accepted for attributes of ``<link>`` tag.
999 
1000         Example::
1001 
1002             app.add_css_file('custom.css')
1003             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
1004 
1005             app.add_css_file('print.css', media='print')
1006             # => <link rel="stylesheet" href="_static/print.css"
1007             #          type="text/css" media="print" />
1008 
1009             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
1010             # => <link rel="alternate stylesheet" href="_static/fancy.css"
1011             #          type="text/css" title="fancy" />
1012 
1013         .. list-table:: priority range for CSS files
1014            :widths: 20,80
1015 
1016            * - Priority
1017              - Main purpose in Sphinx
1018            * - 200
1019              - default priority for built-in CSS files
1020            * - 500
1021              - default priority for extensions
1022            * - 800
1023              - default priority for :confval:`html_css_files`
1024 
1025         A CSS file can be added to the specific HTML page when an extension calls
1026         this method on :event:`html-page-context` event.
1027 
1028         .. versionadded:: 1.0
1029 
1030         .. versionchanged:: 1.6
1031            Optional ``alternate`` and/or ``title`` attributes can be supplied
1032            with the arguments *alternate* (a Boolean) and *title* (a string).
1033            The default is no title and *alternate* = ``False``. For
1034            more information, refer to the `documentation
1035            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
1036 
1037         .. versionchanged:: 1.8
1038            Renamed from ``app.add_stylesheet()``.
1039            And it allows keyword arguments as attributes of link tag.
1040 
1041         .. versionchanged:: 3.5
1042            Take priority argument.  Allow to add a CSS file to the specific page.
1043         """
1044         logger.debug('[app] adding stylesheet: %r', filename)
1045         self.registry.add_css_files(filename, priority=priority, **kwargs)
1046         if hasattr(self.builder, 'add_css_file'):
1047             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore
1048 
1049     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
1050                        ) -> None:
1051         """An alias of :meth:`add_css_file`.
1052 
1053         .. deprecated:: 1.8
1054         """
1055         logger.warning('The app.add_stylesheet() is deprecated. '
1056                        'Please use app.add_css_file() instead.')
1057 
1058         attributes = {}  # type: Dict[str, Any]
1059         if alternate:
1060             attributes['rel'] = 'alternate stylesheet'
1061         else:
1062             attributes['rel'] = 'stylesheet'
1063 
1064         if title:
1065             attributes['title'] = title
1066 
1067         self.add_css_file(filename, **attributes)
1068 
1069     def add_latex_package(self, packagename: str, options: str = None,
1070                           after_hyperref: bool = False) -> None:
1071         r"""Register a package to include in the LaTeX source code.
1072 
1073         Add *packagename* to the list of packages that LaTeX source code will
1074         include.  If you provide *options*, it will be taken to the `\usepackage`
1075         declaration.  If you set *after_hyperref* truthy, the package will be
1076         loaded after ``hyperref`` package.
1077 
1078         .. code-block:: python
1079 
1080            app.add_latex_package('mypackage')
1081            # => \usepackage{mypackage}
1082            app.add_latex_package('mypackage', 'foo,bar')
1083            # => \usepackage[foo,bar]{mypackage}
1084 
1085         .. versionadded:: 1.3
1086         .. versionadded:: 3.1
1087 
1088            *after_hyperref* option.
1089         """
1090         self.registry.add_latex_package(packagename, options, after_hyperref)
1091 
1092     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:
1093         """Register a new lexer for source code.
1094 
1095         Use *lexer* to highlight code blocks with the given language *alias*.
1096 
1097         .. versionadded:: 0.6
1098         .. versionchanged:: 2.1
1099            Take a lexer class as an argument.  An instance of lexers are
1100            still supported until Sphinx-3.x.
1101         """
1102         logger.debug('[app] adding lexer: %r', (alias, lexer))
1103         lexer_classes[alias] = lexer
1104 
1105     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1106         """Register a new documenter class for the autodoc extension.
1107 
1108         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1109         extension.  It must be a subclass of
1110         :class:`sphinx.ext.autodoc.Documenter`.  This allows auto-documenting
1111         new types of objects.  See the source of the autodoc module for
1112         examples on how to subclass :class:`Documenter`.
1113 
1114         If *override* is True, the given *cls* is forcedly installed even if
1115         a documenter having the same name is already installed.
1116 
1117         See :ref:`autodoc_ext_tutorial`.
1118 
1119         .. versionadded:: 0.6
1120         .. versionchanged:: 2.2
1121            Add *override* keyword.
1122         """
1123         logger.debug('[app] adding autodocumenter: %r', cls)
1124         from sphinx.ext.autodoc.directive import AutodocDirective
1125         self.registry.add_documenter(cls.objtype, cls)
1126         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1127 
1128     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]
1129                                ) -> None:
1130         """Register a new ``getattr``-like function for the autodoc extension.
1131 
1132         Add *getter*, which must be a function with an interface compatible to
1133         the :func:`getattr` builtin, as the autodoc attribute getter for
1134         objects that are instances of *typ*.  All cases where autodoc needs to
1135         get an attribute of a type are then handled by this function instead of
1136         :func:`getattr`.
1137 
1138         .. versionadded:: 0.6
1139         """
1140         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1141         self.registry.add_autodoc_attrgetter(typ, getter)
1142 
1143     def add_search_language(self, cls: Any) -> None:
1144         """Register a new language for the HTML search index.
1145 
1146         Add *cls*, which must be a subclass of
1147         :class:`sphinx.search.SearchLanguage`, as a support language for
1148         building the HTML full-text search index.  The class must have a *lang*
1149         attribute that indicates the language it should be used for.  See
1150         :confval:`html_search_language`.
1151 
1152         .. versionadded:: 1.1
1153         """
1154         logger.debug('[app] adding search language: %r', cls)
1155         from sphinx.search import SearchLanguage, languages
1156         assert issubclass(cls, SearchLanguage)
1157         languages[cls.lang] = cls
1158 
1159     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1160         """Register a suffix of source files.
1161 
1162         Same as :confval:`source_suffix`.  The users can override this
1163         using the config setting.
1164 
1165         If *override* is True, the given *suffix* is forcedly installed even if
1166         the same suffix is already installed.
1167 
1168         .. versionadded:: 1.8
1169         """
1170         self.registry.add_source_suffix(suffix, filetype, override=override)
1171 
1172     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
1173         """Register a parser class.
1174 
1175         If *override* is True, the given *parser* is forcedly installed even if
1176         a parser for the same suffix is already installed.
1177 
1178         .. versionadded:: 1.4
1179         .. versionchanged:: 1.8
1180            *suffix* argument is deprecated.  It only accepts *parser* argument.
1181            Use :meth:`add_source_suffix` API to register suffix instead.
1182         .. versionchanged:: 1.8
1183            Add *override* keyword.
1184         """
1185         self.registry.add_source_parser(parser, override=override)
1186 
1187     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:
1188         """Register an environment collector class.
1189 
1190         Refer to :ref:`collector-api`.
1191 
1192         .. versionadded:: 1.6
1193         """
1194         logger.debug('[app] adding environment collector: %r', collector)
1195         collector().enable(self)
1196 
1197     def add_html_theme(self, name: str, theme_path: str) -> None:
1198         """Register a HTML Theme.
1199 
1200         The *name* is a name of theme, and *theme_path* is a full path to the
1201         theme (refs: :ref:`distribute-your-theme`).
1202 
1203         .. versionadded:: 1.6
1204         """
1205         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1206         self.registry.add_html_theme(name, theme_path)
1207 
1208     def add_html_math_renderer(self, name: str,
1209                                inline_renderers: Tuple[Callable, Callable] = None,
1210                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1211         """Register a math renderer for HTML.
1212 
1213         The *name* is a name of math renderer.  Both *inline_renderers* and
1214         *block_renderers* are used as visitor functions for the HTML writer:
1215         the former for inline math node (``nodes.math``), the latter for
1216         block math node (``nodes.math_block``).  Regarding visitor functions,
1217         see :meth:`add_node` for details.
1218 
1219         .. versionadded:: 1.8
1220 
1221         """
1222         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1223 
1224     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1225         """Register a message catalog.
1226 
1227         :param catalog: The name of the catalog
1228         :param locale_dir: The base path of the message catalog
1229 
1230         For more details, see :func:`sphinx.locale.get_translation()`.
1231 
1232         .. versionadded:: 1.8
1233         """
1234         locale.init([locale_dir], self.config.language, catalog)
1235         locale.init_console(locale_dir, catalog)
1236 
1237     # ---- other methods -------------------------------------------------
1238     def is_parallel_allowed(self, typ: str) -> bool:
1239         """Check whether parallel processing is allowed or not.
1240 
1241         :param typ: A type of processing; ``'read'`` or ``'write'``.
1242         """
1243         if typ == 'read':
1244             attrname = 'parallel_read_safe'
1245             message_not_declared = __("the %s extension does not declare if it "
1246                                       "is safe for parallel reading, assuming "
1247                                       "it isn't - please ask the extension author "
1248                                       "to check and make it explicit")
1249             message_not_safe = __("the %s extension is not safe for parallel reading")
1250         elif typ == 'write':
1251             attrname = 'parallel_write_safe'
1252             message_not_declared = __("the %s extension does not declare if it "
1253                                       "is safe for parallel writing, assuming "
1254                                       "it isn't - please ask the extension author "
1255                                       "to check and make it explicit")
1256             message_not_safe = __("the %s extension is not safe for parallel writing")
1257         else:
1258             raise ValueError('parallel type %s is not supported' % typ)
1259 
1260         for ext in self.extensions.values():
1261             allowed = getattr(ext, attrname, None)
1262             if allowed is None:
1263                 logger.warning(message_not_declared, ext.name)
1264                 logger.warning(__('doing serial %s'), typ)
1265                 return False
1266             elif not allowed:
1267                 logger.warning(message_not_safe, ext.name)
1268                 logger.warning(__('doing serial %s'), typ)
1269                 return False
1270 
1271         return True
1272 
1273     def set_html_assets_policy(self, policy):
1274         """Set the policy to include assets in HTML pages.
1275 
1276         - always: include the assets in all the pages
1277         - per_page: include the assets only in pages where they are used
1278 
1279         .. versionadded: 4.1
1280         """
1281         if policy not in ('always', 'per_page'):
1282             raise ValueError('policy %s is not supported' % policy)
1283         self.registry.html_assets_policy = policy
1284 
1285     @property
1286     def html_themes(self) -> Dict[str, str]:
1287         warnings.warn('app.html_themes is deprecated.',
1288                       RemovedInSphinx60Warning)
1289         return self.registry.html_themes
1290 
1291 
1292 class TemplateBridge:
1293     """
1294     This class defines the interface for a "template bridge", that is, a class
1295     that renders templates given a template name and a context.
1296     """
1297 
1298     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1299         """Called by the builder to initialize the template system.
1300 
1301         *builder* is the builder object; you'll probably want to look at the
1302         value of ``builder.config.templates_path``.
1303 
1304         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1305         case, *dirs* can be list of fixed directories to look for templates.
1306         """
1307         raise NotImplementedError('must be implemented in subclasses')
1308 
1309     def newest_template_mtime(self) -> float:
1310         """Called by the builder to determine if output files are outdated
1311         because of template changes.  Return the mtime of the newest template
1312         file that was changed.  The default implementation returns ``0``.
1313         """
1314         return 0
1315 
1316     def render(self, template: str, context: Dict) -> None:
1317         """Called by the builder to render a template given as a filename with
1318         a specified context (a Python dictionary).
1319         """
1320         raise NotImplementedError('must be implemented in subclasses')
1321 
1322     def render_string(self, template: str, context: Dict) -> str:
1323         """Called by the builder to render a template given as a string with a
1324         specified context (a Python dictionary).
1325         """
1326         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>The code responsible for comparing extension versions should accurately perform semantic version comparison, ensuring proper interpretation of version numbers. Modifications should include parsing version strings into numerically comparable parts or utilizing libraries designed for semantic version comparison, such as Python's pkg_resources.parse_version or the packaging library, without compromising existing functionality.</intended_behavior>]
2025-10-18 07:25:27.436 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 07:25:27.436 | INFO     | Search-only: skipping patch selection
2025-10-18 07:25:27.550 | INFO     | Task sphinx-doc__sphinx-9711 completed successfully.
2025-10-18 07:25:27.551 | INFO     | No patch generated. You can try running ACR again.
