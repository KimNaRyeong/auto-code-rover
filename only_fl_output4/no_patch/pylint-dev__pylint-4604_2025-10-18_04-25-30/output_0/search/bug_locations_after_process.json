[
    {
        "rel_file_path": "pylint/checkers/imports.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/checkers/imports.py",
        "start": 1,
        "end": 1017,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2006-2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2012-2014 Google, Inc.\n3 # Copyright (c) 2013 buck@yelp.com <buck@yelp.com>\n4 # Copyright (c) 2014-2020 Claudiu Popa <pcmanticore@gmail.com>\n5 # Copyright (c) 2014 Brett Cannon <brett@python.org>\n6 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n7 # Copyright (c) 2015-2016 Moises Lopez <moylop260@vauxoo.com>\n8 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>\n9 # Copyright (c) 2015 Cezar <celnazli@bitdefender.com>\n10 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>\n11 # Copyright (c) 2015 Noam Yorav-Raphael <noamraph@gmail.com>\n12 # Copyright (c) 2015 James Morgensen <james.morgensen@gmail.com>\n13 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n14 # Copyright (c) 2016 Jared Garst <cultofjared@gmail.com>\n15 # Copyright (c) 2016 Maik R\u00f6der <maikroeder@gmail.com>\n16 # Copyright (c) 2016 Glenn Matthews <glenn@e-dad.net>\n17 # Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>\n18 # Copyright (c) 2017, 2020 hippo91 <guillaume.peillex@gmail.com>\n19 # Copyright (c) 2017 Michka Popoff <michkapopoff@gmail.com>\n20 # Copyright (c) 2017 \u0141ukasz Rogalski <rogalski.91@gmail.com>\n21 # Copyright (c) 2017 Erik Wright <erik.wright@shopify.com>\n22 # Copyright (c) 2018 Lucas Cimon <lucas.cimon@gmail.com>\n23 # Copyright (c) 2018 Hornwitser <github@hornwitser.no>\n24 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n25 # Copyright (c) 2018 Natalie Serebryakova <natalie.serebryakova@Natalies-MacBook-Pro.local>\n26 # Copyright (c) 2018 Mike Frysinger <vapier@gmail.com>\n27 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>\n28 # Copyright (c) 2018 Marianna Polatoglou <mpolatoglou@bloomberg.net>\n29 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n30 # Copyright (c) 2019 Nick Drozd <nicholasdrozd@gmail.com>\n31 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>\n32 # Copyright (c) 2019 Nick Smith <clickthisnick@users.noreply.github.com>\n33 # Copyright (c) 2019 Paul Renvois\u00e9 <renvoisepaul@gmail.com>\n34 # Copyright (c) 2020 Peter Kolbus <peter.kolbus@gmail.com>\n35 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>\n36 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>\n37 # Copyright (c) 2021 yushao2 <36848472+yushao2@users.noreply.github.com>\n38 # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n39 # Copyright (c) 2021 Matus Valo <matusvalo@users.noreply.github.com>\n40 # Copyright (c) 2021 Andrew Howe <howeaj@users.noreply.github.com>\n41 \n42 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n43 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n44 \n45 \"\"\"imports checkers for Python code\"\"\"\n46 \n47 import collections\n48 import copy\n49 import os\n50 import sys\n51 from distutils import sysconfig\n52 from typing import Dict, List, Union\n53 \n54 import astroid\n55 \n56 from pylint.checkers import BaseChecker, DeprecatedMixin\n57 from pylint.checkers.utils import (\n58     check_messages,\n59     is_from_fallback_block,\n60     node_ignores_exception,\n61 )\n62 from pylint.exceptions import EmptyReportError\n63 from pylint.graph import DotBackend, get_cycles\n64 from pylint.interfaces import IAstroidChecker\n65 from pylint.reporters.ureports.nodes import Paragraph, VerbatimText, VNode\n66 from pylint.utils import IsortDriver, get_global_option\n67 \n68 \n69 def _qualified_names(modname):\n70     \"\"\"Split the names of the given module into subparts\n71 \n72     For example,\n73         _qualified_names('pylint.checkers.ImportsChecker')\n74     returns\n75         ['pylint', 'pylint.checkers', 'pylint.checkers.ImportsChecker']\n76     \"\"\"\n77     names = modname.split(\".\")\n78     return [\".\".join(names[0 : i + 1]) for i in range(len(names))]\n79 \n80 \n81 def _get_import_name(importnode, modname):\n82     \"\"\"Get a prepared module name from the given import node\n83 \n84     In the case of relative imports, this will return the\n85     absolute qualified module name, which might be useful\n86     for debugging. Otherwise, the initial module name\n87     is returned unchanged.\n88     \"\"\"\n89     if isinstance(importnode, astroid.ImportFrom):\n90         if importnode.level:\n91             root = importnode.root()\n92             if isinstance(root, astroid.Module):\n93                 modname = root.relative_to_absolute_name(\n94                     modname, level=importnode.level\n95                 )\n96     return modname\n97 \n98 \n99 def _get_first_import(node, context, name, base, level, alias):\n100     \"\"\"return the node where [base.]<name> is imported or None if not found\"\"\"\n101     fullname = f\"{base}.{name}\" if base else name\n102 \n103     first = None\n104     found = False\n105     for first in context.body:\n106         if first is node:\n107             continue\n108         if first.scope() is node.scope() and first.fromlineno > node.fromlineno:\n109             continue\n110         if isinstance(first, astroid.Import):\n111             if any(fullname == iname[0] for iname in first.names):\n112                 found = True\n113                 break\n114         elif isinstance(first, astroid.ImportFrom):\n115             if level == first.level:\n116                 for imported_name, imported_alias in first.names:\n117                     if fullname == f\"{first.modname}.{imported_name}\":\n118                         found = True\n119                         break\n120                     if (\n121                         name != \"*\"\n122                         and name == imported_name\n123                         and not (alias or imported_alias)\n124                     ):\n125                         found = True\n126                         break\n127                 if found:\n128                     break\n129     if found and not astroid.are_exclusive(first, node):\n130         return first\n131     return None\n132 \n133 \n134 def _ignore_import_failure(node, modname, ignored_modules):\n135     for submodule in _qualified_names(modname):\n136         if submodule in ignored_modules:\n137             return True\n138 \n139     # ignore import failure if guarded by `sys.version_info` test\n140     if isinstance(node.parent, astroid.If) and isinstance(\n141         node.parent.test, astroid.Compare\n142     ):\n143         value = node.parent.test.left\n144         if isinstance(value, astroid.Subscript):\n145             value = value.value\n146         if (\n147             isinstance(value, astroid.Attribute)\n148             and value.as_string() == \"sys.version_info\"\n149         ):\n150             return True\n151 \n152     return node_ignores_exception(node, ImportError)\n153 \n154 \n155 # utilities to represents import dependencies as tree and dot graph ###########\n156 \n157 \n158 def _make_tree_defs(mod_files_list):\n159     \"\"\"get a list of 2-uple (module, list_of_files_which_import_this_module),\n160     it will return a dictionary to represent this as a tree\n161     \"\"\"\n162     tree_defs = {}\n163     for mod, files in mod_files_list:\n164         node = (tree_defs, ())\n165         for prefix in mod.split(\".\"):\n166             node = node[0].setdefault(prefix, [{}, []])\n167         node[1] += files\n168     return tree_defs\n169 \n170 \n171 def _repr_tree_defs(data, indent_str=None):\n172     \"\"\"return a string which represents imports as a tree\"\"\"\n173     lines = []\n174     nodes = data.items()\n175     for i, (mod, (sub, files)) in enumerate(sorted(nodes, key=lambda x: x[0])):\n176         if not files:\n177             files = \"\"\n178         else:\n179             files = \"(%s)\" % \",\".join(sorted(files))\n180         if indent_str is None:\n181             lines.append(f\"{mod} {files}\")\n182             sub_indent_str = \"  \"\n183         else:\n184             lines.append(fr\"{indent_str}\\-{mod} {files}\")\n185             if i == len(nodes) - 1:\n186                 sub_indent_str = \"%s  \" % indent_str\n187             else:\n188                 sub_indent_str = \"%s| \" % indent_str\n189         if sub:\n190             lines.append(_repr_tree_defs(sub, sub_indent_str))\n191     return \"\\n\".join(lines)\n192 \n193 \n194 def _dependencies_graph(filename: str, dep_info: Dict[str, List[str]]) -> str:\n195     \"\"\"write dependencies as a dot (graphviz) file\"\"\"\n196     done = {}\n197     printer = DotBackend(os.path.splitext(os.path.basename(filename))[0], rankdir=\"LR\")\n198     printer.emit('URL=\".\" node[shape=\"box\"]')\n199     for modname, dependencies in sorted(dep_info.items()):\n200         done[modname] = 1\n201         printer.emit_node(modname)\n202         for depmodname in dependencies:\n203             if depmodname not in done:\n204                 done[depmodname] = 1\n205                 printer.emit_node(depmodname)\n206     for depmodname, dependencies in sorted(dep_info.items()):\n207         for modname in dependencies:\n208             printer.emit_edge(modname, depmodname)\n209     return printer.generate(filename)\n210 \n211 \n212 def _make_graph(filename: str, dep_info: Dict[str, List[str]], sect: VNode, gtype: str):\n213     \"\"\"generate a dependencies graph and add some information about it in the\n214     report's section\n215     \"\"\"\n216     outputfile = _dependencies_graph(filename, dep_info)\n217     sect.append(Paragraph(f\"{gtype}imports graph has been written to {outputfile}\"))\n218 \n219 \n220 # the import checker itself ###################################################\n221 \n222 MSGS = {\n223     \"E0401\": (\n224         \"Unable to import %s\",\n225         \"import-error\",\n226         \"Used when pylint has been unable to import a module.\",\n227         {\"old_names\": [(\"F0401\", \"old-import-error\")]},\n228     ),\n229     \"E0402\": (\n230         \"Attempted relative import beyond top-level package\",\n231         \"relative-beyond-top-level\",\n232         \"Used when a relative import tries to access too many levels \"\n233         \"in the current package.\",\n234     ),\n235     \"R0401\": (\n236         \"Cyclic import (%s)\",\n237         \"cyclic-import\",\n238         \"Used when a cyclic import between two or more modules is detected.\",\n239     ),\n240     \"R0402\": (\n241         \"Use 'from %s import %s' instead\",\n242         \"consider-using-from-import\",\n243         \"Emitted when a submodule/member of a package is imported and \"\n244         \"aliased with the same name. \"\n245         \"E.g., instead of ``import pandas.DataFrame as DataFrame`` use \"\n246         \"``from pandas import DataFrame``\",\n247     ),\n248     \"W0401\": (\n249         \"Wildcard import %s\",\n250         \"wildcard-import\",\n251         \"Used when `from module import *` is detected.\",\n252     ),\n253     \"W0402\": (\n254         \"Uses of a deprecated module %r\",\n255         \"deprecated-module\",\n256         \"Used a module marked as deprecated is imported.\",\n257     ),\n258     \"W0404\": (\n259         \"Reimport %r (imported line %s)\",\n260         \"reimported\",\n261         \"Used when a module is reimported multiple times.\",\n262     ),\n263     \"W0406\": (\n264         \"Module import itself\",\n265         \"import-self\",\n266         \"Used when a module is importing itself.\",\n267     ),\n268     \"W0407\": (\n269         \"Prefer importing %r instead of %r\",\n270         \"preferred-module\",\n271         \"Used when a module imported has a preferred replacement module.\",\n272     ),\n273     \"W0410\": (\n274         \"__future__ import is not the first non docstring statement\",\n275         \"misplaced-future\",\n276         \"Python 2.5 and greater require __future__ import to be the \"\n277         \"first non docstring statement in the module.\",\n278     ),\n279     \"C0410\": (\n280         \"Multiple imports on one line (%s)\",\n281         \"multiple-imports\",\n282         \"Used when import statement importing multiple modules is detected.\",\n283     ),\n284     \"C0411\": (\n285         \"%s should be placed before %s\",\n286         \"wrong-import-order\",\n287         \"Used when PEP8 import order is not respected (standard imports \"\n288         \"first, then third-party libraries, then local imports)\",\n289     ),\n290     \"C0412\": (\n291         \"Imports from package %s are not grouped\",\n292         \"ungrouped-imports\",\n293         \"Used when imports are not grouped by packages\",\n294     ),\n295     \"C0413\": (\n296         'Import \"%s\" should be placed at the top of the module',\n297         \"wrong-import-position\",\n298         \"Used when code and imports are mixed\",\n299     ),\n300     \"C0414\": (\n301         \"Import alias does not rename original package\",\n302         \"useless-import-alias\",\n303         \"Used when an import alias is same as original package.\"\n304         \"e.g using import numpy as numpy instead of import numpy as np\",\n305     ),\n306     \"C0415\": (\n307         \"Import outside toplevel (%s)\",\n308         \"import-outside-toplevel\",\n309         \"Used when an import statement is used anywhere other than the module \"\n310         \"toplevel. Move this import to the top of the file.\",\n311     ),\n312 }\n313 \n314 \n315 DEFAULT_STANDARD_LIBRARY = ()\n316 DEFAULT_KNOWN_THIRD_PARTY = (\"enchant\",)\n317 DEFAULT_PREFERRED_MODULES = ()\n318 \n319 \n320 class ImportsChecker(DeprecatedMixin, BaseChecker):\n321     \"\"\"checks for\n322     * external modules dependencies\n323     * relative / wildcard imports\n324     * cyclic imports\n325     * uses of deprecated modules\n326     * uses of modules instead of preferred modules\n327     \"\"\"\n328 \n329     __implements__ = IAstroidChecker\n330 \n331     name = \"imports\"\n332     msgs = MSGS\n333     priority = -2\n334     default_deprecated_modules = ()\n335 \n336     options = (\n337         (\n338             \"deprecated-modules\",\n339             {\n340                 \"default\": default_deprecated_modules,\n341                 \"type\": \"csv\",\n342                 \"metavar\": \"<modules>\",\n343                 \"help\": \"Deprecated modules which should not be used,\"\n344                 \" separated by a comma.\",\n345             },\n346         ),\n347         (\n348             \"preferred-modules\",\n349             {\n350                 \"default\": DEFAULT_PREFERRED_MODULES,\n351                 \"type\": \"csv\",\n352                 \"metavar\": \"<module:preferred-module>\",\n353                 \"help\": \"Couples of modules and preferred modules,\"\n354                 \" separated by a comma.\",\n355             },\n356         ),\n357         (\n358             \"import-graph\",\n359             {\n360                 \"default\": \"\",\n361                 \"type\": \"string\",\n362                 \"metavar\": \"<file.gv>\",\n363                 \"help\": \"Output a graph (.gv or any supported image format) of\"\n364                 \" all (i.e. internal and external) dependencies to the given file\"\n365                 \" (report RP0402 must not be disabled).\",\n366             },\n367         ),\n368         (\n369             \"ext-import-graph\",\n370             {\n371                 \"default\": \"\",\n372                 \"type\": \"string\",\n373                 \"metavar\": \"<file.gv>\",\n374                 \"help\": \"Output a graph (.gv or any supported image format)\"\n375                 \" of external dependencies to the given file\"\n376                 \" (report RP0402 must not be disabled).\",\n377             },\n378         ),\n379         (\n380             \"int-import-graph\",\n381             {\n382                 \"default\": \"\",\n383                 \"type\": \"string\",\n384                 \"metavar\": \"<file.gv>\",\n385                 \"help\": \"Output a graph (.gv or any supported image format)\"\n386                 \" of internal dependencies to the given file\"\n387                 \" (report RP0402 must not be disabled).\",\n388             },\n389         ),\n390         (\n391             \"known-standard-library\",\n392             {\n393                 \"default\": DEFAULT_STANDARD_LIBRARY,\n394                 \"type\": \"csv\",\n395                 \"metavar\": \"<modules>\",\n396                 \"help\": \"Force import order to recognize a module as part of \"\n397                 \"the standard compatibility libraries.\",\n398             },\n399         ),\n400         (\n401             \"known-third-party\",\n402             {\n403                 \"default\": DEFAULT_KNOWN_THIRD_PARTY,\n404                 \"type\": \"csv\",\n405                 \"metavar\": \"<modules>\",\n406                 \"help\": \"Force import order to recognize a module as part of \"\n407                 \"a third party library.\",\n408             },\n409         ),\n410         (\n411             \"allow-any-import-level\",\n412             {\n413                 \"default\": (),\n414                 \"type\": \"csv\",\n415                 \"metavar\": \"<modules>\",\n416                 \"help\": (\n417                     \"List of modules that can be imported at any level, not just \"\n418                     \"the top level one.\"\n419                 ),\n420             },\n421         ),\n422         (\n423             \"analyse-fallback-blocks\",\n424             {\n425                 \"default\": False,\n426                 \"type\": \"yn\",\n427                 \"metavar\": \"<y_or_n>\",\n428                 \"help\": \"Analyse import fallback blocks. This can be used to \"\n429                 \"support both Python 2 and 3 compatible code, which \"\n430                 \"means that the block might have code that exists \"\n431                 \"only in one or another interpreter, leading to false \"\n432                 \"positives when analysed.\",\n433             },\n434         ),\n435         (\n436             \"allow-wildcard-with-all\",\n437             {\n438                 \"default\": False,\n439                 \"type\": \"yn\",\n440                 \"metavar\": \"<y_or_n>\",\n441                 \"help\": \"Allow wildcard imports from modules that define __all__.\",\n442             },\n443         ),\n444     )\n445 \n446     def __init__(self, linter=None):\n447         BaseChecker.__init__(self, linter)\n448         self.stats = None\n449         self.import_graph = None\n450         self._imports_stack = []\n451         self._first_non_import_node = None\n452         self._module_pkg = {}  # mapping of modules to the pkg they belong in\n453         self._allow_any_import_level = set()\n454         self.reports = (\n455             (\"RP0401\", \"External dependencies\", self._report_external_dependencies),\n456             (\"RP0402\", \"Modules dependencies graph\", self._report_dependencies_graph),\n457         )\n458 \n459         self._site_packages = self._compute_site_packages()\n460 \n461     @staticmethod\n462     def _compute_site_packages():\n463         def _normalized_path(path):\n464             return os.path.normcase(os.path.abspath(path))\n465 \n466         paths = set()\n467         real_prefix = getattr(sys, \"real_prefix\", None)\n468         for prefix in filter(None, (real_prefix, sys.prefix)):\n469             path = sysconfig.get_python_lib(prefix=prefix)\n470             path = _normalized_path(path)\n471             paths.add(path)\n472 \n473         # Handle Debian's derivatives /usr/local.\n474         if os.path.isfile(\"/etc/debian_version\"):\n475             for prefix in filter(None, (real_prefix, sys.prefix)):\n476                 libpython = os.path.join(\n477                     prefix,\n478                     \"local\",\n479                     \"lib\",\n480                     \"python\" + sysconfig.get_python_version(),\n481                     \"dist-packages\",\n482                 )\n483                 paths.add(libpython)\n484         return paths\n485 \n486     def open(self):\n487         \"\"\"called before visiting project (i.e set of modules)\"\"\"\n488         self.linter.add_stats(dependencies={})\n489         self.linter.add_stats(cycles=[])\n490         self.stats = self.linter.stats\n491         self.import_graph = collections.defaultdict(set)\n492         self._module_pkg = {}  # mapping of modules to the pkg they belong in\n493         self._excluded_edges = collections.defaultdict(set)\n494         self._ignored_modules = get_global_option(self, \"ignored-modules\", default=[])\n495         # Build a mapping {'module': 'preferred-module'}\n496         self.preferred_modules = dict(\n497             module.split(\":\")\n498             for module in self.config.preferred_modules\n499             if \":\" in module\n500         )\n501         self._allow_any_import_level = set(self.config.allow_any_import_level)\n502 \n503     def _import_graph_without_ignored_edges(self):\n504         filtered_graph = copy.deepcopy(self.import_graph)\n505         for node in filtered_graph:\n506             filtered_graph[node].difference_update(self._excluded_edges[node])\n507         return filtered_graph\n508 \n509     def close(self):\n510         \"\"\"called before visiting project (i.e set of modules)\"\"\"\n511         if self.linter.is_message_enabled(\"cyclic-import\"):\n512             graph = self._import_graph_without_ignored_edges()\n513             vertices = list(graph)\n514             for cycle in get_cycles(graph, vertices=vertices):\n515                 self.add_message(\"cyclic-import\", args=\" -> \".join(cycle))\n516 \n517     def deprecated_modules(self):\n518         \"\"\"Callback returning the deprecated modules.\"\"\"\n519         return self.config.deprecated_modules\n520 \n521     @check_messages(*MSGS)\n522     def visit_import(self, node):\n523         \"\"\"triggered when an import statement is seen\"\"\"\n524         self._check_reimport(node)\n525         self._check_import_as_rename(node)\n526         self._check_toplevel(node)\n527 \n528         names = [name for name, _ in node.names]\n529         if len(names) >= 2:\n530             self.add_message(\"multiple-imports\", args=\", \".join(names), node=node)\n531 \n532         for name in names:\n533             self.check_deprecated_module(node, name)\n534             self._check_preferred_module(node, name)\n535             imported_module = self._get_imported_module(node, name)\n536             if isinstance(node.parent, astroid.Module):\n537                 # Allow imports nested\n538                 self._check_position(node)\n539             if isinstance(node.scope(), astroid.Module):\n540                 self._record_import(node, imported_module)\n541 \n542             if imported_module is None:\n543                 continue\n544 \n545             self._add_imported_module(node, imported_module.name)\n546 \n547     @check_messages(*MSGS)\n548     def visit_importfrom(self, node):\n549         \"\"\"triggered when a from statement is seen\"\"\"\n550         basename = node.modname\n551         imported_module = self._get_imported_module(node, basename)\n552 \n553         self._check_import_as_rename(node)\n554         self._check_misplaced_future(node)\n555         self.check_deprecated_module(node, basename)\n556         self._check_preferred_module(node, basename)\n557         self._check_wildcard_imports(node, imported_module)\n558         self._check_same_line_imports(node)\n559         self._check_reimport(node, basename=basename, level=node.level)\n560         self._check_toplevel(node)\n561 \n562         if isinstance(node.parent, astroid.Module):\n563             # Allow imports nested\n564             self._check_position(node)\n565         if isinstance(node.scope(), astroid.Module):\n566             self._record_import(node, imported_module)\n567         if imported_module is None:\n568             return\n569         for name, _ in node.names:\n570             if name != \"*\":\n571                 self._add_imported_module(node, f\"{imported_module.name}.{name}\")\n572             else:\n573                 self._add_imported_module(node, imported_module.name)\n574 \n575     @check_messages(*MSGS)\n576     def leave_module(self, node):\n577         # Check imports are grouped by category (standard, 3rd party, local)\n578         std_imports, ext_imports, loc_imports = self._check_imports_order(node)\n579 \n580         # Check that imports are grouped by package within a given category\n581         met_import = set()  # set for 'import x' style\n582         met_from = set()  # set for 'from x import y' style\n583         current_package = None\n584         for import_node, import_name in std_imports + ext_imports + loc_imports:\n585             if not self.linter.is_message_enabled(\n586                 \"ungrouped-imports\", import_node.fromlineno\n587             ):\n588                 continue\n589             if isinstance(import_node, astroid.node_classes.ImportFrom):\n590                 met = met_from\n591             else:\n592                 met = met_import\n593             package, _, _ = import_name.partition(\".\")\n594             if current_package and current_package != package and package in met:\n595                 self.add_message(\"ungrouped-imports\", node=import_node, args=package)\n596             current_package = package\n597             met.add(package)\n598 \n599         self._imports_stack = []\n600         self._first_non_import_node = None\n601 \n602     def compute_first_non_import_node(self, node):\n603         if not self.linter.is_message_enabled(\"wrong-import-position\", node.fromlineno):\n604             return\n605         # if the node does not contain an import instruction, and if it is the\n606         # first node of the module, keep a track of it (all the import positions\n607         # of the module will be compared to the position of this first\n608         # instruction)\n609         if self._first_non_import_node:\n610             return\n611         if not isinstance(node.parent, astroid.Module):\n612             return\n613         nested_allowed = [astroid.TryExcept, astroid.TryFinally]\n614         is_nested_allowed = [\n615             allowed for allowed in nested_allowed if isinstance(node, allowed)\n616         ]\n617         if is_nested_allowed and any(\n618             node.nodes_of_class((astroid.Import, astroid.ImportFrom))\n619         ):\n620             return\n621         if isinstance(node, astroid.Assign):\n622             # Add compatibility for module level dunder names\n623             # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names\n624             valid_targets = [\n625                 isinstance(target, astroid.AssignName)\n626                 and target.name.startswith(\"__\")\n627                 and target.name.endswith(\"__\")\n628                 for target in node.targets\n629             ]\n630             if all(valid_targets):\n631                 return\n632         self._first_non_import_node = node\n633 \n634     visit_tryfinally = (\n635         visit_tryexcept\n636     ) = (\n637         visit_assignattr\n638     ) = (\n639         visit_assign\n640     ) = (\n641         visit_ifexp\n642     ) = visit_comprehension = visit_expr = visit_if = compute_first_non_import_node\n643 \n644     def visit_functiondef(self, node):\n645         if not self.linter.is_message_enabled(\"wrong-import-position\", node.fromlineno):\n646             return\n647         # If it is the first non import instruction of the module, record it.\n648         if self._first_non_import_node:\n649             return\n650 \n651         # Check if the node belongs to an `If` or a `Try` block. If they\n652         # contain imports, skip recording this node.\n653         if not isinstance(node.parent.scope(), astroid.Module):\n654             return\n655 \n656         root = node\n657         while not isinstance(root.parent, astroid.Module):\n658             root = root.parent\n659 \n660         if isinstance(root, (astroid.If, astroid.TryFinally, astroid.TryExcept)):\n661             if any(root.nodes_of_class((astroid.Import, astroid.ImportFrom))):\n662                 return\n663 \n664         self._first_non_import_node = node\n665 \n666     visit_classdef = visit_for = visit_while = visit_functiondef\n667 \n668     def _check_misplaced_future(self, node):\n669         basename = node.modname\n670         if basename == \"__future__\":\n671             # check if this is the first non-docstring statement in the module\n672             prev = node.previous_sibling()\n673             if prev:\n674                 # consecutive future statements are possible\n675                 if not (\n676                     isinstance(prev, astroid.ImportFrom)\n677                     and prev.modname == \"__future__\"\n678                 ):\n679                     self.add_message(\"misplaced-future\", node=node)\n680             return\n681 \n682     def _check_same_line_imports(self, node):\n683         # Detect duplicate imports on the same line.\n684         names = (name for name, _ in node.names)\n685         counter = collections.Counter(names)\n686         for name, count in counter.items():\n687             if count > 1:\n688                 self.add_message(\"reimported\", node=node, args=(name, node.fromlineno))\n689 \n690     def _check_position(self, node):\n691         \"\"\"Check `node` import or importfrom node position is correct\n692 \n693         Send a message  if `node` comes before another instruction\n694         \"\"\"\n695         # if a first non-import instruction has already been encountered,\n696         # it means the import comes after it and therefore is not well placed\n697         if self._first_non_import_node:\n698             self.add_message(\"wrong-import-position\", node=node, args=node.as_string())\n699 \n700     def _record_import(self, node, importedmodnode):\n701         \"\"\"Record the package `node` imports from\"\"\"\n702         if isinstance(node, astroid.ImportFrom):\n703             importedname = node.modname\n704         else:\n705             importedname = importedmodnode.name if importedmodnode else None\n706         if not importedname:\n707             importedname = node.names[0][0].split(\".\")[0]\n708 \n709         if isinstance(node, astroid.ImportFrom) and (node.level or 0) >= 1:\n710             # We need the importedname with first point to detect local package\n711             # Example of node:\n712             #  'from .my_package1 import MyClass1'\n713             #  the output should be '.my_package1' instead of 'my_package1'\n714             # Example of node:\n715             #  'from . import my_package2'\n716             #  the output should be '.my_package2' instead of '{pyfile}'\n717             importedname = \".\" + importedname\n718 \n719         self._imports_stack.append((node, importedname))\n720 \n721     @staticmethod\n722     def _is_fallback_import(node, imports):\n723         imports = [import_node for (import_node, _) in imports]\n724         return any(astroid.are_exclusive(import_node, node) for import_node in imports)\n725 \n726     def _check_imports_order(self, _module_node):\n727         \"\"\"Checks imports of module `node` are grouped by category\n728 \n729         Imports must follow this order: standard, 3rd party, local\n730         \"\"\"\n731         std_imports = []\n732         third_party_imports = []\n733         first_party_imports = []\n734         # need of a list that holds third or first party ordered import\n735         external_imports = []\n736         local_imports = []\n737         third_party_not_ignored = []\n738         first_party_not_ignored = []\n739         local_not_ignored = []\n740         isort_driver = IsortDriver(self.config)\n741         for node, modname in self._imports_stack:\n742             if modname.startswith(\".\"):\n743                 package = \".\" + modname.split(\".\")[1]\n744             else:\n745                 package = modname.split(\".\")[0]\n746             nested = not isinstance(node.parent, astroid.Module)\n747             ignore_for_import_order = not self.linter.is_message_enabled(\n748                 \"wrong-import-order\", node.fromlineno\n749             )\n750             import_category = isort_driver.place_module(package)\n751             node_and_package_import = (node, package)\n752             if import_category in (\"FUTURE\", \"STDLIB\"):\n753                 std_imports.append(node_and_package_import)\n754                 wrong_import = (\n755                     third_party_not_ignored\n756                     or first_party_not_ignored\n757                     or local_not_ignored\n758                 )\n759                 if self._is_fallback_import(node, wrong_import):\n760                     continue\n761                 if wrong_import and not nested:\n762                     self.add_message(\n763                         \"wrong-import-order\",\n764                         node=node,\n765                         args=(\n766                             'standard import \"%s\"' % node.as_string(),\n767                             '\"%s\"' % wrong_import[0][0].as_string(),\n768                         ),\n769                     )\n770             elif import_category == \"THIRDPARTY\":\n771                 third_party_imports.append(node_and_package_import)\n772                 external_imports.append(node_and_package_import)\n773                 if not nested and not ignore_for_import_order:\n774                     third_party_not_ignored.append(node_and_package_import)\n775                 wrong_import = first_party_not_ignored or local_not_ignored\n776                 if wrong_import and not nested:\n777                     self.add_message(\n778                         \"wrong-import-order\",\n779                         node=node,\n780                         args=(\n781                             'third party import \"%s\"' % node.as_string(),\n782                             '\"%s\"' % wrong_import[0][0].as_string(),\n783                         ),\n784                     )\n785             elif import_category == \"FIRSTPARTY\":\n786                 first_party_imports.append(node_and_package_import)\n787                 external_imports.append(node_and_package_import)\n788                 if not nested and not ignore_for_import_order:\n789                     first_party_not_ignored.append(node_and_package_import)\n790                 wrong_import = local_not_ignored\n791                 if wrong_import and not nested:\n792                     self.add_message(\n793                         \"wrong-import-order\",\n794                         node=node,\n795                         args=(\n796                             'first party import \"%s\"' % node.as_string(),\n797                             '\"%s\"' % wrong_import[0][0].as_string(),\n798                         ),\n799                     )\n800             elif import_category == \"LOCALFOLDER\":\n801                 local_imports.append((node, package))\n802                 if not nested and not ignore_for_import_order:\n803                     local_not_ignored.append((node, package))\n804         return std_imports, external_imports, local_imports\n805 \n806     def _get_imported_module(self, importnode, modname):\n807         try:\n808             return importnode.do_import_module(modname)\n809         except astroid.TooManyLevelsError:\n810             if _ignore_import_failure(importnode, modname, self._ignored_modules):\n811                 return None\n812             self.add_message(\"relative-beyond-top-level\", node=importnode)\n813         except astroid.AstroidSyntaxError as exc:\n814             message = \"Cannot import {!r} due to syntax error {!r}\".format(\n815                 modname, str(exc.error)  # pylint: disable=no-member; false positive\n816             )\n817             self.add_message(\"syntax-error\", line=importnode.lineno, args=message)\n818 \n819         except astroid.AstroidBuildingException:\n820             if not self.linter.is_message_enabled(\"import-error\"):\n821                 return None\n822             if _ignore_import_failure(importnode, modname, self._ignored_modules):\n823                 return None\n824             if not self.config.analyse_fallback_blocks and is_from_fallback_block(\n825                 importnode\n826             ):\n827                 return None\n828 \n829             dotted_modname = _get_import_name(importnode, modname)\n830             self.add_message(\"import-error\", args=repr(dotted_modname), node=importnode)\n831         return None\n832 \n833     def _add_imported_module(self, node, importedmodname):\n834         \"\"\"notify an imported module, used to analyze dependencies\"\"\"\n835         module_file = node.root().file\n836         context_name = node.root().name\n837         base = os.path.splitext(os.path.basename(module_file))[0]\n838 \n839         try:\n840             importedmodname = astroid.modutils.get_module_part(\n841                 importedmodname, module_file\n842             )\n843         except ImportError:\n844             pass\n845 \n846         if context_name == importedmodname:\n847             self.add_message(\"import-self\", node=node)\n848 \n849         elif not astroid.modutils.is_standard_module(importedmodname):\n850             # if this is not a package __init__ module\n851             if base != \"__init__\" and context_name not in self._module_pkg:\n852                 # record the module's parent, or the module itself if this is\n853                 # a top level module, as the package it belongs to\n854                 self._module_pkg[context_name] = context_name.rsplit(\".\", 1)[0]\n855 \n856             # handle dependencies\n857             importedmodnames = self.stats[\"dependencies\"].setdefault(\n858                 importedmodname, set()\n859             )\n860             if context_name not in importedmodnames:\n861                 importedmodnames.add(context_name)\n862 \n863             # update import graph\n864             self.import_graph[context_name].add(importedmodname)\n865             if not self.linter.is_message_enabled(\"cyclic-import\", line=node.lineno):\n866                 self._excluded_edges[context_name].add(importedmodname)\n867 \n868     def _check_preferred_module(self, node, mod_path):\n869         \"\"\"check if the module has a preferred replacement\"\"\"\n870         if mod_path in self.preferred_modules:\n871             self.add_message(\n872                 \"preferred-module\",\n873                 node=node,\n874                 args=(self.preferred_modules[mod_path], mod_path),\n875             )\n876 \n877     def _check_import_as_rename(\n878         self, node: Union[astroid.Import, astroid.ImportFrom]\n879     ) -> None:\n880         names = node.names\n881         for name in names:\n882             if not all(name):\n883                 return\n884 \n885             splitted_packages = name[0].rsplit(\".\", maxsplit=1)\n886             import_name = splitted_packages[-1]\n887             aliased_name = name[1]\n888             if import_name != aliased_name:\n889                 continue\n890 \n891             if len(splitted_packages) == 1:\n892                 self.add_message(\"useless-import-alias\", node=node)\n893             elif len(splitted_packages) == 2:\n894                 self.add_message(\n895                     \"consider-using-from-import\",\n896                     node=node,\n897                     args=(splitted_packages[0], import_name),\n898                 )\n899 \n900     def _check_reimport(self, node, basename=None, level=None):\n901         \"\"\"check if the import is necessary (i.e. not already done)\"\"\"\n902         if not self.linter.is_message_enabled(\"reimported\"):\n903             return\n904 \n905         frame = node.frame()\n906         root = node.root()\n907         contexts = [(frame, level)]\n908         if root is not frame:\n909             contexts.append((root, None))\n910 \n911         for known_context, known_level in contexts:\n912             for name, alias in node.names:\n913                 first = _get_first_import(\n914                     node, known_context, name, basename, known_level, alias\n915                 )\n916                 if first is not None:\n917                     self.add_message(\n918                         \"reimported\", node=node, args=(name, first.fromlineno)\n919                     )\n920 \n921     def _report_external_dependencies(self, sect, _, _dummy):\n922         \"\"\"return a verbatim layout for displaying dependencies\"\"\"\n923         dep_info = _make_tree_defs(self._external_dependencies_info().items())\n924         if not dep_info:\n925             raise EmptyReportError()\n926         tree_str = _repr_tree_defs(dep_info)\n927         sect.append(VerbatimText(tree_str))\n928 \n929     def _report_dependencies_graph(self, sect, _, _dummy):\n930         \"\"\"write dependencies as a dot (graphviz) file\"\"\"\n931         dep_info = self.stats[\"dependencies\"]\n932         if not dep_info or not (\n933             self.config.import_graph\n934             or self.config.ext_import_graph\n935             or self.config.int_import_graph\n936         ):\n937             raise EmptyReportError()\n938         filename = self.config.import_graph\n939         if filename:\n940             _make_graph(filename, dep_info, sect, \"\")\n941         filename = self.config.ext_import_graph\n942         if filename:\n943             _make_graph(filename, self._external_dependencies_info(), sect, \"external \")\n944         filename = self.config.int_import_graph\n945         if filename:\n946             _make_graph(filename, self._internal_dependencies_info(), sect, \"internal \")\n947 \n948     def _filter_dependencies_graph(self, internal):\n949         \"\"\"build the internal or the external dependency graph\"\"\"\n950         graph = collections.defaultdict(set)\n951         for importee, importers in self.stats[\"dependencies\"].items():\n952             for importer in importers:\n953                 package = self._module_pkg.get(importer, importer)\n954                 is_inside = importee.startswith(package)\n955                 if is_inside and internal or not is_inside and not internal:\n956                     graph[importee].add(importer)\n957         return graph\n958 \n959     @astroid.decorators.cached\n960     def _external_dependencies_info(self):\n961         \"\"\"return cached external dependencies information or build and\n962         cache them\n963         \"\"\"\n964         return self._filter_dependencies_graph(internal=False)\n965 \n966     @astroid.decorators.cached\n967     def _internal_dependencies_info(self):\n968         \"\"\"return cached internal dependencies information or build and\n969         cache them\n970         \"\"\"\n971         return self._filter_dependencies_graph(internal=True)\n972 \n973     def _check_wildcard_imports(self, node, imported_module):\n974         if node.root().package:\n975             # Skip the check if in __init__.py issue #2026\n976             return\n977 \n978         wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)\n979         for name, _ in node.names:\n980             if name == \"*\" and not wildcard_import_is_allowed:\n981                 self.add_message(\"wildcard-import\", args=node.modname, node=node)\n982 \n983     def _wildcard_import_is_allowed(self, imported_module):\n984         return (\n985             self.config.allow_wildcard_with_all\n986             and imported_module is not None\n987             and \"__all__\" in imported_module.locals\n988         )\n989 \n990     def _check_toplevel(self, node):\n991         \"\"\"Check whether the import is made outside the module toplevel.\"\"\"\n992         # If the scope of the import is a module, then obviously it is\n993         # not outside the module toplevel.\n994         if isinstance(node.scope(), astroid.Module):\n995             return\n996 \n997         module_names = [\n998             f\"{node.modname}.{name[0]}\"\n999             if isinstance(node, astroid.ImportFrom)\n1000             else name[0]\n1001             for name in node.names\n1002         ]\n1003 \n1004         # Get the full names of all the imports that are only allowed at the module level\n1005         scoped_imports = [\n1006             name for name in module_names if name not in self._allow_any_import_level\n1007         ]\n1008 \n1009         if scoped_imports:\n1010             self.add_message(\n1011                 \"import-outside-toplevel\", args=\", \".join(scoped_imports), node=node\n1012             )\n1013 \n1014 \n1015 def register(linter):\n1016     \"\"\"required method to auto register this checker\"\"\"\n1017     linter.register_checker(ImportsChecker(linter))\n",
        "intended_behavior": "This file likely contains logic for detecting unused imports. A modification or enhancement should be made here to include logic that recognizes and validates imports used in type comments. The checker should parse comments for variables, class attributes, and function annotations, identify type hints within these comments, and cross-reference these types with imported modules or objects. Such an enhancement would address the issue by not flagging imports as unused if they are referenced in type comments."
    },
    {
        "rel_file_path": "pylint/utils/ast_walker.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/utils/ast_walker.py",
        "start": 9,
        "end": 85,
        "class_name": "ASTWalker",
        "method_name": null,
        "code": "9 class ASTWalker:\n10     def __init__(self, linter):\n11         # callbacks per node types\n12         self.nbstatements = 0\n13         self.visit_events = collections.defaultdict(list)\n14         self.leave_events = collections.defaultdict(list)\n15         self.linter = linter\n16         self.exception_msg = False\n17 \n18     def _is_method_enabled(self, method):\n19         if not hasattr(method, \"checks_msgs\"):\n20             return True\n21         for msg_desc in method.checks_msgs:\n22             if self.linter.is_message_enabled(msg_desc):\n23                 return True\n24         return False\n25 \n26     def add_checker(self, checker):\n27         \"\"\"walk to the checker's dir and collect visit and leave methods\"\"\"\n28         vcids = set()\n29         lcids = set()\n30         visits = self.visit_events\n31         leaves = self.leave_events\n32         for member in dir(checker):\n33             cid = member[6:]\n34             if cid == \"default\":\n35                 continue\n36             if member.startswith(\"visit_\"):\n37                 v_meth = getattr(checker, member)\n38                 # don't use visit_methods with no activated message:\n39                 if self._is_method_enabled(v_meth):\n40                     visits[cid].append(v_meth)\n41                     vcids.add(cid)\n42             elif member.startswith(\"leave_\"):\n43                 l_meth = getattr(checker, member)\n44                 # don't use leave_methods with no activated message:\n45                 if self._is_method_enabled(l_meth):\n46                     leaves[cid].append(l_meth)\n47                     lcids.add(cid)\n48         visit_default = getattr(checker, \"visit_default\", None)\n49         if visit_default:\n50             for cls in nodes.ALL_NODE_CLASSES:\n51                 cid = cls.__name__.lower()\n52                 if cid not in vcids:\n53                     visits[cid].append(visit_default)\n54         # for now we have no \"leave_default\" method in Pylint\n55 \n56     def walk(self, astroid):\n57         \"\"\"call visit events of astroid checkers for the given node, recurse on\n58         its children, then leave events.\n59         \"\"\"\n60         cid = astroid.__class__.__name__.lower()\n61 \n62         # Detect if the node is a new name for a deprecated alias.\n63         # In this case, favour the methods for the deprecated\n64         # alias if any,  in order to maintain backwards\n65         # compatibility.\n66         visit_events = self.visit_events.get(cid, ())\n67         leave_events = self.leave_events.get(cid, ())\n68 \n69         try:\n70             if astroid.is_statement:\n71                 self.nbstatements += 1\n72             # generate events for this node on each checker\n73             for callback in visit_events or ():\n74                 callback(astroid)\n75             # recurse on children\n76             for child in astroid.get_children():\n77                 self.walk(child)\n78             for callback in leave_events or ():\n79                 callback(astroid)\n80         except Exception:\n81             if self.exception_msg is False:\n82                 file = getattr(astroid.root(), \"file\", None)\n83                 print(f\"Exception on node {repr(astroid)} in file '{file}'\")\n84                 self.exception_msg = True\n85             raise\n",
        "intended_behavior": "Adjustments to ensure type comments are adequately considered during the visitation of nodes related to import statements. The intended behavior would include enhancements to traverse and analyze comments adjacent to or within node structures that can have associated type hints (e.g., variable annotations, function signatures). This would ensure that the AST traversal logic supports identifying use cases of imported types within comments."
    }
]