[
    {
        "rel_file_path": "src/_pytest/config/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/config/__init__.py",
        "start": 1,
        "end": 1817,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Command line options, ini-file and conftest.py processing.\"\"\"\n2 import argparse\n3 import collections.abc\n4 import copy\n5 import dataclasses\n6 import enum\n7 import glob\n8 import importlib.metadata\n9 import inspect\n10 import os\n11 import re\n12 import shlex\n13 import sys\n14 import types\n15 import warnings\n16 from functools import lru_cache\n17 from pathlib import Path\n18 from textwrap import dedent\n19 from types import FunctionType\n20 from types import TracebackType\n21 from typing import Any\n22 from typing import Callable\n23 from typing import cast\n24 from typing import Dict\n25 from typing import final\n26 from typing import Generator\n27 from typing import IO\n28 from typing import Iterable\n29 from typing import Iterator\n30 from typing import List\n31 from typing import Optional\n32 from typing import Sequence\n33 from typing import Set\n34 from typing import TextIO\n35 from typing import Tuple\n36 from typing import Type\n37 from typing import TYPE_CHECKING\n38 from typing import Union\n39 \n40 from pluggy import HookimplMarker\n41 from pluggy import HookspecMarker\n42 from pluggy import PluginManager\n43 \n44 import _pytest._code\n45 import _pytest.deprecated\n46 import _pytest.hookspec\n47 from .exceptions import PrintHelp as PrintHelp\n48 from .exceptions import UsageError as UsageError\n49 from .findpaths import determine_setup\n50 from _pytest._code import ExceptionInfo\n51 from _pytest._code import filter_traceback\n52 from _pytest._io import TerminalWriter\n53 from _pytest.outcomes import fail\n54 from _pytest.outcomes import Skipped\n55 from _pytest.pathlib import absolutepath\n56 from _pytest.pathlib import bestrelpath\n57 from _pytest.pathlib import import_path\n58 from _pytest.pathlib import ImportMode\n59 from _pytest.pathlib import resolve_package_path\n60 from _pytest.stash import Stash\n61 from _pytest.warning_types import PytestConfigWarning\n62 from _pytest.warning_types import warn_explicit_for\n63 \n64 if TYPE_CHECKING:\n65     from _pytest._code.code import _TracebackStyle\n66     from _pytest.terminal import TerminalReporter\n67     from .argparsing import Argument\n68 \n69 \n70 _PluggyPlugin = object\n71 \"\"\"A type to represent plugin objects.\n72 \n73 Plugins can be any namespace, so we can't narrow it down much, but we use an\n74 alias to make the intent clear.\n75 \n76 Ideally this type would be provided by pluggy itself.\n77 \"\"\"\n78 \n79 \n80 hookimpl = HookimplMarker(\"pytest\")\n81 hookspec = HookspecMarker(\"pytest\")\n82 \n83 \n84 @final\n85 class ExitCode(enum.IntEnum):\n86     \"\"\"Encodes the valid exit codes by pytest.\n87 \n88     Currently users and plugins may supply other exit codes as well.\n89 \n90     .. versionadded:: 5.0\n91     \"\"\"\n92 \n93     #: Tests passed.\n94     OK = 0\n95     #: Tests failed.\n96     TESTS_FAILED = 1\n97     #: pytest was interrupted.\n98     INTERRUPTED = 2\n99     #: An internal error got in the way.\n100     INTERNAL_ERROR = 3\n101     #: pytest was misused.\n102     USAGE_ERROR = 4\n103     #: pytest couldn't find tests.\n104     NO_TESTS_COLLECTED = 5\n105 \n106 \n107 class ConftestImportFailure(Exception):\n108     def __init__(\n109         self,\n110         path: Path,\n111         excinfo: Tuple[Type[Exception], Exception, TracebackType],\n112     ) -> None:\n113         super().__init__(path, excinfo)\n114         self.path = path\n115         self.excinfo = excinfo\n116 \n117     def __str__(self) -> str:\n118         return \"{}: {} (from {})\".format(\n119             self.excinfo[0].__name__, self.excinfo[1], self.path\n120         )\n121 \n122 \n123 def filter_traceback_for_conftest_import_failure(\n124     entry: _pytest._code.TracebackEntry,\n125 ) -> bool:\n126     \"\"\"Filter tracebacks entries which point to pytest internals or importlib.\n127 \n128     Make a special case for importlib because we use it to import test modules and conftest files\n129     in _pytest.pathlib.import_path.\n130     \"\"\"\n131     return filter_traceback(entry) and \"importlib\" not in str(entry.path).split(os.sep)\n132 \n133 \n134 def main(\n135     args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n136     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n137 ) -> Union[int, ExitCode]:\n138     \"\"\"Perform an in-process test run.\n139 \n140     :param args: List of command line arguments.\n141     :param plugins: List of plugin objects to be auto-registered during initialization.\n142 \n143     :returns: An exit code.\n144     \"\"\"\n145     try:\n146         try:\n147             config = _prepareconfig(args, plugins)\n148         except ConftestImportFailure as e:\n149             exc_info = ExceptionInfo.from_exc_info(e.excinfo)\n150             tw = TerminalWriter(sys.stderr)\n151             tw.line(f\"ImportError while loading conftest '{e.path}'.\", red=True)\n152             exc_info.traceback = exc_info.traceback.filter(\n153                 filter_traceback_for_conftest_import_failure\n154             )\n155             exc_repr = (\n156                 exc_info.getrepr(style=\"short\", chain=False)\n157                 if exc_info.traceback\n158                 else exc_info.exconly()\n159             )\n160             formatted_tb = str(exc_repr)\n161             for line in formatted_tb.splitlines():\n162                 tw.line(line.rstrip(), red=True)\n163             return ExitCode.USAGE_ERROR\n164         else:\n165             try:\n166                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\n167                     config=config\n168                 )\n169                 try:\n170                     return ExitCode(ret)\n171                 except ValueError:\n172                     return ret\n173             finally:\n174                 config._ensure_unconfigure()\n175     except UsageError as e:\n176         tw = TerminalWriter(sys.stderr)\n177         for msg in e.args:\n178             tw.line(f\"ERROR: {msg}\\n\", red=True)\n179         return ExitCode.USAGE_ERROR\n180 \n181 \n182 def console_main() -> int:\n183     \"\"\"The CLI entry point of pytest.\n184 \n185     This function is not meant for programmable use; use `main()` instead.\n186     \"\"\"\n187     # https://docs.python.org/3/library/signal.html#note-on-sigpipe\n188     try:\n189         code = main()\n190         sys.stdout.flush()\n191         return code\n192     except BrokenPipeError:\n193         # Python flushes standard streams on exit; redirect remaining output\n194         # to devnull to avoid another BrokenPipeError at shutdown\n195         devnull = os.open(os.devnull, os.O_WRONLY)\n196         os.dup2(devnull, sys.stdout.fileno())\n197         return 1  # Python exits with error code 1 on EPIPE\n198 \n199 \n200 class cmdline:  # compatibility namespace\n201     main = staticmethod(main)\n202 \n203 \n204 def filename_arg(path: str, optname: str) -> str:\n205     \"\"\"Argparse type validator for filename arguments.\n206 \n207     :path: Path of filename.\n208     :optname: Name of the option.\n209     \"\"\"\n210     if os.path.isdir(path):\n211         raise UsageError(f\"{optname} must be a filename, given: {path}\")\n212     return path\n213 \n214 \n215 def directory_arg(path: str, optname: str) -> str:\n216     \"\"\"Argparse type validator for directory arguments.\n217 \n218     :path: Path of directory.\n219     :optname: Name of the option.\n220     \"\"\"\n221     if not os.path.isdir(path):\n222         raise UsageError(f\"{optname} must be a directory, given: {path}\")\n223     return path\n224 \n225 \n226 # Plugins that cannot be disabled via \"-p no:X\" currently.\n227 essential_plugins = (\n228     \"mark\",\n229     \"main\",\n230     \"runner\",\n231     \"fixtures\",\n232     \"helpconfig\",  # Provides -p.\n233 )\n234 \n235 default_plugins = essential_plugins + (\n236     \"python\",\n237     \"terminal\",\n238     \"debugging\",\n239     \"unittest\",\n240     \"capture\",\n241     \"skipping\",\n242     \"legacypath\",\n243     \"tmpdir\",\n244     \"monkeypatch\",\n245     \"recwarn\",\n246     \"pastebin\",\n247     \"nose\",\n248     \"assertion\",\n249     \"junitxml\",\n250     \"doctest\",\n251     \"cacheprovider\",\n252     \"freeze_support\",\n253     \"setuponly\",\n254     \"setupplan\",\n255     \"stepwise\",\n256     \"warnings\",\n257     \"logging\",\n258     \"reports\",\n259     \"python_path\",\n260     \"unraisableexception\",\n261     \"threadexception\",\n262     \"faulthandler\",\n263 )\n264 \n265 builtin_plugins = set(default_plugins)\n266 builtin_plugins.add(\"pytester\")\n267 builtin_plugins.add(\"pytester_assertions\")\n268 \n269 \n270 def get_config(\n271     args: Optional[List[str]] = None,\n272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n273 ) -> \"Config\":\n274     # subsequent calls to main will create a fresh instance\n275     pluginmanager = PytestPluginManager()\n276     config = Config(\n277         pluginmanager,\n278         invocation_params=Config.InvocationParams(\n279             args=args or (),\n280             plugins=plugins,\n281             dir=Path.cwd(),\n282         ),\n283     )\n284 \n285     if args is not None:\n286         # Handle any \"-p no:plugin\" args.\n287         pluginmanager.consider_preparse(args, exclude_only=True)\n288 \n289     for spec in default_plugins:\n290         pluginmanager.import_plugin(spec)\n291 \n292     return config\n293 \n294 \n295 def get_plugin_manager() -> \"PytestPluginManager\":\n296     \"\"\"Obtain a new instance of the\n297     :py:class:`pytest.PytestPluginManager`, with default plugins\n298     already loaded.\n299 \n300     This function can be used by integration with other tools, like hooking\n301     into pytest to run tests into an IDE.\n302     \"\"\"\n303     return get_config().pluginmanager\n304 \n305 \n306 def _prepareconfig(\n307     args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n309 ) -> \"Config\":\n310     if args is None:\n311         args = sys.argv[1:]\n312     elif isinstance(args, os.PathLike):\n313         args = [os.fspath(args)]\n314     elif not isinstance(args, list):\n315         msg = (  # type:ignore[unreachable]\n316             \"`args` parameter expected to be a list of strings, got: {!r} (type: {})\"\n317         )\n318         raise TypeError(msg.format(args, type(args)))\n319 \n320     config = get_config(args, plugins)\n321     pluginmanager = config.pluginmanager\n322     try:\n323         if plugins:\n324             for plugin in plugins:\n325                 if isinstance(plugin, str):\n326                     pluginmanager.consider_pluginarg(plugin)\n327                 else:\n328                     pluginmanager.register(plugin)\n329         config = pluginmanager.hook.pytest_cmdline_parse(\n330             pluginmanager=pluginmanager, args=args\n331         )\n332         return config\n333     except BaseException:\n334         config._ensure_unconfigure()\n335         raise\n336 \n337 \n338 def _get_directory(path: Path) -> Path:\n339     \"\"\"Get the directory of a path - itself if already a directory.\"\"\"\n340     if path.is_file():\n341         return path.parent\n342     else:\n343         return path\n344 \n345 \n346 def _get_legacy_hook_marks(\n347     method: Any,\n348     hook_type: str,\n349     opt_names: Tuple[str, ...],\n350 ) -> Dict[str, bool]:\n351     if TYPE_CHECKING:\n352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias\n353         assert inspect.isroutine(method)\n354     known_marks: set[str] = {m.name for m in getattr(method, \"pytestmark\", [])}\n355     must_warn: list[str] = []\n356     opts: dict[str, bool] = {}\n357     for opt_name in opt_names:\n358         opt_attr = getattr(method, opt_name, AttributeError)\n359         if opt_attr is not AttributeError:\n360             must_warn.append(f\"{opt_name}={opt_attr}\")\n361             opts[opt_name] = True\n362         elif opt_name in known_marks:\n363             must_warn.append(f\"{opt_name}=True\")\n364             opts[opt_name] = True\n365         else:\n366             opts[opt_name] = False\n367     if must_warn:\n368         hook_opts = \", \".join(must_warn)\n369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(\n370             type=hook_type,\n371             fullname=method.__qualname__,\n372             hook_opts=hook_opts,\n373         )\n374         warn_explicit_for(cast(FunctionType, method), message)\n375     return opts\n376 \n377 \n378 @final\n379 class PytestPluginManager(PluginManager):\n380     \"\"\"A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\n381     additional pytest-specific functionality:\n382 \n383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n384       ``pytest_plugins`` global variables found in plugins being loaded.\n385     * ``conftest.py`` loading during start-up.\n386     \"\"\"\n387 \n388     def __init__(self) -> None:\n389         import _pytest.assertion\n390 \n391         super().__init__(\"pytest\")\n392 \n393         # -- State related to local conftest plugins.\n394         # All loaded conftest modules.\n395         self._conftest_plugins: Set[types.ModuleType] = set()\n396         # All conftest modules applicable for a directory.\n397         # This includes the directory's own conftest modules as well\n398         # as those of its parent directories.\n399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n400         # Cutoff directory above which conftests are no longer discovered.\n401         self._confcutdir: Optional[Path] = None\n402         # If set, conftest loading is skipped.\n403         self._noconftest = False\n404 \n405         # _getconftestmodules()'s call to _get_directory() causes a stat\n406         # storm when it's called potentially thousands of times in a test\n407         # session (#9478), often with the same path, so cache it.\n408         self._get_directory = lru_cache(256)(_get_directory)\n409 \n410         self._duplicatepaths: Set[Path] = set()\n411 \n412         # plugins that were explicitly skipped with pytest.skip\n413         # list of (module name, skip reason)\n414         # previously we would issue a warning when a plugin was skipped, but\n415         # since we refactored warnings as first citizens of Config, they are\n416         # just stored here to be used later.\n417         self.skipped_plugins: List[Tuple[str, str]] = []\n418 \n419         self.add_hookspecs(_pytest.hookspec)\n420         self.register(self)\n421         if os.environ.get(\"PYTEST_DEBUG\"):\n422             err: IO[str] = sys.stderr\n423             encoding: str = getattr(err, \"encoding\", \"utf8\")\n424             try:\n425                 err = open(\n426                     os.dup(err.fileno()),\n427                     mode=err.mode,\n428                     buffering=1,\n429                     encoding=encoding,\n430                 )\n431             except Exception:\n432                 pass\n433             self.trace.root.setwriter(err.write)\n434             self.enable_tracing()\n435 \n436         # Config._consider_importhook will set a real object if required.\n437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n438         # Used to know when we are importing conftests after the pytest_configure stage.\n439         self._configured = False\n440 \n441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n442         # pytest hooks are always prefixed with \"pytest_\",\n443         # so we avoid accessing possibly non-readable attributes\n444         # (see issue #1073).\n445         if not name.startswith(\"pytest_\"):\n446             return\n447         # Ignore names which can not be hooks.\n448         if name == \"pytest_plugins\":\n449             return\n450 \n451         opts = super().parse_hookimpl_opts(plugin, name)\n452         if opts is not None:\n453             return opts\n454 \n455         method = getattr(plugin, name)\n456         # Consider only actual functions for hooks (#3775).\n457         if not inspect.isroutine(method):\n458             return\n459         # Collect unmarked hooks as long as they have the `pytest_' prefix.\n460         return _get_legacy_hook_marks(\n461             method, \"impl\", (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\")\n462         )\n463 \n464     def parse_hookspec_opts(self, module_or_class, name: str):\n465         opts = super().parse_hookspec_opts(module_or_class, name)\n466         if opts is None:\n467             method = getattr(module_or_class, name)\n468             if name.startswith(\"pytest_\"):\n469                 opts = _get_legacy_hook_marks(\n470                     method,\n471                     \"spec\",\n472                     (\"firstresult\", \"historic\"),\n473                 )\n474         return opts\n475 \n476     def register(\n477         self, plugin: _PluggyPlugin, name: Optional[str] = None\n478     ) -> Optional[str]:\n479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n480             warnings.warn(\n481                 PytestConfigWarning(\n482                     \"{} plugin has been merged into the core, \"\n483                     \"please remove it from your requirements.\".format(\n484                         name.replace(\"_\", \"-\")\n485                     )\n486                 )\n487             )\n488             return None\n489         ret: Optional[str] = super().register(plugin, name)\n490         if ret:\n491             self.hook.pytest_plugin_registered.call_historic(\n492                 kwargs=dict(plugin=plugin, manager=self)\n493             )\n494 \n495             if isinstance(plugin, types.ModuleType):\n496                 self.consider_module(plugin)\n497         return ret\n498 \n499     def getplugin(self, name: str):\n500         # Support deprecated naming because plugins (xdist e.g.) use it.\n501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)\n502         return plugin\n503 \n504     def hasplugin(self, name: str) -> bool:\n505         \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n506         return bool(self.get_plugin(name))\n507 \n508     def pytest_configure(self, config: \"Config\") -> None:\n509         \"\"\":meta private:\"\"\"\n510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n511         # we should remove tryfirst/trylast as markers.\n512         config.addinivalue_line(\n513             \"markers\",\n514             \"tryfirst: mark a hook implementation function such that the \"\n515             \"plugin machinery will try to call it first/as early as possible. \"\n516             \"DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead.\",\n517         )\n518         config.addinivalue_line(\n519             \"markers\",\n520             \"trylast: mark a hook implementation function such that the \"\n521             \"plugin machinery will try to call it last/as late as possible. \"\n522             \"DEPRECATED, use @pytest.hookimpl(trylast=True) instead.\",\n523         )\n524         self._configured = True\n525 \n526     #\n527     # Internal API for local conftest plugin handling.\n528     #\n529     def _set_initial_conftests(\n530         self,\n531         args: Sequence[Union[str, Path]],\n532         pyargs: bool,\n533         noconftest: bool,\n534         rootpath: Path,\n535         confcutdir: Optional[Path],\n536         importmode: Union[ImportMode, str],\n537     ) -> None:\n538         \"\"\"Load initial conftest files given a preparsed \"namespace\".\n539 \n540         As conftest files may add their own command line options which have\n541         arguments ('--my-opt somepath') we might get some false positives.\n542         All builtin and 3rd party plugins will have been loaded, however, so\n543         common options will not confuse our logic here.\n544         \"\"\"\n545         current = Path.cwd()\n546         self._confcutdir = absolutepath(current / confcutdir) if confcutdir else None\n547         self._noconftest = noconftest\n548         self._using_pyargs = pyargs\n549         foundanchor = False\n550         for intitial_path in args:\n551             path = str(intitial_path)\n552             # remove node-id syntax\n553             i = path.find(\"::\")\n554             if i != -1:\n555                 path = path[:i]\n556             anchor = absolutepath(current / path)\n557 \n558             # Ensure we do not break if what appears to be an anchor\n559             # is in fact a very long option (#10169).\n560             try:\n561                 anchor_exists = anchor.exists()\n562             except OSError:  # pragma: no cover\n563                 anchor_exists = False\n564             if anchor_exists:\n565                 self._try_load_conftest(anchor, importmode, rootpath)\n566                 foundanchor = True\n567         if not foundanchor:\n568             self._try_load_conftest(current, importmode, rootpath)\n569 \n570     def _is_in_confcutdir(self, path: Path) -> bool:\n571         \"\"\"Whether a path is within the confcutdir.\n572 \n573         When false, should not load conftest.\n574         \"\"\"\n575         if self._confcutdir is None:\n576             return True\n577         return path not in self._confcutdir.parents\n578 \n579     def _try_load_conftest(\n580         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path\n581     ) -> None:\n582         self._getconftestmodules(anchor, importmode, rootpath)\n583         # let's also consider test* subdirs\n584         if anchor.is_dir():\n585             for x in anchor.glob(\"test*\"):\n586                 if x.is_dir():\n587                     self._getconftestmodules(x, importmode, rootpath)\n588 \n589     def _getconftestmodules(\n590         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path\n591     ) -> Sequence[types.ModuleType]:\n592         if self._noconftest:\n593             return []\n594 \n595         directory = self._get_directory(path)\n596 \n597         # Optimization: avoid repeated searches in the same directory.\n598         # Assumes always called with same importmode and rootpath.\n599         existing_clist = self._dirpath2confmods.get(directory)\n600         if existing_clist is not None:\n601             return existing_clist\n602 \n603         # XXX these days we may rather want to use config.rootpath\n604         # and allow users to opt into looking into the rootdir parent\n605         # directories instead of requiring to specify confcutdir.\n606         clist = []\n607         for parent in reversed((directory, *directory.parents)):\n608             if self._is_in_confcutdir(parent):\n609                 conftestpath = parent / \"conftest.py\"\n610                 if conftestpath.is_file():\n611                     mod = self._importconftest(conftestpath, importmode, rootpath)\n612                     clist.append(mod)\n613         self._dirpath2confmods[directory] = clist\n614         return clist\n615 \n616     def _rget_with_confmod(\n617         self,\n618         name: str,\n619         path: Path,\n620         importmode: Union[str, ImportMode],\n621         rootpath: Path,\n622     ) -> Tuple[types.ModuleType, Any]:\n623         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)\n624         for mod in reversed(modules):\n625             try:\n626                 return mod, getattr(mod, name)\n627             except AttributeError:\n628                 continue\n629         raise KeyError(name)\n630 \n631     def _importconftest(\n632         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path\n633     ) -> types.ModuleType:\n634         existing = self.get_plugin(str(conftestpath))\n635         if existing is not None:\n636             return cast(types.ModuleType, existing)\n637 \n638         pkgpath = resolve_package_path(conftestpath)\n639         if pkgpath is None:\n640             _ensure_removed_sysmodule(conftestpath.stem)\n641 \n642         try:\n643             mod = import_path(conftestpath, mode=importmode, root=rootpath)\n644         except Exception as e:\n645             assert e.__traceback__ is not None\n646             exc_info = (type(e), e, e.__traceback__)\n647             raise ConftestImportFailure(conftestpath, exc_info) from e\n648 \n649         self._check_non_top_pytest_plugins(mod, conftestpath)\n650 \n651         self._conftest_plugins.add(mod)\n652         dirpath = conftestpath.parent\n653         if dirpath in self._dirpath2confmods:\n654             for path, mods in self._dirpath2confmods.items():\n655                 if dirpath in path.parents or path == dirpath:\n656                     assert mod not in mods\n657                     mods.append(mod)\n658         self.trace(f\"loading conftestmodule {mod!r}\")\n659         self.consider_conftest(mod)\n660         return mod\n661 \n662     def _check_non_top_pytest_plugins(\n663         self,\n664         mod: types.ModuleType,\n665         conftestpath: Path,\n666     ) -> None:\n667         if (\n668             hasattr(mod, \"pytest_plugins\")\n669             and self._configured\n670             and not self._using_pyargs\n671         ):\n672             msg = (\n673                 \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n674                 \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n675                 \"  {}\\n\"\n676                 \"Please move it to a top level conftest file at the rootdir:\\n\"\n677                 \"  {}\\n\"\n678                 \"For more information, visit:\\n\"\n679                 \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n680             )\n681             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)\n682 \n683     #\n684     # API for bootstrapping plugin loading\n685     #\n686     #\n687 \n688     def consider_preparse(\n689         self, args: Sequence[str], *, exclude_only: bool = False\n690     ) -> None:\n691         \"\"\":meta private:\"\"\"\n692         i = 0\n693         n = len(args)\n694         while i < n:\n695             opt = args[i]\n696             i += 1\n697             if isinstance(opt, str):\n698                 if opt == \"-p\":\n699                     try:\n700                         parg = args[i]\n701                     except IndexError:\n702                         return\n703                     i += 1\n704                 elif opt.startswith(\"-p\"):\n705                     parg = opt[2:]\n706                 else:\n707                     continue\n708                 parg = parg.strip()\n709                 if exclude_only and not parg.startswith(\"no:\"):\n710                     continue\n711                 self.consider_pluginarg(parg)\n712 \n713     def consider_pluginarg(self, arg: str) -> None:\n714         \"\"\":meta private:\"\"\"\n715         if arg.startswith(\"no:\"):\n716             name = arg[3:]\n717             if name in essential_plugins:\n718                 raise UsageError(\"plugin %s cannot be disabled\" % name)\n719 \n720             # PR #4304: remove stepwise if cacheprovider is blocked.\n721             if name == \"cacheprovider\":\n722                 self.set_blocked(\"stepwise\")\n723                 self.set_blocked(\"pytest_stepwise\")\n724 \n725             self.set_blocked(name)\n726             if not name.startswith(\"pytest_\"):\n727                 self.set_blocked(\"pytest_\" + name)\n728         else:\n729             name = arg\n730             # Unblock the plugin.  None indicates that it has been blocked.\n731             # There is no interface with pluggy for this.\n732             if self._name2plugin.get(name, -1) is None:\n733                 del self._name2plugin[name]\n734             if not name.startswith(\"pytest_\"):\n735                 if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n736                     del self._name2plugin[\"pytest_\" + name]\n737             self.import_plugin(arg, consider_entry_points=True)\n738 \n739     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:\n740         \"\"\":meta private:\"\"\"\n741         self.register(conftestmodule, name=conftestmodule.__file__)\n742 \n743     def consider_env(self) -> None:\n744         \"\"\":meta private:\"\"\"\n745         self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n746 \n747     def consider_module(self, mod: types.ModuleType) -> None:\n748         \"\"\":meta private:\"\"\"\n749         self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n750 \n751     def _import_plugin_specs(\n752         self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n753     ) -> None:\n754         plugins = _get_plugin_specs_as_list(spec)\n755         for import_spec in plugins:\n756             self.import_plugin(import_spec)\n757 \n758     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n759         \"\"\"Import a plugin with ``modname``.\n760 \n761         If ``consider_entry_points`` is True, entry point names are also\n762         considered to find a plugin.\n763         \"\"\"\n764         # Most often modname refers to builtin modules, e.g. \"pytester\",\n765         # \"terminal\" or \"capture\".  Those plugins are registered under their\n766         # basename for historic purposes but must be imported with the\n767         # _pytest prefix.\n768         assert isinstance(modname, str), (\n769             \"module name as text required, got %r\" % modname\n770         )\n771         if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n772             return\n773 \n774         importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n775         self.rewrite_hook.mark_rewrite(importspec)\n776 \n777         if consider_entry_points:\n778             loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n779             if loaded:\n780                 return\n781 \n782         try:\n783             __import__(importspec)\n784         except ImportError as e:\n785             raise ImportError(\n786                 f'Error importing plugin \"{modname}\": {e.args[0]}'\n787             ).with_traceback(e.__traceback__) from e\n788 \n789         except Skipped as e:\n790             self.skipped_plugins.append((modname, e.msg or \"\"))\n791         else:\n792             mod = sys.modules[importspec]\n793             self.register(mod, modname)\n794 \n795 \n796 def _get_plugin_specs_as_list(\n797     specs: Union[None, types.ModuleType, str, Sequence[str]]\n798 ) -> List[str]:\n799     \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n800     # None means empty.\n801     if specs is None:\n802         return []\n803     # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n804     if isinstance(specs, types.ModuleType):\n805         return []\n806     # Comma-separated list.\n807     if isinstance(specs, str):\n808         return specs.split(\",\") if specs else []\n809     # Direct specification.\n810     if isinstance(specs, collections.abc.Sequence):\n811         return list(specs)\n812     raise UsageError(\n813         \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n814         % specs\n815     )\n816 \n817 \n818 def _ensure_removed_sysmodule(modname: str) -> None:\n819     try:\n820         del sys.modules[modname]\n821     except KeyError:\n822         pass\n823 \n824 \n825 class Notset:\n826     def __repr__(self):\n827         return \"<NOTSET>\"\n828 \n829 \n830 notset = Notset()\n831 \n832 \n833 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:\n834     \"\"\"Given an iterable of file names in a source distribution, return the \"names\" that should\n835     be marked for assertion rewrite.\n836 \n837     For example the package \"pytest_mock/__init__.py\" should be added as \"pytest_mock\" in\n838     the assertion rewrite mechanism.\n839 \n840     This function has to deal with dist-info based distributions and egg based distributions\n841     (which are still very much in use for \"editable\" installs).\n842 \n843     Here are the file names as seen in a dist-info based distribution:\n844 \n845         pytest_mock/__init__.py\n846         pytest_mock/_version.py\n847         pytest_mock/plugin.py\n848         pytest_mock.egg-info/PKG-INFO\n849 \n850     Here are the file names as seen in an egg based distribution:\n851 \n852         src/pytest_mock/__init__.py\n853         src/pytest_mock/_version.py\n854         src/pytest_mock/plugin.py\n855         src/pytest_mock.egg-info/PKG-INFO\n856         LICENSE\n857         setup.py\n858 \n859     We have to take in account those two distribution flavors in order to determine which\n860     names should be considered for assertion rewriting.\n861 \n862     More information:\n863         https://github.com/pytest-dev/pytest-mock/issues/167\n864     \"\"\"\n865     package_files = list(package_files)\n866     seen_some = False\n867     for fn in package_files:\n868         is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n869         is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n870         if is_simple_module:\n871             module_name, _ = os.path.splitext(fn)\n872             # we ignore \"setup.py\" at the root of the distribution\n873             # as well as editable installation finder modules made by setuptools\n874             if module_name != \"setup\" and not module_name.startswith(\"__editable__\"):\n875                 seen_some = True\n876                 yield module_name\n877         elif is_package:\n878             package_name = os.path.dirname(fn)\n879             seen_some = True\n880             yield package_name\n881 \n882     if not seen_some:\n883         # At this point we did not find any packages or modules suitable for assertion\n884         # rewriting, so we try again by stripping the first path component (to account for\n885         # \"src\" based source trees for example).\n886         # This approach lets us have the common case continue to be fast, as egg-distributions\n887         # are rarer.\n888         new_package_files = []\n889         for fn in package_files:\n890             parts = fn.split(\"/\")\n891             new_fn = \"/\".join(parts[1:])\n892             if new_fn:\n893                 new_package_files.append(new_fn)\n894         if new_package_files:\n895             yield from _iter_rewritable_modules(new_package_files)\n896 \n897 \n898 @final\n899 class Config:\n900     \"\"\"Access to configuration values, pluginmanager and plugin hooks.\n901 \n902     :param PytestPluginManager pluginmanager:\n903         A pytest PluginManager.\n904 \n905     :param InvocationParams invocation_params:\n906         Object containing parameters regarding the :func:`pytest.main`\n907         invocation.\n908     \"\"\"\n909 \n910     @final\n911     @dataclasses.dataclass(frozen=True)\n912     class InvocationParams:\n913         \"\"\"Holds parameters passed during :func:`pytest.main`.\n914 \n915         The object attributes are read-only.\n916 \n917         .. versionadded:: 5.1\n918 \n919         .. note::\n920 \n921             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n922             ini option are handled by pytest, not being included in the ``args`` attribute.\n923 \n924             Plugins accessing ``InvocationParams`` must be aware of that.\n925         \"\"\"\n926 \n927         args: Tuple[str, ...]\n928         \"\"\"The command-line arguments as passed to :func:`pytest.main`.\"\"\"\n929         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]\n930         \"\"\"Extra plugins, might be `None`.\"\"\"\n931         dir: Path\n932         \"\"\"The directory from which :func:`pytest.main` was invoked.\"\"\"\n933 \n934         def __init__(\n935             self,\n936             *,\n937             args: Iterable[str],\n938             plugins: Optional[Sequence[Union[str, _PluggyPlugin]]],\n939             dir: Path,\n940         ) -> None:\n941             object.__setattr__(self, \"args\", tuple(args))\n942             object.__setattr__(self, \"plugins\", plugins)\n943             object.__setattr__(self, \"dir\", dir)\n944 \n945     class ArgsSource(enum.Enum):\n946         \"\"\"Indicates the source of the test arguments.\n947 \n948         .. versionadded:: 7.2\n949         \"\"\"\n950 \n951         #: Command line arguments.\n952         ARGS = enum.auto()\n953         #: Invocation directory.\n954         INCOVATION_DIR = enum.auto()\n955         #: 'testpaths' configuration value.\n956         TESTPATHS = enum.auto()\n957 \n958     def __init__(\n959         self,\n960         pluginmanager: PytestPluginManager,\n961         *,\n962         invocation_params: Optional[InvocationParams] = None,\n963     ) -> None:\n964         from .argparsing import Parser, FILE_OR_DIR\n965 \n966         if invocation_params is None:\n967             invocation_params = self.InvocationParams(\n968                 args=(), plugins=None, dir=Path.cwd()\n969             )\n970 \n971         self.option = argparse.Namespace()\n972         \"\"\"Access to command line option as attributes.\n973 \n974         :type: argparse.Namespace\n975         \"\"\"\n976 \n977         self.invocation_params = invocation_params\n978         \"\"\"The parameters with which pytest was invoked.\n979 \n980         :type: InvocationParams\n981         \"\"\"\n982 \n983         _a = FILE_OR_DIR\n984         self._parser = Parser(\n985             usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n986             processopt=self._processopt,\n987             _ispytest=True,\n988         )\n989         self.pluginmanager = pluginmanager\n990         \"\"\"The plugin manager handles plugin registration and hook invocation.\n991 \n992         :type: PytestPluginManager\n993         \"\"\"\n994 \n995         self.stash = Stash()\n996         \"\"\"A place where plugins can store information on the config for their\n997         own use.\n998 \n999         :type: Stash\n1000         \"\"\"\n1001         # Deprecated alias. Was never public. Can be removed in a few releases.\n1002         self._store = self.stash\n1003 \n1004         from .compat import PathAwareHookProxy\n1005 \n1006         self.trace = self.pluginmanager.trace.root.get(\"config\")\n1007         self.hook = PathAwareHookProxy(self.pluginmanager.hook)\n1008         self._inicache: Dict[str, Any] = {}\n1009         self._override_ini: Sequence[str] = ()\n1010         self._opt2dest: Dict[str, str] = {}\n1011         self._cleanup: List[Callable[[], None]] = []\n1012         self.pluginmanager.register(self, \"pytestconfig\")\n1013         self._configured = False\n1014         self.hook.pytest_addoption.call_historic(\n1015             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n1016         )\n1017         self.args_source = Config.ArgsSource.ARGS\n1018         self.args: List[str] = []\n1019 \n1020         if TYPE_CHECKING:\n1021             from _pytest.cacheprovider import Cache\n1022 \n1023             self.cache: Optional[Cache] = None\n1024 \n1025     @property\n1026     def rootpath(self) -> Path:\n1027         \"\"\"The path to the :ref:`rootdir <rootdir>`.\n1028 \n1029         :type: pathlib.Path\n1030 \n1031         .. versionadded:: 6.1\n1032         \"\"\"\n1033         return self._rootpath\n1034 \n1035     @property\n1036     def inipath(self) -> Optional[Path]:\n1037         \"\"\"The path to the :ref:`configfile <configfiles>`.\n1038 \n1039         :type: Optional[pathlib.Path]\n1040 \n1041         .. versionadded:: 6.1\n1042         \"\"\"\n1043         return self._inipath\n1044 \n1045     def add_cleanup(self, func: Callable[[], None]) -> None:\n1046         \"\"\"Add a function to be called when the config object gets out of\n1047         use (usually coinciding with pytest_unconfigure).\"\"\"\n1048         self._cleanup.append(func)\n1049 \n1050     def _do_configure(self) -> None:\n1051         assert not self._configured\n1052         self._configured = True\n1053         with warnings.catch_warnings():\n1054             warnings.simplefilter(\"default\")\n1055             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n1056 \n1057     def _ensure_unconfigure(self) -> None:\n1058         if self._configured:\n1059             self._configured = False\n1060             self.hook.pytest_unconfigure(config=self)\n1061             self.hook.pytest_configure._call_history = []\n1062         while self._cleanup:\n1063             fin = self._cleanup.pop()\n1064             fin()\n1065 \n1066     def get_terminal_writer(self) -> TerminalWriter:\n1067         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n1068             \"terminalreporter\"\n1069         )\n1070         return terminalreporter._tw\n1071 \n1072     def pytest_cmdline_parse(\n1073         self, pluginmanager: PytestPluginManager, args: List[str]\n1074     ) -> \"Config\":\n1075         try:\n1076             self.parse(args)\n1077         except UsageError:\n1078             # Handle --version and --help here in a minimal fashion.\n1079             # This gets done via helpconfig normally, but its\n1080             # pytest_cmdline_main is not called in case of errors.\n1081             if getattr(self.option, \"version\", False) or \"--version\" in args:\n1082                 from _pytest.helpconfig import showversion\n1083 \n1084                 showversion(self)\n1085             elif (\n1086                 getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n1087             ):\n1088                 self._parser._getparser().print_help()\n1089                 sys.stdout.write(\n1090                     \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n1091                 )\n1092 \n1093             raise\n1094 \n1095         return self\n1096 \n1097     def notify_exception(\n1098         self,\n1099         excinfo: ExceptionInfo[BaseException],\n1100         option: Optional[argparse.Namespace] = None,\n1101     ) -> None:\n1102         if option and getattr(option, \"fulltrace\", False):\n1103             style: _TracebackStyle = \"long\"\n1104         else:\n1105             style = \"native\"\n1106         excrepr = excinfo.getrepr(\n1107             funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n1108         )\n1109         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n1110         if not any(res):\n1111             for line in str(excrepr).split(\"\\n\"):\n1112                 sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n1113                 sys.stderr.flush()\n1114 \n1115     def cwd_relative_nodeid(self, nodeid: str) -> str:\n1116         # nodeid's are relative to the rootpath, compute relative to cwd.\n1117         if self.invocation_params.dir != self.rootpath:\n1118             fullpath = self.rootpath / nodeid\n1119             nodeid = bestrelpath(self.invocation_params.dir, fullpath)\n1120         return nodeid\n1121 \n1122     @classmethod\n1123     def fromdictargs(cls, option_dict, args) -> \"Config\":\n1124         \"\"\"Constructor usable for subprocesses.\"\"\"\n1125         config = get_config(args)\n1126         config.option.__dict__.update(option_dict)\n1127         config.parse(args, addopts=False)\n1128         for x in config.option.plugins:\n1129             config.pluginmanager.consider_pluginarg(x)\n1130         return config\n1131 \n1132     def _processopt(self, opt: \"Argument\") -> None:\n1133         for name in opt._short_opts + opt._long_opts:\n1134             self._opt2dest[name] = opt.dest\n1135 \n1136         if hasattr(opt, \"default\"):\n1137             if not hasattr(self.option, opt.dest):\n1138                 setattr(self.option, opt.dest, opt.default)\n1139 \n1140     @hookimpl(trylast=True)\n1141     def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:\n1142         # We haven't fully parsed the command line arguments yet, so\n1143         # early_config.args it not set yet. But we need it for\n1144         # discovering the initial conftests. So \"pre-run\" the logic here.\n1145         # It will be done for real in `parse()`.\n1146         args, args_source = early_config._decide_args(\n1147             args=early_config.known_args_namespace.file_or_dir,\n1148             pyargs=early_config.known_args_namespace.pyargs,\n1149             testpaths=early_config.getini(\"testpaths\"),\n1150             invocation_dir=early_config.invocation_params.dir,\n1151             rootpath=early_config.rootpath,\n1152             warn=False,\n1153         )\n1154         self.pluginmanager._set_initial_conftests(\n1155             args=args,\n1156             pyargs=early_config.known_args_namespace.pyargs,\n1157             noconftest=early_config.known_args_namespace.noconftest,\n1158             rootpath=early_config.rootpath,\n1159             confcutdir=early_config.known_args_namespace.confcutdir,\n1160             importmode=early_config.known_args_namespace.importmode,\n1161         )\n1162 \n1163     def _initini(self, args: Sequence[str]) -> None:\n1164         ns, unknown_args = self._parser.parse_known_and_unknown_args(\n1165             args, namespace=copy.copy(self.option)\n1166         )\n1167         rootpath, inipath, inicfg = determine_setup(\n1168             ns.inifilename,\n1169             ns.file_or_dir + unknown_args,\n1170             rootdir_cmd_arg=ns.rootdir or None,\n1171             config=self,\n1172         )\n1173         self._rootpath = rootpath\n1174         self._inipath = inipath\n1175         self.inicfg = inicfg\n1176         self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n1177         self._parser.extra_info[\"inifile\"] = str(self.inipath)\n1178         self._parser.addini(\"addopts\", \"Extra command line options\", \"args\")\n1179         self._parser.addini(\"minversion\", \"Minimally required pytest version\")\n1180         self._parser.addini(\n1181             \"required_plugins\",\n1182             \"Plugins that must be present for pytest to run\",\n1183             type=\"args\",\n1184             default=[],\n1185         )\n1186         self._override_ini = ns.override_ini or ()\n1187 \n1188     def _consider_importhook(self, args: Sequence[str]) -> None:\n1189         \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n1190 \n1191         Needs to parse the --assert=<mode> option from the commandline\n1192         and find all the installed plugins to mark them for rewriting\n1193         by the importhook.\n1194         \"\"\"\n1195         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n1196         mode = getattr(ns, \"assertmode\", \"plain\")\n1197         if mode == \"rewrite\":\n1198             import _pytest.assertion\n1199 \n1200             try:\n1201                 hook = _pytest.assertion.install_importhook(self)\n1202             except SystemError:\n1203                 mode = \"plain\"\n1204             else:\n1205                 self._mark_plugins_for_rewrite(hook)\n1206         self._warn_about_missing_assertion(mode)\n1207 \n1208     def _mark_plugins_for_rewrite(self, hook) -> None:\n1209         \"\"\"Given an importhook, mark for rewrite any top-level\n1210         modules or packages in the distribution package for\n1211         all pytest plugins.\"\"\"\n1212         self.pluginmanager.rewrite_hook = hook\n1213 \n1214         if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n1215             # We don't autoload from setuptools entry points, no need to continue.\n1216             return\n1217 \n1218         package_files = (\n1219             str(file)\n1220             for dist in importlib.metadata.distributions()\n1221             if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n1222             for file in dist.files or []\n1223         )\n1224 \n1225         for name in _iter_rewritable_modules(package_files):\n1226             hook.mark_rewrite(name)\n1227 \n1228     def _validate_args(self, args: List[str], via: str) -> List[str]:\n1229         \"\"\"Validate known args.\"\"\"\n1230         self._parser._config_source_hint = via  # type: ignore\n1231         try:\n1232             self._parser.parse_known_and_unknown_args(\n1233                 args, namespace=copy.copy(self.option)\n1234             )\n1235         finally:\n1236             del self._parser._config_source_hint  # type: ignore\n1237 \n1238         return args\n1239 \n1240     def _decide_args(\n1241         self,\n1242         *,\n1243         args: List[str],\n1244         pyargs: List[str],\n1245         testpaths: List[str],\n1246         invocation_dir: Path,\n1247         rootpath: Path,\n1248         warn: bool,\n1249     ) -> Tuple[List[str], ArgsSource]:\n1250         \"\"\"Decide the args (initial paths/nodeids) to use given the relevant inputs.\n1251 \n1252         :param warn: Whether can issue warnings.\n1253         \"\"\"\n1254         if args:\n1255             source = Config.ArgsSource.ARGS\n1256             result = args\n1257         else:\n1258             if invocation_dir == rootpath:\n1259                 source = Config.ArgsSource.TESTPATHS\n1260                 if pyargs:\n1261                     result = testpaths\n1262                 else:\n1263                     result = []\n1264                     for path in testpaths:\n1265                         result.extend(sorted(glob.iglob(path, recursive=True)))\n1266                     if testpaths and not result:\n1267                         if warn:\n1268                             warning_text = (\n1269                                 \"No files were found in testpaths; \"\n1270                                 \"consider removing or adjusting your testpaths configuration. \"\n1271                                 \"Searching recursively from the current directory instead.\"\n1272                             )\n1273                             self.issue_config_time_warning(\n1274                                 PytestConfigWarning(warning_text), stacklevel=3\n1275                             )\n1276             else:\n1277                 result = []\n1278             if not result:\n1279                 source = Config.ArgsSource.INCOVATION_DIR\n1280                 result = [str(invocation_dir)]\n1281         return result, source\n1282 \n1283     def _preparse(self, args: List[str], addopts: bool = True) -> None:\n1284         if addopts:\n1285             env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n1286             if len(env_addopts):\n1287                 args[:] = (\n1288                     self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n1289                     + args\n1290                 )\n1291         self._initini(args)\n1292         if addopts:\n1293             args[:] = (\n1294                 self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n1295             )\n1296 \n1297         self.known_args_namespace = self._parser.parse_known_args(\n1298             args, namespace=copy.copy(self.option)\n1299         )\n1300         self._checkversion()\n1301         self._consider_importhook(args)\n1302         self.pluginmanager.consider_preparse(args, exclude_only=False)\n1303         if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n1304             # Don't autoload from setuptools entry point. Only explicitly specified\n1305             # plugins are going to be loaded.\n1306             self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n1307         self.pluginmanager.consider_env()\n1308 \n1309         self.known_args_namespace = self._parser.parse_known_args(\n1310             args, namespace=copy.copy(self.known_args_namespace)\n1311         )\n1312 \n1313         self._validate_plugins()\n1314         self._warn_about_skipped_plugins()\n1315 \n1316         if self.known_args_namespace.strict:\n1317             self.issue_config_time_warning(\n1318                 _pytest.deprecated.STRICT_OPTION, stacklevel=2\n1319             )\n1320 \n1321         if self.known_args_namespace.confcutdir is None:\n1322             if self.inipath is not None:\n1323                 confcutdir = str(self.inipath.parent)\n1324             else:\n1325                 confcutdir = str(self.rootpath)\n1326             self.known_args_namespace.confcutdir = confcutdir\n1327         try:\n1328             self.hook.pytest_load_initial_conftests(\n1329                 early_config=self, args=args, parser=self._parser\n1330             )\n1331         except ConftestImportFailure as e:\n1332             if self.known_args_namespace.help or self.known_args_namespace.version:\n1333                 # we don't want to prevent --help/--version to work\n1334                 # so just let is pass and print a warning at the end\n1335                 self.issue_config_time_warning(\n1336                     PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n1337                     stacklevel=2,\n1338                 )\n1339             else:\n1340                 raise\n1341 \n1342     @hookimpl(hookwrapper=True)\n1343     def pytest_collection(self) -> Generator[None, None, None]:\n1344         # Validate invalid ini keys after collection is done so we take in account\n1345         # options added by late-loading conftest files.\n1346         yield\n1347         self._validate_config_options()\n1348 \n1349     def _checkversion(self) -> None:\n1350         import pytest\n1351 \n1352         minver = self.inicfg.get(\"minversion\", None)\n1353         if minver:\n1354             # Imported lazily to improve start-up time.\n1355             from packaging.version import Version\n1356 \n1357             if not isinstance(minver, str):\n1358                 raise pytest.UsageError(\n1359                     \"%s: 'minversion' must be a single value\" % self.inipath\n1360                 )\n1361 \n1362             if Version(minver) > Version(pytest.__version__):\n1363                 raise pytest.UsageError(\n1364                     \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n1365                     % (\n1366                         self.inipath,\n1367                         minver,\n1368                         pytest.__version__,\n1369                     )\n1370                 )\n1371 \n1372     def _validate_config_options(self) -> None:\n1373         for key in sorted(self._get_unknown_ini_keys()):\n1374             self._warn_or_fail_if_strict(f\"Unknown config option: {key}\\n\")\n1375 \n1376     def _validate_plugins(self) -> None:\n1377         required_plugins = sorted(self.getini(\"required_plugins\"))\n1378         if not required_plugins:\n1379             return\n1380 \n1381         # Imported lazily to improve start-up time.\n1382         from packaging.version import Version\n1383         from packaging.requirements import InvalidRequirement, Requirement\n1384 \n1385         plugin_info = self.pluginmanager.list_plugin_distinfo()\n1386         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n1387 \n1388         missing_plugins = []\n1389         for required_plugin in required_plugins:\n1390             try:\n1391                 req = Requirement(required_plugin)\n1392             except InvalidRequirement:\n1393                 missing_plugins.append(required_plugin)\n1394                 continue\n1395 \n1396             if req.name not in plugin_dist_info:\n1397                 missing_plugins.append(required_plugin)\n1398             elif not req.specifier.contains(\n1399                 Version(plugin_dist_info[req.name]), prereleases=True\n1400             ):\n1401                 missing_plugins.append(required_plugin)\n1402 \n1403         if missing_plugins:\n1404             raise UsageError(\n1405                 \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),\n1406             )\n1407 \n1408     def _warn_or_fail_if_strict(self, message: str) -> None:\n1409         if self.known_args_namespace.strict_config:\n1410             raise UsageError(message)\n1411 \n1412         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)\n1413 \n1414     def _get_unknown_ini_keys(self) -> List[str]:\n1415         parser_inicfg = self._parser._inidict\n1416         return [name for name in self.inicfg if name not in parser_inicfg]\n1417 \n1418     def parse(self, args: List[str], addopts: bool = True) -> None:\n1419         # Parse given cmdline arguments into this config object.\n1420         assert (\n1421             self.args == []\n1422         ), \"can only parse cmdline args at most once per Config object\"\n1423         self.hook.pytest_addhooks.call_historic(\n1424             kwargs=dict(pluginmanager=self.pluginmanager)\n1425         )\n1426         self._preparse(args, addopts=addopts)\n1427         # XXX deprecated hook:\n1428         self.hook.pytest_cmdline_preparse(config=self, args=args)\n1429         self._parser.after_preparse = True  # type: ignore\n1430         try:\n1431             args = self._parser.parse_setoption(\n1432                 args, self.option, namespace=self.option\n1433             )\n1434             self.args, self.args_source = self._decide_args(\n1435                 args=args,\n1436                 pyargs=self.known_args_namespace.pyargs,\n1437                 testpaths=self.getini(\"testpaths\"),\n1438                 invocation_dir=self.invocation_params.dir,\n1439                 rootpath=self.rootpath,\n1440                 warn=True,\n1441             )\n1442         except PrintHelp:\n1443             pass\n1444 \n1445     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n1446         \"\"\"Issue and handle a warning during the \"configure\" stage.\n1447 \n1448         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n1449         function because it is not possible to have hookwrappers around ``pytest_configure``.\n1450 \n1451         This function is mainly intended for plugins that need to issue warnings during\n1452         ``pytest_configure`` (or similar stages).\n1453 \n1454         :param warning: The warning instance.\n1455         :param stacklevel: stacklevel forwarded to warnings.warn.\n1456         \"\"\"\n1457         if self.pluginmanager.is_blocked(\"warnings\"):\n1458             return\n1459 \n1460         cmdline_filters = self.known_args_namespace.pythonwarnings or []\n1461         config_filters = self.getini(\"filterwarnings\")\n1462 \n1463         with warnings.catch_warnings(record=True) as records:\n1464             warnings.simplefilter(\"always\", type(warning))\n1465             apply_warning_filters(config_filters, cmdline_filters)\n1466             warnings.warn(warning, stacklevel=stacklevel)\n1467 \n1468         if records:\n1469             frame = sys._getframe(stacklevel - 1)\n1470             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n1471             self.hook.pytest_warning_recorded.call_historic(\n1472                 kwargs=dict(\n1473                     warning_message=records[0],\n1474                     when=\"config\",\n1475                     nodeid=\"\",\n1476                     location=location,\n1477                 )\n1478             )\n1479 \n1480     def addinivalue_line(self, name: str, line: str) -> None:\n1481         \"\"\"Add a line to an ini-file option. The option must have been\n1482         declared but might not yet be set in which case the line becomes\n1483         the first line in its value.\"\"\"\n1484         x = self.getini(name)\n1485         assert isinstance(x, list)\n1486         x.append(line)  # modifies the cached list inline\n1487 \n1488     def getini(self, name: str):\n1489         \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n1490 \n1491         If the specified name hasn't been registered through a prior\n1492         :func:`parser.addini <pytest.Parser.addini>` call (usually from a\n1493         plugin), a ValueError is raised.\n1494         \"\"\"\n1495         try:\n1496             return self._inicache[name]\n1497         except KeyError:\n1498             self._inicache[name] = val = self._getini(name)\n1499             return val\n1500 \n1501     # Meant for easy monkeypatching by legacypath plugin.\n1502     # Can be inlined back (with no cover removed) once legacypath is gone.\n1503     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):\n1504         msg = f\"unknown configuration type: {type}\"\n1505         raise ValueError(msg, value)  # pragma: no cover\n1506 \n1507     def _getini(self, name: str):\n1508         try:\n1509             description, type, default = self._parser._inidict[name]\n1510         except KeyError as e:\n1511             raise ValueError(f\"unknown configuration value: {name!r}\") from e\n1512         override_value = self._get_override_ini_value(name)\n1513         if override_value is None:\n1514             try:\n1515                 value = self.inicfg[name]\n1516             except KeyError:\n1517                 if default is not None:\n1518                     return default\n1519                 if type is None:\n1520                     return \"\"\n1521                 return []\n1522         else:\n1523             value = override_value\n1524         # Coerce the values based on types.\n1525         #\n1526         # Note: some coercions are only required if we are reading from .ini files, because\n1527         # the file format doesn't contain type information, but when reading from toml we will\n1528         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n1529         # For example:\n1530         #\n1531         #   ini:\n1532         #     a_line_list = \"tests acceptance\"\n1533         #   in this case, we need to split the string to obtain a list of strings.\n1534         #\n1535         #   toml:\n1536         #     a_line_list = [\"tests\", \"acceptance\"]\n1537         #   in this case, we already have a list ready to use.\n1538         #\n1539         if type == \"paths\":\n1540             # TODO: This assert is probably not valid in all cases.\n1541             assert self.inipath is not None\n1542             dp = self.inipath.parent\n1543             input_values = shlex.split(value) if isinstance(value, str) else value\n1544             return [dp / x for x in input_values]\n1545         elif type == \"args\":\n1546             return shlex.split(value) if isinstance(value, str) else value\n1547         elif type == \"linelist\":\n1548             if isinstance(value, str):\n1549                 return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n1550             else:\n1551                 return value\n1552         elif type == \"bool\":\n1553             return _strtobool(str(value).strip())\n1554         elif type == \"string\":\n1555             return value\n1556         elif type is None:\n1557             return value\n1558         else:\n1559             return self._getini_unknown_type(name, type, value)\n1560 \n1561     def _getconftest_pathlist(\n1562         self, name: str, path: Path, rootpath: Path\n1563     ) -> Optional[List[Path]]:\n1564         try:\n1565             mod, relroots = self.pluginmanager._rget_with_confmod(\n1566                 name, path, self.getoption(\"importmode\"), rootpath\n1567             )\n1568         except KeyError:\n1569             return None\n1570         assert mod.__file__ is not None\n1571         modpath = Path(mod.__file__).parent\n1572         values: List[Path] = []\n1573         for relroot in relroots:\n1574             if isinstance(relroot, os.PathLike):\n1575                 relroot = Path(relroot)\n1576             else:\n1577                 relroot = relroot.replace(\"/\", os.sep)\n1578                 relroot = absolutepath(modpath / relroot)\n1579             values.append(relroot)\n1580         return values\n1581 \n1582     def _get_override_ini_value(self, name: str) -> Optional[str]:\n1583         value = None\n1584         # override_ini is a list of \"ini=value\" options.\n1585         # Always use the last item if multiple values are set for same ini-name,\n1586         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n1587         for ini_config in self._override_ini:\n1588             try:\n1589                 key, user_ini_value = ini_config.split(\"=\", 1)\n1590             except ValueError as e:\n1591                 raise UsageError(\n1592                     \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n1593                         ini_config\n1594                     )\n1595                 ) from e\n1596             else:\n1597                 if key == name:\n1598                     value = user_ini_value\n1599         return value\n1600 \n1601     def getoption(self, name: str, default=notset, skip: bool = False):\n1602         \"\"\"Return command line option value.\n1603 \n1604         :param name: Name of the option.  You may also specify\n1605             the literal ``--OPT`` option instead of the \"dest\" option name.\n1606         :param default: Default value if no option of that name exists.\n1607         :param skip: If True, raise pytest.skip if option does not exists\n1608             or has a None value.\n1609         \"\"\"\n1610         name = self._opt2dest.get(name, name)\n1611         try:\n1612             val = getattr(self.option, name)\n1613             if val is None and skip:\n1614                 raise AttributeError(name)\n1615             return val\n1616         except AttributeError as e:\n1617             if default is not notset:\n1618                 return default\n1619             if skip:\n1620                 import pytest\n1621 \n1622                 pytest.skip(f\"no {name!r} option found\")\n1623             raise ValueError(f\"no option named {name!r}\") from e\n1624 \n1625     def getvalue(self, name: str, path=None):\n1626         \"\"\"Deprecated, use getoption() instead.\"\"\"\n1627         return self.getoption(name)\n1628 \n1629     def getvalueorskip(self, name: str, path=None):\n1630         \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\"\n1631         return self.getoption(name, skip=True)\n1632 \n1633     def _warn_about_missing_assertion(self, mode: str) -> None:\n1634         if not _assertion_supported():\n1635             if mode == \"plain\":\n1636                 warning_text = (\n1637                     \"ASSERTIONS ARE NOT EXECUTED\"\n1638                     \" and FAILING TESTS WILL PASS.  Are you\"\n1639                     \" using python -O?\"\n1640                 )\n1641             else:\n1642                 warning_text = (\n1643                     \"assertions not in test modules or\"\n1644                     \" plugins will be ignored\"\n1645                     \" because assert statements are not executed \"\n1646                     \"by the underlying Python interpreter \"\n1647                     \"(are you using python -O?)\\n\"\n1648                 )\n1649             self.issue_config_time_warning(\n1650                 PytestConfigWarning(warning_text),\n1651                 stacklevel=3,\n1652             )\n1653 \n1654     def _warn_about_skipped_plugins(self) -> None:\n1655         for module_name, msg in self.pluginmanager.skipped_plugins:\n1656             self.issue_config_time_warning(\n1657                 PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n1658                 stacklevel=2,\n1659             )\n1660 \n1661 \n1662 def _assertion_supported() -> bool:\n1663     try:\n1664         assert False\n1665     except AssertionError:\n1666         return True\n1667     else:\n1668         return False  # type: ignore[unreachable]\n1669 \n1670 \n1671 def create_terminal_writer(\n1672     config: Config, file: Optional[TextIO] = None\n1673 ) -> TerminalWriter:\n1674     \"\"\"Create a TerminalWriter instance configured according to the options\n1675     in the config object.\n1676 \n1677     Every code which requires a TerminalWriter object and has access to a\n1678     config object should use this function.\n1679     \"\"\"\n1680     tw = TerminalWriter(file=file)\n1681 \n1682     if config.option.color == \"yes\":\n1683         tw.hasmarkup = True\n1684     elif config.option.color == \"no\":\n1685         tw.hasmarkup = False\n1686 \n1687     if config.option.code_highlight == \"yes\":\n1688         tw.code_highlight = True\n1689     elif config.option.code_highlight == \"no\":\n1690         tw.code_highlight = False\n1691 \n1692     return tw\n1693 \n1694 \n1695 def _strtobool(val: str) -> bool:\n1696     \"\"\"Convert a string representation of truth to True or False.\n1697 \n1698     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n1699     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n1700     'val' is anything else.\n1701 \n1702     .. note:: Copied from distutils.util.\n1703     \"\"\"\n1704     val = val.lower()\n1705     if val in (\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"):\n1706         return True\n1707     elif val in (\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"):\n1708         return False\n1709     else:\n1710         raise ValueError(f\"invalid truth value {val!r}\")\n1711 \n1712 \n1713 @lru_cache(maxsize=50)\n1714 def parse_warning_filter(\n1715     arg: str, *, escape: bool\n1716 ) -> Tuple[\"warnings._ActionKind\", str, Type[Warning], str, int]:\n1717     \"\"\"Parse a warnings filter string.\n1718 \n1719     This is copied from warnings._setoption with the following changes:\n1720 \n1721     * Does not apply the filter.\n1722     * Escaping is optional.\n1723     * Raises UsageError so we get nice error messages on failure.\n1724     \"\"\"\n1725     __tracebackhide__ = True\n1726     error_template = dedent(\n1727         f\"\"\"\\\n1728         while parsing the following warning configuration:\n1729 \n1730           {arg}\n1731 \n1732         This error occurred:\n1733 \n1734         {{error}}\n1735         \"\"\"\n1736     )\n1737 \n1738     parts = arg.split(\":\")\n1739     if len(parts) > 5:\n1740         doc_url = (\n1741             \"https://docs.python.org/3/library/warnings.html#describing-warning-filters\"\n1742         )\n1743         error = dedent(\n1744             f\"\"\"\\\n1745             Too many fields ({len(parts)}), expected at most 5 separated by colons:\n1746 \n1747               action:message:category:module:line\n1748 \n1749             For more information please consult: {doc_url}\n1750             \"\"\"\n1751         )\n1752         raise UsageError(error_template.format(error=error))\n1753 \n1754     while len(parts) < 5:\n1755         parts.append(\"\")\n1756     action_, message, category_, module, lineno_ = (s.strip() for s in parts)\n1757     try:\n1758         action: \"warnings._ActionKind\" = warnings._getaction(action_)  # type: ignore[attr-defined]\n1759     except warnings._OptionError as e:\n1760         raise UsageError(error_template.format(error=str(e)))\n1761     try:\n1762         category: Type[Warning] = _resolve_warning_category(category_)\n1763     except Exception:\n1764         exc_info = ExceptionInfo.from_current()\n1765         exception_text = exc_info.getrepr(style=\"native\")\n1766         raise UsageError(error_template.format(error=exception_text))\n1767     if message and escape:\n1768         message = re.escape(message)\n1769     if module and escape:\n1770         module = re.escape(module) + r\"\\Z\"\n1771     if lineno_:\n1772         try:\n1773             lineno = int(lineno_)\n1774             if lineno < 0:\n1775                 raise ValueError(\"number is negative\")\n1776         except ValueError as e:\n1777             raise UsageError(\n1778                 error_template.format(error=f\"invalid lineno {lineno_!r}: {e}\")\n1779             )\n1780     else:\n1781         lineno = 0\n1782     return action, message, category, module, lineno\n1783 \n1784 \n1785 def _resolve_warning_category(category: str) -> Type[Warning]:\n1786     \"\"\"\n1787     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)\n1788     propagate so we can get access to their tracebacks (#9218).\n1789     \"\"\"\n1790     __tracebackhide__ = True\n1791     if not category:\n1792         return Warning\n1793 \n1794     if \".\" not in category:\n1795         import builtins as m\n1796 \n1797         klass = category\n1798     else:\n1799         module, _, klass = category.rpartition(\".\")\n1800         m = __import__(module, None, None, [klass])\n1801     cat = getattr(m, klass)\n1802     if not issubclass(cat, Warning):\n1803         raise UsageError(f\"{cat} is not a Warning subclass\")\n1804     return cast(Type[Warning], cat)\n1805 \n1806 \n1807 def apply_warning_filters(\n1808     config_filters: Iterable[str], cmdline_filters: Iterable[str]\n1809 ) -> None:\n1810     \"\"\"Applies pytest-configured filters to the warnings module\"\"\"\n1811     # Filters should have this precedence: cmdline options, config.\n1812     # Filters should be applied in the inverse order of precedence.\n1813     for arg in config_filters:\n1814         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))\n1815 \n1816     for arg in cmdline_filters:\n1817         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))\n",
        "intended_behavior": "Ensure that when modules are loaded, particularly those related to `pmxbot`, they are loaded in a manner that recognizes and respects the PEP 420 namespace packages, preventing duplicate instances. This may involve checking the configuration logic to ensure it does not inadvertently cause a module to be re-imported or re-initialized in a manner that creates two separate instances of what should be a single module in `sys.modules`."
    },
    {
        "rel_file_path": "src/_pytest/pathlib.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/pathlib.py",
        "start": 1,
        "end": 787,
        "class_name": null,
        "method_name": null,
        "code": "1 import atexit\n2 import contextlib\n3 import fnmatch\n4 import importlib.util\n5 import itertools\n6 import os\n7 import shutil\n8 import sys\n9 import types\n10 import uuid\n11 import warnings\n12 from enum import Enum\n13 from errno import EBADF\n14 from errno import ELOOP\n15 from errno import ENOENT\n16 from errno import ENOTDIR\n17 from functools import partial\n18 from os.path import expanduser\n19 from os.path import expandvars\n20 from os.path import isabs\n21 from os.path import sep\n22 from pathlib import Path\n23 from pathlib import PurePath\n24 from posixpath import sep as posix_sep\n25 from types import ModuleType\n26 from typing import Callable\n27 from typing import Dict\n28 from typing import Iterable\n29 from typing import Iterator\n30 from typing import List\n31 from typing import Optional\n32 from typing import Set\n33 from typing import Tuple\n34 from typing import Type\n35 from typing import TypeVar\n36 from typing import Union\n37 \n38 from _pytest.compat import assert_never\n39 from _pytest.outcomes import skip\n40 from _pytest.warning_types import PytestWarning\n41 \n42 LOCK_TIMEOUT = 60 * 60 * 24 * 3\n43 \n44 \n45 _AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n46 \n47 # The following function, variables and comments were\n48 # copied from cpython 3.9 Lib/pathlib.py file.\n49 \n50 # EBADF - guard against macOS `stat` throwing EBADF\n51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\n52 \n53 _IGNORED_WINERRORS = (\n54     21,  # ERROR_NOT_READY - drive exists but is not accessible\n55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n56 )\n57 \n58 \n59 def _ignore_error(exception):\n60     return (\n61         getattr(exception, \"errno\", None) in _IGNORED_ERRORS\n62         or getattr(exception, \"winerror\", None) in _IGNORED_WINERRORS\n63     )\n64 \n65 \n66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:\n67     return path.joinpath(\".lock\")\n68 \n69 \n70 def on_rm_rf_error(\n71     func,\n72     path: str,\n73     excinfo: Union[\n74         BaseException,\n75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],\n76     ],\n77     *,\n78     start_path: Path,\n79 ) -> bool:\n80     \"\"\"Handle known read-only errors during rmtree.\n81 \n82     The returned value is used only by our own tests.\n83     \"\"\"\n84     if isinstance(excinfo, BaseException):\n85         exc = excinfo\n86     else:\n87         exc = excinfo[1]\n88 \n89     # Another process removed the file in the middle of the \"rm_rf\" (xdist for example).\n90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018\n91     if isinstance(exc, FileNotFoundError):\n92         return False\n93 \n94     if not isinstance(exc, PermissionError):\n95         warnings.warn(\n96             PytestWarning(f\"(rm_rf) error removing {path}\\n{type(exc)}: {exc}\")\n97         )\n98         return False\n99 \n100     if func not in (os.rmdir, os.remove, os.unlink):\n101         if func not in (os.open,):\n102             warnings.warn(\n103                 PytestWarning(\n104                     \"(rm_rf) unknown function {} when removing {}:\\n{}: {}\".format(\n105                         func, path, type(exc), exc\n106                     )\n107                 )\n108             )\n109         return False\n110 \n111     # Chmod + retry.\n112     import stat\n113 \n114     def chmod_rw(p: str) -> None:\n115         mode = os.stat(p).st_mode\n116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)\n117 \n118     # For files, we need to recursively go upwards in the directories to\n119     # ensure they all are also writable.\n120     p = Path(path)\n121     if p.is_file():\n122         for parent in p.parents:\n123             chmod_rw(str(parent))\n124             # Stop when we reach the original path passed to rm_rf.\n125             if parent == start_path:\n126                 break\n127     chmod_rw(str(path))\n128 \n129     func(path)\n130     return True\n131 \n132 \n133 def ensure_extended_length_path(path: Path) -> Path:\n134     \"\"\"Get the extended-length version of a path (Windows).\n135 \n136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260\n137     characters, and operations on paths longer than that fail. But it is possible\n138     to overcome this by converting the path to \"extended-length\" form before\n139     performing the operation:\n140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n141 \n142     On Windows, this function returns the extended-length absolute version of path.\n143     On other platforms it returns path unchanged.\n144     \"\"\"\n145     if sys.platform.startswith(\"win32\"):\n146         path = path.resolve()\n147         path = Path(get_extended_length_path_str(str(path)))\n148     return path\n149 \n150 \n151 def get_extended_length_path_str(path: str) -> str:\n152     \"\"\"Convert a path to a Windows extended length path.\"\"\"\n153     long_path_prefix = \"\\\\\\\\?\\\\\"\n154     unc_long_path_prefix = \"\\\\\\\\?\\\\UNC\\\\\"\n155     if path.startswith((long_path_prefix, unc_long_path_prefix)):\n156         return path\n157     # UNC\n158     if path.startswith(\"\\\\\\\\\"):\n159         return unc_long_path_prefix + path[2:]\n160     return long_path_prefix + path\n161 \n162 \n163 def rm_rf(path: Path) -> None:\n164     \"\"\"Remove the path contents recursively, even if some elements\n165     are read-only.\"\"\"\n166     path = ensure_extended_length_path(path)\n167     onerror = partial(on_rm_rf_error, start_path=path)\n168     if sys.version_info >= (3, 12):\n169         shutil.rmtree(str(path), onexc=onerror)\n170     else:\n171         shutil.rmtree(str(path), onerror=onerror)\n172 \n173 \n174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n175     \"\"\"Find all elements in root that begin with the prefix, case insensitive.\"\"\"\n176     l_prefix = prefix.lower()\n177     for x in root.iterdir():\n178         if x.name.lower().startswith(l_prefix):\n179             yield x\n180 \n181 \n182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n183     \"\"\"Return the parts of the paths following the prefix.\n184 \n185     :param iter: Iterator over path names.\n186     :param prefix: Expected prefix of the path names.\n187     \"\"\"\n188     p_len = len(prefix)\n189     for p in iter:\n190         yield p.name[p_len:]\n191 \n192 \n193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:\n194     \"\"\"Combine find_prefixes and extract_suffixes.\"\"\"\n195     return extract_suffixes(find_prefixed(root, prefix), prefix)\n196 \n197 \n198 def parse_num(maybe_num) -> int:\n199     \"\"\"Parse number path suffixes, returns -1 on error.\"\"\"\n200     try:\n201         return int(maybe_num)\n202     except ValueError:\n203         return -1\n204 \n205 \n206 def _force_symlink(\n207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]\n208 ) -> None:\n209     \"\"\"Helper to create the current symlink.\n210 \n211     It's full of race conditions that are reasonably OK to ignore\n212     for the context of best effort linking to the latest test run.\n213 \n214     The presumption being that in case of much parallelism\n215     the inaccuracy is going to be acceptable.\n216     \"\"\"\n217     current_symlink = root.joinpath(target)\n218     try:\n219         current_symlink.unlink()\n220     except OSError:\n221         pass\n222     try:\n223         current_symlink.symlink_to(link_to)\n224     except Exception:\n225         pass\n226 \n227 \n228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:\n229     \"\"\"Create a directory with an increased number as suffix for the given prefix.\"\"\"\n230     for i in range(10):\n231         # try up to 10 times to create the folder\n232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n233         new_number = max_existing + 1\n234         new_path = root.joinpath(f\"{prefix}{new_number}\")\n235         try:\n236             new_path.mkdir(mode=mode)\n237         except Exception:\n238             pass\n239         else:\n240             _force_symlink(root, prefix + \"current\", new_path)\n241             return new_path\n242     else:\n243         raise OSError(\n244             \"could not create numbered dir with prefix \"\n245             \"{prefix} in {root} after 10 tries\".format(prefix=prefix, root=root)\n246         )\n247 \n248 \n249 def create_cleanup_lock(p: Path) -> Path:\n250     \"\"\"Create a lock to prevent premature folder cleanup.\"\"\"\n251     lock_path = get_lock_path(p)\n252     try:\n253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)\n254     except FileExistsError as e:\n255         raise OSError(f\"cannot create lockfile in {p}\") from e\n256     else:\n257         pid = os.getpid()\n258         spid = str(pid).encode()\n259         os.write(fd, spid)\n260         os.close(fd)\n261         if not lock_path.is_file():\n262             raise OSError(\"lock path got renamed after successful creation\")\n263         return lock_path\n264 \n265 \n266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):\n267     \"\"\"Register a cleanup function for removing a lock, by default on atexit.\"\"\"\n268     pid = os.getpid()\n269 \n270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:\n271         current_pid = os.getpid()\n272         if current_pid != original_pid:\n273             # fork\n274             return\n275         try:\n276             lock_path.unlink()\n277         except OSError:\n278             pass\n279 \n280     return register(cleanup_on_exit)\n281 \n282 \n283 def maybe_delete_a_numbered_dir(path: Path) -> None:\n284     \"\"\"Remove a numbered directory if its lock can be obtained and it does\n285     not seem to be in use.\"\"\"\n286     path = ensure_extended_length_path(path)\n287     lock_path = None\n288     try:\n289         lock_path = create_cleanup_lock(path)\n290         parent = path.parent\n291 \n292         garbage = parent.joinpath(f\"garbage-{uuid.uuid4()}\")\n293         path.rename(garbage)\n294         rm_rf(garbage)\n295     except OSError:\n296         #  known races:\n297         #  * other process did a cleanup at the same time\n298         #  * deletable folder was found\n299         #  * process cwd (Windows)\n300         return\n301     finally:\n302         # If we created the lock, ensure we remove it even if we failed\n303         # to properly remove the numbered dir.\n304         if lock_path is not None:\n305             try:\n306                 lock_path.unlink()\n307             except OSError:\n308                 pass\n309 \n310 \n311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:\n312     \"\"\"Check if `path` is deletable based on whether the lock file is expired.\"\"\"\n313     if path.is_symlink():\n314         return False\n315     lock = get_lock_path(path)\n316     try:\n317         if not lock.is_file():\n318             return True\n319     except OSError:\n320         # we might not have access to the lock file at all, in this case assume\n321         # we don't have access to the entire directory (#7491).\n322         return False\n323     try:\n324         lock_time = lock.stat().st_mtime\n325     except Exception:\n326         return False\n327     else:\n328         if lock_time < consider_lock_dead_if_created_before:\n329             # We want to ignore any errors while trying to remove the lock such as:\n330             # - PermissionDenied, like the file permissions have changed since the lock creation;\n331             # - FileNotFoundError, in case another pytest process got here first;\n332             # and any other cause of failure.\n333             with contextlib.suppress(OSError):\n334                 lock.unlink()\n335                 return True\n336         return False\n337 \n338 \n339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:\n340     \"\"\"Try to cleanup a folder if we can ensure it's deletable.\"\"\"\n341     if ensure_deletable(path, consider_lock_dead_if_created_before):\n342         maybe_delete_a_numbered_dir(path)\n343 \n344 \n345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n346     \"\"\"List candidates for numbered directories to be removed - follows py.path.\"\"\"\n347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n348     max_delete = max_existing - keep\n349     paths = find_prefixed(root, prefix)\n350     paths, paths2 = itertools.tee(paths)\n351     numbers = map(parse_num, extract_suffixes(paths2, prefix))\n352     for path, number in zip(paths, numbers):\n353         if number <= max_delete:\n354             yield path\n355 \n356 \n357 def cleanup_dead_symlinks(root: Path):\n358     for left_dir in root.iterdir():\n359         if left_dir.is_symlink():\n360             if not left_dir.resolve().exists():\n361                 left_dir.unlink()\n362 \n363 \n364 def cleanup_numbered_dir(\n365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float\n366 ) -> None:\n367     \"\"\"Cleanup for lock driven numbered directories.\"\"\"\n368     if not root.exists():\n369         return\n370     for path in cleanup_candidates(root, prefix, keep):\n371         try_cleanup(path, consider_lock_dead_if_created_before)\n372     for path in root.glob(\"garbage-*\"):\n373         try_cleanup(path, consider_lock_dead_if_created_before)\n374 \n375     cleanup_dead_symlinks(root)\n376 \n377 \n378 def make_numbered_dir_with_cleanup(\n379     root: Path,\n380     prefix: str,\n381     keep: int,\n382     lock_timeout: float,\n383     mode: int,\n384 ) -> Path:\n385     \"\"\"Create a numbered dir with a cleanup lock and remove old ones.\"\"\"\n386     e = None\n387     for i in range(10):\n388         try:\n389             p = make_numbered_dir(root, prefix, mode)\n390             # Only lock the current dir when keep is not 0\n391             if keep != 0:\n392                 lock_path = create_cleanup_lock(p)\n393                 register_cleanup_lock_removal(lock_path)\n394         except Exception as exc:\n395             e = exc\n396         else:\n397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout\n398             # Register a cleanup for program exit\n399             atexit.register(\n400                 cleanup_numbered_dir,\n401                 root,\n402                 prefix,\n403                 keep,\n404                 consider_lock_dead_if_created_before,\n405             )\n406             return p\n407     assert e is not None\n408     raise e\n409 \n410 \n411 def resolve_from_str(input: str, rootpath: Path) -> Path:\n412     input = expanduser(input)\n413     input = expandvars(input)\n414     if isabs(input):\n415         return Path(input)\n416     else:\n417         return rootpath.joinpath(input)\n418 \n419 \n420 def fnmatch_ex(pattern: str, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n421     \"\"\"A port of FNMatcher from py.path.common which works with PurePath() instances.\n422 \n423     The difference between this algorithm and PurePath.match() is that the\n424     latter matches \"**\" glob expressions for each part of the path, while\n425     this algorithm uses the whole path instead.\n426 \n427     For example:\n428         \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\"\n429         with this algorithm, but not with PurePath.match().\n430 \n431     This algorithm was ported to keep backward-compatibility with existing\n432     settings which assume paths match according this logic.\n433 \n434     References:\n435     * https://bugs.python.org/issue29249\n436     * https://bugs.python.org/issue34731\n437     \"\"\"\n438     path = PurePath(path)\n439     iswin32 = sys.platform.startswith(\"win\")\n440 \n441     if iswin32 and sep not in pattern and posix_sep in pattern:\n442         # Running on Windows, the pattern has no Windows path separators,\n443         # and the pattern has one or more Posix path separators. Replace\n444         # the Posix path separators with the Windows path separator.\n445         pattern = pattern.replace(posix_sep, sep)\n446 \n447     if sep not in pattern:\n448         name = path.name\n449     else:\n450         name = str(path)\n451         if path.is_absolute() and not os.path.isabs(pattern):\n452             pattern = f\"*{os.sep}{pattern}\"\n453     return fnmatch.fnmatch(name, pattern)\n454 \n455 \n456 def parts(s: str) -> Set[str]:\n457     parts = s.split(sep)\n458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}\n459 \n460 \n461 def symlink_or_skip(src, dst, **kwargs):\n462     \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n463     try:\n464         os.symlink(str(src), str(dst), **kwargs)\n465     except OSError as e:\n466         skip(f\"symlinks not supported: {e}\")\n467 \n468 \n469 class ImportMode(Enum):\n470     \"\"\"Possible values for `mode` parameter of `import_path`.\"\"\"\n471 \n472     prepend = \"prepend\"\n473     append = \"append\"\n474     importlib = \"importlib\"\n475 \n476 \n477 class ImportPathMismatchError(ImportError):\n478     \"\"\"Raised on import_path() if there is a mismatch of __file__'s.\n479 \n480     This can happen when `import_path` is called multiple times with different filenames that has\n481     the same basename but reside in packages\n482     (for example \"/tests1/test_foo.py\" and \"/tests2/test_foo.py\").\n483     \"\"\"\n484 \n485 \n486 def import_path(\n487     p: Union[str, \"os.PathLike[str]\"],\n488     *,\n489     mode: Union[str, ImportMode] = ImportMode.prepend,\n490     root: Path,\n491 ) -> ModuleType:\n492     \"\"\"Import and return a module from the given path, which can be a file (a module) or\n493     a directory (a package).\n494 \n495     The import mechanism used is controlled by the `mode` parameter:\n496 \n497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking\n498       `__init__.py` files into account) will be put at the *start* of `sys.path` before\n499       being imported with `importlib.import_module`.\n500 \n501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended\n502       to the end of `sys.path`, if not already in `sys.path`.\n503 \n504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`\n505       to import the module, which avoids having to muck with `sys.path` at all. It effectively\n506       allows having same-named test modules in different places.\n507 \n508     :param root:\n509         Used as an anchor when mode == ImportMode.importlib to obtain\n510         a unique name for the module being imported so it can safely be stored\n511         into ``sys.modules``.\n512 \n513     :raises ImportPathMismatchError:\n514         If after importing the given `path` and the module `__file__`\n515         are different. Only raised in `prepend` and `append` modes.\n516     \"\"\"\n517     mode = ImportMode(mode)\n518 \n519     path = Path(p)\n520 \n521     if not path.exists():\n522         raise ImportError(path)\n523 \n524     if mode is ImportMode.importlib:\n525         module_name = module_name_from_path(path, root)\n526 \n527         for meta_importer in sys.meta_path:\n528             spec = meta_importer.find_spec(module_name, [str(path.parent)])\n529             if spec is not None:\n530                 break\n531         else:\n532             spec = importlib.util.spec_from_file_location(module_name, str(path))\n533 \n534         if spec is None:\n535             raise ImportError(f\"Can't find module {module_name} at location {path}\")\n536         mod = importlib.util.module_from_spec(spec)\n537         sys.modules[module_name] = mod\n538         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n539         insert_missing_modules(sys.modules, module_name)\n540         return mod\n541 \n542     pkg_path = resolve_package_path(path)\n543     if pkg_path is not None:\n544         pkg_root = pkg_path.parent\n545         names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n546         if names[-1] == \"__init__\":\n547             names.pop()\n548         module_name = \".\".join(names)\n549     else:\n550         pkg_root = path.parent\n551         module_name = path.stem\n552 \n553     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n554     # problems because of delayed imports: for example, a conftest.py file imported by this function\n555     # might have local imports, which would fail at runtime if we restored sys.path.\n556     if mode is ImportMode.append:\n557         if str(pkg_root) not in sys.path:\n558             sys.path.append(str(pkg_root))\n559     elif mode is ImportMode.prepend:\n560         if str(pkg_root) != sys.path[0]:\n561             sys.path.insert(0, str(pkg_root))\n562     else:\n563         assert_never(mode)\n564 \n565     importlib.import_module(module_name)\n566 \n567     mod = sys.modules[module_name]\n568     if path.name == \"__init__.py\":\n569         return mod\n570 \n571     ignore = os.environ.get(\"PY_IGNORE_IMPORTMISMATCH\", \"\")\n572     if ignore != \"1\":\n573         module_file = mod.__file__\n574         if module_file is None:\n575             raise ImportPathMismatchError(module_name, module_file, path)\n576 \n577         if module_file.endswith((\".pyc\", \".pyo\")):\n578             module_file = module_file[:-1]\n579         if module_file.endswith(os.sep + \"__init__.py\"):\n580             module_file = module_file[: -(len(os.sep + \"__init__.py\"))]\n581 \n582         try:\n583             is_same = _is_same(str(path), module_file)\n584         except FileNotFoundError:\n585             is_same = False\n586 \n587         if not is_same:\n588             raise ImportPathMismatchError(module_name, module_file, path)\n589 \n590     return mod\n591 \n592 \n593 # Implement a special _is_same function on Windows which returns True if the two filenames\n594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).\n595 if sys.platform.startswith(\"win\"):\n596 \n597     def _is_same(f1: str, f2: str) -> bool:\n598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)\n599 \n600 else:\n601 \n602     def _is_same(f1: str, f2: str) -> bool:\n603         return os.path.samefile(f1, f2)\n604 \n605 \n606 def module_name_from_path(path: Path, root: Path) -> str:\n607     \"\"\"\n608     Return a dotted module name based on the given path, anchored on root.\n609 \n610     For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n611     resulting module name will be \"src.tests.test_foo\".\n612     \"\"\"\n613     path = path.with_suffix(\"\")\n614     try:\n615         relative_path = path.relative_to(root)\n616     except ValueError:\n617         # If we can't get a relative path to root, use the full path, except\n618         # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n619         path_parts = path.parts[1:]\n620     else:\n621         # Use the parts for the relative path to the root path.\n622         path_parts = relative_path.parts\n623 \n624     return \".\".join(path_parts)\n625 \n626 \n627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n628     \"\"\"\n629     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n630 \n631     When we want to import a module as \"src.tests.test_foo\" for example, we need\n632     to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n633     otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n634     \"\"\"\n635     module_parts = module_name.split(\".\")\n636     child_module: Union[ModuleType, None] = None\n637     module: Union[ModuleType, None] = None\n638     child_name: str = \"\"\n639     while module_name:\n640         if module_name not in modules:\n641             try:\n642                 # If sys.meta_path is empty, calling import_module will issue\n643                 # a warning and raise ModuleNotFoundError. To avoid the\n644                 # warning, we check sys.meta_path explicitly and raise the error\n645                 # ourselves to fall back to creating a dummy module.\n646                 if not sys.meta_path:\n647                     raise ModuleNotFoundError\n648                 module = importlib.import_module(module_name)\n649             except ModuleNotFoundError:\n650                 module = ModuleType(\n651                     module_name,\n652                     doc=\"Empty module created by pytest's importmode=importlib.\",\n653                 )\n654         else:\n655             module = modules[module_name]\n656         if child_module:\n657             # Add child attribute to the parent that can reference the child\n658             # modules.\n659             if not hasattr(module, child_name):\n660                 setattr(module, child_name, child_module)\n661                 modules[module_name] = module\n662         # Keep track of the child module while moving up the tree.\n663         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n664         module_parts.pop(-1)\n665         module_name = \".\".join(module_parts)\n666 \n667 \n668 def resolve_package_path(path: Path) -> Optional[Path]:\n669     \"\"\"Return the Python package path by looking for the last\n670     directory upwards which still contains an __init__.py.\n671 \n672     Returns None if it can not be determined.\n673     \"\"\"\n674     result = None\n675     for parent in itertools.chain((path,), path.parents):\n676         if parent.is_dir():\n677             if not parent.joinpath(\"__init__.py\").is_file():\n678                 break\n679             if not parent.name.isidentifier():\n680                 break\n681             result = parent\n682     return result\n683 \n684 \n685 def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n686     \"\"\"Scan a directory recursively, in breadth-first order.\n687 \n688     The returned entries are sorted.\n689     \"\"\"\n690     entries = []\n691     with os.scandir(path) as s:\n692         # Skip entries with symlink loops and other brokenness, so the caller\n693         # doesn't have to deal with it.\n694         for entry in s:\n695             try:\n696                 entry.is_file()\n697             except OSError as err:\n698                 if _ignore_error(err):\n699                     continue\n700                 raise\n701             entries.append(entry)\n702     entries.sort(key=lambda entry: entry.name)\n703     return entries\n704 \n705 \n706 def visit(\n707     path: Union[str, \"os.PathLike[str]\"], recurse: Callable[[\"os.DirEntry[str]\"], bool]\n708 ) -> Iterator[\"os.DirEntry[str]\"]:\n709     \"\"\"Walk a directory recursively, in breadth-first order.\n710 \n711     The `recurse` predicate determines whether a directory is recursed.\n712 \n713     Entries at each directory level are sorted.\n714     \"\"\"\n715     entries = scandir(path)\n716     yield from entries\n717     for entry in entries:\n718         if entry.is_dir() and recurse(entry):\n719             yield from visit(entry.path, recurse)\n720 \n721 \n722 def absolutepath(path: Union[Path, str]) -> Path:\n723     \"\"\"Convert a path to an absolute path using os.path.abspath.\n724 \n725     Prefer this over Path.resolve() (see #6523).\n726     Prefer this over Path.absolute() (not public, doesn't normalize).\n727     \"\"\"\n728     return Path(os.path.abspath(str(path)))\n729 \n730 \n731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:\n732     \"\"\"Return the common part shared with the other path, or None if there is\n733     no common part.\n734 \n735     If one path is relative and one is absolute, returns None.\n736     \"\"\"\n737     try:\n738         return Path(os.path.commonpath((str(path1), str(path2))))\n739     except ValueError:\n740         return None\n741 \n742 \n743 def bestrelpath(directory: Path, dest: Path) -> str:\n744     \"\"\"Return a string which is a relative path from directory to dest such\n745     that directory/bestrelpath == dest.\n746 \n747     The paths must be either both absolute or both relative.\n748 \n749     If no such path can be determined, returns dest.\n750     \"\"\"\n751     assert isinstance(directory, Path)\n752     assert isinstance(dest, Path)\n753     if dest == directory:\n754         return os.curdir\n755     # Find the longest common directory.\n756     base = commonpath(directory, dest)\n757     # Can be the case on Windows for two absolute paths on different drives.\n758     # Can be the case for two relative paths without common prefix.\n759     # Can be the case for a relative path and an absolute path.\n760     if not base:\n761         return str(dest)\n762     reldirectory = directory.relative_to(base)\n763     reldest = dest.relative_to(base)\n764     return os.path.join(\n765         # Back from directory to base.\n766         *([os.pardir] * len(reldirectory.parts)),\n767         # Forward from base to dest.\n768         *reldest.parts,\n769     )\n770 \n771 \n772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.\n773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)\n774 def copytree(source: Path, target: Path) -> None:\n775     \"\"\"Recursively copy a source directory to target.\"\"\"\n776     assert source.is_dir()\n777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):\n778         x = Path(entry)\n779         relpath = x.relative_to(source)\n780         newx = target / relpath\n781         newx.parent.mkdir(exist_ok=True)\n782         if x.is_symlink():\n783             newx.symlink_to(os.readlink(x))\n784         elif x.is_file():\n785             shutil.copyfile(x, newx)\n786         elif x.is_dir():\n787             newx.mkdir(exist_ok=True)\n",
        "intended_behavior": "These files should correctly handle the resolution and import of modules in a way that's consistent with Python's expected behavior for namespace packages. This ensures that only one instance of each module exists within the application's runtime, specifically avoiding issues where one instance is used to set a configuration and another separate instance is checked for that configuration."
    }
]