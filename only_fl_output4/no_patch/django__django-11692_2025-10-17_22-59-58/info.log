2025-10-17 22:59:59.593 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 23:00:03.202 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=301, output_tokens=12, cost=0.003370
2025-10-17 23:00:03.203 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 23:00:03.207 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:00:14.349 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=607, output_tokens=406, cost=0.018250
2025-10-17 23:00:14.356 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:00:17.146 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=760, output_tokens=53, cost=0.009190
2025-10-17 23:00:17.147 | DEBUG    | Extracted a valid json.
2025-10-17 23:00:17.147 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Document\")",
        "search_method(\"annotate\")",
        "search_code(\"OuterRef('id')\")",
        "search_code(\"Subquery\")"
    ],
    "bug_locations": []
}
2025-10-17 23:00:17.225 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 23:00:17.226 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 23:00:34.875 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1534, output_tokens=806, cost=0.039520
2025-10-17 23:00:34.884 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:00:47.433 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2556, output_tokens=554, cost=0.042180
2025-10-17 23:00:47.443 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:00:52.645 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=908, output_tokens=179, cost=0.014450
2025-10-17 23:00:52.647 | DEBUG    | Extracted a valid json.
2025-10-17 23:00:52.652 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/expressions.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely contains the implementation of `Subquery` and possibly how expressions involving `OuterRef` are treated when used in complex queries, such as with `union` or the `|` operator. A detailed examination is needed to pinpoint the exact locations."
        },
        {
            "file": "django/db/models/sql/compiler.py",
            "class": "",
            "method": "",
            "intended_behavior": "The issue could stem from how combined queries (union or bitwise OR) are compiled when they include references to `OuterRef`. This file's method(s) responsible for compiling these queries needs to be reviewed for potential adjustments."
        }
    ]
}
2025-10-17 23:00:52.668 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import functools
4 import inspect
5 from decimal import Decimal
6 from uuid import UUID
7 
8 from django.core.exceptions import EmptyResultSet, FieldError
9 from django.db import DatabaseError, NotSupportedError, connection
10 from django.db.models import fields
11 from django.db.models.constants import LOOKUP_SEP
12 from django.db.models.query_utils import Q
13 from django.utils.deconstruct import deconstructible
14 from django.utils.functional import cached_property
15 from django.utils.hashable import make_hashable
16 
17 
18 class SQLiteNumericMixin:
19     """
20     Some expressions with output_field=DecimalField() must be cast to
21     numeric to be properly filtered.
22     """
23     def as_sqlite(self, compiler, connection, **extra_context):
24         sql, params = self.as_sql(compiler, connection, **extra_context)
25         try:
26             if self.output_field.get_internal_type() == 'DecimalField':
27                 sql = 'CAST(%s AS NUMERIC)' % sql
28         except FieldError:
29             pass
30         return sql, params
31 
32 
33 class Combinable:
34     """
35     Provide the ability to combine one or two objects with
36     some connector. For example F('foo') + F('bar').
37     """
38 
39     # Arithmetic connectors
40     ADD = '+'
41     SUB = '-'
42     MUL = '*'
43     DIV = '/'
44     POW = '^'
45     # The following is a quoted % operator - it is quoted because it can be
46     # used in strings that also have parameter substitution.
47     MOD = '%%'
48 
49     # Bitwise operators - note that these are generated by .bitand()
50     # and .bitor(), the '&' and '|' are reserved for boolean operator
51     # usage.
52     BITAND = '&'
53     BITOR = '|'
54     BITLEFTSHIFT = '<<'
55     BITRIGHTSHIFT = '>>'
56     BITXOR = '#'
57 
58     def _combine(self, other, connector, reversed):
59         if not hasattr(other, 'resolve_expression'):
60             # everything must be resolvable to an expression
61             other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def bitxor(self, other):
109         return self._combine(other, self.BITXOR, False)
110 
111     def __or__(self, other):
112         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
113             return Q(self) | Q(other)
114         raise NotImplementedError(
115             "Use .bitand() and .bitor() for bitwise logical operations."
116         )
117 
118     def bitor(self, other):
119         return self._combine(other, self.BITOR, False)
120 
121     def __radd__(self, other):
122         return self._combine(other, self.ADD, True)
123 
124     def __rsub__(self, other):
125         return self._combine(other, self.SUB, True)
126 
127     def __rmul__(self, other):
128         return self._combine(other, self.MUL, True)
129 
130     def __rtruediv__(self, other):
131         return self._combine(other, self.DIV, True)
132 
133     def __rmod__(self, other):
134         return self._combine(other, self.MOD, True)
135 
136     def __rpow__(self, other):
137         return self._combine(other, self.POW, True)
138 
139     def __rand__(self, other):
140         raise NotImplementedError(
141             "Use .bitand() and .bitor() for bitwise logical operations."
142         )
143 
144     def __ror__(self, other):
145         raise NotImplementedError(
146             "Use .bitand() and .bitor() for bitwise logical operations."
147         )
148 
149 
150 class BaseExpression:
151     """Base class for all query expressions."""
152 
153     empty_result_set_value = NotImplemented
154     # aggregate specific fields
155     is_summary = False
156     _output_field_resolved_to_none = False
157     # Can the expression be used in a WHERE clause?
158     filterable = True
159     # Can the expression can be used as a source expression in Window?
160     window_compatible = False
161 
162     def __init__(self, output_field=None):
163         if output_field is not None:
164             self.output_field = output_field
165 
166     def __getstate__(self):
167         state = self.__dict__.copy()
168         state.pop('convert_value', None)
169         return state
170 
171     def get_db_converters(self, connection):
172         return (
173             []
174             if self.convert_value is self._convert_value_noop else
175             [self.convert_value]
176         ) + self.output_field.get_db_converters(connection)
177 
178     def get_source_expressions(self):
179         return []
180 
181     def set_source_expressions(self, exprs):
182         assert not exprs
183 
184     def _parse_expressions(self, *expressions):
185         return [
186             arg if hasattr(arg, 'resolve_expression') else (
187                 F(arg) if isinstance(arg, str) else Value(arg)
188             ) for arg in expressions
189         ]
190 
191     def as_sql(self, compiler, connection):
192         """
193         Responsible for returning a (sql, [params]) tuple to be included
194         in the current query.
195 
196         Different backends can provide their own implementation, by
197         providing an `as_{vendor}` method and patching the Expression:
198 
199         ```
200         def override_as_sql(self, compiler, connection):
201             # custom logic
202             return super().as_sql(compiler, connection)
203         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
204         ```
205 
206         Arguments:
207          * compiler: the query compiler responsible for generating the query.
208            Must have a compile method, returning a (sql, [params]) tuple.
209            Calling compiler(value) will return a quoted `value`.
210 
211          * connection: the database connection used for the current query.
212 
213         Return: (sql, params)
214           Where `sql` is a string containing ordered sql parameters to be
215           replaced with the elements of the list `params`.
216         """
217         raise NotImplementedError("Subclasses must implement as_sql()")
218 
219     @cached_property
220     def contains_aggregate(self):
221         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
222 
223     @cached_property
224     def contains_over_clause(self):
225         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
226 
227     @cached_property
228     def contains_column_references(self):
229         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
230 
231     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
232         """
233         Provide the chance to do any preprocessing or validation before being
234         added to the query.
235 
236         Arguments:
237          * query: the backend query implementation
238          * allow_joins: boolean allowing or denying use of joins
239            in this query
240          * reuse: a set of reusable joins for multijoins
241          * summarize: a terminal aggregate clause
242          * for_save: whether this expression about to be used in a save or update
243 
244         Return: an Expression to be added to the query.
245         """
246         c = self.copy()
247         c.is_summary = summarize
248         c.set_source_expressions([
249             expr.resolve_expression(query, allow_joins, reuse, summarize)
250             if expr else None
251             for expr in c.get_source_expressions()
252         ])
253         return c
254 
255     @property
256     def conditional(self):
257         return isinstance(self.output_field, fields.BooleanField)
258 
259     @property
260     def field(self):
261         return self.output_field
262 
263     @cached_property
264     def output_field(self):
265         """Return the output type of this expressions."""
266         output_field = self._resolve_output_field()
267         if output_field is None:
268             self._output_field_resolved_to_none = True
269             raise FieldError('Cannot resolve expression type, unknown output_field')
270         return output_field
271 
272     @cached_property
273     def _output_field_or_none(self):
274         """
275         Return the output field of this expression, or None if
276         _resolve_output_field() didn't return an output type.
277         """
278         try:
279             return self.output_field
280         except FieldError:
281             if not self._output_field_resolved_to_none:
282                 raise
283 
284     def _resolve_output_field(self):
285         """
286         Attempt to infer the output type of the expression. If the output
287         fields of all source fields match then, simply infer the same type
288         here. This isn't always correct, but it makes sense most of the time.
289 
290         Consider the difference between `2 + 2` and `2 / 3`. Inferring
291         the type here is a convenience for the common case. The user should
292         supply their own output_field with more complex computations.
293 
294         If a source's output field resolves to None, exclude it from this check.
295         If all sources are None, then an error is raised higher up the stack in
296         the output_field property.
297         """
298         sources_iter = (source for source in self.get_source_fields() if source is not None)
299         for output_field in sources_iter:
300             for source in sources_iter:
301                 if not isinstance(output_field, source.__class__):
302                     raise FieldError(
303                         'Expression contains mixed types: %s, %s. You must '
304                         'set output_field.' % (
305                             output_field.__class__.__name__,
306                             source.__class__.__name__,
307                         )
308                     )
309             return output_field
310 
311     @staticmethod
312     def _convert_value_noop(value, expression, connection):
313         return value
314 
315     @cached_property
316     def convert_value(self):
317         """
318         Expressions provide their own converters because users have the option
319         of manually specifying the output_field which may be a different type
320         from the one the database returns.
321         """
322         field = self.output_field
323         internal_type = field.get_internal_type()
324         if internal_type == 'FloatField':
325             return lambda value, expression, connection: None if value is None else float(value)
326         elif internal_type.endswith('IntegerField'):
327             return lambda value, expression, connection: None if value is None else int(value)
328         elif internal_type == 'DecimalField':
329             return lambda value, expression, connection: None if value is None else Decimal(value)
330         return self._convert_value_noop
331 
332     def get_lookup(self, lookup):
333         return self.output_field.get_lookup(lookup)
334 
335     def get_transform(self, name):
336         return self.output_field.get_transform(name)
337 
338     def relabeled_clone(self, change_map):
339         clone = self.copy()
340         clone.set_source_expressions([
341             e.relabeled_clone(change_map) if e is not None else None
342             for e in self.get_source_expressions()
343         ])
344         return clone
345 
346     def copy(self):
347         return copy.copy(self)
348 
349     def get_group_by_cols(self, alias=None):
350         if not self.contains_aggregate:
351             return [self]
352         cols = []
353         for source in self.get_source_expressions():
354             cols.extend(source.get_group_by_cols())
355         return cols
356 
357     def get_source_fields(self):
358         """Return the underlying field types used by this aggregate."""
359         return [e._output_field_or_none for e in self.get_source_expressions()]
360 
361     def asc(self, **kwargs):
362         return OrderBy(self, **kwargs)
363 
364     def desc(self, **kwargs):
365         return OrderBy(self, descending=True, **kwargs)
366 
367     def reverse_ordering(self):
368         return self
369 
370     def flatten(self):
371         """
372         Recursively yield this expression and all subexpressions, in
373         depth-first order.
374         """
375         yield self
376         for expr in self.get_source_expressions():
377             if expr:
378                 if hasattr(expr, 'flatten'):
379                     yield from expr.flatten()
380                 else:
381                     yield expr
382 
383     def select_format(self, compiler, sql, params):
384         """
385         Custom format for select clauses. For example, EXISTS expressions need
386         to be wrapped in CASE WHEN on Oracle.
387         """
388         if hasattr(self.output_field, 'select_format'):
389             return self.output_field.select_format(compiler, sql, params)
390         return sql, params
391 
392 
393 @deconstructible
394 class Expression(BaseExpression, Combinable):
395     """An expression that can be combined with other expressions."""
396 
397     @cached_property
398     def identity(self):
399         constructor_signature = inspect.signature(self.__init__)
400         args, kwargs = self._constructor_args
401         signature = constructor_signature.bind_partial(*args, **kwargs)
402         signature.apply_defaults()
403         arguments = signature.arguments.items()
404         identity = [self.__class__]
405         for arg, value in arguments:
406             if isinstance(value, fields.Field):
407                 if value.name and value.model:
408                     value = (value.model._meta.label, value.name)
409                 else:
410                     value = type(value)
411             else:
412                 value = make_hashable(value)
413             identity.append((arg, value))
414         return tuple(identity)
415 
416     def __eq__(self, other):
417         if not isinstance(other, Expression):
418             return NotImplemented
419         return other.identity == self.identity
420 
421     def __hash__(self):
422         return hash(self.identity)
423 
424 
425 _connector_combinators = {
426     connector: [
427         (fields.IntegerField, fields.IntegerField, fields.IntegerField),
428         (fields.IntegerField, fields.DecimalField, fields.DecimalField),
429         (fields.DecimalField, fields.IntegerField, fields.DecimalField),
430         (fields.IntegerField, fields.FloatField, fields.FloatField),
431         (fields.FloatField, fields.IntegerField, fields.FloatField),
432     ]
433     for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)
434 }
435 
436 
437 @functools.lru_cache(maxsize=128)
438 def _resolve_combined_type(connector, lhs_type, rhs_type):
439     combinators = _connector_combinators.get(connector, ())
440     for combinator_lhs_type, combinator_rhs_type, combined_type in combinators:
441         if issubclass(lhs_type, combinator_lhs_type) and issubclass(rhs_type, combinator_rhs_type):
442             return combined_type
443 
444 
445 class CombinedExpression(SQLiteNumericMixin, Expression):
446 
447     def __init__(self, lhs, connector, rhs, output_field=None):
448         super().__init__(output_field=output_field)
449         self.connector = connector
450         self.lhs = lhs
451         self.rhs = rhs
452 
453     def __repr__(self):
454         return "<{}: {}>".format(self.__class__.__name__, self)
455 
456     def __str__(self):
457         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
458 
459     def get_source_expressions(self):
460         return [self.lhs, self.rhs]
461 
462     def set_source_expressions(self, exprs):
463         self.lhs, self.rhs = exprs
464 
465     def _resolve_output_field(self):
466         try:
467             return super()._resolve_output_field()
468         except FieldError:
469             combined_type = _resolve_combined_type(
470                 self.connector,
471                 type(self.lhs.output_field),
472                 type(self.rhs.output_field),
473             )
474             if combined_type is None:
475                 raise
476             return combined_type()
477 
478     def as_sql(self, compiler, connection):
479         expressions = []
480         expression_params = []
481         sql, params = compiler.compile(self.lhs)
482         expressions.append(sql)
483         expression_params.extend(params)
484         sql, params = compiler.compile(self.rhs)
485         expressions.append(sql)
486         expression_params.extend(params)
487         # order of precedence
488         expression_wrapper = '(%s)'
489         sql = connection.ops.combine_expression(self.connector, expressions)
490         return expression_wrapper % sql, expression_params
491 
492     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
493         lhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
494         rhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
495         if not isinstance(self, (DurationExpression, TemporalSubtraction)):
496             try:
497                 lhs_type = lhs.output_field.get_internal_type()
498             except (AttributeError, FieldError):
499                 lhs_type = None
500             try:
501                 rhs_type = rhs.output_field.get_internal_type()
502             except (AttributeError, FieldError):
503                 rhs_type = None
504             if 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:
505                 return DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(
506                     query, allow_joins, reuse, summarize, for_save,
507                 )
508             datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}
509             if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:
510                 return TemporalSubtraction(self.lhs, self.rhs).resolve_expression(
511                     query, allow_joins, reuse, summarize, for_save,
512                 )
513         c = self.copy()
514         c.is_summary = summarize
515         c.lhs = lhs
516         c.rhs = rhs
517         return c
518 
519 
520 class DurationExpression(CombinedExpression):
521     def compile(self, side, compiler, connection):
522         try:
523             output = side.output_field
524         except FieldError:
525             pass
526         else:
527             if output.get_internal_type() == 'DurationField':
528                 sql, params = compiler.compile(side)
529                 return connection.ops.format_for_duration_arithmetic(sql), params
530         return compiler.compile(side)
531 
532     def as_sql(self, compiler, connection):
533         if connection.features.has_native_duration_field:
534             return super().as_sql(compiler, connection)
535         connection.ops.check_expression_support(self)
536         expressions = []
537         expression_params = []
538         sql, params = self.compile(self.lhs, compiler, connection)
539         expressions.append(sql)
540         expression_params.extend(params)
541         sql, params = self.compile(self.rhs, compiler, connection)
542         expressions.append(sql)
543         expression_params.extend(params)
544         # order of precedence
545         expression_wrapper = '(%s)'
546         sql = connection.ops.combine_duration_expression(self.connector, expressions)
547         return expression_wrapper % sql, expression_params
548 
549     def as_sqlite(self, compiler, connection, **extra_context):
550         sql, params = self.as_sql(compiler, connection, **extra_context)
551         if self.connector in {Combinable.MUL, Combinable.DIV}:
552             try:
553                 lhs_type = self.lhs.output_field.get_internal_type()
554                 rhs_type = self.rhs.output_field.get_internal_type()
555             except (AttributeError, FieldError):
556                 pass
557             else:
558                 allowed_fields = {
559                     'DecimalField', 'DurationField', 'FloatField', 'IntegerField',
560                 }
561                 if lhs_type not in allowed_fields or rhs_type not in allowed_fields:
562                     raise DatabaseError(
563                         f'Invalid arguments for operator {self.connector}.'
564                     )
565         return sql, params
566 
567 
568 class TemporalSubtraction(CombinedExpression):
569     output_field = fields.DurationField()
570 
571     def __init__(self, lhs, rhs):
572         super().__init__(lhs, self.SUB, rhs)
573 
574     def as_sql(self, compiler, connection):
575         connection.ops.check_expression_support(self)
576         lhs = compiler.compile(self.lhs)
577         rhs = compiler.compile(self.rhs)
578         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
579 
580 
581 @deconstructible(path='django.db.models.F')
582 class F(Combinable):
583     """An object capable of resolving references to existing query objects."""
584 
585     def __init__(self, name):
586         """
587         Arguments:
588          * name: the name of the field this expression references
589         """
590         self.name = name
591 
592     def __repr__(self):
593         return "{}({})".format(self.__class__.__name__, self.name)
594 
595     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
596                            summarize=False, for_save=False):
597         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
598 
599     def asc(self, **kwargs):
600         return OrderBy(self, **kwargs)
601 
602     def desc(self, **kwargs):
603         return OrderBy(self, descending=True, **kwargs)
604 
605     def __eq__(self, other):
606         return self.__class__ == other.__class__ and self.name == other.name
607 
608     def __hash__(self):
609         return hash(self.name)
610 
611 
612 class ResolvedOuterRef(F):
613     """
614     An object that contains a reference to an outer query.
615 
616     In this case, the reference to the outer query has been resolved because
617     the inner query has been used as a subquery.
618     """
619     contains_aggregate = False
620 
621     def as_sql(self, *args, **kwargs):
622         raise ValueError(
623             'This queryset contains a reference to an outer query and may '
624             'only be used in a subquery.'
625         )
626 
627     def resolve_expression(self, *args, **kwargs):
628         col = super().resolve_expression(*args, **kwargs)
629         # FIXME: Rename possibly_multivalued to multivalued and fix detection
630         # for non-multivalued JOINs (e.g. foreign key fields). This should take
631         # into account only many-to-many and one-to-many relationships.
632         col.possibly_multivalued = LOOKUP_SEP in self.name
633         return col
634 
635     def relabeled_clone(self, relabels):
636         return self
637 
638     def get_group_by_cols(self, alias=None):
639         return []
640 
641 
642 class OuterRef(F):
643     contains_aggregate = False
644 
645     def resolve_expression(self, *args, **kwargs):
646         if isinstance(self.name, self.__class__):
647             return self.name
648         return ResolvedOuterRef(self.name)
649 
650     def relabeled_clone(self, relabels):
651         return self
652 
653 
654 @deconstructible(path='django.db.models.Func')
655 class Func(SQLiteNumericMixin, Expression):
656     """An SQL function call."""
657     function = None
658     template = '%(function)s(%(expressions)s)'
659     arg_joiner = ', '
660     arity = None  # The number of arguments the function accepts.
661 
662     def __init__(self, *expressions, output_field=None, **extra):
663         if self.arity is not None and len(expressions) != self.arity:
664             raise TypeError(
665                 "'%s' takes exactly %s %s (%s given)" % (
666                     self.__class__.__name__,
667                     self.arity,
668                     "argument" if self.arity == 1 else "arguments",
669                     len(expressions),
670                 )
671             )
672         super().__init__(output_field=output_field)
673         self.source_expressions = self._parse_expressions(*expressions)
674         self.extra = extra
675 
676     def __repr__(self):
677         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
678         extra = {**self.extra, **self._get_repr_options()}
679         if extra:
680             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
681             return "{}({}, {})".format(self.__class__.__name__, args, extra)
682         return "{}({})".format(self.__class__.__name__, args)
683 
684     def _get_repr_options(self):
685         """Return a dict of extra __init__() options to include in the repr."""
686         return {}
687 
688     def get_source_expressions(self):
689         return self.source_expressions
690 
691     def set_source_expressions(self, exprs):
692         self.source_expressions = exprs
693 
694     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
695         c = self.copy()
696         c.is_summary = summarize
697         for pos, arg in enumerate(c.source_expressions):
698             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
699         return c
700 
701     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
702         connection.ops.check_expression_support(self)
703         sql_parts = []
704         params = []
705         for arg in self.source_expressions:
706             try:
707                 arg_sql, arg_params = compiler.compile(arg)
708             except EmptyResultSet:
709                 empty_result_set_value = getattr(arg, 'empty_result_set_value', NotImplemented)
710                 if empty_result_set_value is NotImplemented:
711                     raise
712                 arg_sql, arg_params = compiler.compile(Value(empty_result_set_value))
713             sql_parts.append(arg_sql)
714             params.extend(arg_params)
715         data = {**self.extra, **extra_context}
716         # Use the first supplied value in this order: the parameter to this
717         # method, a value supplied in __init__()'s **extra (the value in
718         # `data`), or the value defined on the class.
719         if function is not None:
720             data['function'] = function
721         else:
722             data.setdefault('function', self.function)
723         template = template or data.get('template', self.template)
724         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
725         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
726         return template % data, params
727 
728     def copy(self):
729         copy = super().copy()
730         copy.source_expressions = self.source_expressions[:]
731         copy.extra = self.extra.copy()
732         return copy
733 
734 
735 @deconstructible(path='django.db.models.Value')
736 class Value(SQLiteNumericMixin, Expression):
737     """Represent a wrapped value as a node within an expression."""
738     # Provide a default value for `for_save` in order to allow unresolved
739     # instances to be compiled until a decision is taken in #25425.
740     for_save = False
741 
742     def __init__(self, value, output_field=None):
743         """
744         Arguments:
745          * value: the value this expression represents. The value will be
746            added into the sql parameter list and properly quoted.
747 
748          * output_field: an instance of the model field type that this
749            expression will return, such as IntegerField() or CharField().
750         """
751         super().__init__(output_field=output_field)
752         self.value = value
753 
754     def __repr__(self):
755         return f'{self.__class__.__name__}({self.value!r})'
756 
757     def as_sql(self, compiler, connection):
758         connection.ops.check_expression_support(self)
759         val = self.value
760         output_field = self._output_field_or_none
761         if output_field is not None:
762             if self.for_save:
763                 val = output_field.get_db_prep_save(val, connection=connection)
764             else:
765                 val = output_field.get_db_prep_value(val, connection=connection)
766             if hasattr(output_field, 'get_placeholder'):
767                 return output_field.get_placeholder(val, compiler, connection), [val]
768         if val is None:
769             # cx_Oracle does not always convert None to the appropriate
770             # NULL type (like in case expressions using numbers), so we
771             # use a literal SQL NULL
772             return 'NULL', []
773         return '%s', [val]
774 
775     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
776         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
777         c.for_save = for_save
778         return c
779 
780     def get_group_by_cols(self, alias=None):
781         return []
782 
783     def _resolve_output_field(self):
784         if isinstance(self.value, str):
785             return fields.CharField()
786         if isinstance(self.value, bool):
787             return fields.BooleanField()
788         if isinstance(self.value, int):
789             return fields.IntegerField()
790         if isinstance(self.value, float):
791             return fields.FloatField()
792         if isinstance(self.value, datetime.datetime):
793             return fields.DateTimeField()
794         if isinstance(self.value, datetime.date):
795             return fields.DateField()
796         if isinstance(self.value, datetime.time):
797             return fields.TimeField()
798         if isinstance(self.value, datetime.timedelta):
799             return fields.DurationField()
800         if isinstance(self.value, Decimal):
801             return fields.DecimalField()
802         if isinstance(self.value, bytes):
803             return fields.BinaryField()
804         if isinstance(self.value, UUID):
805             return fields.UUIDField()
806 
807     @property
808     def empty_result_set_value(self):
809         return self.value
810 
811 
812 class RawSQL(Expression):
813     def __init__(self, sql, params, output_field=None):
814         if output_field is None:
815             output_field = fields.Field()
816         self.sql, self.params = sql, params
817         super().__init__(output_field=output_field)
818 
819     def __repr__(self):
820         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
821 
822     def as_sql(self, compiler, connection):
823         return '(%s)' % self.sql, self.params
824 
825     def get_group_by_cols(self, alias=None):
826         return [self]
827 
828     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
829         # Resolve parents fields used in raw SQL.
830         for parent in query.model._meta.get_parent_list():
831             for parent_field in parent._meta.local_fields:
832                 _, column_name = parent_field.get_attname_column()
833                 if column_name.lower() in self.sql.lower():
834                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
835                     break
836         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
837 
838 
839 class Star(Expression):
840     def __repr__(self):
841         return "'*'"
842 
843     def as_sql(self, compiler, connection):
844         return '*', []
845 
846 
847 class Col(Expression):
848 
849     contains_column_references = True
850     possibly_multivalued = False
851 
852     def __init__(self, alias, target, output_field=None):
853         if output_field is None:
854             output_field = target
855         super().__init__(output_field=output_field)
856         self.alias, self.target = alias, target
857 
858     def __repr__(self):
859         alias, target = self.alias, self.target
860         identifiers = (alias, str(target)) if alias else (str(target),)
861         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
862 
863     def as_sql(self, compiler, connection):
864         alias, column = self.alias, self.target.column
865         identifiers = (alias, column) if alias else (column,)
866         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
867         return sql, []
868 
869     def relabeled_clone(self, relabels):
870         if self.alias is None:
871             return self
872         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
873 
874     def get_group_by_cols(self, alias=None):
875         return [self]
876 
877     def get_db_converters(self, connection):
878         if self.target == self.output_field:
879             return self.output_field.get_db_converters(connection)
880         return (self.output_field.get_db_converters(connection) +
881                 self.target.get_db_converters(connection))
882 
883 
884 class Ref(Expression):
885     """
886     Reference to column alias of the query. For example, Ref('sum_cost') in
887     qs.annotate(sum_cost=Sum('cost')) query.
888     """
889     def __init__(self, refs, source):
890         super().__init__()
891         self.refs, self.source = refs, source
892 
893     def __repr__(self):
894         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
895 
896     def get_source_expressions(self):
897         return [self.source]
898 
899     def set_source_expressions(self, exprs):
900         self.source, = exprs
901 
902     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
903         # The sub-expression `source` has already been resolved, as this is
904         # just a reference to the name of `source`.
905         return self
906 
907     def relabeled_clone(self, relabels):
908         return self
909 
910     def as_sql(self, compiler, connection):
911         return connection.ops.quote_name(self.refs), []
912 
913     def get_group_by_cols(self, alias=None):
914         return [self]
915 
916 
917 class ExpressionList(Func):
918     """
919     An expression containing multiple expressions. Can be used to provide a
920     list of expressions as an argument to another expression, like a partition
921     clause.
922     """
923     template = '%(expressions)s'
924 
925     def __init__(self, *expressions, **extra):
926         if not expressions:
927             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
928         super().__init__(*expressions, **extra)
929 
930     def __str__(self):
931         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
932 
933     def as_sqlite(self, compiler, connection, **extra_context):
934         # Casting to numeric is unnecessary.
935         return self.as_sql(compiler, connection, **extra_context)
936 
937 
938 class OrderByList(Func):
939     template = 'ORDER BY %(expressions)s'
940 
941     def __init__(self, *expressions, **extra):
942         expressions = (
943             (
944                 OrderBy(F(expr[1:]), descending=True)
945                 if isinstance(expr, str) and expr[0] == '-'
946                 else expr
947             )
948             for expr in expressions
949         )
950         super().__init__(*expressions, **extra)
951 
952     def as_sql(self, *args, **kwargs):
953         if not self.source_expressions:
954             return '', ()
955         return super().as_sql(*args, **kwargs)
956 
957 
958 @deconstructible(path='django.db.models.ExpressionWrapper')
959 class ExpressionWrapper(SQLiteNumericMixin, Expression):
960     """
961     An expression that can wrap another expression so that it can provide
962     extra context to the inner expression, such as the output_field.
963     """
964 
965     def __init__(self, expression, output_field):
966         super().__init__(output_field=output_field)
967         self.expression = expression
968 
969     def set_source_expressions(self, exprs):
970         self.expression = exprs[0]
971 
972     def get_source_expressions(self):
973         return [self.expression]
974 
975     def get_group_by_cols(self, alias=None):
976         if isinstance(self.expression, Expression):
977             expression = self.expression.copy()
978             expression.output_field = self.output_field
979             return expression.get_group_by_cols(alias=alias)
980         # For non-expressions e.g. an SQL WHERE clause, the entire
981         # `expression` must be included in the GROUP BY clause.
982         return super().get_group_by_cols()
983 
984     def as_sql(self, compiler, connection):
985         return compiler.compile(self.expression)
986 
987     def __repr__(self):
988         return "{}({})".format(self.__class__.__name__, self.expression)
989 
990 
991 @deconstructible(path='django.db.models.When')
992 class When(Expression):
993     template = 'WHEN %(condition)s THEN %(result)s'
994     # This isn't a complete conditional expression, must be used in Case().
995     conditional = False
996 
997     def __init__(self, condition=None, then=None, **lookups):
998         if lookups:
999             if condition is None:
1000                 condition, lookups = Q(**lookups), None
1001             elif getattr(condition, 'conditional', False):
1002                 condition, lookups = Q(condition, **lookups), None
1003         if condition is None or not getattr(condition, 'conditional', False) or lookups:
1004             raise TypeError(
1005                 'When() supports a Q object, a boolean expression, or lookups '
1006                 'as a condition.'
1007             )
1008         if isinstance(condition, Q) and not condition:
1009             raise ValueError("An empty Q() can't be used as a When() condition.")
1010         super().__init__(output_field=None)
1011         self.condition = condition
1012         self.result = self._parse_expressions(then)[0]
1013 
1014     def __str__(self):
1015         return "WHEN %r THEN %r" % (self.condition, self.result)
1016 
1017     def __repr__(self):
1018         return "<%s: %s>" % (self.__class__.__name__, self)
1019 
1020     def get_source_expressions(self):
1021         return [self.condition, self.result]
1022 
1023     def set_source_expressions(self, exprs):
1024         self.condition, self.result = exprs
1025 
1026     def get_source_fields(self):
1027         # We're only interested in the fields of the result expressions.
1028         return [self.result._output_field_or_none]
1029 
1030     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1031         c = self.copy()
1032         c.is_summary = summarize
1033         if hasattr(c.condition, 'resolve_expression'):
1034             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
1035         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1036         return c
1037 
1038     def as_sql(self, compiler, connection, template=None, **extra_context):
1039         connection.ops.check_expression_support(self)
1040         template_params = extra_context
1041         sql_params = []
1042         condition_sql, condition_params = compiler.compile(self.condition)
1043         template_params['condition'] = condition_sql
1044         sql_params.extend(condition_params)
1045         result_sql, result_params = compiler.compile(self.result)
1046         template_params['result'] = result_sql
1047         sql_params.extend(result_params)
1048         template = template or self.template
1049         return template % template_params, sql_params
1050 
1051     def get_group_by_cols(self, alias=None):
1052         # This is not a complete expression and cannot be used in GROUP BY.
1053         cols = []
1054         for source in self.get_source_expressions():
1055             cols.extend(source.get_group_by_cols())
1056         return cols
1057 
1058 
1059 @deconstructible(path='django.db.models.Case')
1060 class Case(SQLiteNumericMixin, Expression):
1061     """
1062     An SQL searched CASE expression:
1063 
1064         CASE
1065             WHEN n > 0
1066                 THEN 'positive'
1067             WHEN n < 0
1068                 THEN 'negative'
1069             ELSE 'zero'
1070         END
1071     """
1072     template = 'CASE %(cases)s ELSE %(default)s END'
1073     case_joiner = ' '
1074 
1075     def __init__(self, *cases, default=None, output_field=None, **extra):
1076         if not all(isinstance(case, When) for case in cases):
1077             raise TypeError("Positional arguments must all be When objects.")
1078         super().__init__(output_field)
1079         self.cases = list(cases)
1080         self.default = self._parse_expressions(default)[0]
1081         self.extra = extra
1082 
1083     def __str__(self):
1084         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
1085 
1086     def __repr__(self):
1087         return "<%s: %s>" % (self.__class__.__name__, self)
1088 
1089     def get_source_expressions(self):
1090         return self.cases + [self.default]
1091 
1092     def set_source_expressions(self, exprs):
1093         *self.cases, self.default = exprs
1094 
1095     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1096         c = self.copy()
1097         c.is_summary = summarize
1098         for pos, case in enumerate(c.cases):
1099             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1100         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1101         return c
1102 
1103     def copy(self):
1104         c = super().copy()
1105         c.cases = c.cases[:]
1106         return c
1107 
1108     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
1109         connection.ops.check_expression_support(self)
1110         if not self.cases:
1111             return compiler.compile(self.default)
1112         template_params = {**self.extra, **extra_context}
1113         case_parts = []
1114         sql_params = []
1115         for case in self.cases:
1116             try:
1117                 case_sql, case_params = compiler.compile(case)
1118             except EmptyResultSet:
1119                 continue
1120             case_parts.append(case_sql)
1121             sql_params.extend(case_params)
1122         default_sql, default_params = compiler.compile(self.default)
1123         if not case_parts:
1124             return default_sql, default_params
1125         case_joiner = case_joiner or self.case_joiner
1126         template_params['cases'] = case_joiner.join(case_parts)
1127         template_params['default'] = default_sql
1128         sql_params.extend(default_params)
1129         template = template or template_params.get('template', self.template)
1130         sql = template % template_params
1131         if self._output_field_or_none is not None:
1132             sql = connection.ops.unification_cast_sql(self.output_field) % sql
1133         return sql, sql_params
1134 
1135     def get_group_by_cols(self, alias=None):
1136         if not self.cases:
1137             return self.default.get_group_by_cols(alias)
1138         return super().get_group_by_cols(alias)
1139 
1140 
1141 class Subquery(BaseExpression, Combinable):
1142     """
1143     An explicit subquery. It may contain OuterRef() references to the outer
1144     query which will be resolved when it is applied to that query.
1145     """
1146     template = '(%(subquery)s)'
1147     contains_aggregate = False
1148     empty_result_set_value = None
1149 
1150     def __init__(self, queryset, output_field=None, **extra):
1151         # Allow the usage of both QuerySet and sql.Query objects.
1152         self.query = getattr(queryset, 'query', queryset).clone()
1153         self.query.subquery = True
1154         self.extra = extra
1155         super().__init__(output_field)
1156 
1157     def get_source_expressions(self):
1158         return [self.query]
1159 
1160     def set_source_expressions(self, exprs):
1161         self.query = exprs[0]
1162 
1163     def _resolve_output_field(self):
1164         return self.query.output_field
1165 
1166     def copy(self):
1167         clone = super().copy()
1168         clone.query = clone.query.clone()
1169         return clone
1170 
1171     @property
1172     def external_aliases(self):
1173         return self.query.external_aliases
1174 
1175     def get_external_cols(self):
1176         return self.query.get_external_cols()
1177 
1178     def as_sql(self, compiler, connection, template=None, query=None, **extra_context):
1179         connection.ops.check_expression_support(self)
1180         template_params = {**self.extra, **extra_context}
1181         query = query or self.query
1182         subquery_sql, sql_params = query.as_sql(compiler, connection)
1183         template_params['subquery'] = subquery_sql[1:-1]
1184 
1185         template = template or template_params.get('template', self.template)
1186         sql = template % template_params
1187         return sql, sql_params
1188 
1189     def get_group_by_cols(self, alias=None):
1190         # If this expression is referenced by an alias for an explicit GROUP BY
1191         # through values() a reference to this expression and not the
1192         # underlying .query must be returned to ensure external column
1193         # references are not grouped against as well.
1194         if alias:
1195             return [Ref(alias, self)]
1196         return self.query.get_group_by_cols()
1197 
1198 
1199 class Exists(Subquery):
1200     template = 'EXISTS(%(subquery)s)'
1201     output_field = fields.BooleanField()
1202 
1203     def __init__(self, queryset, negated=False, **kwargs):
1204         self.negated = negated
1205         super().__init__(queryset, **kwargs)
1206 
1207     def __invert__(self):
1208         clone = self.copy()
1209         clone.negated = not self.negated
1210         return clone
1211 
1212     def as_sql(self, compiler, connection, template=None, **extra_context):
1213         query = self.query.exists(using=connection.alias)
1214         sql, params = super().as_sql(
1215             compiler,
1216             connection,
1217             template=template,
1218             query=query,
1219             **extra_context,
1220         )
1221         if self.negated:
1222             sql = 'NOT {}'.format(sql)
1223         return sql, params
1224 
1225     def select_format(self, compiler, sql, params):
1226         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1227         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP
1228         # BY list.
1229         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1230             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1231         return sql, params
1232 
1233 
1234 @deconstructible(path='django.db.models.OrderBy')
1235 class OrderBy(Expression):
1236     template = '%(expression)s %(ordering)s'
1237     conditional = False
1238 
1239     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1240         if nulls_first and nulls_last:
1241             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1242         self.nulls_first = nulls_first
1243         self.nulls_last = nulls_last
1244         self.descending = descending
1245         if not hasattr(expression, 'resolve_expression'):
1246             raise ValueError('expression must be an expression type')
1247         self.expression = expression
1248 
1249     def __repr__(self):
1250         return "{}({}, descending={})".format(
1251             self.__class__.__name__, self.expression, self.descending)
1252 
1253     def set_source_expressions(self, exprs):
1254         self.expression = exprs[0]
1255 
1256     def get_source_expressions(self):
1257         return [self.expression]
1258 
1259     def as_sql(self, compiler, connection, template=None, **extra_context):
1260         template = template or self.template
1261         if connection.features.supports_order_by_nulls_modifier:
1262             if self.nulls_last:
1263                 template = '%s NULLS LAST' % template
1264             elif self.nulls_first:
1265                 template = '%s NULLS FIRST' % template
1266         else:
1267             if self.nulls_last and not (
1268                 self.descending and connection.features.order_by_nulls_first
1269             ):
1270                 template = '%%(expression)s IS NULL, %s' % template
1271             elif self.nulls_first and not (
1272                 not self.descending and connection.features.order_by_nulls_first
1273             ):
1274                 template = '%%(expression)s IS NOT NULL, %s' % template
1275         connection.ops.check_expression_support(self)
1276         expression_sql, params = compiler.compile(self.expression)
1277         placeholders = {
1278             'expression': expression_sql,
1279             'ordering': 'DESC' if self.descending else 'ASC',
1280             **extra_context,
1281         }
1282         params *= template.count('%(expression)s')
1283         return (template % placeholders).rstrip(), params
1284 
1285     def as_oracle(self, compiler, connection):
1286         # Oracle doesn't allow ORDER BY EXISTS() or filters unless it's wrapped
1287         # in a CASE WHEN.
1288         if connection.ops.conditional_expression_supported_in_where_clause(self.expression):
1289             copy = self.copy()
1290             copy.expression = Case(
1291                 When(self.expression, then=True),
1292                 default=False,
1293             )
1294             return copy.as_sql(compiler, connection)
1295         return self.as_sql(compiler, connection)
1296 
1297     def get_group_by_cols(self, alias=None):
1298         cols = []
1299         for source in self.get_source_expressions():
1300             cols.extend(source.get_group_by_cols())
1301         return cols
1302 
1303     def reverse_ordering(self):
1304         self.descending = not self.descending
1305         if self.nulls_first or self.nulls_last:
1306             self.nulls_first = not self.nulls_first
1307             self.nulls_last = not self.nulls_last
1308         return self
1309 
1310     def asc(self):
1311         self.descending = False
1312 
1313     def desc(self):
1314         self.descending = True
1315 
1316 
1317 class Window(SQLiteNumericMixin, Expression):
1318     template = '%(expression)s OVER (%(window)s)'
1319     # Although the main expression may either be an aggregate or an
1320     # expression with an aggregate function, the GROUP BY that will
1321     # be introduced in the query as a result is not desired.
1322     contains_aggregate = False
1323     contains_over_clause = True
1324     filterable = False
1325 
1326     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1327         self.partition_by = partition_by
1328         self.order_by = order_by
1329         self.frame = frame
1330 
1331         if not getattr(expression, 'window_compatible', False):
1332             raise ValueError(
1333                 "Expression '%s' isn't compatible with OVER clauses." %
1334                 expression.__class__.__name__
1335             )
1336 
1337         if self.partition_by is not None:
1338             if not isinstance(self.partition_by, (tuple, list)):
1339                 self.partition_by = (self.partition_by,)
1340             self.partition_by = ExpressionList(*self.partition_by)
1341 
1342         if self.order_by is not None:
1343             if isinstance(self.order_by, (list, tuple)):
1344                 self.order_by = OrderByList(*self.order_by)
1345             elif isinstance(self.order_by, (BaseExpression, str)):
1346                 self.order_by = OrderByList(self.order_by)
1347             else:
1348                 raise ValueError(
1349                     'Window.order_by must be either a string reference to a '
1350                     'field, an expression, or a list or tuple of them.'
1351                 )
1352         super().__init__(output_field=output_field)
1353         self.source_expression = self._parse_expressions(expression)[0]
1354 
1355     def _resolve_output_field(self):
1356         return self.source_expression.output_field
1357 
1358     def get_source_expressions(self):
1359         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1360 
1361     def set_source_expressions(self, exprs):
1362         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1363 
1364     def as_sql(self, compiler, connection, template=None):
1365         connection.ops.check_expression_support(self)
1366         if not connection.features.supports_over_clause:
1367             raise NotSupportedError('This backend does not support window expressions.')
1368         expr_sql, params = compiler.compile(self.source_expression)
1369         window_sql, window_params = [], []
1370 
1371         if self.partition_by is not None:
1372             sql_expr, sql_params = self.partition_by.as_sql(
1373                 compiler=compiler, connection=connection,
1374                 template='PARTITION BY %(expressions)s',
1375             )
1376             window_sql.append(sql_expr)
1377             window_params.extend(sql_params)
1378 
1379         if self.order_by is not None:
1380             order_sql, order_params = compiler.compile(self.order_by)
1381             window_sql.append(order_sql)
1382             window_params.extend(order_params)
1383 
1384         if self.frame:
1385             frame_sql, frame_params = compiler.compile(self.frame)
1386             window_sql.append(frame_sql)
1387             window_params.extend(frame_params)
1388 
1389         params.extend(window_params)
1390         template = template or self.template
1391 
1392         return template % {
1393             'expression': expr_sql,
1394             'window': ' '.join(window_sql).strip()
1395         }, params
1396 
1397     def as_sqlite(self, compiler, connection):
1398         if isinstance(self.output_field, fields.DecimalField):
1399             # Casting to numeric must be outside of the window expression.
1400             copy = self.copy()
1401             source_expressions = copy.get_source_expressions()
1402             source_expressions[0].output_field = fields.FloatField()
1403             copy.set_source_expressions(source_expressions)
1404             return super(Window, copy).as_sqlite(compiler, connection)
1405         return self.as_sql(compiler, connection)
1406 
1407     def __str__(self):
1408         return '{} OVER ({}{}{})'.format(
1409             str(self.source_expression),
1410             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1411             str(self.order_by or ''),
1412             str(self.frame or ''),
1413         )
1414 
1415     def __repr__(self):
1416         return '<%s: %s>' % (self.__class__.__name__, self)
1417 
1418     def get_group_by_cols(self, alias=None):
1419         return []
1420 
1421 
1422 class WindowFrame(Expression):
1423     """
1424     Model the frame clause in window expressions. There are two types of frame
1425     clauses which are subclasses, however, all processing and validation (by no
1426     means intended to be complete) is done here. Thus, providing an end for a
1427     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1428     row in the frame).
1429     """
1430     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1431 
1432     def __init__(self, start=None, end=None):
1433         self.start = Value(start)
1434         self.end = Value(end)
1435 
1436     def set_source_expressions(self, exprs):
1437         self.start, self.end = exprs
1438 
1439     def get_source_expressions(self):
1440         return [self.start, self.end]
1441 
1442     def as_sql(self, compiler, connection):
1443         connection.ops.check_expression_support(self)
1444         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1445         return self.template % {
1446             'frame_type': self.frame_type,
1447             'start': start,
1448             'end': end,
1449         }, []
1450 
1451     def __repr__(self):
1452         return '<%s: %s>' % (self.__class__.__name__, self)
1453 
1454     def get_group_by_cols(self, alias=None):
1455         return []
1456 
1457     def __str__(self):
1458         if self.start.value is not None and self.start.value < 0:
1459             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1460         elif self.start.value is not None and self.start.value == 0:
1461             start = connection.ops.CURRENT_ROW
1462         else:
1463             start = connection.ops.UNBOUNDED_PRECEDING
1464 
1465         if self.end.value is not None and self.end.value > 0:
1466             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1467         elif self.end.value is not None and self.end.value == 0:
1468             end = connection.ops.CURRENT_ROW
1469         else:
1470             end = connection.ops.UNBOUNDED_FOLLOWING
1471         return self.template % {
1472             'frame_type': self.frame_type,
1473             'start': start,
1474             'end': end,
1475         }
1476 
1477     def window_frame_start_end(self, connection, start, end):
1478         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1479 
1480 
1481 class RowRange(WindowFrame):
1482     frame_type = 'ROWS'
1483 
1484     def window_frame_start_end(self, connection, start, end):
1485         return connection.ops.window_frame_rows_start_end(start, end)
1486 
1487 
1488 class ValueRange(WindowFrame):
1489     frame_type = 'RANGE'
1490 
1491     def window_frame_start_end(self, connection, start, end):
1492         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>This file likely contains the implementation of `Subquery` and possibly how expressions involving `OuterRef` are treated when used in complex queries, such as with `union` or the `|` operator. A detailed examination is needed to pinpoint the exact locations.</intended_behavior>, <file>django/db/models/sql/compiler.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections
2 import json
3 import re
4 from functools import partial
5 from itertools import chain
6 
7 from django.core.exceptions import EmptyResultSet, FieldError
8 from django.db import DatabaseError, NotSupportedError
9 from django.db.models.constants import LOOKUP_SEP
10 from django.db.models.expressions import F, OrderBy, RawSQL, Ref, Value
11 from django.db.models.functions import Cast, Random
12 from django.db.models.query_utils import select_related_descend
13 from django.db.models.sql.constants import (
14     CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS, ORDER_DIR, SINGLE,
15 )
16 from django.db.models.sql.query import Query, get_order_dir
17 from django.db.transaction import TransactionManagementError
18 from django.utils.functional import cached_property
19 from django.utils.hashable import make_hashable
20 from django.utils.regex_helper import _lazy_re_compile
21 
22 
23 class SQLCompiler:
24     # Multiline ordering SQL clause may appear from RawSQL.
25     ordering_parts = _lazy_re_compile(
26         r'^(.*)\s(?:ASC|DESC).*',
27         re.MULTILINE | re.DOTALL,
28     )
29 
30     def __init__(self, query, connection, using, elide_empty=True):
31         self.query = query
32         self.connection = connection
33         self.using = using
34         # Some queries, e.g. coalesced aggregation, need to be executed even if
35         # they would return an empty result set.
36         self.elide_empty = elide_empty
37         self.quote_cache = {'*': '*'}
38         # The select, klass_info, and annotations are needed by QuerySet.iterator()
39         # these are set as a side-effect of executing the query. Note that we calculate
40         # separately a list of extra select columns needed for grammatical correctness
41         # of the query, but these columns are not included in self.select.
42         self.select = None
43         self.annotation_col_map = None
44         self.klass_info = None
45         self._meta_ordering = None
46 
47     def __repr__(self):
48         return (
49             f'<{self.__class__.__qualname__} '
50             f'model={self.query.model.__qualname__} '
51             f'connection={self.connection!r} using={self.using!r}>'
52         )
53 
54     def setup_query(self):
55         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
56             self.query.get_initial_alias()
57         self.select, self.klass_info, self.annotation_col_map = self.get_select()
58         self.col_count = len(self.select)
59 
60     def pre_sql_setup(self):
61         """
62         Do any necessary class setup immediately prior to producing SQL. This
63         is for things that can't necessarily be done in __init__ because we
64         might not have all the pieces in place at that time.
65         """
66         self.setup_query()
67         order_by = self.get_order_by()
68         self.where, self.having = self.query.where.split_having()
69         extra_select = self.get_extra_select(order_by, self.select)
70         self.has_extra_select = bool(extra_select)
71         group_by = self.get_group_by(self.select + extra_select, order_by)
72         return extra_select, order_by, group_by
73 
74     def get_group_by(self, select, order_by):
75         """
76         Return a list of 2-tuples of form (sql, params).
77 
78         The logic of what exactly the GROUP BY clause contains is hard
79         to describe in other words than "if it passes the test suite,
80         then it is correct".
81         """
82         # Some examples:
83         #     SomeModel.objects.annotate(Count('somecol'))
84         #     GROUP BY: all fields of the model
85         #
86         #    SomeModel.objects.values('name').annotate(Count('somecol'))
87         #    GROUP BY: name
88         #
89         #    SomeModel.objects.annotate(Count('somecol')).values('name')
90         #    GROUP BY: all cols of the model
91         #
92         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')
93         #    GROUP BY: name, pk
94         #
95         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')
96         #    GROUP BY: name, pk
97         #
98         # In fact, the self.query.group_by is the minimal set to GROUP BY. It
99         # can't be ever restricted to a smaller set, but additional columns in
100         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately
101         # the end result is that it is impossible to force the query to have
102         # a chosen GROUP BY clause - you can almost do this by using the form:
103         #     .values(*wanted_cols).annotate(AnAggregate())
104         # but any later annotations, extra selects, values calls that
105         # refer some column outside of the wanted_cols, order_by, or even
106         # filter calls can alter the GROUP BY clause.
107 
108         # The query.group_by is either None (no GROUP BY at all), True
109         # (group by select fields), or a list of expressions to be added
110         # to the group by.
111         if self.query.group_by is None:
112             return []
113         expressions = []
114         if self.query.group_by is not True:
115             # If the group by is set to a list (by .values() call most likely),
116             # then we need to add everything in it to the GROUP BY clause.
117             # Backwards compatibility hack for setting query.group_by. Remove
118             # when  we have public API way of forcing the GROUP BY clause.
119             # Converts string references to expressions.
120             for expr in self.query.group_by:
121                 if not hasattr(expr, 'as_sql'):
122                     expressions.append(self.query.resolve_ref(expr))
123                 else:
124                     expressions.append(expr)
125         # Note that even if the group_by is set, it is only the minimal
126         # set to group by. So, we need to add cols in select, order_by, and
127         # having into the select in any case.
128         ref_sources = {
129             expr.source for expr in expressions if isinstance(expr, Ref)
130         }
131         for expr, _, _ in select:
132             # Skip members of the select clause that are already included
133             # by reference.
134             if expr in ref_sources:
135                 continue
136             cols = expr.get_group_by_cols()
137             for col in cols:
138                 expressions.append(col)
139         if not self._meta_ordering:
140             for expr, (sql, params, is_ref) in order_by:
141                 # Skip references to the SELECT clause, as all expressions in
142                 # the SELECT clause are already part of the GROUP BY.
143                 if not is_ref:
144                     expressions.extend(expr.get_group_by_cols())
145         having_group_by = self.having.get_group_by_cols() if self.having else ()
146         for expr in having_group_by:
147             expressions.append(expr)
148         result = []
149         seen = set()
150         expressions = self.collapse_group_by(expressions, having_group_by)
151 
152         for expr in expressions:
153             sql, params = self.compile(expr)
154             sql, params = expr.select_format(self, sql, params)
155             params_hash = make_hashable(params)
156             if (sql, params_hash) not in seen:
157                 result.append((sql, params))
158                 seen.add((sql, params_hash))
159         return result
160 
161     def collapse_group_by(self, expressions, having):
162         # If the DB can group by primary key, then group by the primary key of
163         # query's main model. Note that for PostgreSQL the GROUP BY clause must
164         # include the primary key of every table, but for MySQL it is enough to
165         # have the main table's primary key.
166         if self.connection.features.allows_group_by_pk:
167             # Determine if the main model's primary key is in the query.
168             pk = None
169             for expr in expressions:
170                 # Is this a reference to query's base table primary key? If the
171                 # expression isn't a Col-like, then skip the expression.
172                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and
173                         getattr(expr, 'alias', None) == self.query.base_table):
174                     pk = expr
175                     break
176             # If the main model's primary key is in the query, group by that
177             # field, HAVING expressions, and expressions associated with tables
178             # that don't have a primary key included in the grouped columns.
179             if pk:
180                 pk_aliases = {
181                     expr.alias for expr in expressions
182                     if hasattr(expr, 'target') and expr.target.primary_key
183                 }
184                 expressions = [pk] + [
185                     expr for expr in expressions
186                     if expr in having or (
187                         getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases
188                     )
189                 ]
190         elif self.connection.features.allows_group_by_selected_pks:
191             # Filter out all expressions associated with a table's primary key
192             # present in the grouped columns. This is done by identifying all
193             # tables that have their primary key included in the grouped
194             # columns and removing non-primary key columns referring to them.
195             # Unmanaged models are excluded because they could be representing
196             # database views on which the optimization might not be allowed.
197             pks = {
198                 expr for expr in expressions
199                 if (
200                     hasattr(expr, 'target') and
201                     expr.target.primary_key and
202                     self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)
203                 )
204             }
205             aliases = {expr.alias for expr in pks}
206             expressions = [
207                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases
208             ]
209         return expressions
210 
211     def get_select(self):
212         """
213         Return three values:
214         - a list of 3-tuples of (expression, (sql, params), alias)
215         - a klass_info structure,
216         - a dictionary of annotations
217 
218         The (sql, params) is what the expression will produce, and alias is the
219         "AS alias" for the column (possibly None).
220 
221         The klass_info structure contains the following information:
222         - The base model of the query.
223         - Which columns for that model are present in the query (by
224           position of the select clause).
225         - related_klass_infos: [f, klass_info] to descent into
226 
227         The annotations is a dictionary of {'attname': column position} values.
228         """
229         select = []
230         klass_info = None
231         annotations = {}
232         select_idx = 0
233         for alias, (sql, params) in self.query.extra_select.items():
234             annotations[alias] = select_idx
235             select.append((RawSQL(sql, params), alias))
236             select_idx += 1
237         assert not (self.query.select and self.query.default_cols)
238         if self.query.default_cols:
239             cols = self.get_default_columns()
240         else:
241             # self.query.select is a special case. These columns never go to
242             # any model.
243             cols = self.query.select
244         if cols:
245             select_list = []
246             for col in cols:
247                 select_list.append(select_idx)
248                 select.append((col, None))
249                 select_idx += 1
250             klass_info = {
251                 'model': self.query.model,
252                 'select_fields': select_list,
253             }
254         for alias, annotation in self.query.annotation_select.items():
255             annotations[alias] = select_idx
256             select.append((annotation, alias))
257             select_idx += 1
258 
259         if self.query.select_related:
260             related_klass_infos = self.get_related_selections(select)
261             klass_info['related_klass_infos'] = related_klass_infos
262 
263             def get_select_from_parent(klass_info):
264                 for ki in klass_info['related_klass_infos']:
265                     if ki['from_parent']:
266                         ki['select_fields'] = (klass_info['select_fields'] +
267                                                ki['select_fields'])
268                     get_select_from_parent(ki)
269             get_select_from_parent(klass_info)
270 
271         ret = []
272         for col, alias in select:
273             try:
274                 sql, params = self.compile(col)
275             except EmptyResultSet:
276                 empty_result_set_value = getattr(col, 'empty_result_set_value', NotImplemented)
277                 if empty_result_set_value is NotImplemented:
278                     # Select a predicate that's always False.
279                     sql, params = '0', ()
280                 else:
281                     sql, params = self.compile(Value(empty_result_set_value))
282             else:
283                 sql, params = col.select_format(self, sql, params)
284             ret.append((col, (sql, params), alias))
285         return ret, klass_info, annotations
286 
287     def _order_by_pairs(self):
288         if self.query.extra_order_by:
289             ordering = self.query.extra_order_by
290         elif not self.query.default_ordering:
291             ordering = self.query.order_by
292         elif self.query.order_by:
293             ordering = self.query.order_by
294         elif self.query.get_meta().ordering:
295             ordering = self.query.get_meta().ordering
296             self._meta_ordering = ordering
297         else:
298             ordering = []
299         if self.query.standard_ordering:
300             default_order, _ = ORDER_DIR['ASC']
301         else:
302             default_order, _ = ORDER_DIR['DESC']
303 
304         for field in ordering:
305             if hasattr(field, 'resolve_expression'):
306                 if isinstance(field, Value):
307                     # output_field must be resolved for constants.
308                     field = Cast(field, field.output_field)
309                 if not isinstance(field, OrderBy):
310                     field = field.asc()
311                 if not self.query.standard_ordering:
312                     field = field.copy()
313                     field.reverse_ordering()
314                 yield field, False
315                 continue
316             if field == '?':  # random
317                 yield OrderBy(Random()), False
318                 continue
319 
320             col, order = get_order_dir(field, default_order)
321             descending = order == 'DESC'
322 
323             if col in self.query.annotation_select:
324                 # Reference to expression in SELECT clause
325                 yield (
326                     OrderBy(
327                         Ref(col, self.query.annotation_select[col]),
328                         descending=descending,
329                     ),
330                     True,
331                 )
332                 continue
333             if col in self.query.annotations:
334                 # References to an expression which is masked out of the SELECT
335                 # clause.
336                 if self.query.combinator and self.select:
337                     # Don't use the resolved annotation because other
338                     # combinated queries might define it differently.
339                     expr = F(col)
340                 else:
341                     expr = self.query.annotations[col]
342                     if isinstance(expr, Value):
343                         # output_field must be resolved for constants.
344                         expr = Cast(expr, expr.output_field)
345                 yield OrderBy(expr, descending=descending), False
346                 continue
347 
348             if '.' in field:
349                 # This came in through an extra(order_by=...) addition. Pass it
350                 # on verbatim.
351                 table, col = col.split('.', 1)
352                 yield (
353                     OrderBy(
354                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),
355                         descending=descending,
356                     ),
357                     False,
358                 )
359                 continue
360 
361             if self.query.extra and col in self.query.extra:
362                 if col in self.query.extra_select:
363                     yield (
364                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),
365                         True,
366                     )
367                 else:
368                     yield (
369                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),
370                         False,
371                     )
372             else:
373                 if self.query.combinator and self.select:
374                     # Don't use the first model's field because other
375                     # combinated queries might define it differently.
376                     yield OrderBy(F(col), descending=descending), False
377                 else:
378                     # 'col' is of the form 'field' or 'field1__field2' or
379                     # '-field1__field2__field', etc.
380                     yield from self.find_ordering_name(
381                         field, self.query.get_meta(), default_order=default_order,
382                     )
383 
384     def get_order_by(self):
385         """
386         Return a list of 2-tuples of the form (expr, (sql, params, is_ref)) for
387         the ORDER BY clause.
388 
389         The order_by clause can alter the select clause (for example it can add
390         aliases to clauses that do not yet have one, or it can add totally new
391         select clauses).
392         """
393         result = []
394         seen = set()
395 
396         for expr, is_ref in self._order_by_pairs():
397             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
398             if self.query.combinator and self.select:
399                 src = resolved.get_source_expressions()[0]
400                 expr_src = expr.get_source_expressions()[0]
401                 # Relabel order by columns to raw numbers if this is a combined
402                 # query; necessary since the columns can't be referenced by the
403                 # fully qualified name and the simple column names may collide.
404                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):
405                     if is_ref and col_alias == src.refs:
406                         src = src.source
407                     elif col_alias and not (
408                         isinstance(expr_src, F) and col_alias == expr_src.name
409                     ):
410                         continue
411                     if src == sel_expr:
412                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])
413                         break
414                 else:
415                     if col_alias:
416                         raise DatabaseError('ORDER BY term does not match any column in the result set.')
417                     # Add column used in ORDER BY clause to the selected
418                     # columns and to each combined query.
419                     order_by_idx = len(self.query.select) + 1
420                     col_name = f'__orderbycol{order_by_idx}'
421                     for q in self.query.combined_queries:
422                         q.add_annotation(expr_src, col_name)
423                     self.query.add_select_col(resolved, col_name)
424                     resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])
425             sql, params = self.compile(resolved)
426             # Don't add the same column twice, but the order direction is
427             # not taken into account so we strip it. When this entire method
428             # is refactored into expressions, then we can check each part as we
429             # generate it.
430             without_ordering = self.ordering_parts.search(sql)[1]
431             params_hash = make_hashable(params)
432             if (without_ordering, params_hash) in seen:
433                 continue
434             seen.add((without_ordering, params_hash))
435             result.append((resolved, (sql, params, is_ref)))
436         return result
437 
438     def get_extra_select(self, order_by, select):
439         extra_select = []
440         if self.query.distinct and not self.query.distinct_fields:
441             select_sql = [t[1] for t in select]
442             for expr, (sql, params, is_ref) in order_by:
443                 without_ordering = self.ordering_parts.search(sql)[1]
444                 if not is_ref and (without_ordering, params) not in select_sql:
445                     extra_select.append((expr, (without_ordering, params), None))
446         return extra_select
447 
448     def quote_name_unless_alias(self, name):
449         """
450         A wrapper around connection.ops.quote_name that doesn't quote aliases
451         for table names. This avoids problems with some SQL dialects that treat
452         quoted strings specially (e.g. PostgreSQL).
453         """
454         if name in self.quote_cache:
455             return self.quote_cache[name]
456         if ((name in self.query.alias_map and name not in self.query.table_map) or
457                 name in self.query.extra_select or (
458                     self.query.external_aliases.get(name) and name not in self.query.table_map)):
459             self.quote_cache[name] = name
460             return name
461         r = self.connection.ops.quote_name(name)
462         self.quote_cache[name] = r
463         return r
464 
465     def compile(self, node):
466         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
467         if vendor_impl:
468             sql, params = vendor_impl(self, self.connection)
469         else:
470             sql, params = node.as_sql(self, self.connection)
471         return sql, params
472 
473     def get_combinator_sql(self, combinator, all):
474         features = self.connection.features
475         compilers = [
476             query.get_compiler(self.using, self.connection, self.elide_empty)
477             for query in self.query.combined_queries if not query.is_empty()
478         ]
479         if not features.supports_slicing_ordering_in_compound:
480             for query, compiler in zip(self.query.combined_queries, compilers):
481                 if query.low_mark or query.high_mark:
482                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')
483                 if compiler.get_order_by():
484                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')
485         parts = ()
486         for compiler in compilers:
487             try:
488                 # If the columns list is limited, then all combined queries
489                 # must have the same columns list. Set the selects defined on
490                 # the query on all combined queries, if not already set.
491                 if not compiler.query.values_select and self.query.values_select:
492                     compiler.query = compiler.query.clone()
493                     compiler.query.set_values((
494                         *self.query.extra_select,
495                         *self.query.values_select,
496                         *self.query.annotation_select,
497                     ))
498                 part_sql, part_args = compiler.as_sql()
499                 if compiler.query.combinator:
500                     # Wrap in a subquery if wrapping in parentheses isn't
501                     # supported.
502                     if not features.supports_parentheses_in_compound:
503                         part_sql = 'SELECT * FROM ({})'.format(part_sql)
504                     # Add parentheses when combining with compound query if not
505                     # already added for all compound queries.
506                     elif not features.supports_slicing_ordering_in_compound:
507                         part_sql = '({})'.format(part_sql)
508                 parts += ((part_sql, part_args),)
509             except EmptyResultSet:
510                 # Omit the empty queryset with UNION and with DIFFERENCE if the
511                 # first queryset is nonempty.
512                 if combinator == 'union' or (combinator == 'difference' and parts):
513                     continue
514                 raise
515         if not parts:
516             raise EmptyResultSet
517         combinator_sql = self.connection.ops.set_operators[combinator]
518         if all and combinator == 'union':
519             combinator_sql += ' ALL'
520         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'
521         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
522         result = [' {} '.format(combinator_sql).join(sql_parts)]
523         params = []
524         for part in args_parts:
525             params.extend(part)
526         return result, params
527 
528     def as_sql(self, with_limits=True, with_col_aliases=False):
529         """
530         Create the SQL for this query. Return the SQL string and list of
531         parameters.
532 
533         If 'with_limits' is False, any limit/offset information is not included
534         in the query.
535         """
536         refcounts_before = self.query.alias_refcount.copy()
537         try:
538             extra_select, order_by, group_by = self.pre_sql_setup()
539             for_update_part = None
540             # Is a LIMIT/OFFSET clause needed?
541             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
542             combinator = self.query.combinator
543             features = self.connection.features
544             if combinator:
545                 if not getattr(features, 'supports_select_{}'.format(combinator)):
546                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
547                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
548             else:
549                 distinct_fields, distinct_params = self.get_distinct()
550                 # This must come after 'select', 'ordering', and 'distinct'
551                 # (see docstring of get_from_clause() for details).
552                 from_, f_params = self.get_from_clause()
553                 try:
554                     where, w_params = self.compile(self.where) if self.where is not None else ('', [])
555                 except EmptyResultSet:
556                     if self.elide_empty:
557                         raise
558                     # Use a predicate that's always False.
559                     where, w_params = '0 = 1', []
560                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
561                 result = ['SELECT']
562                 params = []
563 
564                 if self.query.distinct:
565                     distinct_result, distinct_params = self.connection.ops.distinct_sql(
566                         distinct_fields,
567                         distinct_params,
568                     )
569                     result += distinct_result
570                     params += distinct_params
571 
572                 out_cols = []
573                 col_idx = 1
574                 for _, (s_sql, s_params), alias in self.select + extra_select:
575                     if alias:
576                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
577                     elif with_col_aliases:
578                         s_sql = '%s AS %s' % (
579                             s_sql,
580                             self.connection.ops.quote_name('col%d' % col_idx),
581                         )
582                         col_idx += 1
583                     params.extend(s_params)
584                     out_cols.append(s_sql)
585 
586                 result += [', '.join(out_cols), 'FROM', *from_]
587                 params.extend(f_params)
588 
589                 if self.query.select_for_update and self.connection.features.has_select_for_update:
590                     if self.connection.get_autocommit():
591                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')
592 
593                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:
594                         raise NotSupportedError(
595                             'LIMIT/OFFSET is not supported with '
596                             'select_for_update on this database backend.'
597                         )
598                     nowait = self.query.select_for_update_nowait
599                     skip_locked = self.query.select_for_update_skip_locked
600                     of = self.query.select_for_update_of
601                     no_key = self.query.select_for_no_key_update
602                     # If it's a NOWAIT/SKIP LOCKED/OF/NO KEY query but the
603                     # backend doesn't support it, raise NotSupportedError to
604                     # prevent a possible deadlock.
605                     if nowait and not self.connection.features.has_select_for_update_nowait:
606                         raise NotSupportedError('NOWAIT is not supported on this database backend.')
607                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:
608                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')
609                     elif of and not self.connection.features.has_select_for_update_of:
610                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')
611                     elif no_key and not self.connection.features.has_select_for_no_key_update:
612                         raise NotSupportedError(
613                             'FOR NO KEY UPDATE is not supported on this '
614                             'database backend.'
615                         )
616                     for_update_part = self.connection.ops.for_update_sql(
617                         nowait=nowait,
618                         skip_locked=skip_locked,
619                         of=self.get_select_for_update_of_arguments(),
620                         no_key=no_key,
621                     )
622 
623                 if for_update_part and self.connection.features.for_update_after_from:
624                     result.append(for_update_part)
625 
626                 if where:
627                     result.append('WHERE %s' % where)
628                     params.extend(w_params)
629 
630                 grouping = []
631                 for g_sql, g_params in group_by:
632                     grouping.append(g_sql)
633                     params.extend(g_params)
634                 if grouping:
635                     if distinct_fields:
636                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')
637                     order_by = order_by or self.connection.ops.force_no_ordering()
638                     result.append('GROUP BY %s' % ', '.join(grouping))
639                     if self._meta_ordering:
640                         order_by = None
641                 if having:
642                     result.append('HAVING %s' % having)
643                     params.extend(h_params)
644 
645             if self.query.explain_info:
646                 result.insert(0, self.connection.ops.explain_query_prefix(
647                     self.query.explain_info.format,
648                     **self.query.explain_info.options
649                 ))
650 
651             if order_by:
652                 ordering = []
653                 for _, (o_sql, o_params, _) in order_by:
654                     ordering.append(o_sql)
655                     params.extend(o_params)
656                 result.append('ORDER BY %s' % ', '.join(ordering))
657 
658             if with_limit_offset:
659                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
660 
661             if for_update_part and not self.connection.features.for_update_after_from:
662                 result.append(for_update_part)
663 
664             if self.query.subquery and extra_select:
665                 # If the query is used as a subquery, the extra selects would
666                 # result in more columns than the left-hand side expression is
667                 # expecting. This can happen when a subquery uses a combination
668                 # of order_by() and distinct(), forcing the ordering expressions
669                 # to be selected as well. Wrap the query in another subquery
670                 # to exclude extraneous selects.
671                 sub_selects = []
672                 sub_params = []
673                 for index, (select, _, alias) in enumerate(self.select, start=1):
674                     if not alias and with_col_aliases:
675                         alias = 'col%d' % index
676                     if alias:
677                         sub_selects.append("%s.%s" % (
678                             self.connection.ops.quote_name('subquery'),
679                             self.connection.ops.quote_name(alias),
680                         ))
681                     else:
682                         select_clone = select.relabeled_clone({select.alias: 'subquery'})
683                         subselect, subparams = select_clone.as_sql(self, self.connection)
684                         sub_selects.append(subselect)
685                         sub_params.extend(subparams)
686                 return 'SELECT %s FROM (%s) subquery' % (
687                     ', '.join(sub_selects),
688                     ' '.join(result),
689                 ), tuple(sub_params + params)
690 
691             return ' '.join(result), tuple(params)
692         finally:
693             # Finally do cleanup - get rid of the joins we created above.
694             self.query.reset_refcounts(refcounts_before)
695 
696     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):
697         """
698         Compute the default columns for selecting every field in the base
699         model. Will sometimes be called to pull in related models (e.g. via
700         select_related), in which case "opts" and "start_alias" will be given
701         to provide a starting point for the traversal.
702 
703         Return a list of strings, quoted appropriately for use in SQL
704         directly, as well as a set of aliases used in the select statement (if
705         'as_pairs' is True, return a list of (alias, col_name) pairs instead
706         of strings as the first component and None as the second component).
707         """
708         result = []
709         if opts is None:
710             opts = self.query.get_meta()
711         only_load = self.deferred_to_columns()
712         start_alias = start_alias or self.query.get_initial_alias()
713         # The 'seen_models' is used to optimize checking the needed parent
714         # alias for a given field. This also includes None -> start_alias to
715         # be used by local fields.
716         seen_models = {None: start_alias}
717 
718         for field in opts.concrete_fields:
719             model = field.model._meta.concrete_model
720             # A proxy model will have a different model and concrete_model. We
721             # will assign None if the field belongs to this model.
722             if model == opts.model:
723                 model = None
724             if from_parent and model is not None and issubclass(
725                     from_parent._meta.concrete_model, model._meta.concrete_model):
726                 # Avoid loading data for already loaded parents.
727                 # We end up here in the case select_related() resolution
728                 # proceeds from parent model to child model. In that case the
729                 # parent model data is already present in the SELECT clause,
730                 # and we want to avoid reloading the same data again.
731                 continue
732             if field.model in only_load and field.attname not in only_load[field.model]:
733                 continue
734             alias = self.query.join_parent_model(opts, model, start_alias,
735                                                  seen_models)
736             column = field.get_col(alias)
737             result.append(column)
738         return result
739 
740     def get_distinct(self):
741         """
742         Return a quoted list of fields to use in DISTINCT ON part of the query.
743 
744         This method can alter the tables in the query, and thus it must be
745         called before get_from_clause().
746         """
747         result = []
748         params = []
749         opts = self.query.get_meta()
750 
751         for name in self.query.distinct_fields:
752             parts = name.split(LOOKUP_SEP)
753             _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)
754             targets, alias, _ = self.query.trim_joins(targets, joins, path)
755             for target in targets:
756                 if name in self.query.annotation_select:
757                     result.append(self.connection.ops.quote_name(name))
758                 else:
759                     r, p = self.compile(transform_function(target, alias))
760                     result.append(r)
761                     params.append(p)
762         return result, params
763 
764     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',
765                            already_seen=None):
766         """
767         Return the table alias (the name might be ambiguous, the alias will
768         not be) and column name for ordering by the given 'name' parameter.
769         The 'name' is of the form 'field1__field2__...__fieldN'.
770         """
771         name, order = get_order_dir(name, default_order)
772         descending = order == 'DESC'
773         pieces = name.split(LOOKUP_SEP)
774         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
775 
776         # If we get to this point and the field is a relation to another model,
777         # append the default ordering for that model unless it is the pk
778         # shortcut or the attribute name of the field that is specified.
779         if (
780             field.is_relation and
781             opts.ordering and
782             getattr(field, 'attname', None) != pieces[-1] and
783             name != 'pk'
784         ):
785             # Firstly, avoid infinite loops.
786             already_seen = already_seen or set()
787             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)
788             if join_tuple in already_seen:
789                 raise FieldError('Infinite loop caused by ordering.')
790             already_seen.add(join_tuple)
791 
792             results = []
793             for item in opts.ordering:
794                 if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):
795                     item = item.desc() if descending else item.asc()
796                 if isinstance(item, OrderBy):
797                     results.append((item, False))
798                     continue
799                 results.extend(self.find_ordering_name(item, opts, alias,
800                                                        order, already_seen))
801             return results
802         targets, alias, _ = self.query.trim_joins(targets, joins, path)
803         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
804 
805     def _setup_joins(self, pieces, opts, alias):
806         """
807         Helper method for get_order_by() and get_distinct().
808 
809         get_ordering() and get_distinct() must produce same target columns on
810         same input, as the prefixes of get_ordering() and get_distinct() must
811         match. Executing SQL where this is not true is an error.
812         """
813         alias = alias or self.query.get_initial_alias()
814         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
815         alias = joins[-1]
816         return field, targets, alias, joins, path, opts, transform_function
817 
818     def get_from_clause(self):
819         """
820         Return a list of strings that are joined together to go after the
821         "FROM" part of the query, as well as a list any extra parameters that
822         need to be included. Subclasses, can override this to create a
823         from-clause via a "select".
824 
825         This should only be called after any SQL construction methods that
826         might change the tables that are needed. This means the select columns,
827         ordering, and distinct must be done first.
828         """
829         result = []
830         params = []
831         for alias in tuple(self.query.alias_map):
832             if not self.query.alias_refcount[alias]:
833                 continue
834             try:
835                 from_clause = self.query.alias_map[alias]
836             except KeyError:
837                 # Extra tables can end up in self.tables, but not in the
838                 # alias_map if they aren't in a join. That's OK. We skip them.
839                 continue
840             clause_sql, clause_params = self.compile(from_clause)
841             result.append(clause_sql)
842             params.extend(clause_params)
843         for t in self.query.extra_tables:
844             alias, _ = self.query.table_alias(t)
845             # Only add the alias if it's not already present (the table_alias()
846             # call increments the refcount, so an alias refcount of one means
847             # this is the only reference).
848             if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:
849                 result.append(', %s' % self.quote_name_unless_alias(alias))
850         return result, params
851 
852     def get_related_selections(self, select, opts=None, root_alias=None, cur_depth=1,
853                                requested=None, restricted=None):
854         """
855         Fill in the information needed for a select_related query. The current
856         depth is measured as the number of connections away from the root model
857         (for example, cur_depth=1 means we are looking at models with direct
858         connections to the root model).
859         """
860         def _get_field_choices():
861             direct_choices = (f.name for f in opts.fields if f.is_relation)
862             reverse_choices = (
863                 f.field.related_query_name()
864                 for f in opts.related_objects if f.field.unique
865             )
866             return chain(direct_choices, reverse_choices, self.query._filtered_relations)
867 
868         related_klass_infos = []
869         if not restricted and cur_depth > self.query.max_depth:
870             # We've recursed far enough; bail out.
871             return related_klass_infos
872 
873         if not opts:
874             opts = self.query.get_meta()
875             root_alias = self.query.get_initial_alias()
876         only_load = self.query.get_loaded_field_names()
877 
878         # Setup for the case when only particular related fields should be
879         # included in the related selection.
880         fields_found = set()
881         if requested is None:
882             restricted = isinstance(self.query.select_related, dict)
883             if restricted:
884                 requested = self.query.select_related
885 
886         def get_related_klass_infos(klass_info, related_klass_infos):
887             klass_info['related_klass_infos'] = related_klass_infos
888 
889         for f in opts.fields:
890             field_model = f.model._meta.concrete_model
891             fields_found.add(f.name)
892 
893             if restricted:
894                 next = requested.get(f.name, {})
895                 if not f.is_relation:
896                     # If a non-related field is used like a relation,
897                     # or if a single non-relational field is given.
898                     if next or f.name in requested:
899                         raise FieldError(
900                             "Non-relational field given in select_related: '%s'. "
901                             "Choices are: %s" % (
902                                 f.name,
903                                 ", ".join(_get_field_choices()) or '(none)',
904                             )
905                         )
906             else:
907                 next = False
908 
909             if not select_related_descend(f, restricted, requested,
910                                           only_load.get(field_model)):
911                 continue
912             klass_info = {
913                 'model': f.remote_field.model,
914                 'field': f,
915                 'reverse': False,
916                 'local_setter': f.set_cached_value,
917                 'remote_setter': f.remote_field.set_cached_value if f.unique else lambda x, y: None,
918                 'from_parent': False,
919             }
920             related_klass_infos.append(klass_info)
921             select_fields = []
922             _, _, _, joins, _, _ = self.query.setup_joins(
923                 [f.name], opts, root_alias)
924             alias = joins[-1]
925             columns = self.get_default_columns(start_alias=alias, opts=f.remote_field.model._meta)
926             for col in columns:
927                 select_fields.append(len(select))
928                 select.append((col, None))
929             klass_info['select_fields'] = select_fields
930             next_klass_infos = self.get_related_selections(
931                 select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)
932             get_related_klass_infos(klass_info, next_klass_infos)
933 
934         if restricted:
935             related_fields = [
936                 (o.field, o.related_model)
937                 for o in opts.related_objects
938                 if o.field.unique and not o.many_to_many
939             ]
940             for f, model in related_fields:
941                 if not select_related_descend(f, restricted, requested,
942                                               only_load.get(model), reverse=True):
943                     continue
944 
945                 related_field_name = f.related_query_name()
946                 fields_found.add(related_field_name)
947 
948                 join_info = self.query.setup_joins([related_field_name], opts, root_alias)
949                 alias = join_info.joins[-1]
950                 from_parent = issubclass(model, opts.model) and model is not opts.model
951                 klass_info = {
952                     'model': model,
953                     'field': f,
954                     'reverse': True,
955                     'local_setter': f.remote_field.set_cached_value,
956                     'remote_setter': f.set_cached_value,
957                     'from_parent': from_parent,
958                 }
959                 related_klass_infos.append(klass_info)
960                 select_fields = []
961                 columns = self.get_default_columns(
962                     start_alias=alias, opts=model._meta, from_parent=opts.model)
963                 for col in columns:
964                     select_fields.append(len(select))
965                     select.append((col, None))
966                 klass_info['select_fields'] = select_fields
967                 next = requested.get(f.related_query_name(), {})
968                 next_klass_infos = self.get_related_selections(
969                     select, model._meta, alias, cur_depth + 1,
970                     next, restricted)
971                 get_related_klass_infos(klass_info, next_klass_infos)
972 
973             def local_setter(obj, from_obj):
974                 # Set a reverse fk object when relation is non-empty.
975                 if from_obj:
976                     f.remote_field.set_cached_value(from_obj, obj)
977 
978             def remote_setter(name, obj, from_obj):
979                 setattr(from_obj, name, obj)
980 
981             for name in list(requested):
982                 # Filtered relations work only on the topmost level.
983                 if cur_depth > 1:
984                     break
985                 if name in self.query._filtered_relations:
986                     fields_found.add(name)
987                     f, _, join_opts, joins, _, _ = self.query.setup_joins([name], opts, root_alias)
988                     model = join_opts.model
989                     alias = joins[-1]
990                     from_parent = issubclass(model, opts.model) and model is not opts.model
991                     klass_info = {
992                         'model': model,
993                         'field': f,
994                         'reverse': True,
995                         'local_setter': local_setter,
996                         'remote_setter': partial(remote_setter, name),
997                         'from_parent': from_parent,
998                     }
999                     related_klass_infos.append(klass_info)
1000                     select_fields = []
1001                     columns = self.get_default_columns(
1002                         start_alias=alias, opts=model._meta,
1003                         from_parent=opts.model,
1004                     )
1005                     for col in columns:
1006                         select_fields.append(len(select))
1007                         select.append((col, None))
1008                     klass_info['select_fields'] = select_fields
1009                     next_requested = requested.get(name, {})
1010                     next_klass_infos = self.get_related_selections(
1011                         select, opts=model._meta, root_alias=alias,
1012                         cur_depth=cur_depth + 1, requested=next_requested,
1013                         restricted=restricted,
1014                     )
1015                     get_related_klass_infos(klass_info, next_klass_infos)
1016             fields_not_found = set(requested).difference(fields_found)
1017             if fields_not_found:
1018                 invalid_fields = ("'%s'" % s for s in fields_not_found)
1019                 raise FieldError(
1020                     'Invalid field name(s) given in select_related: %s. '
1021                     'Choices are: %s' % (
1022                         ', '.join(invalid_fields),
1023                         ', '.join(_get_field_choices()) or '(none)',
1024                     )
1025                 )
1026         return related_klass_infos
1027 
1028     def get_select_for_update_of_arguments(self):
1029         """
1030         Return a quoted list of arguments for the SELECT FOR UPDATE OF part of
1031         the query.
1032         """
1033         def _get_parent_klass_info(klass_info):
1034             concrete_model = klass_info['model']._meta.concrete_model
1035             for parent_model, parent_link in concrete_model._meta.parents.items():
1036                 parent_list = parent_model._meta.get_parent_list()
1037                 yield {
1038                     'model': parent_model,
1039                     'field': parent_link,
1040                     'reverse': False,
1041                     'select_fields': [
1042                         select_index
1043                         for select_index in klass_info['select_fields']
1044                         # Selected columns from a model or its parents.
1045                         if (
1046                             self.select[select_index][0].target.model == parent_model or
1047                             self.select[select_index][0].target.model in parent_list
1048                         )
1049                     ],
1050                 }
1051 
1052         def _get_first_selected_col_from_model(klass_info):
1053             """
1054             Find the first selected column from a model. If it doesn't exist,
1055             don't lock a model.
1056 
1057             select_fields is filled recursively, so it also contains fields
1058             from the parent models.
1059             """
1060             concrete_model = klass_info['model']._meta.concrete_model
1061             for select_index in klass_info['select_fields']:
1062                 if self.select[select_index][0].target.model == concrete_model:
1063                     return self.select[select_index][0]
1064 
1065         def _get_field_choices():
1066             """Yield all allowed field paths in breadth-first search order."""
1067             queue = collections.deque([(None, self.klass_info)])
1068             while queue:
1069                 parent_path, klass_info = queue.popleft()
1070                 if parent_path is None:
1071                     path = []
1072                     yield 'self'
1073                 else:
1074                     field = klass_info['field']
1075                     if klass_info['reverse']:
1076                         field = field.remote_field
1077                     path = parent_path + [field.name]
1078                     yield LOOKUP_SEP.join(path)
1079                 queue.extend(
1080                     (path, klass_info)
1081                     for klass_info in _get_parent_klass_info(klass_info)
1082                 )
1083                 queue.extend(
1084                     (path, klass_info)
1085                     for klass_info in klass_info.get('related_klass_infos', [])
1086                 )
1087         if not self.klass_info:
1088             return []
1089         result = []
1090         invalid_names = []
1091         for name in self.query.select_for_update_of:
1092             klass_info = self.klass_info
1093             if name == 'self':
1094                 col = _get_first_selected_col_from_model(klass_info)
1095             else:
1096                 for part in name.split(LOOKUP_SEP):
1097                     klass_infos = (
1098                         *klass_info.get('related_klass_infos', []),
1099                         *_get_parent_klass_info(klass_info),
1100                     )
1101                     for related_klass_info in klass_infos:
1102                         field = related_klass_info['field']
1103                         if related_klass_info['reverse']:
1104                             field = field.remote_field
1105                         if field.name == part:
1106                             klass_info = related_klass_info
1107                             break
1108                     else:
1109                         klass_info = None
1110                         break
1111                 if klass_info is None:
1112                     invalid_names.append(name)
1113                     continue
1114                 col = _get_first_selected_col_from_model(klass_info)
1115             if col is not None:
1116                 if self.connection.features.select_for_update_of_column:
1117                     result.append(self.compile(col)[0])
1118                 else:
1119                     result.append(self.quote_name_unless_alias(col.alias))
1120         if invalid_names:
1121             raise FieldError(
1122                 'Invalid field name(s) given in select_for_update(of=(...)): %s. '
1123                 'Only relational fields followed in the query are allowed. '
1124                 'Choices are: %s.' % (
1125                     ', '.join(invalid_names),
1126                     ', '.join(_get_field_choices()),
1127                 )
1128             )
1129         return result
1130 
1131     def deferred_to_columns(self):
1132         """
1133         Convert the self.deferred_loading data structure to mapping of table
1134         names to sets of column names which are to be loaded. Return the
1135         dictionary.
1136         """
1137         columns = {}
1138         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
1139         return columns
1140 
1141     def get_converters(self, expressions):
1142         converters = {}
1143         for i, expression in enumerate(expressions):
1144             if expression:
1145                 backend_converters = self.connection.ops.get_db_converters(expression)
1146                 field_converters = expression.get_db_converters(self.connection)
1147                 if backend_converters or field_converters:
1148                     converters[i] = (backend_converters + field_converters, expression)
1149         return converters
1150 
1151     def apply_converters(self, rows, converters):
1152         connection = self.connection
1153         converters = list(converters.items())
1154         for row in map(list, rows):
1155             for pos, (convs, expression) in converters:
1156                 value = row[pos]
1157                 for converter in convs:
1158                     value = converter(value, expression, connection)
1159                 row[pos] = value
1160             yield row
1161 
1162     def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False,
1163                      chunk_size=GET_ITERATOR_CHUNK_SIZE):
1164         """Return an iterator over the results from executing this query."""
1165         if results is None:
1166             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
1167         fields = [s[0] for s in self.select[0:self.col_count]]
1168         converters = self.get_converters(fields)
1169         rows = chain.from_iterable(results)
1170         if converters:
1171             rows = self.apply_converters(rows, converters)
1172             if tuple_expected:
1173                 rows = map(tuple, rows)
1174         return rows
1175 
1176     def has_results(self):
1177         """
1178         Backends (e.g. NoSQL) can override this in order to use optimized
1179         versions of "query has any results."
1180         """
1181         return bool(self.execute_sql(SINGLE))
1182 
1183     def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
1184         """
1185         Run the query against the database and return the result(s). The
1186         return value is a single data item if result_type is SINGLE, or an
1187         iterator over the results if the result_type is MULTI.
1188 
1189         result_type is either MULTI (use fetchmany() to retrieve all rows),
1190         SINGLE (only retrieve a single row), or None. In this last case, the
1191         cursor is returned if any query is executed, since it's used by
1192         subclasses such as InsertQuery). It's possible, however, that no query
1193         is needed, as the filters describe an empty set. In that case, None is
1194         returned, to avoid any unnecessary database interaction.
1195         """
1196         result_type = result_type or NO_RESULTS
1197         try:
1198             sql, params = self.as_sql()
1199             if not sql:
1200                 raise EmptyResultSet
1201         except EmptyResultSet:
1202             if result_type == MULTI:
1203                 return iter([])
1204             else:
1205                 return
1206         if chunked_fetch:
1207             cursor = self.connection.chunked_cursor()
1208         else:
1209             cursor = self.connection.cursor()
1210         try:
1211             cursor.execute(sql, params)
1212         except Exception:
1213             # Might fail for server-side cursors (e.g. connection closed)
1214             cursor.close()
1215             raise
1216 
1217         if result_type == CURSOR:
1218             # Give the caller the cursor to process and close.
1219             return cursor
1220         if result_type == SINGLE:
1221             try:
1222                 val = cursor.fetchone()
1223                 if val:
1224                     return val[0:self.col_count]
1225                 return val
1226             finally:
1227                 # done with the cursor
1228                 cursor.close()
1229         if result_type == NO_RESULTS:
1230             cursor.close()
1231             return
1232 
1233         result = cursor_iter(
1234             cursor, self.connection.features.empty_fetchmany_value,
1235             self.col_count if self.has_extra_select else None,
1236             chunk_size,
1237         )
1238         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
1239             # If we are using non-chunked reads, we return the same data
1240             # structure as normally, but ensure it is all read into memory
1241             # before going any further. Use chunked_fetch if requested,
1242             # unless the database doesn't support it.
1243             return list(result)
1244         return result
1245 
1246     def as_subquery_condition(self, alias, columns, compiler):
1247         qn = compiler.quote_name_unless_alias
1248         qn2 = self.connection.ops.quote_name
1249 
1250         for index, select_col in enumerate(self.query.select):
1251             lhs_sql, lhs_params = self.compile(select_col)
1252             rhs = '%s.%s' % (qn(alias), qn2(columns[index]))
1253             self.query.where.add(
1254                 RawSQL('%s = %s' % (lhs_sql, rhs), lhs_params), 'AND')
1255 
1256         sql, params = self.as_sql()
1257         return 'EXISTS (%s)' % sql, params
1258 
1259     def explain_query(self):
1260         result = list(self.execute_sql())
1261         # Some backends return 1 item tuples with strings, and others return
1262         # tuples with integers and strings. Flatten them out into strings.
1263         output_formatter = json.dumps if self.query.explain_info.format == 'json' else str
1264         for row in result[0]:
1265             if not isinstance(row, str):
1266                 yield ' '.join(output_formatter(c) for c in row)
1267             else:
1268                 yield row
1269 
1270 
1271 class SQLInsertCompiler(SQLCompiler):
1272     returning_fields = None
1273     returning_params = tuple()
1274 
1275     def field_as_sql(self, field, val):
1276         """
1277         Take a field and a value intended to be saved on that field, and
1278         return placeholder SQL and accompanying params. Check for raw values,
1279         expressions, and fields with get_placeholder() defined in that order.
1280 
1281         When field is None, consider the value raw and use it as the
1282         placeholder, with no corresponding parameters returned.
1283         """
1284         if field is None:
1285             # A field value of None means the value is raw.
1286             sql, params = val, []
1287         elif hasattr(val, 'as_sql'):
1288             # This is an expression, let's compile it.
1289             sql, params = self.compile(val)
1290         elif hasattr(field, 'get_placeholder'):
1291             # Some fields (e.g. geo fields) need special munging before
1292             # they can be inserted.
1293             sql, params = field.get_placeholder(val, self, self.connection), [val]
1294         else:
1295             # Return the common case for the placeholder
1296             sql, params = '%s', [val]
1297 
1298         # The following hook is only used by Oracle Spatial, which sometimes
1299         # needs to yield 'NULL' and [] as its placeholder and params instead
1300         # of '%s' and [None]. The 'NULL' placeholder is produced earlier by
1301         # OracleOperations.get_geom_placeholder(). The following line removes
1302         # the corresponding None parameter. See ticket #10888.
1303         params = self.connection.ops.modify_insert_params(sql, params)
1304 
1305         return sql, params
1306 
1307     def prepare_value(self, field, value):
1308         """
1309         Prepare a value to be used in a query by resolving it if it is an
1310         expression and otherwise calling the field's get_db_prep_save().
1311         """
1312         if hasattr(value, 'resolve_expression'):
1313             value = value.resolve_expression(self.query, allow_joins=False, for_save=True)
1314             # Don't allow values containing Col expressions. They refer to
1315             # existing columns on a row, but in the case of insert the row
1316             # doesn't exist yet.
1317             if value.contains_column_references:
1318                 raise ValueError(
1319                     'Failed to insert expression "%s" on %s. F() expressions '
1320                     'can only be used to update, not to insert.' % (value, field)
1321                 )
1322             if value.contains_aggregate:
1323                 raise FieldError(
1324                     'Aggregate functions are not allowed in this query '
1325                     '(%s=%r).' % (field.name, value)
1326                 )
1327             if value.contains_over_clause:
1328                 raise FieldError(
1329                     'Window expressions are not allowed in this query (%s=%r).'
1330                     % (field.name, value)
1331                 )
1332         else:
1333             value = field.get_db_prep_save(value, connection=self.connection)
1334         return value
1335 
1336     def pre_save_val(self, field, obj):
1337         """
1338         Get the given field's value off the given obj. pre_save() is used for
1339         things like auto_now on DateTimeField. Skip it if this is a raw query.
1340         """
1341         if self.query.raw:
1342             return getattr(obj, field.attname)
1343         return field.pre_save(obj, add=True)
1344 
1345     def assemble_as_sql(self, fields, value_rows):
1346         """
1347         Take a sequence of N fields and a sequence of M rows of values, and
1348         generate placeholder SQL and parameters for each field and value.
1349         Return a pair containing:
1350          * a sequence of M rows of N SQL placeholder strings, and
1351          * a sequence of M rows of corresponding parameter values.
1352 
1353         Each placeholder string may contain any number of '%s' interpolation
1354         strings, and each parameter row will contain exactly as many params
1355         as the total number of '%s's in the corresponding placeholder row.
1356         """
1357         if not value_rows:
1358             return [], []
1359 
1360         # list of (sql, [params]) tuples for each object to be saved
1361         # Shape: [n_objs][n_fields][2]
1362         rows_of_fields_as_sql = (
1363             (self.field_as_sql(field, v) for field, v in zip(fields, row))
1364             for row in value_rows
1365         )
1366 
1367         # tuple like ([sqls], [[params]s]) for each object to be saved
1368         # Shape: [n_objs][2][n_fields]
1369         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
1370 
1371         # Extract separate lists for placeholders and params.
1372         # Each of these has shape [n_objs][n_fields]
1373         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
1374 
1375         # Params for each field are still lists, and need to be flattened.
1376         param_rows = [[p for ps in row for p in ps] for row in param_rows]
1377 
1378         return placeholder_rows, param_rows
1379 
1380     def as_sql(self):
1381         # We don't need quote_name_unless_alias() here, since these are all
1382         # going to be column names (so we can avoid the extra overhead).
1383         qn = self.connection.ops.quote_name
1384         opts = self.query.get_meta()
1385         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
1386         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
1387         fields = self.query.fields or [opts.pk]
1388         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
1389 
1390         if self.query.fields:
1391             value_rows = [
1392                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
1393                 for obj in self.query.objs
1394             ]
1395         else:
1396             # An empty object.
1397             value_rows = [[self.connection.ops.pk_default_value()] for _ in self.query.objs]
1398             fields = [None]
1399 
1400         # Currently the backends just accept values when generating bulk
1401         # queries and generate their own placeholders. Doing that isn't
1402         # necessary and it should be possible to use placeholders and
1403         # expressions in bulk inserts too.
1404         can_bulk = (not self.returning_fields and self.connection.features.has_bulk_insert)
1405 
1406         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
1407 
1408         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
1409             ignore_conflicts=self.query.ignore_conflicts
1410         )
1411         if self.returning_fields and self.connection.features.can_return_columns_from_insert:
1412             if self.connection.features.can_return_rows_from_bulk_insert:
1413                 result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
1414                 params = param_rows
1415             else:
1416                 result.append("VALUES (%s)" % ", ".join(placeholder_rows[0]))
1417                 params = [param_rows[0]]
1418             if ignore_conflicts_suffix_sql:
1419                 result.append(ignore_conflicts_suffix_sql)
1420             # Skip empty r_sql to allow subclasses to customize behavior for
1421             # 3rd party backends. Refs #19096.
1422             r_sql, self.returning_params = self.connection.ops.return_insert_columns(self.returning_fields)
1423             if r_sql:
1424                 result.append(r_sql)
1425                 params += [self.returning_params]
1426             return [(" ".join(result), tuple(chain.from_iterable(params)))]
1427 
1428         if can_bulk:
1429             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
1430             if ignore_conflicts_suffix_sql:
1431                 result.append(ignore_conflicts_suffix_sql)
1432             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
1433         else:
1434             if ignore_conflicts_suffix_sql:
1435                 result.append(ignore_conflicts_suffix_sql)
1436             return [
1437                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
1438                 for p, vals in zip(placeholder_rows, param_rows)
1439             ]
1440 
1441     def execute_sql(self, returning_fields=None):
1442         assert not (
1443             returning_fields and len(self.query.objs) != 1 and
1444             not self.connection.features.can_return_rows_from_bulk_insert
1445         )
1446         opts = self.query.get_meta()
1447         self.returning_fields = returning_fields
1448         with self.connection.cursor() as cursor:
1449             for sql, params in self.as_sql():
1450                 cursor.execute(sql, params)
1451             if not self.returning_fields:
1452                 return []
1453             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
1454                 rows = self.connection.ops.fetch_returned_insert_rows(cursor)
1455             elif self.connection.features.can_return_columns_from_insert:
1456                 assert len(self.query.objs) == 1
1457                 rows = [self.connection.ops.fetch_returned_insert_columns(
1458                     cursor, self.returning_params,
1459                 )]
1460             else:
1461                 rows = [(self.connection.ops.last_insert_id(
1462                     cursor, opts.db_table, opts.pk.column,
1463                 ),)]
1464         cols = [field.get_col(opts.db_table) for field in self.returning_fields]
1465         converters = self.get_converters(cols)
1466         if converters:
1467             rows = list(self.apply_converters(rows, converters))
1468         return rows
1469 
1470 
1471 class SQLDeleteCompiler(SQLCompiler):
1472     @cached_property
1473     def single_alias(self):
1474         # Ensure base table is in aliases.
1475         self.query.get_initial_alias()
1476         return sum(self.query.alias_refcount[t] > 0 for t in self.query.alias_map) == 1
1477 
1478     @classmethod
1479     def _expr_refs_base_model(cls, expr, base_model):
1480         if isinstance(expr, Query):
1481             return expr.model == base_model
1482         if not hasattr(expr, 'get_source_expressions'):
1483             return False
1484         return any(
1485             cls._expr_refs_base_model(source_expr, base_model)
1486             for source_expr in expr.get_source_expressions()
1487         )
1488 
1489     @cached_property
1490     def contains_self_reference_subquery(self):
1491         return any(
1492             self._expr_refs_base_model(expr, self.query.model)
1493             for expr in chain(self.query.annotations.values(), self.query.where.children)
1494         )
1495 
1496     def _as_sql(self, query):
1497         result = [
1498             'DELETE FROM %s' % self.quote_name_unless_alias(query.base_table)
1499         ]
1500         where, params = self.compile(query.where)
1501         if where:
1502             result.append('WHERE %s' % where)
1503         return ' '.join(result), tuple(params)
1504 
1505     def as_sql(self):
1506         """
1507         Create the SQL for this query. Return the SQL string and list of
1508         parameters.
1509         """
1510         if self.single_alias and not self.contains_self_reference_subquery:
1511             return self._as_sql(self.query)
1512         innerq = self.query.clone()
1513         innerq.__class__ = Query
1514         innerq.clear_select_clause()
1515         pk = self.query.model._meta.pk
1516         innerq.select = [
1517             pk.get_col(self.query.get_initial_alias())
1518         ]
1519         outerq = Query(self.query.model)
1520         if not self.connection.features.update_can_self_select:
1521             # Force the materialization of the inner query to allow reference
1522             # to the target table on MySQL.
1523             sql, params = innerq.get_compiler(connection=self.connection).as_sql()
1524             innerq = RawSQL('SELECT * FROM (%s) subquery' % sql, params)
1525         outerq.add_filter('pk__in', innerq)
1526         return self._as_sql(outerq)
1527 
1528 
1529 class SQLUpdateCompiler(SQLCompiler):
1530     def as_sql(self):
1531         """
1532         Create the SQL for this query. Return the SQL string and list of
1533         parameters.
1534         """
1535         self.pre_sql_setup()
1536         if not self.query.values:
1537             return '', ()
1538         qn = self.quote_name_unless_alias
1539         values, update_params = [], []
1540         for field, model, val in self.query.values:
1541             if hasattr(val, 'resolve_expression'):
1542                 val = val.resolve_expression(self.query, allow_joins=False, for_save=True)
1543                 if val.contains_aggregate:
1544                     raise FieldError(
1545                         'Aggregate functions are not allowed in this query '
1546                         '(%s=%r).' % (field.name, val)
1547                     )
1548                 if val.contains_over_clause:
1549                     raise FieldError(
1550                         'Window expressions are not allowed in this query '
1551                         '(%s=%r).' % (field.name, val)
1552                     )
1553             elif hasattr(val, 'prepare_database_save'):
1554                 if field.remote_field:
1555                     val = field.get_db_prep_save(
1556                         val.prepare_database_save(field),
1557                         connection=self.connection,
1558                     )
1559                 else:
1560                     raise TypeError(
1561                         "Tried to update field %s with a model instance, %r. "
1562                         "Use a value compatible with %s."
1563                         % (field, val, field.__class__.__name__)
1564                     )
1565             else:
1566                 val = field.get_db_prep_save(val, connection=self.connection)
1567 
1568             # Getting the placeholder for the field.
1569             if hasattr(field, 'get_placeholder'):
1570                 placeholder = field.get_placeholder(val, self, self.connection)
1571             else:
1572                 placeholder = '%s'
1573             name = field.column
1574             if hasattr(val, 'as_sql'):
1575                 sql, params = self.compile(val)
1576                 values.append('%s = %s' % (qn(name), placeholder % sql))
1577                 update_params.extend(params)
1578             elif val is not None:
1579                 values.append('%s = %s' % (qn(name), placeholder))
1580                 update_params.append(val)
1581             else:
1582                 values.append('%s = NULL' % qn(name))
1583         table = self.query.base_table
1584         result = [
1585             'UPDATE %s SET' % qn(table),
1586             ', '.join(values),
1587         ]
1588         where, params = self.compile(self.query.where)
1589         if where:
1590             result.append('WHERE %s' % where)
1591         return ' '.join(result), tuple(update_params + params)
1592 
1593     def execute_sql(self, result_type):
1594         """
1595         Execute the specified update. Return the number of rows affected by
1596         the primary update query. The "primary update query" is the first
1597         non-empty query that is executed. Row counts for any subsequent,
1598         related queries are not available.
1599         """
1600         cursor = super().execute_sql(result_type)
1601         try:
1602             rows = cursor.rowcount if cursor else 0
1603             is_empty = cursor is None
1604         finally:
1605             if cursor:
1606                 cursor.close()
1607         for query in self.query.get_related_updates():
1608             aux_rows = query.get_compiler(self.using).execute_sql(result_type)
1609             if is_empty and aux_rows:
1610                 rows = aux_rows
1611                 is_empty = False
1612         return rows
1613 
1614     def pre_sql_setup(self):
1615         """
1616         If the update depends on results from other tables, munge the "where"
1617         conditions to match the format required for (portable) SQL updates.
1618 
1619         If multiple updates are required, pull out the id values to update at
1620         this point so that they don't change as a result of the progressive
1621         updates.
1622         """
1623         refcounts_before = self.query.alias_refcount.copy()
1624         # Ensure base table is in the query
1625         self.query.get_initial_alias()
1626         count = self.query.count_active_tables()
1627         if not self.query.related_updates and count == 1:
1628             return
1629         query = self.query.chain(klass=Query)
1630         query.select_related = False
1631         query.clear_ordering(force=True)
1632         query.extra = {}
1633         query.select = []
1634         query.add_fields([query.get_meta().pk.name])
1635         super().pre_sql_setup()
1636 
1637         must_pre_select = count > 1 and not self.connection.features.update_can_self_select
1638 
1639         # Now we adjust the current query: reset the where clause and get rid
1640         # of all the tables we don't need (since they're in the sub-select).
1641         self.query.clear_where()
1642         if self.query.related_updates or must_pre_select:
1643             # Either we're using the idents in multiple update queries (so
1644             # don't want them to change), or the db backend doesn't support
1645             # selecting from the updating table (e.g. MySQL).
1646             idents = []
1647             for rows in query.get_compiler(self.using).execute_sql(MULTI):
1648                 idents.extend(r[0] for r in rows)
1649             self.query.add_filter('pk__in', idents)
1650             self.query.related_ids = idents
1651         else:
1652             # The fast path. Filters and updates in one query.
1653             self.query.add_filter('pk__in', query)
1654         self.query.reset_refcounts(refcounts_before)
1655 
1656 
1657 class SQLAggregateCompiler(SQLCompiler):
1658     def as_sql(self):
1659         """
1660         Create the SQL for this query. Return the SQL string and list of
1661         parameters.
1662         """
1663         sql, params = [], []
1664         for annotation in self.query.annotation_select.values():
1665             ann_sql, ann_params = self.compile(annotation)
1666             ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)
1667             sql.append(ann_sql)
1668             params.extend(ann_params)
1669         self.col_count = len(self.query.annotation_select)
1670         sql = ', '.join(sql)
1671         params = tuple(params)
1672 
1673         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(
1674             self.using, elide_empty=self.elide_empty,
1675         ).as_sql(with_col_aliases=True)
1676         sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)
1677         params = params + inner_query_params
1678         return sql, params
1679 
1680 
1681 def cursor_iter(cursor, sentinel, col_count, itersize):
1682     """
1683     Yield blocks of rows from a cursor and ensure the cursor is closed when
1684     done.
1685     """
1686     try:
1687         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
1688             yield rows if col_count is None else [r[:col_count] for r in rows]
1689     finally:
1690         cursor.close()

</code><intended_behavior>The issue could stem from how combined queries (union or bitwise OR) are compiled when they include references to `OuterRef`. This file's method(s) responsible for compiling these queries needs to be reviewed for potential adjustments.</intended_behavior>]
2025-10-17 23:00:52.669 | INFO     | Search completed. Bug locations: [<file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import functools
4 import inspect
5 from decimal import Decimal
6 from uuid import UUID
7 
8 from django.core.exceptions import EmptyResultSet, FieldError
9 from django.db import DatabaseError, NotSupportedError, connection
10 from django.db.models import fields
11 from django.db.models.constants import LOOKUP_SEP
12 from django.db.models.query_utils import Q
13 from django.utils.deconstruct import deconstructible
14 from django.utils.functional import cached_property
15 from django.utils.hashable import make_hashable
16 
17 
18 class SQLiteNumericMixin:
19     """
20     Some expressions with output_field=DecimalField() must be cast to
21     numeric to be properly filtered.
22     """
23     def as_sqlite(self, compiler, connection, **extra_context):
24         sql, params = self.as_sql(compiler, connection, **extra_context)
25         try:
26             if self.output_field.get_internal_type() == 'DecimalField':
27                 sql = 'CAST(%s AS NUMERIC)' % sql
28         except FieldError:
29             pass
30         return sql, params
31 
32 
33 class Combinable:
34     """
35     Provide the ability to combine one or two objects with
36     some connector. For example F('foo') + F('bar').
37     """
38 
39     # Arithmetic connectors
40     ADD = '+'
41     SUB = '-'
42     MUL = '*'
43     DIV = '/'
44     POW = '^'
45     # The following is a quoted % operator - it is quoted because it can be
46     # used in strings that also have parameter substitution.
47     MOD = '%%'
48 
49     # Bitwise operators - note that these are generated by .bitand()
50     # and .bitor(), the '&' and '|' are reserved for boolean operator
51     # usage.
52     BITAND = '&'
53     BITOR = '|'
54     BITLEFTSHIFT = '<<'
55     BITRIGHTSHIFT = '>>'
56     BITXOR = '#'
57 
58     def _combine(self, other, connector, reversed):
59         if not hasattr(other, 'resolve_expression'):
60             # everything must be resolvable to an expression
61             other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def bitxor(self, other):
109         return self._combine(other, self.BITXOR, False)
110 
111     def __or__(self, other):
112         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
113             return Q(self) | Q(other)
114         raise NotImplementedError(
115             "Use .bitand() and .bitor() for bitwise logical operations."
116         )
117 
118     def bitor(self, other):
119         return self._combine(other, self.BITOR, False)
120 
121     def __radd__(self, other):
122         return self._combine(other, self.ADD, True)
123 
124     def __rsub__(self, other):
125         return self._combine(other, self.SUB, True)
126 
127     def __rmul__(self, other):
128         return self._combine(other, self.MUL, True)
129 
130     def __rtruediv__(self, other):
131         return self._combine(other, self.DIV, True)
132 
133     def __rmod__(self, other):
134         return self._combine(other, self.MOD, True)
135 
136     def __rpow__(self, other):
137         return self._combine(other, self.POW, True)
138 
139     def __rand__(self, other):
140         raise NotImplementedError(
141             "Use .bitand() and .bitor() for bitwise logical operations."
142         )
143 
144     def __ror__(self, other):
145         raise NotImplementedError(
146             "Use .bitand() and .bitor() for bitwise logical operations."
147         )
148 
149 
150 class BaseExpression:
151     """Base class for all query expressions."""
152 
153     empty_result_set_value = NotImplemented
154     # aggregate specific fields
155     is_summary = False
156     _output_field_resolved_to_none = False
157     # Can the expression be used in a WHERE clause?
158     filterable = True
159     # Can the expression can be used as a source expression in Window?
160     window_compatible = False
161 
162     def __init__(self, output_field=None):
163         if output_field is not None:
164             self.output_field = output_field
165 
166     def __getstate__(self):
167         state = self.__dict__.copy()
168         state.pop('convert_value', None)
169         return state
170 
171     def get_db_converters(self, connection):
172         return (
173             []
174             if self.convert_value is self._convert_value_noop else
175             [self.convert_value]
176         ) + self.output_field.get_db_converters(connection)
177 
178     def get_source_expressions(self):
179         return []
180 
181     def set_source_expressions(self, exprs):
182         assert not exprs
183 
184     def _parse_expressions(self, *expressions):
185         return [
186             arg if hasattr(arg, 'resolve_expression') else (
187                 F(arg) if isinstance(arg, str) else Value(arg)
188             ) for arg in expressions
189         ]
190 
191     def as_sql(self, compiler, connection):
192         """
193         Responsible for returning a (sql, [params]) tuple to be included
194         in the current query.
195 
196         Different backends can provide their own implementation, by
197         providing an `as_{vendor}` method and patching the Expression:
198 
199         ```
200         def override_as_sql(self, compiler, connection):
201             # custom logic
202             return super().as_sql(compiler, connection)
203         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
204         ```
205 
206         Arguments:
207          * compiler: the query compiler responsible for generating the query.
208            Must have a compile method, returning a (sql, [params]) tuple.
209            Calling compiler(value) will return a quoted `value`.
210 
211          * connection: the database connection used for the current query.
212 
213         Return: (sql, params)
214           Where `sql` is a string containing ordered sql parameters to be
215           replaced with the elements of the list `params`.
216         """
217         raise NotImplementedError("Subclasses must implement as_sql()")
218 
219     @cached_property
220     def contains_aggregate(self):
221         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
222 
223     @cached_property
224     def contains_over_clause(self):
225         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
226 
227     @cached_property
228     def contains_column_references(self):
229         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
230 
231     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
232         """
233         Provide the chance to do any preprocessing or validation before being
234         added to the query.
235 
236         Arguments:
237          * query: the backend query implementation
238          * allow_joins: boolean allowing or denying use of joins
239            in this query
240          * reuse: a set of reusable joins for multijoins
241          * summarize: a terminal aggregate clause
242          * for_save: whether this expression about to be used in a save or update
243 
244         Return: an Expression to be added to the query.
245         """
246         c = self.copy()
247         c.is_summary = summarize
248         c.set_source_expressions([
249             expr.resolve_expression(query, allow_joins, reuse, summarize)
250             if expr else None
251             for expr in c.get_source_expressions()
252         ])
253         return c
254 
255     @property
256     def conditional(self):
257         return isinstance(self.output_field, fields.BooleanField)
258 
259     @property
260     def field(self):
261         return self.output_field
262 
263     @cached_property
264     def output_field(self):
265         """Return the output type of this expressions."""
266         output_field = self._resolve_output_field()
267         if output_field is None:
268             self._output_field_resolved_to_none = True
269             raise FieldError('Cannot resolve expression type, unknown output_field')
270         return output_field
271 
272     @cached_property
273     def _output_field_or_none(self):
274         """
275         Return the output field of this expression, or None if
276         _resolve_output_field() didn't return an output type.
277         """
278         try:
279             return self.output_field
280         except FieldError:
281             if not self._output_field_resolved_to_none:
282                 raise
283 
284     def _resolve_output_field(self):
285         """
286         Attempt to infer the output type of the expression. If the output
287         fields of all source fields match then, simply infer the same type
288         here. This isn't always correct, but it makes sense most of the time.
289 
290         Consider the difference between `2 + 2` and `2 / 3`. Inferring
291         the type here is a convenience for the common case. The user should
292         supply their own output_field with more complex computations.
293 
294         If a source's output field resolves to None, exclude it from this check.
295         If all sources are None, then an error is raised higher up the stack in
296         the output_field property.
297         """
298         sources_iter = (source for source in self.get_source_fields() if source is not None)
299         for output_field in sources_iter:
300             for source in sources_iter:
301                 if not isinstance(output_field, source.__class__):
302                     raise FieldError(
303                         'Expression contains mixed types: %s, %s. You must '
304                         'set output_field.' % (
305                             output_field.__class__.__name__,
306                             source.__class__.__name__,
307                         )
308                     )
309             return output_field
310 
311     @staticmethod
312     def _convert_value_noop(value, expression, connection):
313         return value
314 
315     @cached_property
316     def convert_value(self):
317         """
318         Expressions provide their own converters because users have the option
319         of manually specifying the output_field which may be a different type
320         from the one the database returns.
321         """
322         field = self.output_field
323         internal_type = field.get_internal_type()
324         if internal_type == 'FloatField':
325             return lambda value, expression, connection: None if value is None else float(value)
326         elif internal_type.endswith('IntegerField'):
327             return lambda value, expression, connection: None if value is None else int(value)
328         elif internal_type == 'DecimalField':
329             return lambda value, expression, connection: None if value is None else Decimal(value)
330         return self._convert_value_noop
331 
332     def get_lookup(self, lookup):
333         return self.output_field.get_lookup(lookup)
334 
335     def get_transform(self, name):
336         return self.output_field.get_transform(name)
337 
338     def relabeled_clone(self, change_map):
339         clone = self.copy()
340         clone.set_source_expressions([
341             e.relabeled_clone(change_map) if e is not None else None
342             for e in self.get_source_expressions()
343         ])
344         return clone
345 
346     def copy(self):
347         return copy.copy(self)
348 
349     def get_group_by_cols(self, alias=None):
350         if not self.contains_aggregate:
351             return [self]
352         cols = []
353         for source in self.get_source_expressions():
354             cols.extend(source.get_group_by_cols())
355         return cols
356 
357     def get_source_fields(self):
358         """Return the underlying field types used by this aggregate."""
359         return [e._output_field_or_none for e in self.get_source_expressions()]
360 
361     def asc(self, **kwargs):
362         return OrderBy(self, **kwargs)
363 
364     def desc(self, **kwargs):
365         return OrderBy(self, descending=True, **kwargs)
366 
367     def reverse_ordering(self):
368         return self
369 
370     def flatten(self):
371         """
372         Recursively yield this expression and all subexpressions, in
373         depth-first order.
374         """
375         yield self
376         for expr in self.get_source_expressions():
377             if expr:
378                 if hasattr(expr, 'flatten'):
379                     yield from expr.flatten()
380                 else:
381                     yield expr
382 
383     def select_format(self, compiler, sql, params):
384         """
385         Custom format for select clauses. For example, EXISTS expressions need
386         to be wrapped in CASE WHEN on Oracle.
387         """
388         if hasattr(self.output_field, 'select_format'):
389             return self.output_field.select_format(compiler, sql, params)
390         return sql, params
391 
392 
393 @deconstructible
394 class Expression(BaseExpression, Combinable):
395     """An expression that can be combined with other expressions."""
396 
397     @cached_property
398     def identity(self):
399         constructor_signature = inspect.signature(self.__init__)
400         args, kwargs = self._constructor_args
401         signature = constructor_signature.bind_partial(*args, **kwargs)
402         signature.apply_defaults()
403         arguments = signature.arguments.items()
404         identity = [self.__class__]
405         for arg, value in arguments:
406             if isinstance(value, fields.Field):
407                 if value.name and value.model:
408                     value = (value.model._meta.label, value.name)
409                 else:
410                     value = type(value)
411             else:
412                 value = make_hashable(value)
413             identity.append((arg, value))
414         return tuple(identity)
415 
416     def __eq__(self, other):
417         if not isinstance(other, Expression):
418             return NotImplemented
419         return other.identity == self.identity
420 
421     def __hash__(self):
422         return hash(self.identity)
423 
424 
425 _connector_combinators = {
426     connector: [
427         (fields.IntegerField, fields.IntegerField, fields.IntegerField),
428         (fields.IntegerField, fields.DecimalField, fields.DecimalField),
429         (fields.DecimalField, fields.IntegerField, fields.DecimalField),
430         (fields.IntegerField, fields.FloatField, fields.FloatField),
431         (fields.FloatField, fields.IntegerField, fields.FloatField),
432     ]
433     for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)
434 }
435 
436 
437 @functools.lru_cache(maxsize=128)
438 def _resolve_combined_type(connector, lhs_type, rhs_type):
439     combinators = _connector_combinators.get(connector, ())
440     for combinator_lhs_type, combinator_rhs_type, combined_type in combinators:
441         if issubclass(lhs_type, combinator_lhs_type) and issubclass(rhs_type, combinator_rhs_type):
442             return combined_type
443 
444 
445 class CombinedExpression(SQLiteNumericMixin, Expression):
446 
447     def __init__(self, lhs, connector, rhs, output_field=None):
448         super().__init__(output_field=output_field)
449         self.connector = connector
450         self.lhs = lhs
451         self.rhs = rhs
452 
453     def __repr__(self):
454         return "<{}: {}>".format(self.__class__.__name__, self)
455 
456     def __str__(self):
457         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
458 
459     def get_source_expressions(self):
460         return [self.lhs, self.rhs]
461 
462     def set_source_expressions(self, exprs):
463         self.lhs, self.rhs = exprs
464 
465     def _resolve_output_field(self):
466         try:
467             return super()._resolve_output_field()
468         except FieldError:
469             combined_type = _resolve_combined_type(
470                 self.connector,
471                 type(self.lhs.output_field),
472                 type(self.rhs.output_field),
473             )
474             if combined_type is None:
475                 raise
476             return combined_type()
477 
478     def as_sql(self, compiler, connection):
479         expressions = []
480         expression_params = []
481         sql, params = compiler.compile(self.lhs)
482         expressions.append(sql)
483         expression_params.extend(params)
484         sql, params = compiler.compile(self.rhs)
485         expressions.append(sql)
486         expression_params.extend(params)
487         # order of precedence
488         expression_wrapper = '(%s)'
489         sql = connection.ops.combine_expression(self.connector, expressions)
490         return expression_wrapper % sql, expression_params
491 
492     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
493         lhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
494         rhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
495         if not isinstance(self, (DurationExpression, TemporalSubtraction)):
496             try:
497                 lhs_type = lhs.output_field.get_internal_type()
498             except (AttributeError, FieldError):
499                 lhs_type = None
500             try:
501                 rhs_type = rhs.output_field.get_internal_type()
502             except (AttributeError, FieldError):
503                 rhs_type = None
504             if 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:
505                 return DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(
506                     query, allow_joins, reuse, summarize, for_save,
507                 )
508             datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}
509             if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:
510                 return TemporalSubtraction(self.lhs, self.rhs).resolve_expression(
511                     query, allow_joins, reuse, summarize, for_save,
512                 )
513         c = self.copy()
514         c.is_summary = summarize
515         c.lhs = lhs
516         c.rhs = rhs
517         return c
518 
519 
520 class DurationExpression(CombinedExpression):
521     def compile(self, side, compiler, connection):
522         try:
523             output = side.output_field
524         except FieldError:
525             pass
526         else:
527             if output.get_internal_type() == 'DurationField':
528                 sql, params = compiler.compile(side)
529                 return connection.ops.format_for_duration_arithmetic(sql), params
530         return compiler.compile(side)
531 
532     def as_sql(self, compiler, connection):
533         if connection.features.has_native_duration_field:
534             return super().as_sql(compiler, connection)
535         connection.ops.check_expression_support(self)
536         expressions = []
537         expression_params = []
538         sql, params = self.compile(self.lhs, compiler, connection)
539         expressions.append(sql)
540         expression_params.extend(params)
541         sql, params = self.compile(self.rhs, compiler, connection)
542         expressions.append(sql)
543         expression_params.extend(params)
544         # order of precedence
545         expression_wrapper = '(%s)'
546         sql = connection.ops.combine_duration_expression(self.connector, expressions)
547         return expression_wrapper % sql, expression_params
548 
549     def as_sqlite(self, compiler, connection, **extra_context):
550         sql, params = self.as_sql(compiler, connection, **extra_context)
551         if self.connector in {Combinable.MUL, Combinable.DIV}:
552             try:
553                 lhs_type = self.lhs.output_field.get_internal_type()
554                 rhs_type = self.rhs.output_field.get_internal_type()
555             except (AttributeError, FieldError):
556                 pass
557             else:
558                 allowed_fields = {
559                     'DecimalField', 'DurationField', 'FloatField', 'IntegerField',
560                 }
561                 if lhs_type not in allowed_fields or rhs_type not in allowed_fields:
562                     raise DatabaseError(
563                         f'Invalid arguments for operator {self.connector}.'
564                     )
565         return sql, params
566 
567 
568 class TemporalSubtraction(CombinedExpression):
569     output_field = fields.DurationField()
570 
571     def __init__(self, lhs, rhs):
572         super().__init__(lhs, self.SUB, rhs)
573 
574     def as_sql(self, compiler, connection):
575         connection.ops.check_expression_support(self)
576         lhs = compiler.compile(self.lhs)
577         rhs = compiler.compile(self.rhs)
578         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
579 
580 
581 @deconstructible(path='django.db.models.F')
582 class F(Combinable):
583     """An object capable of resolving references to existing query objects."""
584 
585     def __init__(self, name):
586         """
587         Arguments:
588          * name: the name of the field this expression references
589         """
590         self.name = name
591 
592     def __repr__(self):
593         return "{}({})".format(self.__class__.__name__, self.name)
594 
595     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
596                            summarize=False, for_save=False):
597         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
598 
599     def asc(self, **kwargs):
600         return OrderBy(self, **kwargs)
601 
602     def desc(self, **kwargs):
603         return OrderBy(self, descending=True, **kwargs)
604 
605     def __eq__(self, other):
606         return self.__class__ == other.__class__ and self.name == other.name
607 
608     def __hash__(self):
609         return hash(self.name)
610 
611 
612 class ResolvedOuterRef(F):
613     """
614     An object that contains a reference to an outer query.
615 
616     In this case, the reference to the outer query has been resolved because
617     the inner query has been used as a subquery.
618     """
619     contains_aggregate = False
620 
621     def as_sql(self, *args, **kwargs):
622         raise ValueError(
623             'This queryset contains a reference to an outer query and may '
624             'only be used in a subquery.'
625         )
626 
627     def resolve_expression(self, *args, **kwargs):
628         col = super().resolve_expression(*args, **kwargs)
629         # FIXME: Rename possibly_multivalued to multivalued and fix detection
630         # for non-multivalued JOINs (e.g. foreign key fields). This should take
631         # into account only many-to-many and one-to-many relationships.
632         col.possibly_multivalued = LOOKUP_SEP in self.name
633         return col
634 
635     def relabeled_clone(self, relabels):
636         return self
637 
638     def get_group_by_cols(self, alias=None):
639         return []
640 
641 
642 class OuterRef(F):
643     contains_aggregate = False
644 
645     def resolve_expression(self, *args, **kwargs):
646         if isinstance(self.name, self.__class__):
647             return self.name
648         return ResolvedOuterRef(self.name)
649 
650     def relabeled_clone(self, relabels):
651         return self
652 
653 
654 @deconstructible(path='django.db.models.Func')
655 class Func(SQLiteNumericMixin, Expression):
656     """An SQL function call."""
657     function = None
658     template = '%(function)s(%(expressions)s)'
659     arg_joiner = ', '
660     arity = None  # The number of arguments the function accepts.
661 
662     def __init__(self, *expressions, output_field=None, **extra):
663         if self.arity is not None and len(expressions) != self.arity:
664             raise TypeError(
665                 "'%s' takes exactly %s %s (%s given)" % (
666                     self.__class__.__name__,
667                     self.arity,
668                     "argument" if self.arity == 1 else "arguments",
669                     len(expressions),
670                 )
671             )
672         super().__init__(output_field=output_field)
673         self.source_expressions = self._parse_expressions(*expressions)
674         self.extra = extra
675 
676     def __repr__(self):
677         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
678         extra = {**self.extra, **self._get_repr_options()}
679         if extra:
680             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
681             return "{}({}, {})".format(self.__class__.__name__, args, extra)
682         return "{}({})".format(self.__class__.__name__, args)
683 
684     def _get_repr_options(self):
685         """Return a dict of extra __init__() options to include in the repr."""
686         return {}
687 
688     def get_source_expressions(self):
689         return self.source_expressions
690 
691     def set_source_expressions(self, exprs):
692         self.source_expressions = exprs
693 
694     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
695         c = self.copy()
696         c.is_summary = summarize
697         for pos, arg in enumerate(c.source_expressions):
698             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
699         return c
700 
701     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
702         connection.ops.check_expression_support(self)
703         sql_parts = []
704         params = []
705         for arg in self.source_expressions:
706             try:
707                 arg_sql, arg_params = compiler.compile(arg)
708             except EmptyResultSet:
709                 empty_result_set_value = getattr(arg, 'empty_result_set_value', NotImplemented)
710                 if empty_result_set_value is NotImplemented:
711                     raise
712                 arg_sql, arg_params = compiler.compile(Value(empty_result_set_value))
713             sql_parts.append(arg_sql)
714             params.extend(arg_params)
715         data = {**self.extra, **extra_context}
716         # Use the first supplied value in this order: the parameter to this
717         # method, a value supplied in __init__()'s **extra (the value in
718         # `data`), or the value defined on the class.
719         if function is not None:
720             data['function'] = function
721         else:
722             data.setdefault('function', self.function)
723         template = template or data.get('template', self.template)
724         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
725         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
726         return template % data, params
727 
728     def copy(self):
729         copy = super().copy()
730         copy.source_expressions = self.source_expressions[:]
731         copy.extra = self.extra.copy()
732         return copy
733 
734 
735 @deconstructible(path='django.db.models.Value')
736 class Value(SQLiteNumericMixin, Expression):
737     """Represent a wrapped value as a node within an expression."""
738     # Provide a default value for `for_save` in order to allow unresolved
739     # instances to be compiled until a decision is taken in #25425.
740     for_save = False
741 
742     def __init__(self, value, output_field=None):
743         """
744         Arguments:
745          * value: the value this expression represents. The value will be
746            added into the sql parameter list and properly quoted.
747 
748          * output_field: an instance of the model field type that this
749            expression will return, such as IntegerField() or CharField().
750         """
751         super().__init__(output_field=output_field)
752         self.value = value
753 
754     def __repr__(self):
755         return f'{self.__class__.__name__}({self.value!r})'
756 
757     def as_sql(self, compiler, connection):
758         connection.ops.check_expression_support(self)
759         val = self.value
760         output_field = self._output_field_or_none
761         if output_field is not None:
762             if self.for_save:
763                 val = output_field.get_db_prep_save(val, connection=connection)
764             else:
765                 val = output_field.get_db_prep_value(val, connection=connection)
766             if hasattr(output_field, 'get_placeholder'):
767                 return output_field.get_placeholder(val, compiler, connection), [val]
768         if val is None:
769             # cx_Oracle does not always convert None to the appropriate
770             # NULL type (like in case expressions using numbers), so we
771             # use a literal SQL NULL
772             return 'NULL', []
773         return '%s', [val]
774 
775     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
776         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
777         c.for_save = for_save
778         return c
779 
780     def get_group_by_cols(self, alias=None):
781         return []
782 
783     def _resolve_output_field(self):
784         if isinstance(self.value, str):
785             return fields.CharField()
786         if isinstance(self.value, bool):
787             return fields.BooleanField()
788         if isinstance(self.value, int):
789             return fields.IntegerField()
790         if isinstance(self.value, float):
791             return fields.FloatField()
792         if isinstance(self.value, datetime.datetime):
793             return fields.DateTimeField()
794         if isinstance(self.value, datetime.date):
795             return fields.DateField()
796         if isinstance(self.value, datetime.time):
797             return fields.TimeField()
798         if isinstance(self.value, datetime.timedelta):
799             return fields.DurationField()
800         if isinstance(self.value, Decimal):
801             return fields.DecimalField()
802         if isinstance(self.value, bytes):
803             return fields.BinaryField()
804         if isinstance(self.value, UUID):
805             return fields.UUIDField()
806 
807     @property
808     def empty_result_set_value(self):
809         return self.value
810 
811 
812 class RawSQL(Expression):
813     def __init__(self, sql, params, output_field=None):
814         if output_field is None:
815             output_field = fields.Field()
816         self.sql, self.params = sql, params
817         super().__init__(output_field=output_field)
818 
819     def __repr__(self):
820         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
821 
822     def as_sql(self, compiler, connection):
823         return '(%s)' % self.sql, self.params
824 
825     def get_group_by_cols(self, alias=None):
826         return [self]
827 
828     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
829         # Resolve parents fields used in raw SQL.
830         for parent in query.model._meta.get_parent_list():
831             for parent_field in parent._meta.local_fields:
832                 _, column_name = parent_field.get_attname_column()
833                 if column_name.lower() in self.sql.lower():
834                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
835                     break
836         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
837 
838 
839 class Star(Expression):
840     def __repr__(self):
841         return "'*'"
842 
843     def as_sql(self, compiler, connection):
844         return '*', []
845 
846 
847 class Col(Expression):
848 
849     contains_column_references = True
850     possibly_multivalued = False
851 
852     def __init__(self, alias, target, output_field=None):
853         if output_field is None:
854             output_field = target
855         super().__init__(output_field=output_field)
856         self.alias, self.target = alias, target
857 
858     def __repr__(self):
859         alias, target = self.alias, self.target
860         identifiers = (alias, str(target)) if alias else (str(target),)
861         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
862 
863     def as_sql(self, compiler, connection):
864         alias, column = self.alias, self.target.column
865         identifiers = (alias, column) if alias else (column,)
866         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
867         return sql, []
868 
869     def relabeled_clone(self, relabels):
870         if self.alias is None:
871             return self
872         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
873 
874     def get_group_by_cols(self, alias=None):
875         return [self]
876 
877     def get_db_converters(self, connection):
878         if self.target == self.output_field:
879             return self.output_field.get_db_converters(connection)
880         return (self.output_field.get_db_converters(connection) +
881                 self.target.get_db_converters(connection))
882 
883 
884 class Ref(Expression):
885     """
886     Reference to column alias of the query. For example, Ref('sum_cost') in
887     qs.annotate(sum_cost=Sum('cost')) query.
888     """
889     def __init__(self, refs, source):
890         super().__init__()
891         self.refs, self.source = refs, source
892 
893     def __repr__(self):
894         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
895 
896     def get_source_expressions(self):
897         return [self.source]
898 
899     def set_source_expressions(self, exprs):
900         self.source, = exprs
901 
902     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
903         # The sub-expression `source` has already been resolved, as this is
904         # just a reference to the name of `source`.
905         return self
906 
907     def relabeled_clone(self, relabels):
908         return self
909 
910     def as_sql(self, compiler, connection):
911         return connection.ops.quote_name(self.refs), []
912 
913     def get_group_by_cols(self, alias=None):
914         return [self]
915 
916 
917 class ExpressionList(Func):
918     """
919     An expression containing multiple expressions. Can be used to provide a
920     list of expressions as an argument to another expression, like a partition
921     clause.
922     """
923     template = '%(expressions)s'
924 
925     def __init__(self, *expressions, **extra):
926         if not expressions:
927             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
928         super().__init__(*expressions, **extra)
929 
930     def __str__(self):
931         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
932 
933     def as_sqlite(self, compiler, connection, **extra_context):
934         # Casting to numeric is unnecessary.
935         return self.as_sql(compiler, connection, **extra_context)
936 
937 
938 class OrderByList(Func):
939     template = 'ORDER BY %(expressions)s'
940 
941     def __init__(self, *expressions, **extra):
942         expressions = (
943             (
944                 OrderBy(F(expr[1:]), descending=True)
945                 if isinstance(expr, str) and expr[0] == '-'
946                 else expr
947             )
948             for expr in expressions
949         )
950         super().__init__(*expressions, **extra)
951 
952     def as_sql(self, *args, **kwargs):
953         if not self.source_expressions:
954             return '', ()
955         return super().as_sql(*args, **kwargs)
956 
957 
958 @deconstructible(path='django.db.models.ExpressionWrapper')
959 class ExpressionWrapper(SQLiteNumericMixin, Expression):
960     """
961     An expression that can wrap another expression so that it can provide
962     extra context to the inner expression, such as the output_field.
963     """
964 
965     def __init__(self, expression, output_field):
966         super().__init__(output_field=output_field)
967         self.expression = expression
968 
969     def set_source_expressions(self, exprs):
970         self.expression = exprs[0]
971 
972     def get_source_expressions(self):
973         return [self.expression]
974 
975     def get_group_by_cols(self, alias=None):
976         if isinstance(self.expression, Expression):
977             expression = self.expression.copy()
978             expression.output_field = self.output_field
979             return expression.get_group_by_cols(alias=alias)
980         # For non-expressions e.g. an SQL WHERE clause, the entire
981         # `expression` must be included in the GROUP BY clause.
982         return super().get_group_by_cols()
983 
984     def as_sql(self, compiler, connection):
985         return compiler.compile(self.expression)
986 
987     def __repr__(self):
988         return "{}({})".format(self.__class__.__name__, self.expression)
989 
990 
991 @deconstructible(path='django.db.models.When')
992 class When(Expression):
993     template = 'WHEN %(condition)s THEN %(result)s'
994     # This isn't a complete conditional expression, must be used in Case().
995     conditional = False
996 
997     def __init__(self, condition=None, then=None, **lookups):
998         if lookups:
999             if condition is None:
1000                 condition, lookups = Q(**lookups), None
1001             elif getattr(condition, 'conditional', False):
1002                 condition, lookups = Q(condition, **lookups), None
1003         if condition is None or not getattr(condition, 'conditional', False) or lookups:
1004             raise TypeError(
1005                 'When() supports a Q object, a boolean expression, or lookups '
1006                 'as a condition.'
1007             )
1008         if isinstance(condition, Q) and not condition:
1009             raise ValueError("An empty Q() can't be used as a When() condition.")
1010         super().__init__(output_field=None)
1011         self.condition = condition
1012         self.result = self._parse_expressions(then)[0]
1013 
1014     def __str__(self):
1015         return "WHEN %r THEN %r" % (self.condition, self.result)
1016 
1017     def __repr__(self):
1018         return "<%s: %s>" % (self.__class__.__name__, self)
1019 
1020     def get_source_expressions(self):
1021         return [self.condition, self.result]
1022 
1023     def set_source_expressions(self, exprs):
1024         self.condition, self.result = exprs
1025 
1026     def get_source_fields(self):
1027         # We're only interested in the fields of the result expressions.
1028         return [self.result._output_field_or_none]
1029 
1030     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1031         c = self.copy()
1032         c.is_summary = summarize
1033         if hasattr(c.condition, 'resolve_expression'):
1034             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
1035         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1036         return c
1037 
1038     def as_sql(self, compiler, connection, template=None, **extra_context):
1039         connection.ops.check_expression_support(self)
1040         template_params = extra_context
1041         sql_params = []
1042         condition_sql, condition_params = compiler.compile(self.condition)
1043         template_params['condition'] = condition_sql
1044         sql_params.extend(condition_params)
1045         result_sql, result_params = compiler.compile(self.result)
1046         template_params['result'] = result_sql
1047         sql_params.extend(result_params)
1048         template = template or self.template
1049         return template % template_params, sql_params
1050 
1051     def get_group_by_cols(self, alias=None):
1052         # This is not a complete expression and cannot be used in GROUP BY.
1053         cols = []
1054         for source in self.get_source_expressions():
1055             cols.extend(source.get_group_by_cols())
1056         return cols
1057 
1058 
1059 @deconstructible(path='django.db.models.Case')
1060 class Case(SQLiteNumericMixin, Expression):
1061     """
1062     An SQL searched CASE expression:
1063 
1064         CASE
1065             WHEN n > 0
1066                 THEN 'positive'
1067             WHEN n < 0
1068                 THEN 'negative'
1069             ELSE 'zero'
1070         END
1071     """
1072     template = 'CASE %(cases)s ELSE %(default)s END'
1073     case_joiner = ' '
1074 
1075     def __init__(self, *cases, default=None, output_field=None, **extra):
1076         if not all(isinstance(case, When) for case in cases):
1077             raise TypeError("Positional arguments must all be When objects.")
1078         super().__init__(output_field)
1079         self.cases = list(cases)
1080         self.default = self._parse_expressions(default)[0]
1081         self.extra = extra
1082 
1083     def __str__(self):
1084         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
1085 
1086     def __repr__(self):
1087         return "<%s: %s>" % (self.__class__.__name__, self)
1088 
1089     def get_source_expressions(self):
1090         return self.cases + [self.default]
1091 
1092     def set_source_expressions(self, exprs):
1093         *self.cases, self.default = exprs
1094 
1095     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1096         c = self.copy()
1097         c.is_summary = summarize
1098         for pos, case in enumerate(c.cases):
1099             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1100         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1101         return c
1102 
1103     def copy(self):
1104         c = super().copy()
1105         c.cases = c.cases[:]
1106         return c
1107 
1108     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
1109         connection.ops.check_expression_support(self)
1110         if not self.cases:
1111             return compiler.compile(self.default)
1112         template_params = {**self.extra, **extra_context}
1113         case_parts = []
1114         sql_params = []
1115         for case in self.cases:
1116             try:
1117                 case_sql, case_params = compiler.compile(case)
1118             except EmptyResultSet:
1119                 continue
1120             case_parts.append(case_sql)
1121             sql_params.extend(case_params)
1122         default_sql, default_params = compiler.compile(self.default)
1123         if not case_parts:
1124             return default_sql, default_params
1125         case_joiner = case_joiner or self.case_joiner
1126         template_params['cases'] = case_joiner.join(case_parts)
1127         template_params['default'] = default_sql
1128         sql_params.extend(default_params)
1129         template = template or template_params.get('template', self.template)
1130         sql = template % template_params
1131         if self._output_field_or_none is not None:
1132             sql = connection.ops.unification_cast_sql(self.output_field) % sql
1133         return sql, sql_params
1134 
1135     def get_group_by_cols(self, alias=None):
1136         if not self.cases:
1137             return self.default.get_group_by_cols(alias)
1138         return super().get_group_by_cols(alias)
1139 
1140 
1141 class Subquery(BaseExpression, Combinable):
1142     """
1143     An explicit subquery. It may contain OuterRef() references to the outer
1144     query which will be resolved when it is applied to that query.
1145     """
1146     template = '(%(subquery)s)'
1147     contains_aggregate = False
1148     empty_result_set_value = None
1149 
1150     def __init__(self, queryset, output_field=None, **extra):
1151         # Allow the usage of both QuerySet and sql.Query objects.
1152         self.query = getattr(queryset, 'query', queryset).clone()
1153         self.query.subquery = True
1154         self.extra = extra
1155         super().__init__(output_field)
1156 
1157     def get_source_expressions(self):
1158         return [self.query]
1159 
1160     def set_source_expressions(self, exprs):
1161         self.query = exprs[0]
1162 
1163     def _resolve_output_field(self):
1164         return self.query.output_field
1165 
1166     def copy(self):
1167         clone = super().copy()
1168         clone.query = clone.query.clone()
1169         return clone
1170 
1171     @property
1172     def external_aliases(self):
1173         return self.query.external_aliases
1174 
1175     def get_external_cols(self):
1176         return self.query.get_external_cols()
1177 
1178     def as_sql(self, compiler, connection, template=None, query=None, **extra_context):
1179         connection.ops.check_expression_support(self)
1180         template_params = {**self.extra, **extra_context}
1181         query = query or self.query
1182         subquery_sql, sql_params = query.as_sql(compiler, connection)
1183         template_params['subquery'] = subquery_sql[1:-1]
1184 
1185         template = template or template_params.get('template', self.template)
1186         sql = template % template_params
1187         return sql, sql_params
1188 
1189     def get_group_by_cols(self, alias=None):
1190         # If this expression is referenced by an alias for an explicit GROUP BY
1191         # through values() a reference to this expression and not the
1192         # underlying .query must be returned to ensure external column
1193         # references are not grouped against as well.
1194         if alias:
1195             return [Ref(alias, self)]
1196         return self.query.get_group_by_cols()
1197 
1198 
1199 class Exists(Subquery):
1200     template = 'EXISTS(%(subquery)s)'
1201     output_field = fields.BooleanField()
1202 
1203     def __init__(self, queryset, negated=False, **kwargs):
1204         self.negated = negated
1205         super().__init__(queryset, **kwargs)
1206 
1207     def __invert__(self):
1208         clone = self.copy()
1209         clone.negated = not self.negated
1210         return clone
1211 
1212     def as_sql(self, compiler, connection, template=None, **extra_context):
1213         query = self.query.exists(using=connection.alias)
1214         sql, params = super().as_sql(
1215             compiler,
1216             connection,
1217             template=template,
1218             query=query,
1219             **extra_context,
1220         )
1221         if self.negated:
1222             sql = 'NOT {}'.format(sql)
1223         return sql, params
1224 
1225     def select_format(self, compiler, sql, params):
1226         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1227         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP
1228         # BY list.
1229         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1230             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1231         return sql, params
1232 
1233 
1234 @deconstructible(path='django.db.models.OrderBy')
1235 class OrderBy(Expression):
1236     template = '%(expression)s %(ordering)s'
1237     conditional = False
1238 
1239     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1240         if nulls_first and nulls_last:
1241             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1242         self.nulls_first = nulls_first
1243         self.nulls_last = nulls_last
1244         self.descending = descending
1245         if not hasattr(expression, 'resolve_expression'):
1246             raise ValueError('expression must be an expression type')
1247         self.expression = expression
1248 
1249     def __repr__(self):
1250         return "{}({}, descending={})".format(
1251             self.__class__.__name__, self.expression, self.descending)
1252 
1253     def set_source_expressions(self, exprs):
1254         self.expression = exprs[0]
1255 
1256     def get_source_expressions(self):
1257         return [self.expression]
1258 
1259     def as_sql(self, compiler, connection, template=None, **extra_context):
1260         template = template or self.template
1261         if connection.features.supports_order_by_nulls_modifier:
1262             if self.nulls_last:
1263                 template = '%s NULLS LAST' % template
1264             elif self.nulls_first:
1265                 template = '%s NULLS FIRST' % template
1266         else:
1267             if self.nulls_last and not (
1268                 self.descending and connection.features.order_by_nulls_first
1269             ):
1270                 template = '%%(expression)s IS NULL, %s' % template
1271             elif self.nulls_first and not (
1272                 not self.descending and connection.features.order_by_nulls_first
1273             ):
1274                 template = '%%(expression)s IS NOT NULL, %s' % template
1275         connection.ops.check_expression_support(self)
1276         expression_sql, params = compiler.compile(self.expression)
1277         placeholders = {
1278             'expression': expression_sql,
1279             'ordering': 'DESC' if self.descending else 'ASC',
1280             **extra_context,
1281         }
1282         params *= template.count('%(expression)s')
1283         return (template % placeholders).rstrip(), params
1284 
1285     def as_oracle(self, compiler, connection):
1286         # Oracle doesn't allow ORDER BY EXISTS() or filters unless it's wrapped
1287         # in a CASE WHEN.
1288         if connection.ops.conditional_expression_supported_in_where_clause(self.expression):
1289             copy = self.copy()
1290             copy.expression = Case(
1291                 When(self.expression, then=True),
1292                 default=False,
1293             )
1294             return copy.as_sql(compiler, connection)
1295         return self.as_sql(compiler, connection)
1296 
1297     def get_group_by_cols(self, alias=None):
1298         cols = []
1299         for source in self.get_source_expressions():
1300             cols.extend(source.get_group_by_cols())
1301         return cols
1302 
1303     def reverse_ordering(self):
1304         self.descending = not self.descending
1305         if self.nulls_first or self.nulls_last:
1306             self.nulls_first = not self.nulls_first
1307             self.nulls_last = not self.nulls_last
1308         return self
1309 
1310     def asc(self):
1311         self.descending = False
1312 
1313     def desc(self):
1314         self.descending = True
1315 
1316 
1317 class Window(SQLiteNumericMixin, Expression):
1318     template = '%(expression)s OVER (%(window)s)'
1319     # Although the main expression may either be an aggregate or an
1320     # expression with an aggregate function, the GROUP BY that will
1321     # be introduced in the query as a result is not desired.
1322     contains_aggregate = False
1323     contains_over_clause = True
1324     filterable = False
1325 
1326     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1327         self.partition_by = partition_by
1328         self.order_by = order_by
1329         self.frame = frame
1330 
1331         if not getattr(expression, 'window_compatible', False):
1332             raise ValueError(
1333                 "Expression '%s' isn't compatible with OVER clauses." %
1334                 expression.__class__.__name__
1335             )
1336 
1337         if self.partition_by is not None:
1338             if not isinstance(self.partition_by, (tuple, list)):
1339                 self.partition_by = (self.partition_by,)
1340             self.partition_by = ExpressionList(*self.partition_by)
1341 
1342         if self.order_by is not None:
1343             if isinstance(self.order_by, (list, tuple)):
1344                 self.order_by = OrderByList(*self.order_by)
1345             elif isinstance(self.order_by, (BaseExpression, str)):
1346                 self.order_by = OrderByList(self.order_by)
1347             else:
1348                 raise ValueError(
1349                     'Window.order_by must be either a string reference to a '
1350                     'field, an expression, or a list or tuple of them.'
1351                 )
1352         super().__init__(output_field=output_field)
1353         self.source_expression = self._parse_expressions(expression)[0]
1354 
1355     def _resolve_output_field(self):
1356         return self.source_expression.output_field
1357 
1358     def get_source_expressions(self):
1359         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1360 
1361     def set_source_expressions(self, exprs):
1362         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1363 
1364     def as_sql(self, compiler, connection, template=None):
1365         connection.ops.check_expression_support(self)
1366         if not connection.features.supports_over_clause:
1367             raise NotSupportedError('This backend does not support window expressions.')
1368         expr_sql, params = compiler.compile(self.source_expression)
1369         window_sql, window_params = [], []
1370 
1371         if self.partition_by is not None:
1372             sql_expr, sql_params = self.partition_by.as_sql(
1373                 compiler=compiler, connection=connection,
1374                 template='PARTITION BY %(expressions)s',
1375             )
1376             window_sql.append(sql_expr)
1377             window_params.extend(sql_params)
1378 
1379         if self.order_by is not None:
1380             order_sql, order_params = compiler.compile(self.order_by)
1381             window_sql.append(order_sql)
1382             window_params.extend(order_params)
1383 
1384         if self.frame:
1385             frame_sql, frame_params = compiler.compile(self.frame)
1386             window_sql.append(frame_sql)
1387             window_params.extend(frame_params)
1388 
1389         params.extend(window_params)
1390         template = template or self.template
1391 
1392         return template % {
1393             'expression': expr_sql,
1394             'window': ' '.join(window_sql).strip()
1395         }, params
1396 
1397     def as_sqlite(self, compiler, connection):
1398         if isinstance(self.output_field, fields.DecimalField):
1399             # Casting to numeric must be outside of the window expression.
1400             copy = self.copy()
1401             source_expressions = copy.get_source_expressions()
1402             source_expressions[0].output_field = fields.FloatField()
1403             copy.set_source_expressions(source_expressions)
1404             return super(Window, copy).as_sqlite(compiler, connection)
1405         return self.as_sql(compiler, connection)
1406 
1407     def __str__(self):
1408         return '{} OVER ({}{}{})'.format(
1409             str(self.source_expression),
1410             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1411             str(self.order_by or ''),
1412             str(self.frame or ''),
1413         )
1414 
1415     def __repr__(self):
1416         return '<%s: %s>' % (self.__class__.__name__, self)
1417 
1418     def get_group_by_cols(self, alias=None):
1419         return []
1420 
1421 
1422 class WindowFrame(Expression):
1423     """
1424     Model the frame clause in window expressions. There are two types of frame
1425     clauses which are subclasses, however, all processing and validation (by no
1426     means intended to be complete) is done here. Thus, providing an end for a
1427     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1428     row in the frame).
1429     """
1430     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1431 
1432     def __init__(self, start=None, end=None):
1433         self.start = Value(start)
1434         self.end = Value(end)
1435 
1436     def set_source_expressions(self, exprs):
1437         self.start, self.end = exprs
1438 
1439     def get_source_expressions(self):
1440         return [self.start, self.end]
1441 
1442     def as_sql(self, compiler, connection):
1443         connection.ops.check_expression_support(self)
1444         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1445         return self.template % {
1446             'frame_type': self.frame_type,
1447             'start': start,
1448             'end': end,
1449         }, []
1450 
1451     def __repr__(self):
1452         return '<%s: %s>' % (self.__class__.__name__, self)
1453 
1454     def get_group_by_cols(self, alias=None):
1455         return []
1456 
1457     def __str__(self):
1458         if self.start.value is not None and self.start.value < 0:
1459             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1460         elif self.start.value is not None and self.start.value == 0:
1461             start = connection.ops.CURRENT_ROW
1462         else:
1463             start = connection.ops.UNBOUNDED_PRECEDING
1464 
1465         if self.end.value is not None and self.end.value > 0:
1466             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1467         elif self.end.value is not None and self.end.value == 0:
1468             end = connection.ops.CURRENT_ROW
1469         else:
1470             end = connection.ops.UNBOUNDED_FOLLOWING
1471         return self.template % {
1472             'frame_type': self.frame_type,
1473             'start': start,
1474             'end': end,
1475         }
1476 
1477     def window_frame_start_end(self, connection, start, end):
1478         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1479 
1480 
1481 class RowRange(WindowFrame):
1482     frame_type = 'ROWS'
1483 
1484     def window_frame_start_end(self, connection, start, end):
1485         return connection.ops.window_frame_rows_start_end(start, end)
1486 
1487 
1488 class ValueRange(WindowFrame):
1489     frame_type = 'RANGE'
1490 
1491     def window_frame_start_end(self, connection, start, end):
1492         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>This file likely contains the implementation of `Subquery` and possibly how expressions involving `OuterRef` are treated when used in complex queries, such as with `union` or the `|` operator. A detailed examination is needed to pinpoint the exact locations.</intended_behavior>, <file>django/db/models/sql/compiler.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections
2 import json
3 import re
4 from functools import partial
5 from itertools import chain
6 
7 from django.core.exceptions import EmptyResultSet, FieldError
8 from django.db import DatabaseError, NotSupportedError
9 from django.db.models.constants import LOOKUP_SEP
10 from django.db.models.expressions import F, OrderBy, RawSQL, Ref, Value
11 from django.db.models.functions import Cast, Random
12 from django.db.models.query_utils import select_related_descend
13 from django.db.models.sql.constants import (
14     CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS, ORDER_DIR, SINGLE,
15 )
16 from django.db.models.sql.query import Query, get_order_dir
17 from django.db.transaction import TransactionManagementError
18 from django.utils.functional import cached_property
19 from django.utils.hashable import make_hashable
20 from django.utils.regex_helper import _lazy_re_compile
21 
22 
23 class SQLCompiler:
24     # Multiline ordering SQL clause may appear from RawSQL.
25     ordering_parts = _lazy_re_compile(
26         r'^(.*)\s(?:ASC|DESC).*',
27         re.MULTILINE | re.DOTALL,
28     )
29 
30     def __init__(self, query, connection, using, elide_empty=True):
31         self.query = query
32         self.connection = connection
33         self.using = using
34         # Some queries, e.g. coalesced aggregation, need to be executed even if
35         # they would return an empty result set.
36         self.elide_empty = elide_empty
37         self.quote_cache = {'*': '*'}
38         # The select, klass_info, and annotations are needed by QuerySet.iterator()
39         # these are set as a side-effect of executing the query. Note that we calculate
40         # separately a list of extra select columns needed for grammatical correctness
41         # of the query, but these columns are not included in self.select.
42         self.select = None
43         self.annotation_col_map = None
44         self.klass_info = None
45         self._meta_ordering = None
46 
47     def __repr__(self):
48         return (
49             f'<{self.__class__.__qualname__} '
50             f'model={self.query.model.__qualname__} '
51             f'connection={self.connection!r} using={self.using!r}>'
52         )
53 
54     def setup_query(self):
55         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
56             self.query.get_initial_alias()
57         self.select, self.klass_info, self.annotation_col_map = self.get_select()
58         self.col_count = len(self.select)
59 
60     def pre_sql_setup(self):
61         """
62         Do any necessary class setup immediately prior to producing SQL. This
63         is for things that can't necessarily be done in __init__ because we
64         might not have all the pieces in place at that time.
65         """
66         self.setup_query()
67         order_by = self.get_order_by()
68         self.where, self.having = self.query.where.split_having()
69         extra_select = self.get_extra_select(order_by, self.select)
70         self.has_extra_select = bool(extra_select)
71         group_by = self.get_group_by(self.select + extra_select, order_by)
72         return extra_select, order_by, group_by
73 
74     def get_group_by(self, select, order_by):
75         """
76         Return a list of 2-tuples of form (sql, params).
77 
78         The logic of what exactly the GROUP BY clause contains is hard
79         to describe in other words than "if it passes the test suite,
80         then it is correct".
81         """
82         # Some examples:
83         #     SomeModel.objects.annotate(Count('somecol'))
84         #     GROUP BY: all fields of the model
85         #
86         #    SomeModel.objects.values('name').annotate(Count('somecol'))
87         #    GROUP BY: name
88         #
89         #    SomeModel.objects.annotate(Count('somecol')).values('name')
90         #    GROUP BY: all cols of the model
91         #
92         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')
93         #    GROUP BY: name, pk
94         #
95         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')
96         #    GROUP BY: name, pk
97         #
98         # In fact, the self.query.group_by is the minimal set to GROUP BY. It
99         # can't be ever restricted to a smaller set, but additional columns in
100         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately
101         # the end result is that it is impossible to force the query to have
102         # a chosen GROUP BY clause - you can almost do this by using the form:
103         #     .values(*wanted_cols).annotate(AnAggregate())
104         # but any later annotations, extra selects, values calls that
105         # refer some column outside of the wanted_cols, order_by, or even
106         # filter calls can alter the GROUP BY clause.
107 
108         # The query.group_by is either None (no GROUP BY at all), True
109         # (group by select fields), or a list of expressions to be added
110         # to the group by.
111         if self.query.group_by is None:
112             return []
113         expressions = []
114         if self.query.group_by is not True:
115             # If the group by is set to a list (by .values() call most likely),
116             # then we need to add everything in it to the GROUP BY clause.
117             # Backwards compatibility hack for setting query.group_by. Remove
118             # when  we have public API way of forcing the GROUP BY clause.
119             # Converts string references to expressions.
120             for expr in self.query.group_by:
121                 if not hasattr(expr, 'as_sql'):
122                     expressions.append(self.query.resolve_ref(expr))
123                 else:
124                     expressions.append(expr)
125         # Note that even if the group_by is set, it is only the minimal
126         # set to group by. So, we need to add cols in select, order_by, and
127         # having into the select in any case.
128         ref_sources = {
129             expr.source for expr in expressions if isinstance(expr, Ref)
130         }
131         for expr, _, _ in select:
132             # Skip members of the select clause that are already included
133             # by reference.
134             if expr in ref_sources:
135                 continue
136             cols = expr.get_group_by_cols()
137             for col in cols:
138                 expressions.append(col)
139         if not self._meta_ordering:
140             for expr, (sql, params, is_ref) in order_by:
141                 # Skip references to the SELECT clause, as all expressions in
142                 # the SELECT clause are already part of the GROUP BY.
143                 if not is_ref:
144                     expressions.extend(expr.get_group_by_cols())
145         having_group_by = self.having.get_group_by_cols() if self.having else ()
146         for expr in having_group_by:
147             expressions.append(expr)
148         result = []
149         seen = set()
150         expressions = self.collapse_group_by(expressions, having_group_by)
151 
152         for expr in expressions:
153             sql, params = self.compile(expr)
154             sql, params = expr.select_format(self, sql, params)
155             params_hash = make_hashable(params)
156             if (sql, params_hash) not in seen:
157                 result.append((sql, params))
158                 seen.add((sql, params_hash))
159         return result
160 
161     def collapse_group_by(self, expressions, having):
162         # If the DB can group by primary key, then group by the primary key of
163         # query's main model. Note that for PostgreSQL the GROUP BY clause must
164         # include the primary key of every table, but for MySQL it is enough to
165         # have the main table's primary key.
166         if self.connection.features.allows_group_by_pk:
167             # Determine if the main model's primary key is in the query.
168             pk = None
169             for expr in expressions:
170                 # Is this a reference to query's base table primary key? If the
171                 # expression isn't a Col-like, then skip the expression.
172                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and
173                         getattr(expr, 'alias', None) == self.query.base_table):
174                     pk = expr
175                     break
176             # If the main model's primary key is in the query, group by that
177             # field, HAVING expressions, and expressions associated with tables
178             # that don't have a primary key included in the grouped columns.
179             if pk:
180                 pk_aliases = {
181                     expr.alias for expr in expressions
182                     if hasattr(expr, 'target') and expr.target.primary_key
183                 }
184                 expressions = [pk] + [
185                     expr for expr in expressions
186                     if expr in having or (
187                         getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases
188                     )
189                 ]
190         elif self.connection.features.allows_group_by_selected_pks:
191             # Filter out all expressions associated with a table's primary key
192             # present in the grouped columns. This is done by identifying all
193             # tables that have their primary key included in the grouped
194             # columns and removing non-primary key columns referring to them.
195             # Unmanaged models are excluded because they could be representing
196             # database views on which the optimization might not be allowed.
197             pks = {
198                 expr for expr in expressions
199                 if (
200                     hasattr(expr, 'target') and
201                     expr.target.primary_key and
202                     self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)
203                 )
204             }
205             aliases = {expr.alias for expr in pks}
206             expressions = [
207                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases
208             ]
209         return expressions
210 
211     def get_select(self):
212         """
213         Return three values:
214         - a list of 3-tuples of (expression, (sql, params), alias)
215         - a klass_info structure,
216         - a dictionary of annotations
217 
218         The (sql, params) is what the expression will produce, and alias is the
219         "AS alias" for the column (possibly None).
220 
221         The klass_info structure contains the following information:
222         - The base model of the query.
223         - Which columns for that model are present in the query (by
224           position of the select clause).
225         - related_klass_infos: [f, klass_info] to descent into
226 
227         The annotations is a dictionary of {'attname': column position} values.
228         """
229         select = []
230         klass_info = None
231         annotations = {}
232         select_idx = 0
233         for alias, (sql, params) in self.query.extra_select.items():
234             annotations[alias] = select_idx
235             select.append((RawSQL(sql, params), alias))
236             select_idx += 1
237         assert not (self.query.select and self.query.default_cols)
238         if self.query.default_cols:
239             cols = self.get_default_columns()
240         else:
241             # self.query.select is a special case. These columns never go to
242             # any model.
243             cols = self.query.select
244         if cols:
245             select_list = []
246             for col in cols:
247                 select_list.append(select_idx)
248                 select.append((col, None))
249                 select_idx += 1
250             klass_info = {
251                 'model': self.query.model,
252                 'select_fields': select_list,
253             }
254         for alias, annotation in self.query.annotation_select.items():
255             annotations[alias] = select_idx
256             select.append((annotation, alias))
257             select_idx += 1
258 
259         if self.query.select_related:
260             related_klass_infos = self.get_related_selections(select)
261             klass_info['related_klass_infos'] = related_klass_infos
262 
263             def get_select_from_parent(klass_info):
264                 for ki in klass_info['related_klass_infos']:
265                     if ki['from_parent']:
266                         ki['select_fields'] = (klass_info['select_fields'] +
267                                                ki['select_fields'])
268                     get_select_from_parent(ki)
269             get_select_from_parent(klass_info)
270 
271         ret = []
272         for col, alias in select:
273             try:
274                 sql, params = self.compile(col)
275             except EmptyResultSet:
276                 empty_result_set_value = getattr(col, 'empty_result_set_value', NotImplemented)
277                 if empty_result_set_value is NotImplemented:
278                     # Select a predicate that's always False.
279                     sql, params = '0', ()
280                 else:
281                     sql, params = self.compile(Value(empty_result_set_value))
282             else:
283                 sql, params = col.select_format(self, sql, params)
284             ret.append((col, (sql, params), alias))
285         return ret, klass_info, annotations
286 
287     def _order_by_pairs(self):
288         if self.query.extra_order_by:
289             ordering = self.query.extra_order_by
290         elif not self.query.default_ordering:
291             ordering = self.query.order_by
292         elif self.query.order_by:
293             ordering = self.query.order_by
294         elif self.query.get_meta().ordering:
295             ordering = self.query.get_meta().ordering
296             self._meta_ordering = ordering
297         else:
298             ordering = []
299         if self.query.standard_ordering:
300             default_order, _ = ORDER_DIR['ASC']
301         else:
302             default_order, _ = ORDER_DIR['DESC']
303 
304         for field in ordering:
305             if hasattr(field, 'resolve_expression'):
306                 if isinstance(field, Value):
307                     # output_field must be resolved for constants.
308                     field = Cast(field, field.output_field)
309                 if not isinstance(field, OrderBy):
310                     field = field.asc()
311                 if not self.query.standard_ordering:
312                     field = field.copy()
313                     field.reverse_ordering()
314                 yield field, False
315                 continue
316             if field == '?':  # random
317                 yield OrderBy(Random()), False
318                 continue
319 
320             col, order = get_order_dir(field, default_order)
321             descending = order == 'DESC'
322 
323             if col in self.query.annotation_select:
324                 # Reference to expression in SELECT clause
325                 yield (
326                     OrderBy(
327                         Ref(col, self.query.annotation_select[col]),
328                         descending=descending,
329                     ),
330                     True,
331                 )
332                 continue
333             if col in self.query.annotations:
334                 # References to an expression which is masked out of the SELECT
335                 # clause.
336                 if self.query.combinator and self.select:
337                     # Don't use the resolved annotation because other
338                     # combinated queries might define it differently.
339                     expr = F(col)
340                 else:
341                     expr = self.query.annotations[col]
342                     if isinstance(expr, Value):
343                         # output_field must be resolved for constants.
344                         expr = Cast(expr, expr.output_field)
345                 yield OrderBy(expr, descending=descending), False
346                 continue
347 
348             if '.' in field:
349                 # This came in through an extra(order_by=...) addition. Pass it
350                 # on verbatim.
351                 table, col = col.split('.', 1)
352                 yield (
353                     OrderBy(
354                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),
355                         descending=descending,
356                     ),
357                     False,
358                 )
359                 continue
360 
361             if self.query.extra and col in self.query.extra:
362                 if col in self.query.extra_select:
363                     yield (
364                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),
365                         True,
366                     )
367                 else:
368                     yield (
369                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),
370                         False,
371                     )
372             else:
373                 if self.query.combinator and self.select:
374                     # Don't use the first model's field because other
375                     # combinated queries might define it differently.
376                     yield OrderBy(F(col), descending=descending), False
377                 else:
378                     # 'col' is of the form 'field' or 'field1__field2' or
379                     # '-field1__field2__field', etc.
380                     yield from self.find_ordering_name(
381                         field, self.query.get_meta(), default_order=default_order,
382                     )
383 
384     def get_order_by(self):
385         """
386         Return a list of 2-tuples of the form (expr, (sql, params, is_ref)) for
387         the ORDER BY clause.
388 
389         The order_by clause can alter the select clause (for example it can add
390         aliases to clauses that do not yet have one, or it can add totally new
391         select clauses).
392         """
393         result = []
394         seen = set()
395 
396         for expr, is_ref in self._order_by_pairs():
397             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
398             if self.query.combinator and self.select:
399                 src = resolved.get_source_expressions()[0]
400                 expr_src = expr.get_source_expressions()[0]
401                 # Relabel order by columns to raw numbers if this is a combined
402                 # query; necessary since the columns can't be referenced by the
403                 # fully qualified name and the simple column names may collide.
404                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):
405                     if is_ref and col_alias == src.refs:
406                         src = src.source
407                     elif col_alias and not (
408                         isinstance(expr_src, F) and col_alias == expr_src.name
409                     ):
410                         continue
411                     if src == sel_expr:
412                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])
413                         break
414                 else:
415                     if col_alias:
416                         raise DatabaseError('ORDER BY term does not match any column in the result set.')
417                     # Add column used in ORDER BY clause to the selected
418                     # columns and to each combined query.
419                     order_by_idx = len(self.query.select) + 1
420                     col_name = f'__orderbycol{order_by_idx}'
421                     for q in self.query.combined_queries:
422                         q.add_annotation(expr_src, col_name)
423                     self.query.add_select_col(resolved, col_name)
424                     resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])
425             sql, params = self.compile(resolved)
426             # Don't add the same column twice, but the order direction is
427             # not taken into account so we strip it. When this entire method
428             # is refactored into expressions, then we can check each part as we
429             # generate it.
430             without_ordering = self.ordering_parts.search(sql)[1]
431             params_hash = make_hashable(params)
432             if (without_ordering, params_hash) in seen:
433                 continue
434             seen.add((without_ordering, params_hash))
435             result.append((resolved, (sql, params, is_ref)))
436         return result
437 
438     def get_extra_select(self, order_by, select):
439         extra_select = []
440         if self.query.distinct and not self.query.distinct_fields:
441             select_sql = [t[1] for t in select]
442             for expr, (sql, params, is_ref) in order_by:
443                 without_ordering = self.ordering_parts.search(sql)[1]
444                 if not is_ref and (without_ordering, params) not in select_sql:
445                     extra_select.append((expr, (without_ordering, params), None))
446         return extra_select
447 
448     def quote_name_unless_alias(self, name):
449         """
450         A wrapper around connection.ops.quote_name that doesn't quote aliases
451         for table names. This avoids problems with some SQL dialects that treat
452         quoted strings specially (e.g. PostgreSQL).
453         """
454         if name in self.quote_cache:
455             return self.quote_cache[name]
456         if ((name in self.query.alias_map and name not in self.query.table_map) or
457                 name in self.query.extra_select or (
458                     self.query.external_aliases.get(name) and name not in self.query.table_map)):
459             self.quote_cache[name] = name
460             return name
461         r = self.connection.ops.quote_name(name)
462         self.quote_cache[name] = r
463         return r
464 
465     def compile(self, node):
466         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
467         if vendor_impl:
468             sql, params = vendor_impl(self, self.connection)
469         else:
470             sql, params = node.as_sql(self, self.connection)
471         return sql, params
472 
473     def get_combinator_sql(self, combinator, all):
474         features = self.connection.features
475         compilers = [
476             query.get_compiler(self.using, self.connection, self.elide_empty)
477             for query in self.query.combined_queries if not query.is_empty()
478         ]
479         if not features.supports_slicing_ordering_in_compound:
480             for query, compiler in zip(self.query.combined_queries, compilers):
481                 if query.low_mark or query.high_mark:
482                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')
483                 if compiler.get_order_by():
484                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')
485         parts = ()
486         for compiler in compilers:
487             try:
488                 # If the columns list is limited, then all combined queries
489                 # must have the same columns list. Set the selects defined on
490                 # the query on all combined queries, if not already set.
491                 if not compiler.query.values_select and self.query.values_select:
492                     compiler.query = compiler.query.clone()
493                     compiler.query.set_values((
494                         *self.query.extra_select,
495                         *self.query.values_select,
496                         *self.query.annotation_select,
497                     ))
498                 part_sql, part_args = compiler.as_sql()
499                 if compiler.query.combinator:
500                     # Wrap in a subquery if wrapping in parentheses isn't
501                     # supported.
502                     if not features.supports_parentheses_in_compound:
503                         part_sql = 'SELECT * FROM ({})'.format(part_sql)
504                     # Add parentheses when combining with compound query if not
505                     # already added for all compound queries.
506                     elif not features.supports_slicing_ordering_in_compound:
507                         part_sql = '({})'.format(part_sql)
508                 parts += ((part_sql, part_args),)
509             except EmptyResultSet:
510                 # Omit the empty queryset with UNION and with DIFFERENCE if the
511                 # first queryset is nonempty.
512                 if combinator == 'union' or (combinator == 'difference' and parts):
513                     continue
514                 raise
515         if not parts:
516             raise EmptyResultSet
517         combinator_sql = self.connection.ops.set_operators[combinator]
518         if all and combinator == 'union':
519             combinator_sql += ' ALL'
520         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'
521         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
522         result = [' {} '.format(combinator_sql).join(sql_parts)]
523         params = []
524         for part in args_parts:
525             params.extend(part)
526         return result, params
527 
528     def as_sql(self, with_limits=True, with_col_aliases=False):
529         """
530         Create the SQL for this query. Return the SQL string and list of
531         parameters.
532 
533         If 'with_limits' is False, any limit/offset information is not included
534         in the query.
535         """
536         refcounts_before = self.query.alias_refcount.copy()
537         try:
538             extra_select, order_by, group_by = self.pre_sql_setup()
539             for_update_part = None
540             # Is a LIMIT/OFFSET clause needed?
541             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
542             combinator = self.query.combinator
543             features = self.connection.features
544             if combinator:
545                 if not getattr(features, 'supports_select_{}'.format(combinator)):
546                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
547                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
548             else:
549                 distinct_fields, distinct_params = self.get_distinct()
550                 # This must come after 'select', 'ordering', and 'distinct'
551                 # (see docstring of get_from_clause() for details).
552                 from_, f_params = self.get_from_clause()
553                 try:
554                     where, w_params = self.compile(self.where) if self.where is not None else ('', [])
555                 except EmptyResultSet:
556                     if self.elide_empty:
557                         raise
558                     # Use a predicate that's always False.
559                     where, w_params = '0 = 1', []
560                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
561                 result = ['SELECT']
562                 params = []
563 
564                 if self.query.distinct:
565                     distinct_result, distinct_params = self.connection.ops.distinct_sql(
566                         distinct_fields,
567                         distinct_params,
568                     )
569                     result += distinct_result
570                     params += distinct_params
571 
572                 out_cols = []
573                 col_idx = 1
574                 for _, (s_sql, s_params), alias in self.select + extra_select:
575                     if alias:
576                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
577                     elif with_col_aliases:
578                         s_sql = '%s AS %s' % (
579                             s_sql,
580                             self.connection.ops.quote_name('col%d' % col_idx),
581                         )
582                         col_idx += 1
583                     params.extend(s_params)
584                     out_cols.append(s_sql)
585 
586                 result += [', '.join(out_cols), 'FROM', *from_]
587                 params.extend(f_params)
588 
589                 if self.query.select_for_update and self.connection.features.has_select_for_update:
590                     if self.connection.get_autocommit():
591                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')
592 
593                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:
594                         raise NotSupportedError(
595                             'LIMIT/OFFSET is not supported with '
596                             'select_for_update on this database backend.'
597                         )
598                     nowait = self.query.select_for_update_nowait
599                     skip_locked = self.query.select_for_update_skip_locked
600                     of = self.query.select_for_update_of
601                     no_key = self.query.select_for_no_key_update
602                     # If it's a NOWAIT/SKIP LOCKED/OF/NO KEY query but the
603                     # backend doesn't support it, raise NotSupportedError to
604                     # prevent a possible deadlock.
605                     if nowait and not self.connection.features.has_select_for_update_nowait:
606                         raise NotSupportedError('NOWAIT is not supported on this database backend.')
607                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:
608                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')
609                     elif of and not self.connection.features.has_select_for_update_of:
610                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')
611                     elif no_key and not self.connection.features.has_select_for_no_key_update:
612                         raise NotSupportedError(
613                             'FOR NO KEY UPDATE is not supported on this '
614                             'database backend.'
615                         )
616                     for_update_part = self.connection.ops.for_update_sql(
617                         nowait=nowait,
618                         skip_locked=skip_locked,
619                         of=self.get_select_for_update_of_arguments(),
620                         no_key=no_key,
621                     )
622 
623                 if for_update_part and self.connection.features.for_update_after_from:
624                     result.append(for_update_part)
625 
626                 if where:
627                     result.append('WHERE %s' % where)
628                     params.extend(w_params)
629 
630                 grouping = []
631                 for g_sql, g_params in group_by:
632                     grouping.append(g_sql)
633                     params.extend(g_params)
634                 if grouping:
635                     if distinct_fields:
636                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')
637                     order_by = order_by or self.connection.ops.force_no_ordering()
638                     result.append('GROUP BY %s' % ', '.join(grouping))
639                     if self._meta_ordering:
640                         order_by = None
641                 if having:
642                     result.append('HAVING %s' % having)
643                     params.extend(h_params)
644 
645             if self.query.explain_info:
646                 result.insert(0, self.connection.ops.explain_query_prefix(
647                     self.query.explain_info.format,
648                     **self.query.explain_info.options
649                 ))
650 
651             if order_by:
652                 ordering = []
653                 for _, (o_sql, o_params, _) in order_by:
654                     ordering.append(o_sql)
655                     params.extend(o_params)
656                 result.append('ORDER BY %s' % ', '.join(ordering))
657 
658             if with_limit_offset:
659                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
660 
661             if for_update_part and not self.connection.features.for_update_after_from:
662                 result.append(for_update_part)
663 
664             if self.query.subquery and extra_select:
665                 # If the query is used as a subquery, the extra selects would
666                 # result in more columns than the left-hand side expression is
667                 # expecting. This can happen when a subquery uses a combination
668                 # of order_by() and distinct(), forcing the ordering expressions
669                 # to be selected as well. Wrap the query in another subquery
670                 # to exclude extraneous selects.
671                 sub_selects = []
672                 sub_params = []
673                 for index, (select, _, alias) in enumerate(self.select, start=1):
674                     if not alias and with_col_aliases:
675                         alias = 'col%d' % index
676                     if alias:
677                         sub_selects.append("%s.%s" % (
678                             self.connection.ops.quote_name('subquery'),
679                             self.connection.ops.quote_name(alias),
680                         ))
681                     else:
682                         select_clone = select.relabeled_clone({select.alias: 'subquery'})
683                         subselect, subparams = select_clone.as_sql(self, self.connection)
684                         sub_selects.append(subselect)
685                         sub_params.extend(subparams)
686                 return 'SELECT %s FROM (%s) subquery' % (
687                     ', '.join(sub_selects),
688                     ' '.join(result),
689                 ), tuple(sub_params + params)
690 
691             return ' '.join(result), tuple(params)
692         finally:
693             # Finally do cleanup - get rid of the joins we created above.
694             self.query.reset_refcounts(refcounts_before)
695 
696     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):
697         """
698         Compute the default columns for selecting every field in the base
699         model. Will sometimes be called to pull in related models (e.g. via
700         select_related), in which case "opts" and "start_alias" will be given
701         to provide a starting point for the traversal.
702 
703         Return a list of strings, quoted appropriately for use in SQL
704         directly, as well as a set of aliases used in the select statement (if
705         'as_pairs' is True, return a list of (alias, col_name) pairs instead
706         of strings as the first component and None as the second component).
707         """
708         result = []
709         if opts is None:
710             opts = self.query.get_meta()
711         only_load = self.deferred_to_columns()
712         start_alias = start_alias or self.query.get_initial_alias()
713         # The 'seen_models' is used to optimize checking the needed parent
714         # alias for a given field. This also includes None -> start_alias to
715         # be used by local fields.
716         seen_models = {None: start_alias}
717 
718         for field in opts.concrete_fields:
719             model = field.model._meta.concrete_model
720             # A proxy model will have a different model and concrete_model. We
721             # will assign None if the field belongs to this model.
722             if model == opts.model:
723                 model = None
724             if from_parent and model is not None and issubclass(
725                     from_parent._meta.concrete_model, model._meta.concrete_model):
726                 # Avoid loading data for already loaded parents.
727                 # We end up here in the case select_related() resolution
728                 # proceeds from parent model to child model. In that case the
729                 # parent model data is already present in the SELECT clause,
730                 # and we want to avoid reloading the same data again.
731                 continue
732             if field.model in only_load and field.attname not in only_load[field.model]:
733                 continue
734             alias = self.query.join_parent_model(opts, model, start_alias,
735                                                  seen_models)
736             column = field.get_col(alias)
737             result.append(column)
738         return result
739 
740     def get_distinct(self):
741         """
742         Return a quoted list of fields to use in DISTINCT ON part of the query.
743 
744         This method can alter the tables in the query, and thus it must be
745         called before get_from_clause().
746         """
747         result = []
748         params = []
749         opts = self.query.get_meta()
750 
751         for name in self.query.distinct_fields:
752             parts = name.split(LOOKUP_SEP)
753             _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)
754             targets, alias, _ = self.query.trim_joins(targets, joins, path)
755             for target in targets:
756                 if name in self.query.annotation_select:
757                     result.append(self.connection.ops.quote_name(name))
758                 else:
759                     r, p = self.compile(transform_function(target, alias))
760                     result.append(r)
761                     params.append(p)
762         return result, params
763 
764     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',
765                            already_seen=None):
766         """
767         Return the table alias (the name might be ambiguous, the alias will
768         not be) and column name for ordering by the given 'name' parameter.
769         The 'name' is of the form 'field1__field2__...__fieldN'.
770         """
771         name, order = get_order_dir(name, default_order)
772         descending = order == 'DESC'
773         pieces = name.split(LOOKUP_SEP)
774         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
775 
776         # If we get to this point and the field is a relation to another model,
777         # append the default ordering for that model unless it is the pk
778         # shortcut or the attribute name of the field that is specified.
779         if (
780             field.is_relation and
781             opts.ordering and
782             getattr(field, 'attname', None) != pieces[-1] and
783             name != 'pk'
784         ):
785             # Firstly, avoid infinite loops.
786             already_seen = already_seen or set()
787             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)
788             if join_tuple in already_seen:
789                 raise FieldError('Infinite loop caused by ordering.')
790             already_seen.add(join_tuple)
791 
792             results = []
793             for item in opts.ordering:
794                 if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):
795                     item = item.desc() if descending else item.asc()
796                 if isinstance(item, OrderBy):
797                     results.append((item, False))
798                     continue
799                 results.extend(self.find_ordering_name(item, opts, alias,
800                                                        order, already_seen))
801             return results
802         targets, alias, _ = self.query.trim_joins(targets, joins, path)
803         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
804 
805     def _setup_joins(self, pieces, opts, alias):
806         """
807         Helper method for get_order_by() and get_distinct().
808 
809         get_ordering() and get_distinct() must produce same target columns on
810         same input, as the prefixes of get_ordering() and get_distinct() must
811         match. Executing SQL where this is not true is an error.
812         """
813         alias = alias or self.query.get_initial_alias()
814         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
815         alias = joins[-1]
816         return field, targets, alias, joins, path, opts, transform_function
817 
818     def get_from_clause(self):
819         """
820         Return a list of strings that are joined together to go after the
821         "FROM" part of the query, as well as a list any extra parameters that
822         need to be included. Subclasses, can override this to create a
823         from-clause via a "select".
824 
825         This should only be called after any SQL construction methods that
826         might change the tables that are needed. This means the select columns,
827         ordering, and distinct must be done first.
828         """
829         result = []
830         params = []
831         for alias in tuple(self.query.alias_map):
832             if not self.query.alias_refcount[alias]:
833                 continue
834             try:
835                 from_clause = self.query.alias_map[alias]
836             except KeyError:
837                 # Extra tables can end up in self.tables, but not in the
838                 # alias_map if they aren't in a join. That's OK. We skip them.
839                 continue
840             clause_sql, clause_params = self.compile(from_clause)
841             result.append(clause_sql)
842             params.extend(clause_params)
843         for t in self.query.extra_tables:
844             alias, _ = self.query.table_alias(t)
845             # Only add the alias if it's not already present (the table_alias()
846             # call increments the refcount, so an alias refcount of one means
847             # this is the only reference).
848             if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:
849                 result.append(', %s' % self.quote_name_unless_alias(alias))
850         return result, params
851 
852     def get_related_selections(self, select, opts=None, root_alias=None, cur_depth=1,
853                                requested=None, restricted=None):
854         """
855         Fill in the information needed for a select_related query. The current
856         depth is measured as the number of connections away from the root model
857         (for example, cur_depth=1 means we are looking at models with direct
858         connections to the root model).
859         """
860         def _get_field_choices():
861             direct_choices = (f.name for f in opts.fields if f.is_relation)
862             reverse_choices = (
863                 f.field.related_query_name()
864                 for f in opts.related_objects if f.field.unique
865             )
866             return chain(direct_choices, reverse_choices, self.query._filtered_relations)
867 
868         related_klass_infos = []
869         if not restricted and cur_depth > self.query.max_depth:
870             # We've recursed far enough; bail out.
871             return related_klass_infos
872 
873         if not opts:
874             opts = self.query.get_meta()
875             root_alias = self.query.get_initial_alias()
876         only_load = self.query.get_loaded_field_names()
877 
878         # Setup for the case when only particular related fields should be
879         # included in the related selection.
880         fields_found = set()
881         if requested is None:
882             restricted = isinstance(self.query.select_related, dict)
883             if restricted:
884                 requested = self.query.select_related
885 
886         def get_related_klass_infos(klass_info, related_klass_infos):
887             klass_info['related_klass_infos'] = related_klass_infos
888 
889         for f in opts.fields:
890             field_model = f.model._meta.concrete_model
891             fields_found.add(f.name)
892 
893             if restricted:
894                 next = requested.get(f.name, {})
895                 if not f.is_relation:
896                     # If a non-related field is used like a relation,
897                     # or if a single non-relational field is given.
898                     if next or f.name in requested:
899                         raise FieldError(
900                             "Non-relational field given in select_related: '%s'. "
901                             "Choices are: %s" % (
902                                 f.name,
903                                 ", ".join(_get_field_choices()) or '(none)',
904                             )
905                         )
906             else:
907                 next = False
908 
909             if not select_related_descend(f, restricted, requested,
910                                           only_load.get(field_model)):
911                 continue
912             klass_info = {
913                 'model': f.remote_field.model,
914                 'field': f,
915                 'reverse': False,
916                 'local_setter': f.set_cached_value,
917                 'remote_setter': f.remote_field.set_cached_value if f.unique else lambda x, y: None,
918                 'from_parent': False,
919             }
920             related_klass_infos.append(klass_info)
921             select_fields = []
922             _, _, _, joins, _, _ = self.query.setup_joins(
923                 [f.name], opts, root_alias)
924             alias = joins[-1]
925             columns = self.get_default_columns(start_alias=alias, opts=f.remote_field.model._meta)
926             for col in columns:
927                 select_fields.append(len(select))
928                 select.append((col, None))
929             klass_info['select_fields'] = select_fields
930             next_klass_infos = self.get_related_selections(
931                 select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)
932             get_related_klass_infos(klass_info, next_klass_infos)
933 
934         if restricted:
935             related_fields = [
936                 (o.field, o.related_model)
937                 for o in opts.related_objects
938                 if o.field.unique and not o.many_to_many
939             ]
940             for f, model in related_fields:
941                 if not select_related_descend(f, restricted, requested,
942                                               only_load.get(model), reverse=True):
943                     continue
944 
945                 related_field_name = f.related_query_name()
946                 fields_found.add(related_field_name)
947 
948                 join_info = self.query.setup_joins([related_field_name], opts, root_alias)
949                 alias = join_info.joins[-1]
950                 from_parent = issubclass(model, opts.model) and model is not opts.model
951                 klass_info = {
952                     'model': model,
953                     'field': f,
954                     'reverse': True,
955                     'local_setter': f.remote_field.set_cached_value,
956                     'remote_setter': f.set_cached_value,
957                     'from_parent': from_parent,
958                 }
959                 related_klass_infos.append(klass_info)
960                 select_fields = []
961                 columns = self.get_default_columns(
962                     start_alias=alias, opts=model._meta, from_parent=opts.model)
963                 for col in columns:
964                     select_fields.append(len(select))
965                     select.append((col, None))
966                 klass_info['select_fields'] = select_fields
967                 next = requested.get(f.related_query_name(), {})
968                 next_klass_infos = self.get_related_selections(
969                     select, model._meta, alias, cur_depth + 1,
970                     next, restricted)
971                 get_related_klass_infos(klass_info, next_klass_infos)
972 
973             def local_setter(obj, from_obj):
974                 # Set a reverse fk object when relation is non-empty.
975                 if from_obj:
976                     f.remote_field.set_cached_value(from_obj, obj)
977 
978             def remote_setter(name, obj, from_obj):
979                 setattr(from_obj, name, obj)
980 
981             for name in list(requested):
982                 # Filtered relations work only on the topmost level.
983                 if cur_depth > 1:
984                     break
985                 if name in self.query._filtered_relations:
986                     fields_found.add(name)
987                     f, _, join_opts, joins, _, _ = self.query.setup_joins([name], opts, root_alias)
988                     model = join_opts.model
989                     alias = joins[-1]
990                     from_parent = issubclass(model, opts.model) and model is not opts.model
991                     klass_info = {
992                         'model': model,
993                         'field': f,
994                         'reverse': True,
995                         'local_setter': local_setter,
996                         'remote_setter': partial(remote_setter, name),
997                         'from_parent': from_parent,
998                     }
999                     related_klass_infos.append(klass_info)
1000                     select_fields = []
1001                     columns = self.get_default_columns(
1002                         start_alias=alias, opts=model._meta,
1003                         from_parent=opts.model,
1004                     )
1005                     for col in columns:
1006                         select_fields.append(len(select))
1007                         select.append((col, None))
1008                     klass_info['select_fields'] = select_fields
1009                     next_requested = requested.get(name, {})
1010                     next_klass_infos = self.get_related_selections(
1011                         select, opts=model._meta, root_alias=alias,
1012                         cur_depth=cur_depth + 1, requested=next_requested,
1013                         restricted=restricted,
1014                     )
1015                     get_related_klass_infos(klass_info, next_klass_infos)
1016             fields_not_found = set(requested).difference(fields_found)
1017             if fields_not_found:
1018                 invalid_fields = ("'%s'" % s for s in fields_not_found)
1019                 raise FieldError(
1020                     'Invalid field name(s) given in select_related: %s. '
1021                     'Choices are: %s' % (
1022                         ', '.join(invalid_fields),
1023                         ', '.join(_get_field_choices()) or '(none)',
1024                     )
1025                 )
1026         return related_klass_infos
1027 
1028     def get_select_for_update_of_arguments(self):
1029         """
1030         Return a quoted list of arguments for the SELECT FOR UPDATE OF part of
1031         the query.
1032         """
1033         def _get_parent_klass_info(klass_info):
1034             concrete_model = klass_info['model']._meta.concrete_model
1035             for parent_model, parent_link in concrete_model._meta.parents.items():
1036                 parent_list = parent_model._meta.get_parent_list()
1037                 yield {
1038                     'model': parent_model,
1039                     'field': parent_link,
1040                     'reverse': False,
1041                     'select_fields': [
1042                         select_index
1043                         for select_index in klass_info['select_fields']
1044                         # Selected columns from a model or its parents.
1045                         if (
1046                             self.select[select_index][0].target.model == parent_model or
1047                             self.select[select_index][0].target.model in parent_list
1048                         )
1049                     ],
1050                 }
1051 
1052         def _get_first_selected_col_from_model(klass_info):
1053             """
1054             Find the first selected column from a model. If it doesn't exist,
1055             don't lock a model.
1056 
1057             select_fields is filled recursively, so it also contains fields
1058             from the parent models.
1059             """
1060             concrete_model = klass_info['model']._meta.concrete_model
1061             for select_index in klass_info['select_fields']:
1062                 if self.select[select_index][0].target.model == concrete_model:
1063                     return self.select[select_index][0]
1064 
1065         def _get_field_choices():
1066             """Yield all allowed field paths in breadth-first search order."""
1067             queue = collections.deque([(None, self.klass_info)])
1068             while queue:
1069                 parent_path, klass_info = queue.popleft()
1070                 if parent_path is None:
1071                     path = []
1072                     yield 'self'
1073                 else:
1074                     field = klass_info['field']
1075                     if klass_info['reverse']:
1076                         field = field.remote_field
1077                     path = parent_path + [field.name]
1078                     yield LOOKUP_SEP.join(path)
1079                 queue.extend(
1080                     (path, klass_info)
1081                     for klass_info in _get_parent_klass_info(klass_info)
1082                 )
1083                 queue.extend(
1084                     (path, klass_info)
1085                     for klass_info in klass_info.get('related_klass_infos', [])
1086                 )
1087         if not self.klass_info:
1088             return []
1089         result = []
1090         invalid_names = []
1091         for name in self.query.select_for_update_of:
1092             klass_info = self.klass_info
1093             if name == 'self':
1094                 col = _get_first_selected_col_from_model(klass_info)
1095             else:
1096                 for part in name.split(LOOKUP_SEP):
1097                     klass_infos = (
1098                         *klass_info.get('related_klass_infos', []),
1099                         *_get_parent_klass_info(klass_info),
1100                     )
1101                     for related_klass_info in klass_infos:
1102                         field = related_klass_info['field']
1103                         if related_klass_info['reverse']:
1104                             field = field.remote_field
1105                         if field.name == part:
1106                             klass_info = related_klass_info
1107                             break
1108                     else:
1109                         klass_info = None
1110                         break
1111                 if klass_info is None:
1112                     invalid_names.append(name)
1113                     continue
1114                 col = _get_first_selected_col_from_model(klass_info)
1115             if col is not None:
1116                 if self.connection.features.select_for_update_of_column:
1117                     result.append(self.compile(col)[0])
1118                 else:
1119                     result.append(self.quote_name_unless_alias(col.alias))
1120         if invalid_names:
1121             raise FieldError(
1122                 'Invalid field name(s) given in select_for_update(of=(...)): %s. '
1123                 'Only relational fields followed in the query are allowed. '
1124                 'Choices are: %s.' % (
1125                     ', '.join(invalid_names),
1126                     ', '.join(_get_field_choices()),
1127                 )
1128             )
1129         return result
1130 
1131     def deferred_to_columns(self):
1132         """
1133         Convert the self.deferred_loading data structure to mapping of table
1134         names to sets of column names which are to be loaded. Return the
1135         dictionary.
1136         """
1137         columns = {}
1138         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
1139         return columns
1140 
1141     def get_converters(self, expressions):
1142         converters = {}
1143         for i, expression in enumerate(expressions):
1144             if expression:
1145                 backend_converters = self.connection.ops.get_db_converters(expression)
1146                 field_converters = expression.get_db_converters(self.connection)
1147                 if backend_converters or field_converters:
1148                     converters[i] = (backend_converters + field_converters, expression)
1149         return converters
1150 
1151     def apply_converters(self, rows, converters):
1152         connection = self.connection
1153         converters = list(converters.items())
1154         for row in map(list, rows):
1155             for pos, (convs, expression) in converters:
1156                 value = row[pos]
1157                 for converter in convs:
1158                     value = converter(value, expression, connection)
1159                 row[pos] = value
1160             yield row
1161 
1162     def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False,
1163                      chunk_size=GET_ITERATOR_CHUNK_SIZE):
1164         """Return an iterator over the results from executing this query."""
1165         if results is None:
1166             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
1167         fields = [s[0] for s in self.select[0:self.col_count]]
1168         converters = self.get_converters(fields)
1169         rows = chain.from_iterable(results)
1170         if converters:
1171             rows = self.apply_converters(rows, converters)
1172             if tuple_expected:
1173                 rows = map(tuple, rows)
1174         return rows
1175 
1176     def has_results(self):
1177         """
1178         Backends (e.g. NoSQL) can override this in order to use optimized
1179         versions of "query has any results."
1180         """
1181         return bool(self.execute_sql(SINGLE))
1182 
1183     def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
1184         """
1185         Run the query against the database and return the result(s). The
1186         return value is a single data item if result_type is SINGLE, or an
1187         iterator over the results if the result_type is MULTI.
1188 
1189         result_type is either MULTI (use fetchmany() to retrieve all rows),
1190         SINGLE (only retrieve a single row), or None. In this last case, the
1191         cursor is returned if any query is executed, since it's used by
1192         subclasses such as InsertQuery). It's possible, however, that no query
1193         is needed, as the filters describe an empty set. In that case, None is
1194         returned, to avoid any unnecessary database interaction.
1195         """
1196         result_type = result_type or NO_RESULTS
1197         try:
1198             sql, params = self.as_sql()
1199             if not sql:
1200                 raise EmptyResultSet
1201         except EmptyResultSet:
1202             if result_type == MULTI:
1203                 return iter([])
1204             else:
1205                 return
1206         if chunked_fetch:
1207             cursor = self.connection.chunked_cursor()
1208         else:
1209             cursor = self.connection.cursor()
1210         try:
1211             cursor.execute(sql, params)
1212         except Exception:
1213             # Might fail for server-side cursors (e.g. connection closed)
1214             cursor.close()
1215             raise
1216 
1217         if result_type == CURSOR:
1218             # Give the caller the cursor to process and close.
1219             return cursor
1220         if result_type == SINGLE:
1221             try:
1222                 val = cursor.fetchone()
1223                 if val:
1224                     return val[0:self.col_count]
1225                 return val
1226             finally:
1227                 # done with the cursor
1228                 cursor.close()
1229         if result_type == NO_RESULTS:
1230             cursor.close()
1231             return
1232 
1233         result = cursor_iter(
1234             cursor, self.connection.features.empty_fetchmany_value,
1235             self.col_count if self.has_extra_select else None,
1236             chunk_size,
1237         )
1238         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
1239             # If we are using non-chunked reads, we return the same data
1240             # structure as normally, but ensure it is all read into memory
1241             # before going any further. Use chunked_fetch if requested,
1242             # unless the database doesn't support it.
1243             return list(result)
1244         return result
1245 
1246     def as_subquery_condition(self, alias, columns, compiler):
1247         qn = compiler.quote_name_unless_alias
1248         qn2 = self.connection.ops.quote_name
1249 
1250         for index, select_col in enumerate(self.query.select):
1251             lhs_sql, lhs_params = self.compile(select_col)
1252             rhs = '%s.%s' % (qn(alias), qn2(columns[index]))
1253             self.query.where.add(
1254                 RawSQL('%s = %s' % (lhs_sql, rhs), lhs_params), 'AND')
1255 
1256         sql, params = self.as_sql()
1257         return 'EXISTS (%s)' % sql, params
1258 
1259     def explain_query(self):
1260         result = list(self.execute_sql())
1261         # Some backends return 1 item tuples with strings, and others return
1262         # tuples with integers and strings. Flatten them out into strings.
1263         output_formatter = json.dumps if self.query.explain_info.format == 'json' else str
1264         for row in result[0]:
1265             if not isinstance(row, str):
1266                 yield ' '.join(output_formatter(c) for c in row)
1267             else:
1268                 yield row
1269 
1270 
1271 class SQLInsertCompiler(SQLCompiler):
1272     returning_fields = None
1273     returning_params = tuple()
1274 
1275     def field_as_sql(self, field, val):
1276         """
1277         Take a field and a value intended to be saved on that field, and
1278         return placeholder SQL and accompanying params. Check for raw values,
1279         expressions, and fields with get_placeholder() defined in that order.
1280 
1281         When field is None, consider the value raw and use it as the
1282         placeholder, with no corresponding parameters returned.
1283         """
1284         if field is None:
1285             # A field value of None means the value is raw.
1286             sql, params = val, []
1287         elif hasattr(val, 'as_sql'):
1288             # This is an expression, let's compile it.
1289             sql, params = self.compile(val)
1290         elif hasattr(field, 'get_placeholder'):
1291             # Some fields (e.g. geo fields) need special munging before
1292             # they can be inserted.
1293             sql, params = field.get_placeholder(val, self, self.connection), [val]
1294         else:
1295             # Return the common case for the placeholder
1296             sql, params = '%s', [val]
1297 
1298         # The following hook is only used by Oracle Spatial, which sometimes
1299         # needs to yield 'NULL' and [] as its placeholder and params instead
1300         # of '%s' and [None]. The 'NULL' placeholder is produced earlier by
1301         # OracleOperations.get_geom_placeholder(). The following line removes
1302         # the corresponding None parameter. See ticket #10888.
1303         params = self.connection.ops.modify_insert_params(sql, params)
1304 
1305         return sql, params
1306 
1307     def prepare_value(self, field, value):
1308         """
1309         Prepare a value to be used in a query by resolving it if it is an
1310         expression and otherwise calling the field's get_db_prep_save().
1311         """
1312         if hasattr(value, 'resolve_expression'):
1313             value = value.resolve_expression(self.query, allow_joins=False, for_save=True)
1314             # Don't allow values containing Col expressions. They refer to
1315             # existing columns on a row, but in the case of insert the row
1316             # doesn't exist yet.
1317             if value.contains_column_references:
1318                 raise ValueError(
1319                     'Failed to insert expression "%s" on %s. F() expressions '
1320                     'can only be used to update, not to insert.' % (value, field)
1321                 )
1322             if value.contains_aggregate:
1323                 raise FieldError(
1324                     'Aggregate functions are not allowed in this query '
1325                     '(%s=%r).' % (field.name, value)
1326                 )
1327             if value.contains_over_clause:
1328                 raise FieldError(
1329                     'Window expressions are not allowed in this query (%s=%r).'
1330                     % (field.name, value)
1331                 )
1332         else:
1333             value = field.get_db_prep_save(value, connection=self.connection)
1334         return value
1335 
1336     def pre_save_val(self, field, obj):
1337         """
1338         Get the given field's value off the given obj. pre_save() is used for
1339         things like auto_now on DateTimeField. Skip it if this is a raw query.
1340         """
1341         if self.query.raw:
1342             return getattr(obj, field.attname)
1343         return field.pre_save(obj, add=True)
1344 
1345     def assemble_as_sql(self, fields, value_rows):
1346         """
1347         Take a sequence of N fields and a sequence of M rows of values, and
1348         generate placeholder SQL and parameters for each field and value.
1349         Return a pair containing:
1350          * a sequence of M rows of N SQL placeholder strings, and
1351          * a sequence of M rows of corresponding parameter values.
1352 
1353         Each placeholder string may contain any number of '%s' interpolation
1354         strings, and each parameter row will contain exactly as many params
1355         as the total number of '%s's in the corresponding placeholder row.
1356         """
1357         if not value_rows:
1358             return [], []
1359 
1360         # list of (sql, [params]) tuples for each object to be saved
1361         # Shape: [n_objs][n_fields][2]
1362         rows_of_fields_as_sql = (
1363             (self.field_as_sql(field, v) for field, v in zip(fields, row))
1364             for row in value_rows
1365         )
1366 
1367         # tuple like ([sqls], [[params]s]) for each object to be saved
1368         # Shape: [n_objs][2][n_fields]
1369         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
1370 
1371         # Extract separate lists for placeholders and params.
1372         # Each of these has shape [n_objs][n_fields]
1373         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
1374 
1375         # Params for each field are still lists, and need to be flattened.
1376         param_rows = [[p for ps in row for p in ps] for row in param_rows]
1377 
1378         return placeholder_rows, param_rows
1379 
1380     def as_sql(self):
1381         # We don't need quote_name_unless_alias() here, since these are all
1382         # going to be column names (so we can avoid the extra overhead).
1383         qn = self.connection.ops.quote_name
1384         opts = self.query.get_meta()
1385         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
1386         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
1387         fields = self.query.fields or [opts.pk]
1388         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
1389 
1390         if self.query.fields:
1391             value_rows = [
1392                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
1393                 for obj in self.query.objs
1394             ]
1395         else:
1396             # An empty object.
1397             value_rows = [[self.connection.ops.pk_default_value()] for _ in self.query.objs]
1398             fields = [None]
1399 
1400         # Currently the backends just accept values when generating bulk
1401         # queries and generate their own placeholders. Doing that isn't
1402         # necessary and it should be possible to use placeholders and
1403         # expressions in bulk inserts too.
1404         can_bulk = (not self.returning_fields and self.connection.features.has_bulk_insert)
1405 
1406         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
1407 
1408         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
1409             ignore_conflicts=self.query.ignore_conflicts
1410         )
1411         if self.returning_fields and self.connection.features.can_return_columns_from_insert:
1412             if self.connection.features.can_return_rows_from_bulk_insert:
1413                 result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
1414                 params = param_rows
1415             else:
1416                 result.append("VALUES (%s)" % ", ".join(placeholder_rows[0]))
1417                 params = [param_rows[0]]
1418             if ignore_conflicts_suffix_sql:
1419                 result.append(ignore_conflicts_suffix_sql)
1420             # Skip empty r_sql to allow subclasses to customize behavior for
1421             # 3rd party backends. Refs #19096.
1422             r_sql, self.returning_params = self.connection.ops.return_insert_columns(self.returning_fields)
1423             if r_sql:
1424                 result.append(r_sql)
1425                 params += [self.returning_params]
1426             return [(" ".join(result), tuple(chain.from_iterable(params)))]
1427 
1428         if can_bulk:
1429             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
1430             if ignore_conflicts_suffix_sql:
1431                 result.append(ignore_conflicts_suffix_sql)
1432             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
1433         else:
1434             if ignore_conflicts_suffix_sql:
1435                 result.append(ignore_conflicts_suffix_sql)
1436             return [
1437                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
1438                 for p, vals in zip(placeholder_rows, param_rows)
1439             ]
1440 
1441     def execute_sql(self, returning_fields=None):
1442         assert not (
1443             returning_fields and len(self.query.objs) != 1 and
1444             not self.connection.features.can_return_rows_from_bulk_insert
1445         )
1446         opts = self.query.get_meta()
1447         self.returning_fields = returning_fields
1448         with self.connection.cursor() as cursor:
1449             for sql, params in self.as_sql():
1450                 cursor.execute(sql, params)
1451             if not self.returning_fields:
1452                 return []
1453             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
1454                 rows = self.connection.ops.fetch_returned_insert_rows(cursor)
1455             elif self.connection.features.can_return_columns_from_insert:
1456                 assert len(self.query.objs) == 1
1457                 rows = [self.connection.ops.fetch_returned_insert_columns(
1458                     cursor, self.returning_params,
1459                 )]
1460             else:
1461                 rows = [(self.connection.ops.last_insert_id(
1462                     cursor, opts.db_table, opts.pk.column,
1463                 ),)]
1464         cols = [field.get_col(opts.db_table) for field in self.returning_fields]
1465         converters = self.get_converters(cols)
1466         if converters:
1467             rows = list(self.apply_converters(rows, converters))
1468         return rows
1469 
1470 
1471 class SQLDeleteCompiler(SQLCompiler):
1472     @cached_property
1473     def single_alias(self):
1474         # Ensure base table is in aliases.
1475         self.query.get_initial_alias()
1476         return sum(self.query.alias_refcount[t] > 0 for t in self.query.alias_map) == 1
1477 
1478     @classmethod
1479     def _expr_refs_base_model(cls, expr, base_model):
1480         if isinstance(expr, Query):
1481             return expr.model == base_model
1482         if not hasattr(expr, 'get_source_expressions'):
1483             return False
1484         return any(
1485             cls._expr_refs_base_model(source_expr, base_model)
1486             for source_expr in expr.get_source_expressions()
1487         )
1488 
1489     @cached_property
1490     def contains_self_reference_subquery(self):
1491         return any(
1492             self._expr_refs_base_model(expr, self.query.model)
1493             for expr in chain(self.query.annotations.values(), self.query.where.children)
1494         )
1495 
1496     def _as_sql(self, query):
1497         result = [
1498             'DELETE FROM %s' % self.quote_name_unless_alias(query.base_table)
1499         ]
1500         where, params = self.compile(query.where)
1501         if where:
1502             result.append('WHERE %s' % where)
1503         return ' '.join(result), tuple(params)
1504 
1505     def as_sql(self):
1506         """
1507         Create the SQL for this query. Return the SQL string and list of
1508         parameters.
1509         """
1510         if self.single_alias and not self.contains_self_reference_subquery:
1511             return self._as_sql(self.query)
1512         innerq = self.query.clone()
1513         innerq.__class__ = Query
1514         innerq.clear_select_clause()
1515         pk = self.query.model._meta.pk
1516         innerq.select = [
1517             pk.get_col(self.query.get_initial_alias())
1518         ]
1519         outerq = Query(self.query.model)
1520         if not self.connection.features.update_can_self_select:
1521             # Force the materialization of the inner query to allow reference
1522             # to the target table on MySQL.
1523             sql, params = innerq.get_compiler(connection=self.connection).as_sql()
1524             innerq = RawSQL('SELECT * FROM (%s) subquery' % sql, params)
1525         outerq.add_filter('pk__in', innerq)
1526         return self._as_sql(outerq)
1527 
1528 
1529 class SQLUpdateCompiler(SQLCompiler):
1530     def as_sql(self):
1531         """
1532         Create the SQL for this query. Return the SQL string and list of
1533         parameters.
1534         """
1535         self.pre_sql_setup()
1536         if not self.query.values:
1537             return '', ()
1538         qn = self.quote_name_unless_alias
1539         values, update_params = [], []
1540         for field, model, val in self.query.values:
1541             if hasattr(val, 'resolve_expression'):
1542                 val = val.resolve_expression(self.query, allow_joins=False, for_save=True)
1543                 if val.contains_aggregate:
1544                     raise FieldError(
1545                         'Aggregate functions are not allowed in this query '
1546                         '(%s=%r).' % (field.name, val)
1547                     )
1548                 if val.contains_over_clause:
1549                     raise FieldError(
1550                         'Window expressions are not allowed in this query '
1551                         '(%s=%r).' % (field.name, val)
1552                     )
1553             elif hasattr(val, 'prepare_database_save'):
1554                 if field.remote_field:
1555                     val = field.get_db_prep_save(
1556                         val.prepare_database_save(field),
1557                         connection=self.connection,
1558                     )
1559                 else:
1560                     raise TypeError(
1561                         "Tried to update field %s with a model instance, %r. "
1562                         "Use a value compatible with %s."
1563                         % (field, val, field.__class__.__name__)
1564                     )
1565             else:
1566                 val = field.get_db_prep_save(val, connection=self.connection)
1567 
1568             # Getting the placeholder for the field.
1569             if hasattr(field, 'get_placeholder'):
1570                 placeholder = field.get_placeholder(val, self, self.connection)
1571             else:
1572                 placeholder = '%s'
1573             name = field.column
1574             if hasattr(val, 'as_sql'):
1575                 sql, params = self.compile(val)
1576                 values.append('%s = %s' % (qn(name), placeholder % sql))
1577                 update_params.extend(params)
1578             elif val is not None:
1579                 values.append('%s = %s' % (qn(name), placeholder))
1580                 update_params.append(val)
1581             else:
1582                 values.append('%s = NULL' % qn(name))
1583         table = self.query.base_table
1584         result = [
1585             'UPDATE %s SET' % qn(table),
1586             ', '.join(values),
1587         ]
1588         where, params = self.compile(self.query.where)
1589         if where:
1590             result.append('WHERE %s' % where)
1591         return ' '.join(result), tuple(update_params + params)
1592 
1593     def execute_sql(self, result_type):
1594         """
1595         Execute the specified update. Return the number of rows affected by
1596         the primary update query. The "primary update query" is the first
1597         non-empty query that is executed. Row counts for any subsequent,
1598         related queries are not available.
1599         """
1600         cursor = super().execute_sql(result_type)
1601         try:
1602             rows = cursor.rowcount if cursor else 0
1603             is_empty = cursor is None
1604         finally:
1605             if cursor:
1606                 cursor.close()
1607         for query in self.query.get_related_updates():
1608             aux_rows = query.get_compiler(self.using).execute_sql(result_type)
1609             if is_empty and aux_rows:
1610                 rows = aux_rows
1611                 is_empty = False
1612         return rows
1613 
1614     def pre_sql_setup(self):
1615         """
1616         If the update depends on results from other tables, munge the "where"
1617         conditions to match the format required for (portable) SQL updates.
1618 
1619         If multiple updates are required, pull out the id values to update at
1620         this point so that they don't change as a result of the progressive
1621         updates.
1622         """
1623         refcounts_before = self.query.alias_refcount.copy()
1624         # Ensure base table is in the query
1625         self.query.get_initial_alias()
1626         count = self.query.count_active_tables()
1627         if not self.query.related_updates and count == 1:
1628             return
1629         query = self.query.chain(klass=Query)
1630         query.select_related = False
1631         query.clear_ordering(force=True)
1632         query.extra = {}
1633         query.select = []
1634         query.add_fields([query.get_meta().pk.name])
1635         super().pre_sql_setup()
1636 
1637         must_pre_select = count > 1 and not self.connection.features.update_can_self_select
1638 
1639         # Now we adjust the current query: reset the where clause and get rid
1640         # of all the tables we don't need (since they're in the sub-select).
1641         self.query.clear_where()
1642         if self.query.related_updates or must_pre_select:
1643             # Either we're using the idents in multiple update queries (so
1644             # don't want them to change), or the db backend doesn't support
1645             # selecting from the updating table (e.g. MySQL).
1646             idents = []
1647             for rows in query.get_compiler(self.using).execute_sql(MULTI):
1648                 idents.extend(r[0] for r in rows)
1649             self.query.add_filter('pk__in', idents)
1650             self.query.related_ids = idents
1651         else:
1652             # The fast path. Filters and updates in one query.
1653             self.query.add_filter('pk__in', query)
1654         self.query.reset_refcounts(refcounts_before)
1655 
1656 
1657 class SQLAggregateCompiler(SQLCompiler):
1658     def as_sql(self):
1659         """
1660         Create the SQL for this query. Return the SQL string and list of
1661         parameters.
1662         """
1663         sql, params = [], []
1664         for annotation in self.query.annotation_select.values():
1665             ann_sql, ann_params = self.compile(annotation)
1666             ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)
1667             sql.append(ann_sql)
1668             params.extend(ann_params)
1669         self.col_count = len(self.query.annotation_select)
1670         sql = ', '.join(sql)
1671         params = tuple(params)
1672 
1673         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(
1674             self.using, elide_empty=self.elide_empty,
1675         ).as_sql(with_col_aliases=True)
1676         sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)
1677         params = params + inner_query_params
1678         return sql, params
1679 
1680 
1681 def cursor_iter(cursor, sentinel, col_count, itersize):
1682     """
1683     Yield blocks of rows from a cursor and ensure the cursor is closed when
1684     done.
1685     """
1686     try:
1687         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
1688             yield rows if col_count is None else [r[:col_count] for r in rows]
1689     finally:
1690         cursor.close()

</code><intended_behavior>The issue could stem from how combined queries (union or bitwise OR) are compiled when they include references to `OuterRef`. This file's method(s) responsible for compiling these queries needs to be reviewed for potential adjustments.</intended_behavior>]
2025-10-17 23:00:52.669 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 23:00:52.670 | INFO     | Search-only: skipping patch selection
2025-10-17 23:00:52.932 | INFO     | Task django__django-11692 completed successfully.
2025-10-17 23:00:52.933 | INFO     | No patch generated. You can try running ACR again.
