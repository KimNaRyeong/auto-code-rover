diff --git a/sympy/functions/combinatorial/factorials.py b/sympy/functions/combinatorial/factorials.py
--- a/sympy/functions/combinatorial/factorials.py
+++ b/sympy/functions/combinatorial/factorials.py
@@ -13,9 +13,7 @@
 from sympy.core.compatibility import reduce, range, HAS_GMPY
 from sympy.core.cache import cacheit
 
-from sympy.polys.polytools import poly_from_expr
-from sympy.polys.polyerrors import PolificationFailed
-
+from sympy.polys.polytools import Poly
 
 class CombinatorialFunction(Function):
     """Base class for combinatorial functions. """
@@ -408,7 +406,8 @@ def _eval_rewrite_as_gamma(self, n):
 
 
 class RisingFactorial(CombinatorialFunction):
-    """Rising factorial (also called Pochhammer symbol) is a double valued
+    """
+    Rising factorial (also called Pochhammer symbol) is a double valued
     function arising in concrete mathematics, hypergeometric functions
     and series expansions. It is defined by:
 
@@ -418,15 +417,16 @@ class RisingFactorial(CombinatorialFunction):
     more information check "Concrete mathematics" by Graham, pp. 66
     or visit http://mathworld.wolfram.com/RisingFactorial.html page.
 
-    When x is a polynomial f of a single variable y of order >= 1,
-    rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in
-    Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
-    Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
+    When x is a Poly instance of degree >= 1 with a single variable,
+    rf(x,k) = x(y) * x(y+1) * ... * x(y+k-1), where y is the variable of x.
+    This is as described in Peter Paule, "Greatest Factorial Factorization and
+    Symbolic Summation", Journal of Symbolic Computation, vol. 20, pp.
+    235-268, 1995.
 
     Examples
     ========
 
-    >>> from sympy import rf, symbols, factorial, ff, binomial
+    >>> from sympy import rf, symbols, factorial, ff, binomial, Poly
     >>> from sympy.abc import x
     >>> n, k = symbols('n k', integer=True)
     >>> rf(x, 0)
@@ -435,7 +435,7 @@ class RisingFactorial(CombinatorialFunction):
     120
     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)
     True
-    >>> rf(x**3, 2)
+    >>> rf(Poly(x**3, x), 2)
     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')
 
     Rewrite
@@ -456,6 +456,7 @@ class RisingFactorial(CombinatorialFunction):
     ==========
 
     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol
+
     """
 
     @classmethod
@@ -480,37 +481,34 @@ def eval(cls, x, k):
                         else:
                             return S.Infinity
                     else:
-                        try:
-                            F, opt = poly_from_expr(x)
-                        except PolificationFailed:
-                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
-                        if len(opt.gens) > 1 or F.degree() <= 1:
-                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
+                        if isinstance(x, Poly):
+                            gens = x.gens
+                            if len(gens)!= 1:
+                                raise ValueError("rf only defined for polynomials on one generator")
+                            else:
+                                return reduce(lambda r, i:
+                                              r*(x.shift(i).expand()),
+                                              range(0, int(k)), 1)
                         else:
-                            v = opt.gens[0]
-                            return reduce(lambda r, i:
-                                          r*(F.subs(v, v + i).expand()),
-                                          range(0, int(k)), 1)
+                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
+
                 else:
                     if x is S.Infinity:
                         return S.Infinity
                     elif x is S.NegativeInfinity:
                         return S.Infinity
                     else:
-                        try:
-                            F, opt = poly_from_expr(x)
-                        except PolificationFailed:
-                            return 1/reduce(lambda r, i:
-                                            r*(x - i),
-                                            range(1, abs(int(k)) + 1), 1)
-                        if len(opt.gens) > 1 or F.degree() <= 1:
-                            return 1/reduce(lambda r, i:
-                                            r*(x - i),
-                                            range(1, abs(int(k)) + 1), 1)
+                        if isinstance(x, Poly):
+                            gens = x.gens
+                            if len(gens)!= 1:
+                                raise ValueError("rf only defined for polynomials on one generator")
+                            else:
+                                return 1/reduce(lambda r, i:
+                                                r*(x.shift(-i).expand()),
+                                                range(1, abs(int(k)) + 1), 1)
                         else:
-                            v = opt.gens[0]
                             return 1/reduce(lambda r, i:
-                                            r*(F.subs(v, v - i).expand()),
+                                            r*(x - i),
                                             range(1, abs(int(k)) + 1), 1)
 
     def _eval_rewrite_as_gamma(self, x, k):
@@ -538,7 +536,8 @@ def _sage_(self):
 
 
 class FallingFactorial(CombinatorialFunction):
-    """Falling factorial (related to rising factorial) is a double valued
+    """
+    Falling factorial (related to rising factorial) is a double valued
     function arising in concrete mathematics, hypergeometric functions
     and series expansions. It is defined by
 
@@ -548,12 +547,13 @@ class FallingFactorial(CombinatorialFunction):
     more information check "Concrete mathematics" by Graham, pp. 66
     or visit http://mathworld.wolfram.com/FallingFactorial.html page.
 
-    When x is a polynomial f of a single variable y of order >= 1,
-    ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in
-    Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
-    Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
+    When x is a Poly instance of degree >= 1 with single variable,
+    ff(x,k) = x(y) * x(y-1) * ... * x(y-k+1), where y is the variable of x.
+    This is as described in Peter Paule, "Greatest Factorial Factorization and
+    Symbolic Summation", Journal of Symbolic Computation, vol. 20, pp.
+    235-268, 1995.
 
-    >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols
+    >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols, Poly
     >>> from sympy.abc import x, k
     >>> n, m = symbols('n m', integer=True)
     >>> ff(x, 0)
@@ -562,7 +562,7 @@ class FallingFactorial(CombinatorialFunction):
     120
     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)
     True
-    >>> ff(x**2, 2)
+    >>> ff(Poly(x**2, x), 2)
     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')
     >>> ff(n, n)
     factorial(n)
@@ -587,6 +587,7 @@ class FallingFactorial(CombinatorialFunction):
     ==========
 
     .. [1] http://mathworld.wolfram.com/FallingFactorial.html
+
     """
 
     @classmethod
@@ -611,18 +612,16 @@ def eval(cls, x, k):
                         else:
                             return S.Infinity
                     else:
-                        try:
-                            F, opt = poly_from_expr(x)
-                        except PolificationFailed:
-                            return reduce(lambda r, i: r*(x - i),
-                                          range(0, int(k)), 1)
-                        if len(opt.gens) > 1 or F.degree() <= 1:
-                            return reduce(lambda r, i: r*(x - i),
-                                          range(0, int(k)), 1)
+                        if isinstance(x, Poly):
+                            gens = x.gens
+                            if len(gens)!= 1:
+                                raise ValueError("ff only defined for polynomials on one generator")
+                            else:
+                                return reduce(lambda r, i:
+                                              r*(x.shift(-i).expand()),
+                                              range(0, int(k)), 1)
                         else:
-                            v = opt.gens[0]
-                            return reduce(lambda r, i:
-                                          r*(F.subs(v, v - i).expand()),
+                            return reduce(lambda r, i: r*(x - i),
                                           range(0, int(k)), 1)
                 else:
                     if x is S.Infinity:
@@ -630,18 +629,16 @@ def eval(cls, x, k):
                     elif x is S.NegativeInfinity:
                         return S.Infinity
                     else:
-                        try:
-                            F, opt = poly_from_expr(x)
-                        except PolificationFailed:
-                            return 1/reduce(lambda r, i: r*(x + i),
-                                            range(1, abs(int(k)) + 1), 1)
-                        if len(opt.gens) > 1 or F.degree() <= 1:
-                            return 1/reduce(lambda r, i: r*(x + i),
-                                            range(1, abs(int(k)) + 1), 1)
+                        if isinstance(x, Poly):
+                            gens = x.gens
+                            if len(gens)!= 1:
+                                raise ValueError("rf only defined for polynomials on one generator")
+                            else:
+                                return 1/reduce(lambda r, i:
+                                                r*(x.shift(i).expand()),
+                                                range(1, abs(int(k)) + 1), 1)
                         else:
-                            v = opt.gens[0]
-                            return 1/reduce(lambda r, i:
-                                            r*(F.subs(v, v + i).expand()),
+                            return 1/reduce(lambda r, i: r*(x + i),
                                             range(1, abs(int(k)) + 1), 1)
 
     def _eval_rewrite_as_gamma(self, x, k):
diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py
--- a/sympy/polys/polytools.py
+++ b/sympy/polys/polytools.py
@@ -5604,27 +5604,30 @@ def gff_list(f, *gens, **args):
     """
     Compute a list of greatest factorial factors of ``f``.
 
+    Note that the input to ff() and rf() should be Poly instances to use the
+    definitions here.
+
     Examples
     ========
 
-    >>> from sympy import gff_list, ff
+    >>> from sympy import gff_list, ff, Poly
     >>> from sympy.abc import x
 
-    >>> f = x**5 + 2*x**4 - x**3 - 2*x**2
+    >>> f = Poly(x**5 + 2*x**4 - x**3 - 2*x**2, x)
 
     >>> gff_list(f)
-    [(x, 1), (x + 2, 4)]
+    [(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)]
 
-    >>> (ff(x, 1)*ff(x + 2, 4)).expand() == f
+    >>> (ff(Poly(x), 1)*ff(Poly(x + 2), 4)).expand() == f
     True
 
-    >>> f = x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 - \
-        1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x
+    >>> f = Poly(x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 - \
+        1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x, x)
 
     >>> gff_list(f)
-    [(x**3 + 7, 2), (x**2 + 5*x, 3)]
+    [(Poly(x**3 + 7, x, domain='ZZ'), 2), (Poly(x**2 + 5*x, x, domain='ZZ'), 3)]
 
-    >>> ff(x**3 + 7, 2)*ff(x**2 + 5*x, 3) == f
+    >>> ff(Poly(x**3 + 7, x), 2)*ff(Poly(x**2 + 5*x, x), 3) == f
     True
 
     """
