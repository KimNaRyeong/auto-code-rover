2025-10-18 02:37:13.994 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 02:37:19.211 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=375, output_tokens=12, cost=0.004110
2025-10-18 02:37:19.218 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 02:37:19.222 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:37:30.598 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=682, output_tokens=262, cost=0.014680
2025-10-18 02:37:30.604 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:37:35.307 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=616, output_tokens=80, cost=0.008560
2025-10-18 02:37:35.308 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("lib/matplotlib/colorbar.py", 489, 4)': old result is ['lib/matplotlib/colorbar.py', '489', '4'], new result  is ['lib/matplotlib/colorbar.py', 489, 4]
2025-10-18 02:37:35.310 | DEBUG    | Extracted a valid json.
2025-10-18 02:37:35.310 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "get_code_around_line(\"lib/matplotlib/colorbar.py\", 489, 4)",
        "search_method_in_file(\"update_ticks\", \"lib/matplotlib/colorbar.py\")",
        "search_method_in_class(\"_set_formatter\", \"Axis\")",
        "search_code(\"callable directly\")"
    ],
    "bug_locations": []
}
2025-10-18 02:37:35.313 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("lib/matplotlib/colorbar.py", 489, 4)': old result is ['lib/matplotlib/colorbar.py', '489', '4'], new result  is ['lib/matplotlib/colorbar.py', 489, 4]
2025-10-18 02:37:35.368 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 02:37:35.369 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 02:37:49.922 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1874, output_tokens=714, cost=0.040160
2025-10-18 02:37:49.934 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:37:57.141 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2804, output_tokens=304, cost=0.037160
2025-10-18 02:37:57.149 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:38:03.747 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=658, output_tokens=270, cost=0.014680
2025-10-18 02:38:03.748 | DEBUG    | Extracted a valid json.
2025-10-18 02:38:03.748 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/colorbar.py",
            "class": "Colorbar",
            "method": "__init__",
            "intended_behavior": "The `__init__` method should no longer explicitly handle format strings using `ticker.FormatStrFormatter` when a format is provided as a string. Instead, it should leverage the updated logic in the `Axis` class, allowing for a consistent use of new style format strings. The handling for if `format` is a callable or `None` should remain as is to preserve backward compatibility and existing functionality."
        },
        {
            "file": "lib/matplotlib/colorbar.py",
            "class": "Colorbar",
            "method": "N/A",
            "intended_behavior": "Ensure that the colorbar can seamlessly integrate with the `Axis` class's format handling mechanisms, especially concerning `_set_formatter` in `axis.py`. This integration should support both new style format strings and direct callables as formatters, aligning with the `Axis` class's capabilities and the enhancements from #16715. Additionally, documentation or helper comments might need to be updated to reflect this new approach and guide users away from outdated formatting conventions towards the new standard."
        }
    ]
}
2025-10-18 02:38:03.760 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>__init__</method>
<code>
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla

</code><intended_behavior>The `__init__` method should no longer explicitly handle format strings using `ticker.FormatStrFormatter` when a format is provided as a string. Instead, it should leverage the updated logic in the `Axis` class, allowing for a consistent use of new style format strings. The handling for if `format` is a callable or `None` should remain as is to preserve backward compatibility and existing functionality.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>None</method>
<code>
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>None</method>
<code>
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]

</code><intended_behavior>Ensure that the colorbar can seamlessly integrate with the `Axis` class's format handling mechanisms, especially concerning `_set_formatter` in `axis.py`. This integration should support both new style format strings and direct callables as formatters, aligning with the `Axis` class's capabilities and the enhancements from #16715. Additionally, documentation or helper comments might need to be updated to reflect this new approach and guide users away from outdated formatting conventions towards the new standard.</intended_behavior>]
2025-10-18 02:38:03.761 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>__init__</method>
<code>
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla

</code><intended_behavior>The `__init__` method should no longer explicitly handle format strings using `ticker.FormatStrFormatter` when a format is provided as a string. Instead, it should leverage the updated logic in the `Axis` class, allowing for a consistent use of new style format strings. The handling for if `format` is a callable or `None` should remain as is to preserve backward compatibility and existing functionality.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>None</method>
<code>
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>None</method>
<code>
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]

</code><intended_behavior>Ensure that the colorbar can seamlessly integrate with the `Axis` class's format handling mechanisms, especially concerning `_set_formatter` in `axis.py`. This integration should support both new style format strings and direct callables as formatters, aligning with the `Axis` class's capabilities and the enhancements from #16715. Additionally, documentation or helper comments might need to be updated to reflect this new approach and guide users away from outdated formatting conventions towards the new standard.</intended_behavior>]
2025-10-18 02:38:03.761 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 02:38:03.761 | INFO     | Search-only: skipping patch selection
2025-10-18 02:38:03.949 | INFO     | Task matplotlib__matplotlib-21542 completed successfully.
2025-10-18 02:38:03.950 | INFO     | No patch generated. You can try running ACR again.
