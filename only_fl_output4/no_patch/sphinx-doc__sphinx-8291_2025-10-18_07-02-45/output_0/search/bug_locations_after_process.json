[
    {
        "rel_file_path": "sphinx/ext/napoleon/docstring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.4/sphinx/ext/napoleon/docstring.py",
        "start": 1,
        "end": 1267,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon.docstring\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5 \n6     Classes for docstring parsing and formatting.\n7 \n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import collections\n14 import inspect\n15 import re\n16 from functools import partial\n17 from typing import Any, Callable, Dict, List, Tuple, Union\n18 \n19 from sphinx.application import Sphinx\n20 from sphinx.config import Config as SphinxConfig\n21 from sphinx.ext.napoleon.iterators import modify_iter\n22 from sphinx.locale import _, __\n23 from sphinx.util import logging\n24 \n25 if False:\n26     # For type annotation\n27     from typing import Type  # for python3.5.1\n28 \n29 \n30 logger = logging.getLogger(__name__)\n31 \n32 _directive_regex = re.compile(r'\\.\\. \\S+::')\n33 _google_section_regex = re.compile(r'^(\\s|\\w)+:\\s*$')\n34 _google_typed_arg_regex = re.compile(r'(.+?)\\(\\s*(.*[^\\s]+)\\s*\\)')\n35 _numpy_section_regex = re.compile(r'^[=\\-`:\\'\"~^_*+#<>]{2,}\\s*$')\n36 _single_colon_regex = re.compile(r'(?<!:):(?!:)')\n37 _xref_or_code_regex = re.compile(\n38     r'((?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'\n39     r'(?:``.+?``))')\n40 _xref_regex = re.compile(\n41     r'(?:(?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)'\n42 )\n43 _bullet_list_regex = re.compile(r'^(\\*|\\+|\\-)(\\s+\\S|\\s*$)')\n44 _enumerated_list_regex = re.compile(\n45     r'^(?P<paren>\\()?'\n46     r'(\\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'\n47     r'(?(paren)\\)|\\.)(\\s+\\S|\\s*$)')\n48 _token_regex = re.compile(\n49     r\"(,\\sor\\s|\\sor\\s|\\sof\\s|:\\s|\\sto\\s|,\\sand\\s|\\sand\\s|,\\s\"\n50     r\"|[{]|[}]\"\n51     r'|\"(?:\\\\\"|[^\"])*\"'\n52     r\"|'(?:\\\\'|[^'])*')\"\n53 )\n54 _default_regex = re.compile(\n55     r\"^default[^_0-9A-Za-z].*$\",\n56 )\n57 _SINGLETONS = (\"None\", \"True\", \"False\", \"Ellipsis\")\n58 \n59 \n60 class GoogleDocstring:\n61     \"\"\"Convert Google style docstrings to reStructuredText.\n62 \n63     Parameters\n64     ----------\n65     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n66         The docstring to parse, given either as a string or split into\n67         individual lines.\n68     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n69         The configuration settings to use. If not given, defaults to the\n70         config object on `app`; or if `app` is not given defaults to the\n71         a new :class:`sphinx.ext.napoleon.Config` object.\n72 \n73 \n74     Other Parameters\n75     ----------------\n76     app : :class:`sphinx.application.Sphinx`, optional\n77         Application object representing the Sphinx process.\n78     what : :obj:`str`, optional\n79         A string specifying the type of the object to which the docstring\n80         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n81         \"method\", \"attribute\".\n82     name : :obj:`str`, optional\n83         The fully qualified name of the object.\n84     obj : module, class, exception, function, method, or attribute\n85         The object to which the docstring belongs.\n86     options : :class:`sphinx.ext.autodoc.Options`, optional\n87         The options given to the directive: an object with attributes\n88         inherited_members, undoc_members, show_inheritance and noindex that\n89         are True if the flag option of same name was given to the auto\n90         directive.\n91 \n92 \n93     Example\n94     -------\n95     >>> from sphinx.ext.napoleon import Config\n96     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n97     >>> docstring = '''One line summary.\n98     ...\n99     ... Extended description.\n100     ...\n101     ... Args:\n102     ...   arg1(int): Description of `arg1`\n103     ...   arg2(str): Description of `arg2`\n104     ... Returns:\n105     ...   str: Description of return value.\n106     ... '''\n107     >>> print(GoogleDocstring(docstring, config))\n108     One line summary.\n109     <BLANKLINE>\n110     Extended description.\n111     <BLANKLINE>\n112     :param arg1: Description of `arg1`\n113     :type arg1: int\n114     :param arg2: Description of `arg2`\n115     :type arg2: str\n116     <BLANKLINE>\n117     :returns: Description of return value.\n118     :rtype: str\n119     <BLANKLINE>\n120 \n121     \"\"\"\n122 \n123     _name_rgx = re.compile(r\"^\\s*((?::(?P<role>\\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|\"\n124                            r\" (?P<name2>~?[a-zA-Z0-9_.-]+))\\s*\", re.X)\n125 \n126     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n127                  app: Sphinx = None, what: str = '', name: str = '',\n128                  obj: Any = None, options: Any = None) -> None:\n129         self._config = config\n130         self._app = app\n131 \n132         if not self._config:\n133             from sphinx.ext.napoleon import Config\n134             self._config = self._app.config if self._app else Config()  # type: ignore\n135 \n136         if not what:\n137             if inspect.isclass(obj):\n138                 what = 'class'\n139             elif inspect.ismodule(obj):\n140                 what = 'module'\n141             elif callable(obj):\n142                 what = 'function'\n143             else:\n144                 what = 'object'\n145 \n146         self._what = what\n147         self._name = name\n148         self._obj = obj\n149         self._opt = options\n150         if isinstance(docstring, str):\n151             lines = docstring.splitlines()\n152         else:\n153             lines = docstring\n154         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())\n155         self._parsed_lines = []  # type: List[str]\n156         self._is_in_section = False\n157         self._section_indent = 0\n158         if not hasattr(self, '_directive_sections'):\n159             self._directive_sections = []  # type: List[str]\n160         if not hasattr(self, '_sections'):\n161             self._sections = {\n162                 'args': self._parse_parameters_section,\n163                 'arguments': self._parse_parameters_section,\n164                 'attention': partial(self._parse_admonition, 'attention'),\n165                 'attributes': self._parse_attributes_section,\n166                 'caution': partial(self._parse_admonition, 'caution'),\n167                 'danger': partial(self._parse_admonition, 'danger'),\n168                 'error': partial(self._parse_admonition, 'error'),\n169                 'example': self._parse_examples_section,\n170                 'examples': self._parse_examples_section,\n171                 'hint': partial(self._parse_admonition, 'hint'),\n172                 'important': partial(self._parse_admonition, 'important'),\n173                 'keyword args': self._parse_keyword_arguments_section,\n174                 'keyword arguments': self._parse_keyword_arguments_section,\n175                 'methods': self._parse_methods_section,\n176                 'note': partial(self._parse_admonition, 'note'),\n177                 'notes': self._parse_notes_section,\n178                 'other parameters': self._parse_other_parameters_section,\n179                 'parameters': self._parse_parameters_section,\n180                 'return': self._parse_returns_section,\n181                 'returns': self._parse_returns_section,\n182                 'raise': self._parse_raises_section,\n183                 'raises': self._parse_raises_section,\n184                 'references': self._parse_references_section,\n185                 'see also': self._parse_see_also_section,\n186                 'tip': partial(self._parse_admonition, 'tip'),\n187                 'todo': partial(self._parse_admonition, 'todo'),\n188                 'warning': partial(self._parse_admonition, 'warning'),\n189                 'warnings': partial(self._parse_admonition, 'warning'),\n190                 'warn': self._parse_warns_section,\n191                 'warns': self._parse_warns_section,\n192                 'yield': self._parse_yields_section,\n193                 'yields': self._parse_yields_section,\n194             }  # type: Dict[str, Callable]\n195 \n196         self._load_custom_sections()\n197 \n198         self._parse()\n199 \n200     def __str__(self) -> str:\n201         \"\"\"Return the parsed docstring in reStructuredText format.\n202 \n203         Returns\n204         -------\n205         unicode\n206             Unicode version of the docstring.\n207 \n208         \"\"\"\n209         return '\\n'.join(self.lines())\n210 \n211     def lines(self) -> List[str]:\n212         \"\"\"Return the parsed lines of the docstring in reStructuredText format.\n213 \n214         Returns\n215         -------\n216         list(str)\n217             The lines of the docstring in a list.\n218 \n219         \"\"\"\n220         return self._parsed_lines\n221 \n222     def _consume_indented_block(self, indent: int = 1) -> List[str]:\n223         lines = []\n224         line = self._line_iter.peek()\n225         while(not self._is_section_break() and\n226               (not line or self._is_indented(line, indent))):\n227             lines.append(next(self._line_iter))\n228             line = self._line_iter.peek()\n229         return lines\n230 \n231     def _consume_contiguous(self) -> List[str]:\n232         lines = []\n233         while (self._line_iter.has_next() and\n234                self._line_iter.peek() and\n235                not self._is_section_header()):\n236             lines.append(next(self._line_iter))\n237         return lines\n238 \n239     def _consume_empty(self) -> List[str]:\n240         lines = []\n241         line = self._line_iter.peek()\n242         while self._line_iter.has_next() and not line:\n243             lines.append(next(self._line_iter))\n244             line = self._line_iter.peek()\n245         return lines\n246 \n247     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n248                        ) -> Tuple[str, str, List[str]]:\n249         line = next(self._line_iter)\n250 \n251         before, colon, after = self._partition_field_on_colon(line)\n252         _name, _type, _desc = before, '', after\n253 \n254         if parse_type:\n255             match = _google_typed_arg_regex.match(before)\n256             if match:\n257                 _name = match.group(1).strip()\n258                 _type = match.group(2)\n259 \n260         _name = self._escape_args_and_kwargs(_name)\n261 \n262         if prefer_type and not _type:\n263             _type, _name = _name, _type\n264         indent = self._get_indent(line) + 1\n265         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))\n266         _descs = self.__class__(_descs, self._config).lines()\n267         return _name, _type, _descs\n268 \n269     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False,\n270                         multiple: bool = False) -> List[Tuple[str, str, List[str]]]:\n271         self._consume_empty()\n272         fields = []\n273         while not self._is_section_break():\n274             _name, _type, _desc = self._consume_field(parse_type, prefer_type)\n275             if multiple and _name:\n276                 for name in _name.split(\",\"):\n277                     fields.append((name.strip(), _type, _desc))\n278             elif _name or _type or _desc:\n279                 fields.append((_name, _type, _desc,))\n280         return fields\n281 \n282     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:\n283         line = next(self._line_iter)\n284         _type, colon, _desc = self._partition_field_on_colon(line)\n285         if not colon or not _desc:\n286             _type, _desc = _desc, _type\n287             _desc += colon\n288         _descs = [_desc] + self._dedent(self._consume_to_end())\n289         _descs = self.__class__(_descs, self._config).lines()\n290         return _type, _descs\n291 \n292     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n293         lines = self._dedent(self._consume_to_next_section())\n294         if lines:\n295             before, colon, after = self._partition_field_on_colon(lines[0])\n296             _name, _type, _desc = '', '', lines\n297 \n298             if colon:\n299                 if after:\n300                     _desc = [after] + lines[1:]\n301                 else:\n302                     _desc = lines[1:]\n303 \n304                 _type = before\n305 \n306             _desc = self.__class__(_desc, self._config).lines()\n307             return [(_name, _type, _desc,)]\n308         else:\n309             return []\n310 \n311     def _consume_usage_section(self) -> List[str]:\n312         lines = self._dedent(self._consume_to_next_section())\n313         return lines\n314 \n315     def _consume_section_header(self) -> str:\n316         section = next(self._line_iter)\n317         stripped_section = section.strip(':')\n318         if stripped_section.lower() in self._sections:\n319             section = stripped_section\n320         return section\n321 \n322     def _consume_to_end(self) -> List[str]:\n323         lines = []\n324         while self._line_iter.has_next():\n325             lines.append(next(self._line_iter))\n326         return lines\n327 \n328     def _consume_to_next_section(self) -> List[str]:\n329         self._consume_empty()\n330         lines = []\n331         while not self._is_section_break():\n332             lines.append(next(self._line_iter))\n333         return lines + self._consume_empty()\n334 \n335     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:\n336         if full:\n337             return [line.lstrip() for line in lines]\n338         else:\n339             min_indent = self._get_min_indent(lines)\n340             return [line[min_indent:] for line in lines]\n341 \n342     def _escape_args_and_kwargs(self, name: str) -> str:\n343         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):\n344             name = name[:-1] + r'\\_'\n345 \n346         if name[:2] == '**':\n347             return r'\\*\\*' + name[2:]\n348         elif name[:1] == '*':\n349             return r'\\*' + name[1:]\n350         else:\n351             return name\n352 \n353     def _fix_field_desc(self, desc: List[str]) -> List[str]:\n354         if self._is_list(desc):\n355             desc = [''] + desc\n356         elif desc[0].endswith('::'):\n357             desc_block = desc[1:]\n358             indent = self._get_indent(desc[0])\n359             block_indent = self._get_initial_indent(desc_block)\n360             if block_indent > indent:\n361                 desc = [''] + desc\n362             else:\n363                 desc = ['', desc[0]] + self._indent(desc_block, 4)\n364         return desc\n365 \n366     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:\n367         lines = self._strip_empty(lines)\n368         if len(lines) == 1:\n369             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']\n370         elif lines:\n371             lines = self._indent(self._dedent(lines), 3)\n372             return ['.. %s::' % admonition, ''] + lines + ['']\n373         else:\n374             return ['.. %s::' % admonition, '']\n375 \n376     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:\n377         if lines:\n378             if padding is None:\n379                 padding = ' ' * len(prefix)\n380             result_lines = []\n381             for i, line in enumerate(lines):\n382                 if i == 0:\n383                     result_lines.append((prefix + line).rstrip())\n384                 elif line:\n385                     result_lines.append(padding + line)\n386                 else:\n387                     result_lines.append('')\n388             return result_lines\n389         else:\n390             return [prefix]\n391 \n392     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],\n393                                 field_role: str = 'param', type_role: str = 'type'\n394                                 ) -> List[str]:\n395         lines = []\n396         for _name, _type, _desc in fields:\n397             _desc = self._strip_empty(_desc)\n398             if any(_desc):\n399                 _desc = self._fix_field_desc(_desc)\n400                 field = ':%s %s: ' % (field_role, _name)\n401                 lines.extend(self._format_block(field, _desc))\n402             else:\n403                 lines.append(':%s %s:' % (field_role, _name))\n404 \n405             if _type:\n406                 lines.append(':%s %s: %s' % (type_role, _name, _type))\n407         return lines + ['']\n408 \n409     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n410         _desc = self._strip_empty(_desc)\n411         has_desc = any(_desc)\n412         separator = ' -- ' if has_desc else ''\n413         if _name:\n414             if _type:\n415                 if '`' in _type:\n416                     field = '**%s** (%s)%s' % (_name, _type, separator)\n417                 else:\n418                     field = '**%s** (*%s*)%s' % (_name, _type, separator)\n419             else:\n420                 field = '**%s**%s' % (_name, separator)\n421         elif _type:\n422             if '`' in _type:\n423                 field = '%s%s' % (_type, separator)\n424             else:\n425                 field = '*%s*%s' % (_type, separator)\n426         else:\n427             field = ''\n428 \n429         if has_desc:\n430             _desc = self._fix_field_desc(_desc)\n431             if _desc[0]:\n432                 return [field + _desc[0]] + _desc[1:]\n433             else:\n434                 return [field] + _desc\n435         else:\n436             return [field]\n437 \n438     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]\n439                        ) -> List[str]:\n440         field_type = ':%s:' % field_type.strip()\n441         padding = ' ' * len(field_type)\n442         multi = len(fields) > 1\n443         lines = []  # type: List[str]\n444         for _name, _type, _desc in fields:\n445             field = self._format_field(_name, _type, _desc)\n446             if multi:\n447                 if lines:\n448                     lines.extend(self._format_block(padding + ' * ', field))\n449                 else:\n450                     lines.extend(self._format_block(field_type + ' * ', field))\n451             else:\n452                 lines.extend(self._format_block(field_type + ' ', field))\n453         if lines and lines[-1]:\n454             lines.append('')\n455         return lines\n456 \n457     def _get_current_indent(self, peek_ahead: int = 0) -> int:\n458         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n459         while line != self._line_iter.sentinel:\n460             if line:\n461                 return self._get_indent(line)\n462             peek_ahead += 1\n463             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n464         return 0\n465 \n466     def _get_indent(self, line: str) -> int:\n467         for i, s in enumerate(line):\n468             if not s.isspace():\n469                 return i\n470         return len(line)\n471 \n472     def _get_initial_indent(self, lines: List[str]) -> int:\n473         for line in lines:\n474             if line:\n475                 return self._get_indent(line)\n476         return 0\n477 \n478     def _get_min_indent(self, lines: List[str]) -> int:\n479         min_indent = None\n480         for line in lines:\n481             if line:\n482                 indent = self._get_indent(line)\n483                 if min_indent is None:\n484                     min_indent = indent\n485                 elif indent < min_indent:\n486                     min_indent = indent\n487         return min_indent or 0\n488 \n489     def _indent(self, lines: List[str], n: int = 4) -> List[str]:\n490         return [(' ' * n) + line for line in lines]\n491 \n492     def _is_indented(self, line: str, indent: int = 1) -> bool:\n493         for i, s in enumerate(line):\n494             if i >= indent:\n495                 return True\n496             elif not s.isspace():\n497                 return False\n498         return False\n499 \n500     def _is_list(self, lines: List[str]) -> bool:\n501         if not lines:\n502             return False\n503         if _bullet_list_regex.match(lines[0]):\n504             return True\n505         if _enumerated_list_regex.match(lines[0]):\n506             return True\n507         if len(lines) < 2 or lines[0].endswith('::'):\n508             return False\n509         indent = self._get_indent(lines[0])\n510         next_indent = indent\n511         for line in lines[1:]:\n512             if line:\n513                 next_indent = self._get_indent(line)\n514                 break\n515         return next_indent > indent\n516 \n517     def _is_section_header(self) -> bool:\n518         section = self._line_iter.peek().lower()\n519         match = _google_section_regex.match(section)\n520         if match and section.strip(':') in self._sections:\n521             header_indent = self._get_indent(section)\n522             section_indent = self._get_current_indent(peek_ahead=1)\n523             return section_indent > header_indent\n524         elif self._directive_sections:\n525             if _directive_regex.match(section):\n526                 for directive_section in self._directive_sections:\n527                     if section.startswith(directive_section):\n528                         return True\n529         return False\n530 \n531     def _is_section_break(self) -> bool:\n532         line = self._line_iter.peek()\n533         return (not self._line_iter.has_next() or\n534                 self._is_section_header() or\n535                 (self._is_in_section and\n536                     line and\n537                     not self._is_indented(line, self._section_indent)))\n538 \n539     def _load_custom_sections(self) -> None:\n540         if self._config.napoleon_custom_sections is not None:\n541             for entry in self._config.napoleon_custom_sections:\n542                 if isinstance(entry, str):\n543                     # if entry is just a label, add to sections list,\n544                     # using generic section logic.\n545                     self._sections[entry.lower()] = self._parse_custom_generic_section\n546                 else:\n547                     # otherwise, assume entry is container;\n548                     # [0] is new section, [1] is the section to alias.\n549                     # in the case of key mismatch, just handle as generic section.\n550                     self._sections[entry[0].lower()] = \\\n551                         self._sections.get(entry[1].lower(),\n552                                            self._parse_custom_generic_section)\n553 \n554     def _parse(self) -> None:\n555         self._parsed_lines = self._consume_empty()\n556 \n557         if self._name and self._what in ('attribute', 'data', 'property'):\n558             # Implicit stop using StopIteration no longer allowed in\n559             # Python 3.7; see PEP 479\n560             res = []  # type: List[str]\n561             try:\n562                 res = self._parse_attribute_docstring()\n563             except StopIteration:\n564                 pass\n565             self._parsed_lines.extend(res)\n566             return\n567 \n568         while self._line_iter.has_next():\n569             if self._is_section_header():\n570                 try:\n571                     section = self._consume_section_header()\n572                     self._is_in_section = True\n573                     self._section_indent = self._get_current_indent()\n574                     if _directive_regex.match(section):\n575                         lines = [section] + self._consume_to_next_section()\n576                     else:\n577                         lines = self._sections[section.lower()](section)\n578                 finally:\n579                     self._is_in_section = False\n580                     self._section_indent = 0\n581             else:\n582                 if not self._parsed_lines:\n583                     lines = self._consume_contiguous() + self._consume_empty()\n584                 else:\n585                     lines = self._consume_to_next_section()\n586             self._parsed_lines.extend(lines)\n587 \n588     def _parse_admonition(self, admonition: str, section: str) -> List[str]:\n589         # type (str, str) -> List[str]\n590         lines = self._consume_to_next_section()\n591         return self._format_admonition(admonition, lines)\n592 \n593     def _parse_attribute_docstring(self) -> List[str]:\n594         _type, _desc = self._consume_inline_attribute()\n595         lines = self._format_field('', '', _desc)\n596         if _type:\n597             lines.extend(['', ':type: %s' % _type])\n598         return lines\n599 \n600     def _parse_attributes_section(self, section: str) -> List[str]:\n601         lines = []\n602         for _name, _type, _desc in self._consume_fields():\n603             if self._config.napoleon_use_ivar:\n604                 _name = self._qualify_name(_name, self._obj)\n605                 field = ':ivar %s: ' % _name\n606                 lines.extend(self._format_block(field, _desc))\n607                 if _type:\n608                     lines.append(':vartype %s: %s' % (_name, _type))\n609             else:\n610                 lines.append('.. attribute:: ' + _name)\n611                 if self._opt and 'noindex' in self._opt:\n612                     lines.append('   :noindex:')\n613                 lines.append('')\n614 \n615                 fields = self._format_field('', '', _desc)\n616                 lines.extend(self._indent(fields, 3))\n617                 if _type:\n618                     lines.append('')\n619                     lines.extend(self._indent([':type: %s' % _type], 3))\n620                 lines.append('')\n621         if self._config.napoleon_use_ivar:\n622             lines.append('')\n623         return lines\n624 \n625     def _parse_examples_section(self, section: str) -> List[str]:\n626         labels = {\n627             'example': _('Example'),\n628             'examples': _('Examples'),\n629         }\n630         use_admonition = self._config.napoleon_use_admonition_for_examples\n631         label = labels.get(section.lower(), section)\n632         return self._parse_generic_section(label, use_admonition)\n633 \n634     def _parse_custom_generic_section(self, section: str) -> List[str]:\n635         # for now, no admonition for simple custom sections\n636         return self._parse_generic_section(section, False)\n637 \n638     def _parse_usage_section(self, section: str) -> List[str]:\n639         header = ['.. rubric:: Usage:', '']\n640         block = ['.. code-block:: python', '']\n641         lines = self._consume_usage_section()\n642         lines = self._indent(lines, 3)\n643         return header + block + lines + ['']\n644 \n645     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:\n646         lines = self._strip_empty(self._consume_to_next_section())\n647         lines = self._dedent(lines)\n648         if use_admonition:\n649             header = '.. admonition:: %s' % section\n650             lines = self._indent(lines, 3)\n651         else:\n652             header = '.. rubric:: %s' % section\n653         if lines:\n654             return [header, ''] + lines + ['']\n655         else:\n656             return [header, '']\n657 \n658     def _parse_keyword_arguments_section(self, section: str) -> List[str]:\n659         fields = self._consume_fields()\n660         if self._config.napoleon_use_keyword:\n661             return self._format_docutils_params(\n662                 fields,\n663                 field_role=\"keyword\",\n664                 type_role=\"kwtype\")\n665         else:\n666             return self._format_fields(_('Keyword Arguments'), fields)\n667 \n668     def _parse_methods_section(self, section: str) -> List[str]:\n669         lines = []  # type: List[str]\n670         for _name, _type, _desc in self._consume_fields(parse_type=False):\n671             lines.append('.. method:: %s' % _name)\n672             if self._opt and 'noindex' in self._opt:\n673                 lines.append('   :noindex:')\n674             if _desc:\n675                 lines.extend([''] + self._indent(_desc, 3))\n676             lines.append('')\n677         return lines\n678 \n679     def _parse_notes_section(self, section: str) -> List[str]:\n680         use_admonition = self._config.napoleon_use_admonition_for_notes\n681         return self._parse_generic_section(_('Notes'), use_admonition)\n682 \n683     def _parse_other_parameters_section(self, section: str) -> List[str]:\n684         return self._format_fields(_('Other Parameters'), self._consume_fields())\n685 \n686     def _parse_parameters_section(self, section: str) -> List[str]:\n687         if self._config.napoleon_use_param:\n688             # Allow to declare multiple parameters at once (ex: x, y: int)\n689             fields = self._consume_fields(multiple=True)\n690             return self._format_docutils_params(fields)\n691         else:\n692             fields = self._consume_fields()\n693             return self._format_fields(_('Parameters'), fields)\n694 \n695     def _parse_raises_section(self, section: str) -> List[str]:\n696         fields = self._consume_fields(parse_type=False, prefer_type=True)\n697         lines = []  # type: List[str]\n698         for _name, _type, _desc in fields:\n699             m = self._name_rgx.match(_type)\n700             if m and m.group('name'):\n701                 _type = m.group('name')\n702             elif _xref_regex.match(_type):\n703                 pos = _type.find('`')\n704                 _type = _type[pos + 1:-1]\n705             _type = ' ' + _type if _type else ''\n706             _desc = self._strip_empty(_desc)\n707             _descs = ' ' + '\\n    '.join(_desc) if any(_desc) else ''\n708             lines.append(':raises%s:%s' % (_type, _descs))\n709         if lines:\n710             lines.append('')\n711         return lines\n712 \n713     def _parse_references_section(self, section: str) -> List[str]:\n714         use_admonition = self._config.napoleon_use_admonition_for_references\n715         return self._parse_generic_section(_('References'), use_admonition)\n716 \n717     def _parse_returns_section(self, section: str) -> List[str]:\n718         fields = self._consume_returns_section()\n719         multi = len(fields) > 1\n720         if multi:\n721             use_rtype = False\n722         else:\n723             use_rtype = self._config.napoleon_use_rtype\n724 \n725         lines = []  # type: List[str]\n726         for _name, _type, _desc in fields:\n727             if use_rtype:\n728                 field = self._format_field(_name, '', _desc)\n729             else:\n730                 field = self._format_field(_name, _type, _desc)\n731 \n732             if multi:\n733                 if lines:\n734                     lines.extend(self._format_block('          * ', field))\n735                 else:\n736                     lines.extend(self._format_block(':returns: * ', field))\n737             else:\n738                 lines.extend(self._format_block(':returns: ', field))\n739                 if _type and use_rtype:\n740                     lines.extend([':rtype: %s' % _type, ''])\n741         if lines and lines[-1]:\n742             lines.append('')\n743         return lines\n744 \n745     def _parse_see_also_section(self, section: str) -> List[str]:\n746         return self._parse_admonition('seealso', section)\n747 \n748     def _parse_warns_section(self, section: str) -> List[str]:\n749         return self._format_fields(_('Warns'), self._consume_fields())\n750 \n751     def _parse_yields_section(self, section: str) -> List[str]:\n752         fields = self._consume_returns_section()\n753         return self._format_fields(_('Yields'), fields)\n754 \n755     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:\n756         before_colon = []\n757         after_colon = []\n758         colon = ''\n759         found_colon = False\n760         for i, source in enumerate(_xref_or_code_regex.split(line)):\n761             if found_colon:\n762                 after_colon.append(source)\n763             else:\n764                 m = _single_colon_regex.search(source)\n765                 if (i % 2) == 0 and m:\n766                     found_colon = True\n767                     colon = source[m.start(): m.end()]\n768                     before_colon.append(source[:m.start()])\n769                     after_colon.append(source[m.end():])\n770                 else:\n771                     before_colon.append(source)\n772 \n773         return (\"\".join(before_colon).strip(),\n774                 colon,\n775                 \"\".join(after_colon).strip())\n776 \n777     def _qualify_name(self, attr_name: str, klass: \"Type\") -> str:\n778         if klass and '.' not in attr_name:\n779             if attr_name.startswith('~'):\n780                 attr_name = attr_name[1:]\n781             try:\n782                 q = klass.__qualname__\n783             except AttributeError:\n784                 q = klass.__name__\n785             return '~%s.%s' % (q, attr_name)\n786         return attr_name\n787 \n788     def _strip_empty(self, lines: List[str]) -> List[str]:\n789         if lines:\n790             start = -1\n791             for i, line in enumerate(lines):\n792                 if line:\n793                     start = i\n794                     break\n795             if start == -1:\n796                 lines = []\n797             end = -1\n798             for i in reversed(range(len(lines))):\n799                 line = lines[i]\n800                 if line:\n801                     end = i\n802                     break\n803             if start > 0 or end + 1 < len(lines):\n804                 lines = lines[start:end + 1]\n805         return lines\n806 \n807 \n808 def _recombine_set_tokens(tokens: List[str]) -> List[str]:\n809     token_queue = collections.deque(tokens)\n810     keywords = (\"optional\", \"default\")\n811 \n812     def takewhile_set(tokens):\n813         open_braces = 0\n814         previous_token = None\n815         while True:\n816             try:\n817                 token = tokens.popleft()\n818             except IndexError:\n819                 break\n820 \n821             if token == \", \":\n822                 previous_token = token\n823                 continue\n824 \n825             if not token.strip():\n826                 continue\n827 \n828             if token in keywords:\n829                 tokens.appendleft(token)\n830                 if previous_token is not None:\n831                     tokens.appendleft(previous_token)\n832                 break\n833 \n834             if previous_token is not None:\n835                 yield previous_token\n836                 previous_token = None\n837 \n838             if token == \"{\":\n839                 open_braces += 1\n840             elif token == \"}\":\n841                 open_braces -= 1\n842 \n843             yield token\n844 \n845             if open_braces == 0:\n846                 break\n847 \n848     def combine_set(tokens):\n849         while True:\n850             try:\n851                 token = tokens.popleft()\n852             except IndexError:\n853                 break\n854 \n855             if token == \"{\":\n856                 tokens.appendleft(\"{\")\n857                 yield \"\".join(takewhile_set(tokens))\n858             else:\n859                 yield token\n860 \n861     return list(combine_set(token_queue))\n862 \n863 \n864 def _tokenize_type_spec(spec: str) -> List[str]:\n865     def postprocess(item):\n866         if _default_regex.match(item):\n867             default = item[:7]\n868             # can't be separated by anything other than a single space\n869             # for now\n870             other = item[8:]\n871 \n872             return [default, \" \", other]\n873         else:\n874             return [item]\n875 \n876     tokens = list(\n877         item\n878         for raw_token in _token_regex.split(spec)\n879         for item in postprocess(raw_token)\n880         if item\n881     )\n882     return tokens\n883 \n884 \n885 def _token_type(token: str, location: str = None) -> str:\n886     def is_numeric(token):\n887         try:\n888             # use complex to make sure every numeric value is detected as literal\n889             complex(token)\n890         except ValueError:\n891             return False\n892         else:\n893             return True\n894 \n895     if token.startswith(\" \") or token.endswith(\" \"):\n896         type_ = \"delimiter\"\n897     elif (\n898             is_numeric(token) or\n899             (token.startswith(\"{\") and token.endswith(\"}\")) or\n900             (token.startswith('\"') and token.endswith('\"')) or\n901             (token.startswith(\"'\") and token.endswith(\"'\"))\n902     ):\n903         type_ = \"literal\"\n904     elif token.startswith(\"{\"):\n905         logger.warning(\n906             __(\"invalid value set (missing closing brace): %s\"),\n907             token,\n908             location=location,\n909         )\n910         type_ = \"literal\"\n911     elif token.endswith(\"}\"):\n912         logger.warning(\n913             __(\"invalid value set (missing opening brace): %s\"),\n914             token,\n915             location=location,\n916         )\n917         type_ = \"literal\"\n918     elif token.startswith(\"'\") or token.startswith('\"'):\n919         logger.warning(\n920             __(\"malformed string literal (missing closing quote): %s\"),\n921             token,\n922             location=location,\n923         )\n924         type_ = \"literal\"\n925     elif token.endswith(\"'\") or token.endswith('\"'):\n926         logger.warning(\n927             __(\"malformed string literal (missing opening quote): %s\"),\n928             token,\n929             location=location,\n930         )\n931         type_ = \"literal\"\n932     elif token in (\"optional\", \"default\"):\n933         # default is not a official keyword (yet) but supported by the\n934         # reference implementation (numpydoc) and widely used\n935         type_ = \"control\"\n936     elif _xref_regex.match(token):\n937         type_ = \"reference\"\n938     else:\n939         type_ = \"obj\"\n940 \n941     return type_\n942 \n943 \n944 def _convert_numpy_type_spec(_type: str, location: str = None, translations: dict = {}) -> str:\n945     def convert_obj(obj, translations, default_translation):\n946         translation = translations.get(obj, obj)\n947 \n948         # use :class: (the default) only if obj is not a standard singleton\n949         if translation in _SINGLETONS and default_translation == \":class:`%s`\":\n950             default_translation = \":obj:`%s`\"\n951         elif translation == \"...\" and default_translation == \":class:`%s`\":\n952             # allow referencing the builtin ...\n953             default_translation = \":obj:`%s <Ellipsis>`\"\n954 \n955         if _xref_regex.match(translation) is None:\n956             translation = default_translation % translation\n957 \n958         return translation\n959 \n960     tokens = _tokenize_type_spec(_type)\n961     combined_tokens = _recombine_set_tokens(tokens)\n962     types = [\n963         (token, _token_type(token, location))\n964         for token in combined_tokens\n965     ]\n966 \n967     converters = {\n968         \"literal\": lambda x: \"``%s``\" % x,\n969         \"obj\": lambda x: convert_obj(x, translations, \":class:`%s`\"),\n970         \"control\": lambda x: \"*%s*\" % x,\n971         \"delimiter\": lambda x: x,\n972         \"reference\": lambda x: x,\n973     }\n974 \n975     converted = \"\".join(converters.get(type_)(token) for token, type_ in types)\n976 \n977     return converted\n978 \n979 \n980 class NumpyDocstring(GoogleDocstring):\n981     \"\"\"Convert NumPy style docstrings to reStructuredText.\n982 \n983     Parameters\n984     ----------\n985     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n986         The docstring to parse, given either as a string or split into\n987         individual lines.\n988     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n989         The configuration settings to use. If not given, defaults to the\n990         config object on `app`; or if `app` is not given defaults to the\n991         a new :class:`sphinx.ext.napoleon.Config` object.\n992 \n993 \n994     Other Parameters\n995     ----------------\n996     app : :class:`sphinx.application.Sphinx`, optional\n997         Application object representing the Sphinx process.\n998     what : :obj:`str`, optional\n999         A string specifying the type of the object to which the docstring\n1000         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n1001         \"method\", \"attribute\".\n1002     name : :obj:`str`, optional\n1003         The fully qualified name of the object.\n1004     obj : module, class, exception, function, method, or attribute\n1005         The object to which the docstring belongs.\n1006     options : :class:`sphinx.ext.autodoc.Options`, optional\n1007         The options given to the directive: an object with attributes\n1008         inherited_members, undoc_members, show_inheritance and noindex that\n1009         are True if the flag option of same name was given to the auto\n1010         directive.\n1011 \n1012 \n1013     Example\n1014     -------\n1015     >>> from sphinx.ext.napoleon import Config\n1016     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n1017     >>> docstring = '''One line summary.\n1018     ...\n1019     ... Extended description.\n1020     ...\n1021     ... Parameters\n1022     ... ----------\n1023     ... arg1 : int\n1024     ...     Description of `arg1`\n1025     ... arg2 : str\n1026     ...     Description of `arg2`\n1027     ... Returns\n1028     ... -------\n1029     ... str\n1030     ...     Description of return value.\n1031     ... '''\n1032     >>> print(NumpyDocstring(docstring, config))\n1033     One line summary.\n1034     <BLANKLINE>\n1035     Extended description.\n1036     <BLANKLINE>\n1037     :param arg1: Description of `arg1`\n1038     :type arg1: int\n1039     :param arg2: Description of `arg2`\n1040     :type arg2: str\n1041     <BLANKLINE>\n1042     :returns: Description of return value.\n1043     :rtype: str\n1044     <BLANKLINE>\n1045 \n1046     Methods\n1047     -------\n1048     __str__()\n1049         Return the parsed docstring in reStructuredText format.\n1050 \n1051         Returns\n1052         -------\n1053         str\n1054             UTF-8 encoded version of the docstring.\n1055 \n1056     __unicode__()\n1057         Return the parsed docstring in reStructuredText format.\n1058 \n1059         Returns\n1060         -------\n1061         unicode\n1062             Unicode version of the docstring.\n1063 \n1064     lines()\n1065         Return the parsed lines of the docstring in reStructuredText format.\n1066 \n1067         Returns\n1068         -------\n1069         list(str)\n1070             The lines of the docstring in a list.\n1071 \n1072     \"\"\"\n1073     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n1074                  app: Sphinx = None, what: str = '', name: str = '',\n1075                  obj: Any = None, options: Any = None) -> None:\n1076         self._directive_sections = ['.. index::']\n1077         super().__init__(docstring, config, app, what, name, obj, options)\n1078 \n1079     def _get_location(self) -> str:\n1080         try:\n1081             filepath = inspect.getfile(self._obj) if self._obj is not None else None\n1082         except TypeError:\n1083             filepath = None\n1084         name = self._name\n1085 \n1086         if filepath is None and name is None:\n1087             return None\n1088         elif filepath is None:\n1089             filepath = \"\"\n1090 \n1091         return \":\".join([filepath, \"docstring of %s\" % name])\n1092 \n1093     def _escape_args_and_kwargs(self, name: str) -> str:\n1094         func = super()._escape_args_and_kwargs\n1095 \n1096         if \", \" in name:\n1097             return \", \".join(func(param) for param in name.split(\", \"))\n1098         else:\n1099             return func(name)\n1100 \n1101     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n1102                        ) -> Tuple[str, str, List[str]]:\n1103         line = next(self._line_iter)\n1104         if parse_type:\n1105             _name, _, _type = self._partition_field_on_colon(line)\n1106         else:\n1107             _name, _type = line, ''\n1108         _name, _type = _name.strip(), _type.strip()\n1109         _name = self._escape_args_and_kwargs(_name)\n1110 \n1111         if prefer_type and not _type:\n1112             _type, _name = _name, _type\n1113 \n1114         if self._config.napoleon_preprocess_types:\n1115             _type = _convert_numpy_type_spec(\n1116                 _type,\n1117                 location=self._get_location(),\n1118                 translations=self._config.napoleon_type_aliases or {},\n1119             )\n1120 \n1121         indent = self._get_indent(line) + 1\n1122         _desc = self._dedent(self._consume_indented_block(indent))\n1123         _desc = self.__class__(_desc, self._config).lines()\n1124         return _name, _type, _desc\n1125 \n1126     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n1127         return self._consume_fields(prefer_type=True)\n1128 \n1129     def _consume_section_header(self) -> str:\n1130         section = next(self._line_iter)\n1131         if not _directive_regex.match(section):\n1132             # Consume the header underline\n1133             next(self._line_iter)\n1134         return section\n1135 \n1136     def _is_section_break(self) -> bool:\n1137         line1, line2 = self._line_iter.peek(2)\n1138         return (not self._line_iter.has_next() or\n1139                 self._is_section_header() or\n1140                 ['', ''] == [line1, line2] or\n1141                 (self._is_in_section and\n1142                     line1 and\n1143                     not self._is_indented(line1, self._section_indent)))\n1144 \n1145     def _is_section_header(self) -> bool:\n1146         section, underline = self._line_iter.peek(2)\n1147         section = section.lower()\n1148         if section in self._sections and isinstance(underline, str):\n1149             return bool(_numpy_section_regex.match(underline))\n1150         elif self._directive_sections:\n1151             if _directive_regex.match(section):\n1152                 for directive_section in self._directive_sections:\n1153                     if section.startswith(directive_section):\n1154                         return True\n1155         return False\n1156 \n1157     def _parse_see_also_section(self, section: str) -> List[str]:\n1158         lines = self._consume_to_next_section()\n1159         try:\n1160             return self._parse_numpydoc_see_also_section(lines)\n1161         except ValueError:\n1162             return self._format_admonition('seealso', lines)\n1163 \n1164     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:\n1165         \"\"\"\n1166         Derived from the NumpyDoc implementation of _parse_see_also.\n1167 \n1168         See Also\n1169         --------\n1170         func_name : Descriptive text\n1171             continued text\n1172         another_func_name : Descriptive text\n1173         func_name1, func_name2, :meth:`func_name`, func_name3\n1174 \n1175         \"\"\"\n1176         items = []\n1177 \n1178         def parse_item_name(text: str) -> Tuple[str, str]:\n1179             \"\"\"Match ':role:`name`' or 'name'\"\"\"\n1180             m = self._name_rgx.match(text)\n1181             if m:\n1182                 g = m.groups()\n1183                 if g[1] is None:\n1184                     return g[3], None\n1185                 else:\n1186                     return g[2], g[1]\n1187             raise ValueError(\"%s is not a item name\" % text)\n1188 \n1189         def push_item(name: str, rest: List[str]) -> None:\n1190             if not name:\n1191                 return\n1192             name, role = parse_item_name(name)\n1193             items.append((name, list(rest), role))\n1194             del rest[:]\n1195 \n1196         def translate(func, description, role):\n1197             translations = self._config.napoleon_type_aliases\n1198             if role is not None or not translations:\n1199                 return func, description, role\n1200 \n1201             translated = translations.get(func, func)\n1202             match = self._name_rgx.match(translated)\n1203             if not match:\n1204                 return translated, description, role\n1205 \n1206             groups = match.groupdict()\n1207             role = groups[\"role\"]\n1208             new_func = groups[\"name\"] or groups[\"name2\"]\n1209 \n1210             return new_func, description, role\n1211 \n1212         current_func = None\n1213         rest = []  # type: List[str]\n1214 \n1215         for line in content:\n1216             if not line.strip():\n1217                 continue\n1218 \n1219             m = self._name_rgx.match(line)\n1220             if m and line[m.end():].strip().startswith(':'):\n1221                 push_item(current_func, rest)\n1222                 current_func, line = line[:m.end()], line[m.end():]\n1223                 rest = [line.split(':', 1)[1].strip()]\n1224                 if not rest[0]:\n1225                     rest = []\n1226             elif not line.startswith(' '):\n1227                 push_item(current_func, rest)\n1228                 current_func = None\n1229                 if ',' in line:\n1230                     for func in line.split(','):\n1231                         if func.strip():\n1232                             push_item(func, [])\n1233                 elif line.strip():\n1234                     current_func = line\n1235             elif current_func is not None:\n1236                 rest.append(line.strip())\n1237         push_item(current_func, rest)\n1238 \n1239         if not items:\n1240             return []\n1241 \n1242         # apply type aliases\n1243         items = [\n1244             translate(func, description, role)\n1245             for func, description, role in items\n1246         ]\n1247 \n1248         lines = []  # type: List[str]\n1249         last_had_desc = True\n1250         for name, desc, role in items:\n1251             if role:\n1252                 link = ':%s:`%s`' % (role, name)\n1253             else:\n1254                 link = ':obj:`%s`' % name\n1255             if desc or last_had_desc:\n1256                 lines += ['']\n1257                 lines += [link]\n1258             else:\n1259                 lines[-1] += \", %s\" % link\n1260             if desc:\n1261                 lines += self._indent([' '.join(desc)])\n1262                 last_had_desc = True\n1263             else:\n1264                 last_had_desc = False\n1265         lines += ['']\n1266 \n1267         return self._format_admonition('seealso', lines)\n",
        "intended_behavior": "Modify the attribute parsing logic to check for existing type hints within the code. If an attribute has a type hint, this type should be automatically incorporated into the attribute documentation generated by Sphinx. Ensure that if `:type` is explicitly mentioned in the docstring, it doesn't result in duplication but rather supplements or confirms the type hint. Ideally, introduce a mechanism to merge the documentation and type information, favoring explicit docstring types if they provide more detail than the type hint, to avoid information loss."
    },
    {
        "rel_file_path": "sphinx/ext/napoleon/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.4/sphinx/ext/napoleon/__init__.py",
        "start": 1,
        "end": 475,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon\n3     ~~~~~~~~~~~~~~~~~~~\n4 \n5     Support for NumPy and Google style docstrings.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import Any, Dict, List\n12 \n13 from sphinx import __display_version__ as __version__\n14 from sphinx.application import Sphinx\n15 from sphinx.ext.napoleon.docstring import GoogleDocstring, NumpyDocstring\n16 from sphinx.util import inspect\n17 \n18 \n19 class Config:\n20     \"\"\"Sphinx napoleon extension settings in `conf.py`.\n21 \n22     Listed below are all the settings used by napoleon and their default\n23     values. These settings can be changed in the Sphinx `conf.py` file. Make\n24     sure that \"sphinx.ext.napoleon\" is enabled in `conf.py`::\n25 \n26         # conf.py\n27 \n28         # Add any Sphinx extension module names here, as strings\n29         extensions = ['sphinx.ext.napoleon']\n30 \n31         # Napoleon settings\n32         napoleon_google_docstring = True\n33         napoleon_numpy_docstring = True\n34         napoleon_include_init_with_doc = False\n35         napoleon_include_private_with_doc = False\n36         napoleon_include_special_with_doc = False\n37         napoleon_use_admonition_for_examples = False\n38         napoleon_use_admonition_for_notes = False\n39         napoleon_use_admonition_for_references = False\n40         napoleon_use_ivar = False\n41         napoleon_use_param = True\n42         napoleon_use_rtype = True\n43         napoleon_use_keyword = True\n44         napoleon_preprocess_types = False\n45         napoleon_type_aliases = None\n46         napoleon_custom_sections = None\n47 \n48     .. _Google style:\n49        https://google.github.io/styleguide/pyguide.html\n50     .. _NumPy style:\n51        https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt\n52 \n53     Attributes\n54     ----------\n55     napoleon_google_docstring : :obj:`bool` (Defaults to True)\n56         True to parse `Google style`_ docstrings. False to disable support\n57         for Google style docstrings.\n58     napoleon_numpy_docstring : :obj:`bool` (Defaults to True)\n59         True to parse `NumPy style`_ docstrings. False to disable support\n60         for NumPy style docstrings.\n61     napoleon_include_init_with_doc : :obj:`bool` (Defaults to False)\n62         True to list ``__init___`` docstrings separately from the class\n63         docstring. False to fall back to Sphinx's default behavior, which\n64         considers the ``__init___`` docstring as part of the class\n65         documentation.\n66 \n67         **If True**::\n68 \n69             def __init__(self):\n70                 \\\"\\\"\\\"\n71                 This will be included in the docs because it has a docstring\n72                 \\\"\\\"\\\"\n73 \n74             def __init__(self):\n75                 # This will NOT be included in the docs\n76 \n77     napoleon_include_private_with_doc : :obj:`bool` (Defaults to False)\n78         True to include private members (like ``_membername``) with docstrings\n79         in the documentation. False to fall back to Sphinx's default behavior.\n80 \n81         **If True**::\n82 \n83             def _included(self):\n84                 \\\"\\\"\\\"\n85                 This will be included in the docs because it has a docstring\n86                 \\\"\\\"\\\"\n87                 pass\n88 \n89             def _skipped(self):\n90                 # This will NOT be included in the docs\n91                 pass\n92 \n93     napoleon_include_special_with_doc : :obj:`bool` (Defaults to False)\n94         True to include special members (like ``__membername__``) with\n95         docstrings in the documentation. False to fall back to Sphinx's\n96         default behavior.\n97 \n98         **If True**::\n99 \n100             def __str__(self):\n101                 \\\"\\\"\\\"\n102                 This will be included in the docs because it has a docstring\n103                 \\\"\\\"\\\"\n104                 return unicode(self).encode('utf-8')\n105 \n106             def __unicode__(self):\n107                 # This will NOT be included in the docs\n108                 return unicode(self.__class__.__name__)\n109 \n110     napoleon_use_admonition_for_examples : :obj:`bool` (Defaults to False)\n111         True to use the ``.. admonition::`` directive for the **Example** and\n112         **Examples** sections. False to use the ``.. rubric::`` directive\n113         instead. One may look better than the other depending on what HTML\n114         theme is used.\n115 \n116         This `NumPy style`_ snippet will be converted as follows::\n117 \n118             Example\n119             -------\n120             This is just a quick example\n121 \n122         **If True**::\n123 \n124             .. admonition:: Example\n125 \n126                This is just a quick example\n127 \n128         **If False**::\n129 \n130             .. rubric:: Example\n131 \n132             This is just a quick example\n133 \n134     napoleon_use_admonition_for_notes : :obj:`bool` (Defaults to False)\n135         True to use the ``.. admonition::`` directive for **Notes** sections.\n136         False to use the ``.. rubric::`` directive instead.\n137 \n138         Note\n139         ----\n140         The singular **Note** section will always be converted to a\n141         ``.. note::`` directive.\n142 \n143         See Also\n144         --------\n145         :attr:`napoleon_use_admonition_for_examples`\n146 \n147     napoleon_use_admonition_for_references : :obj:`bool` (Defaults to False)\n148         True to use the ``.. admonition::`` directive for **References**\n149         sections. False to use the ``.. rubric::`` directive instead.\n150 \n151         See Also\n152         --------\n153         :attr:`napoleon_use_admonition_for_examples`\n154 \n155     napoleon_use_ivar : :obj:`bool` (Defaults to False)\n156         True to use the ``:ivar:`` role for instance variables. False to use\n157         the ``.. attribute::`` directive instead.\n158 \n159         This `NumPy style`_ snippet will be converted as follows::\n160 \n161             Attributes\n162             ----------\n163             attr1 : int\n164                 Description of `attr1`\n165 \n166         **If True**::\n167 \n168             :ivar attr1: Description of `attr1`\n169             :vartype attr1: int\n170 \n171         **If False**::\n172 \n173             .. attribute:: attr1\n174 \n175                Description of `attr1`\n176 \n177                :type: int\n178 \n179     napoleon_use_param : :obj:`bool` (Defaults to True)\n180         True to use a ``:param:`` role for each function parameter. False to\n181         use a single ``:parameters:`` role for all the parameters.\n182 \n183         This `NumPy style`_ snippet will be converted as follows::\n184 \n185             Parameters\n186             ----------\n187             arg1 : str\n188                 Description of `arg1`\n189             arg2 : int, optional\n190                 Description of `arg2`, defaults to 0\n191 \n192         **If True**::\n193 \n194             :param arg1: Description of `arg1`\n195             :type arg1: str\n196             :param arg2: Description of `arg2`, defaults to 0\n197             :type arg2: int, optional\n198 \n199         **If False**::\n200 \n201             :parameters: * **arg1** (*str*) --\n202                            Description of `arg1`\n203                          * **arg2** (*int, optional*) --\n204                            Description of `arg2`, defaults to 0\n205 \n206     napoleon_use_keyword : :obj:`bool` (Defaults to True)\n207         True to use a ``:keyword:`` role for each function keyword argument.\n208         False to use a single ``:keyword arguments:`` role for all the\n209         keywords.\n210 \n211         This behaves similarly to  :attr:`napoleon_use_param`. Note unlike\n212         docutils, ``:keyword:`` and ``:param:`` will not be treated the same\n213         way - there will be a separate \"Keyword Arguments\" section, rendered\n214         in the same fashion as \"Parameters\" section (type links created if\n215         possible)\n216 \n217         See Also\n218         --------\n219         :attr:`napoleon_use_param`\n220 \n221     napoleon_use_rtype : :obj:`bool` (Defaults to True)\n222         True to use the ``:rtype:`` role for the return type. False to output\n223         the return type inline with the description.\n224 \n225         This `NumPy style`_ snippet will be converted as follows::\n226 \n227             Returns\n228             -------\n229             bool\n230                 True if successful, False otherwise\n231 \n232         **If True**::\n233 \n234             :returns: True if successful, False otherwise\n235             :rtype: bool\n236 \n237         **If False**::\n238 \n239             :returns: *bool* -- True if successful, False otherwise\n240 \n241     napoleon_preprocess_types : :obj:`bool` (Defaults to False)\n242         Enable the type preprocessor for numpy style docstrings.\n243 \n244     napoleon_type_aliases : :obj:`dict` (Defaults to None)\n245         Add a mapping of strings to string, translating types in numpy\n246         style docstrings. Only works if ``napoleon_preprocess_types = True``.\n247 \n248     napoleon_custom_sections : :obj:`list` (Defaults to None)\n249         Add a list of custom sections to include, expanding the list of parsed sections.\n250 \n251         The entries can either be strings or tuples, depending on the intention:\n252           * To create a custom \"generic\" section, just pass a string.\n253           * To create an alias for an existing section, pass a tuple containing the\n254             alias name and the original, in that order.\n255 \n256         If an entry is just a string, it is interpreted as a header for a generic\n257         section. If the entry is a tuple/list/indexed container, the first entry\n258         is the name of the section, the second is the section key to emulate.\n259 \n260 \n261     \"\"\"\n262     _config_values = {\n263         'napoleon_google_docstring': (True, 'env'),\n264         'napoleon_numpy_docstring': (True, 'env'),\n265         'napoleon_include_init_with_doc': (False, 'env'),\n266         'napoleon_include_private_with_doc': (False, 'env'),\n267         'napoleon_include_special_with_doc': (False, 'env'),\n268         'napoleon_use_admonition_for_examples': (False, 'env'),\n269         'napoleon_use_admonition_for_notes': (False, 'env'),\n270         'napoleon_use_admonition_for_references': (False, 'env'),\n271         'napoleon_use_ivar': (False, 'env'),\n272         'napoleon_use_param': (True, 'env'),\n273         'napoleon_use_rtype': (True, 'env'),\n274         'napoleon_use_keyword': (True, 'env'),\n275         'napoleon_preprocess_types': (False, 'env'),\n276         'napoleon_type_aliases': (None, 'env'),\n277         'napoleon_custom_sections': (None, 'env')\n278     }\n279 \n280     def __init__(self, **settings: Any) -> None:\n281         for name, (default, rebuild) in self._config_values.items():\n282             setattr(self, name, default)\n283         for name, value in settings.items():\n284             setattr(self, name, value)\n285 \n286 \n287 def setup(app: Sphinx) -> Dict[str, Any]:\n288     \"\"\"Sphinx extension setup function.\n289 \n290     When the extension is loaded, Sphinx imports this module and executes\n291     the ``setup()`` function, which in turn notifies Sphinx of everything\n292     the extension offers.\n293 \n294     Parameters\n295     ----------\n296     app : sphinx.application.Sphinx\n297         Application object representing the Sphinx process\n298 \n299     See Also\n300     --------\n301     `The Sphinx documentation on Extensions\n302     <http://sphinx-doc.org/extensions.html>`_\n303 \n304     `The Extension Tutorial <http://sphinx-doc.org/extdev/tutorial.html>`_\n305 \n306     `The Extension API <http://sphinx-doc.org/extdev/appapi.html>`_\n307 \n308     \"\"\"\n309     if not isinstance(app, Sphinx):\n310         # probably called by tests\n311         return {'version': __version__, 'parallel_read_safe': True}\n312 \n313     _patch_python_domain()\n314 \n315     app.setup_extension('sphinx.ext.autodoc')\n316     app.connect('autodoc-process-docstring', _process_docstring)\n317     app.connect('autodoc-skip-member', _skip_member)\n318 \n319     for name, (default, rebuild) in Config._config_values.items():\n320         app.add_config_value(name, default, rebuild)\n321     return {'version': __version__, 'parallel_read_safe': True}\n322 \n323 \n324 def _patch_python_domain() -> None:\n325     try:\n326         from sphinx.domains.python import PyTypedField\n327     except ImportError:\n328         pass\n329     else:\n330         import sphinx.domains.python\n331         from sphinx.locale import _\n332         for doc_field in sphinx.domains.python.PyObject.doc_field_types:\n333             if doc_field.name == 'parameter':\n334                 doc_field.names = ('param', 'parameter', 'arg', 'argument')\n335                 break\n336         sphinx.domains.python.PyObject.doc_field_types.append(\n337             PyTypedField('keyword', label=_('Keyword Arguments'),\n338                          names=('keyword', 'kwarg', 'kwparam'),\n339                          typerolename='obj', typenames=('paramtype', 'kwtype'),\n340                          can_collapse=True))\n341 \n342 \n343 def _process_docstring(app: Sphinx, what: str, name: str, obj: Any,\n344                        options: Any, lines: List[str]) -> None:\n345     \"\"\"Process the docstring for a given python object.\n346 \n347     Called when autodoc has read and processed a docstring. `lines` is a list\n348     of docstring lines that `_process_docstring` modifies in place to change\n349     what Sphinx outputs.\n350 \n351     The following settings in conf.py control what styles of docstrings will\n352     be parsed:\n353 \n354     * ``napoleon_google_docstring`` -- parse Google style docstrings\n355     * ``napoleon_numpy_docstring`` -- parse NumPy style docstrings\n356 \n357     Parameters\n358     ----------\n359     app : sphinx.application.Sphinx\n360         Application object representing the Sphinx process.\n361     what : str\n362         A string specifying the type of the object to which the docstring\n363         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n364         \"method\", \"attribute\".\n365     name : str\n366         The fully qualified name of the object.\n367     obj : module, class, exception, function, method, or attribute\n368         The object to which the docstring belongs.\n369     options : sphinx.ext.autodoc.Options\n370         The options given to the directive: an object with attributes\n371         inherited_members, undoc_members, show_inheritance and noindex that\n372         are True if the flag option of same name was given to the auto\n373         directive.\n374     lines : list of str\n375         The lines of the docstring, see above.\n376 \n377         .. note:: `lines` is modified *in place*\n378 \n379     \"\"\"\n380     result_lines = lines\n381     docstring = None  # type: GoogleDocstring\n382     if app.config.napoleon_numpy_docstring:\n383         docstring = NumpyDocstring(result_lines, app.config, app, what, name,\n384                                    obj, options)\n385         result_lines = docstring.lines()\n386     if app.config.napoleon_google_docstring:\n387         docstring = GoogleDocstring(result_lines, app.config, app, what, name,\n388                                     obj, options)\n389         result_lines = docstring.lines()\n390     lines[:] = result_lines[:]\n391 \n392 \n393 def _skip_member(app: Sphinx, what: str, name: str, obj: Any,\n394                  skip: bool, options: Any) -> bool:\n395     \"\"\"Determine if private and special class members are included in docs.\n396 \n397     The following settings in conf.py determine if private and special class\n398     members or init methods are included in the generated documentation:\n399 \n400     * ``napoleon_include_init_with_doc`` --\n401       include init methods if they have docstrings\n402     * ``napoleon_include_private_with_doc`` --\n403       include private members if they have docstrings\n404     * ``napoleon_include_special_with_doc`` --\n405       include special members if they have docstrings\n406 \n407     Parameters\n408     ----------\n409     app : sphinx.application.Sphinx\n410         Application object representing the Sphinx process\n411     what : str\n412         A string specifying the type of the object to which the member\n413         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n414         \"method\", \"attribute\".\n415     name : str\n416         The name of the member.\n417     obj : module, class, exception, function, method, or attribute.\n418         For example, if the member is the __init__ method of class A, then\n419         `obj` will be `A.__init__`.\n420     skip : bool\n421         A boolean indicating if autodoc will skip this member if `_skip_member`\n422         does not override the decision\n423     options : sphinx.ext.autodoc.Options\n424         The options given to the directive: an object with attributes\n425         inherited_members, undoc_members, show_inheritance and noindex that\n426         are True if the flag option of same name was given to the auto\n427         directive.\n428 \n429     Returns\n430     -------\n431     bool\n432         True if the member should be skipped during creation of the docs,\n433         False if it should be included in the docs.\n434 \n435     \"\"\"\n436     has_doc = getattr(obj, '__doc__', False)\n437     is_member = (what == 'class' or what == 'exception' or what == 'module')\n438     if name != '__weakref__' and has_doc and is_member:\n439         cls_is_owner = False\n440         if what == 'class' or what == 'exception':\n441             qualname = getattr(obj, '__qualname__', '')\n442             cls_path, _, _ = qualname.rpartition('.')\n443             if cls_path:\n444                 try:\n445                     if '.' in cls_path:\n446                         import functools\n447                         import importlib\n448 \n449                         mod = importlib.import_module(obj.__module__)\n450                         mod_path = cls_path.split('.')\n451                         cls = functools.reduce(getattr, mod_path, mod)\n452                     else:\n453                         cls = inspect.unwrap(obj).__globals__[cls_path]\n454                 except Exception:\n455                     cls_is_owner = False\n456                 else:\n457                     cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore\n458                                     name in cls.__dict__)\n459             else:\n460                 cls_is_owner = False\n461 \n462         if what == 'module' or cls_is_owner:\n463             is_init = (name == '__init__')\n464             is_special = (not is_init and name.startswith('__') and\n465                           name.endswith('__'))\n466             is_private = (not is_init and not is_special and\n467                           name.startswith('_'))\n468             inc_init = app.config.napoleon_include_init_with_doc\n469             inc_special = app.config.napoleon_include_special_with_doc\n470             inc_private = app.config.napoleon_include_private_with_doc\n471             if ((is_special and inc_special) or\n472                     (is_private and inc_private) or\n473                     (is_init and inc_init)):\n474                 return False\n475     return None\n",
        "intended_behavior": "Ensure that the configuration settings allow for the seamless integration of type annotations with the generated attribute documentation. This may involve adding a new configuration option that enables users to specify how type annotations should be treated in relation to the documentation\u2014either as a complementary source of type information or as the primary source."
    }
]