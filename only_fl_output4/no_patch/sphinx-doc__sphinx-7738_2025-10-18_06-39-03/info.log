2025-10-18 06:39:03.957 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:39:06.699 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=372, output_tokens=12, cost=0.004080
2025-10-18 06:39:21.066 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=552, output_tokens=634, cost=0.024540
2025-10-18 06:39:22.080 | INFO     | registered non reproducing test 0
2025-10-18 06:39:38.409 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1515, output_tokens=840, cost=0.040350
2025-10-18 06:39:39.395 | INFO     | registered non reproducing test 1
2025-10-18 06:39:58.845 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1725, output_tokens=944, cost=0.045570
2025-10-18 06:39:59.981 | INFO     | registered non reproducing test 2
2025-10-18 06:39:59.982 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 06:39:59.984 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:40:06.420 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=669, output_tokens=304, cost=0.015810
2025-10-18 06:40:06.426 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:40:09.637 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=658, output_tokens=72, cost=0.008740
2025-10-18 06:40:09.638 | DEBUG    | Every API call must be of form api_call(arg1, ..., argn). Will retry.
2025-10-18 06:40:09.638 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 06:40:12.773 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=658, output_tokens=73, cost=0.008770
2025-10-18 06:40:12.774 | INFO     | Refactored invocation argument parsing gives different result on 'search_code_in_file("Attributes\\n----------", "a.py")': old result is ['Attributes\\n----------', 'a.py'], new result  is ['Attributes\n----------', 'a.py']
2025-10-18 06:40:12.775 | DEBUG    | Extracted a valid json.
2025-10-18 06:40:12.775 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file(\"A\", \"a.py\")",
        "search_code_in_file(\"Attributes\\n----------\", \"a.py\")",
        "search_code(\"sphinx.ext.autodoc\")",
        "search_code(\"sphinx.ext.napoleon\")"
    ],
    "bug_locations": []
}
2025-10-18 06:40:12.778 | INFO     | Refactored invocation argument parsing gives different result on 'search_code_in_file("Attributes\\n----------", "a.py")': old result is ['Attributes\\n----------', 'a.py'], new result  is ['Attributes\n----------', 'a.py']
2025-10-18 06:40:12.856 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:40:12.856 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:40:27.442 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1532, output_tokens=722, cost=0.036980
2025-10-18 06:40:27.449 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:40:34.327 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2470, output_tokens=249, cost=0.032170
2025-10-18 06:40:34.333 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:40:41.008 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=603, output_tokens=268, cost=0.014070
2025-10-18 06:40:41.009 | DEBUG    | Extracted a valid json.
2025-10-18 06:40:41.009 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/ext/napoleon/docstring.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should process attribute docstrings in a way that trailing underscores in attribute names are recognized as part of the identifier and not as characters requiring escape sequences in the generated HTML. The intended behavior is to ensure that when Napoleon parses attribute sections, it correctly formats attribute names, preserving trailing underscores without adding a backslash for the HTML output. This preserves the existing functionality for document generation while fixing the issue with attribute name representation."
        },
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "In the context of rendering docstrings to HTML, this file should ensure that attribute names with trailing underscores are not incorrectly escaped. If the problem lies within Autodoc's handling of docstring content post-Napoleon processing, ensuring that underscores at the end of attribute names are properly handled will resolve the issue. Autodoc's rendering process needs to recognize these cases and treat them accordingly, maintaining the integrity of identifier names including their trailing underscores in the final HTML documentation."
        }
    ]
}
2025-10-18 06:40:41.018 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/napoleon/docstring.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon.docstring
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5 
6     Classes for docstring parsing and formatting.
7 
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import inspect
14 import re
15 from functools import partial
16 from typing import Any, Callable, Dict, List, Tuple, Union
17 
18 from sphinx.application import Sphinx
19 from sphinx.config import Config as SphinxConfig
20 from sphinx.ext.napoleon.iterators import modify_iter
21 from sphinx.locale import _
22 
23 if False:
24     # For type annotation
25     from typing import Type  # for python3.5.1
26 
27 
28 _directive_regex = re.compile(r'\.\. \S+::')
29 _google_section_regex = re.compile(r'^(\s|\w)+:\s*$')
30 _google_typed_arg_regex = re.compile(r'\s*(.+?)\s*\(\s*(.*[^\s]+)\s*\)')
31 _numpy_section_regex = re.compile(r'^[=\-`:\'"~^_*+#<>]{2,}\s*$')
32 _single_colon_regex = re.compile(r'(?<!:):(?!:)')
33 _xref_or_code_regex = re.compile(
34     r'((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'
35     r'(?:``.+``))')
36 _bullet_list_regex = re.compile(r'^(\*|\+|\-)(\s+\S|\s*$)')
37 _enumerated_list_regex = re.compile(
38     r'^(?P<paren>\()?'
39     r'(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'
40     r'(?(paren)\)|\.)(\s+\S|\s*$)')
41 
42 
43 class GoogleDocstring:
44     """Convert Google style docstrings to reStructuredText.
45 
46     Parameters
47     ----------
48     docstring : :obj:`str` or :obj:`list` of :obj:`str`
49         The docstring to parse, given either as a string or split into
50         individual lines.
51     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
52         The configuration settings to use. If not given, defaults to the
53         config object on `app`; or if `app` is not given defaults to the
54         a new :class:`sphinx.ext.napoleon.Config` object.
55 
56 
57     Other Parameters
58     ----------------
59     app : :class:`sphinx.application.Sphinx`, optional
60         Application object representing the Sphinx process.
61     what : :obj:`str`, optional
62         A string specifying the type of the object to which the docstring
63         belongs. Valid values: "module", "class", "exception", "function",
64         "method", "attribute".
65     name : :obj:`str`, optional
66         The fully qualified name of the object.
67     obj : module, class, exception, function, method, or attribute
68         The object to which the docstring belongs.
69     options : :class:`sphinx.ext.autodoc.Options`, optional
70         The options given to the directive: an object with attributes
71         inherited_members, undoc_members, show_inheritance and noindex that
72         are True if the flag option of same name was given to the auto
73         directive.
74 
75 
76     Example
77     -------
78     >>> from sphinx.ext.napoleon import Config
79     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
80     >>> docstring = '''One line summary.
81     ...
82     ... Extended description.
83     ...
84     ... Args:
85     ...   arg1(int): Description of `arg1`
86     ...   arg2(str): Description of `arg2`
87     ... Returns:
88     ...   str: Description of return value.
89     ... '''
90     >>> print(GoogleDocstring(docstring, config))
91     One line summary.
92     <BLANKLINE>
93     Extended description.
94     <BLANKLINE>
95     :param arg1: Description of `arg1`
96     :type arg1: int
97     :param arg2: Description of `arg2`
98     :type arg2: str
99     <BLANKLINE>
100     :returns: Description of return value.
101     :rtype: str
102     <BLANKLINE>
103 
104     """
105 
106     _name_rgx = re.compile(r"^\s*((?::(?P<role>\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|"
107                            r" (?P<name2>~?[a-zA-Z0-9_.-]+))\s*", re.X)
108 
109     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
110                  app: Sphinx = None, what: str = '', name: str = '',
111                  obj: Any = None, options: Any = None) -> None:
112         self._config = config
113         self._app = app
114 
115         if not self._config:
116             from sphinx.ext.napoleon import Config
117             self._config = self._app.config if self._app else Config()  # type: ignore
118 
119         if not what:
120             if inspect.isclass(obj):
121                 what = 'class'
122             elif inspect.ismodule(obj):
123                 what = 'module'
124             elif callable(obj):
125                 what = 'function'
126             else:
127                 what = 'object'
128 
129         self._what = what
130         self._name = name
131         self._obj = obj
132         self._opt = options
133         if isinstance(docstring, str):
134             lines = docstring.splitlines()
135         else:
136             lines = docstring
137         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())
138         self._parsed_lines = []  # type: List[str]
139         self._is_in_section = False
140         self._section_indent = 0
141         if not hasattr(self, '_directive_sections'):
142             self._directive_sections = []  # type: List[str]
143         if not hasattr(self, '_sections'):
144             self._sections = {
145                 'args': self._parse_parameters_section,
146                 'arguments': self._parse_parameters_section,
147                 'attention': partial(self._parse_admonition, 'attention'),
148                 'attributes': self._parse_attributes_section,
149                 'caution': partial(self._parse_admonition, 'caution'),
150                 'danger': partial(self._parse_admonition, 'danger'),
151                 'error': partial(self._parse_admonition, 'error'),
152                 'example': self._parse_examples_section,
153                 'examples': self._parse_examples_section,
154                 'hint': partial(self._parse_admonition, 'hint'),
155                 'important': partial(self._parse_admonition, 'important'),
156                 'keyword args': self._parse_keyword_arguments_section,
157                 'keyword arguments': self._parse_keyword_arguments_section,
158                 'methods': self._parse_methods_section,
159                 'note': partial(self._parse_admonition, 'note'),
160                 'notes': self._parse_notes_section,
161                 'other parameters': self._parse_other_parameters_section,
162                 'parameters': self._parse_parameters_section,
163                 'return': self._parse_returns_section,
164                 'returns': self._parse_returns_section,
165                 'raises': self._parse_raises_section,
166                 'references': self._parse_references_section,
167                 'see also': self._parse_see_also_section,
168                 'tip': partial(self._parse_admonition, 'tip'),
169                 'todo': partial(self._parse_admonition, 'todo'),
170                 'warning': partial(self._parse_admonition, 'warning'),
171                 'warnings': partial(self._parse_admonition, 'warning'),
172                 'warns': self._parse_warns_section,
173                 'yield': self._parse_yields_section,
174                 'yields': self._parse_yields_section,
175             }  # type: Dict[str, Callable]
176 
177         self._load_custom_sections()
178 
179         self._parse()
180 
181     def __str__(self) -> str:
182         """Return the parsed docstring in reStructuredText format.
183 
184         Returns
185         -------
186         unicode
187             Unicode version of the docstring.
188 
189         """
190         return '\n'.join(self.lines())
191 
192     def lines(self) -> List[str]:
193         """Return the parsed lines of the docstring in reStructuredText format.
194 
195         Returns
196         -------
197         list(str)
198             The lines of the docstring in a list.
199 
200         """
201         return self._parsed_lines
202 
203     def _consume_indented_block(self, indent: int = 1) -> List[str]:
204         lines = []
205         line = self._line_iter.peek()
206         while(not self._is_section_break() and
207               (not line or self._is_indented(line, indent))):
208             lines.append(next(self._line_iter))
209             line = self._line_iter.peek()
210         return lines
211 
212     def _consume_contiguous(self) -> List[str]:
213         lines = []
214         while (self._line_iter.has_next() and
215                self._line_iter.peek() and
216                not self._is_section_header()):
217             lines.append(next(self._line_iter))
218         return lines
219 
220     def _consume_empty(self) -> List[str]:
221         lines = []
222         line = self._line_iter.peek()
223         while self._line_iter.has_next() and not line:
224             lines.append(next(self._line_iter))
225             line = self._line_iter.peek()
226         return lines
227 
228     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
229                        ) -> Tuple[str, str, List[str]]:
230         line = next(self._line_iter)
231 
232         before, colon, after = self._partition_field_on_colon(line)
233         _name, _type, _desc = before, '', after
234 
235         if parse_type:
236             match = _google_typed_arg_regex.match(before)
237             if match:
238                 _name = match.group(1)
239                 _type = match.group(2)
240 
241         _name = self._escape_args_and_kwargs(_name)
242 
243         if prefer_type and not _type:
244             _type, _name = _name, _type
245         indent = self._get_indent(line) + 1
246         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))
247         _descs = self.__class__(_descs, self._config).lines()
248         return _name, _type, _descs
249 
250     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False
251                         ) -> List[Tuple[str, str, List[str]]]:
252         self._consume_empty()
253         fields = []
254         while not self._is_section_break():
255             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
256             if _name or _type or _desc:
257                 fields.append((_name, _type, _desc,))
258         return fields
259 
260     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
261         line = next(self._line_iter)
262         _type, colon, _desc = self._partition_field_on_colon(line)
263         if not colon or not _desc:
264             _type, _desc = _desc, _type
265             _desc += colon
266         _descs = [_desc] + self._dedent(self._consume_to_end())
267         _descs = self.__class__(_descs, self._config).lines()
268         return _type, _descs
269 
270     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
271         lines = self._dedent(self._consume_to_next_section())
272         if lines:
273             before, colon, after = self._partition_field_on_colon(lines[0])
274             _name, _type, _desc = '', '', lines
275 
276             if colon:
277                 if after:
278                     _desc = [after] + lines[1:]
279                 else:
280                     _desc = lines[1:]
281 
282                 _type = before
283 
284             _desc = self.__class__(_desc, self._config).lines()
285             return [(_name, _type, _desc,)]
286         else:
287             return []
288 
289     def _consume_usage_section(self) -> List[str]:
290         lines = self._dedent(self._consume_to_next_section())
291         return lines
292 
293     def _consume_section_header(self) -> str:
294         section = next(self._line_iter)
295         stripped_section = section.strip(':')
296         if stripped_section.lower() in self._sections:
297             section = stripped_section
298         return section
299 
300     def _consume_to_end(self) -> List[str]:
301         lines = []
302         while self._line_iter.has_next():
303             lines.append(next(self._line_iter))
304         return lines
305 
306     def _consume_to_next_section(self) -> List[str]:
307         self._consume_empty()
308         lines = []
309         while not self._is_section_break():
310             lines.append(next(self._line_iter))
311         return lines + self._consume_empty()
312 
313     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:
314         if full:
315             return [line.lstrip() for line in lines]
316         else:
317             min_indent = self._get_min_indent(lines)
318             return [line[min_indent:] for line in lines]
319 
320     def _escape_args_and_kwargs(self, name: str) -> str:
321         if name.endswith('_'):
322             name = name[:-1] + r'\_'
323 
324         if name[:2] == '**':
325             return r'\*\*' + name[2:]
326         elif name[:1] == '*':
327             return r'\*' + name[1:]
328         else:
329             return name
330 
331     def _fix_field_desc(self, desc: List[str]) -> List[str]:
332         if self._is_list(desc):
333             desc = [''] + desc
334         elif desc[0].endswith('::'):
335             desc_block = desc[1:]
336             indent = self._get_indent(desc[0])
337             block_indent = self._get_initial_indent(desc_block)
338             if block_indent > indent:
339                 desc = [''] + desc
340             else:
341                 desc = ['', desc[0]] + self._indent(desc_block, 4)
342         return desc
343 
344     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:
345         lines = self._strip_empty(lines)
346         if len(lines) == 1:
347             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']
348         elif lines:
349             lines = self._indent(self._dedent(lines), 3)
350             return ['.. %s::' % admonition, ''] + lines + ['']
351         else:
352             return ['.. %s::' % admonition, '']
353 
354     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:
355         if lines:
356             if padding is None:
357                 padding = ' ' * len(prefix)
358             result_lines = []
359             for i, line in enumerate(lines):
360                 if i == 0:
361                     result_lines.append((prefix + line).rstrip())
362                 elif line:
363                     result_lines.append(padding + line)
364                 else:
365                     result_lines.append('')
366             return result_lines
367         else:
368             return [prefix]
369 
370     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],
371                                 field_role: str = 'param', type_role: str = 'type'
372                                 ) -> List[str]:
373         lines = []
374         for _name, _type, _desc in fields:
375             _desc = self._strip_empty(_desc)
376             if any(_desc):
377                 _desc = self._fix_field_desc(_desc)
378                 field = ':%s %s: ' % (field_role, _name)
379                 lines.extend(self._format_block(field, _desc))
380             else:
381                 lines.append(':%s %s:' % (field_role, _name))
382 
383             if _type:
384                 lines.append(':%s %s: %s' % (type_role, _name, _type))
385         return lines + ['']
386 
387     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:
388         _desc = self._strip_empty(_desc)
389         has_desc = any(_desc)
390         separator = ' -- ' if has_desc else ''
391         if _name:
392             if _type:
393                 if '`' in _type:
394                     field = '**%s** (%s)%s' % (_name, _type, separator)
395                 else:
396                     field = '**%s** (*%s*)%s' % (_name, _type, separator)
397             else:
398                 field = '**%s**%s' % (_name, separator)
399         elif _type:
400             if '`' in _type:
401                 field = '%s%s' % (_type, separator)
402             else:
403                 field = '*%s*%s' % (_type, separator)
404         else:
405             field = ''
406 
407         if has_desc:
408             _desc = self._fix_field_desc(_desc)
409             if _desc[0]:
410                 return [field + _desc[0]] + _desc[1:]
411             else:
412                 return [field] + _desc
413         else:
414             return [field]
415 
416     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]
417                        ) -> List[str]:
418         field_type = ':%s:' % field_type.strip()
419         padding = ' ' * len(field_type)
420         multi = len(fields) > 1
421         lines = []  # type: List[str]
422         for _name, _type, _desc in fields:
423             field = self._format_field(_name, _type, _desc)
424             if multi:
425                 if lines:
426                     lines.extend(self._format_block(padding + ' * ', field))
427                 else:
428                     lines.extend(self._format_block(field_type + ' * ', field))
429             else:
430                 lines.extend(self._format_block(field_type + ' ', field))
431         if lines and lines[-1]:
432             lines.append('')
433         return lines
434 
435     def _get_current_indent(self, peek_ahead: int = 0) -> int:
436         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
437         while line != self._line_iter.sentinel:
438             if line:
439                 return self._get_indent(line)
440             peek_ahead += 1
441             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
442         return 0
443 
444     def _get_indent(self, line: str) -> int:
445         for i, s in enumerate(line):
446             if not s.isspace():
447                 return i
448         return len(line)
449 
450     def _get_initial_indent(self, lines: List[str]) -> int:
451         for line in lines:
452             if line:
453                 return self._get_indent(line)
454         return 0
455 
456     def _get_min_indent(self, lines: List[str]) -> int:
457         min_indent = None
458         for line in lines:
459             if line:
460                 indent = self._get_indent(line)
461                 if min_indent is None:
462                     min_indent = indent
463                 elif indent < min_indent:
464                     min_indent = indent
465         return min_indent or 0
466 
467     def _indent(self, lines: List[str], n: int = 4) -> List[str]:
468         return [(' ' * n) + line for line in lines]
469 
470     def _is_indented(self, line: str, indent: int = 1) -> bool:
471         for i, s in enumerate(line):
472             if i >= indent:
473                 return True
474             elif not s.isspace():
475                 return False
476         return False
477 
478     def _is_list(self, lines: List[str]) -> bool:
479         if not lines:
480             return False
481         if _bullet_list_regex.match(lines[0]):
482             return True
483         if _enumerated_list_regex.match(lines[0]):
484             return True
485         if len(lines) < 2 or lines[0].endswith('::'):
486             return False
487         indent = self._get_indent(lines[0])
488         next_indent = indent
489         for line in lines[1:]:
490             if line:
491                 next_indent = self._get_indent(line)
492                 break
493         return next_indent > indent
494 
495     def _is_section_header(self) -> bool:
496         section = self._line_iter.peek().lower()
497         match = _google_section_regex.match(section)
498         if match and section.strip(':') in self._sections:
499             header_indent = self._get_indent(section)
500             section_indent = self._get_current_indent(peek_ahead=1)
501             return section_indent > header_indent
502         elif self._directive_sections:
503             if _directive_regex.match(section):
504                 for directive_section in self._directive_sections:
505                     if section.startswith(directive_section):
506                         return True
507         return False
508 
509     def _is_section_break(self) -> bool:
510         line = self._line_iter.peek()
511         return (not self._line_iter.has_next() or
512                 self._is_section_header() or
513                 (self._is_in_section and
514                     line and
515                     not self._is_indented(line, self._section_indent)))
516 
517     def _load_custom_sections(self) -> None:
518         if self._config.napoleon_custom_sections is not None:
519             for entry in self._config.napoleon_custom_sections:
520                 if isinstance(entry, str):
521                     # if entry is just a label, add to sections list,
522                     # using generic section logic.
523                     self._sections[entry.lower()] = self._parse_custom_generic_section
524                 else:
525                     # otherwise, assume entry is container;
526                     # [0] is new section, [1] is the section to alias.
527                     # in the case of key mismatch, just handle as generic section.
528                     self._sections[entry[0].lower()] = \
529                         self._sections.get(entry[1].lower(),
530                                            self._parse_custom_generic_section)
531 
532     def _parse(self) -> None:
533         self._parsed_lines = self._consume_empty()
534 
535         if self._name and self._what in ('attribute', 'data', 'property'):
536             # Implicit stop using StopIteration no longer allowed in
537             # Python 3.7; see PEP 479
538             res = []  # type: List[str]
539             try:
540                 res = self._parse_attribute_docstring()
541             except StopIteration:
542                 pass
543             self._parsed_lines.extend(res)
544             return
545 
546         while self._line_iter.has_next():
547             if self._is_section_header():
548                 try:
549                     section = self._consume_section_header()
550                     self._is_in_section = True
551                     self._section_indent = self._get_current_indent()
552                     if _directive_regex.match(section):
553                         lines = [section] + self._consume_to_next_section()
554                     else:
555                         lines = self._sections[section.lower()](section)
556                 finally:
557                     self._is_in_section = False
558                     self._section_indent = 0
559             else:
560                 if not self._parsed_lines:
561                     lines = self._consume_contiguous() + self._consume_empty()
562                 else:
563                     lines = self._consume_to_next_section()
564             self._parsed_lines.extend(lines)
565 
566     def _parse_admonition(self, admonition: str, section: str) -> List[str]:
567         # type (str, str) -> List[str]
568         lines = self._consume_to_next_section()
569         return self._format_admonition(admonition, lines)
570 
571     def _parse_attribute_docstring(self) -> List[str]:
572         _type, _desc = self._consume_inline_attribute()
573         lines = self._format_field('', '', _desc)
574         if _type:
575             lines.extend(['', ':type: %s' % _type])
576         return lines
577 
578     def _parse_attributes_section(self, section: str) -> List[str]:
579         lines = []
580         for _name, _type, _desc in self._consume_fields():
581             if self._config.napoleon_use_ivar:
582                 _name = self._qualify_name(_name, self._obj)
583                 field = ':ivar %s: ' % _name
584                 lines.extend(self._format_block(field, _desc))
585                 if _type:
586                     lines.append(':vartype %s: %s' % (_name, _type))
587             else:
588                 lines.append('.. attribute:: ' + _name)
589                 if self._opt and 'noindex' in self._opt:
590                     lines.append('   :noindex:')
591                 if _type:
592                     lines.extend(self._indent([':type: %s' % _type], 3))
593                 lines.append('')
594 
595                 fields = self._format_field('', '', _desc)
596                 lines.extend(self._indent(fields, 3))
597                 lines.append('')
598         if self._config.napoleon_use_ivar:
599             lines.append('')
600         return lines
601 
602     def _parse_examples_section(self, section: str) -> List[str]:
603         labels = {
604             'example': _('Example'),
605             'examples': _('Examples'),
606         }
607         use_admonition = self._config.napoleon_use_admonition_for_examples
608         label = labels.get(section.lower(), section)
609         return self._parse_generic_section(label, use_admonition)
610 
611     def _parse_custom_generic_section(self, section: str) -> List[str]:
612         # for now, no admonition for simple custom sections
613         return self._parse_generic_section(section, False)
614 
615     def _parse_usage_section(self, section: str) -> List[str]:
616         header = ['.. rubric:: Usage:', '']
617         block = ['.. code-block:: python', '']
618         lines = self._consume_usage_section()
619         lines = self._indent(lines, 3)
620         return header + block + lines + ['']
621 
622     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:
623         lines = self._strip_empty(self._consume_to_next_section())
624         lines = self._dedent(lines)
625         if use_admonition:
626             header = '.. admonition:: %s' % section
627             lines = self._indent(lines, 3)
628         else:
629             header = '.. rubric:: %s' % section
630         if lines:
631             return [header, ''] + lines + ['']
632         else:
633             return [header, '']
634 
635     def _parse_keyword_arguments_section(self, section: str) -> List[str]:
636         fields = self._consume_fields()
637         if self._config.napoleon_use_keyword:
638             return self._format_docutils_params(
639                 fields,
640                 field_role="keyword",
641                 type_role="kwtype")
642         else:
643             return self._format_fields(_('Keyword Arguments'), fields)
644 
645     def _parse_methods_section(self, section: str) -> List[str]:
646         lines = []  # type: List[str]
647         for _name, _type, _desc in self._consume_fields(parse_type=False):
648             lines.append('.. method:: %s' % _name)
649             if self._opt and 'noindex' in self._opt:
650                 lines.append('   :noindex:')
651             if _desc:
652                 lines.extend([''] + self._indent(_desc, 3))
653             lines.append('')
654         return lines
655 
656     def _parse_notes_section(self, section: str) -> List[str]:
657         use_admonition = self._config.napoleon_use_admonition_for_notes
658         return self._parse_generic_section(_('Notes'), use_admonition)
659 
660     def _parse_other_parameters_section(self, section: str) -> List[str]:
661         return self._format_fields(_('Other Parameters'), self._consume_fields())
662 
663     def _parse_parameters_section(self, section: str) -> List[str]:
664         fields = self._consume_fields()
665         if self._config.napoleon_use_param:
666             return self._format_docutils_params(fields)
667         else:
668             return self._format_fields(_('Parameters'), fields)
669 
670     def _parse_raises_section(self, section: str) -> List[str]:
671         fields = self._consume_fields(parse_type=False, prefer_type=True)
672         lines = []  # type: List[str]
673         for _name, _type, _desc in fields:
674             m = self._name_rgx.match(_type)
675             if m and m.group('name'):
676                 _type = m.group('name')
677             _type = ' ' + _type if _type else ''
678             _desc = self._strip_empty(_desc)
679             _descs = ' ' + '\n    '.join(_desc) if any(_desc) else ''
680             lines.append(':raises%s:%s' % (_type, _descs))
681         if lines:
682             lines.append('')
683         return lines
684 
685     def _parse_references_section(self, section: str) -> List[str]:
686         use_admonition = self._config.napoleon_use_admonition_for_references
687         return self._parse_generic_section(_('References'), use_admonition)
688 
689     def _parse_returns_section(self, section: str) -> List[str]:
690         fields = self._consume_returns_section()
691         multi = len(fields) > 1
692         if multi:
693             use_rtype = False
694         else:
695             use_rtype = self._config.napoleon_use_rtype
696 
697         lines = []  # type: List[str]
698         for _name, _type, _desc in fields:
699             if use_rtype:
700                 field = self._format_field(_name, '', _desc)
701             else:
702                 field = self._format_field(_name, _type, _desc)
703 
704             if multi:
705                 if lines:
706                     lines.extend(self._format_block('          * ', field))
707                 else:
708                     lines.extend(self._format_block(':returns: * ', field))
709             else:
710                 lines.extend(self._format_block(':returns: ', field))
711                 if _type and use_rtype:
712                     lines.extend([':rtype: %s' % _type, ''])
713         if lines and lines[-1]:
714             lines.append('')
715         return lines
716 
717     def _parse_see_also_section(self, section: str) -> List[str]:
718         return self._parse_admonition('seealso', section)
719 
720     def _parse_warns_section(self, section: str) -> List[str]:
721         return self._format_fields(_('Warns'), self._consume_fields())
722 
723     def _parse_yields_section(self, section: str) -> List[str]:
724         fields = self._consume_returns_section()
725         return self._format_fields(_('Yields'), fields)
726 
727     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:
728         before_colon = []
729         after_colon = []
730         colon = ''
731         found_colon = False
732         for i, source in enumerate(_xref_or_code_regex.split(line)):
733             if found_colon:
734                 after_colon.append(source)
735             else:
736                 m = _single_colon_regex.search(source)
737                 if (i % 2) == 0 and m:
738                     found_colon = True
739                     colon = source[m.start(): m.end()]
740                     before_colon.append(source[:m.start()])
741                     after_colon.append(source[m.end():])
742                 else:
743                     before_colon.append(source)
744 
745         return ("".join(before_colon).strip(),
746                 colon,
747                 "".join(after_colon).strip())
748 
749     def _qualify_name(self, attr_name: str, klass: "Type") -> str:
750         if klass and '.' not in attr_name:
751             if attr_name.startswith('~'):
752                 attr_name = attr_name[1:]
753             try:
754                 q = klass.__qualname__
755             except AttributeError:
756                 q = klass.__name__
757             return '~%s.%s' % (q, attr_name)
758         return attr_name
759 
760     def _strip_empty(self, lines: List[str]) -> List[str]:
761         if lines:
762             start = -1
763             for i, line in enumerate(lines):
764                 if line:
765                     start = i
766                     break
767             if start == -1:
768                 lines = []
769             end = -1
770             for i in reversed(range(len(lines))):
771                 line = lines[i]
772                 if line:
773                     end = i
774                     break
775             if start > 0 or end + 1 < len(lines):
776                 lines = lines[start:end + 1]
777         return lines
778 
779 
780 class NumpyDocstring(GoogleDocstring):
781     """Convert NumPy style docstrings to reStructuredText.
782 
783     Parameters
784     ----------
785     docstring : :obj:`str` or :obj:`list` of :obj:`str`
786         The docstring to parse, given either as a string or split into
787         individual lines.
788     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
789         The configuration settings to use. If not given, defaults to the
790         config object on `app`; or if `app` is not given defaults to the
791         a new :class:`sphinx.ext.napoleon.Config` object.
792 
793 
794     Other Parameters
795     ----------------
796     app : :class:`sphinx.application.Sphinx`, optional
797         Application object representing the Sphinx process.
798     what : :obj:`str`, optional
799         A string specifying the type of the object to which the docstring
800         belongs. Valid values: "module", "class", "exception", "function",
801         "method", "attribute".
802     name : :obj:`str`, optional
803         The fully qualified name of the object.
804     obj : module, class, exception, function, method, or attribute
805         The object to which the docstring belongs.
806     options : :class:`sphinx.ext.autodoc.Options`, optional
807         The options given to the directive: an object with attributes
808         inherited_members, undoc_members, show_inheritance and noindex that
809         are True if the flag option of same name was given to the auto
810         directive.
811 
812 
813     Example
814     -------
815     >>> from sphinx.ext.napoleon import Config
816     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
817     >>> docstring = '''One line summary.
818     ...
819     ... Extended description.
820     ...
821     ... Parameters
822     ... ----------
823     ... arg1 : int
824     ...     Description of `arg1`
825     ... arg2 : str
826     ...     Description of `arg2`
827     ... Returns
828     ... -------
829     ... str
830     ...     Description of return value.
831     ... '''
832     >>> print(NumpyDocstring(docstring, config))
833     One line summary.
834     <BLANKLINE>
835     Extended description.
836     <BLANKLINE>
837     :param arg1: Description of `arg1`
838     :type arg1: int
839     :param arg2: Description of `arg2`
840     :type arg2: str
841     <BLANKLINE>
842     :returns: Description of return value.
843     :rtype: str
844     <BLANKLINE>
845 
846     Methods
847     -------
848     __str__()
849         Return the parsed docstring in reStructuredText format.
850 
851         Returns
852         -------
853         str
854             UTF-8 encoded version of the docstring.
855 
856     __unicode__()
857         Return the parsed docstring in reStructuredText format.
858 
859         Returns
860         -------
861         unicode
862             Unicode version of the docstring.
863 
864     lines()
865         Return the parsed lines of the docstring in reStructuredText format.
866 
867         Returns
868         -------
869         list(str)
870             The lines of the docstring in a list.
871 
872     """
873     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
874                  app: Sphinx = None, what: str = '', name: str = '',
875                  obj: Any = None, options: Any = None) -> None:
876         self._directive_sections = ['.. index::']
877         super().__init__(docstring, config, app, what, name, obj, options)
878 
879     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
880                        ) -> Tuple[str, str, List[str]]:
881         line = next(self._line_iter)
882         if parse_type:
883             _name, _, _type = self._partition_field_on_colon(line)
884         else:
885             _name, _type = line, ''
886         _name, _type = _name.strip(), _type.strip()
887         _name = self._escape_args_and_kwargs(_name)
888 
889         if prefer_type and not _type:
890             _type, _name = _name, _type
891         indent = self._get_indent(line) + 1
892         _desc = self._dedent(self._consume_indented_block(indent))
893         _desc = self.__class__(_desc, self._config).lines()
894         return _name, _type, _desc
895 
896     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
897         return self._consume_fields(prefer_type=True)
898 
899     def _consume_section_header(self) -> str:
900         section = next(self._line_iter)
901         if not _directive_regex.match(section):
902             # Consume the header underline
903             next(self._line_iter)
904         return section
905 
906     def _is_section_break(self) -> bool:
907         line1, line2 = self._line_iter.peek(2)
908         return (not self._line_iter.has_next() or
909                 self._is_section_header() or
910                 ['', ''] == [line1, line2] or
911                 (self._is_in_section and
912                     line1 and
913                     not self._is_indented(line1, self._section_indent)))
914 
915     def _is_section_header(self) -> bool:
916         section, underline = self._line_iter.peek(2)
917         section = section.lower()
918         if section in self._sections and isinstance(underline, str):
919             return bool(_numpy_section_regex.match(underline))
920         elif self._directive_sections:
921             if _directive_regex.match(section):
922                 for directive_section in self._directive_sections:
923                     if section.startswith(directive_section):
924                         return True
925         return False
926 
927     def _parse_see_also_section(self, section: str) -> List[str]:
928         lines = self._consume_to_next_section()
929         try:
930             return self._parse_numpydoc_see_also_section(lines)
931         except ValueError:
932             return self._format_admonition('seealso', lines)
933 
934     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:
935         """
936         Derived from the NumpyDoc implementation of _parse_see_also.
937 
938         See Also
939         --------
940         func_name : Descriptive text
941             continued text
942         another_func_name : Descriptive text
943         func_name1, func_name2, :meth:`func_name`, func_name3
944 
945         """
946         items = []
947 
948         def parse_item_name(text: str) -> Tuple[str, str]:
949             """Match ':role:`name`' or 'name'"""
950             m = self._name_rgx.match(text)
951             if m:
952                 g = m.groups()
953                 if g[1] is None:
954                     return g[3], None
955                 else:
956                     return g[2], g[1]
957             raise ValueError("%s is not a item name" % text)
958 
959         def push_item(name: str, rest: List[str]) -> None:
960             if not name:
961                 return
962             name, role = parse_item_name(name)
963             items.append((name, list(rest), role))
964             del rest[:]
965 
966         current_func = None
967         rest = []  # type: List[str]
968 
969         for line in content:
970             if not line.strip():
971                 continue
972 
973             m = self._name_rgx.match(line)
974             if m and line[m.end():].strip().startswith(':'):
975                 push_item(current_func, rest)
976                 current_func, line = line[:m.end()], line[m.end():]
977                 rest = [line.split(':', 1)[1].strip()]
978                 if not rest[0]:
979                     rest = []
980             elif not line.startswith(' '):
981                 push_item(current_func, rest)
982                 current_func = None
983                 if ',' in line:
984                     for func in line.split(','):
985                         if func.strip():
986                             push_item(func, [])
987                 elif line.strip():
988                     current_func = line
989             elif current_func is not None:
990                 rest.append(line.strip())
991         push_item(current_func, rest)
992 
993         if not items:
994             return []
995 
996         roles = {
997             'method': 'meth',
998             'meth': 'meth',
999             'function': 'func',
1000             'func': 'func',
1001             'class': 'class',
1002             'exception': 'exc',
1003             'exc': 'exc',
1004             'object': 'obj',
1005             'obj': 'obj',
1006             'module': 'mod',
1007             'mod': 'mod',
1008             'data': 'data',
1009             'constant': 'const',
1010             'const': 'const',
1011             'attribute': 'attr',
1012             'attr': 'attr'
1013         }
1014         if self._what is None:
1015             func_role = 'obj'
1016         else:
1017             func_role = roles.get(self._what, '')
1018         lines = []  # type: List[str]
1019         last_had_desc = True
1020         for func, desc, role in items:
1021             if role:
1022                 link = ':%s:`%s`' % (role, func)
1023             elif func_role:
1024                 link = ':%s:`%s`' % (func_role, func)
1025             else:
1026                 link = "`%s`_" % func
1027             if desc or last_had_desc:
1028                 lines += ['']
1029                 lines += [link]
1030             else:
1031                 lines[-1] += ", %s" % link
1032             if desc:
1033                 lines += self._indent([' '.join(desc)])
1034                 last_had_desc = True
1035             else:
1036                 last_had_desc = False
1037         lines += ['']
1038 
1039         return self._format_admonition('seealso', lines)

</code><intended_behavior>This file should process attribute docstrings in a way that trailing underscores in attribute names are recognized as part of the identifier and not as characters requiring escape sequences in the generated HTML. The intended behavior is to ensure that when Napoleon parses attribute sections, it correctly formats attribute names, preserving trailing underscores without adding a backslash for the HTML output. This preserves the existing functionality for document generation while fixing the issue with attribute name representation.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union
20 )
21 
22 from docutils.statemachine import StringList
23 
24 import sphinx
25 from sphinx.application import Sphinx
26 from sphinx.config import Config, ENUM
27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
28 from sphinx.environment import BuildEnvironment
29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
30 from sphinx.ext.autodoc.mock import mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect
34 from sphinx.util import logging
35 from sphinx.util import split_full_qualified_name
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43     from sphinx.ext.autodoc.directive import DocumenterBridge
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 
49 # This type isn't exposed directly in any modules, but can be found
50 # here in most Python versions
51 MethodDescriptorType = type(type.__subclasses__)
52 
53 
54 #: extended signature RE: with explicit module name separated by ::
55 py_ext_sig_re = re.compile(
56     r'''^ ([\w.]+::)?            # explicit module name
57           ([\w.]+\.)?            # module and/or class name(s)
58           (\w+)  \s*             # thing name
59           (?: \((.*)\)           # optional: arguments
60            (?:\s* -> \s* (.*))?  #           return annotation
61           )? $                   # and nothing more
62           ''', re.VERBOSE)
63 
64 
65 def identity(x: Any) -> Any:
66     return x
67 
68 
69 ALL = object()
70 UNINITIALIZED_ATTR = object()
71 INSTANCEATTR = object()
72 SLOTSATTR = object()
73 
74 
75 def members_option(arg: Any) -> Union[object, List[str]]:
76     """Used to convert the :members: option to auto directives."""
77     if arg is None or arg is True:
78         return ALL
79     return [x.strip() for x in arg.split(',') if x.strip()]
80 
81 
82 def members_set_option(arg: Any) -> Union[object, Set[str]]:
83     """Used to convert the :members: option to auto directives."""
84     if arg is None:
85         return ALL
86     return {x.strip() for x in arg.split(',') if x.strip()}
87 
88 
89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
90     """Used to convert the :members: option to auto directives."""
91     if arg is None:
92         return 'object'
93     else:
94         return arg
95 
96 
97 def member_order_option(arg: Any) -> Optional[str]:
98     """Used to convert the :members: option to auto directives."""
99     if arg is None:
100         return None
101     elif arg in ('alphabetical', 'bysource', 'groupwise'):
102         return arg
103     else:
104         raise ValueError(__('invalid value for member-order option: %s') % arg)
105 
106 
107 SUPPRESS = object()
108 
109 
110 def annotation_option(arg: Any) -> Any:
111     if arg is None:
112         # suppress showing the representation of the object
113         return SUPPRESS
114     else:
115         return arg
116 
117 
118 def bool_option(arg: Any) -> bool:
119     """Used to convert flag options to auto directives.  (Instead of
120     directives.flag(), which returns None).
121     """
122     return True
123 
124 
125 def merge_special_members_option(options: Dict) -> None:
126     """Merge :special-members: option to :members: option."""
127     if 'special-members' in options and options['special-members'] is not ALL:
128         if options.get('members') is ALL:
129             pass
130         elif options.get('members'):
131             for member in options['special-members']:
132                 if member not in options['members']:
133                     options['members'].append(member)
134         else:
135             options['members'] = options['special-members']
136 
137 
138 # Some useful event listener factories for autodoc-process-docstring.
139 
140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
141     """Return a listener that removes the first *pre* and last *post*
142     lines of every docstring.  If *what* is a sequence of strings,
143     only docstrings of a type in *what* will be processed.
144 
145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
146 
147        from sphinx.ext.autodoc import cut_lines
148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
149 
150     This can (and should) be used in place of :confval:`automodule_skip_lines`.
151     """
152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
153                 ) -> None:
154         if what and what_ not in what:
155             return
156         del lines[:pre]
157         if post:
158             # remove one trailing blank line.
159             if lines and not lines[-1]:
160                 lines.pop(-1)
161             del lines[-post:]
162         # make sure there is a blank line at the end
163         if lines and lines[-1]:
164             lines.append('')
165     return process
166 
167 
168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
169             exclude: bool = False) -> Callable:
170     """Return a listener that either keeps, or if *exclude* is True excludes,
171     lines between lines that match the *marker* regular expression.  If no line
172     matches, the resulting docstring would be empty, so no change will be made
173     unless *keepempty* is true.
174 
175     If *what* is a sequence of strings, only docstrings of a type in *what* will
176     be processed.
177     """
178     marker_re = re.compile(marker)
179 
180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
181                 ) -> None:
182         if what and what_ not in what:
183             return
184         deleted = 0
185         delete = not exclude
186         orig_lines = lines[:]
187         for i, line in enumerate(orig_lines):
188             if delete:
189                 lines.pop(i - deleted)
190                 deleted += 1
191             if marker_re.match(line):
192                 delete = not delete
193                 if delete:
194                     lines.pop(i - deleted)
195                     deleted += 1
196         if not lines and not keepempty:
197             lines[:] = orig_lines
198         # make sure there is a blank line at the end
199         if lines and lines[-1]:
200             lines.append('')
201     return process
202 
203 
204 # This class is used only in ``sphinx.ext.autodoc.directive``,
205 # But we define this class here to keep compatibility (see #4538)
206 class Options(dict):
207     """A dict/attribute hybrid that returns None on nonexisting keys."""
208     def __getattr__(self, name: str) -> Any:
209         try:
210             return self[name.replace('_', '-')]
211         except KeyError:
212             return None
213 
214 
215 class Documenter:
216     """
217     A Documenter knows how to autodocument a single object type.  When
218     registered with the AutoDirective, it will be used to document objects
219     of that type when needed by autodoc.
220 
221     Its *objtype* attribute selects what auto directive it is assigned to
222     (the directive name is 'auto' + objtype), and what directive it generates
223     by default, though that can be overridden by an attribute called
224     *directivetype*.
225 
226     A Documenter has an *option_spec* that works like a docutils directive's;
227     in fact, it will be used to parse an auto directive's options that matches
228     the documenter.
229     """
230     #: name by which the directive is called (auto...) and the default
231     #: generated directive name
232     objtype = 'object'
233     #: indentation by which to indent the directive content
234     content_indent = '   '
235     #: priority if multiple documenters return True from can_document_member
236     priority = 0
237     #: order if autodoc_member_order is set to 'groupwise'
238     member_order = 0
239     #: true if the generated content may contain titles
240     titles_allowed = False
241 
242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
243 
244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
245         """getattr() override for types such as Zope interfaces."""
246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
247 
248     @classmethod
249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
250                             ) -> bool:
251         """Called to see if a member can be documented by this documenter."""
252         raise NotImplementedError('must be implemented in subclasses')
253 
254     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
255         self.directive = directive
256         self.env = directive.env    # type: BuildEnvironment
257         self.options = directive.genopt
258         self.name = name
259         self.indent = indent
260         # the module and object path within the module, and the fully
261         # qualified name (all set after resolve_name succeeds)
262         self.modname = None         # type: str
263         self.module = None          # type: ModuleType
264         self.objpath = None         # type: List[str]
265         self.fullname = None        # type: str
266         # extra signature items (arguments and return annotation,
267         # also set after resolve_name succeeds)
268         self.args = None            # type: str
269         self.retann = None          # type: str
270         # the object to document (set after import_object succeeds)
271         self.object = None          # type: Any
272         self.object_name = None     # type: str
273         # the parent/owner of the object to document
274         self.parent = None          # type: Any
275         # the module analyzer to get at attribute docs, or None
276         self.analyzer = None        # type: ModuleAnalyzer
277 
278     @property
279     def documenters(self) -> Dict[str, "Type[Documenter]"]:
280         """Returns registered Documenter classes"""
281         return self.env.app.registry.documenters
282 
283     def add_line(self, line: str, source: str, *lineno: int) -> None:
284         """Append one line of generated reST to the output."""
285         if line.strip():  # not a blank line
286             self.directive.result.append(self.indent + line, source, *lineno)
287         else:
288             self.directive.result.append('', source, *lineno)
289 
290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
291                      ) -> Tuple[str, List[str]]:
292         """Resolve the module and name of the object to document given by the
293         arguments and the current module/class.
294 
295         Must return a pair of the module name and a chain of attributes; for
296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
297         ``zipfile.ZipFile.open`` method.
298         """
299         raise NotImplementedError('must be implemented in subclasses')
300 
301     def parse_name(self) -> bool:
302         """Determine what module to import and what attribute to document.
303 
304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
305         *self.args* and *self.retann* if parsing and resolving was successful.
306         """
307         # first, parse the definition -- auto directives for classes and
308         # functions can contain a signature which is then used instead of
309         # an autogenerated one
310         try:
311             explicit_modname, path, base, args, retann = \
312                 py_ext_sig_re.match(self.name).groups()
313         except AttributeError:
314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
315                            type='autodoc')
316             return False
317 
318         # support explicit module and class name separation via ::
319         if explicit_modname is not None:
320             modname = explicit_modname[:-2]
321             parents = path.rstrip('.').split('.') if path else []
322         else:
323             modname = None
324             parents = []
325 
326         with mock(self.env.config.autodoc_mock_imports):
327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
328 
329         if not self.modname:
330             return False
331 
332         self.args = args
333         self.retann = retann
334         self.fullname = (self.modname or '') + \
335                         ('.' + '.'.join(self.objpath) if self.objpath else '')
336         return True
337 
338     def import_object(self) -> bool:
339         """Import the object given by *self.modname* and *self.objpath* and set
340         it as *self.object*.
341 
342         Returns True if successful, False if an error occurred.
343         """
344         with mock(self.env.config.autodoc_mock_imports):
345             try:
346                 ret = import_object(self.modname, self.objpath, self.objtype,
347                                     attrgetter=self.get_attr,
348                                     warningiserror=self.env.config.autodoc_warningiserror)
349                 self.module, self.parent, self.object_name, self.object = ret
350                 return True
351             except ImportError as exc:
352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
353                 self.env.note_reread()
354                 return False
355 
356     def get_real_modname(self) -> str:
357         """Get the real module name of an object to document.
358 
359         It can differ from the name of the module through which the object was
360         imported.
361         """
362         return self.get_attr(self.object, '__module__', None) or self.modname
363 
364     def check_module(self) -> bool:
365         """Check if *self.object* is really defined in the module given by
366         *self.modname*.
367         """
368         if self.options.imported_members:
369             return True
370 
371         subject = inspect.unpartial(self.object)
372         modname = self.get_attr(subject, '__module__', None)
373         if modname and modname != self.modname:
374             return False
375         return True
376 
377     def format_args(self, **kwargs: Any) -> str:
378         """Format the argument signature of *self.object*.
379 
380         Should return None if the object does not have a signature.
381         """
382         return None
383 
384     def format_name(self) -> str:
385         """Format the name of *self.object*.
386 
387         This normally should be something that can be parsed by the generated
388         directive, but doesn't need to be (Sphinx will display it unparsed
389         then).
390         """
391         # normally the name doesn't contain the module (except for module
392         # directives of course)
393         return '.'.join(self.objpath) or self.modname
394 
395     def format_signature(self, **kwargs: Any) -> str:
396         """Format the signature (arguments and return annotation) of the object.
397 
398         Let the user process it via the ``autodoc-process-signature`` event.
399         """
400         if self.args is not None:
401             # signature given explicitly
402             args = "(%s)" % self.args
403             retann = self.retann
404         else:
405             # try to introspect the signature
406             try:
407                 retann = None
408                 try:
409                     args = self.format_args(**kwargs)
410                 except TypeError:
411                     # retry without arguments for old documenters
412                     args = self.format_args()
413 
414                 if args:
415                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
416                     if matched:
417                         args = matched.group(1)
418                         retann = matched.group(2)
419             except Exception:
420                 logger.warning(__('error while formatting arguments for %s:') %
421                                self.fullname, type='autodoc', exc_info=True)
422                 args = None
423 
424         result = self.env.events.emit_firstresult('autodoc-process-signature',
425                                                   self.objtype, self.fullname,
426                                                   self.object, self.options, args, retann)
427         if result:
428             args, retann = result
429 
430         if args is not None:
431             return args + ((' -> %s' % retann) if retann else '')
432         else:
433             return ''
434 
435     def add_directive_header(self, sig: str) -> None:
436         """Add the directive header and options to the generated content."""
437         domain = getattr(self, 'domain', 'py')
438         directive = getattr(self, 'directivetype', self.objtype)
439         name = self.format_name()
440         sourcename = self.get_sourcename()
441 
442         # one signature per line, indented by column
443         prefix = '.. %s:%s:: ' % (domain, directive)
444         for i, sig_line in enumerate(sig.split("\n")):
445             self.add_line('%s%s%s' % (prefix, name, sig_line),
446                           sourcename)
447             if i == 0:
448                 prefix = " " * len(prefix)
449 
450         if self.options.noindex:
451             self.add_line('   :noindex:', sourcename)
452         if self.objpath:
453             # Be explicit about the module, this is necessary since .. class::
454             # etc. don't support a prepended module name
455             self.add_line('   :module: %s' % self.modname, sourcename)
456 
457     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
458         """Decode and return lines of the docstring(s) for the object."""
459         if encoding is not None:
460             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
461                           % self.__class__.__name__,
462                           RemovedInSphinx40Warning, stacklevel=2)
463         if ignore is not None:
464             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
465                           % self.__class__.__name__,
466                           RemovedInSphinx50Warning, stacklevel=2)
467         docstring = getdoc(self.object, self.get_attr,
468                            self.env.config.autodoc_inherit_docstrings,
469                            self.parent, self.object_name)
470         if docstring:
471             tab_width = self.directive.state.document.settings.tab_width
472             return [prepare_docstring(docstring, ignore, tab_width)]
473         return []
474 
475     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
476         """Let the user process the docstrings before adding them."""
477         for docstringlines in docstrings:
478             if self.env.app:
479                 # let extensions preprocess docstrings
480                 self.env.app.emit('autodoc-process-docstring',
481                                   self.objtype, self.fullname, self.object,
482                                   self.options, docstringlines)
483             yield from docstringlines
484 
485     def get_sourcename(self) -> str:
486         if self.analyzer:
487             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
488         return 'docstring of %s' % self.fullname
489 
490     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
491         """Add content from docstrings, attribute documentation and user."""
492         # set sourcename and add content from attribute documentation
493         sourcename = self.get_sourcename()
494         if self.analyzer:
495             attr_docs = self.analyzer.find_attr_docs()
496             if self.objpath:
497                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
498                 if key in attr_docs:
499                     no_docstring = True
500                     # make a copy of docstring for attributes to avoid cache
501                     # the change of autodoc-process-docstring event.
502                     docstrings = [list(attr_docs[key])]
503 
504                     for i, line in enumerate(self.process_doc(docstrings)):
505                         self.add_line(line, sourcename, i)
506 
507         # add content from docstrings
508         if not no_docstring:
509             docstrings = self.get_doc()
510             if not docstrings:
511                 # append at least a dummy docstring, so that the event
512                 # autodoc-process-docstring is fired and can add some
513                 # content if desired
514                 docstrings.append([])
515             for i, line in enumerate(self.process_doc(docstrings)):
516                 self.add_line(line, sourcename, i)
517 
518         # add additional content (e.g. from document), if present
519         if more_content:
520             for line, src in zip(more_content.data, more_content.items):
521                 self.add_line(line, src[0], src[1])
522 
523     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
524         """Return `(members_check_module, members)` where `members` is a
525         list of `(membername, member)` pairs of the members of *self.object*.
526 
527         If *want_all* is True, return all members.  Else, only return those
528         members given by *self.options.members* (which may also be none).
529         """
530         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
531         if not want_all:
532             if not self.options.members:
533                 return False, []
534             # specific members given
535             selected = []
536             for name in self.options.members:
537                 if name in members:
538                     selected.append((name, members[name].value))
539                 else:
540                     logger.warning(__('missing attribute %s in object %s') %
541                                    (name, self.fullname), type='autodoc')
542             return False, selected
543         elif self.options.inherited_members:
544             return False, [(m.name, m.value) for m in members.values()]
545         else:
546             return False, [(m.name, m.value) for m in members.values()
547                            if m.directly_defined]
548 
549     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
550                        ) -> List[Tuple[str, Any, bool]]:
551         """Filter the given member list.
552 
553         Members are skipped if
554 
555         - they are private (except if given explicitly or the private-members
556           option is set)
557         - they are special methods (except if given explicitly or the
558           special-members option is set)
559         - they are undocumented (except if the undoc-members option is set)
560 
561         The user can override the skipping decision by connecting to the
562         ``autodoc-skip-member`` event.
563         """
564         def is_filtered_inherited_member(name: str) -> bool:
565             if inspect.isclass(self.object):
566                 for cls in self.object.__mro__:
567                     if cls.__name__ == self.options.inherited_members and cls != self.object:
568                         # given member is a member of specified *super class*
569                         return True
570                     elif name in cls.__dict__:
571                         return False
572 
573             return False
574 
575         ret = []
576 
577         # search for members in source code too
578         namespace = '.'.join(self.objpath)  # will be empty for modules
579 
580         if self.analyzer:
581             attr_docs = self.analyzer.find_attr_docs()
582         else:
583             attr_docs = {}
584 
585         # process members and determine which to skip
586         for (membername, member) in members:
587             # if isattr is True, the member is documented as an attribute
588             if member is INSTANCEATTR:
589                 isattr = True
590             else:
591                 isattr = False
592 
593             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
594                          self.parent, self.object_name)
595             if not isinstance(doc, str):
596                 # Ignore non-string __doc__
597                 doc = None
598 
599             # if the member __doc__ is the same as self's __doc__, it's just
600             # inherited and therefore not the member's doc
601             cls = self.get_attr(member, '__class__', None)
602             if cls:
603                 cls_doc = self.get_attr(cls, '__doc__', None)
604                 if cls_doc == doc:
605                     doc = None
606             has_doc = bool(doc)
607 
608             metadata = extract_metadata(doc)
609             if 'private' in metadata:
610                 # consider a member private if docstring has "private" metadata
611                 isprivate = True
612             elif 'public' in metadata:
613                 # consider a member public if docstring has "public" metadata
614                 isprivate = False
615             else:
616                 isprivate = membername.startswith('_')
617 
618             keep = False
619             if safe_getattr(member, '__sphinx_mock__', False):
620                 # mocked module or object
621                 pass
622             elif want_all and membername.startswith('__') and \
623                     membername.endswith('__') and len(membername) > 4:
624                 # special __methods__
625                 if self.options.special_members is ALL:
626                     if membername == '__doc__':
627                         keep = False
628                     elif is_filtered_inherited_member(membername):
629                         keep = False
630                     else:
631                         keep = has_doc or self.options.undoc_members
632                 elif self.options.special_members:
633                     if membername in self.options.special_members:
634                         keep = has_doc or self.options.undoc_members
635             elif (namespace, membername) in attr_docs:
636                 if want_all and isprivate:
637                     # ignore members whose name starts with _ by default
638                     keep = self.options.private_members
639                 else:
640                     # keep documented attributes
641                     keep = True
642                 isattr = True
643             elif want_all and isprivate:
644                 # ignore members whose name starts with _ by default
645                 keep = self.options.private_members and \
646                     (has_doc or self.options.undoc_members)
647             else:
648                 if self.options.members is ALL and is_filtered_inherited_member(membername):
649                     keep = False
650                 else:
651                     # ignore undocumented members if :undoc-members: is not given
652                     keep = has_doc or self.options.undoc_members
653 
654             # give the user a chance to decide whether this member
655             # should be skipped
656             if self.env.app:
657                 # let extensions preprocess docstrings
658                 try:
659                     skip_user = self.env.app.emit_firstresult(
660                         'autodoc-skip-member', self.objtype, membername, member,
661                         not keep, self.options)
662                     if skip_user is not None:
663                         keep = not skip_user
664                 except Exception as exc:
665                     logger.warning(__('autodoc: failed to determine %r to be documented, '
666                                       'the following exception was raised:\n%s'),
667                                    member, exc, type='autodoc')
668                     keep = False
669 
670             if keep:
671                 ret.append((membername, member, isattr))
672 
673         return ret
674 
675     def document_members(self, all_members: bool = False) -> None:
676         """Generate reST for member documentation.
677 
678         If *all_members* is True, do all members, else those given by
679         *self.options.members*.
680         """
681         # set current namespace for finding members
682         self.env.temp_data['autodoc:module'] = self.modname
683         if self.objpath:
684             self.env.temp_data['autodoc:class'] = self.objpath[0]
685 
686         want_all = all_members or self.options.inherited_members or \
687             self.options.members is ALL
688         # find out which members are documentable
689         members_check_module, members = self.get_object_members(want_all)
690 
691         # remove members given by exclude-members
692         if self.options.exclude_members:
693             members = [
694                 (membername, member) for (membername, member) in members
695                 if (
696                     self.options.exclude_members is ALL or
697                     membername not in self.options.exclude_members
698                 )
699             ]
700 
701         # document non-skipped members
702         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
703         for (mname, member, isattr) in self.filter_members(members, want_all):
704             classes = [cls for cls in self.documenters.values()
705                        if cls.can_document_member(member, mname, isattr, self)]
706             if not classes:
707                 # don't know how to document this member
708                 continue
709             # prefer the documenter with the highest priority
710             classes.sort(key=lambda cls: cls.priority)
711             # give explicitly separated module name, so that members
712             # of inner classes can be documented
713             full_mname = self.modname + '::' + \
714                 '.'.join(self.objpath + [mname])
715             documenter = classes[-1](self.directive, full_mname, self.indent)
716             memberdocumenters.append((documenter, isattr))
717         member_order = self.options.member_order or \
718             self.env.config.autodoc_member_order
719         if member_order == 'groupwise':
720             # sort by group; alphabetically within groups
721             memberdocumenters.sort(key=lambda e: (e[0].member_order, e[0].name))
722         elif member_order == 'bysource':
723             if self.analyzer:
724                 # sort by source order, by virtue of the module analyzer
725                 tagorder = self.analyzer.tagorder
726 
727                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
728                     fullname = entry[0].name.split('::')[1]
729                     return tagorder.get(fullname, len(tagorder))
730                 memberdocumenters.sort(key=keyfunc)
731             else:
732                 # Assume that member discovery order matches source order.
733                 # This is a reasonable assumption in Python 3.6 and up, where
734                 # module.__dict__ is insertion-ordered.
735                 pass
736         else:  # alphabetical
737             memberdocumenters.sort(key=lambda e: e[0].name)
738 
739         for documenter, isattr in memberdocumenters:
740             documenter.generate(
741                 all_members=True, real_modname=self.real_modname,
742                 check_module=members_check_module and not isattr)
743 
744         # reset current objects
745         self.env.temp_data['autodoc:module'] = None
746         self.env.temp_data['autodoc:class'] = None
747 
748     def generate(self, more_content: Any = None, real_modname: str = None,
749                  check_module: bool = False, all_members: bool = False) -> None:
750         """Generate reST for the object given by *self.name*, and possibly for
751         its members.
752 
753         If *more_content* is given, include that content. If *real_modname* is
754         given, use that module name to find attribute docs. If *check_module* is
755         True, only generate if the object is defined in the module name it is
756         imported from. If *all_members* is True, document all members.
757         """
758         if not self.parse_name():
759             # need a module to import
760             logger.warning(
761                 __('don\'t know which module to import for autodocumenting '
762                    '%r (try placing a "module" or "currentmodule" directive '
763                    'in the document, or giving an explicit module name)') %
764                 self.name, type='autodoc')
765             return
766 
767         # now, import the module and get object to document
768         if not self.import_object():
769             return
770 
771         # If there is no real module defined, figure out which to use.
772         # The real module is used in the module analyzer to look up the module
773         # where the attribute documentation would actually be found in.
774         # This is used for situations where you have a module that collects the
775         # functions and classes of internal submodules.
776         guess_modname = self.get_real_modname()
777         self.real_modname = real_modname or guess_modname
778 
779         # try to also get a source code analyzer for attribute docs
780         try:
781             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
782             # parse right now, to get PycodeErrors on parsing (results will
783             # be cached anyway)
784             self.analyzer.find_attr_docs()
785         except PycodeError:
786             logger.debug('[autodoc] module analyzer failed:', exc_info=True)
787             # no source file -- e.g. for builtin and C modules
788             self.analyzer = None
789             # at least add the module.__file__ as a dependency
790             if hasattr(self.module, '__file__') and self.module.__file__:
791                 self.directive.filename_set.add(self.module.__file__)
792         else:
793             self.directive.filename_set.add(self.analyzer.srcname)
794 
795         if self.real_modname != guess_modname:
796             # Add module to dependency list if target object is defined in other module.
797             try:
798                 analyzer = ModuleAnalyzer.for_module(guess_modname)
799                 self.directive.filename_set.add(analyzer.srcname)
800             except PycodeError:
801                 pass
802 
803         # check __module__ of object (for members not given explicitly)
804         if check_module:
805             if not self.check_module():
806                 return
807 
808         sourcename = self.get_sourcename()
809 
810         # make sure that the result starts with an empty line.  This is
811         # necessary for some situations where another directive preprocesses
812         # reST and no starting newline is present
813         self.add_line('', sourcename)
814 
815         # format the object's signature, if any
816         sig = self.format_signature()
817 
818         # generate the directive header and options, if applicable
819         self.add_directive_header(sig)
820         self.add_line('', sourcename)
821 
822         # e.g. the module directive doesn't have content
823         self.indent += self.content_indent
824 
825         # add all content (from docstrings, attribute docs etc.)
826         self.add_content(more_content)
827 
828         # document members, if possible
829         self.document_members(all_members)
830 
831 
832 class ModuleDocumenter(Documenter):
833     """
834     Specialized Documenter subclass for modules.
835     """
836     objtype = 'module'
837     content_indent = ''
838     titles_allowed = True
839 
840     option_spec = {
841         'members': members_option, 'undoc-members': bool_option,
842         'noindex': bool_option, 'inherited-members': inherited_members_option,
843         'show-inheritance': bool_option, 'synopsis': identity,
844         'platform': identity, 'deprecated': bool_option,
845         'member-order': member_order_option, 'exclude-members': members_set_option,
846         'private-members': bool_option, 'special-members': members_option,
847         'imported-members': bool_option, 'ignore-module-all': bool_option
848     }  # type: Dict[str, Callable]
849 
850     def __init__(self, *args: Any) -> None:
851         super().__init__(*args)
852         merge_special_members_option(self.options)
853 
854     @classmethod
855     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
856                             ) -> bool:
857         # don't document submodules automatically
858         return False
859 
860     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
861                      ) -> Tuple[str, List[str]]:
862         if modname is not None:
863             logger.warning(__('"::" in automodule name doesn\'t make sense'),
864                            type='autodoc')
865         return (path or '') + base, []
866 
867     def parse_name(self) -> bool:
868         ret = super().parse_name()
869         if self.args or self.retann:
870             logger.warning(__('signature arguments or return annotation '
871                               'given for automodule %s') % self.fullname,
872                            type='autodoc')
873         return ret
874 
875     def add_directive_header(self, sig: str) -> None:
876         Documenter.add_directive_header(self, sig)
877 
878         sourcename = self.get_sourcename()
879 
880         # add some module-specific options
881         if self.options.synopsis:
882             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
883         if self.options.platform:
884             self.add_line('   :platform: ' + self.options.platform, sourcename)
885         if self.options.deprecated:
886             self.add_line('   :deprecated:', sourcename)
887 
888     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
889         if want_all:
890             if (self.options.ignore_module_all or not
891                     hasattr(self.object, '__all__')):
892                 # for implicit module members, check __module__ to avoid
893                 # documenting imported objects
894                 return True, get_module_members(self.object)
895             else:
896                 memberlist = self.object.__all__
897                 # Sometimes __all__ is broken...
898                 if not isinstance(memberlist, (list, tuple)) or not \
899                    all(isinstance(entry, str) for entry in memberlist):
900                     logger.warning(
901                         __('__all__ should be a list of strings, not %r '
902                            '(in module %s) -- ignoring __all__') %
903                         (memberlist, self.fullname),
904                         type='autodoc'
905                     )
906                     # fall back to all members
907                     return True, get_module_members(self.object)
908         else:
909             memberlist = self.options.members or []
910         ret = []
911         for mname in memberlist:
912             try:
913                 ret.append((mname, safe_getattr(self.object, mname)))
914             except AttributeError:
915                 logger.warning(
916                     __('missing attribute mentioned in :members: or __all__: '
917                        'module %s, attribute %s') %
918                     (safe_getattr(self.object, '__name__', '???'), mname),
919                     type='autodoc'
920                 )
921         return False, ret
922 
923 
924 class ModuleLevelDocumenter(Documenter):
925     """
926     Specialized Documenter subclass for objects on module level (functions,
927     classes, data/constants).
928     """
929     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
930                      ) -> Tuple[str, List[str]]:
931         if modname is None:
932             if path:
933                 stripped = path.rstrip('.')
934                 modname, qualname = split_full_qualified_name(stripped)
935                 if qualname:
936                     parents = qualname.split(".")
937                 else:
938                     parents = []
939 
940             if modname is None:
941                 # if documenting a toplevel object without explicit module,
942                 # it can be contained in another auto directive ...
943                 modname = self.env.temp_data.get('autodoc:module')
944                 # ... or in the scope of a module directive
945                 if not modname:
946                     modname = self.env.ref_context.get('py:module')
947                 # ... else, it stays None, which means invalid
948         return modname, parents + [base]
949 
950 
951 class ClassLevelDocumenter(Documenter):
952     """
953     Specialized Documenter subclass for objects on class level (methods,
954     attributes).
955     """
956     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
957                      ) -> Tuple[str, List[str]]:
958         if modname is None:
959             if path:
960                 mod_cls = path.rstrip('.')
961             else:
962                 mod_cls = None
963                 # if documenting a class-level object without path,
964                 # there must be a current class, either from a parent
965                 # auto directive ...
966                 mod_cls = self.env.temp_data.get('autodoc:class')
967                 # ... or from a class directive
968                 if mod_cls is None:
969                     mod_cls = self.env.ref_context.get('py:class')
970                 # ... if still None, there's no way to know
971                 if mod_cls is None:
972                     return None, []
973 
974             try:
975                 modname, qualname = split_full_qualified_name(mod_cls)
976                 parents = qualname.split(".") if qualname else []
977             except ImportError:
978                 parents = mod_cls.split(".")
979 
980             # if the module name is still missing, get it like above
981             if not modname:
982                 modname = self.env.temp_data.get('autodoc:module')
983             if not modname:
984                 modname = self.env.ref_context.get('py:module')
985             # ... else, it stays None, which means invalid
986         return modname, parents + [base]
987 
988 
989 class DocstringSignatureMixin:
990     """
991     Mixin for FunctionDocumenter and MethodDocumenter to provide the
992     feature of reading the signature from the docstring.
993     """
994 
995     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
996         if encoding is not None:
997             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
998                           "deprecated." % self.__class__.__name__,
999                           RemovedInSphinx40Warning, stacklevel=2)
1000         docstrings = self.get_doc()
1001         self._new_docstrings = docstrings[:]
1002         result = None
1003         for i, doclines in enumerate(docstrings):
1004             # no lines in docstring, no match
1005             if not doclines:
1006                 continue
1007             # match first line of docstring against signature RE
1008             match = py_ext_sig_re.match(doclines[0])
1009             if not match:
1010                 continue
1011             exmod, path, base, args, retann = match.groups()
1012             # the base name must match ours
1013             valid_names = [self.objpath[-1]]  # type: ignore
1014             if isinstance(self, ClassDocumenter):
1015                 valid_names.append('__init__')
1016                 if hasattr(self.object, '__mro__'):
1017                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1018             if base not in valid_names:
1019                 continue
1020             # re-prepare docstring to ignore more leading indentation
1021             tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1022             self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
1023                                                         tabsize=tab_width)
1024             result = args, retann
1025             # don't look any further
1026             break
1027         return result
1028 
1029     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1030         if encoding is not None:
1031             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1032                           % self.__class__.__name__,
1033                           RemovedInSphinx40Warning, stacklevel=2)
1034         lines = getattr(self, '_new_docstrings', None)
1035         if lines is not None:
1036             return lines
1037         return super().get_doc(None, ignore)  # type: ignore
1038 
1039     def format_signature(self, **kwargs: Any) -> str:
1040         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1041             # only act if a signature is not explicitly given already, and if
1042             # the feature is enabled
1043             result = self._find_signature()
1044             if result is not None:
1045                 self.args, self.retann = result
1046         return super().format_signature(**kwargs)  # type: ignore
1047 
1048 
1049 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1050     """
1051     Mixin for AttributeDocumenter to provide the
1052     feature of stripping any function signature from the docstring.
1053     """
1054     def format_signature(self, **kwargs: Any) -> str:
1055         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1056             # only act if a signature is not explicitly given already, and if
1057             # the feature is enabled
1058             result = self._find_signature()
1059             if result is not None:
1060                 # Discarding _args is a only difference with
1061                 # DocstringSignatureMixin.format_signature.
1062                 # Documenter.format_signature use self.args value to format.
1063                 _args, self.retann = result
1064         return super().format_signature(**kwargs)
1065 
1066 
1067 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1068     """
1069     Specialized Documenter subclass for functions.
1070     """
1071     objtype = 'function'
1072     member_order = 30
1073 
1074     @classmethod
1075     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1076                             ) -> bool:
1077         # supports functions, builtins and bound methods exported at the module level
1078         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1079                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1080 
1081     def format_args(self, **kwargs: Any) -> str:
1082         if self.env.config.autodoc_typehints in ('none', 'description'):
1083             kwargs.setdefault('show_annotation', False)
1084 
1085         try:
1086             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1087             if inspect.is_singledispatch_function(self.object):
1088                 sig = inspect.signature(self.object, follow_wrapped=True)
1089             else:
1090                 sig = inspect.signature(self.object)
1091             args = stringify_signature(sig, **kwargs)
1092         except TypeError as exc:
1093             logger.warning(__("Failed to get a function signature for %s: %s"),
1094                            self.fullname, exc)
1095             return None
1096         except ValueError:
1097             args = ''
1098 
1099         if self.env.config.strip_signature_backslash:
1100             # escape backslashes for reST
1101             args = args.replace('\\', '\\\\')
1102         return args
1103 
1104     def document_members(self, all_members: bool = False) -> None:
1105         pass
1106 
1107     def add_directive_header(self, sig: str) -> None:
1108         sourcename = self.get_sourcename()
1109         super().add_directive_header(sig)
1110 
1111         if inspect.iscoroutinefunction(self.object):
1112             self.add_line('   :async:', sourcename)
1113 
1114     def format_signature(self, **kwargs: Any) -> str:
1115         sig = super().format_signature(**kwargs)
1116         sigs = [sig]
1117 
1118         if inspect.is_singledispatch_function(self.object):
1119             # append signature of singledispatch'ed functions
1120             for typ, func in self.object.registry.items():
1121                 if typ is object:
1122                     pass  # default implementation. skipped.
1123                 else:
1124                     self.annotate_to_first_argument(func, typ)
1125 
1126                     documenter = FunctionDocumenter(self.directive, '')
1127                     documenter.object = func
1128                     sigs.append(documenter.format_signature())
1129 
1130         return "\n".join(sigs)
1131 
1132     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1133         """Annotate type hint to the first argument of function if needed."""
1134         sig = inspect.signature(func)
1135         if len(sig.parameters) == 0:
1136             return
1137 
1138         params = list(sig.parameters.values())
1139         if params[0].annotation is Parameter.empty:
1140             params[0] = params[0].replace(annotation=typ)
1141             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1142 
1143 
1144 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1145     """
1146     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1147 
1148     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1149     """
1150 
1151 
1152 class DecoratorDocumenter(FunctionDocumenter):
1153     """
1154     Specialized Documenter subclass for decorator functions.
1155     """
1156     objtype = 'decorator'
1157 
1158     # must be lower than FunctionDocumenter
1159     priority = -1
1160 
1161     def format_args(self, **kwargs: Any) -> Any:
1162         args = super().format_args(**kwargs)
1163         if ',' in args:
1164             return args
1165         else:
1166             return None
1167 
1168 
1169 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1170     """
1171     Specialized Documenter subclass for classes.
1172     """
1173     objtype = 'class'
1174     member_order = 20
1175     option_spec = {
1176         'members': members_option, 'undoc-members': bool_option,
1177         'noindex': bool_option, 'inherited-members': inherited_members_option,
1178         'show-inheritance': bool_option, 'member-order': member_order_option,
1179         'exclude-members': members_set_option,
1180         'private-members': bool_option, 'special-members': members_option,
1181     }  # type: Dict[str, Callable]
1182 
1183     def __init__(self, *args: Any) -> None:
1184         super().__init__(*args)
1185         merge_special_members_option(self.options)
1186 
1187     @classmethod
1188     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1189                             ) -> bool:
1190         return isinstance(member, type)
1191 
1192     def import_object(self) -> Any:
1193         ret = super().import_object()
1194         # if the class is documented under another name, document it
1195         # as data/attribute
1196         if ret:
1197             if hasattr(self.object, '__name__'):
1198                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1199             else:
1200                 self.doc_as_attr = True
1201         return ret
1202 
1203     def format_args(self, **kwargs: Any) -> str:
1204         if self.env.config.autodoc_typehints in ('none', 'description'):
1205             kwargs.setdefault('show_annotation', False)
1206 
1207         # for classes, the relevant signature is the __init__ method's
1208         initmeth = self.get_attr(self.object, '__init__', None)
1209         # classes without __init__ method, default __init__ or
1210         # __init__ written in C?
1211         if initmeth is None or \
1212                 inspect.is_builtin_class_method(self.object, '__init__') or \
1213                 not(inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):
1214             return None
1215         try:
1216             self.env.app.emit('autodoc-before-process-signature', initmeth, True)
1217             sig = inspect.signature(initmeth, bound_method=True)
1218             return stringify_signature(sig, show_return_annotation=False, **kwargs)
1219         except TypeError:
1220             # still not possible: happens e.g. for old-style classes
1221             # with __init__ in C
1222             return None
1223 
1224     def format_signature(self, **kwargs: Any) -> str:
1225         if self.doc_as_attr:
1226             return ''
1227 
1228         return super().format_signature(**kwargs)
1229 
1230     def add_directive_header(self, sig: str) -> None:
1231         sourcename = self.get_sourcename()
1232 
1233         if self.doc_as_attr:
1234             self.directivetype = 'attribute'
1235         super().add_directive_header(sig)
1236 
1237         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1238             self.add_line('   :final:', sourcename)
1239 
1240         # add inheritance info, if wanted
1241         if not self.doc_as_attr and self.options.show_inheritance:
1242             sourcename = self.get_sourcename()
1243             self.add_line('', sourcename)
1244             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1245                 bases = [':class:`%s`' % b.__name__
1246                          if b.__module__ in ('__builtin__', 'builtins')
1247                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1248                          for b in self.object.__bases__]
1249                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1250                               sourcename)
1251 
1252     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1253         if encoding is not None:
1254             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1255                           % self.__class__.__name__,
1256                           RemovedInSphinx40Warning, stacklevel=2)
1257         lines = getattr(self, '_new_docstrings', None)
1258         if lines is not None:
1259             return lines
1260 
1261         content = self.env.config.autoclass_content
1262 
1263         docstrings = []
1264         attrdocstring = self.get_attr(self.object, '__doc__', None)
1265         if attrdocstring:
1266             docstrings.append(attrdocstring)
1267 
1268         # for classes, what the "docstring" is can be controlled via a
1269         # config value; the default is only the class docstring
1270         if content in ('both', 'init'):
1271             __init__ = self.get_attr(self.object, '__init__', None)
1272             initdocstring = getdoc(__init__, self.get_attr,
1273                                    self.env.config.autodoc_inherit_docstrings,
1274                                    self.parent, self.object_name)
1275             # for new-style classes, no __init__ means default __init__
1276             if (initdocstring is not None and
1277                 (initdocstring == object.__init__.__doc__ or  # for pypy
1278                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1279                 initdocstring = None
1280             if not initdocstring:
1281                 # try __new__
1282                 __new__ = self.get_attr(self.object, '__new__', None)
1283                 initdocstring = getdoc(__new__, self.get_attr,
1284                                        self.env.config.autodoc_inherit_docstrings,
1285                                        self.parent, self.object_name)
1286                 # for new-style classes, no __new__ means default __new__
1287                 if (initdocstring is not None and
1288                     (initdocstring == object.__new__.__doc__ or  # for pypy
1289                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1290                     initdocstring = None
1291             if initdocstring:
1292                 if content == 'init':
1293                     docstrings = [initdocstring]
1294                 else:
1295                     docstrings.append(initdocstring)
1296 
1297         tab_width = self.directive.state.document.settings.tab_width
1298         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1299 
1300     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1301         if self.doc_as_attr:
1302             classname = safe_getattr(self.object, '__qualname__', None)
1303             if not classname:
1304                 classname = safe_getattr(self.object, '__name__', None)
1305             if classname:
1306                 module = safe_getattr(self.object, '__module__', None)
1307                 parentmodule = safe_getattr(self.parent, '__module__', None)
1308                 if module and module != parentmodule:
1309                     classname = str(module) + '.' + str(classname)
1310                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1311                 super().add_content(content, no_docstring=True)
1312         else:
1313             super().add_content(more_content)
1314 
1315     def document_members(self, all_members: bool = False) -> None:
1316         if self.doc_as_attr:
1317             return
1318         super().document_members(all_members)
1319 
1320     def generate(self, more_content: Any = None, real_modname: str = None,
1321                  check_module: bool = False, all_members: bool = False) -> None:
1322         # Do not pass real_modname and use the name from the __module__
1323         # attribute of the class.
1324         # If a class gets imported into the module real_modname
1325         # the analyzer won't find the source of the class, if
1326         # it looks in real_modname.
1327         return super().generate(more_content=more_content,
1328                                 check_module=check_module,
1329                                 all_members=all_members)
1330 
1331 
1332 class ExceptionDocumenter(ClassDocumenter):
1333     """
1334     Specialized ClassDocumenter subclass for exceptions.
1335     """
1336     objtype = 'exception'
1337     member_order = 10
1338 
1339     # needs a higher priority than ClassDocumenter
1340     priority = 10
1341 
1342     @classmethod
1343     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1344                             ) -> bool:
1345         return isinstance(member, type) and issubclass(member, BaseException)
1346 
1347 
1348 class DataDocumenter(ModuleLevelDocumenter):
1349     """
1350     Specialized Documenter subclass for data items.
1351     """
1352     objtype = 'data'
1353     member_order = 40
1354     priority = -10
1355     option_spec = dict(ModuleLevelDocumenter.option_spec)
1356     option_spec["annotation"] = annotation_option
1357 
1358     @classmethod
1359     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1360                             ) -> bool:
1361         return isinstance(parent, ModuleDocumenter) and isattr
1362 
1363     def add_directive_header(self, sig: str) -> None:
1364         super().add_directive_header(sig)
1365         sourcename = self.get_sourcename()
1366         if not self.options.annotation:
1367             # obtain annotation for this data
1368             annotations = getattr(self.parent, '__annotations__', {})
1369             if annotations and self.objpath[-1] in annotations:
1370                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1371                 self.add_line('   :type: ' + objrepr, sourcename)
1372             else:
1373                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1374                 if self.analyzer and key in self.analyzer.annotations:
1375                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1376                                   sourcename)
1377 
1378             try:
1379                 if self.object is UNINITIALIZED_ATTR:
1380                     pass
1381                 else:
1382                     objrepr = object_description(self.object)
1383                     self.add_line('   :value: ' + objrepr, sourcename)
1384             except ValueError:
1385                 pass
1386         elif self.options.annotation is SUPPRESS:
1387             pass
1388         else:
1389             self.add_line('   :annotation: %s' % self.options.annotation,
1390                           sourcename)
1391 
1392     def document_members(self, all_members: bool = False) -> None:
1393         pass
1394 
1395     def get_real_modname(self) -> str:
1396         return self.get_attr(self.parent or self.object, '__module__', None) \
1397             or self.modname
1398 
1399 
1400 class DataDeclarationDocumenter(DataDocumenter):
1401     """
1402     Specialized Documenter subclass for data that cannot be imported
1403     because they are declared without initial value (refs: PEP-526).
1404     """
1405     objtype = 'datadecl'
1406     directivetype = 'data'
1407     member_order = 60
1408 
1409     # must be higher than AttributeDocumenter
1410     priority = 11
1411 
1412     @classmethod
1413     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1414                             ) -> bool:
1415         """This documents only INSTANCEATTR members."""
1416         return (isinstance(parent, ModuleDocumenter) and
1417                 isattr and
1418                 member is INSTANCEATTR)
1419 
1420     def import_object(self) -> bool:
1421         """Never import anything."""
1422         # disguise as a data
1423         self.objtype = 'data'
1424         self.object = UNINITIALIZED_ATTR
1425         try:
1426             # import module to obtain type annotation
1427             self.parent = importlib.import_module(self.modname)
1428         except ImportError:
1429             pass
1430 
1431         return True
1432 
1433     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1434         """Never try to get a docstring from the object."""
1435         super().add_content(more_content, no_docstring=True)
1436 
1437 
1438 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1439     """
1440     Specialized Documenter subclass for methods (normal, static and class).
1441     """
1442     objtype = 'method'
1443     directivetype = 'method'
1444     member_order = 50
1445     priority = 1  # must be more than FunctionDocumenter
1446 
1447     @classmethod
1448     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1449                             ) -> bool:
1450         return inspect.isroutine(member) and \
1451             not isinstance(parent, ModuleDocumenter)
1452 
1453     def import_object(self) -> Any:
1454         ret = super().import_object()
1455         if not ret:
1456             return ret
1457 
1458         # to distinguish classmethod/staticmethod
1459         obj = self.parent.__dict__.get(self.object_name)
1460         if obj is None:
1461             obj = self.object
1462 
1463         if (inspect.isclassmethod(obj) or
1464                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1465             # document class and static members before ordinary ones
1466             self.member_order = self.member_order - 1
1467 
1468         return ret
1469 
1470     def format_args(self, **kwargs: Any) -> str:
1471         if self.env.config.autodoc_typehints in ('none', 'description'):
1472             kwargs.setdefault('show_annotation', False)
1473 
1474         try:
1475             if self.object == object.__init__ and self.parent != object:
1476                 # Classes not having own __init__() method are shown as no arguments.
1477                 #
1478                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1479                 #       But it makes users confused.
1480                 args = '()'
1481             else:
1482                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1483                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1484                     sig = inspect.signature(self.object, bound_method=False)
1485                 else:
1486                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1487 
1488                     meth = self.parent.__dict__.get(self.objpath[-1], None)
1489                     if meth and inspect.is_singledispatch_method(meth):
1490                         sig = inspect.signature(self.object, bound_method=True,
1491                                                 follow_wrapped=True)
1492                     else:
1493                         sig = inspect.signature(self.object, bound_method=True)
1494                 args = stringify_signature(sig, **kwargs)
1495         except TypeError as exc:
1496             logger.warning(__("Failed to get a method signature for %s: %s"),
1497                            self.fullname, exc)
1498             return None
1499         except ValueError:
1500             args = ''
1501 
1502         if self.env.config.strip_signature_backslash:
1503             # escape backslashes for reST
1504             args = args.replace('\\', '\\\\')
1505         return args
1506 
1507     def add_directive_header(self, sig: str) -> None:
1508         super().add_directive_header(sig)
1509 
1510         sourcename = self.get_sourcename()
1511         obj = self.parent.__dict__.get(self.object_name, self.object)
1512         if inspect.isabstractmethod(obj):
1513             self.add_line('   :abstractmethod:', sourcename)
1514         if inspect.iscoroutinefunction(obj):
1515             self.add_line('   :async:', sourcename)
1516         if inspect.isclassmethod(obj):
1517             self.add_line('   :classmethod:', sourcename)
1518         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1519             self.add_line('   :staticmethod:', sourcename)
1520         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1521             self.add_line('   :final:', sourcename)
1522 
1523     def document_members(self, all_members: bool = False) -> None:
1524         pass
1525 
1526     def format_signature(self, **kwargs: Any) -> str:
1527         sig = super().format_signature(**kwargs)
1528         sigs = [sig]
1529 
1530         meth = self.parent.__dict__.get(self.objpath[-1])
1531         if inspect.is_singledispatch_method(meth):
1532             # append signature of singledispatch'ed functions
1533             for typ, func in meth.dispatcher.registry.items():
1534                 if typ is object:
1535                     pass  # default implementation. skipped.
1536                 else:
1537                     self.annotate_to_first_argument(func, typ)
1538 
1539                     documenter = MethodDocumenter(self.directive, '')
1540                     documenter.parent = self.parent
1541                     documenter.object = func
1542                     documenter.objpath = [None]
1543                     sigs.append(documenter.format_signature())
1544 
1545         return "\n".join(sigs)
1546 
1547     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1548         """Annotate type hint to the first argument of function if needed."""
1549         sig = inspect.signature(func)
1550         if len(sig.parameters) == 1:
1551             return
1552 
1553         params = list(sig.parameters.values())
1554         if params[1].annotation is Parameter.empty:
1555             params[1] = params[1].replace(annotation=typ)
1556             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1557 
1558 
1559 class SingledispatchMethodDocumenter(MethodDocumenter):
1560     """
1561     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1562 
1563     Retained for backwards compatibility, now does the same as the MethodDocumenter
1564     """
1565 
1566 
1567 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1568     """
1569     Specialized Documenter subclass for attributes.
1570     """
1571     objtype = 'attribute'
1572     member_order = 60
1573     option_spec = dict(ModuleLevelDocumenter.option_spec)
1574     option_spec["annotation"] = annotation_option
1575 
1576     # must be higher than the MethodDocumenter, else it will recognize
1577     # some non-data descriptors as methods
1578     priority = 10
1579 
1580     @staticmethod
1581     def is_function_or_method(obj: Any) -> bool:
1582         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1583 
1584     @classmethod
1585     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1586                             ) -> bool:
1587         if inspect.isattributedescriptor(member):
1588             return True
1589         elif (not isinstance(parent, ModuleDocumenter) and
1590               not inspect.isroutine(member) and
1591               not isinstance(member, type)):
1592             return True
1593         else:
1594             return False
1595 
1596     def document_members(self, all_members: bool = False) -> None:
1597         pass
1598 
1599     def import_object(self) -> Any:
1600         ret = super().import_object()
1601         if inspect.isenumattribute(self.object):
1602             self.object = self.object.value
1603         if inspect.isattributedescriptor(self.object):
1604             self._datadescriptor = True
1605         else:
1606             # if it's not a data descriptor
1607             self._datadescriptor = False
1608         return ret
1609 
1610     def get_real_modname(self) -> str:
1611         return self.get_attr(self.parent or self.object, '__module__', None) \
1612             or self.modname
1613 
1614     def add_directive_header(self, sig: str) -> None:
1615         super().add_directive_header(sig)
1616         sourcename = self.get_sourcename()
1617         if not self.options.annotation:
1618             # obtain type annotation for this attribute
1619             annotations = getattr(self.parent, '__annotations__', {})
1620             if annotations and self.objpath[-1] in annotations:
1621                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1622                 self.add_line('   :type: ' + objrepr, sourcename)
1623             else:
1624                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1625                 if self.analyzer and key in self.analyzer.annotations:
1626                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1627                                   sourcename)
1628 
1629             # data descriptors do not have useful values
1630             if not self._datadescriptor:
1631                 try:
1632                     if self.object is INSTANCEATTR:
1633                         pass
1634                     else:
1635                         objrepr = object_description(self.object)
1636                         self.add_line('   :value: ' + objrepr, sourcename)
1637                 except ValueError:
1638                     pass
1639         elif self.options.annotation is SUPPRESS:
1640             pass
1641         else:
1642             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
1643 
1644     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1645         if not self._datadescriptor:
1646             # if it's not a data descriptor, its docstring is very probably the
1647             # wrong thing to display
1648             no_docstring = True
1649         super().add_content(more_content, no_docstring)
1650 
1651 
1652 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1653     """
1654     Specialized Documenter subclass for properties.
1655     """
1656     objtype = 'property'
1657     directivetype = 'method'
1658     member_order = 60
1659 
1660     # before AttributeDocumenter
1661     priority = AttributeDocumenter.priority + 1
1662 
1663     @classmethod
1664     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1665                             ) -> bool:
1666         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
1667 
1668     def document_members(self, all_members: bool = False) -> None:
1669         pass
1670 
1671     def get_real_modname(self) -> str:
1672         return self.get_attr(self.parent or self.object, '__module__', None) \
1673             or self.modname
1674 
1675     def add_directive_header(self, sig: str) -> None:
1676         super().add_directive_header(sig)
1677         sourcename = self.get_sourcename()
1678         if inspect.isabstractmethod(self.object):
1679             self.add_line('   :abstractmethod:', sourcename)
1680         self.add_line('   :property:', sourcename)
1681 
1682 
1683 class InstanceAttributeDocumenter(AttributeDocumenter):
1684     """
1685     Specialized Documenter subclass for attributes that cannot be imported
1686     because they are instance attributes (e.g. assigned in __init__).
1687     """
1688     objtype = 'instanceattribute'
1689     directivetype = 'attribute'
1690     member_order = 60
1691 
1692     # must be higher than AttributeDocumenter
1693     priority = 11
1694 
1695     @classmethod
1696     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1697                             ) -> bool:
1698         """This documents only INSTANCEATTR members."""
1699         return (not isinstance(parent, ModuleDocumenter) and
1700                 isattr and
1701                 member is INSTANCEATTR)
1702 
1703     def import_object(self) -> bool:
1704         """Never import anything."""
1705         # disguise as an attribute
1706         self.objtype = 'attribute'
1707         self.object = INSTANCEATTR
1708         self._datadescriptor = False
1709         return True
1710 
1711     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1712         """Never try to get a docstring from the object."""
1713         super().add_content(more_content, no_docstring=True)
1714 
1715 
1716 class SlotsAttributeDocumenter(AttributeDocumenter):
1717     """
1718     Specialized Documenter subclass for attributes that cannot be imported
1719     because they are attributes in __slots__.
1720     """
1721     objtype = 'slotsattribute'
1722     directivetype = 'attribute'
1723     member_order = 60
1724 
1725     # must be higher than AttributeDocumenter
1726     priority = 11
1727 
1728     @classmethod
1729     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1730                             ) -> bool:
1731         """This documents only SLOTSATTR members."""
1732         return member is SLOTSATTR
1733 
1734     def import_object(self) -> Any:
1735         """Never import anything."""
1736         # disguise as an attribute
1737         self.objtype = 'attribute'
1738         self._datadescriptor = True
1739 
1740         with mock(self.env.config.autodoc_mock_imports):
1741             try:
1742                 ret = import_object(self.modname, self.objpath[:-1], 'class',
1743                                     attrgetter=self.get_attr,
1744                                     warningiserror=self.env.config.autodoc_warningiserror)
1745                 self.module, _, _, self.parent = ret
1746                 return True
1747             except ImportError as exc:
1748                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1749                 self.env.note_reread()
1750                 return False
1751 
1752     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1753         """Decode and return lines of the docstring(s) for the object."""
1754         if ignore is not None:
1755             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1756                           % self.__class__.__name__,
1757                           RemovedInSphinx50Warning, stacklevel=2)
1758         name = self.objpath[-1]
1759         __slots__ = safe_getattr(self.parent, '__slots__', [])
1760         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
1761             docstring = prepare_docstring(__slots__[name])
1762             return [docstring]
1763         else:
1764             return []
1765 
1766 
1767 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
1768     """Returns registered Documenter classes"""
1769     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
1770     return app.registry.documenters
1771 
1772 
1773 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
1774     """Alternative getattr() for types"""
1775     for typ, func in app.registry.autodoc_attrgettrs.items():
1776         if isinstance(obj, typ):
1777             return func(obj, name, *defargs)
1778 
1779     return safe_getattr(obj, name, *defargs)
1780 
1781 
1782 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
1783     if config.autodoc_member_order == 'alphabetic':
1784         # RemovedInSphinx50Warning
1785         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
1786                           'instead of "alphabetic". Please update your setting.'))
1787         config.autodoc_member_order = 'alphabetical'  # type: ignore
1788 
1789 
1790 def setup(app: Sphinx) -> Dict[str, Any]:
1791     app.add_autodocumenter(ModuleDocumenter)
1792     app.add_autodocumenter(ClassDocumenter)
1793     app.add_autodocumenter(ExceptionDocumenter)
1794     app.add_autodocumenter(DataDocumenter)
1795     app.add_autodocumenter(DataDeclarationDocumenter)
1796     app.add_autodocumenter(FunctionDocumenter)
1797     app.add_autodocumenter(DecoratorDocumenter)
1798     app.add_autodocumenter(MethodDocumenter)
1799     app.add_autodocumenter(AttributeDocumenter)
1800     app.add_autodocumenter(PropertyDocumenter)
1801     app.add_autodocumenter(InstanceAttributeDocumenter)
1802     app.add_autodocumenter(SlotsAttributeDocumenter)
1803 
1804     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
1805     app.add_config_value('autodoc_member_order', 'alphabetical', True,
1806                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
1807     app.add_config_value('autodoc_default_options', {}, True)
1808     app.add_config_value('autodoc_docstring_signature', True, True)
1809     app.add_config_value('autodoc_mock_imports', [], True)
1810     app.add_config_value('autodoc_typehints', "signature", True,
1811                          ENUM("signature", "description", "none"))
1812     app.add_config_value('autodoc_warningiserror', True, True)
1813     app.add_config_value('autodoc_inherit_docstrings', True, True)
1814     app.add_event('autodoc-before-process-signature')
1815     app.add_event('autodoc-process-docstring')
1816     app.add_event('autodoc-process-signature')
1817     app.add_event('autodoc-skip-member')
1818 
1819     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
1820 
1821     app.setup_extension('sphinx.ext.autodoc.type_comment')
1822     app.setup_extension('sphinx.ext.autodoc.typehints')
1823 
1824     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>In the context of rendering docstrings to HTML, this file should ensure that attribute names with trailing underscores are not incorrectly escaped. If the problem lies within Autodoc's handling of docstring content post-Napoleon processing, ensuring that underscores at the end of attribute names are properly handled will resolve the issue. Autodoc's rendering process needs to recognize these cases and treat them accordingly, maintaining the integrity of identifier names including their trailing underscores in the final HTML documentation.</intended_behavior>]
2025-10-18 06:40:41.018 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/napoleon/docstring.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon.docstring
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5 
6     Classes for docstring parsing and formatting.
7 
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import inspect
14 import re
15 from functools import partial
16 from typing import Any, Callable, Dict, List, Tuple, Union
17 
18 from sphinx.application import Sphinx
19 from sphinx.config import Config as SphinxConfig
20 from sphinx.ext.napoleon.iterators import modify_iter
21 from sphinx.locale import _
22 
23 if False:
24     # For type annotation
25     from typing import Type  # for python3.5.1
26 
27 
28 _directive_regex = re.compile(r'\.\. \S+::')
29 _google_section_regex = re.compile(r'^(\s|\w)+:\s*$')
30 _google_typed_arg_regex = re.compile(r'\s*(.+?)\s*\(\s*(.*[^\s]+)\s*\)')
31 _numpy_section_regex = re.compile(r'^[=\-`:\'"~^_*+#<>]{2,}\s*$')
32 _single_colon_regex = re.compile(r'(?<!:):(?!:)')
33 _xref_or_code_regex = re.compile(
34     r'((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'
35     r'(?:``.+``))')
36 _bullet_list_regex = re.compile(r'^(\*|\+|\-)(\s+\S|\s*$)')
37 _enumerated_list_regex = re.compile(
38     r'^(?P<paren>\()?'
39     r'(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'
40     r'(?(paren)\)|\.)(\s+\S|\s*$)')
41 
42 
43 class GoogleDocstring:
44     """Convert Google style docstrings to reStructuredText.
45 
46     Parameters
47     ----------
48     docstring : :obj:`str` or :obj:`list` of :obj:`str`
49         The docstring to parse, given either as a string or split into
50         individual lines.
51     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
52         The configuration settings to use. If not given, defaults to the
53         config object on `app`; or if `app` is not given defaults to the
54         a new :class:`sphinx.ext.napoleon.Config` object.
55 
56 
57     Other Parameters
58     ----------------
59     app : :class:`sphinx.application.Sphinx`, optional
60         Application object representing the Sphinx process.
61     what : :obj:`str`, optional
62         A string specifying the type of the object to which the docstring
63         belongs. Valid values: "module", "class", "exception", "function",
64         "method", "attribute".
65     name : :obj:`str`, optional
66         The fully qualified name of the object.
67     obj : module, class, exception, function, method, or attribute
68         The object to which the docstring belongs.
69     options : :class:`sphinx.ext.autodoc.Options`, optional
70         The options given to the directive: an object with attributes
71         inherited_members, undoc_members, show_inheritance and noindex that
72         are True if the flag option of same name was given to the auto
73         directive.
74 
75 
76     Example
77     -------
78     >>> from sphinx.ext.napoleon import Config
79     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
80     >>> docstring = '''One line summary.
81     ...
82     ... Extended description.
83     ...
84     ... Args:
85     ...   arg1(int): Description of `arg1`
86     ...   arg2(str): Description of `arg2`
87     ... Returns:
88     ...   str: Description of return value.
89     ... '''
90     >>> print(GoogleDocstring(docstring, config))
91     One line summary.
92     <BLANKLINE>
93     Extended description.
94     <BLANKLINE>
95     :param arg1: Description of `arg1`
96     :type arg1: int
97     :param arg2: Description of `arg2`
98     :type arg2: str
99     <BLANKLINE>
100     :returns: Description of return value.
101     :rtype: str
102     <BLANKLINE>
103 
104     """
105 
106     _name_rgx = re.compile(r"^\s*((?::(?P<role>\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|"
107                            r" (?P<name2>~?[a-zA-Z0-9_.-]+))\s*", re.X)
108 
109     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
110                  app: Sphinx = None, what: str = '', name: str = '',
111                  obj: Any = None, options: Any = None) -> None:
112         self._config = config
113         self._app = app
114 
115         if not self._config:
116             from sphinx.ext.napoleon import Config
117             self._config = self._app.config if self._app else Config()  # type: ignore
118 
119         if not what:
120             if inspect.isclass(obj):
121                 what = 'class'
122             elif inspect.ismodule(obj):
123                 what = 'module'
124             elif callable(obj):
125                 what = 'function'
126             else:
127                 what = 'object'
128 
129         self._what = what
130         self._name = name
131         self._obj = obj
132         self._opt = options
133         if isinstance(docstring, str):
134             lines = docstring.splitlines()
135         else:
136             lines = docstring
137         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())
138         self._parsed_lines = []  # type: List[str]
139         self._is_in_section = False
140         self._section_indent = 0
141         if not hasattr(self, '_directive_sections'):
142             self._directive_sections = []  # type: List[str]
143         if not hasattr(self, '_sections'):
144             self._sections = {
145                 'args': self._parse_parameters_section,
146                 'arguments': self._parse_parameters_section,
147                 'attention': partial(self._parse_admonition, 'attention'),
148                 'attributes': self._parse_attributes_section,
149                 'caution': partial(self._parse_admonition, 'caution'),
150                 'danger': partial(self._parse_admonition, 'danger'),
151                 'error': partial(self._parse_admonition, 'error'),
152                 'example': self._parse_examples_section,
153                 'examples': self._parse_examples_section,
154                 'hint': partial(self._parse_admonition, 'hint'),
155                 'important': partial(self._parse_admonition, 'important'),
156                 'keyword args': self._parse_keyword_arguments_section,
157                 'keyword arguments': self._parse_keyword_arguments_section,
158                 'methods': self._parse_methods_section,
159                 'note': partial(self._parse_admonition, 'note'),
160                 'notes': self._parse_notes_section,
161                 'other parameters': self._parse_other_parameters_section,
162                 'parameters': self._parse_parameters_section,
163                 'return': self._parse_returns_section,
164                 'returns': self._parse_returns_section,
165                 'raises': self._parse_raises_section,
166                 'references': self._parse_references_section,
167                 'see also': self._parse_see_also_section,
168                 'tip': partial(self._parse_admonition, 'tip'),
169                 'todo': partial(self._parse_admonition, 'todo'),
170                 'warning': partial(self._parse_admonition, 'warning'),
171                 'warnings': partial(self._parse_admonition, 'warning'),
172                 'warns': self._parse_warns_section,
173                 'yield': self._parse_yields_section,
174                 'yields': self._parse_yields_section,
175             }  # type: Dict[str, Callable]
176 
177         self._load_custom_sections()
178 
179         self._parse()
180 
181     def __str__(self) -> str:
182         """Return the parsed docstring in reStructuredText format.
183 
184         Returns
185         -------
186         unicode
187             Unicode version of the docstring.
188 
189         """
190         return '\n'.join(self.lines())
191 
192     def lines(self) -> List[str]:
193         """Return the parsed lines of the docstring in reStructuredText format.
194 
195         Returns
196         -------
197         list(str)
198             The lines of the docstring in a list.
199 
200         """
201         return self._parsed_lines
202 
203     def _consume_indented_block(self, indent: int = 1) -> List[str]:
204         lines = []
205         line = self._line_iter.peek()
206         while(not self._is_section_break() and
207               (not line or self._is_indented(line, indent))):
208             lines.append(next(self._line_iter))
209             line = self._line_iter.peek()
210         return lines
211 
212     def _consume_contiguous(self) -> List[str]:
213         lines = []
214         while (self._line_iter.has_next() and
215                self._line_iter.peek() and
216                not self._is_section_header()):
217             lines.append(next(self._line_iter))
218         return lines
219 
220     def _consume_empty(self) -> List[str]:
221         lines = []
222         line = self._line_iter.peek()
223         while self._line_iter.has_next() and not line:
224             lines.append(next(self._line_iter))
225             line = self._line_iter.peek()
226         return lines
227 
228     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
229                        ) -> Tuple[str, str, List[str]]:
230         line = next(self._line_iter)
231 
232         before, colon, after = self._partition_field_on_colon(line)
233         _name, _type, _desc = before, '', after
234 
235         if parse_type:
236             match = _google_typed_arg_regex.match(before)
237             if match:
238                 _name = match.group(1)
239                 _type = match.group(2)
240 
241         _name = self._escape_args_and_kwargs(_name)
242 
243         if prefer_type and not _type:
244             _type, _name = _name, _type
245         indent = self._get_indent(line) + 1
246         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))
247         _descs = self.__class__(_descs, self._config).lines()
248         return _name, _type, _descs
249 
250     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False
251                         ) -> List[Tuple[str, str, List[str]]]:
252         self._consume_empty()
253         fields = []
254         while not self._is_section_break():
255             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
256             if _name or _type or _desc:
257                 fields.append((_name, _type, _desc,))
258         return fields
259 
260     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
261         line = next(self._line_iter)
262         _type, colon, _desc = self._partition_field_on_colon(line)
263         if not colon or not _desc:
264             _type, _desc = _desc, _type
265             _desc += colon
266         _descs = [_desc] + self._dedent(self._consume_to_end())
267         _descs = self.__class__(_descs, self._config).lines()
268         return _type, _descs
269 
270     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
271         lines = self._dedent(self._consume_to_next_section())
272         if lines:
273             before, colon, after = self._partition_field_on_colon(lines[0])
274             _name, _type, _desc = '', '', lines
275 
276             if colon:
277                 if after:
278                     _desc = [after] + lines[1:]
279                 else:
280                     _desc = lines[1:]
281 
282                 _type = before
283 
284             _desc = self.__class__(_desc, self._config).lines()
285             return [(_name, _type, _desc,)]
286         else:
287             return []
288 
289     def _consume_usage_section(self) -> List[str]:
290         lines = self._dedent(self._consume_to_next_section())
291         return lines
292 
293     def _consume_section_header(self) -> str:
294         section = next(self._line_iter)
295         stripped_section = section.strip(':')
296         if stripped_section.lower() in self._sections:
297             section = stripped_section
298         return section
299 
300     def _consume_to_end(self) -> List[str]:
301         lines = []
302         while self._line_iter.has_next():
303             lines.append(next(self._line_iter))
304         return lines
305 
306     def _consume_to_next_section(self) -> List[str]:
307         self._consume_empty()
308         lines = []
309         while not self._is_section_break():
310             lines.append(next(self._line_iter))
311         return lines + self._consume_empty()
312 
313     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:
314         if full:
315             return [line.lstrip() for line in lines]
316         else:
317             min_indent = self._get_min_indent(lines)
318             return [line[min_indent:] for line in lines]
319 
320     def _escape_args_and_kwargs(self, name: str) -> str:
321         if name.endswith('_'):
322             name = name[:-1] + r'\_'
323 
324         if name[:2] == '**':
325             return r'\*\*' + name[2:]
326         elif name[:1] == '*':
327             return r'\*' + name[1:]
328         else:
329             return name
330 
331     def _fix_field_desc(self, desc: List[str]) -> List[str]:
332         if self._is_list(desc):
333             desc = [''] + desc
334         elif desc[0].endswith('::'):
335             desc_block = desc[1:]
336             indent = self._get_indent(desc[0])
337             block_indent = self._get_initial_indent(desc_block)
338             if block_indent > indent:
339                 desc = [''] + desc
340             else:
341                 desc = ['', desc[0]] + self._indent(desc_block, 4)
342         return desc
343 
344     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:
345         lines = self._strip_empty(lines)
346         if len(lines) == 1:
347             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']
348         elif lines:
349             lines = self._indent(self._dedent(lines), 3)
350             return ['.. %s::' % admonition, ''] + lines + ['']
351         else:
352             return ['.. %s::' % admonition, '']
353 
354     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:
355         if lines:
356             if padding is None:
357                 padding = ' ' * len(prefix)
358             result_lines = []
359             for i, line in enumerate(lines):
360                 if i == 0:
361                     result_lines.append((prefix + line).rstrip())
362                 elif line:
363                     result_lines.append(padding + line)
364                 else:
365                     result_lines.append('')
366             return result_lines
367         else:
368             return [prefix]
369 
370     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],
371                                 field_role: str = 'param', type_role: str = 'type'
372                                 ) -> List[str]:
373         lines = []
374         for _name, _type, _desc in fields:
375             _desc = self._strip_empty(_desc)
376             if any(_desc):
377                 _desc = self._fix_field_desc(_desc)
378                 field = ':%s %s: ' % (field_role, _name)
379                 lines.extend(self._format_block(field, _desc))
380             else:
381                 lines.append(':%s %s:' % (field_role, _name))
382 
383             if _type:
384                 lines.append(':%s %s: %s' % (type_role, _name, _type))
385         return lines + ['']
386 
387     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:
388         _desc = self._strip_empty(_desc)
389         has_desc = any(_desc)
390         separator = ' -- ' if has_desc else ''
391         if _name:
392             if _type:
393                 if '`' in _type:
394                     field = '**%s** (%s)%s' % (_name, _type, separator)
395                 else:
396                     field = '**%s** (*%s*)%s' % (_name, _type, separator)
397             else:
398                 field = '**%s**%s' % (_name, separator)
399         elif _type:
400             if '`' in _type:
401                 field = '%s%s' % (_type, separator)
402             else:
403                 field = '*%s*%s' % (_type, separator)
404         else:
405             field = ''
406 
407         if has_desc:
408             _desc = self._fix_field_desc(_desc)
409             if _desc[0]:
410                 return [field + _desc[0]] + _desc[1:]
411             else:
412                 return [field] + _desc
413         else:
414             return [field]
415 
416     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]
417                        ) -> List[str]:
418         field_type = ':%s:' % field_type.strip()
419         padding = ' ' * len(field_type)
420         multi = len(fields) > 1
421         lines = []  # type: List[str]
422         for _name, _type, _desc in fields:
423             field = self._format_field(_name, _type, _desc)
424             if multi:
425                 if lines:
426                     lines.extend(self._format_block(padding + ' * ', field))
427                 else:
428                     lines.extend(self._format_block(field_type + ' * ', field))
429             else:
430                 lines.extend(self._format_block(field_type + ' ', field))
431         if lines and lines[-1]:
432             lines.append('')
433         return lines
434 
435     def _get_current_indent(self, peek_ahead: int = 0) -> int:
436         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
437         while line != self._line_iter.sentinel:
438             if line:
439                 return self._get_indent(line)
440             peek_ahead += 1
441             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
442         return 0
443 
444     def _get_indent(self, line: str) -> int:
445         for i, s in enumerate(line):
446             if not s.isspace():
447                 return i
448         return len(line)
449 
450     def _get_initial_indent(self, lines: List[str]) -> int:
451         for line in lines:
452             if line:
453                 return self._get_indent(line)
454         return 0
455 
456     def _get_min_indent(self, lines: List[str]) -> int:
457         min_indent = None
458         for line in lines:
459             if line:
460                 indent = self._get_indent(line)
461                 if min_indent is None:
462                     min_indent = indent
463                 elif indent < min_indent:
464                     min_indent = indent
465         return min_indent or 0
466 
467     def _indent(self, lines: List[str], n: int = 4) -> List[str]:
468         return [(' ' * n) + line for line in lines]
469 
470     def _is_indented(self, line: str, indent: int = 1) -> bool:
471         for i, s in enumerate(line):
472             if i >= indent:
473                 return True
474             elif not s.isspace():
475                 return False
476         return False
477 
478     def _is_list(self, lines: List[str]) -> bool:
479         if not lines:
480             return False
481         if _bullet_list_regex.match(lines[0]):
482             return True
483         if _enumerated_list_regex.match(lines[0]):
484             return True
485         if len(lines) < 2 or lines[0].endswith('::'):
486             return False
487         indent = self._get_indent(lines[0])
488         next_indent = indent
489         for line in lines[1:]:
490             if line:
491                 next_indent = self._get_indent(line)
492                 break
493         return next_indent > indent
494 
495     def _is_section_header(self) -> bool:
496         section = self._line_iter.peek().lower()
497         match = _google_section_regex.match(section)
498         if match and section.strip(':') in self._sections:
499             header_indent = self._get_indent(section)
500             section_indent = self._get_current_indent(peek_ahead=1)
501             return section_indent > header_indent
502         elif self._directive_sections:
503             if _directive_regex.match(section):
504                 for directive_section in self._directive_sections:
505                     if section.startswith(directive_section):
506                         return True
507         return False
508 
509     def _is_section_break(self) -> bool:
510         line = self._line_iter.peek()
511         return (not self._line_iter.has_next() or
512                 self._is_section_header() or
513                 (self._is_in_section and
514                     line and
515                     not self._is_indented(line, self._section_indent)))
516 
517     def _load_custom_sections(self) -> None:
518         if self._config.napoleon_custom_sections is not None:
519             for entry in self._config.napoleon_custom_sections:
520                 if isinstance(entry, str):
521                     # if entry is just a label, add to sections list,
522                     # using generic section logic.
523                     self._sections[entry.lower()] = self._parse_custom_generic_section
524                 else:
525                     # otherwise, assume entry is container;
526                     # [0] is new section, [1] is the section to alias.
527                     # in the case of key mismatch, just handle as generic section.
528                     self._sections[entry[0].lower()] = \
529                         self._sections.get(entry[1].lower(),
530                                            self._parse_custom_generic_section)
531 
532     def _parse(self) -> None:
533         self._parsed_lines = self._consume_empty()
534 
535         if self._name and self._what in ('attribute', 'data', 'property'):
536             # Implicit stop using StopIteration no longer allowed in
537             # Python 3.7; see PEP 479
538             res = []  # type: List[str]
539             try:
540                 res = self._parse_attribute_docstring()
541             except StopIteration:
542                 pass
543             self._parsed_lines.extend(res)
544             return
545 
546         while self._line_iter.has_next():
547             if self._is_section_header():
548                 try:
549                     section = self._consume_section_header()
550                     self._is_in_section = True
551                     self._section_indent = self._get_current_indent()
552                     if _directive_regex.match(section):
553                         lines = [section] + self._consume_to_next_section()
554                     else:
555                         lines = self._sections[section.lower()](section)
556                 finally:
557                     self._is_in_section = False
558                     self._section_indent = 0
559             else:
560                 if not self._parsed_lines:
561                     lines = self._consume_contiguous() + self._consume_empty()
562                 else:
563                     lines = self._consume_to_next_section()
564             self._parsed_lines.extend(lines)
565 
566     def _parse_admonition(self, admonition: str, section: str) -> List[str]:
567         # type (str, str) -> List[str]
568         lines = self._consume_to_next_section()
569         return self._format_admonition(admonition, lines)
570 
571     def _parse_attribute_docstring(self) -> List[str]:
572         _type, _desc = self._consume_inline_attribute()
573         lines = self._format_field('', '', _desc)
574         if _type:
575             lines.extend(['', ':type: %s' % _type])
576         return lines
577 
578     def _parse_attributes_section(self, section: str) -> List[str]:
579         lines = []
580         for _name, _type, _desc in self._consume_fields():
581             if self._config.napoleon_use_ivar:
582                 _name = self._qualify_name(_name, self._obj)
583                 field = ':ivar %s: ' % _name
584                 lines.extend(self._format_block(field, _desc))
585                 if _type:
586                     lines.append(':vartype %s: %s' % (_name, _type))
587             else:
588                 lines.append('.. attribute:: ' + _name)
589                 if self._opt and 'noindex' in self._opt:
590                     lines.append('   :noindex:')
591                 if _type:
592                     lines.extend(self._indent([':type: %s' % _type], 3))
593                 lines.append('')
594 
595                 fields = self._format_field('', '', _desc)
596                 lines.extend(self._indent(fields, 3))
597                 lines.append('')
598         if self._config.napoleon_use_ivar:
599             lines.append('')
600         return lines
601 
602     def _parse_examples_section(self, section: str) -> List[str]:
603         labels = {
604             'example': _('Example'),
605             'examples': _('Examples'),
606         }
607         use_admonition = self._config.napoleon_use_admonition_for_examples
608         label = labels.get(section.lower(), section)
609         return self._parse_generic_section(label, use_admonition)
610 
611     def _parse_custom_generic_section(self, section: str) -> List[str]:
612         # for now, no admonition for simple custom sections
613         return self._parse_generic_section(section, False)
614 
615     def _parse_usage_section(self, section: str) -> List[str]:
616         header = ['.. rubric:: Usage:', '']
617         block = ['.. code-block:: python', '']
618         lines = self._consume_usage_section()
619         lines = self._indent(lines, 3)
620         return header + block + lines + ['']
621 
622     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:
623         lines = self._strip_empty(self._consume_to_next_section())
624         lines = self._dedent(lines)
625         if use_admonition:
626             header = '.. admonition:: %s' % section
627             lines = self._indent(lines, 3)
628         else:
629             header = '.. rubric:: %s' % section
630         if lines:
631             return [header, ''] + lines + ['']
632         else:
633             return [header, '']
634 
635     def _parse_keyword_arguments_section(self, section: str) -> List[str]:
636         fields = self._consume_fields()
637         if self._config.napoleon_use_keyword:
638             return self._format_docutils_params(
639                 fields,
640                 field_role="keyword",
641                 type_role="kwtype")
642         else:
643             return self._format_fields(_('Keyword Arguments'), fields)
644 
645     def _parse_methods_section(self, section: str) -> List[str]:
646         lines = []  # type: List[str]
647         for _name, _type, _desc in self._consume_fields(parse_type=False):
648             lines.append('.. method:: %s' % _name)
649             if self._opt and 'noindex' in self._opt:
650                 lines.append('   :noindex:')
651             if _desc:
652                 lines.extend([''] + self._indent(_desc, 3))
653             lines.append('')
654         return lines
655 
656     def _parse_notes_section(self, section: str) -> List[str]:
657         use_admonition = self._config.napoleon_use_admonition_for_notes
658         return self._parse_generic_section(_('Notes'), use_admonition)
659 
660     def _parse_other_parameters_section(self, section: str) -> List[str]:
661         return self._format_fields(_('Other Parameters'), self._consume_fields())
662 
663     def _parse_parameters_section(self, section: str) -> List[str]:
664         fields = self._consume_fields()
665         if self._config.napoleon_use_param:
666             return self._format_docutils_params(fields)
667         else:
668             return self._format_fields(_('Parameters'), fields)
669 
670     def _parse_raises_section(self, section: str) -> List[str]:
671         fields = self._consume_fields(parse_type=False, prefer_type=True)
672         lines = []  # type: List[str]
673         for _name, _type, _desc in fields:
674             m = self._name_rgx.match(_type)
675             if m and m.group('name'):
676                 _type = m.group('name')
677             _type = ' ' + _type if _type else ''
678             _desc = self._strip_empty(_desc)
679             _descs = ' ' + '\n    '.join(_desc) if any(_desc) else ''
680             lines.append(':raises%s:%s' % (_type, _descs))
681         if lines:
682             lines.append('')
683         return lines
684 
685     def _parse_references_section(self, section: str) -> List[str]:
686         use_admonition = self._config.napoleon_use_admonition_for_references
687         return self._parse_generic_section(_('References'), use_admonition)
688 
689     def _parse_returns_section(self, section: str) -> List[str]:
690         fields = self._consume_returns_section()
691         multi = len(fields) > 1
692         if multi:
693             use_rtype = False
694         else:
695             use_rtype = self._config.napoleon_use_rtype
696 
697         lines = []  # type: List[str]
698         for _name, _type, _desc in fields:
699             if use_rtype:
700                 field = self._format_field(_name, '', _desc)
701             else:
702                 field = self._format_field(_name, _type, _desc)
703 
704             if multi:
705                 if lines:
706                     lines.extend(self._format_block('          * ', field))
707                 else:
708                     lines.extend(self._format_block(':returns: * ', field))
709             else:
710                 lines.extend(self._format_block(':returns: ', field))
711                 if _type and use_rtype:
712                     lines.extend([':rtype: %s' % _type, ''])
713         if lines and lines[-1]:
714             lines.append('')
715         return lines
716 
717     def _parse_see_also_section(self, section: str) -> List[str]:
718         return self._parse_admonition('seealso', section)
719 
720     def _parse_warns_section(self, section: str) -> List[str]:
721         return self._format_fields(_('Warns'), self._consume_fields())
722 
723     def _parse_yields_section(self, section: str) -> List[str]:
724         fields = self._consume_returns_section()
725         return self._format_fields(_('Yields'), fields)
726 
727     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:
728         before_colon = []
729         after_colon = []
730         colon = ''
731         found_colon = False
732         for i, source in enumerate(_xref_or_code_regex.split(line)):
733             if found_colon:
734                 after_colon.append(source)
735             else:
736                 m = _single_colon_regex.search(source)
737                 if (i % 2) == 0 and m:
738                     found_colon = True
739                     colon = source[m.start(): m.end()]
740                     before_colon.append(source[:m.start()])
741                     after_colon.append(source[m.end():])
742                 else:
743                     before_colon.append(source)
744 
745         return ("".join(before_colon).strip(),
746                 colon,
747                 "".join(after_colon).strip())
748 
749     def _qualify_name(self, attr_name: str, klass: "Type") -> str:
750         if klass and '.' not in attr_name:
751             if attr_name.startswith('~'):
752                 attr_name = attr_name[1:]
753             try:
754                 q = klass.__qualname__
755             except AttributeError:
756                 q = klass.__name__
757             return '~%s.%s' % (q, attr_name)
758         return attr_name
759 
760     def _strip_empty(self, lines: List[str]) -> List[str]:
761         if lines:
762             start = -1
763             for i, line in enumerate(lines):
764                 if line:
765                     start = i
766                     break
767             if start == -1:
768                 lines = []
769             end = -1
770             for i in reversed(range(len(lines))):
771                 line = lines[i]
772                 if line:
773                     end = i
774                     break
775             if start > 0 or end + 1 < len(lines):
776                 lines = lines[start:end + 1]
777         return lines
778 
779 
780 class NumpyDocstring(GoogleDocstring):
781     """Convert NumPy style docstrings to reStructuredText.
782 
783     Parameters
784     ----------
785     docstring : :obj:`str` or :obj:`list` of :obj:`str`
786         The docstring to parse, given either as a string or split into
787         individual lines.
788     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
789         The configuration settings to use. If not given, defaults to the
790         config object on `app`; or if `app` is not given defaults to the
791         a new :class:`sphinx.ext.napoleon.Config` object.
792 
793 
794     Other Parameters
795     ----------------
796     app : :class:`sphinx.application.Sphinx`, optional
797         Application object representing the Sphinx process.
798     what : :obj:`str`, optional
799         A string specifying the type of the object to which the docstring
800         belongs. Valid values: "module", "class", "exception", "function",
801         "method", "attribute".
802     name : :obj:`str`, optional
803         The fully qualified name of the object.
804     obj : module, class, exception, function, method, or attribute
805         The object to which the docstring belongs.
806     options : :class:`sphinx.ext.autodoc.Options`, optional
807         The options given to the directive: an object with attributes
808         inherited_members, undoc_members, show_inheritance and noindex that
809         are True if the flag option of same name was given to the auto
810         directive.
811 
812 
813     Example
814     -------
815     >>> from sphinx.ext.napoleon import Config
816     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
817     >>> docstring = '''One line summary.
818     ...
819     ... Extended description.
820     ...
821     ... Parameters
822     ... ----------
823     ... arg1 : int
824     ...     Description of `arg1`
825     ... arg2 : str
826     ...     Description of `arg2`
827     ... Returns
828     ... -------
829     ... str
830     ...     Description of return value.
831     ... '''
832     >>> print(NumpyDocstring(docstring, config))
833     One line summary.
834     <BLANKLINE>
835     Extended description.
836     <BLANKLINE>
837     :param arg1: Description of `arg1`
838     :type arg1: int
839     :param arg2: Description of `arg2`
840     :type arg2: str
841     <BLANKLINE>
842     :returns: Description of return value.
843     :rtype: str
844     <BLANKLINE>
845 
846     Methods
847     -------
848     __str__()
849         Return the parsed docstring in reStructuredText format.
850 
851         Returns
852         -------
853         str
854             UTF-8 encoded version of the docstring.
855 
856     __unicode__()
857         Return the parsed docstring in reStructuredText format.
858 
859         Returns
860         -------
861         unicode
862             Unicode version of the docstring.
863 
864     lines()
865         Return the parsed lines of the docstring in reStructuredText format.
866 
867         Returns
868         -------
869         list(str)
870             The lines of the docstring in a list.
871 
872     """
873     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
874                  app: Sphinx = None, what: str = '', name: str = '',
875                  obj: Any = None, options: Any = None) -> None:
876         self._directive_sections = ['.. index::']
877         super().__init__(docstring, config, app, what, name, obj, options)
878 
879     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
880                        ) -> Tuple[str, str, List[str]]:
881         line = next(self._line_iter)
882         if parse_type:
883             _name, _, _type = self._partition_field_on_colon(line)
884         else:
885             _name, _type = line, ''
886         _name, _type = _name.strip(), _type.strip()
887         _name = self._escape_args_and_kwargs(_name)
888 
889         if prefer_type and not _type:
890             _type, _name = _name, _type
891         indent = self._get_indent(line) + 1
892         _desc = self._dedent(self._consume_indented_block(indent))
893         _desc = self.__class__(_desc, self._config).lines()
894         return _name, _type, _desc
895 
896     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
897         return self._consume_fields(prefer_type=True)
898 
899     def _consume_section_header(self) -> str:
900         section = next(self._line_iter)
901         if not _directive_regex.match(section):
902             # Consume the header underline
903             next(self._line_iter)
904         return section
905 
906     def _is_section_break(self) -> bool:
907         line1, line2 = self._line_iter.peek(2)
908         return (not self._line_iter.has_next() or
909                 self._is_section_header() or
910                 ['', ''] == [line1, line2] or
911                 (self._is_in_section and
912                     line1 and
913                     not self._is_indented(line1, self._section_indent)))
914 
915     def _is_section_header(self) -> bool:
916         section, underline = self._line_iter.peek(2)
917         section = section.lower()
918         if section in self._sections and isinstance(underline, str):
919             return bool(_numpy_section_regex.match(underline))
920         elif self._directive_sections:
921             if _directive_regex.match(section):
922                 for directive_section in self._directive_sections:
923                     if section.startswith(directive_section):
924                         return True
925         return False
926 
927     def _parse_see_also_section(self, section: str) -> List[str]:
928         lines = self._consume_to_next_section()
929         try:
930             return self._parse_numpydoc_see_also_section(lines)
931         except ValueError:
932             return self._format_admonition('seealso', lines)
933 
934     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:
935         """
936         Derived from the NumpyDoc implementation of _parse_see_also.
937 
938         See Also
939         --------
940         func_name : Descriptive text
941             continued text
942         another_func_name : Descriptive text
943         func_name1, func_name2, :meth:`func_name`, func_name3
944 
945         """
946         items = []
947 
948         def parse_item_name(text: str) -> Tuple[str, str]:
949             """Match ':role:`name`' or 'name'"""
950             m = self._name_rgx.match(text)
951             if m:
952                 g = m.groups()
953                 if g[1] is None:
954                     return g[3], None
955                 else:
956                     return g[2], g[1]
957             raise ValueError("%s is not a item name" % text)
958 
959         def push_item(name: str, rest: List[str]) -> None:
960             if not name:
961                 return
962             name, role = parse_item_name(name)
963             items.append((name, list(rest), role))
964             del rest[:]
965 
966         current_func = None
967         rest = []  # type: List[str]
968 
969         for line in content:
970             if not line.strip():
971                 continue
972 
973             m = self._name_rgx.match(line)
974             if m and line[m.end():].strip().startswith(':'):
975                 push_item(current_func, rest)
976                 current_func, line = line[:m.end()], line[m.end():]
977                 rest = [line.split(':', 1)[1].strip()]
978                 if not rest[0]:
979                     rest = []
980             elif not line.startswith(' '):
981                 push_item(current_func, rest)
982                 current_func = None
983                 if ',' in line:
984                     for func in line.split(','):
985                         if func.strip():
986                             push_item(func, [])
987                 elif line.strip():
988                     current_func = line
989             elif current_func is not None:
990                 rest.append(line.strip())
991         push_item(current_func, rest)
992 
993         if not items:
994             return []
995 
996         roles = {
997             'method': 'meth',
998             'meth': 'meth',
999             'function': 'func',
1000             'func': 'func',
1001             'class': 'class',
1002             'exception': 'exc',
1003             'exc': 'exc',
1004             'object': 'obj',
1005             'obj': 'obj',
1006             'module': 'mod',
1007             'mod': 'mod',
1008             'data': 'data',
1009             'constant': 'const',
1010             'const': 'const',
1011             'attribute': 'attr',
1012             'attr': 'attr'
1013         }
1014         if self._what is None:
1015             func_role = 'obj'
1016         else:
1017             func_role = roles.get(self._what, '')
1018         lines = []  # type: List[str]
1019         last_had_desc = True
1020         for func, desc, role in items:
1021             if role:
1022                 link = ':%s:`%s`' % (role, func)
1023             elif func_role:
1024                 link = ':%s:`%s`' % (func_role, func)
1025             else:
1026                 link = "`%s`_" % func
1027             if desc or last_had_desc:
1028                 lines += ['']
1029                 lines += [link]
1030             else:
1031                 lines[-1] += ", %s" % link
1032             if desc:
1033                 lines += self._indent([' '.join(desc)])
1034                 last_had_desc = True
1035             else:
1036                 last_had_desc = False
1037         lines += ['']
1038 
1039         return self._format_admonition('seealso', lines)

</code><intended_behavior>This file should process attribute docstrings in a way that trailing underscores in attribute names are recognized as part of the identifier and not as characters requiring escape sequences in the generated HTML. The intended behavior is to ensure that when Napoleon parses attribute sections, it correctly formats attribute names, preserving trailing underscores without adding a backslash for the HTML output. This preserves the existing functionality for document generation while fixing the issue with attribute name representation.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union
20 )
21 
22 from docutils.statemachine import StringList
23 
24 import sphinx
25 from sphinx.application import Sphinx
26 from sphinx.config import Config, ENUM
27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
28 from sphinx.environment import BuildEnvironment
29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
30 from sphinx.ext.autodoc.mock import mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect
34 from sphinx.util import logging
35 from sphinx.util import split_full_qualified_name
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43     from sphinx.ext.autodoc.directive import DocumenterBridge
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 
49 # This type isn't exposed directly in any modules, but can be found
50 # here in most Python versions
51 MethodDescriptorType = type(type.__subclasses__)
52 
53 
54 #: extended signature RE: with explicit module name separated by ::
55 py_ext_sig_re = re.compile(
56     r'''^ ([\w.]+::)?            # explicit module name
57           ([\w.]+\.)?            # module and/or class name(s)
58           (\w+)  \s*             # thing name
59           (?: \((.*)\)           # optional: arguments
60            (?:\s* -> \s* (.*))?  #           return annotation
61           )? $                   # and nothing more
62           ''', re.VERBOSE)
63 
64 
65 def identity(x: Any) -> Any:
66     return x
67 
68 
69 ALL = object()
70 UNINITIALIZED_ATTR = object()
71 INSTANCEATTR = object()
72 SLOTSATTR = object()
73 
74 
75 def members_option(arg: Any) -> Union[object, List[str]]:
76     """Used to convert the :members: option to auto directives."""
77     if arg is None or arg is True:
78         return ALL
79     return [x.strip() for x in arg.split(',') if x.strip()]
80 
81 
82 def members_set_option(arg: Any) -> Union[object, Set[str]]:
83     """Used to convert the :members: option to auto directives."""
84     if arg is None:
85         return ALL
86     return {x.strip() for x in arg.split(',') if x.strip()}
87 
88 
89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
90     """Used to convert the :members: option to auto directives."""
91     if arg is None:
92         return 'object'
93     else:
94         return arg
95 
96 
97 def member_order_option(arg: Any) -> Optional[str]:
98     """Used to convert the :members: option to auto directives."""
99     if arg is None:
100         return None
101     elif arg in ('alphabetical', 'bysource', 'groupwise'):
102         return arg
103     else:
104         raise ValueError(__('invalid value for member-order option: %s') % arg)
105 
106 
107 SUPPRESS = object()
108 
109 
110 def annotation_option(arg: Any) -> Any:
111     if arg is None:
112         # suppress showing the representation of the object
113         return SUPPRESS
114     else:
115         return arg
116 
117 
118 def bool_option(arg: Any) -> bool:
119     """Used to convert flag options to auto directives.  (Instead of
120     directives.flag(), which returns None).
121     """
122     return True
123 
124 
125 def merge_special_members_option(options: Dict) -> None:
126     """Merge :special-members: option to :members: option."""
127     if 'special-members' in options and options['special-members'] is not ALL:
128         if options.get('members') is ALL:
129             pass
130         elif options.get('members'):
131             for member in options['special-members']:
132                 if member not in options['members']:
133                     options['members'].append(member)
134         else:
135             options['members'] = options['special-members']
136 
137 
138 # Some useful event listener factories for autodoc-process-docstring.
139 
140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
141     """Return a listener that removes the first *pre* and last *post*
142     lines of every docstring.  If *what* is a sequence of strings,
143     only docstrings of a type in *what* will be processed.
144 
145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
146 
147        from sphinx.ext.autodoc import cut_lines
148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
149 
150     This can (and should) be used in place of :confval:`automodule_skip_lines`.
151     """
152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
153                 ) -> None:
154         if what and what_ not in what:
155             return
156         del lines[:pre]
157         if post:
158             # remove one trailing blank line.
159             if lines and not lines[-1]:
160                 lines.pop(-1)
161             del lines[-post:]
162         # make sure there is a blank line at the end
163         if lines and lines[-1]:
164             lines.append('')
165     return process
166 
167 
168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
169             exclude: bool = False) -> Callable:
170     """Return a listener that either keeps, or if *exclude* is True excludes,
171     lines between lines that match the *marker* regular expression.  If no line
172     matches, the resulting docstring would be empty, so no change will be made
173     unless *keepempty* is true.
174 
175     If *what* is a sequence of strings, only docstrings of a type in *what* will
176     be processed.
177     """
178     marker_re = re.compile(marker)
179 
180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
181                 ) -> None:
182         if what and what_ not in what:
183             return
184         deleted = 0
185         delete = not exclude
186         orig_lines = lines[:]
187         for i, line in enumerate(orig_lines):
188             if delete:
189                 lines.pop(i - deleted)
190                 deleted += 1
191             if marker_re.match(line):
192                 delete = not delete
193                 if delete:
194                     lines.pop(i - deleted)
195                     deleted += 1
196         if not lines and not keepempty:
197             lines[:] = orig_lines
198         # make sure there is a blank line at the end
199         if lines and lines[-1]:
200             lines.append('')
201     return process
202 
203 
204 # This class is used only in ``sphinx.ext.autodoc.directive``,
205 # But we define this class here to keep compatibility (see #4538)
206 class Options(dict):
207     """A dict/attribute hybrid that returns None on nonexisting keys."""
208     def __getattr__(self, name: str) -> Any:
209         try:
210             return self[name.replace('_', '-')]
211         except KeyError:
212             return None
213 
214 
215 class Documenter:
216     """
217     A Documenter knows how to autodocument a single object type.  When
218     registered with the AutoDirective, it will be used to document objects
219     of that type when needed by autodoc.
220 
221     Its *objtype* attribute selects what auto directive it is assigned to
222     (the directive name is 'auto' + objtype), and what directive it generates
223     by default, though that can be overridden by an attribute called
224     *directivetype*.
225 
226     A Documenter has an *option_spec* that works like a docutils directive's;
227     in fact, it will be used to parse an auto directive's options that matches
228     the documenter.
229     """
230     #: name by which the directive is called (auto...) and the default
231     #: generated directive name
232     objtype = 'object'
233     #: indentation by which to indent the directive content
234     content_indent = '   '
235     #: priority if multiple documenters return True from can_document_member
236     priority = 0
237     #: order if autodoc_member_order is set to 'groupwise'
238     member_order = 0
239     #: true if the generated content may contain titles
240     titles_allowed = False
241 
242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
243 
244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
245         """getattr() override for types such as Zope interfaces."""
246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
247 
248     @classmethod
249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
250                             ) -> bool:
251         """Called to see if a member can be documented by this documenter."""
252         raise NotImplementedError('must be implemented in subclasses')
253 
254     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
255         self.directive = directive
256         self.env = directive.env    # type: BuildEnvironment
257         self.options = directive.genopt
258         self.name = name
259         self.indent = indent
260         # the module and object path within the module, and the fully
261         # qualified name (all set after resolve_name succeeds)
262         self.modname = None         # type: str
263         self.module = None          # type: ModuleType
264         self.objpath = None         # type: List[str]
265         self.fullname = None        # type: str
266         # extra signature items (arguments and return annotation,
267         # also set after resolve_name succeeds)
268         self.args = None            # type: str
269         self.retann = None          # type: str
270         # the object to document (set after import_object succeeds)
271         self.object = None          # type: Any
272         self.object_name = None     # type: str
273         # the parent/owner of the object to document
274         self.parent = None          # type: Any
275         # the module analyzer to get at attribute docs, or None
276         self.analyzer = None        # type: ModuleAnalyzer
277 
278     @property
279     def documenters(self) -> Dict[str, "Type[Documenter]"]:
280         """Returns registered Documenter classes"""
281         return self.env.app.registry.documenters
282 
283     def add_line(self, line: str, source: str, *lineno: int) -> None:
284         """Append one line of generated reST to the output."""
285         if line.strip():  # not a blank line
286             self.directive.result.append(self.indent + line, source, *lineno)
287         else:
288             self.directive.result.append('', source, *lineno)
289 
290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
291                      ) -> Tuple[str, List[str]]:
292         """Resolve the module and name of the object to document given by the
293         arguments and the current module/class.
294 
295         Must return a pair of the module name and a chain of attributes; for
296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
297         ``zipfile.ZipFile.open`` method.
298         """
299         raise NotImplementedError('must be implemented in subclasses')
300 
301     def parse_name(self) -> bool:
302         """Determine what module to import and what attribute to document.
303 
304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
305         *self.args* and *self.retann* if parsing and resolving was successful.
306         """
307         # first, parse the definition -- auto directives for classes and
308         # functions can contain a signature which is then used instead of
309         # an autogenerated one
310         try:
311             explicit_modname, path, base, args, retann = \
312                 py_ext_sig_re.match(self.name).groups()
313         except AttributeError:
314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
315                            type='autodoc')
316             return False
317 
318         # support explicit module and class name separation via ::
319         if explicit_modname is not None:
320             modname = explicit_modname[:-2]
321             parents = path.rstrip('.').split('.') if path else []
322         else:
323             modname = None
324             parents = []
325 
326         with mock(self.env.config.autodoc_mock_imports):
327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
328 
329         if not self.modname:
330             return False
331 
332         self.args = args
333         self.retann = retann
334         self.fullname = (self.modname or '') + \
335                         ('.' + '.'.join(self.objpath) if self.objpath else '')
336         return True
337 
338     def import_object(self) -> bool:
339         """Import the object given by *self.modname* and *self.objpath* and set
340         it as *self.object*.
341 
342         Returns True if successful, False if an error occurred.
343         """
344         with mock(self.env.config.autodoc_mock_imports):
345             try:
346                 ret = import_object(self.modname, self.objpath, self.objtype,
347                                     attrgetter=self.get_attr,
348                                     warningiserror=self.env.config.autodoc_warningiserror)
349                 self.module, self.parent, self.object_name, self.object = ret
350                 return True
351             except ImportError as exc:
352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
353                 self.env.note_reread()
354                 return False
355 
356     def get_real_modname(self) -> str:
357         """Get the real module name of an object to document.
358 
359         It can differ from the name of the module through which the object was
360         imported.
361         """
362         return self.get_attr(self.object, '__module__', None) or self.modname
363 
364     def check_module(self) -> bool:
365         """Check if *self.object* is really defined in the module given by
366         *self.modname*.
367         """
368         if self.options.imported_members:
369             return True
370 
371         subject = inspect.unpartial(self.object)
372         modname = self.get_attr(subject, '__module__', None)
373         if modname and modname != self.modname:
374             return False
375         return True
376 
377     def format_args(self, **kwargs: Any) -> str:
378         """Format the argument signature of *self.object*.
379 
380         Should return None if the object does not have a signature.
381         """
382         return None
383 
384     def format_name(self) -> str:
385         """Format the name of *self.object*.
386 
387         This normally should be something that can be parsed by the generated
388         directive, but doesn't need to be (Sphinx will display it unparsed
389         then).
390         """
391         # normally the name doesn't contain the module (except for module
392         # directives of course)
393         return '.'.join(self.objpath) or self.modname
394 
395     def format_signature(self, **kwargs: Any) -> str:
396         """Format the signature (arguments and return annotation) of the object.
397 
398         Let the user process it via the ``autodoc-process-signature`` event.
399         """
400         if self.args is not None:
401             # signature given explicitly
402             args = "(%s)" % self.args
403             retann = self.retann
404         else:
405             # try to introspect the signature
406             try:
407                 retann = None
408                 try:
409                     args = self.format_args(**kwargs)
410                 except TypeError:
411                     # retry without arguments for old documenters
412                     args = self.format_args()
413 
414                 if args:
415                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
416                     if matched:
417                         args = matched.group(1)
418                         retann = matched.group(2)
419             except Exception:
420                 logger.warning(__('error while formatting arguments for %s:') %
421                                self.fullname, type='autodoc', exc_info=True)
422                 args = None
423 
424         result = self.env.events.emit_firstresult('autodoc-process-signature',
425                                                   self.objtype, self.fullname,
426                                                   self.object, self.options, args, retann)
427         if result:
428             args, retann = result
429 
430         if args is not None:
431             return args + ((' -> %s' % retann) if retann else '')
432         else:
433             return ''
434 
435     def add_directive_header(self, sig: str) -> None:
436         """Add the directive header and options to the generated content."""
437         domain = getattr(self, 'domain', 'py')
438         directive = getattr(self, 'directivetype', self.objtype)
439         name = self.format_name()
440         sourcename = self.get_sourcename()
441 
442         # one signature per line, indented by column
443         prefix = '.. %s:%s:: ' % (domain, directive)
444         for i, sig_line in enumerate(sig.split("\n")):
445             self.add_line('%s%s%s' % (prefix, name, sig_line),
446                           sourcename)
447             if i == 0:
448                 prefix = " " * len(prefix)
449 
450         if self.options.noindex:
451             self.add_line('   :noindex:', sourcename)
452         if self.objpath:
453             # Be explicit about the module, this is necessary since .. class::
454             # etc. don't support a prepended module name
455             self.add_line('   :module: %s' % self.modname, sourcename)
456 
457     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
458         """Decode and return lines of the docstring(s) for the object."""
459         if encoding is not None:
460             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
461                           % self.__class__.__name__,
462                           RemovedInSphinx40Warning, stacklevel=2)
463         if ignore is not None:
464             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
465                           % self.__class__.__name__,
466                           RemovedInSphinx50Warning, stacklevel=2)
467         docstring = getdoc(self.object, self.get_attr,
468                            self.env.config.autodoc_inherit_docstrings,
469                            self.parent, self.object_name)
470         if docstring:
471             tab_width = self.directive.state.document.settings.tab_width
472             return [prepare_docstring(docstring, ignore, tab_width)]
473         return []
474 
475     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
476         """Let the user process the docstrings before adding them."""
477         for docstringlines in docstrings:
478             if self.env.app:
479                 # let extensions preprocess docstrings
480                 self.env.app.emit('autodoc-process-docstring',
481                                   self.objtype, self.fullname, self.object,
482                                   self.options, docstringlines)
483             yield from docstringlines
484 
485     def get_sourcename(self) -> str:
486         if self.analyzer:
487             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
488         return 'docstring of %s' % self.fullname
489 
490     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
491         """Add content from docstrings, attribute documentation and user."""
492         # set sourcename and add content from attribute documentation
493         sourcename = self.get_sourcename()
494         if self.analyzer:
495             attr_docs = self.analyzer.find_attr_docs()
496             if self.objpath:
497                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
498                 if key in attr_docs:
499                     no_docstring = True
500                     # make a copy of docstring for attributes to avoid cache
501                     # the change of autodoc-process-docstring event.
502                     docstrings = [list(attr_docs[key])]
503 
504                     for i, line in enumerate(self.process_doc(docstrings)):
505                         self.add_line(line, sourcename, i)
506 
507         # add content from docstrings
508         if not no_docstring:
509             docstrings = self.get_doc()
510             if not docstrings:
511                 # append at least a dummy docstring, so that the event
512                 # autodoc-process-docstring is fired and can add some
513                 # content if desired
514                 docstrings.append([])
515             for i, line in enumerate(self.process_doc(docstrings)):
516                 self.add_line(line, sourcename, i)
517 
518         # add additional content (e.g. from document), if present
519         if more_content:
520             for line, src in zip(more_content.data, more_content.items):
521                 self.add_line(line, src[0], src[1])
522 
523     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
524         """Return `(members_check_module, members)` where `members` is a
525         list of `(membername, member)` pairs of the members of *self.object*.
526 
527         If *want_all* is True, return all members.  Else, only return those
528         members given by *self.options.members* (which may also be none).
529         """
530         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
531         if not want_all:
532             if not self.options.members:
533                 return False, []
534             # specific members given
535             selected = []
536             for name in self.options.members:
537                 if name in members:
538                     selected.append((name, members[name].value))
539                 else:
540                     logger.warning(__('missing attribute %s in object %s') %
541                                    (name, self.fullname), type='autodoc')
542             return False, selected
543         elif self.options.inherited_members:
544             return False, [(m.name, m.value) for m in members.values()]
545         else:
546             return False, [(m.name, m.value) for m in members.values()
547                            if m.directly_defined]
548 
549     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
550                        ) -> List[Tuple[str, Any, bool]]:
551         """Filter the given member list.
552 
553         Members are skipped if
554 
555         - they are private (except if given explicitly or the private-members
556           option is set)
557         - they are special methods (except if given explicitly or the
558           special-members option is set)
559         - they are undocumented (except if the undoc-members option is set)
560 
561         The user can override the skipping decision by connecting to the
562         ``autodoc-skip-member`` event.
563         """
564         def is_filtered_inherited_member(name: str) -> bool:
565             if inspect.isclass(self.object):
566                 for cls in self.object.__mro__:
567                     if cls.__name__ == self.options.inherited_members and cls != self.object:
568                         # given member is a member of specified *super class*
569                         return True
570                     elif name in cls.__dict__:
571                         return False
572 
573             return False
574 
575         ret = []
576 
577         # search for members in source code too
578         namespace = '.'.join(self.objpath)  # will be empty for modules
579 
580         if self.analyzer:
581             attr_docs = self.analyzer.find_attr_docs()
582         else:
583             attr_docs = {}
584 
585         # process members and determine which to skip
586         for (membername, member) in members:
587             # if isattr is True, the member is documented as an attribute
588             if member is INSTANCEATTR:
589                 isattr = True
590             else:
591                 isattr = False
592 
593             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
594                          self.parent, self.object_name)
595             if not isinstance(doc, str):
596                 # Ignore non-string __doc__
597                 doc = None
598 
599             # if the member __doc__ is the same as self's __doc__, it's just
600             # inherited and therefore not the member's doc
601             cls = self.get_attr(member, '__class__', None)
602             if cls:
603                 cls_doc = self.get_attr(cls, '__doc__', None)
604                 if cls_doc == doc:
605                     doc = None
606             has_doc = bool(doc)
607 
608             metadata = extract_metadata(doc)
609             if 'private' in metadata:
610                 # consider a member private if docstring has "private" metadata
611                 isprivate = True
612             elif 'public' in metadata:
613                 # consider a member public if docstring has "public" metadata
614                 isprivate = False
615             else:
616                 isprivate = membername.startswith('_')
617 
618             keep = False
619             if safe_getattr(member, '__sphinx_mock__', False):
620                 # mocked module or object
621                 pass
622             elif want_all and membername.startswith('__') and \
623                     membername.endswith('__') and len(membername) > 4:
624                 # special __methods__
625                 if self.options.special_members is ALL:
626                     if membername == '__doc__':
627                         keep = False
628                     elif is_filtered_inherited_member(membername):
629                         keep = False
630                     else:
631                         keep = has_doc or self.options.undoc_members
632                 elif self.options.special_members:
633                     if membername in self.options.special_members:
634                         keep = has_doc or self.options.undoc_members
635             elif (namespace, membername) in attr_docs:
636                 if want_all and isprivate:
637                     # ignore members whose name starts with _ by default
638                     keep = self.options.private_members
639                 else:
640                     # keep documented attributes
641                     keep = True
642                 isattr = True
643             elif want_all and isprivate:
644                 # ignore members whose name starts with _ by default
645                 keep = self.options.private_members and \
646                     (has_doc or self.options.undoc_members)
647             else:
648                 if self.options.members is ALL and is_filtered_inherited_member(membername):
649                     keep = False
650                 else:
651                     # ignore undocumented members if :undoc-members: is not given
652                     keep = has_doc or self.options.undoc_members
653 
654             # give the user a chance to decide whether this member
655             # should be skipped
656             if self.env.app:
657                 # let extensions preprocess docstrings
658                 try:
659                     skip_user = self.env.app.emit_firstresult(
660                         'autodoc-skip-member', self.objtype, membername, member,
661                         not keep, self.options)
662                     if skip_user is not None:
663                         keep = not skip_user
664                 except Exception as exc:
665                     logger.warning(__('autodoc: failed to determine %r to be documented, '
666                                       'the following exception was raised:\n%s'),
667                                    member, exc, type='autodoc')
668                     keep = False
669 
670             if keep:
671                 ret.append((membername, member, isattr))
672 
673         return ret
674 
675     def document_members(self, all_members: bool = False) -> None:
676         """Generate reST for member documentation.
677 
678         If *all_members* is True, do all members, else those given by
679         *self.options.members*.
680         """
681         # set current namespace for finding members
682         self.env.temp_data['autodoc:module'] = self.modname
683         if self.objpath:
684             self.env.temp_data['autodoc:class'] = self.objpath[0]
685 
686         want_all = all_members or self.options.inherited_members or \
687             self.options.members is ALL
688         # find out which members are documentable
689         members_check_module, members = self.get_object_members(want_all)
690 
691         # remove members given by exclude-members
692         if self.options.exclude_members:
693             members = [
694                 (membername, member) for (membername, member) in members
695                 if (
696                     self.options.exclude_members is ALL or
697                     membername not in self.options.exclude_members
698                 )
699             ]
700 
701         # document non-skipped members
702         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
703         for (mname, member, isattr) in self.filter_members(members, want_all):
704             classes = [cls for cls in self.documenters.values()
705                        if cls.can_document_member(member, mname, isattr, self)]
706             if not classes:
707                 # don't know how to document this member
708                 continue
709             # prefer the documenter with the highest priority
710             classes.sort(key=lambda cls: cls.priority)
711             # give explicitly separated module name, so that members
712             # of inner classes can be documented
713             full_mname = self.modname + '::' + \
714                 '.'.join(self.objpath + [mname])
715             documenter = classes[-1](self.directive, full_mname, self.indent)
716             memberdocumenters.append((documenter, isattr))
717         member_order = self.options.member_order or \
718             self.env.config.autodoc_member_order
719         if member_order == 'groupwise':
720             # sort by group; alphabetically within groups
721             memberdocumenters.sort(key=lambda e: (e[0].member_order, e[0].name))
722         elif member_order == 'bysource':
723             if self.analyzer:
724                 # sort by source order, by virtue of the module analyzer
725                 tagorder = self.analyzer.tagorder
726 
727                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
728                     fullname = entry[0].name.split('::')[1]
729                     return tagorder.get(fullname, len(tagorder))
730                 memberdocumenters.sort(key=keyfunc)
731             else:
732                 # Assume that member discovery order matches source order.
733                 # This is a reasonable assumption in Python 3.6 and up, where
734                 # module.__dict__ is insertion-ordered.
735                 pass
736         else:  # alphabetical
737             memberdocumenters.sort(key=lambda e: e[0].name)
738 
739         for documenter, isattr in memberdocumenters:
740             documenter.generate(
741                 all_members=True, real_modname=self.real_modname,
742                 check_module=members_check_module and not isattr)
743 
744         # reset current objects
745         self.env.temp_data['autodoc:module'] = None
746         self.env.temp_data['autodoc:class'] = None
747 
748     def generate(self, more_content: Any = None, real_modname: str = None,
749                  check_module: bool = False, all_members: bool = False) -> None:
750         """Generate reST for the object given by *self.name*, and possibly for
751         its members.
752 
753         If *more_content* is given, include that content. If *real_modname* is
754         given, use that module name to find attribute docs. If *check_module* is
755         True, only generate if the object is defined in the module name it is
756         imported from. If *all_members* is True, document all members.
757         """
758         if not self.parse_name():
759             # need a module to import
760             logger.warning(
761                 __('don\'t know which module to import for autodocumenting '
762                    '%r (try placing a "module" or "currentmodule" directive '
763                    'in the document, or giving an explicit module name)') %
764                 self.name, type='autodoc')
765             return
766 
767         # now, import the module and get object to document
768         if not self.import_object():
769             return
770 
771         # If there is no real module defined, figure out which to use.
772         # The real module is used in the module analyzer to look up the module
773         # where the attribute documentation would actually be found in.
774         # This is used for situations where you have a module that collects the
775         # functions and classes of internal submodules.
776         guess_modname = self.get_real_modname()
777         self.real_modname = real_modname or guess_modname
778 
779         # try to also get a source code analyzer for attribute docs
780         try:
781             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
782             # parse right now, to get PycodeErrors on parsing (results will
783             # be cached anyway)
784             self.analyzer.find_attr_docs()
785         except PycodeError:
786             logger.debug('[autodoc] module analyzer failed:', exc_info=True)
787             # no source file -- e.g. for builtin and C modules
788             self.analyzer = None
789             # at least add the module.__file__ as a dependency
790             if hasattr(self.module, '__file__') and self.module.__file__:
791                 self.directive.filename_set.add(self.module.__file__)
792         else:
793             self.directive.filename_set.add(self.analyzer.srcname)
794 
795         if self.real_modname != guess_modname:
796             # Add module to dependency list if target object is defined in other module.
797             try:
798                 analyzer = ModuleAnalyzer.for_module(guess_modname)
799                 self.directive.filename_set.add(analyzer.srcname)
800             except PycodeError:
801                 pass
802 
803         # check __module__ of object (for members not given explicitly)
804         if check_module:
805             if not self.check_module():
806                 return
807 
808         sourcename = self.get_sourcename()
809 
810         # make sure that the result starts with an empty line.  This is
811         # necessary for some situations where another directive preprocesses
812         # reST and no starting newline is present
813         self.add_line('', sourcename)
814 
815         # format the object's signature, if any
816         sig = self.format_signature()
817 
818         # generate the directive header and options, if applicable
819         self.add_directive_header(sig)
820         self.add_line('', sourcename)
821 
822         # e.g. the module directive doesn't have content
823         self.indent += self.content_indent
824 
825         # add all content (from docstrings, attribute docs etc.)
826         self.add_content(more_content)
827 
828         # document members, if possible
829         self.document_members(all_members)
830 
831 
832 class ModuleDocumenter(Documenter):
833     """
834     Specialized Documenter subclass for modules.
835     """
836     objtype = 'module'
837     content_indent = ''
838     titles_allowed = True
839 
840     option_spec = {
841         'members': members_option, 'undoc-members': bool_option,
842         'noindex': bool_option, 'inherited-members': inherited_members_option,
843         'show-inheritance': bool_option, 'synopsis': identity,
844         'platform': identity, 'deprecated': bool_option,
845         'member-order': member_order_option, 'exclude-members': members_set_option,
846         'private-members': bool_option, 'special-members': members_option,
847         'imported-members': bool_option, 'ignore-module-all': bool_option
848     }  # type: Dict[str, Callable]
849 
850     def __init__(self, *args: Any) -> None:
851         super().__init__(*args)
852         merge_special_members_option(self.options)
853 
854     @classmethod
855     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
856                             ) -> bool:
857         # don't document submodules automatically
858         return False
859 
860     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
861                      ) -> Tuple[str, List[str]]:
862         if modname is not None:
863             logger.warning(__('"::" in automodule name doesn\'t make sense'),
864                            type='autodoc')
865         return (path or '') + base, []
866 
867     def parse_name(self) -> bool:
868         ret = super().parse_name()
869         if self.args or self.retann:
870             logger.warning(__('signature arguments or return annotation '
871                               'given for automodule %s') % self.fullname,
872                            type='autodoc')
873         return ret
874 
875     def add_directive_header(self, sig: str) -> None:
876         Documenter.add_directive_header(self, sig)
877 
878         sourcename = self.get_sourcename()
879 
880         # add some module-specific options
881         if self.options.synopsis:
882             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
883         if self.options.platform:
884             self.add_line('   :platform: ' + self.options.platform, sourcename)
885         if self.options.deprecated:
886             self.add_line('   :deprecated:', sourcename)
887 
888     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
889         if want_all:
890             if (self.options.ignore_module_all or not
891                     hasattr(self.object, '__all__')):
892                 # for implicit module members, check __module__ to avoid
893                 # documenting imported objects
894                 return True, get_module_members(self.object)
895             else:
896                 memberlist = self.object.__all__
897                 # Sometimes __all__ is broken...
898                 if not isinstance(memberlist, (list, tuple)) or not \
899                    all(isinstance(entry, str) for entry in memberlist):
900                     logger.warning(
901                         __('__all__ should be a list of strings, not %r '
902                            '(in module %s) -- ignoring __all__') %
903                         (memberlist, self.fullname),
904                         type='autodoc'
905                     )
906                     # fall back to all members
907                     return True, get_module_members(self.object)
908         else:
909             memberlist = self.options.members or []
910         ret = []
911         for mname in memberlist:
912             try:
913                 ret.append((mname, safe_getattr(self.object, mname)))
914             except AttributeError:
915                 logger.warning(
916                     __('missing attribute mentioned in :members: or __all__: '
917                        'module %s, attribute %s') %
918                     (safe_getattr(self.object, '__name__', '???'), mname),
919                     type='autodoc'
920                 )
921         return False, ret
922 
923 
924 class ModuleLevelDocumenter(Documenter):
925     """
926     Specialized Documenter subclass for objects on module level (functions,
927     classes, data/constants).
928     """
929     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
930                      ) -> Tuple[str, List[str]]:
931         if modname is None:
932             if path:
933                 stripped = path.rstrip('.')
934                 modname, qualname = split_full_qualified_name(stripped)
935                 if qualname:
936                     parents = qualname.split(".")
937                 else:
938                     parents = []
939 
940             if modname is None:
941                 # if documenting a toplevel object without explicit module,
942                 # it can be contained in another auto directive ...
943                 modname = self.env.temp_data.get('autodoc:module')
944                 # ... or in the scope of a module directive
945                 if not modname:
946                     modname = self.env.ref_context.get('py:module')
947                 # ... else, it stays None, which means invalid
948         return modname, parents + [base]
949 
950 
951 class ClassLevelDocumenter(Documenter):
952     """
953     Specialized Documenter subclass for objects on class level (methods,
954     attributes).
955     """
956     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
957                      ) -> Tuple[str, List[str]]:
958         if modname is None:
959             if path:
960                 mod_cls = path.rstrip('.')
961             else:
962                 mod_cls = None
963                 # if documenting a class-level object without path,
964                 # there must be a current class, either from a parent
965                 # auto directive ...
966                 mod_cls = self.env.temp_data.get('autodoc:class')
967                 # ... or from a class directive
968                 if mod_cls is None:
969                     mod_cls = self.env.ref_context.get('py:class')
970                 # ... if still None, there's no way to know
971                 if mod_cls is None:
972                     return None, []
973 
974             try:
975                 modname, qualname = split_full_qualified_name(mod_cls)
976                 parents = qualname.split(".") if qualname else []
977             except ImportError:
978                 parents = mod_cls.split(".")
979 
980             # if the module name is still missing, get it like above
981             if not modname:
982                 modname = self.env.temp_data.get('autodoc:module')
983             if not modname:
984                 modname = self.env.ref_context.get('py:module')
985             # ... else, it stays None, which means invalid
986         return modname, parents + [base]
987 
988 
989 class DocstringSignatureMixin:
990     """
991     Mixin for FunctionDocumenter and MethodDocumenter to provide the
992     feature of reading the signature from the docstring.
993     """
994 
995     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
996         if encoding is not None:
997             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
998                           "deprecated." % self.__class__.__name__,
999                           RemovedInSphinx40Warning, stacklevel=2)
1000         docstrings = self.get_doc()
1001         self._new_docstrings = docstrings[:]
1002         result = None
1003         for i, doclines in enumerate(docstrings):
1004             # no lines in docstring, no match
1005             if not doclines:
1006                 continue
1007             # match first line of docstring against signature RE
1008             match = py_ext_sig_re.match(doclines[0])
1009             if not match:
1010                 continue
1011             exmod, path, base, args, retann = match.groups()
1012             # the base name must match ours
1013             valid_names = [self.objpath[-1]]  # type: ignore
1014             if isinstance(self, ClassDocumenter):
1015                 valid_names.append('__init__')
1016                 if hasattr(self.object, '__mro__'):
1017                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1018             if base not in valid_names:
1019                 continue
1020             # re-prepare docstring to ignore more leading indentation
1021             tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1022             self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
1023                                                         tabsize=tab_width)
1024             result = args, retann
1025             # don't look any further
1026             break
1027         return result
1028 
1029     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1030         if encoding is not None:
1031             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1032                           % self.__class__.__name__,
1033                           RemovedInSphinx40Warning, stacklevel=2)
1034         lines = getattr(self, '_new_docstrings', None)
1035         if lines is not None:
1036             return lines
1037         return super().get_doc(None, ignore)  # type: ignore
1038 
1039     def format_signature(self, **kwargs: Any) -> str:
1040         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1041             # only act if a signature is not explicitly given already, and if
1042             # the feature is enabled
1043             result = self._find_signature()
1044             if result is not None:
1045                 self.args, self.retann = result
1046         return super().format_signature(**kwargs)  # type: ignore
1047 
1048 
1049 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1050     """
1051     Mixin for AttributeDocumenter to provide the
1052     feature of stripping any function signature from the docstring.
1053     """
1054     def format_signature(self, **kwargs: Any) -> str:
1055         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1056             # only act if a signature is not explicitly given already, and if
1057             # the feature is enabled
1058             result = self._find_signature()
1059             if result is not None:
1060                 # Discarding _args is a only difference with
1061                 # DocstringSignatureMixin.format_signature.
1062                 # Documenter.format_signature use self.args value to format.
1063                 _args, self.retann = result
1064         return super().format_signature(**kwargs)
1065 
1066 
1067 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1068     """
1069     Specialized Documenter subclass for functions.
1070     """
1071     objtype = 'function'
1072     member_order = 30
1073 
1074     @classmethod
1075     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1076                             ) -> bool:
1077         # supports functions, builtins and bound methods exported at the module level
1078         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1079                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1080 
1081     def format_args(self, **kwargs: Any) -> str:
1082         if self.env.config.autodoc_typehints in ('none', 'description'):
1083             kwargs.setdefault('show_annotation', False)
1084 
1085         try:
1086             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1087             if inspect.is_singledispatch_function(self.object):
1088                 sig = inspect.signature(self.object, follow_wrapped=True)
1089             else:
1090                 sig = inspect.signature(self.object)
1091             args = stringify_signature(sig, **kwargs)
1092         except TypeError as exc:
1093             logger.warning(__("Failed to get a function signature for %s: %s"),
1094                            self.fullname, exc)
1095             return None
1096         except ValueError:
1097             args = ''
1098 
1099         if self.env.config.strip_signature_backslash:
1100             # escape backslashes for reST
1101             args = args.replace('\\', '\\\\')
1102         return args
1103 
1104     def document_members(self, all_members: bool = False) -> None:
1105         pass
1106 
1107     def add_directive_header(self, sig: str) -> None:
1108         sourcename = self.get_sourcename()
1109         super().add_directive_header(sig)
1110 
1111         if inspect.iscoroutinefunction(self.object):
1112             self.add_line('   :async:', sourcename)
1113 
1114     def format_signature(self, **kwargs: Any) -> str:
1115         sig = super().format_signature(**kwargs)
1116         sigs = [sig]
1117 
1118         if inspect.is_singledispatch_function(self.object):
1119             # append signature of singledispatch'ed functions
1120             for typ, func in self.object.registry.items():
1121                 if typ is object:
1122                     pass  # default implementation. skipped.
1123                 else:
1124                     self.annotate_to_first_argument(func, typ)
1125 
1126                     documenter = FunctionDocumenter(self.directive, '')
1127                     documenter.object = func
1128                     sigs.append(documenter.format_signature())
1129 
1130         return "\n".join(sigs)
1131 
1132     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1133         """Annotate type hint to the first argument of function if needed."""
1134         sig = inspect.signature(func)
1135         if len(sig.parameters) == 0:
1136             return
1137 
1138         params = list(sig.parameters.values())
1139         if params[0].annotation is Parameter.empty:
1140             params[0] = params[0].replace(annotation=typ)
1141             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1142 
1143 
1144 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1145     """
1146     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1147 
1148     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1149     """
1150 
1151 
1152 class DecoratorDocumenter(FunctionDocumenter):
1153     """
1154     Specialized Documenter subclass for decorator functions.
1155     """
1156     objtype = 'decorator'
1157 
1158     # must be lower than FunctionDocumenter
1159     priority = -1
1160 
1161     def format_args(self, **kwargs: Any) -> Any:
1162         args = super().format_args(**kwargs)
1163         if ',' in args:
1164             return args
1165         else:
1166             return None
1167 
1168 
1169 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1170     """
1171     Specialized Documenter subclass for classes.
1172     """
1173     objtype = 'class'
1174     member_order = 20
1175     option_spec = {
1176         'members': members_option, 'undoc-members': bool_option,
1177         'noindex': bool_option, 'inherited-members': inherited_members_option,
1178         'show-inheritance': bool_option, 'member-order': member_order_option,
1179         'exclude-members': members_set_option,
1180         'private-members': bool_option, 'special-members': members_option,
1181     }  # type: Dict[str, Callable]
1182 
1183     def __init__(self, *args: Any) -> None:
1184         super().__init__(*args)
1185         merge_special_members_option(self.options)
1186 
1187     @classmethod
1188     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1189                             ) -> bool:
1190         return isinstance(member, type)
1191 
1192     def import_object(self) -> Any:
1193         ret = super().import_object()
1194         # if the class is documented under another name, document it
1195         # as data/attribute
1196         if ret:
1197             if hasattr(self.object, '__name__'):
1198                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1199             else:
1200                 self.doc_as_attr = True
1201         return ret
1202 
1203     def format_args(self, **kwargs: Any) -> str:
1204         if self.env.config.autodoc_typehints in ('none', 'description'):
1205             kwargs.setdefault('show_annotation', False)
1206 
1207         # for classes, the relevant signature is the __init__ method's
1208         initmeth = self.get_attr(self.object, '__init__', None)
1209         # classes without __init__ method, default __init__ or
1210         # __init__ written in C?
1211         if initmeth is None or \
1212                 inspect.is_builtin_class_method(self.object, '__init__') or \
1213                 not(inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):
1214             return None
1215         try:
1216             self.env.app.emit('autodoc-before-process-signature', initmeth, True)
1217             sig = inspect.signature(initmeth, bound_method=True)
1218             return stringify_signature(sig, show_return_annotation=False, **kwargs)
1219         except TypeError:
1220             # still not possible: happens e.g. for old-style classes
1221             # with __init__ in C
1222             return None
1223 
1224     def format_signature(self, **kwargs: Any) -> str:
1225         if self.doc_as_attr:
1226             return ''
1227 
1228         return super().format_signature(**kwargs)
1229 
1230     def add_directive_header(self, sig: str) -> None:
1231         sourcename = self.get_sourcename()
1232 
1233         if self.doc_as_attr:
1234             self.directivetype = 'attribute'
1235         super().add_directive_header(sig)
1236 
1237         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1238             self.add_line('   :final:', sourcename)
1239 
1240         # add inheritance info, if wanted
1241         if not self.doc_as_attr and self.options.show_inheritance:
1242             sourcename = self.get_sourcename()
1243             self.add_line('', sourcename)
1244             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1245                 bases = [':class:`%s`' % b.__name__
1246                          if b.__module__ in ('__builtin__', 'builtins')
1247                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1248                          for b in self.object.__bases__]
1249                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1250                               sourcename)
1251 
1252     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1253         if encoding is not None:
1254             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1255                           % self.__class__.__name__,
1256                           RemovedInSphinx40Warning, stacklevel=2)
1257         lines = getattr(self, '_new_docstrings', None)
1258         if lines is not None:
1259             return lines
1260 
1261         content = self.env.config.autoclass_content
1262 
1263         docstrings = []
1264         attrdocstring = self.get_attr(self.object, '__doc__', None)
1265         if attrdocstring:
1266             docstrings.append(attrdocstring)
1267 
1268         # for classes, what the "docstring" is can be controlled via a
1269         # config value; the default is only the class docstring
1270         if content in ('both', 'init'):
1271             __init__ = self.get_attr(self.object, '__init__', None)
1272             initdocstring = getdoc(__init__, self.get_attr,
1273                                    self.env.config.autodoc_inherit_docstrings,
1274                                    self.parent, self.object_name)
1275             # for new-style classes, no __init__ means default __init__
1276             if (initdocstring is not None and
1277                 (initdocstring == object.__init__.__doc__ or  # for pypy
1278                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1279                 initdocstring = None
1280             if not initdocstring:
1281                 # try __new__
1282                 __new__ = self.get_attr(self.object, '__new__', None)
1283                 initdocstring = getdoc(__new__, self.get_attr,
1284                                        self.env.config.autodoc_inherit_docstrings,
1285                                        self.parent, self.object_name)
1286                 # for new-style classes, no __new__ means default __new__
1287                 if (initdocstring is not None and
1288                     (initdocstring == object.__new__.__doc__ or  # for pypy
1289                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1290                     initdocstring = None
1291             if initdocstring:
1292                 if content == 'init':
1293                     docstrings = [initdocstring]
1294                 else:
1295                     docstrings.append(initdocstring)
1296 
1297         tab_width = self.directive.state.document.settings.tab_width
1298         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1299 
1300     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1301         if self.doc_as_attr:
1302             classname = safe_getattr(self.object, '__qualname__', None)
1303             if not classname:
1304                 classname = safe_getattr(self.object, '__name__', None)
1305             if classname:
1306                 module = safe_getattr(self.object, '__module__', None)
1307                 parentmodule = safe_getattr(self.parent, '__module__', None)
1308                 if module and module != parentmodule:
1309                     classname = str(module) + '.' + str(classname)
1310                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1311                 super().add_content(content, no_docstring=True)
1312         else:
1313             super().add_content(more_content)
1314 
1315     def document_members(self, all_members: bool = False) -> None:
1316         if self.doc_as_attr:
1317             return
1318         super().document_members(all_members)
1319 
1320     def generate(self, more_content: Any = None, real_modname: str = None,
1321                  check_module: bool = False, all_members: bool = False) -> None:
1322         # Do not pass real_modname and use the name from the __module__
1323         # attribute of the class.
1324         # If a class gets imported into the module real_modname
1325         # the analyzer won't find the source of the class, if
1326         # it looks in real_modname.
1327         return super().generate(more_content=more_content,
1328                                 check_module=check_module,
1329                                 all_members=all_members)
1330 
1331 
1332 class ExceptionDocumenter(ClassDocumenter):
1333     """
1334     Specialized ClassDocumenter subclass for exceptions.
1335     """
1336     objtype = 'exception'
1337     member_order = 10
1338 
1339     # needs a higher priority than ClassDocumenter
1340     priority = 10
1341 
1342     @classmethod
1343     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1344                             ) -> bool:
1345         return isinstance(member, type) and issubclass(member, BaseException)
1346 
1347 
1348 class DataDocumenter(ModuleLevelDocumenter):
1349     """
1350     Specialized Documenter subclass for data items.
1351     """
1352     objtype = 'data'
1353     member_order = 40
1354     priority = -10
1355     option_spec = dict(ModuleLevelDocumenter.option_spec)
1356     option_spec["annotation"] = annotation_option
1357 
1358     @classmethod
1359     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1360                             ) -> bool:
1361         return isinstance(parent, ModuleDocumenter) and isattr
1362 
1363     def add_directive_header(self, sig: str) -> None:
1364         super().add_directive_header(sig)
1365         sourcename = self.get_sourcename()
1366         if not self.options.annotation:
1367             # obtain annotation for this data
1368             annotations = getattr(self.parent, '__annotations__', {})
1369             if annotations and self.objpath[-1] in annotations:
1370                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1371                 self.add_line('   :type: ' + objrepr, sourcename)
1372             else:
1373                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1374                 if self.analyzer and key in self.analyzer.annotations:
1375                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1376                                   sourcename)
1377 
1378             try:
1379                 if self.object is UNINITIALIZED_ATTR:
1380                     pass
1381                 else:
1382                     objrepr = object_description(self.object)
1383                     self.add_line('   :value: ' + objrepr, sourcename)
1384             except ValueError:
1385                 pass
1386         elif self.options.annotation is SUPPRESS:
1387             pass
1388         else:
1389             self.add_line('   :annotation: %s' % self.options.annotation,
1390                           sourcename)
1391 
1392     def document_members(self, all_members: bool = False) -> None:
1393         pass
1394 
1395     def get_real_modname(self) -> str:
1396         return self.get_attr(self.parent or self.object, '__module__', None) \
1397             or self.modname
1398 
1399 
1400 class DataDeclarationDocumenter(DataDocumenter):
1401     """
1402     Specialized Documenter subclass for data that cannot be imported
1403     because they are declared without initial value (refs: PEP-526).
1404     """
1405     objtype = 'datadecl'
1406     directivetype = 'data'
1407     member_order = 60
1408 
1409     # must be higher than AttributeDocumenter
1410     priority = 11
1411 
1412     @classmethod
1413     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1414                             ) -> bool:
1415         """This documents only INSTANCEATTR members."""
1416         return (isinstance(parent, ModuleDocumenter) and
1417                 isattr and
1418                 member is INSTANCEATTR)
1419 
1420     def import_object(self) -> bool:
1421         """Never import anything."""
1422         # disguise as a data
1423         self.objtype = 'data'
1424         self.object = UNINITIALIZED_ATTR
1425         try:
1426             # import module to obtain type annotation
1427             self.parent = importlib.import_module(self.modname)
1428         except ImportError:
1429             pass
1430 
1431         return True
1432 
1433     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1434         """Never try to get a docstring from the object."""
1435         super().add_content(more_content, no_docstring=True)
1436 
1437 
1438 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1439     """
1440     Specialized Documenter subclass for methods (normal, static and class).
1441     """
1442     objtype = 'method'
1443     directivetype = 'method'
1444     member_order = 50
1445     priority = 1  # must be more than FunctionDocumenter
1446 
1447     @classmethod
1448     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1449                             ) -> bool:
1450         return inspect.isroutine(member) and \
1451             not isinstance(parent, ModuleDocumenter)
1452 
1453     def import_object(self) -> Any:
1454         ret = super().import_object()
1455         if not ret:
1456             return ret
1457 
1458         # to distinguish classmethod/staticmethod
1459         obj = self.parent.__dict__.get(self.object_name)
1460         if obj is None:
1461             obj = self.object
1462 
1463         if (inspect.isclassmethod(obj) or
1464                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1465             # document class and static members before ordinary ones
1466             self.member_order = self.member_order - 1
1467 
1468         return ret
1469 
1470     def format_args(self, **kwargs: Any) -> str:
1471         if self.env.config.autodoc_typehints in ('none', 'description'):
1472             kwargs.setdefault('show_annotation', False)
1473 
1474         try:
1475             if self.object == object.__init__ and self.parent != object:
1476                 # Classes not having own __init__() method are shown as no arguments.
1477                 #
1478                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1479                 #       But it makes users confused.
1480                 args = '()'
1481             else:
1482                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1483                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1484                     sig = inspect.signature(self.object, bound_method=False)
1485                 else:
1486                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1487 
1488                     meth = self.parent.__dict__.get(self.objpath[-1], None)
1489                     if meth and inspect.is_singledispatch_method(meth):
1490                         sig = inspect.signature(self.object, bound_method=True,
1491                                                 follow_wrapped=True)
1492                     else:
1493                         sig = inspect.signature(self.object, bound_method=True)
1494                 args = stringify_signature(sig, **kwargs)
1495         except TypeError as exc:
1496             logger.warning(__("Failed to get a method signature for %s: %s"),
1497                            self.fullname, exc)
1498             return None
1499         except ValueError:
1500             args = ''
1501 
1502         if self.env.config.strip_signature_backslash:
1503             # escape backslashes for reST
1504             args = args.replace('\\', '\\\\')
1505         return args
1506 
1507     def add_directive_header(self, sig: str) -> None:
1508         super().add_directive_header(sig)
1509 
1510         sourcename = self.get_sourcename()
1511         obj = self.parent.__dict__.get(self.object_name, self.object)
1512         if inspect.isabstractmethod(obj):
1513             self.add_line('   :abstractmethod:', sourcename)
1514         if inspect.iscoroutinefunction(obj):
1515             self.add_line('   :async:', sourcename)
1516         if inspect.isclassmethod(obj):
1517             self.add_line('   :classmethod:', sourcename)
1518         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1519             self.add_line('   :staticmethod:', sourcename)
1520         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1521             self.add_line('   :final:', sourcename)
1522 
1523     def document_members(self, all_members: bool = False) -> None:
1524         pass
1525 
1526     def format_signature(self, **kwargs: Any) -> str:
1527         sig = super().format_signature(**kwargs)
1528         sigs = [sig]
1529 
1530         meth = self.parent.__dict__.get(self.objpath[-1])
1531         if inspect.is_singledispatch_method(meth):
1532             # append signature of singledispatch'ed functions
1533             for typ, func in meth.dispatcher.registry.items():
1534                 if typ is object:
1535                     pass  # default implementation. skipped.
1536                 else:
1537                     self.annotate_to_first_argument(func, typ)
1538 
1539                     documenter = MethodDocumenter(self.directive, '')
1540                     documenter.parent = self.parent
1541                     documenter.object = func
1542                     documenter.objpath = [None]
1543                     sigs.append(documenter.format_signature())
1544 
1545         return "\n".join(sigs)
1546 
1547     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1548         """Annotate type hint to the first argument of function if needed."""
1549         sig = inspect.signature(func)
1550         if len(sig.parameters) == 1:
1551             return
1552 
1553         params = list(sig.parameters.values())
1554         if params[1].annotation is Parameter.empty:
1555             params[1] = params[1].replace(annotation=typ)
1556             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1557 
1558 
1559 class SingledispatchMethodDocumenter(MethodDocumenter):
1560     """
1561     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1562 
1563     Retained for backwards compatibility, now does the same as the MethodDocumenter
1564     """
1565 
1566 
1567 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1568     """
1569     Specialized Documenter subclass for attributes.
1570     """
1571     objtype = 'attribute'
1572     member_order = 60
1573     option_spec = dict(ModuleLevelDocumenter.option_spec)
1574     option_spec["annotation"] = annotation_option
1575 
1576     # must be higher than the MethodDocumenter, else it will recognize
1577     # some non-data descriptors as methods
1578     priority = 10
1579 
1580     @staticmethod
1581     def is_function_or_method(obj: Any) -> bool:
1582         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1583 
1584     @classmethod
1585     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1586                             ) -> bool:
1587         if inspect.isattributedescriptor(member):
1588             return True
1589         elif (not isinstance(parent, ModuleDocumenter) and
1590               not inspect.isroutine(member) and
1591               not isinstance(member, type)):
1592             return True
1593         else:
1594             return False
1595 
1596     def document_members(self, all_members: bool = False) -> None:
1597         pass
1598 
1599     def import_object(self) -> Any:
1600         ret = super().import_object()
1601         if inspect.isenumattribute(self.object):
1602             self.object = self.object.value
1603         if inspect.isattributedescriptor(self.object):
1604             self._datadescriptor = True
1605         else:
1606             # if it's not a data descriptor
1607             self._datadescriptor = False
1608         return ret
1609 
1610     def get_real_modname(self) -> str:
1611         return self.get_attr(self.parent or self.object, '__module__', None) \
1612             or self.modname
1613 
1614     def add_directive_header(self, sig: str) -> None:
1615         super().add_directive_header(sig)
1616         sourcename = self.get_sourcename()
1617         if not self.options.annotation:
1618             # obtain type annotation for this attribute
1619             annotations = getattr(self.parent, '__annotations__', {})
1620             if annotations and self.objpath[-1] in annotations:
1621                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1622                 self.add_line('   :type: ' + objrepr, sourcename)
1623             else:
1624                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1625                 if self.analyzer and key in self.analyzer.annotations:
1626                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1627                                   sourcename)
1628 
1629             # data descriptors do not have useful values
1630             if not self._datadescriptor:
1631                 try:
1632                     if self.object is INSTANCEATTR:
1633                         pass
1634                     else:
1635                         objrepr = object_description(self.object)
1636                         self.add_line('   :value: ' + objrepr, sourcename)
1637                 except ValueError:
1638                     pass
1639         elif self.options.annotation is SUPPRESS:
1640             pass
1641         else:
1642             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
1643 
1644     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1645         if not self._datadescriptor:
1646             # if it's not a data descriptor, its docstring is very probably the
1647             # wrong thing to display
1648             no_docstring = True
1649         super().add_content(more_content, no_docstring)
1650 
1651 
1652 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1653     """
1654     Specialized Documenter subclass for properties.
1655     """
1656     objtype = 'property'
1657     directivetype = 'method'
1658     member_order = 60
1659 
1660     # before AttributeDocumenter
1661     priority = AttributeDocumenter.priority + 1
1662 
1663     @classmethod
1664     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1665                             ) -> bool:
1666         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
1667 
1668     def document_members(self, all_members: bool = False) -> None:
1669         pass
1670 
1671     def get_real_modname(self) -> str:
1672         return self.get_attr(self.parent or self.object, '__module__', None) \
1673             or self.modname
1674 
1675     def add_directive_header(self, sig: str) -> None:
1676         super().add_directive_header(sig)
1677         sourcename = self.get_sourcename()
1678         if inspect.isabstractmethod(self.object):
1679             self.add_line('   :abstractmethod:', sourcename)
1680         self.add_line('   :property:', sourcename)
1681 
1682 
1683 class InstanceAttributeDocumenter(AttributeDocumenter):
1684     """
1685     Specialized Documenter subclass for attributes that cannot be imported
1686     because they are instance attributes (e.g. assigned in __init__).
1687     """
1688     objtype = 'instanceattribute'
1689     directivetype = 'attribute'
1690     member_order = 60
1691 
1692     # must be higher than AttributeDocumenter
1693     priority = 11
1694 
1695     @classmethod
1696     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1697                             ) -> bool:
1698         """This documents only INSTANCEATTR members."""
1699         return (not isinstance(parent, ModuleDocumenter) and
1700                 isattr and
1701                 member is INSTANCEATTR)
1702 
1703     def import_object(self) -> bool:
1704         """Never import anything."""
1705         # disguise as an attribute
1706         self.objtype = 'attribute'
1707         self.object = INSTANCEATTR
1708         self._datadescriptor = False
1709         return True
1710 
1711     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1712         """Never try to get a docstring from the object."""
1713         super().add_content(more_content, no_docstring=True)
1714 
1715 
1716 class SlotsAttributeDocumenter(AttributeDocumenter):
1717     """
1718     Specialized Documenter subclass for attributes that cannot be imported
1719     because they are attributes in __slots__.
1720     """
1721     objtype = 'slotsattribute'
1722     directivetype = 'attribute'
1723     member_order = 60
1724 
1725     # must be higher than AttributeDocumenter
1726     priority = 11
1727 
1728     @classmethod
1729     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1730                             ) -> bool:
1731         """This documents only SLOTSATTR members."""
1732         return member is SLOTSATTR
1733 
1734     def import_object(self) -> Any:
1735         """Never import anything."""
1736         # disguise as an attribute
1737         self.objtype = 'attribute'
1738         self._datadescriptor = True
1739 
1740         with mock(self.env.config.autodoc_mock_imports):
1741             try:
1742                 ret = import_object(self.modname, self.objpath[:-1], 'class',
1743                                     attrgetter=self.get_attr,
1744                                     warningiserror=self.env.config.autodoc_warningiserror)
1745                 self.module, _, _, self.parent = ret
1746                 return True
1747             except ImportError as exc:
1748                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1749                 self.env.note_reread()
1750                 return False
1751 
1752     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1753         """Decode and return lines of the docstring(s) for the object."""
1754         if ignore is not None:
1755             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1756                           % self.__class__.__name__,
1757                           RemovedInSphinx50Warning, stacklevel=2)
1758         name = self.objpath[-1]
1759         __slots__ = safe_getattr(self.parent, '__slots__', [])
1760         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
1761             docstring = prepare_docstring(__slots__[name])
1762             return [docstring]
1763         else:
1764             return []
1765 
1766 
1767 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
1768     """Returns registered Documenter classes"""
1769     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
1770     return app.registry.documenters
1771 
1772 
1773 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
1774     """Alternative getattr() for types"""
1775     for typ, func in app.registry.autodoc_attrgettrs.items():
1776         if isinstance(obj, typ):
1777             return func(obj, name, *defargs)
1778 
1779     return safe_getattr(obj, name, *defargs)
1780 
1781 
1782 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
1783     if config.autodoc_member_order == 'alphabetic':
1784         # RemovedInSphinx50Warning
1785         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
1786                           'instead of "alphabetic". Please update your setting.'))
1787         config.autodoc_member_order = 'alphabetical'  # type: ignore
1788 
1789 
1790 def setup(app: Sphinx) -> Dict[str, Any]:
1791     app.add_autodocumenter(ModuleDocumenter)
1792     app.add_autodocumenter(ClassDocumenter)
1793     app.add_autodocumenter(ExceptionDocumenter)
1794     app.add_autodocumenter(DataDocumenter)
1795     app.add_autodocumenter(DataDeclarationDocumenter)
1796     app.add_autodocumenter(FunctionDocumenter)
1797     app.add_autodocumenter(DecoratorDocumenter)
1798     app.add_autodocumenter(MethodDocumenter)
1799     app.add_autodocumenter(AttributeDocumenter)
1800     app.add_autodocumenter(PropertyDocumenter)
1801     app.add_autodocumenter(InstanceAttributeDocumenter)
1802     app.add_autodocumenter(SlotsAttributeDocumenter)
1803 
1804     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
1805     app.add_config_value('autodoc_member_order', 'alphabetical', True,
1806                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
1807     app.add_config_value('autodoc_default_options', {}, True)
1808     app.add_config_value('autodoc_docstring_signature', True, True)
1809     app.add_config_value('autodoc_mock_imports', [], True)
1810     app.add_config_value('autodoc_typehints', "signature", True,
1811                          ENUM("signature", "description", "none"))
1812     app.add_config_value('autodoc_warningiserror', True, True)
1813     app.add_config_value('autodoc_inherit_docstrings', True, True)
1814     app.add_event('autodoc-before-process-signature')
1815     app.add_event('autodoc-process-docstring')
1816     app.add_event('autodoc-process-signature')
1817     app.add_event('autodoc-skip-member')
1818 
1819     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
1820 
1821     app.setup_extension('sphinx.ext.autodoc.type_comment')
1822     app.setup_extension('sphinx.ext.autodoc.typehints')
1823 
1824     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>In the context of rendering docstrings to HTML, this file should ensure that attribute names with trailing underscores are not incorrectly escaped. If the problem lies within Autodoc's handling of docstring content post-Napoleon processing, ensuring that underscores at the end of attribute names are properly handled will resolve the issue. Autodoc's rendering process needs to recognize these cases and treat them accordingly, maintaining the integrity of identifier names including their trailing underscores in the final HTML documentation.</intended_behavior>]
2025-10-18 06:40:41.019 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:40:41.019 | INFO     | Search-only: skipping patch selection
2025-10-18 06:40:41.135 | INFO     | Task sphinx-doc__sphinx-7738 completed successfully.
2025-10-18 06:40:41.135 | INFO     | No patch generated. You can try running ACR again.
