[
    {
        "rel_file_path": "sympy/core/function.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/core/function.py",
        "start": 2383,
        "end": 2398,
        "class_name": null,
        "method_name": "expand_func",
        "code": "2383 def expand_func(expr, deep=True):\n2384     \"\"\"\n2385     Wrapper around expand that only uses the func hint.  See the expand\n2386     docstring for more information.\n2387 \n2388     Examples\n2389     ========\n2390 \n2391     >>> from sympy import expand_func, gamma\n2392     >>> from sympy.abc import x\n2393     >>> expand_func(gamma(x + 2))\n2394     x*(x + 1)*gamma(x)\n2395 \n2396     \"\"\"\n2397     return sympify(expr).expand(deep=deep, func=True, basic=False,\n2398     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)\n",
        "intended_behavior": "The `expand_func` method should be modified to correctly handle the expansion of `polylog` functions. This involves specifically addressing how `polylog` terms are expanded without introducing unnecessary or incorrect mathematical entities such as `exp_polar(-I*pi)`. The intended behavior should ensure that for cases like `polylog(2, Rational(1,2))`, it expands correctly according to known mathematical identities without resorting to defaults that leave the expression unchanged or incorrectly altered. It should correctly simplify to `-log(2)**2/2 + pi**2/12` where applicable, following the mathematical principles of polylogarithms and their expansions."
    },
    {
        "rel_file_path": "sympy/functions/special/zeta_functions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/functions/special/zeta_functions.py",
        "start": 1,
        "end": 578,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Riemann zeta and related function. \"\"\"\n2 from __future__ import print_function, division\n3 \n4 from sympy.core import Function, S, sympify, pi\n5 from sympy.core.function import ArgumentIndexError\n6 from sympy.core.compatibility import range\n7 from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic\n8 from sympy.functions.elementary.exponential import log\n9 \n10 \n11 ###############################################################################\n12 ###################### LERCH TRANSCENDENT #####################################\n13 ###############################################################################\n14 \n15 \n16 class lerchphi(Function):\n17     r\"\"\"\n18     Lerch transcendent (Lerch phi function).\n19 \n20     For :math:`\\operatorname{Re}(a) > 0`, `|z| < 1` and `s \\in \\mathbb{C}`, the\n21     Lerch transcendent is defined as\n22 \n23     .. math :: \\Phi(z, s, a) = \\sum_{n=0}^\\infty \\frac{z^n}{(n + a)^s},\n24 \n25     where the standard branch of the argument is used for :math:`n + a`,\n26     and by analytic continuation for other values of the parameters.\n27 \n28     A commonly used related function is the Lerch zeta function, defined by\n29 \n30     .. math:: L(q, s, a) = \\Phi(e^{2\\pi i q}, s, a).\n31 \n32     **Analytic Continuation and Branching Behavior**\n33 \n34     It can be shown that\n35 \n36     .. math:: \\Phi(z, s, a) = z\\Phi(z, s, a+1) + a^{-s}.\n37 \n38     This provides the analytic continuation to `\\operatorname{Re}(a) \\le 0`.\n39 \n40     Assume now `\\operatorname{Re}(a) > 0`. The integral representation\n41 \n42     .. math:: \\Phi_0(z, s, a) = \\int_0^\\infty \\frac{t^{s-1} e^{-at}}{1 - ze^{-t}}\n43                                 \\frac{\\mathrm{d}t}{\\Gamma(s)}\n44 \n45     provides an analytic continuation to :math:`\\mathbb{C} - [1, \\infty)`.\n46     Finally, for :math:`x \\in (1, \\infty)` we find\n47 \n48     .. math:: \\lim_{\\epsilon \\to 0^+} \\Phi_0(x + i\\epsilon, s, a)\n49              -\\lim_{\\epsilon \\to 0^+} \\Phi_0(x - i\\epsilon, s, a)\n50              = \\frac{2\\pi i \\log^{s-1}{x}}{x^a \\Gamma(s)},\n51 \n52     using the standard branch for both :math:`\\log{x}` and\n53     :math:`\\log{\\log{x}}` (a branch of :math:`\\log{\\log{x}}` is needed to\n54     evaluate :math:`\\log{x}^{s-1}`).\n55     This concludes the analytic continuation. The Lerch transcendent is thus\n56     branched at :math:`z \\in \\{0, 1, \\infty\\}` and\n57     :math:`a \\in \\mathbb{Z}_{\\le 0}`. For fixed :math:`z, a` outside these\n58     branch points, it is an entire function of :math:`s`.\n59 \n60     See Also\n61     ========\n62 \n63     polylog, zeta\n64 \n65     References\n66     ==========\n67 \n68     .. [1] Bateman, H.; Erdelyi, A. (1953), Higher Transcendental Functions,\n69            Vol. I, New York: McGraw-Hill. Section 1.11.\n70     .. [2] http://dlmf.nist.gov/25.14\n71     .. [3] http://en.wikipedia.org/wiki/Lerch_transcendent\n72 \n73     Examples\n74     ========\n75 \n76     The Lerch transcendent is a fairly general function, for this reason it does\n77     not automatically evaluate to simpler functions. Use expand_func() to\n78     achieve this.\n79 \n80     If :math:`z=1`, the Lerch transcendent reduces to the Hurwitz zeta function:\n81 \n82     >>> from sympy import lerchphi, expand_func\n83     >>> from sympy.abc import z, s, a\n84     >>> expand_func(lerchphi(1, s, a))\n85     zeta(s, a)\n86 \n87     More generally, if :math:`z` is a root of unity, the Lerch transcendent\n88     reduces to a sum of Hurwitz zeta functions:\n89 \n90     >>> expand_func(lerchphi(-1, s, a))\n91     2**(-s)*zeta(s, a/2) - 2**(-s)*zeta(s, a/2 + 1/2)\n92 \n93     If :math:`a=1`, the Lerch transcendent reduces to the polylogarithm:\n94 \n95     >>> expand_func(lerchphi(z, s, 1))\n96     polylog(s, z)/z\n97 \n98     More generally, if :math:`a` is rational, the Lerch transcendent reduces\n99     to a sum of polylogarithms:\n100 \n101     >>> from sympy import S\n102     >>> expand_func(lerchphi(z, s, S(1)/2))\n103     2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -\n104                 polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))\n105     >>> expand_func(lerchphi(z, s, S(3)/2))\n106     -2**s/z + 2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -\n107                           polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))/z\n108 \n109     The derivatives with respect to :math:`z` and :math:`a` can be computed in\n110     closed form:\n111 \n112     >>> lerchphi(z, s, a).diff(z)\n113     (-a*lerchphi(z, s, a) + lerchphi(z, s - 1, a))/z\n114     >>> lerchphi(z, s, a).diff(a)\n115     -s*lerchphi(z, s + 1, a)\n116     \"\"\"\n117 \n118     def _eval_expand_func(self, **hints):\n119         from sympy import exp, I, floor, Add, Poly, Dummy, exp_polar, unpolarify\n120         z, s, a = self.args\n121         if z == 1:\n122             return zeta(s, a)\n123         if s.is_Integer and s <= 0:\n124             t = Dummy('t')\n125             p = Poly((t + a)**(-s), t)\n126             start = 1/(1 - t)\n127             res = S(0)\n128             for c in reversed(p.all_coeffs()):\n129                 res += c*start\n130                 start = t*start.diff(t)\n131             return res.subs(t, z)\n132 \n133         if a.is_Rational:\n134             # See section 18 of\n135             #   Kelly B. Roach.  Hypergeometric Function Representations.\n136             #   In: Proceedings of the 1997 International Symposium on Symbolic and\n137             #   Algebraic Computation, pages 205-211, New York, 1997. ACM.\n138             # TODO should something be polarified here?\n139             add = S(0)\n140             mul = S(1)\n141             # First reduce a to the interaval (0, 1]\n142             if a > 1:\n143                 n = floor(a)\n144                 if n == a:\n145                     n -= 1\n146                 a -= n\n147                 mul = z**(-n)\n148                 add = Add(*[-z**(k - n)/(a + k)**s for k in range(n)])\n149             elif a <= 0:\n150                 n = floor(-a) + 1\n151                 a += n\n152                 mul = z**n\n153                 add = Add(*[z**(n - 1 - k)/(a - k - 1)**s for k in range(n)])\n154 \n155             m, n = S([a.p, a.q])\n156             zet = exp_polar(2*pi*I/n)\n157             root = z**(1/n)\n158             return add + mul*n**(s - 1)*Add(\n159                 *[polylog(s, zet**k*root)._eval_expand_func(**hints)\n160                   / (unpolarify(zet)**k*root)**m for k in range(n)])\n161 \n162         # TODO use minpoly instead of ad-hoc methods when issue 5888 is fixed\n163         if isinstance(z, exp) and (z.args[0]/(pi*I)).is_Rational or z in [-1, I, -I]:\n164             # TODO reference?\n165             if z == -1:\n166                 p, q = S([1, 2])\n167             elif z == I:\n168                 p, q = S([1, 4])\n169             elif z == -I:\n170                 p, q = S([-1, 4])\n171             else:\n172                 arg = z.args[0]/(2*pi*I)\n173                 p, q = S([arg.p, arg.q])\n174             return Add(*[exp(2*pi*I*k*p/q)/q**s*zeta(s, (k + a)/q)\n175                          for k in range(q)])\n176 \n177         return lerchphi(z, s, a)\n178 \n179     def fdiff(self, argindex=1):\n180         z, s, a = self.args\n181         if argindex == 3:\n182             return -s*lerchphi(z, s + 1, a)\n183         elif argindex == 1:\n184             return (lerchphi(z, s - 1, a) - a*lerchphi(z, s, a))/z\n185         else:\n186             raise ArgumentIndexError\n187 \n188     def _eval_rewrite_helper(self, z, s, a, target):\n189         res = self._eval_expand_func()\n190         if res.has(target):\n191             return res\n192         else:\n193             return self\n194 \n195     def _eval_rewrite_as_zeta(self, z, s, a):\n196         return self._eval_rewrite_helper(z, s, a, zeta)\n197 \n198     def _eval_rewrite_as_polylog(self, z, s, a):\n199         return self._eval_rewrite_helper(z, s, a, polylog)\n200 \n201 ###############################################################################\n202 ###################### POLYLOGARITHM ##########################################\n203 ###############################################################################\n204 \n205 \n206 class polylog(Function):\n207     r\"\"\"\n208     Polylogarithm function.\n209 \n210     For :math:`|z| < 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n211     defined by\n212 \n213     .. math:: \\operatorname{Li}_s(z) = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n214 \n215     where the standard branch of the argument is used for :math:`n`. It admits\n216     an analytic continuation which is branched at :math:`z=1` (notably not on the\n217     sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n218 \n219     The name polylogarithm comes from the fact that for :math:`s=1`, the\n220     polylogarithm is related to the ordinary logarithm (see examples), and that\n221 \n222     .. math:: \\operatorname{Li}_{s+1}(z) =\n223                     \\int_0^z \\frac{\\operatorname{Li}_s(t)}{t} \\mathrm{d}t.\n224 \n225     The polylogarithm is a special case of the Lerch transcendent:\n226 \n227     .. math:: \\operatorname{Li}_{s}(z) = z \\Phi(z, s, 1)\n228 \n229     See Also\n230     ========\n231 \n232     zeta, lerchphi\n233 \n234     Examples\n235     ========\n236 \n237     For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n238     using other functions:\n239 \n240     >>> from sympy import polylog\n241     >>> from sympy.abc import s\n242     >>> polylog(s, 0)\n243     0\n244     >>> polylog(s, 1)\n245     zeta(s)\n246     >>> polylog(s, -1)\n247     -dirichlet_eta(s)\n248 \n249     If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n250     polylogarithm can be expressed using elementary functions. This can be\n251     done using expand_func():\n252 \n253     >>> from sympy import expand_func\n254     >>> from sympy.abc import z\n255     >>> expand_func(polylog(1, z))\n256     -log(z*exp_polar(-I*pi) + 1)\n257     >>> expand_func(polylog(0, z))\n258     z/(-z + 1)\n259 \n260     The derivative with respect to :math:`z` can be computed in closed form:\n261 \n262     >>> polylog(s, z).diff(z)\n263     polylog(s - 1, z)/z\n264 \n265     The polylogarithm can be expressed in terms of the lerch transcendent:\n266 \n267     >>> from sympy import lerchphi\n268     >>> polylog(s, z).rewrite(lerchphi)\n269     z*lerchphi(z, s, 1)\n270     \"\"\"\n271 \n272     @classmethod\n273     def eval(cls, s, z):\n274         if z == 1:\n275             return zeta(s)\n276         elif z == -1:\n277             return -dirichlet_eta(s)\n278         elif z == 0:\n279             return 0\n280 \n281     def fdiff(self, argindex=1):\n282         s, z = self.args\n283         if argindex == 2:\n284             return polylog(s - 1, z)/z\n285         raise ArgumentIndexError\n286 \n287     def _eval_rewrite_as_lerchphi(self, s, z):\n288         return z*lerchphi(z, s, 1)\n289 \n290     def _eval_expand_func(self, **hints):\n291         from sympy import log, expand_mul, Dummy, exp_polar, I\n292         s, z = self.args\n293         if s == 1:\n294             return -log(1 + exp_polar(-I*pi)*z)\n295         if s.is_Integer and s <= 0:\n296             u = Dummy('u')\n297             start = u/(1 - u)\n298             for _ in range(-s):\n299                 start = u*start.diff(u)\n300             return expand_mul(start).subs(u, z)\n301         return polylog(s, z)\n302 \n303 ###############################################################################\n304 ###################### HURWITZ GENERALIZED ZETA FUNCTION ######################\n305 ###############################################################################\n306 \n307 \n308 class zeta(Function):\n309     r\"\"\"\n310     Hurwitz zeta function (or Riemann zeta function).\n311 \n312     For `\\operatorname{Re}(a) > 0` and `\\operatorname{Re}(s) > 1`, this function is defined as\n313 \n314     .. math:: \\zeta(s, a) = \\sum_{n=0}^\\infty \\frac{1}{(n + a)^s},\n315 \n316     where the standard choice of argument for :math:`n + a` is used. For fixed\n317     :math:`a` with `\\operatorname{Re}(a) > 0` the Hurwitz zeta function admits a\n318     meromorphic continuation to all of :math:`\\mathbb{C}`, it is an unbranched\n319     function with a simple pole at :math:`s = 1`.\n320 \n321     Analytic continuation to other :math:`a` is possible under some circumstances,\n322     but this is not typically done.\n323 \n324     The Hurwitz zeta function is a special case of the Lerch transcendent:\n325 \n326     .. math:: \\zeta(s, a) = \\Phi(1, s, a).\n327 \n328     This formula defines an analytic continuation for all possible values of\n329     :math:`s` and :math:`a` (also `\\operatorname{Re}(a) < 0`), see the documentation of\n330     :class:`lerchphi` for a description of the branching behavior.\n331 \n332     If no value is passed for :math:`a`, by this function assumes a default value\n333     of :math:`a = 1`, yielding the Riemann zeta function.\n334 \n335     See Also\n336     ========\n337 \n338     dirichlet_eta, lerchphi, polylog\n339 \n340     References\n341     ==========\n342 \n343     .. [1] http://dlmf.nist.gov/25.11\n344     .. [2] http://en.wikipedia.org/wiki/Hurwitz_zeta_function\n345 \n346     Examples\n347     ========\n348 \n349     For :math:`a = 1` the Hurwitz zeta function reduces to the famous Riemann\n350     zeta function:\n351 \n352     .. math:: \\zeta(s, 1) = \\zeta(s) = \\sum_{n=1}^\\infty \\frac{1}{n^s}.\n353 \n354     >>> from sympy import zeta\n355     >>> from sympy.abc import s\n356     >>> zeta(s, 1)\n357     zeta(s)\n358     >>> zeta(s)\n359     zeta(s)\n360 \n361     The Riemann zeta function can also be expressed using the Dirichlet eta\n362     function:\n363 \n364     >>> from sympy import dirichlet_eta\n365     >>> zeta(s).rewrite(dirichlet_eta)\n366     dirichlet_eta(s)/(-2**(-s + 1) + 1)\n367 \n368     The Riemann zeta function at positive even integer and negative odd integer\n369     values is related to the Bernoulli numbers:\n370 \n371     >>> zeta(2)\n372     pi**2/6\n373     >>> zeta(4)\n374     pi**4/90\n375     >>> zeta(-1)\n376     -1/12\n377 \n378     The specific formulae are:\n379 \n380     .. math:: \\zeta(2n) = (-1)^{n+1} \\frac{B_{2n} (2\\pi)^{2n}}{2(2n)!}\n381     .. math:: \\zeta(-n) = -\\frac{B_{n+1}}{n+1}\n382 \n383     At negative even integers the Riemann zeta function is zero:\n384 \n385     >>> zeta(-4)\n386     0\n387 \n388     No closed-form expressions are known at positive odd integers, but\n389     numerical evaluation is possible:\n390 \n391     >>> zeta(3).n()\n392     1.20205690315959\n393 \n394     The derivative of :math:`\\zeta(s, a)` with respect to :math:`a` is easily\n395     computed:\n396 \n397     >>> from sympy.abc import a\n398     >>> zeta(s, a).diff(a)\n399     -s*zeta(s + 1, a)\n400 \n401     However the derivative with respect to :math:`s` has no useful closed form\n402     expression:\n403 \n404     >>> zeta(s, a).diff(s)\n405     Derivative(zeta(s, a), s)\n406 \n407     The Hurwitz zeta function can be expressed in terms of the Lerch transcendent,\n408     :class:`sympy.functions.special.lerchphi`:\n409 \n410     >>> from sympy import lerchphi\n411     >>> zeta(s, a).rewrite(lerchphi)\n412     lerchphi(1, s, a)\n413 \n414     \"\"\"\n415 \n416     @classmethod\n417     def eval(cls, z, a_=None):\n418         if a_ is None:\n419             z, a = list(map(sympify, (z, 1)))\n420         else:\n421             z, a = list(map(sympify, (z, a_)))\n422 \n423         if a.is_Number:\n424             if a is S.NaN:\n425                 return S.NaN\n426             elif a is S.One and a_ is not None:\n427                 return cls(z)\n428             # TODO Should a == 0 return S.NaN as well?\n429 \n430         if z.is_Number:\n431             if z is S.NaN:\n432                 return S.NaN\n433             elif z is S.Infinity:\n434                 return S.One\n435             elif z is S.Zero:\n436                 return S.Half - a\n437             elif z is S.One:\n438                 return S.ComplexInfinity\n439             elif z.is_Integer:\n440                 if a.is_Integer:\n441                     if z.is_negative:\n442                         zeta = (-1)**z * bernoulli(-z + 1)/(-z + 1)\n443                     elif z.is_even:\n444                         B, F = bernoulli(z), factorial(z)\n445                         zeta = 2**(z - 1) * abs(B) * pi**z / F\n446                     else:\n447                         return\n448 \n449                     if a.is_negative:\n450                         return zeta + harmonic(abs(a), z)\n451                     else:\n452                         return zeta - harmonic(a - 1, z)\n453 \n454     def _eval_rewrite_as_dirichlet_eta(self, s, a=1):\n455         if a != 1:\n456             return self\n457         s = self.args[0]\n458         return dirichlet_eta(s)/(1 - 2**(1 - s))\n459 \n460     def _eval_rewrite_as_lerchphi(self, s, a=1):\n461         return lerchphi(1, s, a)\n462 \n463     def _eval_is_finite(self):\n464         arg_is_one = (self.args[0] - 1).is_zero\n465         if arg_is_one is not None:\n466             return not arg_is_one\n467 \n468     def fdiff(self, argindex=1):\n469         if len(self.args) == 2:\n470             s, a = self.args\n471         else:\n472             s, a = self.args + (1,)\n473         if argindex == 2:\n474             return -s*zeta(s + 1, a)\n475         else:\n476             raise ArgumentIndexError\n477 \n478 \n479 class dirichlet_eta(Function):\n480     r\"\"\"\n481     Dirichlet eta function.\n482 \n483     For `\\operatorname{Re}(s) > 0`, this function is defined as\n484 \n485     .. math:: \\eta(s) = \\sum_{n=1}^\\infty \\frac{(-1)^n}{n^s}.\n486 \n487     It admits a unique analytic continuation to all of :math:`\\mathbb{C}`.\n488     It is an entire, unbranched function.\n489 \n490     See Also\n491     ========\n492 \n493     zeta\n494 \n495     References\n496     ==========\n497 \n498     .. [1] http://en.wikipedia.org/wiki/Dirichlet_eta_function\n499 \n500     Examples\n501     ========\n502 \n503     The Dirichlet eta function is closely related to the Riemann zeta function:\n504 \n505     >>> from sympy import dirichlet_eta, zeta\n506     >>> from sympy.abc import s\n507     >>> dirichlet_eta(s).rewrite(zeta)\n508     (-2**(-s + 1) + 1)*zeta(s)\n509 \n510     \"\"\"\n511 \n512     @classmethod\n513     def eval(cls, s):\n514         if s == 1:\n515             return log(2)\n516         z = zeta(s)\n517         if not z.has(zeta):\n518             return (1 - 2**(1 - s))*z\n519 \n520     def _eval_rewrite_as_zeta(self, s):\n521         return (1 - 2**(1 - s)) * zeta(s)\n522 \n523 \n524 class stieltjes(Function):\n525     r\"\"\"Represents Stieltjes constants, :math:`\\gamma_{k}` that occur in\n526     Laurent Series expansion of the Riemann zeta function.\n527 \n528     Examples\n529     ========\n530 \n531     >>> from sympy import stieltjes\n532     >>> from sympy.abc import n, m\n533     >>> stieltjes(n)\n534     stieltjes(n)\n535 \n536     zero'th stieltjes constant\n537 \n538     >>> stieltjes(0)\n539     EulerGamma\n540     >>> stieltjes(0, 1)\n541     EulerGamma\n542 \n543     For generalized stieltjes constants\n544 \n545     >>> stieltjes(n, m)\n546     stieltjes(n, m)\n547 \n548     Constants are only defined for integers >= 0\n549 \n550     >>> stieltjes(-1)\n551     zoo\n552 \n553     References\n554     ==========\n555 \n556     .. [1] http://en.wikipedia.org/wiki/Stieltjes_constants\n557     \"\"\"\n558 \n559     @classmethod\n560     def eval(cls, n, a=None):\n561         n = sympify(n)\n562 \n563         if a != None:\n564             a = sympify(a)\n565             if a is S.NaN:\n566                 return S.NaN\n567             if a.is_Integer and a.is_nonpositive:\n568                 return S.ComplexInfinity\n569 \n570         if n.is_Number:\n571             if n is S.NaN:\n572                 return S.NaN\n573             elif n < 0:\n574                 return S.ComplexInfinity\n575             elif not n.is_Integer:\n576                 return S.ComplexInfinity\n577             elif n == 0 and a in [None, 1]:\n578                 return S.EulerGamma\n",
        "intended_behavior": "Modifications or clarifications need to be made wherever `polylog` or manipulations involving `exp_polar(-I*pi)` are dealt with. Specifically, ensure that expansions or simplifications of `polylog` functions avoid unnecessary complexities or mathematically unsound transformations. The introduction of `exp_polar(-I*pi)` during simplification or expansion should be closely examined to ensure it is only applied when mathematically justified, faithfully reflecting the properties of `polylog` and related functions, particularly with respect to their branch cuts and continuity properties."
    },
    {
        "rel_file_path": "sympy/core/expr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/core/expr.py",
        "start": 1,
        "end": 3449,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from .sympify import sympify, _sympify, SympifyError\n4 from .basic import Basic, Atom\n5 from .singleton import S\n6 from .evalf import EvalfMixin, pure_complex\n7 from .decorators import _sympifyit, call_highest_priority\n8 from .cache import cacheit\n9 from .compatibility import reduce, as_int, default_sort_key, range\n10 from mpmath.libmp import mpf_log, prec_to_dps\n11 \n12 from collections import defaultdict\n13 \n14 class Expr(Basic, EvalfMixin):\n15     \"\"\"\n16     Base class for algebraic expressions.\n17 \n18     Everything that requires arithmetic operations to be defined\n19     should subclass this class, instead of Basic (which should be\n20     used only for argument storage and expression manipulation, i.e.\n21     pattern matching, substitutions, etc).\n22 \n23     See Also\n24     ========\n25 \n26     sympy.core.basic.Basic\n27     \"\"\"\n28 \n29     __slots__ = []\n30 \n31     @property\n32     def _diff_wrt(self):\n33         \"\"\"Is it allowed to take derivative wrt to this instance.\n34 \n35         This determines if it is allowed to take derivatives wrt this object.\n36         Subclasses such as Symbol, Function and Derivative should return True\n37         to enable derivatives wrt them. The implementation in Derivative\n38         separates the Symbol and non-Symbol _diff_wrt=True variables and\n39         temporarily converts the non-Symbol vars in Symbols when performing\n40         the differentiation.\n41 \n42         Note, see the docstring of Derivative for how this should work\n43         mathematically. In particular, note that expr.subs(yourclass, Symbol)\n44         should be well-defined on a structural level, or this will lead to\n45         inconsistent results.\n46 \n47         Examples\n48         ========\n49 \n50         >>> from sympy import Expr\n51         >>> e = Expr()\n52         >>> e._diff_wrt\n53         False\n54         >>> class MyClass(Expr):\n55         ...     _diff_wrt = True\n56         ...\n57         >>> (2*MyClass()).diff(MyClass())\n58         2\n59         \"\"\"\n60         return False\n61 \n62     @cacheit\n63     def sort_key(self, order=None):\n64 \n65         coeff, expr = self.as_coeff_Mul()\n66 \n67         if expr.is_Pow:\n68             expr, exp = expr.args\n69         else:\n70             expr, exp = expr, S.One\n71 \n72         if expr.is_Dummy:\n73             args = (expr.sort_key(),)\n74         elif expr.is_Atom:\n75             args = (str(expr),)\n76         else:\n77             if expr.is_Add:\n78                 args = expr.as_ordered_terms(order=order)\n79             elif expr.is_Mul:\n80                 args = expr.as_ordered_factors(order=order)\n81             else:\n82                 args = expr.args\n83 \n84             args = tuple(\n85                 [ default_sort_key(arg, order=order) for arg in args ])\n86 \n87         args = (len(args), tuple(args))\n88         exp = exp.sort_key(order=order)\n89 \n90         return expr.class_key(), args, exp, coeff\n91 \n92     # ***************\n93     # * Arithmetics *\n94     # ***************\n95     # Expr and its sublcasses use _op_priority to determine which object\n96     # passed to a binary special method (__mul__, etc.) will handle the\n97     # operation. In general, the 'call_highest_priority' decorator will choose\n98     # the object with the highest _op_priority to handle the call.\n99     # Custom subclasses that want to define their own binary special methods\n100     # should set an _op_priority value that is higher than the default.\n101     #\n102     # **NOTE**:\n103     # This is a temporary fix, and will eventually be replaced with\n104     # something better and more powerful.  See issue 5510.\n105     _op_priority = 10.0\n106 \n107     def __pos__(self):\n108         return self\n109 \n110     def __neg__(self):\n111         return Mul(S.NegativeOne, self)\n112 \n113     def __abs__(self):\n114         from sympy import Abs\n115         return Abs(self)\n116 \n117     @_sympifyit('other', NotImplemented)\n118     @call_highest_priority('__radd__')\n119     def __add__(self, other):\n120         return Add(self, other)\n121 \n122     @_sympifyit('other', NotImplemented)\n123     @call_highest_priority('__add__')\n124     def __radd__(self, other):\n125         return Add(other, self)\n126 \n127     @_sympifyit('other', NotImplemented)\n128     @call_highest_priority('__rsub__')\n129     def __sub__(self, other):\n130         return Add(self, -other)\n131 \n132     @_sympifyit('other', NotImplemented)\n133     @call_highest_priority('__sub__')\n134     def __rsub__(self, other):\n135         return Add(other, -self)\n136 \n137     @_sympifyit('other', NotImplemented)\n138     @call_highest_priority('__rmul__')\n139     def __mul__(self, other):\n140         return Mul(self, other)\n141 \n142     @_sympifyit('other', NotImplemented)\n143     @call_highest_priority('__mul__')\n144     def __rmul__(self, other):\n145         return Mul(other, self)\n146 \n147     @_sympifyit('other', NotImplemented)\n148     @call_highest_priority('__rpow__')\n149     def _pow(self, other):\n150         return Pow(self, other)\n151 \n152     def __pow__(self, other, mod=None):\n153         if mod is None:\n154             return self._pow(other)\n155         try:\n156             _self, other, mod = as_int(self), as_int(other), as_int(mod)\n157             if other >= 0:\n158                 return pow(_self, other, mod)\n159             else:\n160                 from sympy.core.numbers import mod_inverse\n161                 return mod_inverse(pow(_self, -other, mod), mod)\n162         except ValueError:\n163             power = self._pow(other)\n164             try:\n165                 return power%mod\n166             except TypeError:\n167                 return NotImplemented\n168 \n169     @_sympifyit('other', NotImplemented)\n170     @call_highest_priority('__pow__')\n171     def __rpow__(self, other):\n172         return Pow(other, self)\n173 \n174     @_sympifyit('other', NotImplemented)\n175     @call_highest_priority('__rdiv__')\n176     def __div__(self, other):\n177         return Mul(self, Pow(other, S.NegativeOne))\n178 \n179     @_sympifyit('other', NotImplemented)\n180     @call_highest_priority('__div__')\n181     def __rdiv__(self, other):\n182         return Mul(other, Pow(self, S.NegativeOne))\n183 \n184     __truediv__ = __div__\n185     __rtruediv__ = __rdiv__\n186 \n187     @_sympifyit('other', NotImplemented)\n188     @call_highest_priority('__rmod__')\n189     def __mod__(self, other):\n190         return Mod(self, other)\n191 \n192     @_sympifyit('other', NotImplemented)\n193     @call_highest_priority('__mod__')\n194     def __rmod__(self, other):\n195         return Mod(other, self)\n196 \n197     @_sympifyit('other', NotImplemented)\n198     @call_highest_priority('__rfloordiv__')\n199     def __floordiv__(self, other):\n200         from sympy.functions.elementary.integers import floor\n201         return floor(self / other)\n202 \n203     @_sympifyit('other', NotImplemented)\n204     @call_highest_priority('__floordiv__')\n205     def __rfloordiv__(self, other):\n206         from sympy.functions.elementary.integers import floor\n207         return floor(other / self)\n208 \n209     def __int__(self):\n210         # Although we only need to round to the units position, we'll\n211         # get one more digit so the extra testing below can be avoided\n212         # unless the rounded value rounded to an integer, e.g. if an\n213         # expression were equal to 1.9 and we rounded to the unit position\n214         # we would get a 2 and would not know if this rounded up or not\n215         # without doing a test (as done below). But if we keep an extra\n216         # digit we know that 1.9 is not the same as 1 and there is no\n217         # need for further testing: our int value is correct. If the value\n218         # were 1.99, however, this would round to 2.0 and our int value is\n219         # off by one. So...if our round value is the same as the int value\n220         # (regardless of how much extra work we do to calculate extra decimal\n221         # places) we need to test whether we are off by one.\n222         from sympy import Dummy\n223         if not self.is_number:\n224             raise TypeError(\"can't convert symbols to int\")\n225         r = self.round(2)\n226         if not r.is_Number:\n227             raise TypeError(\"can't convert complex to int\")\n228         if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n229             raise TypeError(\"can't convert %s to int\" % r)\n230         i = int(r)\n231         if not i:\n232             return 0\n233         # off-by-one check\n234         if i == r and not (self - i).equals(0):\n235             isign = 1 if i > 0 else -1\n236             x = Dummy()\n237             # in the following (self - i).evalf(2) will not always work while\n238             # (self - r).evalf(2) and the use of subs does; if the test that\n239             # was added when this comment was added passes, it might be safe\n240             # to simply use sign to compute this rather than doing this by hand:\n241             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1\n242             if diff_sign != isign:\n243                 i -= isign\n244         return i\n245     __long__ = __int__\n246 \n247     def __float__(self):\n248         # Don't bother testing if it's a number; if it's not this is going\n249         # to fail, and if it is we still need to check that it evalf'ed to\n250         # a number.\n251         result = self.evalf()\n252         if result.is_Number:\n253             return float(result)\n254         if result.is_number and result.as_real_imag()[1]:\n255             raise TypeError(\"can't convert complex to float\")\n256         raise TypeError(\"can't convert expression to float\")\n257 \n258     def __complex__(self):\n259         result = self.evalf()\n260         re, im = result.as_real_imag()\n261         return complex(float(re), float(im))\n262 \n263     def __ge__(self, other):\n264         from sympy import GreaterThan\n265         try:\n266             other = _sympify(other)\n267         except SympifyError:\n268             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n269         for me in (self, other):\n270             if me.is_complex and me.is_real is False:\n271                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n272             if me is S.NaN:\n273                 raise TypeError(\"Invalid NaN comparison\")\n274         n2 = _n2(self, other)\n275         if n2 is not None:\n276             return _sympify(n2 >= 0)\n277         if self.is_real or other.is_real:\n278             dif = self - other\n279             if dif.is_nonnegative is not None and \\\n280                     dif.is_nonnegative is not dif.is_negative:\n281                 return sympify(dif.is_nonnegative)\n282         return GreaterThan(self, other, evaluate=False)\n283 \n284     def __le__(self, other):\n285         from sympy import LessThan\n286         try:\n287             other = _sympify(other)\n288         except SympifyError:\n289             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n290         for me in (self, other):\n291             if me.is_complex and me.is_real is False:\n292                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n293             if me is S.NaN:\n294                 raise TypeError(\"Invalid NaN comparison\")\n295         n2 = _n2(self, other)\n296         if n2 is not None:\n297             return _sympify(n2 <= 0)\n298         if self.is_real or other.is_real:\n299             dif = self - other\n300             if dif.is_nonpositive is not None and \\\n301                     dif.is_nonpositive is not dif.is_positive:\n302                 return sympify(dif.is_nonpositive)\n303         return LessThan(self, other, evaluate=False)\n304 \n305     def __gt__(self, other):\n306         from sympy import StrictGreaterThan\n307         try:\n308             other = _sympify(other)\n309         except SympifyError:\n310             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n311         for me in (self, other):\n312             if me.is_complex and me.is_real is False:\n313                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n314             if me is S.NaN:\n315                 raise TypeError(\"Invalid NaN comparison\")\n316         n2 = _n2(self, other)\n317         if n2 is not None:\n318             return _sympify(n2 > 0)\n319         if self.is_real or other.is_real:\n320             dif = self - other\n321             if dif.is_positive is not None and \\\n322                     dif.is_positive is not dif.is_nonpositive:\n323                 return sympify(dif.is_positive)\n324         return StrictGreaterThan(self, other, evaluate=False)\n325 \n326     def __lt__(self, other):\n327         from sympy import StrictLessThan\n328         try:\n329             other = _sympify(other)\n330         except SympifyError:\n331             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n332         for me in (self, other):\n333             if me.is_complex and me.is_real is False:\n334                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n335             if me is S.NaN:\n336                 raise TypeError(\"Invalid NaN comparison\")\n337         n2 = _n2(self, other)\n338         if n2 is not None:\n339             return _sympify(n2 < 0)\n340         if self.is_real or other.is_real:\n341             dif = self - other\n342             if dif.is_negative is not None and \\\n343                     dif.is_negative is not dif.is_nonnegative:\n344                 return sympify(dif.is_negative)\n345         return StrictLessThan(self, other, evaluate=False)\n346 \n347     @staticmethod\n348     def _from_mpmath(x, prec):\n349         from sympy import Float\n350         if hasattr(x, \"_mpf_\"):\n351             return Float._new(x._mpf_, prec)\n352         elif hasattr(x, \"_mpc_\"):\n353             re, im = x._mpc_\n354             re = Float._new(re, prec)\n355             im = Float._new(im, prec)*S.ImaginaryUnit\n356             return re + im\n357         else:\n358             raise TypeError(\"expected mpmath number (mpf or mpc)\")\n359 \n360     @property\n361     def is_number(self):\n362         \"\"\"Returns True if ``self`` has no free symbols and no\n363         undefined functions (AppliedUndef, to be precise). It will be\n364         faster than ``if not self.free_symbols``, however, since\n365         ``is_number`` will fail as soon as it hits a free symbol\n366         or undefined function.\n367 \n368         Examples\n369         ========\n370 \n371         >>> from sympy import log, Integral, cos, sin, pi\n372         >>> from sympy.core.function import Function\n373         >>> from sympy.abc import x\n374         >>> f = Function('f')\n375 \n376         >>> x.is_number\n377         False\n378         >>> f(1).is_number\n379         False\n380         >>> (2*x).is_number\n381         False\n382         >>> (2 + Integral(2, x)).is_number\n383         False\n384         >>> (2 + Integral(2, (x, 1, 2))).is_number\n385         True\n386 \n387         Not all numbers are Numbers in the SymPy sense:\n388 \n389         >>> pi.is_number, pi.is_Number\n390         (True, False)\n391 \n392         If something is a number it should evaluate to a number with\n393         real and imaginary parts that are Numbers; the result may not\n394         be comparable, however, since the real and/or imaginary part\n395         of the result may not have precision.\n396 \n397         >>> cos(1).is_number and cos(1).is_comparable\n398         True\n399 \n400         >>> z = cos(1)**2 + sin(1)**2 - 1\n401         >>> z.is_number\n402         True\n403         >>> z.is_comparable\n404         False\n405 \n406         See Also\n407         ========\n408         sympy.core.basic.is_comparable\n409         \"\"\"\n410         return all(obj.is_number for obj in self.args)\n411 \n412     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):\n413         \"\"\"Return self evaluated, if possible, replacing free symbols with\n414         random complex values, if necessary.\n415 \n416         The random complex value for each free symbol is generated\n417         by the random_complex_number routine giving real and imaginary\n418         parts in the range given by the re_min, re_max, im_min, and im_max\n419         values. The returned value is evaluated to a precision of n\n420         (if given) else the maximum of 15 and the precision needed\n421         to get more than 1 digit of precision. If the expression\n422         could not be evaluated to a number, or could not be evaluated\n423         to more than 1 digit of precision, then None is returned.\n424 \n425         Examples\n426         ========\n427 \n428         >>> from sympy import sqrt\n429         >>> from sympy.abc import x, y\n430         >>> x._random()                         # doctest: +SKIP\n431         0.0392918155679172 + 0.916050214307199*I\n432         >>> x._random(2)                        # doctest: +SKIP\n433         -0.77 - 0.87*I\n434         >>> (x + y/2)._random(2)                # doctest: +SKIP\n435         -0.57 + 0.16*I\n436         >>> sqrt(2)._random(2)\n437         1.4\n438 \n439         See Also\n440         ========\n441 \n442         sympy.utilities.randtest.random_complex_number\n443         \"\"\"\n444 \n445         free = self.free_symbols\n446         prec = 1\n447         if free:\n448             from sympy.utilities.randtest import random_complex_number\n449             a, c, b, d = re_min, re_max, im_min, im_max\n450             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)\n451                            for zi in free])))\n452             try:\n453                 nmag = abs(self.evalf(2, subs=reps))\n454             except (ValueError, TypeError):\n455                 # if an out of range value resulted in evalf problems\n456                 # then return None -- XXX is there a way to know how to\n457                 # select a good random number for a given expression?\n458                 # e.g. when calculating n! negative values for n should not\n459                 # be used\n460                 return None\n461         else:\n462             reps = {}\n463             nmag = abs(self.evalf(2))\n464 \n465         if not hasattr(nmag, '_prec'):\n466             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True\n467             return None\n468 \n469         if nmag._prec == 1:\n470             # increase the precision up to the default maximum\n471             # precision to see if we can get any significance\n472 \n473             from mpmath.libmp.libintmath import giant_steps\n474             from sympy.core.evalf import DEFAULT_MAXPREC as target\n475 \n476             # evaluate\n477             for prec in giant_steps(2, target):\n478                 nmag = abs(self.evalf(prec, subs=reps))\n479                 if nmag._prec != 1:\n480                     break\n481 \n482         if nmag._prec != 1:\n483             if n is None:\n484                 n = max(prec, 15)\n485             return self.evalf(n, subs=reps)\n486 \n487         # never got any significance\n488         return None\n489 \n490     def is_constant(self, *wrt, **flags):\n491         \"\"\"Return True if self is constant, False if not, or None if\n492         the constancy could not be determined conclusively.\n493 \n494         If an expression has no free symbols then it is a constant. If\n495         there are free symbols it is possible that the expression is a\n496         constant, perhaps (but not necessarily) zero. To test such\n497         expressions, two strategies are tried:\n498 \n499         1) numerical evaluation at two random points. If two such evaluations\n500         give two different values and the values have a precision greater than\n501         1 then self is not constant. If the evaluations agree or could not be\n502         obtained with any precision, no decision is made. The numerical testing\n503         is done only if ``wrt`` is different than the free symbols.\n504 \n505         2) differentiation with respect to variables in 'wrt' (or all free\n506         symbols if omitted) to see if the expression is constant or not. This\n507         will not always lead to an expression that is zero even though an\n508         expression is constant (see added test in test_expr.py). If\n509         all derivatives are zero then self is constant with respect to the\n510         given symbols.\n511 \n512         If neither evaluation nor differentiation can prove the expression is\n513         constant, None is returned unless two numerical values happened to be\n514         the same and the flag ``failing_number`` is True -- in that case the\n515         numerical value will be returned.\n516 \n517         If flag simplify=False is passed, self will not be simplified;\n518         the default is True since self should be simplified before testing.\n519 \n520         Examples\n521         ========\n522 \n523         >>> from sympy import cos, sin, Sum, S, pi\n524         >>> from sympy.abc import a, n, x, y\n525         >>> x.is_constant()\n526         False\n527         >>> S(2).is_constant()\n528         True\n529         >>> Sum(x, (x, 1, 10)).is_constant()\n530         True\n531         >>> Sum(x, (x, 1, n)).is_constant()\n532         False\n533         >>> Sum(x, (x, 1, n)).is_constant(y)\n534         True\n535         >>> Sum(x, (x, 1, n)).is_constant(n)\n536         False\n537         >>> Sum(x, (x, 1, n)).is_constant(x)\n538         True\n539         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n540         >>> eq.is_constant()\n541         True\n542         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\n543         True\n544 \n545         >>> (0**x).is_constant()\n546         False\n547         >>> x.is_constant()\n548         False\n549         >>> (x**x).is_constant()\n550         False\n551         >>> one = cos(x)**2 + sin(x)**2\n552         >>> one.is_constant()\n553         True\n554         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\n555         True\n556         \"\"\"\n557 \n558         simplify = flags.get('simplify', True)\n559 \n560         if self.is_number:\n561             return True\n562         free = self.free_symbols\n563         if not free:\n564             return True  # assume f(1) is some constant\n565 \n566         # if we are only interested in some symbols and they are not in the\n567         # free symbols then this expression is constant wrt those symbols\n568         wrt = set(wrt)\n569         if wrt and not wrt & free:\n570             return True\n571         wrt = wrt or free\n572 \n573         # simplify unless this has already been done\n574         expr = self\n575         if simplify:\n576             expr = expr.simplify()\n577 \n578         # is_zero should be a quick assumptions check; it can be wrong for\n579         # numbers (see test_is_not_constant test), giving False when it\n580         # shouldn't, but hopefully it will never give True unless it is sure.\n581         if expr.is_zero:\n582             return True\n583 \n584         # try numerical evaluation to see if we get two different values\n585         failing_number = None\n586         if wrt == free:\n587             # try 0 (for a) and 1 (for b)\n588             try:\n589                 a = expr.subs(list(zip(free, [0]*len(free))),\n590                     simultaneous=True)\n591                 if a is S.NaN:\n592                     # evaluation may succeed when substitution fails\n593                     a = expr._random(None, 0, 0, 0, 0)\n594             except ZeroDivisionError:\n595                 a = None\n596             if a is not None and a is not S.NaN:\n597                 try:\n598                     b = expr.subs(list(zip(free, [1]*len(free))),\n599                         simultaneous=True)\n600                     if b is S.NaN:\n601                         # evaluation may succeed when substitution fails\n602                         b = expr._random(None, 1, 0, 1, 0)\n603                 except ZeroDivisionError:\n604                     b = None\n605                 if b is not None and b is not S.NaN and b.equals(a) is False:\n606                     return False\n607                 # try random real\n608                 b = expr._random(None, -1, 0, 1, 0)\n609                 if b is not None and b is not S.NaN and b.equals(a) is False:\n610                     return False\n611                 # try random complex\n612                 b = expr._random()\n613                 if b is not None and b is not S.NaN:\n614                     if b.equals(a) is False:\n615                         return False\n616                     failing_number = a if a.is_number else b\n617 \n618         # now we will test each wrt symbol (or all free symbols) to see if the\n619         # expression depends on them or not using differentiation. This is\n620         # not sufficient for all expressions, however, so we don't return\n621         # False if we get a derivative other than 0 with free symbols.\n622         for w in wrt:\n623             deriv = expr.diff(w)\n624             if simplify:\n625                 deriv = deriv.simplify()\n626             if deriv != 0:\n627                 if not (pure_complex(deriv, or_real=True)):\n628                     if flags.get('failing_number', False):\n629                         return failing_number\n630                     elif deriv.free_symbols:\n631                         # dead line provided _random returns None in such cases\n632                         return None\n633                 return False\n634         return True\n635 \n636     def equals(self, other, failing_expression=False):\n637         \"\"\"Return True if self == other, False if it doesn't, or None. If\n638         failing_expression is True then the expression which did not simplify\n639         to a 0 will be returned instead of None.\n640 \n641         If ``self`` is a Number (or complex number) that is not zero, then\n642         the result is False.\n643 \n644         If ``self`` is a number and has not evaluated to zero, evalf will be\n645         used to test whether the expression evaluates to zero. If it does so\n646         and the result has significance (i.e. the precision is either -1, for\n647         a Rational result, or is greater than 1) then the evalf value will be\n648         used to return True or False.\n649 \n650         \"\"\"\n651         from sympy.simplify.simplify import nsimplify, simplify\n652         from sympy.solvers.solveset import solveset\n653         from sympy.polys.polyerrors import NotAlgebraic\n654         from sympy.polys.numberfields import minimal_polynomial\n655 \n656         other = sympify(other)\n657         if self == other:\n658             return True\n659 \n660         # they aren't the same so see if we can make the difference 0;\n661         # don't worry about doing simplification steps one at a time\n662         # because if the expression ever goes to 0 then the subsequent\n663         # simplification steps that are done will be very fast.\n664         diff = factor_terms(simplify(self - other), radical=True)\n665 \n666         if not diff:\n667             return True\n668 \n669         if not diff.has(Add, Mod):\n670             # if there is no expanding to be done after simplifying\n671             # then this can't be a zero\n672             return False\n673 \n674         constant = diff.is_constant(simplify=False, failing_number=True)\n675 \n676         if constant is False:\n677             return False\n678 \n679         if constant is None and (diff.free_symbols or not diff.is_number):\n680             # e.g. unless the right simplification is done, a symbolic\n681             # zero is possible (see expression of issue 6829: without\n682             # simplification constant will be None).\n683             return\n684 \n685         if constant is True:\n686             ndiff = diff._random()\n687             if ndiff:\n688                 return False\n689 \n690         # sometimes we can use a simplified result to give a clue as to\n691         # what the expression should be; if the expression is *not* zero\n692         # then we should have been able to compute that and so now\n693         # we can just consider the cases where the approximation appears\n694         # to be zero -- we try to prove it via minimal_polynomial.\n695         if diff.is_number:\n696             approx = diff.nsimplify()\n697             if not approx:\n698                 # try to prove via self-consistency\n699                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n700                 # it seems to work better to try big ones first\n701                 surds.sort(key=lambda x: -x.args[0])\n702                 for s in surds:\n703                     try:\n704                         # simplify is False here -- this expression has already\n705                         # been identified as being hard to identify as zero;\n706                         # we will handle the checking ourselves using nsimplify\n707                         # to see if we are in the right ballpark or not and if so\n708                         # *then* the simplification will be attempted.\n709                         if s.is_Symbol:\n710                             sol = list(solveset(diff, s))\n711                         else:\n712                             sol = [s]\n713                         if sol:\n714                             if s in sol:\n715                                 return True\n716                             if s.is_real:\n717                                 if any(nsimplify(si, [s]) == s and simplify(si) == s\n718                                         for si in sol):\n719                                     return True\n720                     except NotImplementedError:\n721                         pass\n722 \n723                 # try to prove with minimal_polynomial but know when\n724                 # *not* to use this or else it can take a long time. e.g. issue 8354\n725                 if True:  # change True to condition that assures non-hang\n726                     try:\n727                         mp = minimal_polynomial(diff)\n728                         if mp.is_Symbol:\n729                             return True\n730                         return False\n731                     except (NotAlgebraic, NotImplementedError):\n732                         pass\n733 \n734         # diff has not simplified to zero; constant is either None, True\n735         # or the number with significance (prec != 1) that was randomly\n736         # calculated twice as the same value.\n737         if constant not in (True, None) and constant != 0:\n738             return False\n739 \n740         if failing_expression:\n741             return diff\n742         return None\n743 \n744     def _eval_is_positive(self):\n745         from sympy.polys.numberfields import minimal_polynomial\n746         from sympy.polys.polyerrors import NotAlgebraic\n747         if self.is_number:\n748             if self.is_real is False:\n749                 return False\n750             try:\n751                 # check to see that we can get a value\n752                 n2 = self._eval_evalf(2)\n753                 if n2 is None:\n754                     raise AttributeError\n755                 if n2._prec == 1:  # no significance\n756                     raise AttributeError\n757                 if n2 == S.NaN:\n758                     raise AttributeError\n759             except (AttributeError, ValueError):\n760                 return None\n761             n, i = self.evalf(2).as_real_imag()\n762             if not i.is_Number or not n.is_Number:\n763                 return False\n764             if n._prec != 1 and i._prec != 1:\n765                 return bool(not i and n > 0)\n766             elif n._prec == 1 and (not i or i._prec == 1) and \\\n767                     self.is_algebraic and not self.has(Function):\n768                 try:\n769                     if minimal_polynomial(self).is_Symbol:\n770                         return False\n771                 except (NotAlgebraic, NotImplementedError):\n772                     pass\n773 \n774     def _eval_is_negative(self):\n775         from sympy.polys.numberfields import minimal_polynomial\n776         from sympy.polys.polyerrors import NotAlgebraic\n777         if self.is_number:\n778             if self.is_real is False:\n779                 return False\n780             try:\n781                 # check to see that we can get a value\n782                 n2 = self._eval_evalf(2)\n783                 if n2 is None:\n784                     raise AttributeError\n785                 if n2._prec == 1:  # no significance\n786                     raise AttributeError\n787                 if n2 == S.NaN:\n788                     raise AttributeError\n789             except (AttributeError, ValueError):\n790                 return None\n791             n, i = self.evalf(2).as_real_imag()\n792             if not i.is_Number or not n.is_Number:\n793                 return False\n794             if n._prec != 1 and i._prec != 1:\n795                 return bool(not i and n < 0)\n796             elif n._prec == 1 and (not i or i._prec == 1) and \\\n797                     self.is_algebraic and not self.has(Function):\n798                 try:\n799                     if minimal_polynomial(self).is_Symbol:\n800                         return False\n801                 except (NotAlgebraic, NotImplementedError):\n802                     pass\n803 \n804     def _eval_interval(self, x, a, b):\n805         \"\"\"\n806         Returns evaluation over an interval.  For most functions this is:\n807 \n808         self.subs(x, b) - self.subs(x, a),\n809 \n810         possibly using limit() if NaN is returned from subs.\n811 \n812         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),\n813         respectively.\n814 \n815         \"\"\"\n816         from sympy.series import limit, Limit\n817         from sympy.solvers.solveset import solveset\n818         from sympy.sets.sets import Interval\n819 \n820         if (a is None and b is None):\n821             raise ValueError('Both interval ends cannot be None.')\n822 \n823         if a == b:\n824             return 0\n825 \n826         if a is None:\n827             A = 0\n828         else:\n829             A = self.subs(x, a)\n830             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n831                 if (a < b) != False:\n832                     A = limit(self, x, a,\"+\")\n833                 else:\n834                     A = limit(self, x, a,\"-\")\n835 \n836                 if A is S.NaN:\n837                     return A\n838                 if isinstance(A, Limit):\n839                     raise NotImplementedError(\"Could not compute limit\")\n840 \n841         if b is None:\n842             B = 0\n843         else:\n844             B = self.subs(x, b)\n845             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n846                 if (a < b) != False:\n847                     B = limit(self, x, b,\"-\")\n848                 else:\n849                     B = limit(self, x, b,\"+\")\n850 \n851                 if isinstance(B, Limit):\n852                     raise NotImplementedError(\"Could not compute limit\")\n853 \n854         if (a and b) is None:\n855             return B - A\n856 \n857         value = B - A\n858 \n859         if a.is_comparable and b.is_comparable:\n860             if a < b:\n861                 domain = Interval(a, b)\n862             else:\n863                 domain = Interval(b, a)\n864             singularities = list(solveset(self.cancel().as_numer_denom()[1], x, domain = domain))\n865             for s in singularities:\n866                 if a < s < b:\n867                     value += -limit(self, x, s, \"+\") + limit(self, x, s, \"-\")\n868                 elif b < s < a:\n869                     value += limit(self, x, s, \"+\") - limit(self, x, s, \"-\")\n870 \n871         return value\n872 \n873     def _eval_power(self, other):\n874         # subclass to compute self**other for cases when\n875         # other is not NaN, 0, or 1\n876         return None\n877 \n878     def _eval_conjugate(self):\n879         if self.is_real:\n880             return self\n881         elif self.is_imaginary:\n882             return -self\n883 \n884     def conjugate(self):\n885         from sympy.functions.elementary.complexes import conjugate as c\n886         return c(self)\n887 \n888     def _eval_transpose(self):\n889         from sympy.functions.elementary.complexes import conjugate\n890         if self.is_complex:\n891             return self\n892         elif self.is_hermitian:\n893             return conjugate(self)\n894         elif self.is_antihermitian:\n895             return -conjugate(self)\n896 \n897     def transpose(self):\n898         from sympy.functions.elementary.complexes import transpose\n899         return transpose(self)\n900 \n901     def _eval_adjoint(self):\n902         from sympy.functions.elementary.complexes import conjugate, transpose\n903         if self.is_hermitian:\n904             return self\n905         elif self.is_antihermitian:\n906             return -self\n907         obj = self._eval_conjugate()\n908         if obj is not None:\n909             return transpose(obj)\n910         obj = self._eval_transpose()\n911         if obj is not None:\n912             return conjugate(obj)\n913 \n914     def adjoint(self):\n915         from sympy.functions.elementary.complexes import adjoint\n916         return adjoint(self)\n917 \n918     @classmethod\n919     def _parse_order(cls, order):\n920         \"\"\"Parse and configure the ordering of terms. \"\"\"\n921         from sympy.polys.orderings import monomial_key\n922 \n923         try:\n924             reverse = order.startswith('rev-')\n925         except AttributeError:\n926             reverse = False\n927         else:\n928             if reverse:\n929                 order = order[4:]\n930 \n931         monom_key = monomial_key(order)\n932 \n933         def neg(monom):\n934             result = []\n935 \n936             for m in monom:\n937                 if isinstance(m, tuple):\n938                     result.append(neg(m))\n939                 else:\n940                     result.append(-m)\n941 \n942             return tuple(result)\n943 \n944         def key(term):\n945             _, ((re, im), monom, ncpart) = term\n946 \n947             monom = neg(monom_key(monom))\n948             ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n949             coeff = ((bool(im), im), (re, im))\n950 \n951             return monom, ncpart, coeff\n952 \n953         return key, reverse\n954 \n955     def as_ordered_factors(self, order=None):\n956         \"\"\"Return list of ordered factors (if Mul) else [self].\"\"\"\n957         return [self]\n958 \n959     def as_ordered_terms(self, order=None, data=False):\n960         \"\"\"\n961         Transform an expression to an ordered list of terms.\n962 \n963         Examples\n964         ========\n965 \n966         >>> from sympy import sin, cos\n967         >>> from sympy.abc import x\n968 \n969         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n970         [sin(x)**2*cos(x), sin(x)**2, 1]\n971 \n972         \"\"\"\n973         key, reverse = self._parse_order(order)\n974         terms, gens = self.as_terms()\n975 \n976         if not any(term.is_Order for term, _ in terms):\n977             ordered = sorted(terms, key=key, reverse=reverse)\n978         else:\n979             _terms, _order = [], []\n980 \n981             for term, repr in terms:\n982                 if not term.is_Order:\n983                     _terms.append((term, repr))\n984                 else:\n985                     _order.append((term, repr))\n986 \n987             ordered = sorted(_terms, key=key, reverse=True) \\\n988                 + sorted(_order, key=key, reverse=True)\n989 \n990         if data:\n991             return ordered, gens\n992         else:\n993             return [term for term, _ in ordered]\n994 \n995     def as_terms(self):\n996         \"\"\"Transform an expression to a list of terms. \"\"\"\n997         from .add import Add\n998         from .mul import Mul\n999         from .exprtools import decompose_power\n1000 \n1001         gens, terms = set([]), []\n1002 \n1003         for term in Add.make_args(self):\n1004             coeff, _term = term.as_coeff_Mul()\n1005 \n1006             coeff = complex(coeff)\n1007             cpart, ncpart = {}, []\n1008 \n1009             if _term is not S.One:\n1010                 for factor in Mul.make_args(_term):\n1011                     if factor.is_number:\n1012                         try:\n1013                             coeff *= complex(factor)\n1014                         except TypeError:\n1015                             pass\n1016                         else:\n1017                             continue\n1018 \n1019                     if factor.is_commutative:\n1020                         base, exp = decompose_power(factor)\n1021 \n1022                         cpart[base] = exp\n1023                         gens.add(base)\n1024                     else:\n1025                         ncpart.append(factor)\n1026 \n1027             coeff = coeff.real, coeff.imag\n1028             ncpart = tuple(ncpart)\n1029 \n1030             terms.append((term, (coeff, cpart, ncpart)))\n1031 \n1032         gens = sorted(gens, key=default_sort_key)\n1033 \n1034         k, indices = len(gens), {}\n1035 \n1036         for i, g in enumerate(gens):\n1037             indices[g] = i\n1038 \n1039         result = []\n1040 \n1041         for term, (coeff, cpart, ncpart) in terms:\n1042             monom = [0]*k\n1043 \n1044             for base, exp in cpart.items():\n1045                 monom[indices[base]] = exp\n1046 \n1047             result.append((term, (coeff, tuple(monom), ncpart)))\n1048 \n1049         return result, gens\n1050 \n1051     def removeO(self):\n1052         \"\"\"Removes the additive O(..) symbol if there is one\"\"\"\n1053         return self\n1054 \n1055     def getO(self):\n1056         \"\"\"Returns the additive O(..) symbol if there is one, else None.\"\"\"\n1057         return None\n1058 \n1059     def getn(self):\n1060         \"\"\"\n1061         Returns the order of the expression.\n1062 \n1063         The order is determined either from the O(...) term. If there\n1064         is no O(...) term, it returns None.\n1065 \n1066         Examples\n1067         ========\n1068 \n1069         >>> from sympy import O\n1070         >>> from sympy.abc import x\n1071         >>> (1 + x + O(x**2)).getn()\n1072         2\n1073         >>> (1 + x).getn()\n1074 \n1075         \"\"\"\n1076         from sympy import Dummy, Symbol\n1077         o = self.getO()\n1078         if o is None:\n1079             return None\n1080         elif o.is_Order:\n1081             o = o.expr\n1082             if o is S.One:\n1083                 return S.Zero\n1084             if o.is_Symbol:\n1085                 return S.One\n1086             if o.is_Pow:\n1087                 return o.args[1]\n1088             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n\n1089                 for oi in o.args:\n1090                     if oi.is_Symbol:\n1091                         return S.One\n1092                     if oi.is_Pow:\n1093                         syms = oi.atoms(Symbol)\n1094                         if len(syms) == 1:\n1095                             x = syms.pop()\n1096                             oi = oi.subs(x, Dummy('x', positive=True))\n1097                             if oi.base.is_Symbol and oi.exp.is_Rational:\n1098                                 return abs(oi.exp)\n1099 \n1100         raise NotImplementedError('not sure of order of %s' % o)\n1101 \n1102     def count_ops(self, visual=None):\n1103         \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n1104         from .function import count_ops\n1105         return count_ops(self, visual)\n1106 \n1107     def args_cnc(self, cset=False, warn=True, split_1=True):\n1108         \"\"\"Return [commutative factors, non-commutative factors] of self.\n1109 \n1110         self is treated as a Mul and the ordering of the factors is maintained.\n1111         If ``cset`` is True the commutative factors will be returned in a set.\n1112         If there were repeated factors (as may happen with an unevaluated Mul)\n1113         then an error will be raised unless it is explicitly suppressed by\n1114         setting ``warn`` to False.\n1115 \n1116         Note: -1 is always separated from a Number unless split_1 is False.\n1117 \n1118         >>> from sympy import symbols, oo\n1119         >>> A, B = symbols('A B', commutative=0)\n1120         >>> x, y = symbols('x y')\n1121         >>> (-2*x*y).args_cnc()\n1122         [[-1, 2, x, y], []]\n1123         >>> (-2.5*x).args_cnc()\n1124         [[-1, 2.5, x], []]\n1125         >>> (-2*x*A*B*y).args_cnc()\n1126         [[-1, 2, x, y], [A, B]]\n1127         >>> (-2*x*A*B*y).args_cnc(split_1=False)\n1128         [[-2, x, y], [A, B]]\n1129         >>> (-2*x*y).args_cnc(cset=True)\n1130         [{-1, 2, x, y}, []]\n1131 \n1132         The arg is always treated as a Mul:\n1133 \n1134         >>> (-2 + x + A).args_cnc()\n1135         [[], [x - 2 + A]]\n1136         >>> (-oo).args_cnc() # -oo is a singleton\n1137         [[-1, oo], []]\n1138         \"\"\"\n1139 \n1140         if self.is_Mul:\n1141             args = list(self.args)\n1142         else:\n1143             args = [self]\n1144         for i, mi in enumerate(args):\n1145             if not mi.is_commutative:\n1146                 c = args[:i]\n1147                 nc = args[i:]\n1148                 break\n1149         else:\n1150             c = args\n1151             nc = []\n1152 \n1153         if c and split_1 and (\n1154             c[0].is_Number and\n1155             c[0].is_negative and\n1156                 c[0] is not S.NegativeOne):\n1157             c[:1] = [S.NegativeOne, -c[0]]\n1158 \n1159         if cset:\n1160             clen = len(c)\n1161             c = set(c)\n1162             if clen and warn and len(c) != clen:\n1163                 raise ValueError('repeated commutative arguments: %s' %\n1164                                  [ci for ci in c if list(self.args).count(ci) > 1])\n1165         return [c, nc]\n1166 \n1167     def coeff(self, x, n=1, right=False):\n1168         \"\"\"\n1169         Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n1170         is zero then all terms independent of ``x`` will be returned.\n1171 \n1172         When ``x`` is noncommutative, the coefficient to the left (default) or\n1173         right of ``x`` can be returned. The keyword 'right' is ignored when\n1174         ``x`` is commutative.\n1175 \n1176         See Also\n1177         ========\n1178 \n1179         as_coefficient: separate the expression into a coefficient and factor\n1180         as_coeff_Add: separate the additive constant from an expression\n1181         as_coeff_Mul: separate the multiplicative constant from an expression\n1182         as_independent: separate x-dependent terms/factors from others\n1183         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1184         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1185 \n1186         Examples\n1187         ========\n1188 \n1189         >>> from sympy import symbols\n1190         >>> from sympy.abc import x, y, z\n1191 \n1192         You can select terms that have an explicit negative in front of them:\n1193 \n1194         >>> (-x + 2*y).coeff(-1)\n1195         x\n1196         >>> (x - 2*y).coeff(-1)\n1197         2*y\n1198 \n1199         You can select terms with no Rational coefficient:\n1200 \n1201         >>> (x + 2*y).coeff(1)\n1202         x\n1203         >>> (3 + 2*x + 4*x**2).coeff(1)\n1204         0\n1205 \n1206         You can select terms independent of x by making n=0; in this case\n1207         expr.as_independent(x)[0] is returned (and 0 will be returned instead\n1208         of None):\n1209 \n1210         >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n1211         3\n1212         >>> eq = ((x + 1)**3).expand() + 1\n1213         >>> eq\n1214         x**3 + 3*x**2 + 3*x + 2\n1215         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1216         [1, 3, 3, 2]\n1217         >>> eq -= 2\n1218         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1219         [1, 3, 3, 0]\n1220 \n1221         You can select terms that have a numerical term in front of them:\n1222 \n1223         >>> (-x - 2*y).coeff(2)\n1224         -y\n1225         >>> from sympy import sqrt\n1226         >>> (x + sqrt(2)*x).coeff(sqrt(2))\n1227         x\n1228 \n1229         The matching is exact:\n1230 \n1231         >>> (3 + 2*x + 4*x**2).coeff(x)\n1232         2\n1233         >>> (3 + 2*x + 4*x**2).coeff(x**2)\n1234         4\n1235         >>> (3 + 2*x + 4*x**2).coeff(x**3)\n1236         0\n1237         >>> (z*(x + y)**2).coeff((x + y)**2)\n1238         z\n1239         >>> (z*(x + y)**2).coeff(x + y)\n1240         0\n1241 \n1242         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n1243         from the following:\n1244 \n1245         >>> (x + z*(x + x*y)).coeff(x)\n1246         1\n1247 \n1248         If such factoring is desired, factor_terms can be used first:\n1249 \n1250         >>> from sympy import factor_terms\n1251         >>> factor_terms(x + z*(x + x*y)).coeff(x)\n1252         z*(y + 1) + 1\n1253 \n1254         >>> n, m, o = symbols('n m o', commutative=False)\n1255         >>> n.coeff(n)\n1256         1\n1257         >>> (3*n).coeff(n)\n1258         3\n1259         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n1260         1 + m\n1261         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n1262         m\n1263 \n1264         If there is more than one possible coefficient 0 is returned:\n1265 \n1266         >>> (n*m + m*n).coeff(n)\n1267         0\n1268 \n1269         If there is only one possible coefficient, it is returned:\n1270 \n1271         >>> (n*m + x*m*n).coeff(m*n)\n1272         x\n1273         >>> (n*m + x*m*n).coeff(m*n, right=1)\n1274         1\n1275 \n1276         \"\"\"\n1277         x = sympify(x)\n1278         if not isinstance(x, Basic):\n1279             return S.Zero\n1280 \n1281         n = as_int(n)\n1282 \n1283         if not x:\n1284             return S.Zero\n1285 \n1286         if x == self:\n1287             if n == 1:\n1288                 return S.One\n1289             return S.Zero\n1290 \n1291         if x is S.One:\n1292             co = [a for a in Add.make_args(self)\n1293                   if a.as_coeff_Mul()[0] is S.One]\n1294             if not co:\n1295                 return S.Zero\n1296             return Add(*co)\n1297 \n1298         if n == 0:\n1299             if x.is_Add and self.is_Add:\n1300                 c = self.coeff(x, right=right)\n1301                 if not c:\n1302                     return S.Zero\n1303                 if not right:\n1304                     return self - Add(*[a*x for a in Add.make_args(c)])\n1305                 return self - Add(*[x*a for a in Add.make_args(c)])\n1306             return self.as_independent(x, as_Add=True)[0]\n1307 \n1308         # continue with the full method, looking for this power of x:\n1309         x = x**n\n1310 \n1311         def incommon(l1, l2):\n1312             if not l1 or not l2:\n1313                 return []\n1314             n = min(len(l1), len(l2))\n1315             for i in range(n):\n1316                 if l1[i] != l2[i]:\n1317                     return l1[:i]\n1318             return l1[:]\n1319 \n1320         def find(l, sub, first=True):\n1321             \"\"\" Find where list sub appears in list l. When ``first`` is True\n1322             the first occurrence from the left is returned, else the last\n1323             occurrence is returned. Return None if sub is not in l.\n1324 \n1325             >> l = range(5)*2\n1326             >> find(l, [2, 3])\n1327             2\n1328             >> find(l, [2, 3], first=0)\n1329             7\n1330             >> find(l, [2, 4])\n1331             None\n1332 \n1333             \"\"\"\n1334             if not sub or not l or len(sub) > len(l):\n1335                 return None\n1336             n = len(sub)\n1337             if not first:\n1338                 l.reverse()\n1339                 sub.reverse()\n1340             for i in range(0, len(l) - n + 1):\n1341                 if all(l[i + j] == sub[j] for j in range(n)):\n1342                     break\n1343             else:\n1344                 i = None\n1345             if not first:\n1346                 l.reverse()\n1347                 sub.reverse()\n1348             if i is not None and not first:\n1349                 i = len(l) - (i + n)\n1350             return i\n1351 \n1352         co = []\n1353         args = Add.make_args(self)\n1354         self_c = self.is_commutative\n1355         x_c = x.is_commutative\n1356         if self_c and not x_c:\n1357             return S.Zero\n1358 \n1359         if self_c:\n1360             xargs = x.args_cnc(cset=True, warn=False)[0]\n1361             for a in args:\n1362                 margs = a.args_cnc(cset=True, warn=False)[0]\n1363                 if len(xargs) > len(margs):\n1364                     continue\n1365                 resid = margs.difference(xargs)\n1366                 if len(resid) + len(xargs) == len(margs):\n1367                     co.append(Mul(*resid))\n1368             if co == []:\n1369                 return S.Zero\n1370             elif co:\n1371                 return Add(*co)\n1372         elif x_c:\n1373             xargs = x.args_cnc(cset=True, warn=False)[0]\n1374             for a in args:\n1375                 margs, nc = a.args_cnc(cset=True)\n1376                 if len(xargs) > len(margs):\n1377                     continue\n1378                 resid = margs.difference(xargs)\n1379                 if len(resid) + len(xargs) == len(margs):\n1380                     co.append(Mul(*(list(resid) + nc)))\n1381             if co == []:\n1382                 return S.Zero\n1383             elif co:\n1384                 return Add(*co)\n1385         else:  # both nc\n1386             xargs, nx = x.args_cnc(cset=True)\n1387             # find the parts that pass the commutative terms\n1388             for a in args:\n1389                 margs, nc = a.args_cnc(cset=True)\n1390                 if len(xargs) > len(margs):\n1391                     continue\n1392                 resid = margs.difference(xargs)\n1393                 if len(resid) + len(xargs) == len(margs):\n1394                     co.append((resid, nc))\n1395             # now check the non-comm parts\n1396             if not co:\n1397                 return S.Zero\n1398             if all(n == co[0][1] for r, n in co):\n1399                 ii = find(co[0][1], nx, right)\n1400                 if ii is not None:\n1401                     if not right:\n1402                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))\n1403                     else:\n1404                         return Mul(*co[0][1][ii + len(nx):])\n1405             beg = reduce(incommon, (n[1] for n in co))\n1406             if beg:\n1407                 ii = find(beg, nx, right)\n1408                 if ii is not None:\n1409                     if not right:\n1410                         gcdc = co[0][0]\n1411                         for i in range(1, len(co)):\n1412                             gcdc = gcdc.intersection(co[i][0])\n1413                             if not gcdc:\n1414                                 break\n1415                         return Mul(*(list(gcdc) + beg[:ii]))\n1416                     else:\n1417                         m = ii + len(nx)\n1418                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])\n1419             end = list(reversed(\n1420                 reduce(incommon, (list(reversed(n[1])) for n in co))))\n1421             if end:\n1422                 ii = find(end, nx, right)\n1423                 if ii is not None:\n1424                     if not right:\n1425                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])\n1426                     else:\n1427                         return Mul(*end[ii + len(nx):])\n1428             # look for single match\n1429             hit = None\n1430             for i, (r, n) in enumerate(co):\n1431                 ii = find(n, nx, right)\n1432                 if ii is not None:\n1433                     if not hit:\n1434                         hit = ii, r, n\n1435                     else:\n1436                         break\n1437             else:\n1438                 if hit:\n1439                     ii, r, n = hit\n1440                     if not right:\n1441                         return Mul(*(list(r) + n[:ii]))\n1442                     else:\n1443                         return Mul(*n[ii + len(nx):])\n1444 \n1445             return S.Zero\n1446 \n1447     def as_expr(self, *gens):\n1448         \"\"\"\n1449         Convert a polynomial to a SymPy expression.\n1450 \n1451         Examples\n1452         ========\n1453 \n1454         >>> from sympy import sin\n1455         >>> from sympy.abc import x, y\n1456 \n1457         >>> f = (x**2 + x*y).as_poly(x, y)\n1458         >>> f.as_expr()\n1459         x**2 + x*y\n1460 \n1461         >>> sin(x).as_expr()\n1462         sin(x)\n1463 \n1464         \"\"\"\n1465         return self\n1466 \n1467     def as_coefficient(self, expr):\n1468         \"\"\"\n1469         Extracts symbolic coefficient at the given expression. In\n1470         other words, this functions separates 'self' into the product\n1471         of 'expr' and 'expr'-free coefficient. If such separation\n1472         is not possible it will return None.\n1473 \n1474         Examples\n1475         ========\n1476 \n1477         >>> from sympy import E, pi, sin, I, Poly\n1478         >>> from sympy.abc import x\n1479 \n1480         >>> E.as_coefficient(E)\n1481         1\n1482         >>> (2*E).as_coefficient(E)\n1483         2\n1484         >>> (2*sin(E)*E).as_coefficient(E)\n1485 \n1486         Two terms have E in them so a sum is returned. (If one were\n1487         desiring the coefficient of the term exactly matching E then\n1488         the constant from the returned expression could be selected.\n1489         Or, for greater precision, a method of Poly can be used to\n1490         indicate the desired term from which the coefficient is\n1491         desired.)\n1492 \n1493         >>> (2*E + x*E).as_coefficient(E)\n1494         x + 2\n1495         >>> _.args[0]  # just want the exact match\n1496         2\n1497         >>> p = Poly(2*E + x*E); p\n1498         Poly(x*E + 2*E, x, E, domain='ZZ')\n1499         >>> p.coeff_monomial(E)\n1500         2\n1501         >>> p.nth(0, 1)\n1502         2\n1503 \n1504         Since the following cannot be written as a product containing\n1505         E as a factor, None is returned. (If the coefficient ``2*x`` is\n1506         desired then the ``coeff`` method should be used.)\n1507 \n1508         >>> (2*E*x + x).as_coefficient(E)\n1509         >>> (2*E*x + x).coeff(E)\n1510         2*x\n1511 \n1512         >>> (E*(x + 1) + x).as_coefficient(E)\n1513 \n1514         >>> (2*pi*I).as_coefficient(pi*I)\n1515         2\n1516         >>> (2*I).as_coefficient(pi*I)\n1517 \n1518         See Also\n1519         ========\n1520 \n1521         coeff: return sum of terms have a given factor\n1522         as_coeff_Add: separate the additive constant from an expression\n1523         as_coeff_Mul: separate the multiplicative constant from an expression\n1524         as_independent: separate x-dependent terms/factors from others\n1525         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1526         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1527 \n1528 \n1529         \"\"\"\n1530 \n1531         r = self.extract_multiplicatively(expr)\n1532         if r and not r.has(expr):\n1533             return r\n1534 \n1535     def as_independent(self, *deps, **hint):\n1536         \"\"\"\n1537         A mostly naive separation of a Mul or Add into arguments that are not\n1538         are dependent on deps. To obtain as complete a separation of variables\n1539         as possible, use a separation method first, e.g.:\n1540 \n1541         * separatevars() to change Mul, Add and Pow (including exp) into Mul\n1542         * .expand(mul=True) to change Add or Mul into Add\n1543         * .expand(log=True) to change log expr into an Add\n1544 \n1545         The only non-naive thing that is done here is to respect noncommutative\n1546         ordering of variables and to always return (0, 0) for `self` of zero\n1547         regardless of hints.\n1548 \n1549         For nonzero `self`, the returned tuple (i, d) has the\n1550         following interpretation:\n1551 \n1552         * i will has no variable that appears in deps\n1553         * d will either have terms that contain variables that are in deps, or\n1554           be equal to 0 (when self is an Add) or 1 (when self is a Mul)\n1555         * if self is an Add then self = i + d\n1556         * if self is a Mul then self = i*d\n1557         * otherwise (self, S.One) or (S.One, self) is returned.\n1558 \n1559         To force the expression to be treated as an Add, use the hint as_Add=True\n1560 \n1561         Examples\n1562         ========\n1563 \n1564         -- self is an Add\n1565 \n1566         >>> from sympy import sin, cos, exp\n1567         >>> from sympy.abc import x, y, z\n1568 \n1569         >>> (x + x*y).as_independent(x)\n1570         (0, x*y + x)\n1571         >>> (x + x*y).as_independent(y)\n1572         (x, x*y)\n1573         >>> (2*x*sin(x) + y + x + z).as_independent(x)\n1574         (y + z, 2*x*sin(x) + x)\n1575         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n1576         (z, 2*x*sin(x) + x + y)\n1577 \n1578         -- self is a Mul\n1579 \n1580         >>> (x*sin(x)*cos(y)).as_independent(x)\n1581         (cos(y), x*sin(x))\n1582 \n1583         non-commutative terms cannot always be separated out when self is a Mul\n1584 \n1585         >>> from sympy import symbols\n1586         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n1587         >>> (n1 + n1*n2).as_independent(n2)\n1588         (n1, n1*n2)\n1589         >>> (n2*n1 + n1*n2).as_independent(n2)\n1590         (0, n1*n2 + n2*n1)\n1591         >>> (n1*n2*n3).as_independent(n1)\n1592         (1, n1*n2*n3)\n1593         >>> (n1*n2*n3).as_independent(n2)\n1594         (n1, n2*n3)\n1595         >>> ((x-n1)*(x-y)).as_independent(x)\n1596         (1, (x - y)*(x - n1))\n1597 \n1598         -- self is anything else:\n1599 \n1600         >>> (sin(x)).as_independent(x)\n1601         (1, sin(x))\n1602         >>> (sin(x)).as_independent(y)\n1603         (sin(x), 1)\n1604         >>> exp(x+y).as_independent(x)\n1605         (1, exp(x + y))\n1606 \n1607         -- force self to be treated as an Add:\n1608 \n1609         >>> (3*x).as_independent(x, as_Add=True)\n1610         (0, 3*x)\n1611 \n1612         -- force self to be treated as a Mul:\n1613 \n1614         >>> (3+x).as_independent(x, as_Add=False)\n1615         (1, x + 3)\n1616         >>> (-3+x).as_independent(x, as_Add=False)\n1617         (1, x - 3)\n1618 \n1619         Note how the below differs from the above in making the\n1620         constant on the dep term positive.\n1621 \n1622         >>> (y*(-3+x)).as_independent(x)\n1623         (y, x - 3)\n1624 \n1625         -- use .as_independent() for true independence testing instead\n1626            of .has(). The former considers only symbols in the free\n1627            symbols while the latter considers all symbols\n1628 \n1629         >>> from sympy import Integral\n1630         >>> I = Integral(x, (x, 1, 2))\n1631         >>> I.has(x)\n1632         True\n1633         >>> x in I.free_symbols\n1634         False\n1635         >>> I.as_independent(x) == (I, 1)\n1636         True\n1637         >>> (I + x).as_independent(x) == (I, x)\n1638         True\n1639 \n1640         Note: when trying to get independent terms, a separation method\n1641         might need to be used first. In this case, it is important to keep\n1642         track of what you send to this routine so you know how to interpret\n1643         the returned values\n1644 \n1645         >>> from sympy import separatevars, log\n1646         >>> separatevars(exp(x+y)).as_independent(x)\n1647         (exp(y), exp(x))\n1648         >>> (x + x*y).as_independent(y)\n1649         (x, x*y)\n1650         >>> separatevars(x + x*y).as_independent(y)\n1651         (x, y + 1)\n1652         >>> (x*(1 + y)).as_independent(y)\n1653         (x, y + 1)\n1654         >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n1655         (x, x*y)\n1656         >>> a, b=symbols('a b', positive=True)\n1657         >>> (log(a*b).expand(log=True)).as_independent(b)\n1658         (log(a), log(b))\n1659 \n1660         See Also\n1661         ========\n1662         .separatevars(), .expand(log=True), Add.as_two_terms(),\n1663         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()\n1664         \"\"\"\n1665         from .symbol import Symbol\n1666         from .add import _unevaluated_Add\n1667         from .mul import _unevaluated_Mul\n1668         from sympy.utilities.iterables import sift\n1669 \n1670         if self.is_zero:\n1671             return S.Zero, S.Zero\n1672 \n1673         func = self.func\n1674         if hint.get('as_Add', isinstance(self, Add) ):\n1675             want = Add\n1676         else:\n1677             want = Mul\n1678 \n1679         # sift out deps into symbolic and other and ignore\n1680         # all symbols but those that are in the free symbols\n1681         sym = set()\n1682         other = []\n1683         for d in deps:\n1684             if isinstance(d, Symbol):  # Symbol.is_Symbol is True\n1685                 sym.add(d)\n1686             else:\n1687                 other.append(d)\n1688 \n1689         def has(e):\n1690             \"\"\"return the standard has() if there are no literal symbols, else\n1691             check to see that symbol-deps are in the free symbols.\"\"\"\n1692             has_other = e.has(*other)\n1693             if not sym:\n1694                 return has_other\n1695             return has_other or e.has(*(e.free_symbols & sym))\n1696 \n1697         if (want is not func or\n1698                 func is not Add and func is not Mul):\n1699             if has(self):\n1700                 return (want.identity, self)\n1701             else:\n1702                 return (self, want.identity)\n1703         else:\n1704             if func is Add:\n1705                 args = list(self.args)\n1706             else:\n1707                 args, nc = self.args_cnc()\n1708 \n1709         d = sift(args, lambda x: has(x))\n1710         depend = d[True]\n1711         indep = d[False]\n1712         if func is Add:  # all terms were treated as commutative\n1713             return (Add(*indep), _unevaluated_Add(*depend))\n1714         else:  # handle noncommutative by stopping at first dependent term\n1715             for i, n in enumerate(nc):\n1716                 if has(n):\n1717                     depend.extend(nc[i:])\n1718                     break\n1719                 indep.append(n)\n1720             return Mul(*indep), (\n1721                 Mul(*depend, evaluate=False) if nc else\n1722                 _unevaluated_Mul(*depend))\n1723 \n1724     def as_real_imag(self, deep=True, **hints):\n1725         \"\"\"Performs complex expansion on 'self' and returns a tuple\n1726            containing collected both real and imaginary parts. This\n1727            method can't be confused with re() and im() functions,\n1728            which does not perform complex expansion at evaluation.\n1729 \n1730            However it is possible to expand both re() and im()\n1731            functions and get exactly the same results as with\n1732            a single call to this function.\n1733 \n1734            >>> from sympy import symbols, I\n1735 \n1736            >>> x, y = symbols('x,y', real=True)\n1737 \n1738            >>> (x + y*I).as_real_imag()\n1739            (x, y)\n1740 \n1741            >>> from sympy.abc import z, w\n1742 \n1743            >>> (z + w*I).as_real_imag()\n1744            (re(z) - im(w), re(w) + im(z))\n1745 \n1746         \"\"\"\n1747         from sympy import im, re\n1748         if hints.get('ignore') == self:\n1749             return None\n1750         else:\n1751             return (re(self), im(self))\n1752 \n1753     def as_powers_dict(self):\n1754         \"\"\"Return self as a dictionary of factors with each factor being\n1755         treated as a power. The keys are the bases of the factors and the\n1756         values, the corresponding exponents. The resulting dictionary should\n1757         be used with caution if the expression is a Mul and contains non-\n1758         commutative factors since the order that they appeared will be lost in\n1759         the dictionary.\"\"\"\n1760         d = defaultdict(int)\n1761         d.update(dict([self.as_base_exp()]))\n1762         return d\n1763 \n1764     def as_coefficients_dict(self):\n1765         \"\"\"Return a dictionary mapping terms to their Rational coefficient.\n1766         Since the dictionary is a defaultdict, inquiries about terms which\n1767         were not present will return a coefficient of 0. If an expression is\n1768         not an Add it is considered to have a single term.\n1769 \n1770         Examples\n1771         ========\n1772 \n1773         >>> from sympy.abc import a, x\n1774         >>> (3*x + a*x + 4).as_coefficients_dict()\n1775         {1: 4, x: 3, a*x: 1}\n1776         >>> _[a]\n1777         0\n1778         >>> (3*a*x).as_coefficients_dict()\n1779         {a*x: 3}\n1780 \n1781         \"\"\"\n1782         c, m = self.as_coeff_Mul()\n1783         if not c.is_Rational:\n1784             c = S.One\n1785             m = self\n1786         d = defaultdict(int)\n1787         d.update({m: c})\n1788         return d\n1789 \n1790     def as_base_exp(self):\n1791         # a -> b ** e\n1792         return self, S.One\n1793 \n1794     def as_coeff_mul(self, *deps, **kwargs):\n1795         \"\"\"Return the tuple (c, args) where self is written as a Mul, ``m``.\n1796 \n1797         c should be a Rational multiplied by any factors of the Mul that are\n1798         independent of deps.\n1799 \n1800         args should be a tuple of all other factors of m; args is empty\n1801         if self is a Number or if self is independent of deps (when given).\n1802 \n1803         This should be used when you don't know if self is a Mul or not but\n1804         you want to treat self as a Mul or if you want to process the\n1805         individual arguments of the tail of self as a Mul.\n1806 \n1807         - if you know self is a Mul and want only the head, use self.args[0];\n1808         - if you don't want to process the arguments of the tail but need the\n1809           tail then use self.as_two_terms() which gives the head and tail;\n1810         - if you want to split self into an independent and dependent parts\n1811           use ``self.as_independent(*deps)``\n1812 \n1813         >>> from sympy import S\n1814         >>> from sympy.abc import x, y\n1815         >>> (S(3)).as_coeff_mul()\n1816         (3, ())\n1817         >>> (3*x*y).as_coeff_mul()\n1818         (3, (x, y))\n1819         >>> (3*x*y).as_coeff_mul(x)\n1820         (3*y, (x,))\n1821         >>> (3*y).as_coeff_mul(x)\n1822         (3*y, ())\n1823         \"\"\"\n1824         if deps:\n1825             if not self.has(*deps):\n1826                 return self, tuple()\n1827         return S.One, (self,)\n1828 \n1829     def as_coeff_add(self, *deps):\n1830         \"\"\"Return the tuple (c, args) where self is written as an Add, ``a``.\n1831 \n1832         c should be a Rational added to any terms of the Add that are\n1833         independent of deps.\n1834 \n1835         args should be a tuple of all other terms of ``a``; args is empty\n1836         if self is a Number or if self is independent of deps (when given).\n1837 \n1838         This should be used when you don't know if self is an Add or not but\n1839         you want to treat self as an Add or if you want to process the\n1840         individual arguments of the tail of self as an Add.\n1841 \n1842         - if you know self is an Add and want only the head, use self.args[0];\n1843         - if you don't want to process the arguments of the tail but need the\n1844           tail then use self.as_two_terms() which gives the head and tail.\n1845         - if you want to split self into an independent and dependent parts\n1846           use ``self.as_independent(*deps)``\n1847 \n1848         >>> from sympy import S\n1849         >>> from sympy.abc import x, y\n1850         >>> (S(3)).as_coeff_add()\n1851         (3, ())\n1852         >>> (3 + x).as_coeff_add()\n1853         (3, (x,))\n1854         >>> (3 + x + y).as_coeff_add(x)\n1855         (y + 3, (x,))\n1856         >>> (3 + y).as_coeff_add(x)\n1857         (y + 3, ())\n1858 \n1859         \"\"\"\n1860         if deps:\n1861             if not self.has(*deps):\n1862                 return self, tuple()\n1863         return S.Zero, (self,)\n1864 \n1865     def primitive(self):\n1866         \"\"\"Return the positive Rational that can be extracted non-recursively\n1867         from every term of self (i.e., self is treated like an Add). This is\n1868         like the as_coeff_Mul() method but primitive always extracts a positive\n1869         Rational (never a negative or a Float).\n1870 \n1871         Examples\n1872         ========\n1873 \n1874         >>> from sympy.abc import x\n1875         >>> (3*(x + 1)**2).primitive()\n1876         (3, (x + 1)**2)\n1877         >>> a = (6*x + 2); a.primitive()\n1878         (2, 3*x + 1)\n1879         >>> b = (x/2 + 3); b.primitive()\n1880         (1/2, x + 6)\n1881         >>> (a*b).primitive() == (1, a*b)\n1882         True\n1883         \"\"\"\n1884         if not self:\n1885             return S.One, S.Zero\n1886         c, r = self.as_coeff_Mul(rational=True)\n1887         if c.is_negative:\n1888             c, r = -c, -r\n1889         return c, r\n1890 \n1891     def as_content_primitive(self, radical=False, clear=True):\n1892         \"\"\"This method should recursively remove a Rational from all arguments\n1893         and return that (content) and the new self (primitive). The content\n1894         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n1895         The primitive need not be in canonical form and should try to preserve\n1896         the underlying structure if possible (i.e. expand_mul should not be\n1897         applied to self).\n1898 \n1899         Examples\n1900         ========\n1901 \n1902         >>> from sympy import sqrt\n1903         >>> from sympy.abc import x, y, z\n1904 \n1905         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n1906 \n1907         The as_content_primitive function is recursive and retains structure:\n1908 \n1909         >>> eq.as_content_primitive()\n1910         (2, x + 3*y*(y + 1) + 1)\n1911 \n1912         Integer powers will have Rationals extracted from the base:\n1913 \n1914         >>> ((2 + 6*x)**2).as_content_primitive()\n1915         (4, (3*x + 1)**2)\n1916         >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n1917         (1, (2*(3*x + 1))**(2*y))\n1918 \n1919         Terms may end up joining once their as_content_primitives are added:\n1920 \n1921         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n1922         (11, x*(y + 1))\n1923         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n1924         (9, x*(y + 1))\n1925         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n1926         (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n1927         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n1928         (121, x**2*(y + 1)**2)\n1929         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()\n1930         (1, 121.0*x**2*(y + 1)**2)\n1931 \n1932         Radical content can also be factored out of the primitive:\n1933 \n1934         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n1935         (2, sqrt(2)*(1 + 2*sqrt(5)))\n1936 \n1937         If clear=False (default is True) then content will not be removed\n1938         from an Add if it can be distributed to leave one or more\n1939         terms with integer coefficients.\n1940 \n1941         >>> (x/2 + y).as_content_primitive()\n1942         (1/2, x + 2*y)\n1943         >>> (x/2 + y).as_content_primitive(clear=False)\n1944         (1, x/2 + y)\n1945         \"\"\"\n1946         return S.One, self\n1947 \n1948     def as_numer_denom(self):\n1949         \"\"\" expression -> a/b -> a, b\n1950 \n1951         This is just a stub that should be defined by\n1952         an object's class methods to get anything else.\n1953 \n1954         See Also\n1955         ========\n1956         normal: return a/b instead of a, b\n1957         \"\"\"\n1958 \n1959         return self, S.One\n1960 \n1961     def normal(self):\n1962         from .mul import _unevaluated_Mul\n1963         n, d = self.as_numer_denom()\n1964         if d is S.One:\n1965             return n\n1966         if d.is_Number:\n1967             if d is S.One:\n1968                 return n\n1969             else:\n1970                 return _unevaluated_Mul(n, 1/d)\n1971         else:\n1972             return n/d\n1973 \n1974     def extract_multiplicatively(self, c):\n1975         \"\"\"Return None if it's not possible to make self in the form\n1976            c * something in a nice way, i.e. preserving the properties\n1977            of arguments of self.\n1978 \n1979            >>> from sympy import symbols, Rational\n1980 \n1981            >>> x, y = symbols('x,y', real=True)\n1982 \n1983            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n1984            x*y**2\n1985 \n1986            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n1987 \n1988            >>> (2*x).extract_multiplicatively(2)\n1989            x\n1990 \n1991            >>> (2*x).extract_multiplicatively(3)\n1992 \n1993            >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n1994            x/6\n1995 \n1996         \"\"\"\n1997         from .function import _coeff_isneg\n1998 \n1999         c = sympify(c)\n2000         if self is S.NaN:\n2001             return None\n2002         if c is S.One:\n2003             return self\n2004         elif c == self:\n2005             return S.One\n2006 \n2007         if c.is_Add:\n2008             cc, pc = c.primitive()\n2009             if cc is not S.One:\n2010                 c = Mul(cc, pc, evaluate=False)\n2011 \n2012         if c.is_Mul:\n2013             a, b = c.as_two_terms()\n2014             x = self.extract_multiplicatively(a)\n2015             if x is not None:\n2016                 return x.extract_multiplicatively(b)\n2017 \n2018         quotient = self / c\n2019         if self.is_Number:\n2020             if self is S.Infinity:\n2021                 if c.is_positive:\n2022                     return S.Infinity\n2023             elif self is S.NegativeInfinity:\n2024                 if c.is_negative:\n2025                     return S.Infinity\n2026                 elif c.is_positive:\n2027                     return S.NegativeInfinity\n2028             elif self is S.ComplexInfinity:\n2029                 if not c.is_zero:\n2030                     return S.ComplexInfinity\n2031             elif self.is_Integer:\n2032                 if not quotient.is_Integer:\n2033                     return None\n2034                 elif self.is_positive and quotient.is_negative:\n2035                     return None\n2036                 else:\n2037                     return quotient\n2038             elif self.is_Rational:\n2039                 if not quotient.is_Rational:\n2040                     return None\n2041                 elif self.is_positive and quotient.is_negative:\n2042                     return None\n2043                 else:\n2044                     return quotient\n2045             elif self.is_Float:\n2046                 if not quotient.is_Float:\n2047                     return None\n2048                 elif self.is_positive and quotient.is_negative:\n2049                     return None\n2050                 else:\n2051                     return quotient\n2052         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n2053             if quotient.is_Mul and len(quotient.args) == 2:\n2054                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n2055                     return quotient\n2056             elif quotient.is_Integer and c.is_Number:\n2057                 return quotient\n2058         elif self.is_Add:\n2059             cs, ps = self.primitive()\n2060             # assert cs >= 1\n2061             if c.is_Number and c is not S.NegativeOne:\n2062                 # assert c != 1 (handled at top)\n2063                 if cs is not S.One:\n2064                     if c.is_negative:\n2065                         xc = -(cs.extract_multiplicatively(-c))\n2066                     else:\n2067                         xc = cs.extract_multiplicatively(c)\n2068                     if xc is not None:\n2069                         return xc*ps  # rely on 2-arg Mul to restore Add\n2070                 return  # |c| != 1 can only be extracted from cs\n2071             if c == ps:\n2072                 return cs\n2073             # check args of ps\n2074             newargs = []\n2075             for arg in ps.args:\n2076                 newarg = arg.extract_multiplicatively(c)\n2077                 if newarg is None:\n2078                     return  # all or nothing\n2079                 newargs.append(newarg)\n2080             # args should be in same order so use unevaluated return\n2081             if cs is not S.One:\n2082                 return Add._from_args([cs*t for t in newargs])\n2083             else:\n2084                 return Add._from_args(newargs)\n2085         elif self.is_Mul:\n2086             args = list(self.args)\n2087             for i, arg in enumerate(args):\n2088                 newarg = arg.extract_multiplicatively(c)\n2089                 if newarg is not None:\n2090                     args[i] = newarg\n2091                     return Mul(*args)\n2092         elif self.is_Pow:\n2093             if c.is_Pow and c.base == self.base:\n2094                 new_exp = self.exp.extract_additively(c.exp)\n2095                 if new_exp is not None:\n2096                     return self.base ** (new_exp)\n2097             elif c == self.base:\n2098                 new_exp = self.exp.extract_additively(1)\n2099                 if new_exp is not None:\n2100                     return self.base ** (new_exp)\n2101 \n2102     def extract_additively(self, c):\n2103         \"\"\"Return self - c if it's possible to subtract c from self and\n2104         make all matching coefficients move towards zero, else return None.\n2105 \n2106         Examples\n2107         ========\n2108 \n2109         >>> from sympy.abc import x, y\n2110         >>> e = 2*x + 3\n2111         >>> e.extract_additively(x + 1)\n2112         x + 2\n2113         >>> e.extract_additively(3*x)\n2114         >>> e.extract_additively(4)\n2115         >>> (y*(x + 1)).extract_additively(x + 1)\n2116         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n2117         (x + 1)*(x + 2*y) + 3\n2118 \n2119         Sometimes auto-expansion will return a less simplified result\n2120         than desired; gcd_terms might be used in such cases:\n2121 \n2122         >>> from sympy import gcd_terms\n2123         >>> (4*x*(y + 1) + y).extract_additively(x)\n2124         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y\n2125         >>> gcd_terms(_)\n2126         x*(4*y + 3) + y\n2127 \n2128         See Also\n2129         ========\n2130         extract_multiplicatively\n2131         coeff\n2132         as_coefficient\n2133 \n2134         \"\"\"\n2135 \n2136         c = sympify(c)\n2137         if self is S.NaN:\n2138             return None\n2139         if c is S.Zero:\n2140             return self\n2141         elif c == self:\n2142             return S.Zero\n2143         elif self is S.Zero:\n2144             return None\n2145 \n2146         if self.is_Number:\n2147             if not c.is_Number:\n2148                 return None\n2149             co = self\n2150             diff = co - c\n2151             # XXX should we match types? i.e should 3 - .1 succeed?\n2152             if (co > 0 and diff > 0 and diff < co or\n2153                     co < 0 and diff < 0 and diff > co):\n2154                 return diff\n2155             return None\n2156 \n2157         if c.is_Number:\n2158             co, t = self.as_coeff_Add()\n2159             xa = co.extract_additively(c)\n2160             if xa is None:\n2161                 return None\n2162             return xa + t\n2163 \n2164         # handle the args[0].is_Number case separately\n2165         # since we will have trouble looking for the coeff of\n2166         # a number.\n2167         if c.is_Add and c.args[0].is_Number:\n2168             # whole term as a term factor\n2169             co = self.coeff(c)\n2170             xa0 = (co.extract_additively(1) or 0)*c\n2171             if xa0:\n2172                 diff = self - co*c\n2173                 return (xa0 + (diff.extract_additively(c) or diff)) or None\n2174             # term-wise\n2175             h, t = c.as_coeff_Add()\n2176             sh, st = self.as_coeff_Add()\n2177             xa = sh.extract_additively(h)\n2178             if xa is None:\n2179                 return None\n2180             xa2 = st.extract_additively(t)\n2181             if xa2 is None:\n2182                 return None\n2183             return xa + xa2\n2184 \n2185         # whole term as a term factor\n2186         co = self.coeff(c)\n2187         xa0 = (co.extract_additively(1) or 0)*c\n2188         if xa0:\n2189             diff = self - co*c\n2190             return (xa0 + (diff.extract_additively(c) or diff)) or None\n2191         # term-wise\n2192         coeffs = []\n2193         for a in Add.make_args(c):\n2194             ac, at = a.as_coeff_Mul()\n2195             co = self.coeff(at)\n2196             if not co:\n2197                 return None\n2198             coc, cot = co.as_coeff_Add()\n2199             xa = coc.extract_additively(ac)\n2200             if xa is None:\n2201                 return None\n2202             self -= co*at\n2203             coeffs.append((cot + xa)*at)\n2204         coeffs.append(self)\n2205         return Add(*coeffs)\n2206 \n2207     @property\n2208     def expr_free_symbols(self):\n2209         \"\"\"\n2210         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.\n2211 \n2212         Examples\n2213         ========\n2214 \n2215         >>> from sympy.abc import x, y\n2216         >>> (x + y).expr_free_symbols\n2217         {x, y}\n2218 \n2219         If the expression is contained in a non-expression object, don't return\n2220         the free symbols. Compare:\n2221 \n2222         >>> from sympy import Tuple\n2223         >>> t = Tuple(x + y)\n2224         >>> t.expr_free_symbols\n2225         set()\n2226         >>> t.free_symbols\n2227         {x, y}\n2228         \"\"\"\n2229         return {j for i in self.args for j in i.expr_free_symbols}\n2230 \n2231     def could_extract_minus_sign(self):\n2232         \"\"\"Return True if self is not in a canonical form with respect\n2233         to its sign.\n2234 \n2235         For most expressions, e, there will be a difference in e and -e.\n2236         When there is, True will be returned for one and False for the\n2237         other; False will be returned if there is no difference.\n2238 \n2239         Examples\n2240         ========\n2241 \n2242         >>> from sympy.abc import x, y\n2243         >>> e = x - y\n2244         >>> {i.could_extract_minus_sign() for i in (e, -e)}\n2245         {False, True}\n2246 \n2247         \"\"\"\n2248         negative_self = -self\n2249         if self == negative_self:\n2250             return False  # e.g. zoo*x == -zoo*x\n2251         self_has_minus = (self.extract_multiplicatively(-1) is not None)\n2252         negative_self_has_minus = (\n2253             (negative_self).extract_multiplicatively(-1) is not None)\n2254         if self_has_minus != negative_self_has_minus:\n2255             return self_has_minus\n2256         else:\n2257             if self.is_Add:\n2258                 # We choose the one with less arguments with minus signs\n2259                 all_args = len(self.args)\n2260                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])\n2261                 positive_args = all_args - negative_args\n2262                 if positive_args > negative_args:\n2263                     return False\n2264                 elif positive_args < negative_args:\n2265                     return True\n2266             elif self.is_Mul:\n2267                 # We choose the one with an odd number of minus signs\n2268                 num, den = self.as_numer_denom()\n2269                 args = Mul.make_args(num) + Mul.make_args(den)\n2270                 arg_signs = [arg.could_extract_minus_sign() for arg in args]\n2271                 negative_args = list(filter(None, arg_signs))\n2272                 return len(negative_args) % 2 == 1\n2273 \n2274             # As a last resort, we choose the one with greater value of .sort_key()\n2275             return bool(self.sort_key() < negative_self.sort_key())\n2276 \n2277     def extract_branch_factor(self, allow_half=False):\n2278         \"\"\"\n2279         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.\n2280         Return (z, n).\n2281 \n2282         >>> from sympy import exp_polar, I, pi\n2283         >>> from sympy.abc import x, y\n2284         >>> exp_polar(I*pi).extract_branch_factor()\n2285         (exp_polar(I*pi), 0)\n2286         >>> exp_polar(2*I*pi).extract_branch_factor()\n2287         (1, 1)\n2288         >>> exp_polar(-pi*I).extract_branch_factor()\n2289         (exp_polar(I*pi), -1)\n2290         >>> exp_polar(3*pi*I + x).extract_branch_factor()\n2291         (exp_polar(x + I*pi), 1)\n2292         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()\n2293         (y*exp_polar(2*pi*x), -1)\n2294         >>> exp_polar(-I*pi/2).extract_branch_factor()\n2295         (exp_polar(-I*pi/2), 0)\n2296 \n2297         If allow_half is True, also extract exp_polar(I*pi):\n2298 \n2299         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)\n2300         (1, 1/2)\n2301         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)\n2302         (1, 1)\n2303         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)\n2304         (1, 3/2)\n2305         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)\n2306         (1, -1/2)\n2307         \"\"\"\n2308         from sympy import exp_polar, pi, I, ceiling, Add\n2309         n = S(0)\n2310         res = S(1)\n2311         args = Mul.make_args(self)\n2312         exps = []\n2313         for arg in args:\n2314             if isinstance(arg, exp_polar):\n2315                 exps += [arg.exp]\n2316             else:\n2317                 res *= arg\n2318         piimult = S(0)\n2319         extras = []\n2320         while exps:\n2321             exp = exps.pop()\n2322             if exp.is_Add:\n2323                 exps += exp.args\n2324                 continue\n2325             if exp.is_Mul:\n2326                 coeff = exp.as_coefficient(pi*I)\n2327                 if coeff is not None:\n2328                     piimult += coeff\n2329                     continue\n2330             extras += [exp]\n2331         if not piimult.free_symbols:\n2332             coeff = piimult\n2333             tail = ()\n2334         else:\n2335             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)\n2336         # round down to nearest multiple of 2\n2337         branchfact = ceiling(coeff/2 - S(1)/2)*2\n2338         n += branchfact/2\n2339         c = coeff - branchfact\n2340         if allow_half:\n2341             nc = c.extract_additively(1)\n2342             if nc is not None:\n2343                 n += S(1)/2\n2344                 c = nc\n2345         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)\n2346         if newexp != 0:\n2347             res *= exp_polar(newexp)\n2348         return res, n\n2349 \n2350     def _eval_is_polynomial(self, syms):\n2351         if self.free_symbols.intersection(syms) == set([]):\n2352             return True\n2353         return False\n2354 \n2355     def is_polynomial(self, *syms):\n2356         r\"\"\"\n2357         Return True if self is a polynomial in syms and False otherwise.\n2358 \n2359         This checks if self is an exact polynomial in syms.  This function\n2360         returns False for expressions that are \"polynomials\" with symbolic\n2361         exponents.  Thus, you should be able to apply polynomial algorithms to\n2362         expressions for which this returns True, and Poly(expr, \\*syms) should\n2363         work if and only if expr.is_polynomial(\\*syms) returns True. The\n2364         polynomial does not have to be in expanded form.  If no symbols are\n2365         given, all free symbols in the expression will be used.\n2366 \n2367         This is not part of the assumptions system.  You cannot do\n2368         Symbol('z', polynomial=True).\n2369 \n2370         Examples\n2371         ========\n2372 \n2373         >>> from sympy import Symbol\n2374         >>> x = Symbol('x')\n2375         >>> ((x**2 + 1)**4).is_polynomial(x)\n2376         True\n2377         >>> ((x**2 + 1)**4).is_polynomial()\n2378         True\n2379         >>> (2**x + 1).is_polynomial(x)\n2380         False\n2381 \n2382 \n2383         >>> n = Symbol('n', nonnegative=True, integer=True)\n2384         >>> (x**n + 1).is_polynomial(x)\n2385         False\n2386 \n2387         This function does not attempt any nontrivial simplifications that may\n2388         result in an expression that does not appear to be a polynomial to\n2389         become one.\n2390 \n2391         >>> from sympy import sqrt, factor, cancel\n2392         >>> y = Symbol('y', positive=True)\n2393         >>> a = sqrt(y**2 + 2*y + 1)\n2394         >>> a.is_polynomial(y)\n2395         False\n2396         >>> factor(a)\n2397         y + 1\n2398         >>> factor(a).is_polynomial(y)\n2399         True\n2400 \n2401         >>> b = (y**2 + 2*y + 1)/(y + 1)\n2402         >>> b.is_polynomial(y)\n2403         False\n2404         >>> cancel(b)\n2405         y + 1\n2406         >>> cancel(b).is_polynomial(y)\n2407         True\n2408 \n2409         See also .is_rational_function()\n2410 \n2411         \"\"\"\n2412         if syms:\n2413             syms = set(map(sympify, syms))\n2414         else:\n2415             syms = self.free_symbols\n2416 \n2417         if syms.intersection(self.free_symbols) == set([]):\n2418             # constant polynomial\n2419             return True\n2420         else:\n2421             return self._eval_is_polynomial(syms)\n2422 \n2423     def _eval_is_rational_function(self, syms):\n2424         if self.free_symbols.intersection(syms) == set([]):\n2425             return True\n2426         return False\n2427 \n2428     def is_rational_function(self, *syms):\n2429         \"\"\"\n2430         Test whether function is a ratio of two polynomials in the given\n2431         symbols, syms. When syms is not given, all free symbols will be used.\n2432         The rational function does not have to be in expanded or in any kind of\n2433         canonical form.\n2434 \n2435         This function returns False for expressions that are \"rational\n2436         functions\" with symbolic exponents.  Thus, you should be able to call\n2437         .as_numer_denom() and apply polynomial algorithms to the result for\n2438         expressions for which this returns True.\n2439 \n2440         This is not part of the assumptions system.  You cannot do\n2441         Symbol('z', rational_function=True).\n2442 \n2443         Examples\n2444         ========\n2445 \n2446         >>> from sympy import Symbol, sin\n2447         >>> from sympy.abc import x, y\n2448 \n2449         >>> (x/y).is_rational_function()\n2450         True\n2451 \n2452         >>> (x**2).is_rational_function()\n2453         True\n2454 \n2455         >>> (x/sin(y)).is_rational_function(y)\n2456         False\n2457 \n2458         >>> n = Symbol('n', integer=True)\n2459         >>> (x**n + 1).is_rational_function(x)\n2460         False\n2461 \n2462         This function does not attempt any nontrivial simplifications that may\n2463         result in an expression that does not appear to be a rational function\n2464         to become one.\n2465 \n2466         >>> from sympy import sqrt, factor\n2467         >>> y = Symbol('y', positive=True)\n2468         >>> a = sqrt(y**2 + 2*y + 1)/y\n2469         >>> a.is_rational_function(y)\n2470         False\n2471         >>> factor(a)\n2472         (y + 1)/y\n2473         >>> factor(a).is_rational_function(y)\n2474         True\n2475 \n2476         See also is_algebraic_expr().\n2477 \n2478         \"\"\"\n2479         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:\n2480             return False\n2481 \n2482         if syms:\n2483             syms = set(map(sympify, syms))\n2484         else:\n2485             syms = self.free_symbols\n2486 \n2487         if syms.intersection(self.free_symbols) == set([]):\n2488             # constant rational function\n2489             return True\n2490         else:\n2491             return self._eval_is_rational_function(syms)\n2492 \n2493     def _eval_is_algebraic_expr(self, syms):\n2494         if self.free_symbols.intersection(syms) == set([]):\n2495             return True\n2496         return False\n2497 \n2498     def is_algebraic_expr(self, *syms):\n2499         \"\"\"\n2500         This tests whether a given expression is algebraic or not, in the\n2501         given symbols, syms. When syms is not given, all free symbols\n2502         will be used. The rational function does not have to be in expanded\n2503         or in any kind of canonical form.\n2504 \n2505         This function returns False for expressions that are \"algebraic\n2506         expressions\" with symbolic exponents. This is a simple extension to the\n2507         is_rational_function, including rational exponentiation.\n2508 \n2509         Examples\n2510         ========\n2511 \n2512         >>> from sympy import Symbol, sqrt\n2513         >>> x = Symbol('x', real=True)\n2514         >>> sqrt(1 + x).is_rational_function()\n2515         False\n2516         >>> sqrt(1 + x).is_algebraic_expr()\n2517         True\n2518 \n2519         This function does not attempt any nontrivial simplifications that may\n2520         result in an expression that does not appear to be an algebraic\n2521         expression to become one.\n2522 \n2523         >>> from sympy import exp, factor\n2524         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)\n2525         >>> a.is_algebraic_expr(x)\n2526         False\n2527         >>> factor(a).is_algebraic_expr()\n2528         True\n2529 \n2530         See Also\n2531         ========\n2532         is_rational_function()\n2533 \n2534         References\n2535         ==========\n2536 \n2537         - http://en.wikipedia.org/wiki/Algebraic_expression\n2538 \n2539         \"\"\"\n2540         if syms:\n2541             syms = set(map(sympify, syms))\n2542         else:\n2543             syms = self.free_symbols\n2544 \n2545         if syms.intersection(self.free_symbols) == set([]):\n2546             # constant algebraic expression\n2547             return True\n2548         else:\n2549             return self._eval_is_algebraic_expr(syms)\n2550 \n2551     ###################################################################################\n2552     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################\n2553     ###################################################################################\n2554 \n2555     def series(self, x=None, x0=0, n=6, dir=\"+\", logx=None):\n2556         \"\"\"\n2557         Series expansion of \"self\" around ``x = x0`` yielding either terms of\n2558         the series one by one (the lazy series given when n=None), else\n2559         all the terms at once when n != None.\n2560 \n2561         Returns the series expansion of \"self\" around the point ``x = x0``\n2562         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).\n2563 \n2564         If ``x=None`` and ``self`` is univariate, the univariate symbol will\n2565         be supplied, otherwise an error will be raised.\n2566 \n2567         >>> from sympy import cos, exp\n2568         >>> from sympy.abc import x, y\n2569         >>> cos(x).series()\n2570         1 - x**2/2 + x**4/24 + O(x**6)\n2571         >>> cos(x).series(n=4)\n2572         1 - x**2/2 + O(x**4)\n2573         >>> cos(x).series(x, x0=1, n=2)\n2574         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))\n2575         >>> e = cos(x + exp(y))\n2576         >>> e.series(y, n=2)\n2577         cos(x + 1) - y*sin(x + 1) + O(y**2)\n2578         >>> e.series(x, n=2)\n2579         cos(exp(y)) - x*sin(exp(y)) + O(x**2)\n2580 \n2581         If ``n=None`` then a generator of the series terms will be returned.\n2582 \n2583         >>> term=cos(x).series(n=None)\n2584         >>> [next(term) for i in range(2)]\n2585         [1, -x**2/2]\n2586 \n2587         For ``dir=+`` (default) the series is calculated from the right and\n2588         for ``dir=-`` the series from the left. For smooth functions this\n2589         flag will not alter the results.\n2590 \n2591         >>> abs(x).series(dir=\"+\")\n2592         x\n2593         >>> abs(x).series(dir=\"-\")\n2594         -x\n2595 \n2596         \"\"\"\n2597         from sympy import collect, Dummy, Order, Rational, Symbol\n2598         if x is None:\n2599             syms = self.atoms(Symbol)\n2600             if not syms:\n2601                 return self\n2602             elif len(syms) > 1:\n2603                 raise ValueError('x must be given for multivariate functions.')\n2604             x = syms.pop()\n2605 \n2606         if not self.has(x):\n2607             if n is None:\n2608                 return (s for s in [self])\n2609             else:\n2610                 return self\n2611 \n2612         if len(dir) != 1 or dir not in '+-':\n2613             raise ValueError(\"Dir must be '+' or '-'\")\n2614 \n2615         if x0 in [S.Infinity, S.NegativeInfinity]:\n2616             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]\n2617             s = self.subs(x, 1/x).series(x, n=n, dir=dir)\n2618             if n is None:\n2619                 return (si.subs(x, 1/x) for si in s)\n2620             return s.subs(x, 1/x)\n2621 \n2622         # use rep to shift origin to x0 and change sign (if dir is negative)\n2623         # and undo the process with rep2\n2624         if x0 or dir == '-':\n2625             if dir == '-':\n2626                 rep = -x + x0\n2627                 rep2 = -x\n2628                 rep2b = x0\n2629             else:\n2630                 rep = x + x0\n2631                 rep2 = x\n2632                 rep2b = -x0\n2633             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)\n2634             if n is None:  # lseries...\n2635                 return (si.subs(x, rep2 + rep2b) for si in s)\n2636             return s.subs(x, rep2 + rep2b)\n2637 \n2638         # from here on it's x0=0 and dir='+' handling\n2639 \n2640         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:\n2641             # replace x with an x that has a positive assumption\n2642             xpos = Dummy('x', positive=True, finite=True)\n2643             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)\n2644             if n is None:\n2645                 return (s.subs(xpos, x) for s in rv)\n2646             else:\n2647                 return rv.subs(xpos, x)\n2648 \n2649         if n is not None:  # nseries handling\n2650             s1 = self._eval_nseries(x, n=n, logx=logx)\n2651             o = s1.getO() or S.Zero\n2652             if o:\n2653                 # make sure the requested order is returned\n2654                 ngot = o.getn()\n2655                 if ngot > n:\n2656                     # leave o in its current form (e.g. with x*log(x)) so\n2657                     # it eats terms properly, then replace it below\n2658                     if n != 0:\n2659                         s1 += o.subs(x, x**Rational(n, ngot))\n2660                     else:\n2661                         s1 += Order(1, x)\n2662                 elif ngot < n:\n2663                     # increase the requested number of terms to get the desired\n2664                     # number keep increasing (up to 9) until the received order\n2665                     # is different than the original order and then predict how\n2666                     # many additional terms are needed\n2667                     for more in range(1, 9):\n2668                         s1 = self._eval_nseries(x, n=n + more, logx=logx)\n2669                         newn = s1.getn()\n2670                         if newn != ngot:\n2671                             ndo = n + (n - ngot)*more/(newn - ngot)\n2672                             s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2673                             while s1.getn() < n:\n2674                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2675                                 ndo += 1\n2676                             break\n2677                     else:\n2678                         raise ValueError('Could not calculate %s terms for %s'\n2679                                          % (str(n), self))\n2680                     s1 += Order(x**n, x)\n2681                 o = s1.getO()\n2682                 s1 = s1.removeO()\n2683             else:\n2684                 o = Order(x**n, x)\n2685                 s1done = s1.doit()\n2686                 if (s1done + o).removeO() == s1done:\n2687                     o = S.Zero\n2688 \n2689             try:\n2690                 return collect(s1, x) + o\n2691             except NotImplementedError:\n2692                 return s1 + o\n2693 \n2694         else:  # lseries handling\n2695             def yield_lseries(s):\n2696                 \"\"\"Return terms of lseries one at a time.\"\"\"\n2697                 for si in s:\n2698                     if not si.is_Add:\n2699                         yield si\n2700                         continue\n2701                     # yield terms 1 at a time if possible\n2702                     # by increasing order until all the\n2703                     # terms have been returned\n2704                     yielded = 0\n2705                     o = Order(si, x)*x\n2706                     ndid = 0\n2707                     ndo = len(si.args)\n2708                     while 1:\n2709                         do = (si - yielded + o).removeO()\n2710                         o *= x\n2711                         if not do or do.is_Order:\n2712                             continue\n2713                         if do.is_Add:\n2714                             ndid += len(do.args)\n2715                         else:\n2716                             ndid += 1\n2717                         yield do\n2718                         if ndid == ndo:\n2719                             break\n2720                         yielded += do\n2721 \n2722             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))\n2723 \n2724     def taylor_term(self, n, x, *previous_terms):\n2725         \"\"\"General method for the taylor term.\n2726 \n2727         This method is slow, because it differentiates n-times. Subclasses can\n2728         redefine it to make it faster by using the \"previous_terms\".\n2729         \"\"\"\n2730         from sympy import Dummy, factorial\n2731         x = sympify(x)\n2732         _x = Dummy('x')\n2733         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)\n2734 \n2735     def lseries(self, x=None, x0=0, dir='+', logx=None):\n2736         \"\"\"\n2737         Wrapper for series yielding an iterator of the terms of the series.\n2738 \n2739         Note: an infinite series will yield an infinite iterator. The following,\n2740         for exaxmple, will never terminate. It will just keep printing terms\n2741         of the sin(x) series::\n2742 \n2743           for term in sin(x).lseries(x):\n2744               print term\n2745 \n2746         The advantage of lseries() over nseries() is that many times you are\n2747         just interested in the next term in the series (i.e. the first term for\n2748         example), but you don't know how many you should ask for in nseries()\n2749         using the \"n\" parameter.\n2750 \n2751         See also nseries().\n2752         \"\"\"\n2753         return self.series(x, x0, n=None, dir=dir, logx=logx)\n2754 \n2755     def _eval_lseries(self, x, logx=None):\n2756         # default implementation of lseries is using nseries(), and adaptively\n2757         # increasing the \"n\". As you can see, it is not very efficient, because\n2758         # we are calculating the series over and over again. Subclasses should\n2759         # override this method and implement much more efficient yielding of\n2760         # terms.\n2761         n = 0\n2762         series = self._eval_nseries(x, n=n, logx=logx)\n2763         if not series.is_Order:\n2764             if series.is_Add:\n2765                 yield series.removeO()\n2766             else:\n2767                 yield series\n2768             return\n2769 \n2770         while series.is_Order:\n2771             n += 1\n2772             series = self._eval_nseries(x, n=n, logx=logx)\n2773         e = series.removeO()\n2774         yield e\n2775         while 1:\n2776             while 1:\n2777                 n += 1\n2778                 series = self._eval_nseries(x, n=n, logx=logx).removeO()\n2779                 if e != series:\n2780                     break\n2781             yield series - e\n2782             e = series\n2783 \n2784     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):\n2785         \"\"\"\n2786         Wrapper to _eval_nseries if assumptions allow, else to series.\n2787 \n2788         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is\n2789         called. This calculates \"n\" terms in the innermost expressions and\n2790         then builds up the final series just by \"cross-multiplying\" everything\n2791         out.\n2792 \n2793         The optional ``logx`` parameter can be used to replace any log(x) in the\n2794         returned series with a symbolic value to avoid evaluating log(x) at 0. A\n2795         symbol to use in place of log(x) should be provided.\n2796 \n2797         Advantage -- it's fast, because we don't have to determine how many\n2798         terms we need to calculate in advance.\n2799 \n2800         Disadvantage -- you may end up with less terms than you may have\n2801         expected, but the O(x**n) term appended will always be correct and\n2802         so the result, though perhaps shorter, will also be correct.\n2803 \n2804         If any of those assumptions is not met, this is treated like a\n2805         wrapper to series which will try harder to return the correct\n2806         number of terms.\n2807 \n2808         See also lseries().\n2809 \n2810         Examples\n2811         ========\n2812 \n2813         >>> from sympy import sin, log, Symbol\n2814         >>> from sympy.abc import x, y\n2815         >>> sin(x).nseries(x, 0, 6)\n2816         x - x**3/6 + x**5/120 + O(x**6)\n2817         >>> log(x+1).nseries(x, 0, 5)\n2818         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)\n2819 \n2820         Handling of the ``logx`` parameter --- in the following example the\n2821         expansion fails since ``sin`` does not have an asymptotic expansion\n2822         at -oo (the limit of log(x) as x approaches 0):\n2823 \n2824         >>> e = sin(log(x))\n2825         >>> e.nseries(x, 0, 6)\n2826         Traceback (most recent call last):\n2827         ...\n2828         PoleError: ...\n2829         ...\n2830         >>> logx = Symbol('logx')\n2831         >>> e.nseries(x, 0, 6, logx=logx)\n2832         sin(logx)\n2833 \n2834         In the following example, the expansion works but gives only an Order term\n2835         unless the ``logx`` parameter is used:\n2836 \n2837         >>> e = x**y\n2838         >>> e.nseries(x, 0, 2)\n2839         O(log(x)**2)\n2840         >>> e.nseries(x, 0, 2, logx=logx)\n2841         exp(logx*y)\n2842 \n2843         \"\"\"\n2844         if x and not x in self.free_symbols:\n2845             return self\n2846         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):\n2847             return self.series(x, x0, n, dir)\n2848         else:\n2849             return self._eval_nseries(x, n=n, logx=logx)\n2850 \n2851     def _eval_nseries(self, x, n, logx):\n2852         \"\"\"\n2853         Return terms of series for self up to O(x**n) at x=0\n2854         from the positive direction.\n2855 \n2856         This is a method that should be overridden in subclasses. Users should\n2857         never call this method directly (use .nseries() instead), so you don't\n2858         have to write docstrings for _eval_nseries().\n2859         \"\"\"\n2860         from sympy.utilities.misc import filldedent\n2861         raise NotImplementedError(filldedent(\"\"\"\n2862                      The _eval_nseries method should be added to\n2863                      %s to give terms up to O(x**n) at x=0\n2864                      from the positive direction so it is available when\n2865                      nseries calls it.\"\"\" % self.func)\n2866                      )\n2867 \n2868     def limit(self, x, xlim, dir='+'):\n2869         \"\"\" Compute limit x->xlim.\n2870         \"\"\"\n2871         from sympy.series.limits import limit\n2872         return limit(self, x, xlim, dir)\n2873 \n2874     def compute_leading_term(self, x, logx=None):\n2875         \"\"\"\n2876         as_leading_term is only allowed for results of .series()\n2877         This is a wrapper to compute a series first.\n2878         \"\"\"\n2879         from sympy import Dummy, log\n2880         from sympy.series.gruntz import calculate_series\n2881 \n2882         if self.removeO() == 0:\n2883             return self\n2884 \n2885         if logx is None:\n2886             d = Dummy('logx')\n2887             s = calculate_series(self, x, d).subs(d, log(x))\n2888         else:\n2889             s = calculate_series(self, x, logx)\n2890 \n2891         return s.as_leading_term(x)\n2892 \n2893     @cacheit\n2894     def as_leading_term(self, *symbols):\n2895         \"\"\"\n2896         Returns the leading (nonzero) term of the series expansion of self.\n2897 \n2898         The _eval_as_leading_term routines are used to do this, and they must\n2899         always return a non-zero value.\n2900 \n2901         Examples\n2902         ========\n2903 \n2904         >>> from sympy.abc import x\n2905         >>> (1 + x + x**2).as_leading_term(x)\n2906         1\n2907         >>> (1/x**2 + x + x**2).as_leading_term(x)\n2908         x**(-2)\n2909 \n2910         \"\"\"\n2911         from sympy import powsimp\n2912         if len(symbols) > 1:\n2913             c = self\n2914             for x in symbols:\n2915                 c = c.as_leading_term(x)\n2916             return c\n2917         elif not symbols:\n2918             return self\n2919         x = sympify(symbols[0])\n2920         if not x.is_symbol:\n2921             raise ValueError('expecting a Symbol but got %s' % x)\n2922         if x not in self.free_symbols:\n2923             return self\n2924         obj = self._eval_as_leading_term(x)\n2925         if obj is not None:\n2926             return powsimp(obj, deep=True, combine='exp')\n2927         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))\n2928 \n2929     def _eval_as_leading_term(self, x):\n2930         return self\n2931 \n2932     def as_coeff_exponent(self, x):\n2933         \"\"\" ``c*x**e -> c,e`` where x can be any symbolic expression.\n2934         \"\"\"\n2935         from sympy import collect\n2936         s = collect(self, x)\n2937         c, p = s.as_coeff_mul(x)\n2938         if len(p) == 1:\n2939             b, e = p[0].as_base_exp()\n2940             if b == x:\n2941                 return c, e\n2942         return s, S.Zero\n2943 \n2944     def leadterm(self, x):\n2945         \"\"\"\n2946         Returns the leading term a*x**b as a tuple (a, b).\n2947 \n2948         Examples\n2949         ========\n2950 \n2951         >>> from sympy.abc import x\n2952         >>> (1+x+x**2).leadterm(x)\n2953         (1, 0)\n2954         >>> (1/x**2+x+x**2).leadterm(x)\n2955         (1, -2)\n2956 \n2957         \"\"\"\n2958         from sympy import Dummy, log\n2959         l = self.as_leading_term(x)\n2960         d = Dummy('logx')\n2961         if l.has(log(x)):\n2962             l = l.subs(log(x), d)\n2963         c, e = l.as_coeff_exponent(x)\n2964         if x in c.free_symbols:\n2965             from sympy.utilities.misc import filldedent\n2966             raise ValueError(filldedent(\"\"\"\n2967                 cannot compute leadterm(%s, %s). The coefficient\n2968                 should have been free of x but got %s\"\"\" % (self, x, c)))\n2969         c = c.subs(d, log(x))\n2970         return c, e\n2971 \n2972     def as_coeff_Mul(self, rational=False):\n2973         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n2974         return S.One, self\n2975 \n2976     def as_coeff_Add(self, rational=False):\n2977         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2978         return S.Zero, self\n2979 \n2980     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,\n2981             full=False):\n2982         \"\"\"\n2983         Compute formal power power series of self.\n2984 \n2985         See the docstring of the :func:`fps` function in sympy.series.formal for\n2986         more information.\n2987         \"\"\"\n2988         from sympy.series.formal import fps\n2989 \n2990         return fps(self, x, x0, dir, hyper, order, rational, full)\n2991 \n2992     def fourier_series(self, limits=None):\n2993         \"\"\"Compute fourier sine/cosine series of self.\n2994 \n2995         See the docstring of the :func:`fourier_series` in sympy.series.fourier\n2996         for more information.\n2997         \"\"\"\n2998         from sympy.series.fourier import fourier_series\n2999 \n3000         return fourier_series(self, limits)\n3001 \n3002     ###################################################################################\n3003     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################\n3004     ###################################################################################\n3005 \n3006     def diff(self, *symbols, **assumptions):\n3007         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z\n3008         assumptions.setdefault(\"evaluate\", True)\n3009         return Derivative(self, *new_symbols, **assumptions)\n3010 \n3011     ###########################################################################\n3012     ###################### EXPRESSION EXPANSION METHODS #######################\n3013     ###########################################################################\n3014 \n3015     # Relevant subclasses should override _eval_expand_hint() methods.  See\n3016     # the docstring of expand() for more info.\n3017 \n3018     def _eval_expand_complex(self, **hints):\n3019         real, imag = self.as_real_imag(**hints)\n3020         return real + S.ImaginaryUnit*imag\n3021 \n3022     @staticmethod\n3023     def _expand_hint(expr, hint, deep=True, **hints):\n3024         \"\"\"\n3025         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.\n3026 \n3027         Returns ``(expr, hit)``, where expr is the (possibly) expanded\n3028         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and\n3029         ``False`` otherwise.\n3030         \"\"\"\n3031         hit = False\n3032         # XXX: Hack to support non-Basic args\n3033         #              |\n3034         #              V\n3035         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:\n3036             sargs = []\n3037             for arg in expr.args:\n3038                 arg, arghit = Expr._expand_hint(arg, hint, **hints)\n3039                 hit |= arghit\n3040                 sargs.append(arg)\n3041 \n3042             if hit:\n3043                 expr = expr.func(*sargs)\n3044 \n3045         if hasattr(expr, hint):\n3046             newexpr = getattr(expr, hint)(**hints)\n3047             if newexpr != expr:\n3048                 return (newexpr, True)\n3049 \n3050         return (expr, hit)\n3051 \n3052     @cacheit\n3053     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,\n3054             mul=True, log=True, multinomial=True, basic=True, **hints):\n3055         \"\"\"\n3056         Expand an expression using hints.\n3057 \n3058         See the docstring of the expand() function in sympy.core.function for\n3059         more information.\n3060 \n3061         \"\"\"\n3062         from sympy.simplify.radsimp import fraction\n3063 \n3064         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,\n3065            log=log, multinomial=multinomial, basic=basic)\n3066 \n3067         expr = self\n3068         if hints.pop('frac', False):\n3069             n, d = [a.expand(deep=deep, modulus=modulus, **hints)\n3070                     for a in fraction(self)]\n3071             return n/d\n3072         elif hints.pop('denom', False):\n3073             n, d = fraction(self)\n3074             return n/d.expand(deep=deep, modulus=modulus, **hints)\n3075         elif hints.pop('numer', False):\n3076             n, d = fraction(self)\n3077             return n.expand(deep=deep, modulus=modulus, **hints)/d\n3078 \n3079         # Although the hints are sorted here, an earlier hint may get applied\n3080         # at a given node in the expression tree before another because of how\n3081         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +\n3082         # x*z) because while applying log at the top level, log and mul are\n3083         # applied at the deeper level in the tree so that when the log at the\n3084         # upper level gets applied, the mul has already been applied at the\n3085         # lower level.\n3086 \n3087         # Additionally, because hints are only applied once, the expression\n3088         # may not be expanded all the way.   For example, if mul is applied\n3089         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For\n3090         # now, we just use a special case to make multinomial run before mul,\n3091         # so that at least polynomials will be expanded all the way.  In the\n3092         # future, smarter heuristics should be applied.\n3093         # TODO: Smarter heuristics\n3094 \n3095         def _expand_hint_key(hint):\n3096             \"\"\"Make multinomial come before mul\"\"\"\n3097             if hint == 'mul':\n3098                 return 'mulz'\n3099             return hint\n3100 \n3101         for hint in sorted(hints.keys(), key=_expand_hint_key):\n3102             use_hint = hints[hint]\n3103             if use_hint:\n3104                 hint = '_eval_expand_' + hint\n3105                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n3106 \n3107         while True:\n3108             was = expr\n3109             if hints.get('multinomial', False):\n3110                 expr, _ = Expr._expand_hint(\n3111                     expr, '_eval_expand_multinomial', deep=deep, **hints)\n3112             if hints.get('mul', False):\n3113                 expr, _ = Expr._expand_hint(\n3114                     expr, '_eval_expand_mul', deep=deep, **hints)\n3115             if hints.get('log', False):\n3116                 expr, _ = Expr._expand_hint(\n3117                     expr, '_eval_expand_log', deep=deep, **hints)\n3118             if expr == was:\n3119                 break\n3120 \n3121         if modulus is not None:\n3122             modulus = sympify(modulus)\n3123 \n3124             if not modulus.is_Integer or modulus <= 0:\n3125                 raise ValueError(\n3126                     \"modulus must be a positive integer, got %s\" % modulus)\n3127 \n3128             terms = []\n3129 \n3130             for term in Add.make_args(expr):\n3131                 coeff, tail = term.as_coeff_Mul(rational=True)\n3132 \n3133                 coeff %= modulus\n3134 \n3135                 if coeff:\n3136                     terms.append(coeff*tail)\n3137 \n3138             expr = Add(*terms)\n3139 \n3140         return expr\n3141 \n3142     ###########################################################################\n3143     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################\n3144     ###########################################################################\n3145 \n3146     def integrate(self, *args, **kwargs):\n3147         \"\"\"See the integrate function in sympy.integrals\"\"\"\n3148         from sympy.integrals import integrate\n3149         return integrate(self, *args, **kwargs)\n3150 \n3151     def simplify(self, ratio=1.7, measure=None):\n3152         \"\"\"See the simplify function in sympy.simplify\"\"\"\n3153         from sympy.simplify import simplify\n3154         from sympy.core.function import count_ops\n3155         measure = measure or count_ops\n3156         return simplify(self, ratio, measure)\n3157 \n3158     def nsimplify(self, constants=[], tolerance=None, full=False):\n3159         \"\"\"See the nsimplify function in sympy.simplify\"\"\"\n3160         from sympy.simplify import nsimplify\n3161         return nsimplify(self, constants, tolerance, full)\n3162 \n3163     def separate(self, deep=False, force=False):\n3164         \"\"\"See the separate function in sympy.simplify\"\"\"\n3165         from sympy.core.function import expand_power_base\n3166         return expand_power_base(self, deep=deep, force=force)\n3167 \n3168     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):\n3169         \"\"\"See the collect function in sympy.simplify\"\"\"\n3170         from sympy.simplify import collect\n3171         return collect(self, syms, func, evaluate, exact, distribute_order_term)\n3172 \n3173     def together(self, *args, **kwargs):\n3174         \"\"\"See the together function in sympy.polys\"\"\"\n3175         from sympy.polys import together\n3176         return together(self, *args, **kwargs)\n3177 \n3178     def apart(self, x=None, **args):\n3179         \"\"\"See the apart function in sympy.polys\"\"\"\n3180         from sympy.polys import apart\n3181         return apart(self, x, **args)\n3182 \n3183     def ratsimp(self):\n3184         \"\"\"See the ratsimp function in sympy.simplify\"\"\"\n3185         from sympy.simplify import ratsimp\n3186         return ratsimp(self)\n3187 \n3188     def trigsimp(self, **args):\n3189         \"\"\"See the trigsimp function in sympy.simplify\"\"\"\n3190         from sympy.simplify import trigsimp\n3191         return trigsimp(self, **args)\n3192 \n3193     def radsimp(self, **kwargs):\n3194         \"\"\"See the radsimp function in sympy.simplify\"\"\"\n3195         from sympy.simplify import radsimp\n3196         return radsimp(self, **kwargs)\n3197 \n3198     def powsimp(self, *args, **kwargs):\n3199         \"\"\"See the powsimp function in sympy.simplify\"\"\"\n3200         from sympy.simplify import powsimp\n3201         return powsimp(self, *args, **kwargs)\n3202 \n3203     def combsimp(self):\n3204         \"\"\"See the combsimp function in sympy.simplify\"\"\"\n3205         from sympy.simplify import combsimp\n3206         return combsimp(self)\n3207 \n3208     def gammasimp(self):\n3209         \"\"\"See the gammasimp function in sympy.simplify\"\"\"\n3210         from sympy.simplify import gammasimp\n3211         return gammasimp(self)\n3212 \n3213     def factor(self, *gens, **args):\n3214         \"\"\"See the factor() function in sympy.polys.polytools\"\"\"\n3215         from sympy.polys import factor\n3216         return factor(self, *gens, **args)\n3217 \n3218     def refine(self, assumption=True):\n3219         \"\"\"See the refine function in sympy.assumptions\"\"\"\n3220         from sympy.assumptions import refine\n3221         return refine(self, assumption)\n3222 \n3223     def cancel(self, *gens, **args):\n3224         \"\"\"See the cancel function in sympy.polys\"\"\"\n3225         from sympy.polys import cancel\n3226         return cancel(self, *gens, **args)\n3227 \n3228     def invert(self, g, *gens, **args):\n3229         \"\"\"Return the multiplicative inverse of ``self`` mod ``g``\n3230         where ``self`` (and ``g``) may be symbolic expressions).\n3231 \n3232         See Also\n3233         ========\n3234         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert\n3235         \"\"\"\n3236         from sympy.polys.polytools import invert\n3237         from sympy.core.numbers import mod_inverse\n3238         if self.is_number and getattr(g, 'is_number', True):\n3239             return mod_inverse(self, g)\n3240         return invert(self, g, *gens, **args)\n3241 \n3242     def round(self, p=0):\n3243         \"\"\"Return x rounded to the given decimal place.\n3244 \n3245         If a complex number would results, apply round to the real\n3246         and imaginary components of the number.\n3247 \n3248         Examples\n3249         ========\n3250 \n3251         >>> from sympy import pi, E, I, S, Add, Mul, Number\n3252         >>> S(10.5).round()\n3253         11.\n3254         >>> pi.round()\n3255         3.\n3256         >>> pi.round(2)\n3257         3.14\n3258         >>> (2*pi + E*I).round()\n3259         6. + 3.*I\n3260 \n3261         The round method has a chopping effect:\n3262 \n3263         >>> (2*pi + I/10).round()\n3264         6.\n3265         >>> (pi/10 + 2*I).round()\n3266         2.*I\n3267         >>> (pi/10 + E*I).round(2)\n3268         0.31 + 2.72*I\n3269 \n3270         Notes\n3271         =====\n3272 \n3273         Do not confuse the Python builtin function, round, with the\n3274         SymPy method of the same name. The former always returns a float\n3275         (or raises an error if applied to a complex value) while the\n3276         latter returns either a Number or a complex number:\n3277 \n3278         >>> isinstance(round(S(123), -2), Number)\n3279         False\n3280         >>> isinstance(S(123).round(-2), Number)\n3281         True\n3282         >>> isinstance((3*I).round(), Mul)\n3283         True\n3284         >>> isinstance((1 + 3*I).round(), Add)\n3285         True\n3286 \n3287         \"\"\"\n3288         from sympy import Float\n3289         x = self\n3290         if not x.is_number:\n3291             raise TypeError(\"can't round symbolic expression\")\n3292         if not x.is_Atom:\n3293             xn = x.n(2)\n3294             if not pure_complex(xn, or_real=True):\n3295                 raise TypeError('Expected a number but got %s:' %\n3296                     getattr(getattr(x,'func', x), '__name__', type(x)))\n3297         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n3298             return x\n3299         if not x.is_real:\n3300             i, r = x.as_real_imag()\n3301             return i.round(p) + S.ImaginaryUnit*r.round(p)\n3302         if not x:\n3303             return x\n3304         p = int(p)\n3305 \n3306         precs = [f._prec for f in x.atoms(Float)]\n3307         dps = prec_to_dps(max(precs)) if precs else None\n3308 \n3309         mag_first_dig = _mag(x)\n3310         allow = digits_needed = mag_first_dig + p\n3311         if dps is not None and allow > dps:\n3312             allow = dps\n3313         mag = Pow(10, p)  # magnitude needed to bring digit p to units place\n3314         xwas = x\n3315         x += 1/(2*mag)  # add the half for rounding\n3316         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)\n3317         if i10.is_negative:\n3318             x = xwas - 1/(2*mag)  # should have gone the other way\n3319             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)\n3320             rv = -(Integer(-i10)//10)\n3321         else:\n3322             rv = Integer(i10)//10\n3323         q = 1\n3324         if p > 0:\n3325             q = mag\n3326         elif p < 0:\n3327             rv /= mag\n3328         rv = Rational(rv, q)\n3329         if rv.is_Integer:\n3330             # use str or else it won't be a float\n3331             return Float(str(rv), digits_needed)\n3332         else:\n3333             if not allow and rv > self:\n3334                 allow += 1\n3335             return Float(rv, allow)\n3336 \n3337 \n3338 class AtomicExpr(Atom, Expr):\n3339     \"\"\"\n3340     A parent class for object which are both atoms and Exprs.\n3341 \n3342     For example: Symbol, Number, Rational, Integer, ...\n3343     But not: Add, Mul, Pow, ...\n3344     \"\"\"\n3345     is_number = False\n3346     is_Atom = True\n3347 \n3348     __slots__ = []\n3349 \n3350     def _eval_derivative(self, s):\n3351         if self == s:\n3352             return S.One\n3353         return S.Zero\n3354 \n3355     def _eval_is_polynomial(self, syms):\n3356         return True\n3357 \n3358     def _eval_is_rational_function(self, syms):\n3359         return True\n3360 \n3361     def _eval_is_algebraic_expr(self, syms):\n3362         return True\n3363 \n3364     def _eval_nseries(self, x, n, logx):\n3365         return self\n3366 \n3367     @property\n3368     def expr_free_symbols(self):\n3369         return {self}\n3370 \n3371 \n3372 def _mag(x):\n3373     \"\"\"Return integer ``i`` such that .1 <= x/10**i < 1\n3374 \n3375     Examples\n3376     ========\n3377 \n3378     >>> from sympy.core.expr import _mag\n3379     >>> from sympy import Float\n3380     >>> _mag(Float(.1))\n3381     0\n3382     >>> _mag(Float(.01))\n3383     -1\n3384     >>> _mag(Float(1234))\n3385     4\n3386     \"\"\"\n3387     from math import log10, ceil, log\n3388     from sympy import Float\n3389     xpos = abs(x.n())\n3390     if not xpos:\n3391         return S.Zero\n3392     try:\n3393         mag_first_dig = int(ceil(log10(xpos)))\n3394     except (ValueError, OverflowError):\n3395         mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53))/log(10)))\n3396     # check that we aren't off by 1\n3397     if (xpos/10**mag_first_dig) >= 1:\n3398         assert 1 <= (xpos/10**mag_first_dig) < 10\n3399         mag_first_dig += 1\n3400     return mag_first_dig\n3401 \n3402 \n3403 class UnevaluatedExpr(Expr):\n3404     \"\"\"\n3405     Expression that is not evaluated unless released.\n3406 \n3407     Examples\n3408     ========\n3409 \n3410     >>> from sympy import UnevaluatedExpr\n3411     >>> from sympy.abc import a, b, x, y\n3412     >>> x*(1/x)\n3413     1\n3414     >>> x*UnevaluatedExpr(1/x)\n3415     x*1/x\n3416 \n3417     \"\"\"\n3418 \n3419     def __new__(cls, arg, **kwargs):\n3420         arg = _sympify(arg)\n3421         obj = Expr.__new__(cls, arg, **kwargs)\n3422         return obj\n3423 \n3424     def doit(self, *args, **kwargs):\n3425         if kwargs.get(\"deep\", True):\n3426             return self.args[0].doit(*args, **kwargs)\n3427         else:\n3428             return self.args[0]\n3429 \n3430 \n3431 def _n2(a, b):\n3432     \"\"\"Return (a - b).evalf(2) if a and b are comparable, else None.\n3433     This should only be used when a and b are already sympified.\n3434     \"\"\"\n3435     # /!\\ it is very important (see issue 8245) not to\n3436     # use a re-evaluated number in the calculation of dif\n3437     if a.is_comparable and b.is_comparable:\n3438         dif = (a - b).evalf(2)\n3439         if dif.is_comparable:\n3440             return dif\n3441 \n3442 \n3443 from .mul import Mul\n3444 from .add import Add\n3445 from .power import Pow\n3446 from .function import Derivative, Function\n3447 from .mod import Mod\n3448 from .exprtools import factor_terms\n3449 from .numbers import Integer, Rational\n",
        "intended_behavior": "Modifications or clarifications need to be made wherever `polylog` or manipulations involving `exp_polar(-I*pi)` are dealt with. Specifically, ensure that expansions or simplifications of `polylog` functions avoid unnecessary complexities or mathematically unsound transformations. The introduction of `exp_polar(-I*pi)` during simplification or expansion should be closely examined to ensure it is only applied when mathematically justified, faithfully reflecting the properties of `polylog` and related functions, particularly with respect to their branch cuts and continuity properties."
    },
    {
        "rel_file_path": "sympy/simplify/simplify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/simplify/simplify.py",
        "start": 1,
        "end": 1447,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from collections import defaultdict\n4 \n5 from sympy.core import (Basic, S, Add, Mul, Pow,\n6     Symbol, sympify, expand_mul, expand_func,\n7     Function, Dummy, Expr, factor_terms,\n8     symbols, expand_power_exp)\n9 from sympy.core.compatibility import (iterable,\n10     ordered, range, as_int)\n11 from sympy.core.numbers import Float, I, pi, Rational, Integer\n12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg, nfloat\n13 from sympy.core.rules import Transform\n14 from sympy.core.evaluate import global_evaluate\n15 from sympy.functions import (\n16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)\n17 from sympy.core.sympify import _sympify\n18 from sympy.functions.elementary.exponential import ExpBase\n19 from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n20 from sympy.functions.elementary.integers import ceiling\n21 from sympy.functions.elementary.complexes import unpolarify\n22 from sympy.functions.elementary.trigonometric import TrigonometricFunction\n23 from sympy.functions.combinatorial.factorials import CombinatorialFunction\n24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely\n25 \n26 from sympy.utilities.iterables import has_variety\n27 \n28 from sympy.simplify.radsimp import radsimp, fraction\n29 from sympy.simplify.trigsimp import trigsimp, exptrigsimp\n30 from sympy.simplify.powsimp import powsimp\n31 from sympy.simplify.cse_opts import sub_pre, sub_post\n32 from sympy.simplify.sqrtdenest import sqrtdenest\n33 from sympy.simplify.combsimp import combsimp\n34 \n35 from sympy.polys import (together, cancel, factor)\n36 \n37 \n38 import mpmath\n39 \n40 \n41 \n42 def separatevars(expr, symbols=[], dict=False, force=False):\n43     \"\"\"\n44     Separates variables in an expression, if possible.  By\n45     default, it separates with respect to all symbols in an\n46     expression and collects constant coefficients that are\n47     independent of symbols.\n48 \n49     If dict=True then the separated terms will be returned\n50     in a dictionary keyed to their corresponding symbols.\n51     By default, all symbols in the expression will appear as\n52     keys; if symbols are provided, then all those symbols will\n53     be used as keys, and any terms in the expression containing\n54     other symbols or non-symbols will be returned keyed to the\n55     string 'coeff'. (Passing None for symbols will return the\n56     expression in a dictionary keyed to 'coeff'.)\n57 \n58     If force=True, then bases of powers will be separated regardless\n59     of assumptions on the symbols involved.\n60 \n61     Notes\n62     =====\n63     The order of the factors is determined by Mul, so that the\n64     separated expressions may not necessarily be grouped together.\n65 \n66     Although factoring is necessary to separate variables in some\n67     expressions, it is not necessary in all cases, so one should not\n68     count on the returned factors being factored.\n69 \n70     Examples\n71     ========\n72 \n73     >>> from sympy.abc import x, y, z, alpha\n74     >>> from sympy import separatevars, sin\n75     >>> separatevars((x*y)**y)\n76     (x*y)**y\n77     >>> separatevars((x*y)**y, force=True)\n78     x**y*y**y\n79 \n80     >>> e = 2*x**2*z*sin(y)+2*z*x**2\n81     >>> separatevars(e)\n82     2*x**2*z*(sin(y) + 1)\n83     >>> separatevars(e, symbols=(x, y), dict=True)\n84     {'coeff': 2*z, x: x**2, y: sin(y) + 1}\n85     >>> separatevars(e, [x, y, alpha], dict=True)\n86     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}\n87 \n88     If the expression is not really separable, or is only partially\n89     separable, separatevars will do the best it can to separate it\n90     by using factoring.\n91 \n92     >>> separatevars(x + x*y - 3*x**2)\n93     -x*(3*x - y - 1)\n94 \n95     If the expression is not separable then expr is returned unchanged\n96     or (if dict=True) then None is returned.\n97 \n98     >>> eq = 2*x + y*sin(x)\n99     >>> separatevars(eq) == eq\n100     True\n101     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None\n102     True\n103 \n104     \"\"\"\n105     expr = sympify(expr)\n106     if dict:\n107         return _separatevars_dict(_separatevars(expr, force), symbols)\n108     else:\n109         return _separatevars(expr, force)\n110 \n111 \n112 def _separatevars(expr, force):\n113     if len(expr.free_symbols) == 1:\n114         return expr\n115     # don't destroy a Mul since much of the work may already be done\n116     if expr.is_Mul:\n117         args = list(expr.args)\n118         changed = False\n119         for i, a in enumerate(args):\n120             args[i] = separatevars(a, force)\n121             changed = changed or args[i] != a\n122         if changed:\n123             expr = expr.func(*args)\n124         return expr\n125 \n126     # get a Pow ready for expansion\n127     if expr.is_Pow:\n128         expr = Pow(separatevars(expr.base, force=force), expr.exp)\n129 \n130     # First try other expansion methods\n131     expr = expr.expand(mul=False, multinomial=False, force=force)\n132 \n133     _expr, reps = posify(expr) if force else (expr, {})\n134     expr = factor(_expr).subs(reps)\n135 \n136     if not expr.is_Add:\n137         return expr\n138 \n139     # Find any common coefficients to pull out\n140     args = list(expr.args)\n141     commonc = args[0].args_cnc(cset=True, warn=False)[0]\n142     for i in args[1:]:\n143         commonc &= i.args_cnc(cset=True, warn=False)[0]\n144     commonc = Mul(*commonc)\n145     commonc = commonc.as_coeff_Mul()[1]  # ignore constants\n146     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]\n147 \n148     # remove them\n149     for i, a in enumerate(args):\n150         c, nc = a.args_cnc(cset=True, warn=False)\n151         c = c - commonc_set\n152         args[i] = Mul(*c)*Mul(*nc)\n153     nonsepar = Add(*args)\n154 \n155     if len(nonsepar.free_symbols) > 1:\n156         _expr = nonsepar\n157         _expr, reps = posify(_expr) if force else (_expr, {})\n158         _expr = (factor(_expr)).subs(reps)\n159 \n160         if not _expr.is_Add:\n161             nonsepar = _expr\n162 \n163     return commonc*nonsepar\n164 \n165 \n166 def _separatevars_dict(expr, symbols):\n167     if symbols:\n168         if not all((t.is_Atom for t in symbols)):\n169             raise ValueError(\"symbols must be Atoms.\")\n170         symbols = list(symbols)\n171     elif symbols is None:\n172         return {'coeff': expr}\n173     else:\n174         symbols = list(expr.free_symbols)\n175         if not symbols:\n176             return None\n177 \n178     ret = dict(((i, []) for i in symbols + ['coeff']))\n179 \n180     for i in Mul.make_args(expr):\n181         expsym = i.free_symbols\n182         intersection = set(symbols).intersection(expsym)\n183         if len(intersection) > 1:\n184             return None\n185         if len(intersection) == 0:\n186             # There are no symbols, so it is part of the coefficient\n187             ret['coeff'].append(i)\n188         else:\n189             ret[intersection.pop()].append(i)\n190 \n191     # rebuild\n192     for k, v in ret.items():\n193         ret[k] = Mul(*v)\n194 \n195     return ret\n196 \n197 \n198 def _is_sum_surds(p):\n199     args = p.args if p.is_Add else [p]\n200     for y in args:\n201         if not ((y**2).is_Rational and y.is_real):\n202             return False\n203     return True\n204 \n205 \n206 def posify(eq):\n207     \"\"\"Return eq (with generic symbols made positive) and a\n208     dictionary containing the mapping between the old and new\n209     symbols.\n210 \n211     Any symbol that has positive=None will be replaced with a positive dummy\n212     symbol having the same name. This replacement will allow more symbolic\n213     processing of expressions, especially those involving powers and\n214     logarithms.\n215 \n216     A dictionary that can be sent to subs to restore eq to its original\n217     symbols is also returned.\n218 \n219     >>> from sympy import posify, Symbol, log, solve\n220     >>> from sympy.abc import x\n221     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))\n222     (_x + n + p, {_x: x})\n223 \n224     >>> eq = 1/x\n225     >>> log(eq).expand()\n226     log(1/x)\n227     >>> log(posify(eq)[0]).expand()\n228     -log(_x)\n229     >>> p, rep = posify(eq)\n230     >>> log(p).expand().subs(rep)\n231     -log(x)\n232 \n233     It is possible to apply the same transformations to an iterable\n234     of expressions:\n235 \n236     >>> eq = x**2 - 4\n237     >>> solve(eq, x)\n238     [-2, 2]\n239     >>> eq_x, reps = posify([eq, x]); eq_x\n240     [_x**2 - 4, _x]\n241     >>> solve(*eq_x)\n242     [2]\n243     \"\"\"\n244     eq = sympify(eq)\n245     if iterable(eq):\n246         f = type(eq)\n247         eq = list(eq)\n248         syms = set()\n249         for e in eq:\n250             syms = syms.union(e.atoms(Symbol))\n251         reps = {}\n252         for s in syms:\n253             reps.update(dict((v, k) for k, v in posify(s)[1].items()))\n254         for i, e in enumerate(eq):\n255             eq[i] = e.subs(reps)\n256         return f(eq), {r: s for s, r in reps.items()}\n257 \n258     reps = dict([(s, Dummy(s.name, positive=True))\n259                  for s in eq.free_symbols if s.is_positive is None])\n260     eq = eq.subs(reps)\n261     return eq, {r: s for s, r in reps.items()}\n262 \n263 \n264 def hypersimp(f, k):\n265     \"\"\"Given combinatorial term f(k) simplify its consecutive term ratio\n266        i.e. f(k+1)/f(k).  The input term can be composed of functions and\n267        integer sequences which have equivalent representation in terms\n268        of gamma special function.\n269 \n270        The algorithm performs three basic steps:\n271 \n272        1. Rewrite all functions in terms of gamma, if possible.\n273 \n274        2. Rewrite all occurrences of gamma in terms of products\n275           of gamma and rising factorial with integer,  absolute\n276           constant exponent.\n277 \n278        3. Perform simplification of nested fractions, powers\n279           and if the resulting expression is a quotient of\n280           polynomials, reduce their total degree.\n281 \n282        If f(k) is hypergeometric then as result we arrive with a\n283        quotient of polynomials of minimal degree. Otherwise None\n284        is returned.\n285 \n286        For more information on the implemented algorithm refer to:\n287 \n288        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,\n289           Journal of Symbolic Computation (1995) 20, 399-417\n290     \"\"\"\n291     f = sympify(f)\n292 \n293     g = f.subs(k, k + 1) / f\n294 \n295     g = g.rewrite(gamma)\n296     g = expand_func(g)\n297     g = powsimp(g, deep=True, combine='exp')\n298 \n299     if g.is_rational_function(k):\n300         return simplify(g, ratio=S.Infinity)\n301     else:\n302         return None\n303 \n304 \n305 def hypersimilar(f, g, k):\n306     \"\"\"Returns True if 'f' and 'g' are hyper-similar.\n307 \n308        Similarity in hypergeometric sense means that a quotient of\n309        f(k) and g(k) is a rational function in k.  This procedure\n310        is useful in solving recurrence relations.\n311 \n312        For more information see hypersimp().\n313 \n314     \"\"\"\n315     f, g = list(map(sympify, (f, g)))\n316 \n317     h = (f/g).rewrite(gamma)\n318     h = h.expand(func=True, basic=False)\n319 \n320     return h.is_rational_function(k)\n321 \n322 \n323 def signsimp(expr, evaluate=None):\n324     \"\"\"Make all Add sub-expressions canonical wrt sign.\n325 \n326     If an Add subexpression, ``a``, can have a sign extracted,\n327     as determined by could_extract_minus_sign, it is replaced\n328     with Mul(-1, a, evaluate=False). This allows signs to be\n329     extracted from powers and products.\n330 \n331     Examples\n332     ========\n333 \n334     >>> from sympy import signsimp, exp, symbols\n335     >>> from sympy.abc import x, y\n336     >>> i = symbols('i', odd=True)\n337     >>> n = -1 + 1/x\n338     >>> n/x/(-n)**2 - 1/n/x\n339     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))\n340     >>> signsimp(_)\n341     0\n342     >>> x*n + x*-n\n343     x*(-1 + 1/x) + x*(1 - 1/x)\n344     >>> signsimp(_)\n345     0\n346 \n347     Since powers automatically handle leading signs\n348 \n349     >>> (-2)**i\n350     -2**i\n351 \n352     signsimp can be used to put the base of a power with an integer\n353     exponent into canonical form:\n354 \n355     >>> n**i\n356     (-1 + 1/x)**i\n357 \n358     By default, signsimp doesn't leave behind any hollow simplification:\n359     if making an Add canonical wrt sign didn't change the expression, the\n360     original Add is restored. If this is not desired then the keyword\n361     ``evaluate`` can be set to False:\n362 \n363     >>> e = exp(y - x)\n364     >>> signsimp(e) == e\n365     True\n366     >>> signsimp(e, evaluate=False)\n367     exp(-(x - y))\n368 \n369     \"\"\"\n370     if evaluate is None:\n371         evaluate = global_evaluate[0]\n372     expr = sympify(expr)\n373     if not isinstance(expr, Expr) or expr.is_Atom:\n374         return expr\n375     e = sub_post(sub_pre(expr))\n376     if not isinstance(e, Expr) or e.is_Atom:\n377         return e\n378     if e.is_Add:\n379         return e.func(*[signsimp(a, evaluate) for a in e.args])\n380     if evaluate:\n381         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n382     return e\n383 \n384 \n385 def simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n386     # type: (object, object, object, object) -> object\n387     \"\"\"\n388     Simplifies the given expression.\n389 \n390     Simplification is not a well defined term and the exact strategies\n391     this function tries can change in the future versions of SymPy. If\n392     your algorithm relies on \"simplification\" (whatever it is), try to\n393     determine what you need exactly  -  is it powsimp()?, radsimp()?,\n394     together()?, logcombine()?, or something else? And use this particular\n395     function directly, because those are well defined and thus your algorithm\n396     will be robust.\n397 \n398     Nonetheless, especially for interactive use, or when you don't know\n399     anything about the structure of the expression, simplify() tries to apply\n400     intelligent heuristics to make the input expression \"simpler\".  For\n401     example:\n402 \n403     >>> from sympy import simplify, cos, sin\n404     >>> from sympy.abc import x, y\n405     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n406     >>> a\n407     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n408     >>> simplify(a)\n409     x + 1\n410 \n411     Note that we could have obtained the same result by using specific\n412     simplification functions:\n413 \n414     >>> from sympy import trigsimp, cancel\n415     >>> trigsimp(a)\n416     (x**2 + x)/x\n417     >>> cancel(_)\n418     x + 1\n419 \n420     In some cases, applying :func:`simplify` may actually result in some more\n421     complicated expression. The default ``ratio=1.7`` prevents more extreme\n422     cases: if (result length)/(input length) > ratio, then input is returned\n423     unmodified.  The ``measure`` parameter lets you specify the function used\n424     to determine how complex an expression is.  The function should take a\n425     single argument as an expression and return a number such that if\n426     expression ``a`` is more complex than expression ``b``, then\n427     ``measure(a) > measure(b)``.  The default measure function is\n428     :func:`count_ops`, which returns the total number of operations in the\n429     expression.\n430 \n431     For example, if ``ratio=1``, ``simplify`` output can't be longer\n432     than input.\n433 \n434     ::\n435 \n436         >>> from sympy import sqrt, simplify, count_ops, oo\n437         >>> root = 1/(sqrt(2)+3)\n438 \n439     Since ``simplify(root)`` would result in a slightly longer expression,\n440     root is returned unchanged instead::\n441 \n442        >>> simplify(root, ratio=1) == root\n443        True\n444 \n445     If ``ratio=oo``, simplify will be applied anyway::\n446 \n447         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n448         True\n449 \n450     Note that the shortest expression is not necessary the simplest, so\n451     setting ``ratio`` to 1 may not be a good idea.\n452     Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n453     choice.\n454 \n455     You can easily define your own measure function based on what you feel\n456     should represent the \"size\" or \"complexity\" of the input expression.  Note\n457     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n458     good metrics, but have other problems (in this case, the measure function\n459     may slow down simplify too much for very large expressions).  If you don't\n460     know what a good metric would be, the default, ``count_ops``, is a good\n461     one.\n462 \n463     For example:\n464 \n465     >>> from sympy import symbols, log\n466     >>> a, b = symbols('a b', positive=True)\n467     >>> g = log(a) + log(b) + log(a)*log(1/b)\n468     >>> h = simplify(g)\n469     >>> h\n470     log(a*b**(-log(a) + 1))\n471     >>> count_ops(g)\n472     8\n473     >>> count_ops(h)\n474     5\n475 \n476     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n477     However, we may not like how ``simplify`` (in this case, using\n478     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n479     to reduce this would be to give more weight to powers as operations in\n480     ``count_ops``.  We can do this by using the ``visual=True`` option:\n481 \n482     >>> print(count_ops(g, visual=True))\n483     2*ADD + DIV + 4*LOG + MUL\n484     >>> print(count_ops(h, visual=True))\n485     2*LOG + MUL + POW + SUB\n486 \n487     >>> from sympy import Symbol, S\n488     >>> def my_measure(expr):\n489     ...     POW = Symbol('POW')\n490     ...     # Discourage powers by giving POW a weight of 10\n491     ...     count = count_ops(expr, visual=True).subs(POW, 10)\n492     ...     # Every other operation gets a weight of 1 (the default)\n493     ...     count = count.replace(Symbol, type(S.One))\n494     ...     return count\n495     >>> my_measure(g)\n496     8\n497     >>> my_measure(h)\n498     14\n499     >>> 15./8 > 1.7 # 1.7 is the default ratio\n500     True\n501     >>> simplify(g, measure=my_measure)\n502     -log(a)*log(b) + log(a) + log(b)\n503 \n504     Note that because ``simplify()`` internally tries many different\n505     simplification strategies and then compares them using the measure\n506     function, we get a completely different result that is still different\n507     from the input expression by doing this.\n508 \n509     If rational=True, Floats will be recast as Rationals before simplification.\n510     If rational=None, Floats will be recast as Rationals but the result will\n511     be recast as Floats. If rational=False(default) then nothing will be done\n512     to the Floats.\n513     \"\"\"\n514     expr = sympify(expr)\n515 \n516     try:\n517         return expr._eval_simplify(ratio=ratio, measure=measure)\n518     except AttributeError:\n519         pass\n520 \n521     original_expr = expr = signsimp(expr)\n522 \n523     from sympy.simplify.hyperexpand import hyperexpand\n524     from sympy.functions.special.bessel import BesselBase\n525     from sympy import Sum, Product\n526 \n527     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n528         return expr\n529 \n530     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n531         if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n532             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n533                isinstance(expr.args[0], expr.inverse(argindex=1)):\n534                 return simplify(expr.args[0].args[0], ratio=ratio,\n535                                 measure=measure, rational=rational)\n536         return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n537                          for x in expr.args])\n538 \n539     # TODO: Apply different strategies, considering expression pattern:\n540     # is it a purely rational function? Is there any trigonometric function?...\n541     # See also https://github.com/sympy/sympy/pull/185.\n542 \n543     def shorter(*choices):\n544         '''Return the choice that has the fewest ops. In case of a tie,\n545         the expression listed first is selected.'''\n546         if not has_variety(choices):\n547             return choices[0]\n548         return min(choices, key=measure)\n549 \n550     # rationalize Floats\n551     floats = False\n552     if rational is not False and expr.has(Float):\n553         floats = True\n554         expr = nsimplify(expr, rational=True)\n555 \n556     expr = bottom_up(expr, lambda w: w.normal())\n557     expr = Mul(*powsimp(expr).as_content_primitive())\n558     _e = cancel(expr)\n559     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n560     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n561 \n562     if ratio is S.Infinity:\n563         expr = expr2\n564     else:\n565         expr = shorter(expr2, expr1, expr)\n566     if not isinstance(expr, Basic):  # XXX: temporary hack\n567         return expr\n568 \n569     expr = factor_terms(expr, sign=False)\n570 \n571     # hyperexpand automatically only works on hypergeometric terms\n572     expr = hyperexpand(expr)\n573 \n574     expr = piecewise_fold(expr)\n575 \n576     if expr.has(BesselBase):\n577         expr = besselsimp(expr)\n578 \n579     if expr.has(TrigonometricFunction, HyperbolicFunction):\n580         expr = trigsimp(expr, deep=True)\n581 \n582     if expr.has(log):\n583         expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n584 \n585     if expr.has(CombinatorialFunction, gamma):\n586         # expression with gamma functions or non-integer arguments is\n587         # automatically passed to gammasimp\n588         expr = combsimp(expr)\n589 \n590     if expr.has(Sum):\n591         expr = sum_simplify(expr)\n592 \n593     if expr.has(Product):\n594         expr = product_simplify(expr)\n595 \n596     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n597     short = shorter(short, cancel(short))\n598     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n599     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n600         short = exptrigsimp(short)\n601 \n602     # get rid of hollow 2-arg Mul factorization\n603     hollow_mul = Transform(\n604         lambda x: Mul(*x.args),\n605         lambda x:\n606         x.is_Mul and\n607         len(x.args) == 2 and\n608         x.args[0].is_Number and\n609         x.args[1].is_Add and\n610         x.is_commutative)\n611     expr = short.xreplace(hollow_mul)\n612 \n613     numer, denom = expr.as_numer_denom()\n614     if denom.is_Add:\n615         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n616         if n is not S.One:\n617             expr = (numer*n).expand()/d\n618 \n619     if expr.could_extract_minus_sign():\n620         n, d = fraction(expr)\n621         if d != 0:\n622             expr = signsimp(-n/(-d))\n623 \n624     if measure(expr) > ratio*measure(original_expr):\n625         expr = original_expr\n626 \n627     # restore floats\n628     if floats and rational is None:\n629         expr = nfloat(expr, exponent=False)\n630 \n631     return expr\n632 \n633 \n634 def sum_simplify(s):\n635     \"\"\"Main function for Sum simplification\"\"\"\n636     from sympy.concrete.summations import Sum\n637     from sympy.core.function import expand\n638 \n639     terms = Add.make_args(expand(s))\n640     s_t = [] # Sum Terms\n641     o_t = [] # Other Terms\n642 \n643     for term in terms:\n644         if isinstance(term, Mul):\n645             other = 1\n646             sum_terms = []\n647 \n648             if not term.has(Sum):\n649                 o_t.append(term)\n650                 continue\n651 \n652             mul_terms = Mul.make_args(term)\n653             for mul_term in mul_terms:\n654                 if isinstance(mul_term, Sum):\n655                     r = mul_term._eval_simplify()\n656                     sum_terms.extend(Add.make_args(r))\n657                 else:\n658                     other = other * mul_term\n659             if len(sum_terms):\n660                 #some simplification may have happened\n661                 #use if so\n662                 s_t.append(Mul(*sum_terms) * other)\n663             else:\n664                 o_t.append(other)\n665         elif isinstance(term, Sum):\n666             #as above, we need to turn this into an add list\n667             r = term._eval_simplify()\n668             s_t.extend(Add.make_args(r))\n669         else:\n670             o_t.append(term)\n671 \n672 \n673     result = Add(sum_combine(s_t), *o_t)\n674 \n675     return result\n676 \n677 def sum_combine(s_t):\n678     \"\"\"Helper function for Sum simplification\n679 \n680        Attempts to simplify a list of sums, by combining limits / sum function's\n681        returns the simplified sum\n682     \"\"\"\n683     from sympy.concrete.summations import Sum\n684 \n685 \n686     used = [False] * len(s_t)\n687 \n688     for method in range(2):\n689         for i, s_term1 in enumerate(s_t):\n690             if not used[i]:\n691                 for j, s_term2 in enumerate(s_t):\n692                     if not used[j] and i != j:\n693                         temp = sum_add(s_term1, s_term2, method)\n694                         if isinstance(temp, Sum) or isinstance(temp, Mul):\n695                             s_t[i] = temp\n696                             s_term1 = s_t[i]\n697                             used[j] = True\n698 \n699     result = S.Zero\n700     for i, s_term in enumerate(s_t):\n701         if not used[i]:\n702             result = Add(result, s_term)\n703 \n704     return result\n705 \n706 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):\n707     \"\"\"Helper function for Sum simplification\n708 \n709        if limits is specified, \"self\" is the inner part of a sum\n710 \n711        Returns the sum with constant factors brought outside\n712     \"\"\"\n713     from sympy.core.exprtools import factor_terms\n714     from sympy.concrete.summations import Sum\n715 \n716     result = self.function if limits is None else self\n717     limits = self.limits if limits is None else limits\n718     #avoid any confusion w/ as_independent\n719     if result == 0:\n720         return S.Zero\n721 \n722     #get the summation variables\n723     sum_vars = set([limit.args[0] for limit in limits])\n724 \n725     #finally we try to factor out any common terms\n726     #and remove the from the sum if independent\n727     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)\n728     #avoid doing anything bad\n729     if not result.is_commutative:\n730         return Sum(result, *limits)\n731 \n732     i, d = retv.as_independent(*sum_vars)\n733     if isinstance(retv, Add):\n734         return i * Sum(1, *limits) + Sum(d, *limits)\n735     else:\n736         return i * Sum(d, *limits)\n737 \n738 def sum_add(self, other, method=0):\n739     \"\"\"Helper function for Sum simplification\"\"\"\n740     from sympy.concrete.summations import Sum\n741     from sympy import Mul\n742 \n743     #we know this is something in terms of a constant * a sum\n744     #so we temporarily put the constants inside for simplification\n745     #then simplify the result\n746     def __refactor(val):\n747         args = Mul.make_args(val)\n748         sumv = next(x for x in args if isinstance(x, Sum))\n749         constant = Mul(*[x for x in args if x != sumv])\n750         return Sum(constant * sumv.function, *sumv.limits)\n751 \n752     if isinstance(self, Mul):\n753         rself = __refactor(self)\n754     else:\n755         rself = self\n756 \n757     if isinstance(other, Mul):\n758         rother = __refactor(other)\n759     else:\n760         rother = other\n761 \n762     if type(rself) == type(rother):\n763         if method == 0:\n764             if rself.limits == rother.limits:\n765                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))\n766         elif method == 1:\n767             if simplify(rself.function - rother.function) == 0:\n768                 if len(rself.limits) == len(rother.limits) == 1:\n769                     i = rself.limits[0][0]\n770                     x1 = rself.limits[0][1]\n771                     y1 = rself.limits[0][2]\n772                     j = rother.limits[0][0]\n773                     x2 = rother.limits[0][1]\n774                     y2 = rother.limits[0][2]\n775 \n776                     if i == j:\n777                         if x2 == y1 + 1:\n778                             return factor_sum(Sum(rself.function, (i, x1, y2)))\n779                         elif x1 == y2 + 1:\n780                             return factor_sum(Sum(rself.function, (i, x2, y1)))\n781 \n782     return Add(self, other)\n783 \n784 \n785 def product_simplify(s):\n786     \"\"\"Main function for Product simplification\"\"\"\n787     from sympy.concrete.products import Product\n788 \n789     terms = Mul.make_args(s)\n790     p_t = [] # Product Terms\n791     o_t = [] # Other Terms\n792 \n793     for term in terms:\n794         if isinstance(term, Product):\n795             p_t.append(term)\n796         else:\n797             o_t.append(term)\n798 \n799     used = [False] * len(p_t)\n800 \n801     for method in range(2):\n802         for i, p_term1 in enumerate(p_t):\n803             if not used[i]:\n804                 for j, p_term2 in enumerate(p_t):\n805                     if not used[j] and i != j:\n806                         if isinstance(product_mul(p_term1, p_term2, method), Product):\n807                             p_t[i] = product_mul(p_term1, p_term2, method)\n808                             used[j] = True\n809 \n810     result = Mul(*o_t)\n811 \n812     for i, p_term in enumerate(p_t):\n813         if not used[i]:\n814             result = Mul(result, p_term)\n815 \n816     return result\n817 \n818 \n819 def product_mul(self, other, method=0):\n820     \"\"\"Helper function for Product simplification\"\"\"\n821     from sympy.concrete.products import Product\n822 \n823     if type(self) == type(other):\n824         if method == 0:\n825             if self.limits == other.limits:\n826                 return Product(self.function * other.function, *self.limits)\n827         elif method == 1:\n828             if simplify(self.function - other.function) == 0:\n829                 if len(self.limits) == len(other.limits) == 1:\n830                     i = self.limits[0][0]\n831                     x1 = self.limits[0][1]\n832                     y1 = self.limits[0][2]\n833                     j = other.limits[0][0]\n834                     x2 = other.limits[0][1]\n835                     y2 = other.limits[0][2]\n836 \n837                     if i == j:\n838                         if x2 == y1 + 1:\n839                             return Product(self.function, (i, x1, y2))\n840                         elif x1 == y2 + 1:\n841                             return Product(self.function, (i, x2, y1))\n842 \n843     return Mul(self, other)\n844 \n845 \n846 def _nthroot_solve(p, n, prec):\n847     \"\"\"\n848      helper function for ``nthroot``\n849      It denests ``p**Rational(1, n)`` using its minimal polynomial\n850     \"\"\"\n851     from sympy.polys.numberfields import _minimal_polynomial_sq\n852     from sympy.solvers import solve\n853     while n % 2 == 0:\n854         p = sqrtdenest(sqrt(p))\n855         n = n // 2\n856     if n == 1:\n857         return p\n858     pn = p**Rational(1, n)\n859     x = Symbol('x')\n860     f = _minimal_polynomial_sq(p, n, x)\n861     if f is None:\n862         return None\n863     sols = solve(f, x)\n864     for sol in sols:\n865         if abs(sol - pn).n() < 1./10**prec:\n866             sol = sqrtdenest(sol)\n867             if _mexpand(sol**n) == p:\n868                 return sol\n869 \n870 \n871 def logcombine(expr, force=False):\n872     \"\"\"\n873     Takes logarithms and combines them using the following rules:\n874 \n875     - log(x) + log(y) == log(x*y) if both are not negative\n876     - a*log(x) == log(x**a) if x is positive and a is real\n877 \n878     If ``force`` is True then the assumptions above will be assumed to hold if\n879     there is no assumption already in place on a quantity. For example, if\n880     ``a`` is imaginary or the argument negative, force will not perform a\n881     combination but if ``a`` is a symbol with no assumptions the change will\n882     take place.\n883 \n884     Examples\n885     ========\n886 \n887     >>> from sympy import Symbol, symbols, log, logcombine, I\n888     >>> from sympy.abc import a, x, y, z\n889     >>> logcombine(a*log(x) + log(y) - log(z))\n890     a*log(x) + log(y) - log(z)\n891     >>> logcombine(a*log(x) + log(y) - log(z), force=True)\n892     log(x**a*y/z)\n893     >>> x,y,z = symbols('x,y,z', positive=True)\n894     >>> a = Symbol('a', real=True)\n895     >>> logcombine(a*log(x) + log(y) - log(z))\n896     log(x**a*y/z)\n897 \n898     The transformation is limited to factors and/or terms that\n899     contain logs, so the result depends on the initial state of\n900     expansion:\n901 \n902     >>> eq = (2 + 3*I)*log(x)\n903     >>> logcombine(eq, force=True) == eq\n904     True\n905     >>> logcombine(eq.expand(), force=True)\n906     log(x**2) + I*log(x**3)\n907 \n908     See Also\n909     ========\n910     posify: replace all symbols with symbols having positive assumptions\n911 \n912     \"\"\"\n913 \n914     def f(rv):\n915         if not (rv.is_Add or rv.is_Mul):\n916             return rv\n917 \n918         def gooda(a):\n919             # bool to tell whether the leading ``a`` in ``a*log(x)``\n920             # could appear as log(x**a)\n921             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow\n922                 (a.is_real or force and a.is_real is not False))\n923 \n924         def goodlog(l):\n925             # bool to tell whether log ``l``'s argument can combine with others\n926             a = l.args[0]\n927             return a.is_positive or force and a.is_nonpositive is not False\n928 \n929         other = []\n930         logs = []\n931         log1 = defaultdict(list)\n932         for a in Add.make_args(rv):\n933             if isinstance(a, log) and goodlog(a):\n934                 log1[()].append(([], a))\n935             elif not a.is_Mul:\n936                 other.append(a)\n937             else:\n938                 ot = []\n939                 co = []\n940                 lo = []\n941                 for ai in a.args:\n942                     if ai.is_Rational and ai < 0:\n943                         ot.append(S.NegativeOne)\n944                         co.append(-ai)\n945                     elif isinstance(ai, log) and goodlog(ai):\n946                         lo.append(ai)\n947                     elif gooda(ai):\n948                         co.append(ai)\n949                     else:\n950                         ot.append(ai)\n951                 if len(lo) > 1:\n952                     logs.append((ot, co, lo))\n953                 elif lo:\n954                     log1[tuple(ot)].append((co, lo[0]))\n955                 else:\n956                     other.append(a)\n957 \n958         # if there is only one log at each coefficient and none have\n959         # an exponent to place inside the log then there is nothing to do\n960         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):\n961             return rv\n962 \n963         # collapse multi-logs as far as possible in a canonical way\n964         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?\n965         # -- in this case, it's unambiguous, but if it were were a log(c) in\n966         # each term then it's arbitrary whether they are grouped by log(a) or\n967         # by log(c). So for now, just leave this alone; it's probably better to\n968         # let the user decide\n969         for o, e, l in logs:\n970             l = list(ordered(l))\n971             e = log(l.pop(0).args[0]**Mul(*e))\n972             while l:\n973                 li = l.pop(0)\n974                 e = log(li.args[0]**e)\n975             c, l = Mul(*o), e\n976             if isinstance(l, log):  # it should be, but check to be sure\n977                 log1[(c,)].append(([], l))\n978             else:\n979                 other.append(c*l)\n980 \n981         # logs that have the same coefficient can multiply\n982         for k in list(log1.keys()):\n983             log1[Mul(*k)] = log(logcombine(Mul(*[\n984                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),\n985                 force=force))\n986 \n987         # logs that have oppositely signed coefficients can divide\n988         for k in ordered(list(log1.keys())):\n989             if not k in log1:  # already popped as -k\n990                 continue\n991             if -k in log1:\n992                 # figure out which has the minus sign; the one with\n993                 # more op counts should be the one\n994                 num, den = k, -k\n995                 if num.count_ops() > den.count_ops():\n996                     num, den = den, num\n997                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))\n998             else:\n999                 other.append(k*log1.pop(k))\n1000 \n1001         return Add(*other)\n1002 \n1003     return bottom_up(expr, f)\n1004 \n1005 \n1006 def walk(e, *target):\n1007     \"\"\"iterate through the args that are the given types (target) and\n1008     return a list of the args that were traversed; arguments\n1009     that are not of the specified types are not traversed.\n1010 \n1011     Examples\n1012     ========\n1013 \n1014     >>> from sympy.simplify.simplify import walk\n1015     >>> from sympy import Min, Max\n1016     >>> from sympy.abc import x, y, z\n1017     >>> list(walk(Min(x, Max(y, Min(1, z))), Min))\n1018     [Min(x, Max(y, Min(1, z)))]\n1019     >>> list(walk(Min(x, Max(y, Min(1, z))), Min, Max))\n1020     [Min(x, Max(y, Min(1, z))), Max(y, Min(1, z)), Min(1, z)]\n1021 \n1022     See Also\n1023     ========\n1024     bottom_up\n1025     \"\"\"\n1026     if isinstance(e, target):\n1027         yield e\n1028         for i in e.args:\n1029             for w in walk(i, *target):\n1030                 yield w\n1031 \n1032 \n1033 def bottom_up(rv, F, atoms=False, nonbasic=False):\n1034     \"\"\"Apply ``F`` to all expressions in an expression tree from the\n1035     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n1036     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n1037     \"\"\"\n1038     try:\n1039         if rv.args:\n1040             args = tuple([bottom_up(a, F, atoms, nonbasic)\n1041                 for a in rv.args])\n1042             if args != rv.args:\n1043                 rv = rv.func(*args)\n1044             rv = F(rv)\n1045         elif atoms:\n1046             rv = F(rv)\n1047     except AttributeError:\n1048         if nonbasic:\n1049             try:\n1050                 rv = F(rv)\n1051             except TypeError:\n1052                 pass\n1053 \n1054     return rv\n1055 \n1056 \n1057 def besselsimp(expr):\n1058     \"\"\"\n1059     Simplify bessel-type functions.\n1060 \n1061     This routine tries to simplify bessel-type functions. Currently it only\n1062     works on the Bessel J and I functions, however. It works by looking at all\n1063     such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually\n1064     their polar equivalents) in front of the argument. Then, functions of\n1065     half-integer order are rewritten using strigonometric functions and\n1066     functions of integer order (> 1) are rewritten using functions\n1067     of low order.  Finally, if the expression was changed, compute\n1068     factorization of the result with factor().\n1069 \n1070     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S\n1071     >>> from sympy.abc import z, nu\n1072     >>> besselsimp(besselj(nu, z*polar_lift(-1)))\n1073     exp(I*pi*nu)*besselj(nu, z)\n1074     >>> besselsimp(besseli(nu, z*polar_lift(-I)))\n1075     exp(-I*pi*nu/2)*besselj(nu, z)\n1076     >>> besselsimp(besseli(S(-1)/2, z))\n1077     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))\n1078     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))\n1079     3*z*besseli(0, z)/2\n1080     \"\"\"\n1081     # TODO\n1082     # - better algorithm?\n1083     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...\n1084     # - use contiguity relations?\n1085 \n1086     def replacer(fro, to, factors):\n1087         factors = set(factors)\n1088 \n1089         def repl(nu, z):\n1090             if factors.intersection(Mul.make_args(z)):\n1091                 return to(nu, z)\n1092             return fro(nu, z)\n1093         return repl\n1094 \n1095     def torewrite(fro, to):\n1096         def tofunc(nu, z):\n1097             return fro(nu, z).rewrite(to)\n1098         return tofunc\n1099 \n1100     def tominus(fro):\n1101         def tofunc(nu, z):\n1102             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)\n1103         return tofunc\n1104 \n1105     orig_expr = expr\n1106 \n1107     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]\n1108     expr = expr.replace(\n1109         besselj, replacer(besselj,\n1110         torewrite(besselj, besseli), ifactors))\n1111     expr = expr.replace(\n1112         besseli, replacer(besseli,\n1113         torewrite(besseli, besselj), ifactors))\n1114 \n1115     minusfactors = [-1, exp_polar(I*pi)]\n1116     expr = expr.replace(\n1117         besselj, replacer(besselj, tominus(besselj), minusfactors))\n1118     expr = expr.replace(\n1119         besseli, replacer(besseli, tominus(besseli), minusfactors))\n1120 \n1121     z0 = Dummy('z')\n1122 \n1123     def expander(fro):\n1124         def repl(nu, z):\n1125             if (nu % 1) == S(1)/2:\n1126                 return simplify(trigsimp(unpolarify(\n1127                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(\n1128                             func=True)).subs(z0, z)))\n1129             elif nu.is_Integer and nu > 1:\n1130                 return fro(nu, z).expand(func=True)\n1131             return fro(nu, z)\n1132         return repl\n1133 \n1134     expr = expr.replace(besselj, expander(besselj))\n1135     expr = expr.replace(bessely, expander(bessely))\n1136     expr = expr.replace(besseli, expander(besseli))\n1137     expr = expr.replace(besselk, expander(besselk))\n1138 \n1139     if expr != orig_expr:\n1140         expr = expr.factor()\n1141 \n1142     return expr\n1143 \n1144 \n1145 def nthroot(expr, n, max_len=4, prec=15):\n1146     \"\"\"\n1147     compute a real nth-root of a sum of surds\n1148 \n1149     Parameters\n1150     ==========\n1151 \n1152     expr : sum of surds\n1153     n : integer\n1154     max_len : maximum number of surds passed as constants to ``nsimplify``\n1155 \n1156     Algorithm\n1157     =========\n1158 \n1159     First ``nsimplify`` is used to get a candidate root; if it is not a\n1160     root the minimal polynomial is computed; the answer is one of its\n1161     roots.\n1162 \n1163     Examples\n1164     ========\n1165 \n1166     >>> from sympy.simplify.simplify import nthroot\n1167     >>> from sympy import Rational, sqrt\n1168     >>> nthroot(90 + 34*sqrt(7), 3)\n1169     sqrt(7) + 3\n1170 \n1171     \"\"\"\n1172     expr = sympify(expr)\n1173     n = sympify(n)\n1174     p = expr**Rational(1, n)\n1175     if not n.is_integer:\n1176         return p\n1177     if not _is_sum_surds(expr):\n1178         return p\n1179     surds = []\n1180     coeff_muls = [x.as_coeff_Mul() for x in expr.args]\n1181     for x, y in coeff_muls:\n1182         if not x.is_rational:\n1183             return p\n1184         if y is S.One:\n1185             continue\n1186         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):\n1187             return p\n1188         surds.append(y)\n1189     surds.sort()\n1190     surds = surds[:max_len]\n1191     if expr < 0 and n % 2 == 1:\n1192         p = (-expr)**Rational(1, n)\n1193         a = nsimplify(p, constants=surds)\n1194         res = a if _mexpand(a**n) == _mexpand(-expr) else p\n1195         return -res\n1196     a = nsimplify(p, constants=surds)\n1197     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):\n1198         return _mexpand(a)\n1199     expr = _nthroot_solve(expr, n, prec)\n1200     if expr is None:\n1201         return p\n1202     return expr\n1203 \n1204 \n1205 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,\n1206     rational_conversion='base10'):\n1207     \"\"\"\n1208     Find a simple representation for a number or, if there are free symbols or\n1209     if rational=True, then replace Floats with their Rational equivalents. If\n1210     no change is made and rational is not False then Floats will at least be\n1211     converted to Rationals.\n1212 \n1213     For numerical expressions, a simple formula that numerically matches the\n1214     given numerical expression is sought (and the input should be possible\n1215     to evalf to a precision of at least 30 digits).\n1216 \n1217     Optionally, a list of (rationally independent) constants to\n1218     include in the formula may be given.\n1219 \n1220     A lower tolerance may be set to find less exact matches. If no tolerance\n1221     is given then the least precise value will set the tolerance (e.g. Floats\n1222     default to 15 digits of precision, so would be tolerance=10**-15).\n1223 \n1224     With full=True, a more extensive search is performed\n1225     (this is useful to find simpler numbers when the tolerance\n1226     is set low).\n1227 \n1228     When converting to rational, if rational_conversion='base10' (the default), then\n1229     convert floats to rationals using their base-10 (string) representation.\n1230     When rational_conversion='exact' it uses the exact, base-2 representation.\n1231 \n1232     Examples\n1233     ========\n1234 \n1235     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi\n1236     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n1237     -2 + 2*GoldenRatio\n1238     >>> nsimplify((1/(exp(3*pi*I/5)+1)))\n1239     1/2 - I*sqrt(sqrt(5)/10 + 1/4)\n1240     >>> nsimplify(I**I, [pi])\n1241     exp(-pi/2)\n1242     >>> nsimplify(pi, tolerance=0.01)\n1243     22/7\n1244 \n1245     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')\n1246     6004799503160655/18014398509481984\n1247     >>> nsimplify(0.333333333333333, rational=True)\n1248     1/3\n1249 \n1250     See Also\n1251     ========\n1252     sympy.core.function.nfloat\n1253 \n1254     \"\"\"\n1255     try:\n1256         return sympify(as_int(expr))\n1257     except (TypeError, ValueError):\n1258         pass\n1259     expr = sympify(expr).xreplace({\n1260         Float('inf'): S.Infinity,\n1261         Float('-inf'): S.NegativeInfinity,\n1262         })\n1263     if expr is S.Infinity or expr is S.NegativeInfinity:\n1264         return expr\n1265     if rational or expr.free_symbols:\n1266         return _real_to_rational(expr, tolerance, rational_conversion)\n1267 \n1268     # SymPy's default tolerance for Rationals is 15; other numbers may have\n1269     # lower tolerances set, so use them to pick the largest tolerance if None\n1270     # was given\n1271     if tolerance is None:\n1272         tolerance = 10**-min([15] +\n1273              [mpmath.libmp.libmpf.prec_to_dps(n._prec)\n1274              for n in expr.atoms(Float)])\n1275     # XXX should prec be set independent of tolerance or should it be computed\n1276     # from tolerance?\n1277     prec = 30\n1278     bprec = int(prec*3.33)\n1279 \n1280     constants_dict = {}\n1281     for constant in constants:\n1282         constant = sympify(constant)\n1283         v = constant.evalf(prec)\n1284         if not v.is_Float:\n1285             raise ValueError(\"constants must be real-valued\")\n1286         constants_dict[str(constant)] = v._to_mpmath(bprec)\n1287 \n1288     exprval = expr.evalf(prec, chop=True)\n1289     re, im = exprval.as_real_imag()\n1290 \n1291     # safety check to make sure that this evaluated to a number\n1292     if not (re.is_Number and im.is_Number):\n1293         return expr\n1294 \n1295     def nsimplify_real(x):\n1296         orig = mpmath.mp.dps\n1297         xv = x._to_mpmath(bprec)\n1298         try:\n1299             # We'll be happy with low precision if a simple fraction\n1300             if not (tolerance or full):\n1301                 mpmath.mp.dps = 15\n1302                 rat = mpmath.pslq([xv, 1])\n1303                 if rat is not None:\n1304                     return Rational(-int(rat[1]), int(rat[0]))\n1305             mpmath.mp.dps = prec\n1306             newexpr = mpmath.identify(xv, constants=constants_dict,\n1307                 tol=tolerance, full=full)\n1308             if not newexpr:\n1309                 raise ValueError\n1310             if full:\n1311                 newexpr = newexpr[0]\n1312             expr = sympify(newexpr)\n1313             if x and not expr:  # don't let x become 0\n1314                 raise ValueError\n1315             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:\n1316                 raise ValueError\n1317             return expr\n1318         finally:\n1319             # even though there are returns above, this is executed\n1320             # before leaving\n1321             mpmath.mp.dps = orig\n1322     try:\n1323         if re:\n1324             re = nsimplify_real(re)\n1325         if im:\n1326             im = nsimplify_real(im)\n1327     except ValueError:\n1328         if rational is None:\n1329             return _real_to_rational(expr, rational_conversion=rational_conversion)\n1330         return expr\n1331 \n1332     rv = re + im*S.ImaginaryUnit\n1333     # if there was a change or rational is explicitly not wanted\n1334     # return the value, else return the Rational representation\n1335     if rv != expr or rational is False:\n1336         return rv\n1337     return _real_to_rational(expr, rational_conversion=rational_conversion)\n1338 \n1339 \n1340 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):\n1341     \"\"\"\n1342     Replace all reals in expr with rationals.\n1343 \n1344     >>> from sympy import Rational\n1345     >>> from sympy.simplify.simplify import _real_to_rational\n1346     >>> from sympy.abc import x\n1347 \n1348     >>> _real_to_rational(.76 + .1*x**.5)\n1349     sqrt(x)/10 + 19/25\n1350 \n1351     If rational_conversion='base10', this uses the base-10 string. If\n1352     rational_conversion='exact', the exact, base-2 representation is used.\n1353 \n1354     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')\n1355     6004799503160655/18014398509481984\n1356     >>> _real_to_rational(0.333333333333333)\n1357     1/3\n1358 \n1359     \"\"\"\n1360     expr = _sympify(expr)\n1361     inf = Float('inf')\n1362     p = expr\n1363     reps = {}\n1364     reduce_num = None\n1365     if tolerance is not None and tolerance < 1:\n1366         reduce_num = ceiling(1/tolerance)\n1367     for fl in p.atoms(Float):\n1368         key = fl\n1369         if reduce_num is not None:\n1370             r = Rational(fl).limit_denominator(reduce_num)\n1371         elif (tolerance is not None and tolerance >= 1 and\n1372                 fl.is_Integer is False):\n1373             r = Rational(tolerance*round(fl/tolerance)\n1374                 ).limit_denominator(int(tolerance))\n1375         else:\n1376             if rational_conversion == 'exact':\n1377                 r = Rational(fl)\n1378                 reps[key] = r\n1379                 continue\n1380             elif rational_conversion != 'base10':\n1381                 raise ValueError(\"rational_conversion must be 'base10' or 'exact'\")\n1382 \n1383             r = nsimplify(fl, rational=False)\n1384             # e.g. log(3).n() -> log(3) instead of a Rational\n1385             if fl and not r:\n1386                 r = Rational(fl)\n1387             elif not r.is_Rational:\n1388                 if fl == inf or fl == -inf:\n1389                     r = S.ComplexInfinity\n1390                 elif fl < 0:\n1391                     fl = -fl\n1392                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))\n1393                     r = -Rational(str(fl/d))*d\n1394                 elif fl > 0:\n1395                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))\n1396                     r = Rational(str(fl/d))*d\n1397                 else:\n1398                     r = Integer(0)\n1399         reps[key] = r\n1400     return p.subs(reps, simultaneous=True)\n1401 \n1402 \n1403 def clear_coefficients(expr, rhs=S.Zero):\n1404     \"\"\"Return `p, r` where `p` is the expression obtained when Rational\n1405     additive and multiplicative coefficients of `expr` have been stripped\n1406     away in a naive fashion (i.e. without simplification). The operations\n1407     needed to remove the coefficients will be applied to `rhs` and returned\n1408     as `r`.\n1409 \n1410     Examples\n1411     ========\n1412 \n1413     >>> from sympy.simplify.simplify import clear_coefficients\n1414     >>> from sympy.abc import x, y\n1415     >>> from sympy import Dummy\n1416     >>> expr = 4*y*(6*x + 3)\n1417     >>> clear_coefficients(expr - 2)\n1418     (y*(2*x + 1), 1/6)\n1419 \n1420     When solving 2 or more expressions like `expr = a`,\n1421     `expr = b`, etc..., it is advantageous to provide a Dummy symbol\n1422     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.\n1423 \n1424     >>> rhs = Dummy('rhs')\n1425     >>> clear_coefficients(expr, rhs)\n1426     (y*(2*x + 1), _rhs/12)\n1427     >>> _[1].subs(rhs, 2)\n1428     1/6\n1429     \"\"\"\n1430     was = None\n1431     free = expr.free_symbols\n1432     if expr.is_Rational:\n1433         return (S.Zero, rhs - expr)\n1434     while expr and was != expr:\n1435         was = expr\n1436         m, expr = (\n1437             expr.as_content_primitive()\n1438             if free else\n1439             factor_terms(expr).as_coeff_Mul(rational=True))\n1440         rhs /= m\n1441         c, expr = expr.as_coeff_Add(rational=True)\n1442         rhs -= c\n1443     expr = signsimp(expr, evaluate = False)\n1444     if _coeff_isneg(expr):\n1445         expr = -expr\n1446         rhs = -rhs\n1447     return expr, rhs\n",
        "intended_behavior": "Modifications or clarifications need to be made wherever `polylog` or manipulations involving `exp_polar(-I*pi)` are dealt with. Specifically, ensure that expansions or simplifications of `polylog` functions avoid unnecessary complexities or mathematically unsound transformations. The introduction of `exp_polar(-I*pi)` during simplification or expansion should be closely examined to ensure it is only applied when mathematically justified, faithfully reflecting the properties of `polylog` and related functions, particularly with respect to their branch cuts and continuity properties."
    }
]