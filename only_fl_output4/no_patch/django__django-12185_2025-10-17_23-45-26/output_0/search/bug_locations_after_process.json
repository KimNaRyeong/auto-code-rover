[
    {
        "rel_file_path": "django/db/models/expressions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/expressions.py",
        "start": 1156,
        "end": 1247,
        "class_name": "Window",
        "method_name": null,
        "code": "1156 class Window(Expression):\n1157     template = '%(expression)s OVER (%(window)s)'\n1158     # Although the main expression may either be an aggregate or an\n1159     # expression with an aggregate function, the GROUP BY that will\n1160     # be introduced in the query as a result is not desired.\n1161     contains_aggregate = False\n1162     contains_over_clause = True\n1163     filterable = False\n1164 \n1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n1166         self.partition_by = partition_by\n1167         self.order_by = order_by\n1168         self.frame = frame\n1169 \n1170         if not getattr(expression, 'window_compatible', False):\n1171             raise ValueError(\n1172                 \"Expression '%s' isn't compatible with OVER clauses.\" %\n1173                 expression.__class__.__name__\n1174             )\n1175 \n1176         if self.partition_by is not None:\n1177             if not isinstance(self.partition_by, (tuple, list)):\n1178                 self.partition_by = (self.partition_by,)\n1179             self.partition_by = ExpressionList(*self.partition_by)\n1180 \n1181         if self.order_by is not None:\n1182             if isinstance(self.order_by, (list, tuple)):\n1183                 self.order_by = ExpressionList(*self.order_by)\n1184             elif not isinstance(self.order_by, BaseExpression):\n1185                 raise ValueError(\n1186                     'order_by must be either an Expression or a sequence of '\n1187                     'expressions.'\n1188                 )\n1189         super().__init__(output_field=output_field)\n1190         self.source_expression = self._parse_expressions(expression)[0]\n1191 \n1192     def _resolve_output_field(self):\n1193         return self.source_expression.output_field\n1194 \n1195     def get_source_expressions(self):\n1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n1197 \n1198     def set_source_expressions(self, exprs):\n1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n1200 \n1201     def as_sql(self, compiler, connection, template=None):\n1202         connection.ops.check_expression_support(self)\n1203         if not connection.features.supports_over_clause:\n1204             raise NotSupportedError('This backend does not support window expressions.')\n1205         expr_sql, params = compiler.compile(self.source_expression)\n1206         window_sql, window_params = [], []\n1207 \n1208         if self.partition_by is not None:\n1209             sql_expr, sql_params = self.partition_by.as_sql(\n1210                 compiler=compiler, connection=connection,\n1211                 template='PARTITION BY %(expressions)s',\n1212             )\n1213             window_sql.extend(sql_expr)\n1214             window_params.extend(sql_params)\n1215 \n1216         if self.order_by is not None:\n1217             window_sql.append(' ORDER BY ')\n1218             order_sql, order_params = compiler.compile(self.order_by)\n1219             window_sql.extend(order_sql)\n1220             window_params.extend(order_params)\n1221 \n1222         if self.frame:\n1223             frame_sql, frame_params = compiler.compile(self.frame)\n1224             window_sql.append(' ' + frame_sql)\n1225             window_params.extend(frame_params)\n1226 \n1227         params.extend(window_params)\n1228         template = template or self.template\n1229 \n1230         return template % {\n1231             'expression': expr_sql,\n1232             'window': ''.join(window_sql).strip()\n1233         }, params\n1234 \n1235     def __str__(self):\n1236         return '{} OVER ({}{}{})'.format(\n1237             str(self.source_expression),\n1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',\n1240             str(self.frame or ''),\n1241         )\n1242 \n1243     def __repr__(self):\n1244         return '<%s: %s>' % (self.__class__.__name__, self)\n1245 \n1246     def get_group_by_cols(self, alias=None):\n1247         return []\n",
        "intended_behavior": "The intended behavior should include a validation or compilation pathway that recognizes and correctly handles Window expressions when used in such a context, properly generating the SQL without raising errors, ensuring that the use of window functions in SELECT clause conditionals is supported as per SQL standards."
    },
    {
        "rel_file_path": "django/db/models/expressions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/expressions.py",
        "start": 1,
        "end": 1320,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import datetime\n3 import inspect\n4 from decimal import Decimal\n5 \n6 from django.core.exceptions import EmptyResultSet, FieldError\n7 from django.db import connection\n8 from django.db.models import fields\n9 from django.db.models.query_utils import Q\n10 from django.db.utils import NotSupportedError\n11 from django.utils.deconstruct import deconstructible\n12 from django.utils.functional import cached_property\n13 from django.utils.hashable import make_hashable\n14 \n15 \n16 class SQLiteNumericMixin:\n17     \"\"\"\n18     Some expressions with output_field=DecimalField() must be cast to\n19     numeric to be properly filtered.\n20     \"\"\"\n21     def as_sqlite(self, compiler, connection, **extra_context):\n22         sql, params = self.as_sql(compiler, connection, **extra_context)\n23         try:\n24             if self.output_field.get_internal_type() == 'DecimalField':\n25                 sql = 'CAST(%s AS NUMERIC)' % sql\n26         except FieldError:\n27             pass\n28         return sql, params\n29 \n30 \n31 class Combinable:\n32     \"\"\"\n33     Provide the ability to combine one or two objects with\n34     some connector. For example F('foo') + F('bar').\n35     \"\"\"\n36 \n37     # Arithmetic connectors\n38     ADD = '+'\n39     SUB = '-'\n40     MUL = '*'\n41     DIV = '/'\n42     POW = '^'\n43     # The following is a quoted % operator - it is quoted because it can be\n44     # used in strings that also have parameter substitution.\n45     MOD = '%%'\n46 \n47     # Bitwise operators - note that these are generated by .bitand()\n48     # and .bitor(), the '&' and '|' are reserved for boolean operator\n49     # usage.\n50     BITAND = '&'\n51     BITOR = '|'\n52     BITLEFTSHIFT = '<<'\n53     BITRIGHTSHIFT = '>>'\n54 \n55     def _combine(self, other, connector, reversed):\n56         if not hasattr(other, 'resolve_expression'):\n57             # everything must be resolvable to an expression\n58             if isinstance(other, datetime.timedelta):\n59                 other = DurationValue(other, output_field=fields.DurationField())\n60             else:\n61                 other = Value(other)\n62 \n63         if reversed:\n64             return CombinedExpression(other, connector, self)\n65         return CombinedExpression(self, connector, other)\n66 \n67     #############\n68     # OPERATORS #\n69     #############\n70 \n71     def __neg__(self):\n72         return self._combine(-1, self.MUL, False)\n73 \n74     def __add__(self, other):\n75         return self._combine(other, self.ADD, False)\n76 \n77     def __sub__(self, other):\n78         return self._combine(other, self.SUB, False)\n79 \n80     def __mul__(self, other):\n81         return self._combine(other, self.MUL, False)\n82 \n83     def __truediv__(self, other):\n84         return self._combine(other, self.DIV, False)\n85 \n86     def __mod__(self, other):\n87         return self._combine(other, self.MOD, False)\n88 \n89     def __pow__(self, other):\n90         return self._combine(other, self.POW, False)\n91 \n92     def __and__(self, other):\n93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n94             return Q(self) & Q(other)\n95         raise NotImplementedError(\n96             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n97         )\n98 \n99     def bitand(self, other):\n100         return self._combine(other, self.BITAND, False)\n101 \n102     def bitleftshift(self, other):\n103         return self._combine(other, self.BITLEFTSHIFT, False)\n104 \n105     def bitrightshift(self, other):\n106         return self._combine(other, self.BITRIGHTSHIFT, False)\n107 \n108     def __or__(self, other):\n109         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n110             return Q(self) | Q(other)\n111         raise NotImplementedError(\n112             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n113         )\n114 \n115     def bitor(self, other):\n116         return self._combine(other, self.BITOR, False)\n117 \n118     def __radd__(self, other):\n119         return self._combine(other, self.ADD, True)\n120 \n121     def __rsub__(self, other):\n122         return self._combine(other, self.SUB, True)\n123 \n124     def __rmul__(self, other):\n125         return self._combine(other, self.MUL, True)\n126 \n127     def __rtruediv__(self, other):\n128         return self._combine(other, self.DIV, True)\n129 \n130     def __rmod__(self, other):\n131         return self._combine(other, self.MOD, True)\n132 \n133     def __rpow__(self, other):\n134         return self._combine(other, self.POW, True)\n135 \n136     def __rand__(self, other):\n137         raise NotImplementedError(\n138             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n139         )\n140 \n141     def __ror__(self, other):\n142         raise NotImplementedError(\n143             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n144         )\n145 \n146 \n147 @deconstructible\n148 class BaseExpression:\n149     \"\"\"Base class for all query expressions.\"\"\"\n150 \n151     # aggregate specific fields\n152     is_summary = False\n153     _output_field_resolved_to_none = False\n154     # Can the expression be used in a WHERE clause?\n155     filterable = True\n156     # Can the expression can be used as a source expression in Window?\n157     window_compatible = False\n158 \n159     def __init__(self, output_field=None):\n160         if output_field is not None:\n161             self.output_field = output_field\n162 \n163     def __getstate__(self):\n164         state = self.__dict__.copy()\n165         state.pop('convert_value', None)\n166         return state\n167 \n168     def get_db_converters(self, connection):\n169         return (\n170             []\n171             if self.convert_value is self._convert_value_noop else\n172             [self.convert_value]\n173         ) + self.output_field.get_db_converters(connection)\n174 \n175     def get_source_expressions(self):\n176         return []\n177 \n178     def set_source_expressions(self, exprs):\n179         assert not exprs\n180 \n181     def _parse_expressions(self, *expressions):\n182         return [\n183             arg if hasattr(arg, 'resolve_expression') else (\n184                 F(arg) if isinstance(arg, str) else Value(arg)\n185             ) for arg in expressions\n186         ]\n187 \n188     def as_sql(self, compiler, connection):\n189         \"\"\"\n190         Responsible for returning a (sql, [params]) tuple to be included\n191         in the current query.\n192 \n193         Different backends can provide their own implementation, by\n194         providing an `as_{vendor}` method and patching the Expression:\n195 \n196         ```\n197         def override_as_sql(self, compiler, connection):\n198             # custom logic\n199             return super().as_sql(compiler, connection)\n200         setattr(Expression, 'as_' + connection.vendor, override_as_sql)\n201         ```\n202 \n203         Arguments:\n204          * compiler: the query compiler responsible for generating the query.\n205            Must have a compile method, returning a (sql, [params]) tuple.\n206            Calling compiler(value) will return a quoted `value`.\n207 \n208          * connection: the database connection used for the current query.\n209 \n210         Return: (sql, params)\n211           Where `sql` is a string containing ordered sql parameters to be\n212           replaced with the elements of the list `params`.\n213         \"\"\"\n214         raise NotImplementedError(\"Subclasses must implement as_sql()\")\n215 \n216     @cached_property\n217     def contains_aggregate(self):\n218         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())\n219 \n220     @cached_property\n221     def contains_over_clause(self):\n222         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())\n223 \n224     @cached_property\n225     def contains_column_references(self):\n226         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())\n227 \n228     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n229         \"\"\"\n230         Provide the chance to do any preprocessing or validation before being\n231         added to the query.\n232 \n233         Arguments:\n234          * query: the backend query implementation\n235          * allow_joins: boolean allowing or denying use of joins\n236            in this query\n237          * reuse: a set of reusable joins for multijoins\n238          * summarize: a terminal aggregate clause\n239          * for_save: whether this expression about to be used in a save or update\n240 \n241         Return: an Expression to be added to the query.\n242         \"\"\"\n243         c = self.copy()\n244         c.is_summary = summarize\n245         c.set_source_expressions([\n246             expr.resolve_expression(query, allow_joins, reuse, summarize)\n247             if expr else None\n248             for expr in c.get_source_expressions()\n249         ])\n250         return c\n251 \n252     @property\n253     def conditional(self):\n254         return isinstance(self.output_field, fields.BooleanField)\n255 \n256     @property\n257     def field(self):\n258         return self.output_field\n259 \n260     @cached_property\n261     def output_field(self):\n262         \"\"\"Return the output type of this expressions.\"\"\"\n263         output_field = self._resolve_output_field()\n264         if output_field is None:\n265             self._output_field_resolved_to_none = True\n266             raise FieldError('Cannot resolve expression type, unknown output_field')\n267         return output_field\n268 \n269     @cached_property\n270     def _output_field_or_none(self):\n271         \"\"\"\n272         Return the output field of this expression, or None if\n273         _resolve_output_field() didn't return an output type.\n274         \"\"\"\n275         try:\n276             return self.output_field\n277         except FieldError:\n278             if not self._output_field_resolved_to_none:\n279                 raise\n280 \n281     def _resolve_output_field(self):\n282         \"\"\"\n283         Attempt to infer the output type of the expression. If the output\n284         fields of all source fields match then, simply infer the same type\n285         here. This isn't always correct, but it makes sense most of the time.\n286 \n287         Consider the difference between `2 + 2` and `2 / 3`. Inferring\n288         the type here is a convenience for the common case. The user should\n289         supply their own output_field with more complex computations.\n290 \n291         If a source's output field resolves to None, exclude it from this check.\n292         If all sources are None, then an error is raised higher up the stack in\n293         the output_field property.\n294         \"\"\"\n295         sources_iter = (source for source in self.get_source_fields() if source is not None)\n296         for output_field in sources_iter:\n297             for source in sources_iter:\n298                 if not isinstance(output_field, source.__class__):\n299                     raise FieldError(\n300                         'Expression contains mixed types: %s, %s. You must '\n301                         'set output_field.' % (\n302                             output_field.__class__.__name__,\n303                             source.__class__.__name__,\n304                         )\n305                     )\n306             return output_field\n307 \n308     @staticmethod\n309     def _convert_value_noop(value, expression, connection):\n310         return value\n311 \n312     @cached_property\n313     def convert_value(self):\n314         \"\"\"\n315         Expressions provide their own converters because users have the option\n316         of manually specifying the output_field which may be a different type\n317         from the one the database returns.\n318         \"\"\"\n319         field = self.output_field\n320         internal_type = field.get_internal_type()\n321         if internal_type == 'FloatField':\n322             return lambda value, expression, connection: None if value is None else float(value)\n323         elif internal_type.endswith('IntegerField'):\n324             return lambda value, expression, connection: None if value is None else int(value)\n325         elif internal_type == 'DecimalField':\n326             return lambda value, expression, connection: None if value is None else Decimal(value)\n327         return self._convert_value_noop\n328 \n329     def get_lookup(self, lookup):\n330         return self.output_field.get_lookup(lookup)\n331 \n332     def get_transform(self, name):\n333         return self.output_field.get_transform(name)\n334 \n335     def relabeled_clone(self, change_map):\n336         clone = self.copy()\n337         clone.set_source_expressions([\n338             e.relabeled_clone(change_map) if e is not None else None\n339             for e in self.get_source_expressions()\n340         ])\n341         return clone\n342 \n343     def copy(self):\n344         return copy.copy(self)\n345 \n346     def get_group_by_cols(self, alias=None):\n347         if not self.contains_aggregate:\n348             return [self]\n349         cols = []\n350         for source in self.get_source_expressions():\n351             cols.extend(source.get_group_by_cols())\n352         return cols\n353 \n354     def get_source_fields(self):\n355         \"\"\"Return the underlying field types used by this aggregate.\"\"\"\n356         return [e._output_field_or_none for e in self.get_source_expressions()]\n357 \n358     def asc(self, **kwargs):\n359         return OrderBy(self, **kwargs)\n360 \n361     def desc(self, **kwargs):\n362         return OrderBy(self, descending=True, **kwargs)\n363 \n364     def reverse_ordering(self):\n365         return self\n366 \n367     def flatten(self):\n368         \"\"\"\n369         Recursively yield this expression and all subexpressions, in\n370         depth-first order.\n371         \"\"\"\n372         yield self\n373         for expr in self.get_source_expressions():\n374             if expr:\n375                 yield from expr.flatten()\n376 \n377     def select_format(self, compiler, sql, params):\n378         \"\"\"\n379         Custom format for select clauses. For example, EXISTS expressions need\n380         to be wrapped in CASE WHEN on Oracle.\n381         \"\"\"\n382         return self.output_field.select_format(compiler, sql, params)\n383 \n384     @cached_property\n385     def identity(self):\n386         constructor_signature = inspect.signature(self.__init__)\n387         args, kwargs = self._constructor_args\n388         signature = constructor_signature.bind_partial(*args, **kwargs)\n389         signature.apply_defaults()\n390         arguments = signature.arguments.items()\n391         identity = [self.__class__]\n392         for arg, value in arguments:\n393             if isinstance(value, fields.Field):\n394                 if value.name and value.model:\n395                     value = (value.model._meta.label, value.name)\n396                 else:\n397                     value = type(value)\n398             else:\n399                 value = make_hashable(value)\n400             identity.append((arg, value))\n401         return tuple(identity)\n402 \n403     def __eq__(self, other):\n404         if not isinstance(other, BaseExpression):\n405             return NotImplemented\n406         return other.identity == self.identity\n407 \n408     def __hash__(self):\n409         return hash(self.identity)\n410 \n411 \n412 class Expression(BaseExpression, Combinable):\n413     \"\"\"An expression that can be combined with other expressions.\"\"\"\n414     pass\n415 \n416 \n417 class CombinedExpression(SQLiteNumericMixin, Expression):\n418 \n419     def __init__(self, lhs, connector, rhs, output_field=None):\n420         super().__init__(output_field=output_field)\n421         self.connector = connector\n422         self.lhs = lhs\n423         self.rhs = rhs\n424 \n425     def __repr__(self):\n426         return \"<{}: {}>\".format(self.__class__.__name__, self)\n427 \n428     def __str__(self):\n429         return \"{} {} {}\".format(self.lhs, self.connector, self.rhs)\n430 \n431     def get_source_expressions(self):\n432         return [self.lhs, self.rhs]\n433 \n434     def set_source_expressions(self, exprs):\n435         self.lhs, self.rhs = exprs\n436 \n437     def as_sql(self, compiler, connection):\n438         try:\n439             lhs_output = self.lhs.output_field\n440         except FieldError:\n441             lhs_output = None\n442         try:\n443             rhs_output = self.rhs.output_field\n444         except FieldError:\n445             rhs_output = None\n446         if (not connection.features.has_native_duration_field and\n447                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or\n448                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):\n449             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n450         if (lhs_output and rhs_output and self.connector == self.SUB and\n451             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and\n452                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):\n453             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n454         expressions = []\n455         expression_params = []\n456         sql, params = compiler.compile(self.lhs)\n457         expressions.append(sql)\n458         expression_params.extend(params)\n459         sql, params = compiler.compile(self.rhs)\n460         expressions.append(sql)\n461         expression_params.extend(params)\n462         # order of precedence\n463         expression_wrapper = '(%s)'\n464         sql = connection.ops.combine_expression(self.connector, expressions)\n465         return expression_wrapper % sql, expression_params\n466 \n467     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n468         c = self.copy()\n469         c.is_summary = summarize\n470         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n471         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n472         return c\n473 \n474 \n475 class DurationExpression(CombinedExpression):\n476     def compile(self, side, compiler, connection):\n477         if not isinstance(side, DurationValue):\n478             try:\n479                 output = side.output_field\n480             except FieldError:\n481                 pass\n482             else:\n483                 if output.get_internal_type() == 'DurationField':\n484                     sql, params = compiler.compile(side)\n485                     return connection.ops.format_for_duration_arithmetic(sql), params\n486         return compiler.compile(side)\n487 \n488     def as_sql(self, compiler, connection):\n489         connection.ops.check_expression_support(self)\n490         expressions = []\n491         expression_params = []\n492         sql, params = self.compile(self.lhs, compiler, connection)\n493         expressions.append(sql)\n494         expression_params.extend(params)\n495         sql, params = self.compile(self.rhs, compiler, connection)\n496         expressions.append(sql)\n497         expression_params.extend(params)\n498         # order of precedence\n499         expression_wrapper = '(%s)'\n500         sql = connection.ops.combine_duration_expression(self.connector, expressions)\n501         return expression_wrapper % sql, expression_params\n502 \n503 \n504 class TemporalSubtraction(CombinedExpression):\n505     output_field = fields.DurationField()\n506 \n507     def __init__(self, lhs, rhs):\n508         super().__init__(lhs, self.SUB, rhs)\n509 \n510     def as_sql(self, compiler, connection):\n511         connection.ops.check_expression_support(self)\n512         lhs = compiler.compile(self.lhs)\n513         rhs = compiler.compile(self.rhs)\n514         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)\n515 \n516 \n517 @deconstructible\n518 class F(Combinable):\n519     \"\"\"An object capable of resolving references to existing query objects.\"\"\"\n520 \n521     def __init__(self, name):\n522         \"\"\"\n523         Arguments:\n524          * name: the name of the field this expression references\n525         \"\"\"\n526         self.name = name\n527 \n528     def __repr__(self):\n529         return \"{}({})\".format(self.__class__.__name__, self.name)\n530 \n531     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n532                            summarize=False, for_save=False):\n533         return query.resolve_ref(self.name, allow_joins, reuse, summarize)\n534 \n535     def asc(self, **kwargs):\n536         return OrderBy(self, **kwargs)\n537 \n538     def desc(self, **kwargs):\n539         return OrderBy(self, descending=True, **kwargs)\n540 \n541     def __eq__(self, other):\n542         return self.__class__ == other.__class__ and self.name == other.name\n543 \n544     def __hash__(self):\n545         return hash(self.name)\n546 \n547 \n548 class ResolvedOuterRef(F):\n549     \"\"\"\n550     An object that contains a reference to an outer query.\n551 \n552     In this case, the reference to the outer query has been resolved because\n553     the inner query has been used as a subquery.\n554     \"\"\"\n555     contains_aggregate = False\n556 \n557     def as_sql(self, *args, **kwargs):\n558         raise ValueError(\n559             'This queryset contains a reference to an outer query and may '\n560             'only be used in a subquery.'\n561         )\n562 \n563     def relabeled_clone(self, relabels):\n564         return self\n565 \n566 \n567 class OuterRef(F):\n568     def resolve_expression(self, *args, **kwargs):\n569         if isinstance(self.name, self.__class__):\n570             return self.name\n571         return ResolvedOuterRef(self.name)\n572 \n573 \n574 class Func(SQLiteNumericMixin, Expression):\n575     \"\"\"An SQL function call.\"\"\"\n576     function = None\n577     template = '%(function)s(%(expressions)s)'\n578     arg_joiner = ', '\n579     arity = None  # The number of arguments the function accepts.\n580 \n581     def __init__(self, *expressions, output_field=None, **extra):\n582         if self.arity is not None and len(expressions) != self.arity:\n583             raise TypeError(\n584                 \"'%s' takes exactly %s %s (%s given)\" % (\n585                     self.__class__.__name__,\n586                     self.arity,\n587                     \"argument\" if self.arity == 1 else \"arguments\",\n588                     len(expressions),\n589                 )\n590             )\n591         super().__init__(output_field=output_field)\n592         self.source_expressions = self._parse_expressions(*expressions)\n593         self.extra = extra\n594 \n595     def __repr__(self):\n596         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n597         extra = {**self.extra, **self._get_repr_options()}\n598         if extra:\n599             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))\n600             return \"{}({}, {})\".format(self.__class__.__name__, args, extra)\n601         return \"{}({})\".format(self.__class__.__name__, args)\n602 \n603     def _get_repr_options(self):\n604         \"\"\"Return a dict of extra __init__() options to include in the repr.\"\"\"\n605         return {}\n606 \n607     def get_source_expressions(self):\n608         return self.source_expressions\n609 \n610     def set_source_expressions(self, exprs):\n611         self.source_expressions = exprs\n612 \n613     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n614         c = self.copy()\n615         c.is_summary = summarize\n616         for pos, arg in enumerate(c.source_expressions):\n617             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n618         return c\n619 \n620     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):\n621         connection.ops.check_expression_support(self)\n622         sql_parts = []\n623         params = []\n624         for arg in self.source_expressions:\n625             arg_sql, arg_params = compiler.compile(arg)\n626             sql_parts.append(arg_sql)\n627             params.extend(arg_params)\n628         data = {**self.extra, **extra_context}\n629         # Use the first supplied value in this order: the parameter to this\n630         # method, a value supplied in __init__()'s **extra (the value in\n631         # `data`), or the value defined on the class.\n632         if function is not None:\n633             data['function'] = function\n634         else:\n635             data.setdefault('function', self.function)\n636         template = template or data.get('template', self.template)\n637         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)\n638         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)\n639         return template % data, params\n640 \n641     def copy(self):\n642         copy = super().copy()\n643         copy.source_expressions = self.source_expressions[:]\n644         copy.extra = self.extra.copy()\n645         return copy\n646 \n647 \n648 class Value(Expression):\n649     \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n650     def __init__(self, value, output_field=None):\n651         \"\"\"\n652         Arguments:\n653          * value: the value this expression represents. The value will be\n654            added into the sql parameter list and properly quoted.\n655 \n656          * output_field: an instance of the model field type that this\n657            expression will return, such as IntegerField() or CharField().\n658         \"\"\"\n659         super().__init__(output_field=output_field)\n660         self.value = value\n661 \n662     def __repr__(self):\n663         return \"{}({})\".format(self.__class__.__name__, self.value)\n664 \n665     def as_sql(self, compiler, connection):\n666         connection.ops.check_expression_support(self)\n667         val = self.value\n668         output_field = self._output_field_or_none\n669         if output_field is not None:\n670             if self.for_save:\n671                 val = output_field.get_db_prep_save(val, connection=connection)\n672             else:\n673                 val = output_field.get_db_prep_value(val, connection=connection)\n674             if hasattr(output_field, 'get_placeholder'):\n675                 return output_field.get_placeholder(val, compiler, connection), [val]\n676         if val is None:\n677             # cx_Oracle does not always convert None to the appropriate\n678             # NULL type (like in case expressions using numbers), so we\n679             # use a literal SQL NULL\n680             return 'NULL', []\n681         return '%s', [val]\n682 \n683     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n684         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n685         c.for_save = for_save\n686         return c\n687 \n688     def get_group_by_cols(self, alias=None):\n689         return []\n690 \n691 \n692 class DurationValue(Value):\n693     def as_sql(self, compiler, connection):\n694         connection.ops.check_expression_support(self)\n695         if connection.features.has_native_duration_field:\n696             return super().as_sql(compiler, connection)\n697         return connection.ops.date_interval_sql(self.value), []\n698 \n699 \n700 class RawSQL(Expression):\n701     def __init__(self, sql, params, output_field=None):\n702         if output_field is None:\n703             output_field = fields.Field()\n704         self.sql, self.params = sql, params\n705         super().__init__(output_field=output_field)\n706 \n707     def __repr__(self):\n708         return \"{}({}, {})\".format(self.__class__.__name__, self.sql, self.params)\n709 \n710     def as_sql(self, compiler, connection):\n711         return '(%s)' % self.sql, self.params\n712 \n713     def get_group_by_cols(self, alias=None):\n714         return [self]\n715 \n716     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n717         # Resolve parents fields used in raw SQL.\n718         for parent in query.model._meta.get_parent_list():\n719             for parent_field in parent._meta.local_fields:\n720                 _, column_name = parent_field.get_attname_column()\n721                 if column_name.lower() in self.sql.lower():\n722                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)\n723                     break\n724         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n725 \n726 \n727 class Star(Expression):\n728     def __repr__(self):\n729         return \"'*'\"\n730 \n731     def as_sql(self, compiler, connection):\n732         return '*', []\n733 \n734 \n735 class Random(Expression):\n736     output_field = fields.FloatField()\n737 \n738     def __repr__(self):\n739         return \"Random()\"\n740 \n741     def as_sql(self, compiler, connection):\n742         return connection.ops.random_function_sql(), []\n743 \n744 \n745 class Col(Expression):\n746 \n747     contains_column_references = True\n748 \n749     def __init__(self, alias, target, output_field=None):\n750         if output_field is None:\n751             output_field = target\n752         super().__init__(output_field=output_field)\n753         self.alias, self.target = alias, target\n754 \n755     def __repr__(self):\n756         alias, target = self.alias, self.target\n757         identifiers = (alias, str(target)) if alias else (str(target),)\n758         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))\n759 \n760     def as_sql(self, compiler, connection):\n761         alias, column = self.alias, self.target.column\n762         identifiers = (alias, column) if alias else (column,)\n763         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n764         return sql, []\n765 \n766     def relabeled_clone(self, relabels):\n767         if self.alias is None:\n768             return self\n769         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)\n770 \n771     def get_group_by_cols(self, alias=None):\n772         return [self]\n773 \n774     def get_db_converters(self, connection):\n775         if self.target == self.output_field:\n776             return self.output_field.get_db_converters(connection)\n777         return (self.output_field.get_db_converters(connection) +\n778                 self.target.get_db_converters(connection))\n779 \n780 \n781 class Ref(Expression):\n782     \"\"\"\n783     Reference to column alias of the query. For example, Ref('sum_cost') in\n784     qs.annotate(sum_cost=Sum('cost')) query.\n785     \"\"\"\n786     def __init__(self, refs, source):\n787         super().__init__()\n788         self.refs, self.source = refs, source\n789 \n790     def __repr__(self):\n791         return \"{}({}, {})\".format(self.__class__.__name__, self.refs, self.source)\n792 \n793     def get_source_expressions(self):\n794         return [self.source]\n795 \n796     def set_source_expressions(self, exprs):\n797         self.source, = exprs\n798 \n799     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n800         # The sub-expression `source` has already been resolved, as this is\n801         # just a reference to the name of `source`.\n802         return self\n803 \n804     def relabeled_clone(self, relabels):\n805         return self\n806 \n807     def as_sql(self, compiler, connection):\n808         return connection.ops.quote_name(self.refs), []\n809 \n810     def get_group_by_cols(self, alias=None):\n811         return [self]\n812 \n813 \n814 class ExpressionList(Func):\n815     \"\"\"\n816     An expression containing multiple expressions. Can be used to provide a\n817     list of expressions as an argument to another expression, like an\n818     ordering clause.\n819     \"\"\"\n820     template = '%(expressions)s'\n821 \n822     def __init__(self, *expressions, **extra):\n823         if not expressions:\n824             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)\n825         super().__init__(*expressions, **extra)\n826 \n827     def __str__(self):\n828         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n829 \n830 \n831 class ExpressionWrapper(Expression):\n832     \"\"\"\n833     An expression that can wrap another expression so that it can provide\n834     extra context to the inner expression, such as the output_field.\n835     \"\"\"\n836 \n837     def __init__(self, expression, output_field):\n838         super().__init__(output_field=output_field)\n839         self.expression = expression\n840 \n841     def set_source_expressions(self, exprs):\n842         self.expression = exprs[0]\n843 \n844     def get_source_expressions(self):\n845         return [self.expression]\n846 \n847     def as_sql(self, compiler, connection):\n848         return self.expression.as_sql(compiler, connection)\n849 \n850     def __repr__(self):\n851         return \"{}({})\".format(self.__class__.__name__, self.expression)\n852 \n853 \n854 class When(Expression):\n855     template = 'WHEN %(condition)s THEN %(result)s'\n856     # This isn't a complete conditional expression, must be used in Case().\n857     conditional = False\n858 \n859     def __init__(self, condition=None, then=None, **lookups):\n860         if lookups and condition is None:\n861             condition, lookups = Q(**lookups), None\n862         if condition is None or not getattr(condition, 'conditional', False) or lookups:\n863             raise TypeError(\n864                 'When() supports a Q object, a boolean expression, or lookups '\n865                 'as a condition.'\n866             )\n867         if isinstance(condition, Q) and not condition:\n868             raise ValueError(\"An empty Q() can't be used as a When() condition.\")\n869         super().__init__(output_field=None)\n870         self.condition = condition\n871         self.result = self._parse_expressions(then)[0]\n872 \n873     def __str__(self):\n874         return \"WHEN %r THEN %r\" % (self.condition, self.result)\n875 \n876     def __repr__(self):\n877         return \"<%s: %s>\" % (self.__class__.__name__, self)\n878 \n879     def get_source_expressions(self):\n880         return [self.condition, self.result]\n881 \n882     def set_source_expressions(self, exprs):\n883         self.condition, self.result = exprs\n884 \n885     def get_source_fields(self):\n886         # We're only interested in the fields of the result expressions.\n887         return [self.result._output_field_or_none]\n888 \n889     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n890         c = self.copy()\n891         c.is_summary = summarize\n892         if hasattr(c.condition, 'resolve_expression'):\n893             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)\n894         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n895         return c\n896 \n897     def as_sql(self, compiler, connection, template=None, **extra_context):\n898         connection.ops.check_expression_support(self)\n899         template_params = extra_context\n900         sql_params = []\n901         condition_sql, condition_params = compiler.compile(self.condition)\n902         template_params['condition'] = condition_sql\n903         sql_params.extend(condition_params)\n904         result_sql, result_params = compiler.compile(self.result)\n905         template_params['result'] = result_sql\n906         sql_params.extend(result_params)\n907         template = template or self.template\n908         return template % template_params, sql_params\n909 \n910     def get_group_by_cols(self, alias=None):\n911         # This is not a complete expression and cannot be used in GROUP BY.\n912         cols = []\n913         for source in self.get_source_expressions():\n914             cols.extend(source.get_group_by_cols())\n915         return cols\n916 \n917 \n918 class Case(Expression):\n919     \"\"\"\n920     An SQL searched CASE expression:\n921 \n922         CASE\n923             WHEN n > 0\n924                 THEN 'positive'\n925             WHEN n < 0\n926                 THEN 'negative'\n927             ELSE 'zero'\n928         END\n929     \"\"\"\n930     template = 'CASE %(cases)s ELSE %(default)s END'\n931     case_joiner = ' '\n932 \n933     def __init__(self, *cases, default=None, output_field=None, **extra):\n934         if not all(isinstance(case, When) for case in cases):\n935             raise TypeError(\"Positional arguments must all be When objects.\")\n936         super().__init__(output_field)\n937         self.cases = list(cases)\n938         self.default = self._parse_expressions(default)[0]\n939         self.extra = extra\n940 \n941     def __str__(self):\n942         return \"CASE %s, ELSE %r\" % (', '.join(str(c) for c in self.cases), self.default)\n943 \n944     def __repr__(self):\n945         return \"<%s: %s>\" % (self.__class__.__name__, self)\n946 \n947     def get_source_expressions(self):\n948         return self.cases + [self.default]\n949 \n950     def set_source_expressions(self, exprs):\n951         *self.cases, self.default = exprs\n952 \n953     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n954         c = self.copy()\n955         c.is_summary = summarize\n956         for pos, case in enumerate(c.cases):\n957             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n958         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n959         return c\n960 \n961     def copy(self):\n962         c = super().copy()\n963         c.cases = c.cases[:]\n964         return c\n965 \n966     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n967         connection.ops.check_expression_support(self)\n968         if not self.cases:\n969             return compiler.compile(self.default)\n970         template_params = {**self.extra, **extra_context}\n971         case_parts = []\n972         sql_params = []\n973         for case in self.cases:\n974             try:\n975                 case_sql, case_params = compiler.compile(case)\n976             except EmptyResultSet:\n977                 continue\n978             case_parts.append(case_sql)\n979             sql_params.extend(case_params)\n980         default_sql, default_params = compiler.compile(self.default)\n981         if not case_parts:\n982             return default_sql, default_params\n983         case_joiner = case_joiner or self.case_joiner\n984         template_params['cases'] = case_joiner.join(case_parts)\n985         template_params['default'] = default_sql\n986         sql_params.extend(default_params)\n987         template = template or template_params.get('template', self.template)\n988         sql = template % template_params\n989         if self._output_field_or_none is not None:\n990             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n991         return sql, sql_params\n992 \n993 \n994 class Subquery(Expression):\n995     \"\"\"\n996     An explicit subquery. It may contain OuterRef() references to the outer\n997     query which will be resolved when it is applied to that query.\n998     \"\"\"\n999     template = '(%(subquery)s)'\n1000     contains_aggregate = False\n1001 \n1002     def __init__(self, queryset, output_field=None, **extra):\n1003         self.query = queryset.query\n1004         self.extra = extra\n1005         super().__init__(output_field)\n1006 \n1007     def __getstate__(self):\n1008         state = super().__getstate__()\n1009         state.pop('_constructor_args', None)\n1010         return state\n1011 \n1012     def get_source_expressions(self):\n1013         return [self.query]\n1014 \n1015     def set_source_expressions(self, exprs):\n1016         self.query = exprs[0]\n1017 \n1018     def _resolve_output_field(self):\n1019         return self.query.output_field\n1020 \n1021     def copy(self):\n1022         clone = super().copy()\n1023         clone.query = clone.query.clone()\n1024         return clone\n1025 \n1026     @property\n1027     def external_aliases(self):\n1028         return self.query.external_aliases\n1029 \n1030     def as_sql(self, compiler, connection, template=None, **extra_context):\n1031         connection.ops.check_expression_support(self)\n1032         template_params = {**self.extra, **extra_context}\n1033         subquery_sql, sql_params = self.query.as_sql(compiler, connection)\n1034         template_params['subquery'] = subquery_sql[1:-1]\n1035 \n1036         template = template or template_params.get('template', self.template)\n1037         sql = template % template_params\n1038         return sql, sql_params\n1039 \n1040     def get_group_by_cols(self, alias=None):\n1041         if alias:\n1042             return [Ref(alias, self)]\n1043         return []\n1044 \n1045 \n1046 class Exists(Subquery):\n1047     template = 'EXISTS(%(subquery)s)'\n1048     output_field = fields.BooleanField()\n1049 \n1050     def __init__(self, queryset, negated=False, **kwargs):\n1051         # As a performance optimization, remove ordering since EXISTS doesn't\n1052         # care about it, just whether or not a row matches.\n1053         queryset = queryset.order_by()\n1054         self.negated = negated\n1055         super().__init__(queryset, **kwargs)\n1056 \n1057     def __invert__(self):\n1058         clone = self.copy()\n1059         clone.negated = not self.negated\n1060         return clone\n1061 \n1062     def as_sql(self, compiler, connection, template=None, **extra_context):\n1063         sql, params = super().as_sql(compiler, connection, template, **extra_context)\n1064         if self.negated:\n1065             sql = 'NOT {}'.format(sql)\n1066         return sql, params\n1067 \n1068     def select_format(self, compiler, sql, params):\n1069         # Wrap EXISTS() with a CASE WHEN expression if a database backend\n1070         # (e.g. Oracle) doesn't support boolean expression in the SELECT list.\n1071         if not compiler.connection.features.supports_boolean_expr_in_select_clause:\n1072             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n1073         return sql, params\n1074 \n1075 \n1076 class OrderBy(BaseExpression):\n1077     template = '%(expression)s %(ordering)s'\n1078     conditional = False\n1079 \n1080     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):\n1081         if nulls_first and nulls_last:\n1082             raise ValueError('nulls_first and nulls_last are mutually exclusive')\n1083         self.nulls_first = nulls_first\n1084         self.nulls_last = nulls_last\n1085         self.descending = descending\n1086         if not hasattr(expression, 'resolve_expression'):\n1087             raise ValueError('expression must be an expression type')\n1088         self.expression = expression\n1089 \n1090     def __repr__(self):\n1091         return \"{}({}, descending={})\".format(\n1092             self.__class__.__name__, self.expression, self.descending)\n1093 \n1094     def set_source_expressions(self, exprs):\n1095         self.expression = exprs[0]\n1096 \n1097     def get_source_expressions(self):\n1098         return [self.expression]\n1099 \n1100     def as_sql(self, compiler, connection, template=None, **extra_context):\n1101         template = template or self.template\n1102         if connection.features.supports_order_by_nulls_modifier:\n1103             if self.nulls_last:\n1104                 template = '%s NULLS LAST' % template\n1105             elif self.nulls_first:\n1106                 template = '%s NULLS FIRST' % template\n1107         else:\n1108             if self.nulls_last:\n1109                 template = '%%(expression)s IS NULL, %s' % template\n1110             elif self.nulls_first:\n1111                 template = '%%(expression)s IS NOT NULL, %s' % template\n1112         connection.ops.check_expression_support(self)\n1113         expression_sql, params = compiler.compile(self.expression)\n1114         placeholders = {\n1115             'expression': expression_sql,\n1116             'ordering': 'DESC' if self.descending else 'ASC',\n1117             **extra_context,\n1118         }\n1119         template = template or self.template\n1120         params *= template.count('%(expression)s')\n1121         return (template % placeholders).rstrip(), params\n1122 \n1123     def as_oracle(self, compiler, connection):\n1124         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in\n1125         # a CASE WHEN.\n1126         if isinstance(self.expression, Exists):\n1127             copy = self.copy()\n1128             copy.expression = Case(\n1129                 When(self.expression, then=True),\n1130                 default=False,\n1131                 output_field=fields.BooleanField(),\n1132             )\n1133             return copy.as_sql(compiler, connection)\n1134         return self.as_sql(compiler, connection)\n1135 \n1136     def get_group_by_cols(self, alias=None):\n1137         cols = []\n1138         for source in self.get_source_expressions():\n1139             cols.extend(source.get_group_by_cols())\n1140         return cols\n1141 \n1142     def reverse_ordering(self):\n1143         self.descending = not self.descending\n1144         if self.nulls_first or self.nulls_last:\n1145             self.nulls_first = not self.nulls_first\n1146             self.nulls_last = not self.nulls_last\n1147         return self\n1148 \n1149     def asc(self):\n1150         self.descending = False\n1151 \n1152     def desc(self):\n1153         self.descending = True\n1154 \n1155 \n1156 class Window(Expression):\n1157     template = '%(expression)s OVER (%(window)s)'\n1158     # Although the main expression may either be an aggregate or an\n1159     # expression with an aggregate function, the GROUP BY that will\n1160     # be introduced in the query as a result is not desired.\n1161     contains_aggregate = False\n1162     contains_over_clause = True\n1163     filterable = False\n1164 \n1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n1166         self.partition_by = partition_by\n1167         self.order_by = order_by\n1168         self.frame = frame\n1169 \n1170         if not getattr(expression, 'window_compatible', False):\n1171             raise ValueError(\n1172                 \"Expression '%s' isn't compatible with OVER clauses.\" %\n1173                 expression.__class__.__name__\n1174             )\n1175 \n1176         if self.partition_by is not None:\n1177             if not isinstance(self.partition_by, (tuple, list)):\n1178                 self.partition_by = (self.partition_by,)\n1179             self.partition_by = ExpressionList(*self.partition_by)\n1180 \n1181         if self.order_by is not None:\n1182             if isinstance(self.order_by, (list, tuple)):\n1183                 self.order_by = ExpressionList(*self.order_by)\n1184             elif not isinstance(self.order_by, BaseExpression):\n1185                 raise ValueError(\n1186                     'order_by must be either an Expression or a sequence of '\n1187                     'expressions.'\n1188                 )\n1189         super().__init__(output_field=output_field)\n1190         self.source_expression = self._parse_expressions(expression)[0]\n1191 \n1192     def _resolve_output_field(self):\n1193         return self.source_expression.output_field\n1194 \n1195     def get_source_expressions(self):\n1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n1197 \n1198     def set_source_expressions(self, exprs):\n1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n1200 \n1201     def as_sql(self, compiler, connection, template=None):\n1202         connection.ops.check_expression_support(self)\n1203         if not connection.features.supports_over_clause:\n1204             raise NotSupportedError('This backend does not support window expressions.')\n1205         expr_sql, params = compiler.compile(self.source_expression)\n1206         window_sql, window_params = [], []\n1207 \n1208         if self.partition_by is not None:\n1209             sql_expr, sql_params = self.partition_by.as_sql(\n1210                 compiler=compiler, connection=connection,\n1211                 template='PARTITION BY %(expressions)s',\n1212             )\n1213             window_sql.extend(sql_expr)\n1214             window_params.extend(sql_params)\n1215 \n1216         if self.order_by is not None:\n1217             window_sql.append(' ORDER BY ')\n1218             order_sql, order_params = compiler.compile(self.order_by)\n1219             window_sql.extend(order_sql)\n1220             window_params.extend(order_params)\n1221 \n1222         if self.frame:\n1223             frame_sql, frame_params = compiler.compile(self.frame)\n1224             window_sql.append(' ' + frame_sql)\n1225             window_params.extend(frame_params)\n1226 \n1227         params.extend(window_params)\n1228         template = template or self.template\n1229 \n1230         return template % {\n1231             'expression': expr_sql,\n1232             'window': ''.join(window_sql).strip()\n1233         }, params\n1234 \n1235     def __str__(self):\n1236         return '{} OVER ({}{}{})'.format(\n1237             str(self.source_expression),\n1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',\n1240             str(self.frame or ''),\n1241         )\n1242 \n1243     def __repr__(self):\n1244         return '<%s: %s>' % (self.__class__.__name__, self)\n1245 \n1246     def get_group_by_cols(self, alias=None):\n1247         return []\n1248 \n1249 \n1250 class WindowFrame(Expression):\n1251     \"\"\"\n1252     Model the frame clause in window expressions. There are two types of frame\n1253     clauses which are subclasses, however, all processing and validation (by no\n1254     means intended to be complete) is done here. Thus, providing an end for a\n1255     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last\n1256     row in the frame).\n1257     \"\"\"\n1258     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'\n1259 \n1260     def __init__(self, start=None, end=None):\n1261         self.start = Value(start)\n1262         self.end = Value(end)\n1263 \n1264     def set_source_expressions(self, exprs):\n1265         self.start, self.end = exprs\n1266 \n1267     def get_source_expressions(self):\n1268         return [self.start, self.end]\n1269 \n1270     def as_sql(self, compiler, connection):\n1271         connection.ops.check_expression_support(self)\n1272         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)\n1273         return self.template % {\n1274             'frame_type': self.frame_type,\n1275             'start': start,\n1276             'end': end,\n1277         }, []\n1278 \n1279     def __repr__(self):\n1280         return '<%s: %s>' % (self.__class__.__name__, self)\n1281 \n1282     def get_group_by_cols(self, alias=None):\n1283         return []\n1284 \n1285     def __str__(self):\n1286         if self.start.value is not None and self.start.value < 0:\n1287             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)\n1288         elif self.start.value is not None and self.start.value == 0:\n1289             start = connection.ops.CURRENT_ROW\n1290         else:\n1291             start = connection.ops.UNBOUNDED_PRECEDING\n1292 \n1293         if self.end.value is not None and self.end.value > 0:\n1294             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)\n1295         elif self.end.value is not None and self.end.value == 0:\n1296             end = connection.ops.CURRENT_ROW\n1297         else:\n1298             end = connection.ops.UNBOUNDED_FOLLOWING\n1299         return self.template % {\n1300             'frame_type': self.frame_type,\n1301             'start': start,\n1302             'end': end,\n1303         }\n1304 \n1305     def window_frame_start_end(self, connection, start, end):\n1306         raise NotImplementedError('Subclasses must implement window_frame_start_end().')\n1307 \n1308 \n1309 class RowRange(WindowFrame):\n1310     frame_type = 'ROWS'\n1311 \n1312     def window_frame_start_end(self, connection, start, end):\n1313         return connection.ops.window_frame_rows_start_end(start, end)\n1314 \n1315 \n1316 class ValueRange(WindowFrame):\n1317     frame_type = 'RANGE'\n1318 \n1319     def window_frame_start_end(self, connection, start, end):\n1320         return connection.ops.window_frame_range_start_end(start, end)\n",
        "intended_behavior": "The intended behavior would ensure that Case and When expressions can encapsulate Window expressions without issue, propagating the necessary context or flags to successfully compile the SQL query."
    }
]