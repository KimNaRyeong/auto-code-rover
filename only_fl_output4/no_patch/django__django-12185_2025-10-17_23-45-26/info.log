2025-10-17 23:45:26.607 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 23:45:29.750 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=269, output_tokens=12, cost=0.003050
2025-10-17 23:45:46.773 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=449, output_tokens=725, cost=0.026240
2025-10-17 23:45:47.972 | INFO     | registered non reproducing test 0
2025-10-17 23:46:04.064 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1536, output_tokens=775, cost=0.038610
2025-10-17 23:46:05.282 | INFO     | registered non reproducing test 1
2025-10-17 23:46:22.812 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2088, output_tokens=762, cost=0.043740
2025-10-17 23:46:23.979 | INFO     | registered non reproducing test 2
2025-10-17 23:46:23.979 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 23:46:23.986 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:46:33.587 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=567, output_tokens=428, cost=0.018510
2025-10-17 23:46:33.597 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:46:36.889 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=782, output_tokens=77, cost=0.010130
2025-10-17 23:46:36.891 | DEBUG    | Extracted a valid json.
2025-10-17 23:46:36.891 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Window\")",
        "search_class(\"Case\")",
        "search_class(\"When\")",
        "search_method(\"compile\")",
        "search_method(\"validate\")",
        "search_code(\"Window(expression=\")",
        "search_code(\"Case(When(\")"
    ],
    "bug_locations": []
}
2025-10-17 23:46:36.979 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 23:46:36.980 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 23:46:55.576 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2104, output_tokens=947, cost=0.049450
2025-10-17 23:46:55.595 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:47:02.412 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3267, output_tokens=300, cost=0.041670
2025-10-17 23:47:02.418 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:47:07.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=654, output_tokens=173, cost=0.011730
2025-10-17 23:47:07.105 | DEBUG    | Extracted a valid json.
2025-10-17 23:47:07.105 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/expressions.py",
            "class": "Window",
            "method": "",
            "intended_behavior": "The intended behavior should include a validation or compilation pathway that recognizes and correctly handles Window expressions when used in such a context, properly generating the SQL without raising errors, ensuring that the use of window functions in SELECT clause conditionals is supported as per SQL standards."
        },
        {
            "file": "django/db/models/expressions.py",
            "class": "Case, When",
            "method": "",
            "intended_behavior": "The intended behavior would ensure that Case and When expressions can encapsulate Window expressions without issue, propagating the necessary context or flags to successfully compile the SQL query."
        }
    ]
}
2025-10-17 23:47:07.115 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/expressions.py</file>
<class>Window</class>
<method>None</method>
<code>
1156 class Window(Expression):
1157     template = '%(expression)s OVER (%(window)s)'
1158     # Although the main expression may either be an aggregate or an
1159     # expression with an aggregate function, the GROUP BY that will
1160     # be introduced in the query as a result is not desired.
1161     contains_aggregate = False
1162     contains_over_clause = True
1163     filterable = False
1164 
1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1166         self.partition_by = partition_by
1167         self.order_by = order_by
1168         self.frame = frame
1169 
1170         if not getattr(expression, 'window_compatible', False):
1171             raise ValueError(
1172                 "Expression '%s' isn't compatible with OVER clauses." %
1173                 expression.__class__.__name__
1174             )
1175 
1176         if self.partition_by is not None:
1177             if not isinstance(self.partition_by, (tuple, list)):
1178                 self.partition_by = (self.partition_by,)
1179             self.partition_by = ExpressionList(*self.partition_by)
1180 
1181         if self.order_by is not None:
1182             if isinstance(self.order_by, (list, tuple)):
1183                 self.order_by = ExpressionList(*self.order_by)
1184             elif not isinstance(self.order_by, BaseExpression):
1185                 raise ValueError(
1186                     'order_by must be either an Expression or a sequence of '
1187                     'expressions.'
1188                 )
1189         super().__init__(output_field=output_field)
1190         self.source_expression = self._parse_expressions(expression)[0]
1191 
1192     def _resolve_output_field(self):
1193         return self.source_expression.output_field
1194 
1195     def get_source_expressions(self):
1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1197 
1198     def set_source_expressions(self, exprs):
1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1200 
1201     def as_sql(self, compiler, connection, template=None):
1202         connection.ops.check_expression_support(self)
1203         if not connection.features.supports_over_clause:
1204             raise NotSupportedError('This backend does not support window expressions.')
1205         expr_sql, params = compiler.compile(self.source_expression)
1206         window_sql, window_params = [], []
1207 
1208         if self.partition_by is not None:
1209             sql_expr, sql_params = self.partition_by.as_sql(
1210                 compiler=compiler, connection=connection,
1211                 template='PARTITION BY %(expressions)s',
1212             )
1213             window_sql.extend(sql_expr)
1214             window_params.extend(sql_params)
1215 
1216         if self.order_by is not None:
1217             window_sql.append(' ORDER BY ')
1218             order_sql, order_params = compiler.compile(self.order_by)
1219             window_sql.extend(order_sql)
1220             window_params.extend(order_params)
1221 
1222         if self.frame:
1223             frame_sql, frame_params = compiler.compile(self.frame)
1224             window_sql.append(' ' + frame_sql)
1225             window_params.extend(frame_params)
1226 
1227         params.extend(window_params)
1228         template = template or self.template
1229 
1230         return template % {
1231             'expression': expr_sql,
1232             'window': ''.join(window_sql).strip()
1233         }, params
1234 
1235     def __str__(self):
1236         return '{} OVER ({}{}{})'.format(
1237             str(self.source_expression),
1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1240             str(self.frame or ''),
1241         )
1242 
1243     def __repr__(self):
1244         return '<%s: %s>' % (self.__class__.__name__, self)
1245 
1246     def get_group_by_cols(self, alias=None):
1247         return []

</code><intended_behavior>The intended behavior should include a validation or compilation pathway that recognizes and correctly handles Window expressions when used in such a context, properly generating the SQL without raising errors, ensuring that the use of window functions in SELECT clause conditionals is supported as per SQL standards.</intended_behavior>, <file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import inspect
4 from decimal import Decimal
5 
6 from django.core.exceptions import EmptyResultSet, FieldError
7 from django.db import connection
8 from django.db.models import fields
9 from django.db.models.query_utils import Q
10 from django.db.utils import NotSupportedError
11 from django.utils.deconstruct import deconstructible
12 from django.utils.functional import cached_property
13 from django.utils.hashable import make_hashable
14 
15 
16 class SQLiteNumericMixin:
17     """
18     Some expressions with output_field=DecimalField() must be cast to
19     numeric to be properly filtered.
20     """
21     def as_sqlite(self, compiler, connection, **extra_context):
22         sql, params = self.as_sql(compiler, connection, **extra_context)
23         try:
24             if self.output_field.get_internal_type() == 'DecimalField':
25                 sql = 'CAST(%s AS NUMERIC)' % sql
26         except FieldError:
27             pass
28         return sql, params
29 
30 
31 class Combinable:
32     """
33     Provide the ability to combine one or two objects with
34     some connector. For example F('foo') + F('bar').
35     """
36 
37     # Arithmetic connectors
38     ADD = '+'
39     SUB = '-'
40     MUL = '*'
41     DIV = '/'
42     POW = '^'
43     # The following is a quoted % operator - it is quoted because it can be
44     # used in strings that also have parameter substitution.
45     MOD = '%%'
46 
47     # Bitwise operators - note that these are generated by .bitand()
48     # and .bitor(), the '&' and '|' are reserved for boolean operator
49     # usage.
50     BITAND = '&'
51     BITOR = '|'
52     BITLEFTSHIFT = '<<'
53     BITRIGHTSHIFT = '>>'
54 
55     def _combine(self, other, connector, reversed):
56         if not hasattr(other, 'resolve_expression'):
57             # everything must be resolvable to an expression
58             if isinstance(other, datetime.timedelta):
59                 other = DurationValue(other, output_field=fields.DurationField())
60             else:
61                 other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def __or__(self, other):
109         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
110             return Q(self) | Q(other)
111         raise NotImplementedError(
112             "Use .bitand() and .bitor() for bitwise logical operations."
113         )
114 
115     def bitor(self, other):
116         return self._combine(other, self.BITOR, False)
117 
118     def __radd__(self, other):
119         return self._combine(other, self.ADD, True)
120 
121     def __rsub__(self, other):
122         return self._combine(other, self.SUB, True)
123 
124     def __rmul__(self, other):
125         return self._combine(other, self.MUL, True)
126 
127     def __rtruediv__(self, other):
128         return self._combine(other, self.DIV, True)
129 
130     def __rmod__(self, other):
131         return self._combine(other, self.MOD, True)
132 
133     def __rpow__(self, other):
134         return self._combine(other, self.POW, True)
135 
136     def __rand__(self, other):
137         raise NotImplementedError(
138             "Use .bitand() and .bitor() for bitwise logical operations."
139         )
140 
141     def __ror__(self, other):
142         raise NotImplementedError(
143             "Use .bitand() and .bitor() for bitwise logical operations."
144         )
145 
146 
147 @deconstructible
148 class BaseExpression:
149     """Base class for all query expressions."""
150 
151     # aggregate specific fields
152     is_summary = False
153     _output_field_resolved_to_none = False
154     # Can the expression be used in a WHERE clause?
155     filterable = True
156     # Can the expression can be used as a source expression in Window?
157     window_compatible = False
158 
159     def __init__(self, output_field=None):
160         if output_field is not None:
161             self.output_field = output_field
162 
163     def __getstate__(self):
164         state = self.__dict__.copy()
165         state.pop('convert_value', None)
166         return state
167 
168     def get_db_converters(self, connection):
169         return (
170             []
171             if self.convert_value is self._convert_value_noop else
172             [self.convert_value]
173         ) + self.output_field.get_db_converters(connection)
174 
175     def get_source_expressions(self):
176         return []
177 
178     def set_source_expressions(self, exprs):
179         assert not exprs
180 
181     def _parse_expressions(self, *expressions):
182         return [
183             arg if hasattr(arg, 'resolve_expression') else (
184                 F(arg) if isinstance(arg, str) else Value(arg)
185             ) for arg in expressions
186         ]
187 
188     def as_sql(self, compiler, connection):
189         """
190         Responsible for returning a (sql, [params]) tuple to be included
191         in the current query.
192 
193         Different backends can provide their own implementation, by
194         providing an `as_{vendor}` method and patching the Expression:
195 
196         ```
197         def override_as_sql(self, compiler, connection):
198             # custom logic
199             return super().as_sql(compiler, connection)
200         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
201         ```
202 
203         Arguments:
204          * compiler: the query compiler responsible for generating the query.
205            Must have a compile method, returning a (sql, [params]) tuple.
206            Calling compiler(value) will return a quoted `value`.
207 
208          * connection: the database connection used for the current query.
209 
210         Return: (sql, params)
211           Where `sql` is a string containing ordered sql parameters to be
212           replaced with the elements of the list `params`.
213         """
214         raise NotImplementedError("Subclasses must implement as_sql()")
215 
216     @cached_property
217     def contains_aggregate(self):
218         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
219 
220     @cached_property
221     def contains_over_clause(self):
222         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
223 
224     @cached_property
225     def contains_column_references(self):
226         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
227 
228     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
229         """
230         Provide the chance to do any preprocessing or validation before being
231         added to the query.
232 
233         Arguments:
234          * query: the backend query implementation
235          * allow_joins: boolean allowing or denying use of joins
236            in this query
237          * reuse: a set of reusable joins for multijoins
238          * summarize: a terminal aggregate clause
239          * for_save: whether this expression about to be used in a save or update
240 
241         Return: an Expression to be added to the query.
242         """
243         c = self.copy()
244         c.is_summary = summarize
245         c.set_source_expressions([
246             expr.resolve_expression(query, allow_joins, reuse, summarize)
247             if expr else None
248             for expr in c.get_source_expressions()
249         ])
250         return c
251 
252     @property
253     def conditional(self):
254         return isinstance(self.output_field, fields.BooleanField)
255 
256     @property
257     def field(self):
258         return self.output_field
259 
260     @cached_property
261     def output_field(self):
262         """Return the output type of this expressions."""
263         output_field = self._resolve_output_field()
264         if output_field is None:
265             self._output_field_resolved_to_none = True
266             raise FieldError('Cannot resolve expression type, unknown output_field')
267         return output_field
268 
269     @cached_property
270     def _output_field_or_none(self):
271         """
272         Return the output field of this expression, or None if
273         _resolve_output_field() didn't return an output type.
274         """
275         try:
276             return self.output_field
277         except FieldError:
278             if not self._output_field_resolved_to_none:
279                 raise
280 
281     def _resolve_output_field(self):
282         """
283         Attempt to infer the output type of the expression. If the output
284         fields of all source fields match then, simply infer the same type
285         here. This isn't always correct, but it makes sense most of the time.
286 
287         Consider the difference between `2 + 2` and `2 / 3`. Inferring
288         the type here is a convenience for the common case. The user should
289         supply their own output_field with more complex computations.
290 
291         If a source's output field resolves to None, exclude it from this check.
292         If all sources are None, then an error is raised higher up the stack in
293         the output_field property.
294         """
295         sources_iter = (source for source in self.get_source_fields() if source is not None)
296         for output_field in sources_iter:
297             for source in sources_iter:
298                 if not isinstance(output_field, source.__class__):
299                     raise FieldError(
300                         'Expression contains mixed types: %s, %s. You must '
301                         'set output_field.' % (
302                             output_field.__class__.__name__,
303                             source.__class__.__name__,
304                         )
305                     )
306             return output_field
307 
308     @staticmethod
309     def _convert_value_noop(value, expression, connection):
310         return value
311 
312     @cached_property
313     def convert_value(self):
314         """
315         Expressions provide their own converters because users have the option
316         of manually specifying the output_field which may be a different type
317         from the one the database returns.
318         """
319         field = self.output_field
320         internal_type = field.get_internal_type()
321         if internal_type == 'FloatField':
322             return lambda value, expression, connection: None if value is None else float(value)
323         elif internal_type.endswith('IntegerField'):
324             return lambda value, expression, connection: None if value is None else int(value)
325         elif internal_type == 'DecimalField':
326             return lambda value, expression, connection: None if value is None else Decimal(value)
327         return self._convert_value_noop
328 
329     def get_lookup(self, lookup):
330         return self.output_field.get_lookup(lookup)
331 
332     def get_transform(self, name):
333         return self.output_field.get_transform(name)
334 
335     def relabeled_clone(self, change_map):
336         clone = self.copy()
337         clone.set_source_expressions([
338             e.relabeled_clone(change_map) if e is not None else None
339             for e in self.get_source_expressions()
340         ])
341         return clone
342 
343     def copy(self):
344         return copy.copy(self)
345 
346     def get_group_by_cols(self, alias=None):
347         if not self.contains_aggregate:
348             return [self]
349         cols = []
350         for source in self.get_source_expressions():
351             cols.extend(source.get_group_by_cols())
352         return cols
353 
354     def get_source_fields(self):
355         """Return the underlying field types used by this aggregate."""
356         return [e._output_field_or_none for e in self.get_source_expressions()]
357 
358     def asc(self, **kwargs):
359         return OrderBy(self, **kwargs)
360 
361     def desc(self, **kwargs):
362         return OrderBy(self, descending=True, **kwargs)
363 
364     def reverse_ordering(self):
365         return self
366 
367     def flatten(self):
368         """
369         Recursively yield this expression and all subexpressions, in
370         depth-first order.
371         """
372         yield self
373         for expr in self.get_source_expressions():
374             if expr:
375                 yield from expr.flatten()
376 
377     def select_format(self, compiler, sql, params):
378         """
379         Custom format for select clauses. For example, EXISTS expressions need
380         to be wrapped in CASE WHEN on Oracle.
381         """
382         return self.output_field.select_format(compiler, sql, params)
383 
384     @cached_property
385     def identity(self):
386         constructor_signature = inspect.signature(self.__init__)
387         args, kwargs = self._constructor_args
388         signature = constructor_signature.bind_partial(*args, **kwargs)
389         signature.apply_defaults()
390         arguments = signature.arguments.items()
391         identity = [self.__class__]
392         for arg, value in arguments:
393             if isinstance(value, fields.Field):
394                 if value.name and value.model:
395                     value = (value.model._meta.label, value.name)
396                 else:
397                     value = type(value)
398             else:
399                 value = make_hashable(value)
400             identity.append((arg, value))
401         return tuple(identity)
402 
403     def __eq__(self, other):
404         if not isinstance(other, BaseExpression):
405             return NotImplemented
406         return other.identity == self.identity
407 
408     def __hash__(self):
409         return hash(self.identity)
410 
411 
412 class Expression(BaseExpression, Combinable):
413     """An expression that can be combined with other expressions."""
414     pass
415 
416 
417 class CombinedExpression(SQLiteNumericMixin, Expression):
418 
419     def __init__(self, lhs, connector, rhs, output_field=None):
420         super().__init__(output_field=output_field)
421         self.connector = connector
422         self.lhs = lhs
423         self.rhs = rhs
424 
425     def __repr__(self):
426         return "<{}: {}>".format(self.__class__.__name__, self)
427 
428     def __str__(self):
429         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
430 
431     def get_source_expressions(self):
432         return [self.lhs, self.rhs]
433 
434     def set_source_expressions(self, exprs):
435         self.lhs, self.rhs = exprs
436 
437     def as_sql(self, compiler, connection):
438         try:
439             lhs_output = self.lhs.output_field
440         except FieldError:
441             lhs_output = None
442         try:
443             rhs_output = self.rhs.output_field
444         except FieldError:
445             rhs_output = None
446         if (not connection.features.has_native_duration_field and
447                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or
448                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):
449             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)
450         if (lhs_output and rhs_output and self.connector == self.SUB and
451             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and
452                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):
453             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)
454         expressions = []
455         expression_params = []
456         sql, params = compiler.compile(self.lhs)
457         expressions.append(sql)
458         expression_params.extend(params)
459         sql, params = compiler.compile(self.rhs)
460         expressions.append(sql)
461         expression_params.extend(params)
462         # order of precedence
463         expression_wrapper = '(%s)'
464         sql = connection.ops.combine_expression(self.connector, expressions)
465         return expression_wrapper % sql, expression_params
466 
467     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
468         c = self.copy()
469         c.is_summary = summarize
470         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
471         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
472         return c
473 
474 
475 class DurationExpression(CombinedExpression):
476     def compile(self, side, compiler, connection):
477         if not isinstance(side, DurationValue):
478             try:
479                 output = side.output_field
480             except FieldError:
481                 pass
482             else:
483                 if output.get_internal_type() == 'DurationField':
484                     sql, params = compiler.compile(side)
485                     return connection.ops.format_for_duration_arithmetic(sql), params
486         return compiler.compile(side)
487 
488     def as_sql(self, compiler, connection):
489         connection.ops.check_expression_support(self)
490         expressions = []
491         expression_params = []
492         sql, params = self.compile(self.lhs, compiler, connection)
493         expressions.append(sql)
494         expression_params.extend(params)
495         sql, params = self.compile(self.rhs, compiler, connection)
496         expressions.append(sql)
497         expression_params.extend(params)
498         # order of precedence
499         expression_wrapper = '(%s)'
500         sql = connection.ops.combine_duration_expression(self.connector, expressions)
501         return expression_wrapper % sql, expression_params
502 
503 
504 class TemporalSubtraction(CombinedExpression):
505     output_field = fields.DurationField()
506 
507     def __init__(self, lhs, rhs):
508         super().__init__(lhs, self.SUB, rhs)
509 
510     def as_sql(self, compiler, connection):
511         connection.ops.check_expression_support(self)
512         lhs = compiler.compile(self.lhs)
513         rhs = compiler.compile(self.rhs)
514         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
515 
516 
517 @deconstructible
518 class F(Combinable):
519     """An object capable of resolving references to existing query objects."""
520 
521     def __init__(self, name):
522         """
523         Arguments:
524          * name: the name of the field this expression references
525         """
526         self.name = name
527 
528     def __repr__(self):
529         return "{}({})".format(self.__class__.__name__, self.name)
530 
531     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
532                            summarize=False, for_save=False):
533         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
534 
535     def asc(self, **kwargs):
536         return OrderBy(self, **kwargs)
537 
538     def desc(self, **kwargs):
539         return OrderBy(self, descending=True, **kwargs)
540 
541     def __eq__(self, other):
542         return self.__class__ == other.__class__ and self.name == other.name
543 
544     def __hash__(self):
545         return hash(self.name)
546 
547 
548 class ResolvedOuterRef(F):
549     """
550     An object that contains a reference to an outer query.
551 
552     In this case, the reference to the outer query has been resolved because
553     the inner query has been used as a subquery.
554     """
555     contains_aggregate = False
556 
557     def as_sql(self, *args, **kwargs):
558         raise ValueError(
559             'This queryset contains a reference to an outer query and may '
560             'only be used in a subquery.'
561         )
562 
563     def relabeled_clone(self, relabels):
564         return self
565 
566 
567 class OuterRef(F):
568     def resolve_expression(self, *args, **kwargs):
569         if isinstance(self.name, self.__class__):
570             return self.name
571         return ResolvedOuterRef(self.name)
572 
573 
574 class Func(SQLiteNumericMixin, Expression):
575     """An SQL function call."""
576     function = None
577     template = '%(function)s(%(expressions)s)'
578     arg_joiner = ', '
579     arity = None  # The number of arguments the function accepts.
580 
581     def __init__(self, *expressions, output_field=None, **extra):
582         if self.arity is not None and len(expressions) != self.arity:
583             raise TypeError(
584                 "'%s' takes exactly %s %s (%s given)" % (
585                     self.__class__.__name__,
586                     self.arity,
587                     "argument" if self.arity == 1 else "arguments",
588                     len(expressions),
589                 )
590             )
591         super().__init__(output_field=output_field)
592         self.source_expressions = self._parse_expressions(*expressions)
593         self.extra = extra
594 
595     def __repr__(self):
596         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
597         extra = {**self.extra, **self._get_repr_options()}
598         if extra:
599             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
600             return "{}({}, {})".format(self.__class__.__name__, args, extra)
601         return "{}({})".format(self.__class__.__name__, args)
602 
603     def _get_repr_options(self):
604         """Return a dict of extra __init__() options to include in the repr."""
605         return {}
606 
607     def get_source_expressions(self):
608         return self.source_expressions
609 
610     def set_source_expressions(self, exprs):
611         self.source_expressions = exprs
612 
613     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
614         c = self.copy()
615         c.is_summary = summarize
616         for pos, arg in enumerate(c.source_expressions):
617             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
618         return c
619 
620     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
621         connection.ops.check_expression_support(self)
622         sql_parts = []
623         params = []
624         for arg in self.source_expressions:
625             arg_sql, arg_params = compiler.compile(arg)
626             sql_parts.append(arg_sql)
627             params.extend(arg_params)
628         data = {**self.extra, **extra_context}
629         # Use the first supplied value in this order: the parameter to this
630         # method, a value supplied in __init__()'s **extra (the value in
631         # `data`), or the value defined on the class.
632         if function is not None:
633             data['function'] = function
634         else:
635             data.setdefault('function', self.function)
636         template = template or data.get('template', self.template)
637         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
638         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
639         return template % data, params
640 
641     def copy(self):
642         copy = super().copy()
643         copy.source_expressions = self.source_expressions[:]
644         copy.extra = self.extra.copy()
645         return copy
646 
647 
648 class Value(Expression):
649     """Represent a wrapped value as a node within an expression."""
650     def __init__(self, value, output_field=None):
651         """
652         Arguments:
653          * value: the value this expression represents. The value will be
654            added into the sql parameter list and properly quoted.
655 
656          * output_field: an instance of the model field type that this
657            expression will return, such as IntegerField() or CharField().
658         """
659         super().__init__(output_field=output_field)
660         self.value = value
661 
662     def __repr__(self):
663         return "{}({})".format(self.__class__.__name__, self.value)
664 
665     def as_sql(self, compiler, connection):
666         connection.ops.check_expression_support(self)
667         val = self.value
668         output_field = self._output_field_or_none
669         if output_field is not None:
670             if self.for_save:
671                 val = output_field.get_db_prep_save(val, connection=connection)
672             else:
673                 val = output_field.get_db_prep_value(val, connection=connection)
674             if hasattr(output_field, 'get_placeholder'):
675                 return output_field.get_placeholder(val, compiler, connection), [val]
676         if val is None:
677             # cx_Oracle does not always convert None to the appropriate
678             # NULL type (like in case expressions using numbers), so we
679             # use a literal SQL NULL
680             return 'NULL', []
681         return '%s', [val]
682 
683     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
684         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
685         c.for_save = for_save
686         return c
687 
688     def get_group_by_cols(self, alias=None):
689         return []
690 
691 
692 class DurationValue(Value):
693     def as_sql(self, compiler, connection):
694         connection.ops.check_expression_support(self)
695         if connection.features.has_native_duration_field:
696             return super().as_sql(compiler, connection)
697         return connection.ops.date_interval_sql(self.value), []
698 
699 
700 class RawSQL(Expression):
701     def __init__(self, sql, params, output_field=None):
702         if output_field is None:
703             output_field = fields.Field()
704         self.sql, self.params = sql, params
705         super().__init__(output_field=output_field)
706 
707     def __repr__(self):
708         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
709 
710     def as_sql(self, compiler, connection):
711         return '(%s)' % self.sql, self.params
712 
713     def get_group_by_cols(self, alias=None):
714         return [self]
715 
716     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
717         # Resolve parents fields used in raw SQL.
718         for parent in query.model._meta.get_parent_list():
719             for parent_field in parent._meta.local_fields:
720                 _, column_name = parent_field.get_attname_column()
721                 if column_name.lower() in self.sql.lower():
722                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
723                     break
724         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
725 
726 
727 class Star(Expression):
728     def __repr__(self):
729         return "'*'"
730 
731     def as_sql(self, compiler, connection):
732         return '*', []
733 
734 
735 class Random(Expression):
736     output_field = fields.FloatField()
737 
738     def __repr__(self):
739         return "Random()"
740 
741     def as_sql(self, compiler, connection):
742         return connection.ops.random_function_sql(), []
743 
744 
745 class Col(Expression):
746 
747     contains_column_references = True
748 
749     def __init__(self, alias, target, output_field=None):
750         if output_field is None:
751             output_field = target
752         super().__init__(output_field=output_field)
753         self.alias, self.target = alias, target
754 
755     def __repr__(self):
756         alias, target = self.alias, self.target
757         identifiers = (alias, str(target)) if alias else (str(target),)
758         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
759 
760     def as_sql(self, compiler, connection):
761         alias, column = self.alias, self.target.column
762         identifiers = (alias, column) if alias else (column,)
763         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
764         return sql, []
765 
766     def relabeled_clone(self, relabels):
767         if self.alias is None:
768             return self
769         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
770 
771     def get_group_by_cols(self, alias=None):
772         return [self]
773 
774     def get_db_converters(self, connection):
775         if self.target == self.output_field:
776             return self.output_field.get_db_converters(connection)
777         return (self.output_field.get_db_converters(connection) +
778                 self.target.get_db_converters(connection))
779 
780 
781 class Ref(Expression):
782     """
783     Reference to column alias of the query. For example, Ref('sum_cost') in
784     qs.annotate(sum_cost=Sum('cost')) query.
785     """
786     def __init__(self, refs, source):
787         super().__init__()
788         self.refs, self.source = refs, source
789 
790     def __repr__(self):
791         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
792 
793     def get_source_expressions(self):
794         return [self.source]
795 
796     def set_source_expressions(self, exprs):
797         self.source, = exprs
798 
799     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
800         # The sub-expression `source` has already been resolved, as this is
801         # just a reference to the name of `source`.
802         return self
803 
804     def relabeled_clone(self, relabels):
805         return self
806 
807     def as_sql(self, compiler, connection):
808         return connection.ops.quote_name(self.refs), []
809 
810     def get_group_by_cols(self, alias=None):
811         return [self]
812 
813 
814 class ExpressionList(Func):
815     """
816     An expression containing multiple expressions. Can be used to provide a
817     list of expressions as an argument to another expression, like an
818     ordering clause.
819     """
820     template = '%(expressions)s'
821 
822     def __init__(self, *expressions, **extra):
823         if not expressions:
824             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
825         super().__init__(*expressions, **extra)
826 
827     def __str__(self):
828         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
829 
830 
831 class ExpressionWrapper(Expression):
832     """
833     An expression that can wrap another expression so that it can provide
834     extra context to the inner expression, such as the output_field.
835     """
836 
837     def __init__(self, expression, output_field):
838         super().__init__(output_field=output_field)
839         self.expression = expression
840 
841     def set_source_expressions(self, exprs):
842         self.expression = exprs[0]
843 
844     def get_source_expressions(self):
845         return [self.expression]
846 
847     def as_sql(self, compiler, connection):
848         return self.expression.as_sql(compiler, connection)
849 
850     def __repr__(self):
851         return "{}({})".format(self.__class__.__name__, self.expression)
852 
853 
854 class When(Expression):
855     template = 'WHEN %(condition)s THEN %(result)s'
856     # This isn't a complete conditional expression, must be used in Case().
857     conditional = False
858 
859     def __init__(self, condition=None, then=None, **lookups):
860         if lookups and condition is None:
861             condition, lookups = Q(**lookups), None
862         if condition is None or not getattr(condition, 'conditional', False) or lookups:
863             raise TypeError(
864                 'When() supports a Q object, a boolean expression, or lookups '
865                 'as a condition.'
866             )
867         if isinstance(condition, Q) and not condition:
868             raise ValueError("An empty Q() can't be used as a When() condition.")
869         super().__init__(output_field=None)
870         self.condition = condition
871         self.result = self._parse_expressions(then)[0]
872 
873     def __str__(self):
874         return "WHEN %r THEN %r" % (self.condition, self.result)
875 
876     def __repr__(self):
877         return "<%s: %s>" % (self.__class__.__name__, self)
878 
879     def get_source_expressions(self):
880         return [self.condition, self.result]
881 
882     def set_source_expressions(self, exprs):
883         self.condition, self.result = exprs
884 
885     def get_source_fields(self):
886         # We're only interested in the fields of the result expressions.
887         return [self.result._output_field_or_none]
888 
889     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
890         c = self.copy()
891         c.is_summary = summarize
892         if hasattr(c.condition, 'resolve_expression'):
893             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
894         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
895         return c
896 
897     def as_sql(self, compiler, connection, template=None, **extra_context):
898         connection.ops.check_expression_support(self)
899         template_params = extra_context
900         sql_params = []
901         condition_sql, condition_params = compiler.compile(self.condition)
902         template_params['condition'] = condition_sql
903         sql_params.extend(condition_params)
904         result_sql, result_params = compiler.compile(self.result)
905         template_params['result'] = result_sql
906         sql_params.extend(result_params)
907         template = template or self.template
908         return template % template_params, sql_params
909 
910     def get_group_by_cols(self, alias=None):
911         # This is not a complete expression and cannot be used in GROUP BY.
912         cols = []
913         for source in self.get_source_expressions():
914             cols.extend(source.get_group_by_cols())
915         return cols
916 
917 
918 class Case(Expression):
919     """
920     An SQL searched CASE expression:
921 
922         CASE
923             WHEN n > 0
924                 THEN 'positive'
925             WHEN n < 0
926                 THEN 'negative'
927             ELSE 'zero'
928         END
929     """
930     template = 'CASE %(cases)s ELSE %(default)s END'
931     case_joiner = ' '
932 
933     def __init__(self, *cases, default=None, output_field=None, **extra):
934         if not all(isinstance(case, When) for case in cases):
935             raise TypeError("Positional arguments must all be When objects.")
936         super().__init__(output_field)
937         self.cases = list(cases)
938         self.default = self._parse_expressions(default)[0]
939         self.extra = extra
940 
941     def __str__(self):
942         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
943 
944     def __repr__(self):
945         return "<%s: %s>" % (self.__class__.__name__, self)
946 
947     def get_source_expressions(self):
948         return self.cases + [self.default]
949 
950     def set_source_expressions(self, exprs):
951         *self.cases, self.default = exprs
952 
953     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
954         c = self.copy()
955         c.is_summary = summarize
956         for pos, case in enumerate(c.cases):
957             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
958         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
959         return c
960 
961     def copy(self):
962         c = super().copy()
963         c.cases = c.cases[:]
964         return c
965 
966     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
967         connection.ops.check_expression_support(self)
968         if not self.cases:
969             return compiler.compile(self.default)
970         template_params = {**self.extra, **extra_context}
971         case_parts = []
972         sql_params = []
973         for case in self.cases:
974             try:
975                 case_sql, case_params = compiler.compile(case)
976             except EmptyResultSet:
977                 continue
978             case_parts.append(case_sql)
979             sql_params.extend(case_params)
980         default_sql, default_params = compiler.compile(self.default)
981         if not case_parts:
982             return default_sql, default_params
983         case_joiner = case_joiner or self.case_joiner
984         template_params['cases'] = case_joiner.join(case_parts)
985         template_params['default'] = default_sql
986         sql_params.extend(default_params)
987         template = template or template_params.get('template', self.template)
988         sql = template % template_params
989         if self._output_field_or_none is not None:
990             sql = connection.ops.unification_cast_sql(self.output_field) % sql
991         return sql, sql_params
992 
993 
994 class Subquery(Expression):
995     """
996     An explicit subquery. It may contain OuterRef() references to the outer
997     query which will be resolved when it is applied to that query.
998     """
999     template = '(%(subquery)s)'
1000     contains_aggregate = False
1001 
1002     def __init__(self, queryset, output_field=None, **extra):
1003         self.query = queryset.query
1004         self.extra = extra
1005         super().__init__(output_field)
1006 
1007     def __getstate__(self):
1008         state = super().__getstate__()
1009         state.pop('_constructor_args', None)
1010         return state
1011 
1012     def get_source_expressions(self):
1013         return [self.query]
1014 
1015     def set_source_expressions(self, exprs):
1016         self.query = exprs[0]
1017 
1018     def _resolve_output_field(self):
1019         return self.query.output_field
1020 
1021     def copy(self):
1022         clone = super().copy()
1023         clone.query = clone.query.clone()
1024         return clone
1025 
1026     @property
1027     def external_aliases(self):
1028         return self.query.external_aliases
1029 
1030     def as_sql(self, compiler, connection, template=None, **extra_context):
1031         connection.ops.check_expression_support(self)
1032         template_params = {**self.extra, **extra_context}
1033         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
1034         template_params['subquery'] = subquery_sql[1:-1]
1035 
1036         template = template or template_params.get('template', self.template)
1037         sql = template % template_params
1038         return sql, sql_params
1039 
1040     def get_group_by_cols(self, alias=None):
1041         if alias:
1042             return [Ref(alias, self)]
1043         return []
1044 
1045 
1046 class Exists(Subquery):
1047     template = 'EXISTS(%(subquery)s)'
1048     output_field = fields.BooleanField()
1049 
1050     def __init__(self, queryset, negated=False, **kwargs):
1051         # As a performance optimization, remove ordering since EXISTS doesn't
1052         # care about it, just whether or not a row matches.
1053         queryset = queryset.order_by()
1054         self.negated = negated
1055         super().__init__(queryset, **kwargs)
1056 
1057     def __invert__(self):
1058         clone = self.copy()
1059         clone.negated = not self.negated
1060         return clone
1061 
1062     def as_sql(self, compiler, connection, template=None, **extra_context):
1063         sql, params = super().as_sql(compiler, connection, template, **extra_context)
1064         if self.negated:
1065             sql = 'NOT {}'.format(sql)
1066         return sql, params
1067 
1068     def select_format(self, compiler, sql, params):
1069         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1070         # (e.g. Oracle) doesn't support boolean expression in the SELECT list.
1071         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1072             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1073         return sql, params
1074 
1075 
1076 class OrderBy(BaseExpression):
1077     template = '%(expression)s %(ordering)s'
1078     conditional = False
1079 
1080     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1081         if nulls_first and nulls_last:
1082             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1083         self.nulls_first = nulls_first
1084         self.nulls_last = nulls_last
1085         self.descending = descending
1086         if not hasattr(expression, 'resolve_expression'):
1087             raise ValueError('expression must be an expression type')
1088         self.expression = expression
1089 
1090     def __repr__(self):
1091         return "{}({}, descending={})".format(
1092             self.__class__.__name__, self.expression, self.descending)
1093 
1094     def set_source_expressions(self, exprs):
1095         self.expression = exprs[0]
1096 
1097     def get_source_expressions(self):
1098         return [self.expression]
1099 
1100     def as_sql(self, compiler, connection, template=None, **extra_context):
1101         template = template or self.template
1102         if connection.features.supports_order_by_nulls_modifier:
1103             if self.nulls_last:
1104                 template = '%s NULLS LAST' % template
1105             elif self.nulls_first:
1106                 template = '%s NULLS FIRST' % template
1107         else:
1108             if self.nulls_last:
1109                 template = '%%(expression)s IS NULL, %s' % template
1110             elif self.nulls_first:
1111                 template = '%%(expression)s IS NOT NULL, %s' % template
1112         connection.ops.check_expression_support(self)
1113         expression_sql, params = compiler.compile(self.expression)
1114         placeholders = {
1115             'expression': expression_sql,
1116             'ordering': 'DESC' if self.descending else 'ASC',
1117             **extra_context,
1118         }
1119         template = template or self.template
1120         params *= template.count('%(expression)s')
1121         return (template % placeholders).rstrip(), params
1122 
1123     def as_oracle(self, compiler, connection):
1124         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in
1125         # a CASE WHEN.
1126         if isinstance(self.expression, Exists):
1127             copy = self.copy()
1128             copy.expression = Case(
1129                 When(self.expression, then=True),
1130                 default=False,
1131                 output_field=fields.BooleanField(),
1132             )
1133             return copy.as_sql(compiler, connection)
1134         return self.as_sql(compiler, connection)
1135 
1136     def get_group_by_cols(self, alias=None):
1137         cols = []
1138         for source in self.get_source_expressions():
1139             cols.extend(source.get_group_by_cols())
1140         return cols
1141 
1142     def reverse_ordering(self):
1143         self.descending = not self.descending
1144         if self.nulls_first or self.nulls_last:
1145             self.nulls_first = not self.nulls_first
1146             self.nulls_last = not self.nulls_last
1147         return self
1148 
1149     def asc(self):
1150         self.descending = False
1151 
1152     def desc(self):
1153         self.descending = True
1154 
1155 
1156 class Window(Expression):
1157     template = '%(expression)s OVER (%(window)s)'
1158     # Although the main expression may either be an aggregate or an
1159     # expression with an aggregate function, the GROUP BY that will
1160     # be introduced in the query as a result is not desired.
1161     contains_aggregate = False
1162     contains_over_clause = True
1163     filterable = False
1164 
1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1166         self.partition_by = partition_by
1167         self.order_by = order_by
1168         self.frame = frame
1169 
1170         if not getattr(expression, 'window_compatible', False):
1171             raise ValueError(
1172                 "Expression '%s' isn't compatible with OVER clauses." %
1173                 expression.__class__.__name__
1174             )
1175 
1176         if self.partition_by is not None:
1177             if not isinstance(self.partition_by, (tuple, list)):
1178                 self.partition_by = (self.partition_by,)
1179             self.partition_by = ExpressionList(*self.partition_by)
1180 
1181         if self.order_by is not None:
1182             if isinstance(self.order_by, (list, tuple)):
1183                 self.order_by = ExpressionList(*self.order_by)
1184             elif not isinstance(self.order_by, BaseExpression):
1185                 raise ValueError(
1186                     'order_by must be either an Expression or a sequence of '
1187                     'expressions.'
1188                 )
1189         super().__init__(output_field=output_field)
1190         self.source_expression = self._parse_expressions(expression)[0]
1191 
1192     def _resolve_output_field(self):
1193         return self.source_expression.output_field
1194 
1195     def get_source_expressions(self):
1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1197 
1198     def set_source_expressions(self, exprs):
1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1200 
1201     def as_sql(self, compiler, connection, template=None):
1202         connection.ops.check_expression_support(self)
1203         if not connection.features.supports_over_clause:
1204             raise NotSupportedError('This backend does not support window expressions.')
1205         expr_sql, params = compiler.compile(self.source_expression)
1206         window_sql, window_params = [], []
1207 
1208         if self.partition_by is not None:
1209             sql_expr, sql_params = self.partition_by.as_sql(
1210                 compiler=compiler, connection=connection,
1211                 template='PARTITION BY %(expressions)s',
1212             )
1213             window_sql.extend(sql_expr)
1214             window_params.extend(sql_params)
1215 
1216         if self.order_by is not None:
1217             window_sql.append(' ORDER BY ')
1218             order_sql, order_params = compiler.compile(self.order_by)
1219             window_sql.extend(order_sql)
1220             window_params.extend(order_params)
1221 
1222         if self.frame:
1223             frame_sql, frame_params = compiler.compile(self.frame)
1224             window_sql.append(' ' + frame_sql)
1225             window_params.extend(frame_params)
1226 
1227         params.extend(window_params)
1228         template = template or self.template
1229 
1230         return template % {
1231             'expression': expr_sql,
1232             'window': ''.join(window_sql).strip()
1233         }, params
1234 
1235     def __str__(self):
1236         return '{} OVER ({}{}{})'.format(
1237             str(self.source_expression),
1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1240             str(self.frame or ''),
1241         )
1242 
1243     def __repr__(self):
1244         return '<%s: %s>' % (self.__class__.__name__, self)
1245 
1246     def get_group_by_cols(self, alias=None):
1247         return []
1248 
1249 
1250 class WindowFrame(Expression):
1251     """
1252     Model the frame clause in window expressions. There are two types of frame
1253     clauses which are subclasses, however, all processing and validation (by no
1254     means intended to be complete) is done here. Thus, providing an end for a
1255     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1256     row in the frame).
1257     """
1258     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1259 
1260     def __init__(self, start=None, end=None):
1261         self.start = Value(start)
1262         self.end = Value(end)
1263 
1264     def set_source_expressions(self, exprs):
1265         self.start, self.end = exprs
1266 
1267     def get_source_expressions(self):
1268         return [self.start, self.end]
1269 
1270     def as_sql(self, compiler, connection):
1271         connection.ops.check_expression_support(self)
1272         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1273         return self.template % {
1274             'frame_type': self.frame_type,
1275             'start': start,
1276             'end': end,
1277         }, []
1278 
1279     def __repr__(self):
1280         return '<%s: %s>' % (self.__class__.__name__, self)
1281 
1282     def get_group_by_cols(self, alias=None):
1283         return []
1284 
1285     def __str__(self):
1286         if self.start.value is not None and self.start.value < 0:
1287             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1288         elif self.start.value is not None and self.start.value == 0:
1289             start = connection.ops.CURRENT_ROW
1290         else:
1291             start = connection.ops.UNBOUNDED_PRECEDING
1292 
1293         if self.end.value is not None and self.end.value > 0:
1294             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1295         elif self.end.value is not None and self.end.value == 0:
1296             end = connection.ops.CURRENT_ROW
1297         else:
1298             end = connection.ops.UNBOUNDED_FOLLOWING
1299         return self.template % {
1300             'frame_type': self.frame_type,
1301             'start': start,
1302             'end': end,
1303         }
1304 
1305     def window_frame_start_end(self, connection, start, end):
1306         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1307 
1308 
1309 class RowRange(WindowFrame):
1310     frame_type = 'ROWS'
1311 
1312     def window_frame_start_end(self, connection, start, end):
1313         return connection.ops.window_frame_rows_start_end(start, end)
1314 
1315 
1316 class ValueRange(WindowFrame):
1317     frame_type = 'RANGE'
1318 
1319     def window_frame_start_end(self, connection, start, end):
1320         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>The intended behavior would ensure that Case and When expressions can encapsulate Window expressions without issue, propagating the necessary context or flags to successfully compile the SQL query.</intended_behavior>]
2025-10-17 23:47:07.115 | INFO     | Search completed. Bug locations: [<file>django/db/models/expressions.py</file>
<class>Window</class>
<method>None</method>
<code>
1156 class Window(Expression):
1157     template = '%(expression)s OVER (%(window)s)'
1158     # Although the main expression may either be an aggregate or an
1159     # expression with an aggregate function, the GROUP BY that will
1160     # be introduced in the query as a result is not desired.
1161     contains_aggregate = False
1162     contains_over_clause = True
1163     filterable = False
1164 
1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1166         self.partition_by = partition_by
1167         self.order_by = order_by
1168         self.frame = frame
1169 
1170         if not getattr(expression, 'window_compatible', False):
1171             raise ValueError(
1172                 "Expression '%s' isn't compatible with OVER clauses." %
1173                 expression.__class__.__name__
1174             )
1175 
1176         if self.partition_by is not None:
1177             if not isinstance(self.partition_by, (tuple, list)):
1178                 self.partition_by = (self.partition_by,)
1179             self.partition_by = ExpressionList(*self.partition_by)
1180 
1181         if self.order_by is not None:
1182             if isinstance(self.order_by, (list, tuple)):
1183                 self.order_by = ExpressionList(*self.order_by)
1184             elif not isinstance(self.order_by, BaseExpression):
1185                 raise ValueError(
1186                     'order_by must be either an Expression or a sequence of '
1187                     'expressions.'
1188                 )
1189         super().__init__(output_field=output_field)
1190         self.source_expression = self._parse_expressions(expression)[0]
1191 
1192     def _resolve_output_field(self):
1193         return self.source_expression.output_field
1194 
1195     def get_source_expressions(self):
1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1197 
1198     def set_source_expressions(self, exprs):
1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1200 
1201     def as_sql(self, compiler, connection, template=None):
1202         connection.ops.check_expression_support(self)
1203         if not connection.features.supports_over_clause:
1204             raise NotSupportedError('This backend does not support window expressions.')
1205         expr_sql, params = compiler.compile(self.source_expression)
1206         window_sql, window_params = [], []
1207 
1208         if self.partition_by is not None:
1209             sql_expr, sql_params = self.partition_by.as_sql(
1210                 compiler=compiler, connection=connection,
1211                 template='PARTITION BY %(expressions)s',
1212             )
1213             window_sql.extend(sql_expr)
1214             window_params.extend(sql_params)
1215 
1216         if self.order_by is not None:
1217             window_sql.append(' ORDER BY ')
1218             order_sql, order_params = compiler.compile(self.order_by)
1219             window_sql.extend(order_sql)
1220             window_params.extend(order_params)
1221 
1222         if self.frame:
1223             frame_sql, frame_params = compiler.compile(self.frame)
1224             window_sql.append(' ' + frame_sql)
1225             window_params.extend(frame_params)
1226 
1227         params.extend(window_params)
1228         template = template or self.template
1229 
1230         return template % {
1231             'expression': expr_sql,
1232             'window': ''.join(window_sql).strip()
1233         }, params
1234 
1235     def __str__(self):
1236         return '{} OVER ({}{}{})'.format(
1237             str(self.source_expression),
1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1240             str(self.frame or ''),
1241         )
1242 
1243     def __repr__(self):
1244         return '<%s: %s>' % (self.__class__.__name__, self)
1245 
1246     def get_group_by_cols(self, alias=None):
1247         return []

</code><intended_behavior>The intended behavior should include a validation or compilation pathway that recognizes and correctly handles Window expressions when used in such a context, properly generating the SQL without raising errors, ensuring that the use of window functions in SELECT clause conditionals is supported as per SQL standards.</intended_behavior>, <file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import inspect
4 from decimal import Decimal
5 
6 from django.core.exceptions import EmptyResultSet, FieldError
7 from django.db import connection
8 from django.db.models import fields
9 from django.db.models.query_utils import Q
10 from django.db.utils import NotSupportedError
11 from django.utils.deconstruct import deconstructible
12 from django.utils.functional import cached_property
13 from django.utils.hashable import make_hashable
14 
15 
16 class SQLiteNumericMixin:
17     """
18     Some expressions with output_field=DecimalField() must be cast to
19     numeric to be properly filtered.
20     """
21     def as_sqlite(self, compiler, connection, **extra_context):
22         sql, params = self.as_sql(compiler, connection, **extra_context)
23         try:
24             if self.output_field.get_internal_type() == 'DecimalField':
25                 sql = 'CAST(%s AS NUMERIC)' % sql
26         except FieldError:
27             pass
28         return sql, params
29 
30 
31 class Combinable:
32     """
33     Provide the ability to combine one or two objects with
34     some connector. For example F('foo') + F('bar').
35     """
36 
37     # Arithmetic connectors
38     ADD = '+'
39     SUB = '-'
40     MUL = '*'
41     DIV = '/'
42     POW = '^'
43     # The following is a quoted % operator - it is quoted because it can be
44     # used in strings that also have parameter substitution.
45     MOD = '%%'
46 
47     # Bitwise operators - note that these are generated by .bitand()
48     # and .bitor(), the '&' and '|' are reserved for boolean operator
49     # usage.
50     BITAND = '&'
51     BITOR = '|'
52     BITLEFTSHIFT = '<<'
53     BITRIGHTSHIFT = '>>'
54 
55     def _combine(self, other, connector, reversed):
56         if not hasattr(other, 'resolve_expression'):
57             # everything must be resolvable to an expression
58             if isinstance(other, datetime.timedelta):
59                 other = DurationValue(other, output_field=fields.DurationField())
60             else:
61                 other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def __or__(self, other):
109         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
110             return Q(self) | Q(other)
111         raise NotImplementedError(
112             "Use .bitand() and .bitor() for bitwise logical operations."
113         )
114 
115     def bitor(self, other):
116         return self._combine(other, self.BITOR, False)
117 
118     def __radd__(self, other):
119         return self._combine(other, self.ADD, True)
120 
121     def __rsub__(self, other):
122         return self._combine(other, self.SUB, True)
123 
124     def __rmul__(self, other):
125         return self._combine(other, self.MUL, True)
126 
127     def __rtruediv__(self, other):
128         return self._combine(other, self.DIV, True)
129 
130     def __rmod__(self, other):
131         return self._combine(other, self.MOD, True)
132 
133     def __rpow__(self, other):
134         return self._combine(other, self.POW, True)
135 
136     def __rand__(self, other):
137         raise NotImplementedError(
138             "Use .bitand() and .bitor() for bitwise logical operations."
139         )
140 
141     def __ror__(self, other):
142         raise NotImplementedError(
143             "Use .bitand() and .bitor() for bitwise logical operations."
144         )
145 
146 
147 @deconstructible
148 class BaseExpression:
149     """Base class for all query expressions."""
150 
151     # aggregate specific fields
152     is_summary = False
153     _output_field_resolved_to_none = False
154     # Can the expression be used in a WHERE clause?
155     filterable = True
156     # Can the expression can be used as a source expression in Window?
157     window_compatible = False
158 
159     def __init__(self, output_field=None):
160         if output_field is not None:
161             self.output_field = output_field
162 
163     def __getstate__(self):
164         state = self.__dict__.copy()
165         state.pop('convert_value', None)
166         return state
167 
168     def get_db_converters(self, connection):
169         return (
170             []
171             if self.convert_value is self._convert_value_noop else
172             [self.convert_value]
173         ) + self.output_field.get_db_converters(connection)
174 
175     def get_source_expressions(self):
176         return []
177 
178     def set_source_expressions(self, exprs):
179         assert not exprs
180 
181     def _parse_expressions(self, *expressions):
182         return [
183             arg if hasattr(arg, 'resolve_expression') else (
184                 F(arg) if isinstance(arg, str) else Value(arg)
185             ) for arg in expressions
186         ]
187 
188     def as_sql(self, compiler, connection):
189         """
190         Responsible for returning a (sql, [params]) tuple to be included
191         in the current query.
192 
193         Different backends can provide their own implementation, by
194         providing an `as_{vendor}` method and patching the Expression:
195 
196         ```
197         def override_as_sql(self, compiler, connection):
198             # custom logic
199             return super().as_sql(compiler, connection)
200         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
201         ```
202 
203         Arguments:
204          * compiler: the query compiler responsible for generating the query.
205            Must have a compile method, returning a (sql, [params]) tuple.
206            Calling compiler(value) will return a quoted `value`.
207 
208          * connection: the database connection used for the current query.
209 
210         Return: (sql, params)
211           Where `sql` is a string containing ordered sql parameters to be
212           replaced with the elements of the list `params`.
213         """
214         raise NotImplementedError("Subclasses must implement as_sql()")
215 
216     @cached_property
217     def contains_aggregate(self):
218         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
219 
220     @cached_property
221     def contains_over_clause(self):
222         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
223 
224     @cached_property
225     def contains_column_references(self):
226         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
227 
228     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
229         """
230         Provide the chance to do any preprocessing or validation before being
231         added to the query.
232 
233         Arguments:
234          * query: the backend query implementation
235          * allow_joins: boolean allowing or denying use of joins
236            in this query
237          * reuse: a set of reusable joins for multijoins
238          * summarize: a terminal aggregate clause
239          * for_save: whether this expression about to be used in a save or update
240 
241         Return: an Expression to be added to the query.
242         """
243         c = self.copy()
244         c.is_summary = summarize
245         c.set_source_expressions([
246             expr.resolve_expression(query, allow_joins, reuse, summarize)
247             if expr else None
248             for expr in c.get_source_expressions()
249         ])
250         return c
251 
252     @property
253     def conditional(self):
254         return isinstance(self.output_field, fields.BooleanField)
255 
256     @property
257     def field(self):
258         return self.output_field
259 
260     @cached_property
261     def output_field(self):
262         """Return the output type of this expressions."""
263         output_field = self._resolve_output_field()
264         if output_field is None:
265             self._output_field_resolved_to_none = True
266             raise FieldError('Cannot resolve expression type, unknown output_field')
267         return output_field
268 
269     @cached_property
270     def _output_field_or_none(self):
271         """
272         Return the output field of this expression, or None if
273         _resolve_output_field() didn't return an output type.
274         """
275         try:
276             return self.output_field
277         except FieldError:
278             if not self._output_field_resolved_to_none:
279                 raise
280 
281     def _resolve_output_field(self):
282         """
283         Attempt to infer the output type of the expression. If the output
284         fields of all source fields match then, simply infer the same type
285         here. This isn't always correct, but it makes sense most of the time.
286 
287         Consider the difference between `2 + 2` and `2 / 3`. Inferring
288         the type here is a convenience for the common case. The user should
289         supply their own output_field with more complex computations.
290 
291         If a source's output field resolves to None, exclude it from this check.
292         If all sources are None, then an error is raised higher up the stack in
293         the output_field property.
294         """
295         sources_iter = (source for source in self.get_source_fields() if source is not None)
296         for output_field in sources_iter:
297             for source in sources_iter:
298                 if not isinstance(output_field, source.__class__):
299                     raise FieldError(
300                         'Expression contains mixed types: %s, %s. You must '
301                         'set output_field.' % (
302                             output_field.__class__.__name__,
303                             source.__class__.__name__,
304                         )
305                     )
306             return output_field
307 
308     @staticmethod
309     def _convert_value_noop(value, expression, connection):
310         return value
311 
312     @cached_property
313     def convert_value(self):
314         """
315         Expressions provide their own converters because users have the option
316         of manually specifying the output_field which may be a different type
317         from the one the database returns.
318         """
319         field = self.output_field
320         internal_type = field.get_internal_type()
321         if internal_type == 'FloatField':
322             return lambda value, expression, connection: None if value is None else float(value)
323         elif internal_type.endswith('IntegerField'):
324             return lambda value, expression, connection: None if value is None else int(value)
325         elif internal_type == 'DecimalField':
326             return lambda value, expression, connection: None if value is None else Decimal(value)
327         return self._convert_value_noop
328 
329     def get_lookup(self, lookup):
330         return self.output_field.get_lookup(lookup)
331 
332     def get_transform(self, name):
333         return self.output_field.get_transform(name)
334 
335     def relabeled_clone(self, change_map):
336         clone = self.copy()
337         clone.set_source_expressions([
338             e.relabeled_clone(change_map) if e is not None else None
339             for e in self.get_source_expressions()
340         ])
341         return clone
342 
343     def copy(self):
344         return copy.copy(self)
345 
346     def get_group_by_cols(self, alias=None):
347         if not self.contains_aggregate:
348             return [self]
349         cols = []
350         for source in self.get_source_expressions():
351             cols.extend(source.get_group_by_cols())
352         return cols
353 
354     def get_source_fields(self):
355         """Return the underlying field types used by this aggregate."""
356         return [e._output_field_or_none for e in self.get_source_expressions()]
357 
358     def asc(self, **kwargs):
359         return OrderBy(self, **kwargs)
360 
361     def desc(self, **kwargs):
362         return OrderBy(self, descending=True, **kwargs)
363 
364     def reverse_ordering(self):
365         return self
366 
367     def flatten(self):
368         """
369         Recursively yield this expression and all subexpressions, in
370         depth-first order.
371         """
372         yield self
373         for expr in self.get_source_expressions():
374             if expr:
375                 yield from expr.flatten()
376 
377     def select_format(self, compiler, sql, params):
378         """
379         Custom format for select clauses. For example, EXISTS expressions need
380         to be wrapped in CASE WHEN on Oracle.
381         """
382         return self.output_field.select_format(compiler, sql, params)
383 
384     @cached_property
385     def identity(self):
386         constructor_signature = inspect.signature(self.__init__)
387         args, kwargs = self._constructor_args
388         signature = constructor_signature.bind_partial(*args, **kwargs)
389         signature.apply_defaults()
390         arguments = signature.arguments.items()
391         identity = [self.__class__]
392         for arg, value in arguments:
393             if isinstance(value, fields.Field):
394                 if value.name and value.model:
395                     value = (value.model._meta.label, value.name)
396                 else:
397                     value = type(value)
398             else:
399                 value = make_hashable(value)
400             identity.append((arg, value))
401         return tuple(identity)
402 
403     def __eq__(self, other):
404         if not isinstance(other, BaseExpression):
405             return NotImplemented
406         return other.identity == self.identity
407 
408     def __hash__(self):
409         return hash(self.identity)
410 
411 
412 class Expression(BaseExpression, Combinable):
413     """An expression that can be combined with other expressions."""
414     pass
415 
416 
417 class CombinedExpression(SQLiteNumericMixin, Expression):
418 
419     def __init__(self, lhs, connector, rhs, output_field=None):
420         super().__init__(output_field=output_field)
421         self.connector = connector
422         self.lhs = lhs
423         self.rhs = rhs
424 
425     def __repr__(self):
426         return "<{}: {}>".format(self.__class__.__name__, self)
427 
428     def __str__(self):
429         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
430 
431     def get_source_expressions(self):
432         return [self.lhs, self.rhs]
433 
434     def set_source_expressions(self, exprs):
435         self.lhs, self.rhs = exprs
436 
437     def as_sql(self, compiler, connection):
438         try:
439             lhs_output = self.lhs.output_field
440         except FieldError:
441             lhs_output = None
442         try:
443             rhs_output = self.rhs.output_field
444         except FieldError:
445             rhs_output = None
446         if (not connection.features.has_native_duration_field and
447                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or
448                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):
449             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)
450         if (lhs_output and rhs_output and self.connector == self.SUB and
451             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and
452                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):
453             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)
454         expressions = []
455         expression_params = []
456         sql, params = compiler.compile(self.lhs)
457         expressions.append(sql)
458         expression_params.extend(params)
459         sql, params = compiler.compile(self.rhs)
460         expressions.append(sql)
461         expression_params.extend(params)
462         # order of precedence
463         expression_wrapper = '(%s)'
464         sql = connection.ops.combine_expression(self.connector, expressions)
465         return expression_wrapper % sql, expression_params
466 
467     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
468         c = self.copy()
469         c.is_summary = summarize
470         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
471         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
472         return c
473 
474 
475 class DurationExpression(CombinedExpression):
476     def compile(self, side, compiler, connection):
477         if not isinstance(side, DurationValue):
478             try:
479                 output = side.output_field
480             except FieldError:
481                 pass
482             else:
483                 if output.get_internal_type() == 'DurationField':
484                     sql, params = compiler.compile(side)
485                     return connection.ops.format_for_duration_arithmetic(sql), params
486         return compiler.compile(side)
487 
488     def as_sql(self, compiler, connection):
489         connection.ops.check_expression_support(self)
490         expressions = []
491         expression_params = []
492         sql, params = self.compile(self.lhs, compiler, connection)
493         expressions.append(sql)
494         expression_params.extend(params)
495         sql, params = self.compile(self.rhs, compiler, connection)
496         expressions.append(sql)
497         expression_params.extend(params)
498         # order of precedence
499         expression_wrapper = '(%s)'
500         sql = connection.ops.combine_duration_expression(self.connector, expressions)
501         return expression_wrapper % sql, expression_params
502 
503 
504 class TemporalSubtraction(CombinedExpression):
505     output_field = fields.DurationField()
506 
507     def __init__(self, lhs, rhs):
508         super().__init__(lhs, self.SUB, rhs)
509 
510     def as_sql(self, compiler, connection):
511         connection.ops.check_expression_support(self)
512         lhs = compiler.compile(self.lhs)
513         rhs = compiler.compile(self.rhs)
514         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
515 
516 
517 @deconstructible
518 class F(Combinable):
519     """An object capable of resolving references to existing query objects."""
520 
521     def __init__(self, name):
522         """
523         Arguments:
524          * name: the name of the field this expression references
525         """
526         self.name = name
527 
528     def __repr__(self):
529         return "{}({})".format(self.__class__.__name__, self.name)
530 
531     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
532                            summarize=False, for_save=False):
533         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
534 
535     def asc(self, **kwargs):
536         return OrderBy(self, **kwargs)
537 
538     def desc(self, **kwargs):
539         return OrderBy(self, descending=True, **kwargs)
540 
541     def __eq__(self, other):
542         return self.__class__ == other.__class__ and self.name == other.name
543 
544     def __hash__(self):
545         return hash(self.name)
546 
547 
548 class ResolvedOuterRef(F):
549     """
550     An object that contains a reference to an outer query.
551 
552     In this case, the reference to the outer query has been resolved because
553     the inner query has been used as a subquery.
554     """
555     contains_aggregate = False
556 
557     def as_sql(self, *args, **kwargs):
558         raise ValueError(
559             'This queryset contains a reference to an outer query and may '
560             'only be used in a subquery.'
561         )
562 
563     def relabeled_clone(self, relabels):
564         return self
565 
566 
567 class OuterRef(F):
568     def resolve_expression(self, *args, **kwargs):
569         if isinstance(self.name, self.__class__):
570             return self.name
571         return ResolvedOuterRef(self.name)
572 
573 
574 class Func(SQLiteNumericMixin, Expression):
575     """An SQL function call."""
576     function = None
577     template = '%(function)s(%(expressions)s)'
578     arg_joiner = ', '
579     arity = None  # The number of arguments the function accepts.
580 
581     def __init__(self, *expressions, output_field=None, **extra):
582         if self.arity is not None and len(expressions) != self.arity:
583             raise TypeError(
584                 "'%s' takes exactly %s %s (%s given)" % (
585                     self.__class__.__name__,
586                     self.arity,
587                     "argument" if self.arity == 1 else "arguments",
588                     len(expressions),
589                 )
590             )
591         super().__init__(output_field=output_field)
592         self.source_expressions = self._parse_expressions(*expressions)
593         self.extra = extra
594 
595     def __repr__(self):
596         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
597         extra = {**self.extra, **self._get_repr_options()}
598         if extra:
599             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
600             return "{}({}, {})".format(self.__class__.__name__, args, extra)
601         return "{}({})".format(self.__class__.__name__, args)
602 
603     def _get_repr_options(self):
604         """Return a dict of extra __init__() options to include in the repr."""
605         return {}
606 
607     def get_source_expressions(self):
608         return self.source_expressions
609 
610     def set_source_expressions(self, exprs):
611         self.source_expressions = exprs
612 
613     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
614         c = self.copy()
615         c.is_summary = summarize
616         for pos, arg in enumerate(c.source_expressions):
617             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
618         return c
619 
620     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
621         connection.ops.check_expression_support(self)
622         sql_parts = []
623         params = []
624         for arg in self.source_expressions:
625             arg_sql, arg_params = compiler.compile(arg)
626             sql_parts.append(arg_sql)
627             params.extend(arg_params)
628         data = {**self.extra, **extra_context}
629         # Use the first supplied value in this order: the parameter to this
630         # method, a value supplied in __init__()'s **extra (the value in
631         # `data`), or the value defined on the class.
632         if function is not None:
633             data['function'] = function
634         else:
635             data.setdefault('function', self.function)
636         template = template or data.get('template', self.template)
637         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
638         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
639         return template % data, params
640 
641     def copy(self):
642         copy = super().copy()
643         copy.source_expressions = self.source_expressions[:]
644         copy.extra = self.extra.copy()
645         return copy
646 
647 
648 class Value(Expression):
649     """Represent a wrapped value as a node within an expression."""
650     def __init__(self, value, output_field=None):
651         """
652         Arguments:
653          * value: the value this expression represents. The value will be
654            added into the sql parameter list and properly quoted.
655 
656          * output_field: an instance of the model field type that this
657            expression will return, such as IntegerField() or CharField().
658         """
659         super().__init__(output_field=output_field)
660         self.value = value
661 
662     def __repr__(self):
663         return "{}({})".format(self.__class__.__name__, self.value)
664 
665     def as_sql(self, compiler, connection):
666         connection.ops.check_expression_support(self)
667         val = self.value
668         output_field = self._output_field_or_none
669         if output_field is not None:
670             if self.for_save:
671                 val = output_field.get_db_prep_save(val, connection=connection)
672             else:
673                 val = output_field.get_db_prep_value(val, connection=connection)
674             if hasattr(output_field, 'get_placeholder'):
675                 return output_field.get_placeholder(val, compiler, connection), [val]
676         if val is None:
677             # cx_Oracle does not always convert None to the appropriate
678             # NULL type (like in case expressions using numbers), so we
679             # use a literal SQL NULL
680             return 'NULL', []
681         return '%s', [val]
682 
683     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
684         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
685         c.for_save = for_save
686         return c
687 
688     def get_group_by_cols(self, alias=None):
689         return []
690 
691 
692 class DurationValue(Value):
693     def as_sql(self, compiler, connection):
694         connection.ops.check_expression_support(self)
695         if connection.features.has_native_duration_field:
696             return super().as_sql(compiler, connection)
697         return connection.ops.date_interval_sql(self.value), []
698 
699 
700 class RawSQL(Expression):
701     def __init__(self, sql, params, output_field=None):
702         if output_field is None:
703             output_field = fields.Field()
704         self.sql, self.params = sql, params
705         super().__init__(output_field=output_field)
706 
707     def __repr__(self):
708         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
709 
710     def as_sql(self, compiler, connection):
711         return '(%s)' % self.sql, self.params
712 
713     def get_group_by_cols(self, alias=None):
714         return [self]
715 
716     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
717         # Resolve parents fields used in raw SQL.
718         for parent in query.model._meta.get_parent_list():
719             for parent_field in parent._meta.local_fields:
720                 _, column_name = parent_field.get_attname_column()
721                 if column_name.lower() in self.sql.lower():
722                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
723                     break
724         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
725 
726 
727 class Star(Expression):
728     def __repr__(self):
729         return "'*'"
730 
731     def as_sql(self, compiler, connection):
732         return '*', []
733 
734 
735 class Random(Expression):
736     output_field = fields.FloatField()
737 
738     def __repr__(self):
739         return "Random()"
740 
741     def as_sql(self, compiler, connection):
742         return connection.ops.random_function_sql(), []
743 
744 
745 class Col(Expression):
746 
747     contains_column_references = True
748 
749     def __init__(self, alias, target, output_field=None):
750         if output_field is None:
751             output_field = target
752         super().__init__(output_field=output_field)
753         self.alias, self.target = alias, target
754 
755     def __repr__(self):
756         alias, target = self.alias, self.target
757         identifiers = (alias, str(target)) if alias else (str(target),)
758         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
759 
760     def as_sql(self, compiler, connection):
761         alias, column = self.alias, self.target.column
762         identifiers = (alias, column) if alias else (column,)
763         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
764         return sql, []
765 
766     def relabeled_clone(self, relabels):
767         if self.alias is None:
768             return self
769         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
770 
771     def get_group_by_cols(self, alias=None):
772         return [self]
773 
774     def get_db_converters(self, connection):
775         if self.target == self.output_field:
776             return self.output_field.get_db_converters(connection)
777         return (self.output_field.get_db_converters(connection) +
778                 self.target.get_db_converters(connection))
779 
780 
781 class Ref(Expression):
782     """
783     Reference to column alias of the query. For example, Ref('sum_cost') in
784     qs.annotate(sum_cost=Sum('cost')) query.
785     """
786     def __init__(self, refs, source):
787         super().__init__()
788         self.refs, self.source = refs, source
789 
790     def __repr__(self):
791         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
792 
793     def get_source_expressions(self):
794         return [self.source]
795 
796     def set_source_expressions(self, exprs):
797         self.source, = exprs
798 
799     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
800         # The sub-expression `source` has already been resolved, as this is
801         # just a reference to the name of `source`.
802         return self
803 
804     def relabeled_clone(self, relabels):
805         return self
806 
807     def as_sql(self, compiler, connection):
808         return connection.ops.quote_name(self.refs), []
809 
810     def get_group_by_cols(self, alias=None):
811         return [self]
812 
813 
814 class ExpressionList(Func):
815     """
816     An expression containing multiple expressions. Can be used to provide a
817     list of expressions as an argument to another expression, like an
818     ordering clause.
819     """
820     template = '%(expressions)s'
821 
822     def __init__(self, *expressions, **extra):
823         if not expressions:
824             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
825         super().__init__(*expressions, **extra)
826 
827     def __str__(self):
828         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
829 
830 
831 class ExpressionWrapper(Expression):
832     """
833     An expression that can wrap another expression so that it can provide
834     extra context to the inner expression, such as the output_field.
835     """
836 
837     def __init__(self, expression, output_field):
838         super().__init__(output_field=output_field)
839         self.expression = expression
840 
841     def set_source_expressions(self, exprs):
842         self.expression = exprs[0]
843 
844     def get_source_expressions(self):
845         return [self.expression]
846 
847     def as_sql(self, compiler, connection):
848         return self.expression.as_sql(compiler, connection)
849 
850     def __repr__(self):
851         return "{}({})".format(self.__class__.__name__, self.expression)
852 
853 
854 class When(Expression):
855     template = 'WHEN %(condition)s THEN %(result)s'
856     # This isn't a complete conditional expression, must be used in Case().
857     conditional = False
858 
859     def __init__(self, condition=None, then=None, **lookups):
860         if lookups and condition is None:
861             condition, lookups = Q(**lookups), None
862         if condition is None or not getattr(condition, 'conditional', False) or lookups:
863             raise TypeError(
864                 'When() supports a Q object, a boolean expression, or lookups '
865                 'as a condition.'
866             )
867         if isinstance(condition, Q) and not condition:
868             raise ValueError("An empty Q() can't be used as a When() condition.")
869         super().__init__(output_field=None)
870         self.condition = condition
871         self.result = self._parse_expressions(then)[0]
872 
873     def __str__(self):
874         return "WHEN %r THEN %r" % (self.condition, self.result)
875 
876     def __repr__(self):
877         return "<%s: %s>" % (self.__class__.__name__, self)
878 
879     def get_source_expressions(self):
880         return [self.condition, self.result]
881 
882     def set_source_expressions(self, exprs):
883         self.condition, self.result = exprs
884 
885     def get_source_fields(self):
886         # We're only interested in the fields of the result expressions.
887         return [self.result._output_field_or_none]
888 
889     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
890         c = self.copy()
891         c.is_summary = summarize
892         if hasattr(c.condition, 'resolve_expression'):
893             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
894         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
895         return c
896 
897     def as_sql(self, compiler, connection, template=None, **extra_context):
898         connection.ops.check_expression_support(self)
899         template_params = extra_context
900         sql_params = []
901         condition_sql, condition_params = compiler.compile(self.condition)
902         template_params['condition'] = condition_sql
903         sql_params.extend(condition_params)
904         result_sql, result_params = compiler.compile(self.result)
905         template_params['result'] = result_sql
906         sql_params.extend(result_params)
907         template = template or self.template
908         return template % template_params, sql_params
909 
910     def get_group_by_cols(self, alias=None):
911         # This is not a complete expression and cannot be used in GROUP BY.
912         cols = []
913         for source in self.get_source_expressions():
914             cols.extend(source.get_group_by_cols())
915         return cols
916 
917 
918 class Case(Expression):
919     """
920     An SQL searched CASE expression:
921 
922         CASE
923             WHEN n > 0
924                 THEN 'positive'
925             WHEN n < 0
926                 THEN 'negative'
927             ELSE 'zero'
928         END
929     """
930     template = 'CASE %(cases)s ELSE %(default)s END'
931     case_joiner = ' '
932 
933     def __init__(self, *cases, default=None, output_field=None, **extra):
934         if not all(isinstance(case, When) for case in cases):
935             raise TypeError("Positional arguments must all be When objects.")
936         super().__init__(output_field)
937         self.cases = list(cases)
938         self.default = self._parse_expressions(default)[0]
939         self.extra = extra
940 
941     def __str__(self):
942         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
943 
944     def __repr__(self):
945         return "<%s: %s>" % (self.__class__.__name__, self)
946 
947     def get_source_expressions(self):
948         return self.cases + [self.default]
949 
950     def set_source_expressions(self, exprs):
951         *self.cases, self.default = exprs
952 
953     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
954         c = self.copy()
955         c.is_summary = summarize
956         for pos, case in enumerate(c.cases):
957             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
958         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
959         return c
960 
961     def copy(self):
962         c = super().copy()
963         c.cases = c.cases[:]
964         return c
965 
966     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
967         connection.ops.check_expression_support(self)
968         if not self.cases:
969             return compiler.compile(self.default)
970         template_params = {**self.extra, **extra_context}
971         case_parts = []
972         sql_params = []
973         for case in self.cases:
974             try:
975                 case_sql, case_params = compiler.compile(case)
976             except EmptyResultSet:
977                 continue
978             case_parts.append(case_sql)
979             sql_params.extend(case_params)
980         default_sql, default_params = compiler.compile(self.default)
981         if not case_parts:
982             return default_sql, default_params
983         case_joiner = case_joiner or self.case_joiner
984         template_params['cases'] = case_joiner.join(case_parts)
985         template_params['default'] = default_sql
986         sql_params.extend(default_params)
987         template = template or template_params.get('template', self.template)
988         sql = template % template_params
989         if self._output_field_or_none is not None:
990             sql = connection.ops.unification_cast_sql(self.output_field) % sql
991         return sql, sql_params
992 
993 
994 class Subquery(Expression):
995     """
996     An explicit subquery. It may contain OuterRef() references to the outer
997     query which will be resolved when it is applied to that query.
998     """
999     template = '(%(subquery)s)'
1000     contains_aggregate = False
1001 
1002     def __init__(self, queryset, output_field=None, **extra):
1003         self.query = queryset.query
1004         self.extra = extra
1005         super().__init__(output_field)
1006 
1007     def __getstate__(self):
1008         state = super().__getstate__()
1009         state.pop('_constructor_args', None)
1010         return state
1011 
1012     def get_source_expressions(self):
1013         return [self.query]
1014 
1015     def set_source_expressions(self, exprs):
1016         self.query = exprs[0]
1017 
1018     def _resolve_output_field(self):
1019         return self.query.output_field
1020 
1021     def copy(self):
1022         clone = super().copy()
1023         clone.query = clone.query.clone()
1024         return clone
1025 
1026     @property
1027     def external_aliases(self):
1028         return self.query.external_aliases
1029 
1030     def as_sql(self, compiler, connection, template=None, **extra_context):
1031         connection.ops.check_expression_support(self)
1032         template_params = {**self.extra, **extra_context}
1033         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
1034         template_params['subquery'] = subquery_sql[1:-1]
1035 
1036         template = template or template_params.get('template', self.template)
1037         sql = template % template_params
1038         return sql, sql_params
1039 
1040     def get_group_by_cols(self, alias=None):
1041         if alias:
1042             return [Ref(alias, self)]
1043         return []
1044 
1045 
1046 class Exists(Subquery):
1047     template = 'EXISTS(%(subquery)s)'
1048     output_field = fields.BooleanField()
1049 
1050     def __init__(self, queryset, negated=False, **kwargs):
1051         # As a performance optimization, remove ordering since EXISTS doesn't
1052         # care about it, just whether or not a row matches.
1053         queryset = queryset.order_by()
1054         self.negated = negated
1055         super().__init__(queryset, **kwargs)
1056 
1057     def __invert__(self):
1058         clone = self.copy()
1059         clone.negated = not self.negated
1060         return clone
1061 
1062     def as_sql(self, compiler, connection, template=None, **extra_context):
1063         sql, params = super().as_sql(compiler, connection, template, **extra_context)
1064         if self.negated:
1065             sql = 'NOT {}'.format(sql)
1066         return sql, params
1067 
1068     def select_format(self, compiler, sql, params):
1069         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1070         # (e.g. Oracle) doesn't support boolean expression in the SELECT list.
1071         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1072             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1073         return sql, params
1074 
1075 
1076 class OrderBy(BaseExpression):
1077     template = '%(expression)s %(ordering)s'
1078     conditional = False
1079 
1080     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1081         if nulls_first and nulls_last:
1082             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1083         self.nulls_first = nulls_first
1084         self.nulls_last = nulls_last
1085         self.descending = descending
1086         if not hasattr(expression, 'resolve_expression'):
1087             raise ValueError('expression must be an expression type')
1088         self.expression = expression
1089 
1090     def __repr__(self):
1091         return "{}({}, descending={})".format(
1092             self.__class__.__name__, self.expression, self.descending)
1093 
1094     def set_source_expressions(self, exprs):
1095         self.expression = exprs[0]
1096 
1097     def get_source_expressions(self):
1098         return [self.expression]
1099 
1100     def as_sql(self, compiler, connection, template=None, **extra_context):
1101         template = template or self.template
1102         if connection.features.supports_order_by_nulls_modifier:
1103             if self.nulls_last:
1104                 template = '%s NULLS LAST' % template
1105             elif self.nulls_first:
1106                 template = '%s NULLS FIRST' % template
1107         else:
1108             if self.nulls_last:
1109                 template = '%%(expression)s IS NULL, %s' % template
1110             elif self.nulls_first:
1111                 template = '%%(expression)s IS NOT NULL, %s' % template
1112         connection.ops.check_expression_support(self)
1113         expression_sql, params = compiler.compile(self.expression)
1114         placeholders = {
1115             'expression': expression_sql,
1116             'ordering': 'DESC' if self.descending else 'ASC',
1117             **extra_context,
1118         }
1119         template = template or self.template
1120         params *= template.count('%(expression)s')
1121         return (template % placeholders).rstrip(), params
1122 
1123     def as_oracle(self, compiler, connection):
1124         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in
1125         # a CASE WHEN.
1126         if isinstance(self.expression, Exists):
1127             copy = self.copy()
1128             copy.expression = Case(
1129                 When(self.expression, then=True),
1130                 default=False,
1131                 output_field=fields.BooleanField(),
1132             )
1133             return copy.as_sql(compiler, connection)
1134         return self.as_sql(compiler, connection)
1135 
1136     def get_group_by_cols(self, alias=None):
1137         cols = []
1138         for source in self.get_source_expressions():
1139             cols.extend(source.get_group_by_cols())
1140         return cols
1141 
1142     def reverse_ordering(self):
1143         self.descending = not self.descending
1144         if self.nulls_first or self.nulls_last:
1145             self.nulls_first = not self.nulls_first
1146             self.nulls_last = not self.nulls_last
1147         return self
1148 
1149     def asc(self):
1150         self.descending = False
1151 
1152     def desc(self):
1153         self.descending = True
1154 
1155 
1156 class Window(Expression):
1157     template = '%(expression)s OVER (%(window)s)'
1158     # Although the main expression may either be an aggregate or an
1159     # expression with an aggregate function, the GROUP BY that will
1160     # be introduced in the query as a result is not desired.
1161     contains_aggregate = False
1162     contains_over_clause = True
1163     filterable = False
1164 
1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1166         self.partition_by = partition_by
1167         self.order_by = order_by
1168         self.frame = frame
1169 
1170         if not getattr(expression, 'window_compatible', False):
1171             raise ValueError(
1172                 "Expression '%s' isn't compatible with OVER clauses." %
1173                 expression.__class__.__name__
1174             )
1175 
1176         if self.partition_by is not None:
1177             if not isinstance(self.partition_by, (tuple, list)):
1178                 self.partition_by = (self.partition_by,)
1179             self.partition_by = ExpressionList(*self.partition_by)
1180 
1181         if self.order_by is not None:
1182             if isinstance(self.order_by, (list, tuple)):
1183                 self.order_by = ExpressionList(*self.order_by)
1184             elif not isinstance(self.order_by, BaseExpression):
1185                 raise ValueError(
1186                     'order_by must be either an Expression or a sequence of '
1187                     'expressions.'
1188                 )
1189         super().__init__(output_field=output_field)
1190         self.source_expression = self._parse_expressions(expression)[0]
1191 
1192     def _resolve_output_field(self):
1193         return self.source_expression.output_field
1194 
1195     def get_source_expressions(self):
1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1197 
1198     def set_source_expressions(self, exprs):
1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1200 
1201     def as_sql(self, compiler, connection, template=None):
1202         connection.ops.check_expression_support(self)
1203         if not connection.features.supports_over_clause:
1204             raise NotSupportedError('This backend does not support window expressions.')
1205         expr_sql, params = compiler.compile(self.source_expression)
1206         window_sql, window_params = [], []
1207 
1208         if self.partition_by is not None:
1209             sql_expr, sql_params = self.partition_by.as_sql(
1210                 compiler=compiler, connection=connection,
1211                 template='PARTITION BY %(expressions)s',
1212             )
1213             window_sql.extend(sql_expr)
1214             window_params.extend(sql_params)
1215 
1216         if self.order_by is not None:
1217             window_sql.append(' ORDER BY ')
1218             order_sql, order_params = compiler.compile(self.order_by)
1219             window_sql.extend(order_sql)
1220             window_params.extend(order_params)
1221 
1222         if self.frame:
1223             frame_sql, frame_params = compiler.compile(self.frame)
1224             window_sql.append(' ' + frame_sql)
1225             window_params.extend(frame_params)
1226 
1227         params.extend(window_params)
1228         template = template or self.template
1229 
1230         return template % {
1231             'expression': expr_sql,
1232             'window': ''.join(window_sql).strip()
1233         }, params
1234 
1235     def __str__(self):
1236         return '{} OVER ({}{}{})'.format(
1237             str(self.source_expression),
1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1240             str(self.frame or ''),
1241         )
1242 
1243     def __repr__(self):
1244         return '<%s: %s>' % (self.__class__.__name__, self)
1245 
1246     def get_group_by_cols(self, alias=None):
1247         return []
1248 
1249 
1250 class WindowFrame(Expression):
1251     """
1252     Model the frame clause in window expressions. There are two types of frame
1253     clauses which are subclasses, however, all processing and validation (by no
1254     means intended to be complete) is done here. Thus, providing an end for a
1255     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1256     row in the frame).
1257     """
1258     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1259 
1260     def __init__(self, start=None, end=None):
1261         self.start = Value(start)
1262         self.end = Value(end)
1263 
1264     def set_source_expressions(self, exprs):
1265         self.start, self.end = exprs
1266 
1267     def get_source_expressions(self):
1268         return [self.start, self.end]
1269 
1270     def as_sql(self, compiler, connection):
1271         connection.ops.check_expression_support(self)
1272         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1273         return self.template % {
1274             'frame_type': self.frame_type,
1275             'start': start,
1276             'end': end,
1277         }, []
1278 
1279     def __repr__(self):
1280         return '<%s: %s>' % (self.__class__.__name__, self)
1281 
1282     def get_group_by_cols(self, alias=None):
1283         return []
1284 
1285     def __str__(self):
1286         if self.start.value is not None and self.start.value < 0:
1287             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1288         elif self.start.value is not None and self.start.value == 0:
1289             start = connection.ops.CURRENT_ROW
1290         else:
1291             start = connection.ops.UNBOUNDED_PRECEDING
1292 
1293         if self.end.value is not None and self.end.value > 0:
1294             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1295         elif self.end.value is not None and self.end.value == 0:
1296             end = connection.ops.CURRENT_ROW
1297         else:
1298             end = connection.ops.UNBOUNDED_FOLLOWING
1299         return self.template % {
1300             'frame_type': self.frame_type,
1301             'start': start,
1302             'end': end,
1303         }
1304 
1305     def window_frame_start_end(self, connection, start, end):
1306         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1307 
1308 
1309 class RowRange(WindowFrame):
1310     frame_type = 'ROWS'
1311 
1312     def window_frame_start_end(self, connection, start, end):
1313         return connection.ops.window_frame_rows_start_end(start, end)
1314 
1315 
1316 class ValueRange(WindowFrame):
1317     frame_type = 'RANGE'
1318 
1319     def window_frame_start_end(self, connection, start, end):
1320         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>The intended behavior would ensure that Case and When expressions can encapsulate Window expressions without issue, propagating the necessary context or flags to successfully compile the SQL query.</intended_behavior>]
2025-10-17 23:47:07.116 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 23:47:07.116 | INFO     | Search-only: skipping patch selection
2025-10-17 23:47:07.292 | INFO     | Task django__django-12185 completed successfully.
2025-10-17 23:47:07.293 | INFO     | No patch generated. You can try running ACR again.
