[
    {
        "rel_file_path": "sklearn/utils/metaestimators.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.20/sklearn/utils/metaestimators.py",
        "start": 38,
        "end": 50,
        "class_name": "_BaseComposition",
        "method_name": "_set_params",
        "code": "38     def _set_params(self, attr, **params):\n39         # Ensure strict ordering of parameter setting:\n40         # 1. All steps\n41         if attr in params:\n42             setattr(self, attr, params.pop(attr))\n43         # 2. Step replacement\n44         names, _ = zip(*getattr(self, attr))\n45         for name in list(six.iterkeys(params)):\n46             if '__' not in name and name in names:\n47                 self._replace_estimator(attr, name, params.pop(name))\n48         # 3. Step parameters and other initialisation arguments\n49         super(_BaseComposition, self).set_params(**params)\n50         return self\n",
        "intended_behavior": "To resolve the issue, the `_set_params` method should be modified to handle the case when there are no transformers (or estimators) to set parameters on. Specifically, before the line attempting to unpack names with `names, _ = zip(*getattr(self, attr))`, the method should check if `getattr(self, attr)` is an empty list. If it is, the method should skip the unpacking process and directly proceed to the next steps of setting parameters. This change ensures that the method can gracefully handle scenarios where there are no estimators in the composition, thereby preventing the `ValueError` described in the issue. This behavior should preserve the existing functionality of setting parameters when there are estimators while also accommodating compositions with no estimators without causing errors."
    },
    {
        "rel_file_path": "sklearn/utils/metaestimators.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.20/sklearn/utils/metaestimators.py",
        "start": 18,
        "end": 72,
        "class_name": "_BaseComposition",
        "method_name": null,
        "code": "18 class _BaseComposition(six.with_metaclass(ABCMeta, BaseEstimator)):\n19     \"\"\"Handles parameter management for classifiers composed of named estimators.\n20     \"\"\"\n21     @abstractmethod\n22     def __init__(self):\n23         pass\n24 \n25     def _get_params(self, attr, deep=True):\n26         out = super(_BaseComposition, self).get_params(deep=deep)\n27         if not deep:\n28             return out\n29         estimators = getattr(self, attr)\n30         out.update(estimators)\n31         for name, estimator in estimators:\n32             if hasattr(estimator, 'get_params'):\n33                 for key, value in six.iteritems(\n34                         estimator.get_params(deep=True)):\n35                     out['%s__%s' % (name, key)] = value\n36         return out\n37 \n38     def _set_params(self, attr, **params):\n39         # Ensure strict ordering of parameter setting:\n40         # 1. All steps\n41         if attr in params:\n42             setattr(self, attr, params.pop(attr))\n43         # 2. Step replacement\n44         names, _ = zip(*getattr(self, attr))\n45         for name in list(six.iterkeys(params)):\n46             if '__' not in name and name in names:\n47                 self._replace_estimator(attr, name, params.pop(name))\n48         # 3. Step parameters and other initialisation arguments\n49         super(_BaseComposition, self).set_params(**params)\n50         return self\n51 \n52     def _replace_estimator(self, attr, name, new_val):\n53         # assumes `name` is a valid estimator name\n54         new_estimators = list(getattr(self, attr))\n55         for i, (estimator_name, _) in enumerate(new_estimators):\n56             if estimator_name == name:\n57                 new_estimators[i] = (name, new_val)\n58                 break\n59         setattr(self, attr, new_estimators)\n60 \n61     def _validate_names(self, names):\n62         if len(set(names)) != len(names):\n63             raise ValueError('Names provided are not unique: '\n64                              '{0!r}'.format(list(names)))\n65         invalid_names = set(names).intersection(self.get_params(deep=False))\n66         if invalid_names:\n67             raise ValueError('Estimator names conflict with constructor '\n68                              'arguments: {0!r}'.format(sorted(invalid_names)))\n69         invalid_names = [name for name in names if '__' in name]\n70         if invalid_names:\n71             raise ValueError('Estimator names must not contain __: got '\n72                              '{0!r}'.format(invalid_names))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]