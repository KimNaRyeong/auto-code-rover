[
    {
        "rel_file_path": "sympy/core/sympify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/sympify.py",
        "start": 1,
        "end": 520,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"sympify -- convert objects SymPy internal format\"\"\"\n2 \n3 from __future__ import print_function, division\n4 \n5 from inspect import getmro\n6 \n7 from .core import all_classes as sympy_classes\n8 from .compatibility import iterable, string_types, range\n9 from .evaluate import global_evaluate\n10 \n11 \n12 class SympifyError(ValueError):\n13     def __init__(self, expr, base_exc=None):\n14         self.expr = expr\n15         self.base_exc = base_exc\n16 \n17     def __str__(self):\n18         if self.base_exc is None:\n19             return \"SympifyError: %r\" % (self.expr,)\n20 \n21         return (\"Sympify of expression '%s' failed, because of exception being \"\n22             \"raised:\\n%s: %s\" % (self.expr, self.base_exc.__class__.__name__,\n23             str(self.base_exc)))\n24 \n25 converter = {}  # See sympify docstring.\n26 \n27 class CantSympify(object):\n28     \"\"\"\n29     Mix in this trait to a class to disallow sympification of its instances.\n30 \n31     Examples\n32     ========\n33 \n34     >>> from sympy.core.sympify import sympify, CantSympify\n35 \n36     >>> class Something(dict):\n37     ...     pass\n38     ...\n39     >>> sympify(Something())\n40     {}\n41 \n42     >>> class Something(dict, CantSympify):\n43     ...     pass\n44     ...\n45     >>> sympify(Something())\n46     Traceback (most recent call last):\n47     ...\n48     SympifyError: SympifyError: {}\n49 \n50     \"\"\"\n51     pass\n52 \n53 \n54 def _convert_numpy_types(a, **sympify_args):\n55     \"\"\"\n56     Converts a numpy datatype input to an appropriate SymPy type.\n57     \"\"\"\n58     import numpy as np\n59     if not isinstance(a, np.floating):\n60         if np.iscomplex(a):\n61             return converter[complex](a.item())\n62         else:\n63             return sympify(a.item(), **sympify_args)\n64     else:\n65         try:\n66             from sympy.core.numbers import Float\n67             prec = np.finfo(a).nmant + 1\n68             # E.g. double precision means prec=53 but nmant=52\n69             # Leading bit of mantissa is always 1, so is not stored\n70             a = str(list(np.reshape(np.asarray(a),\n71                                     (1, np.size(a)))[0]))[1:-1]\n72             return Float(a, precision=prec)\n73         except NotImplementedError:\n74             raise SympifyError('Translation for numpy float : %s '\n75                                'is not implemented' % a)\n76 \n77 \n78 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n79         evaluate=None):\n80     \"\"\"Converts an arbitrary expression to a type that can be used inside SymPy.\n81 \n82     For example, it will convert Python ints into instances of sympy.Integer,\n83     floats into instances of sympy.Float, etc. It is also able to coerce symbolic\n84     expressions which inherit from Basic. This can be useful in cooperation\n85     with SAGE.\n86 \n87     It currently accepts as arguments:\n88        - any object defined in SymPy\n89        - standard numeric python types: int, long, float, Decimal\n90        - strings (like \"0.09\" or \"2e-19\")\n91        - booleans, including ``None`` (will leave ``None`` unchanged)\n92        - dict, lists, sets or tuples containing any of the above\n93 \n94     .. warning::\n95         Note that this function uses ``eval``, and thus shouldn't be used on\n96         unsanitized input.\n97 \n98     If the argument is already a type that SymPy understands, it will do\n99     nothing but return that value. This can be used at the beginning of a\n100     function to ensure you are working with the correct type.\n101 \n102     >>> from sympy import sympify\n103 \n104     >>> sympify(2).is_integer\n105     True\n106     >>> sympify(2).is_real\n107     True\n108 \n109     >>> sympify(2.0).is_real\n110     True\n111     >>> sympify(\"2.0\").is_real\n112     True\n113     >>> sympify(\"2e-45\").is_real\n114     True\n115 \n116     If the expression could not be converted, a SympifyError is raised.\n117 \n118     >>> sympify(\"x***2\")\n119     Traceback (most recent call last):\n120     ...\n121     SympifyError: SympifyError: \"could not parse u'x***2'\"\n122 \n123     Locals\n124     ------\n125 \n126     The sympification happens with access to everything that is loaded\n127     by ``from sympy import *``; anything used in a string that is not\n128     defined by that import will be converted to a symbol. In the following,\n129     the ``bitcount`` function is treated as a symbol and the ``O`` is\n130     interpreted as the Order object (used with series) and it raises\n131     an error when used improperly:\n132 \n133     >>> s = 'bitcount(42)'\n134     >>> sympify(s)\n135     bitcount(42)\n136     >>> sympify(\"O(x)\")\n137     O(x)\n138     >>> sympify(\"O + 1\")\n139     Traceback (most recent call last):\n140     ...\n141     TypeError: unbound method...\n142 \n143     In order to have ``bitcount`` be recognized it can be imported into a\n144     namespace dictionary and passed as locals:\n145 \n146     >>> from sympy.core.compatibility import exec_\n147     >>> ns = {}\n148     >>> exec_('from sympy.core.evalf import bitcount', ns)\n149     >>> sympify(s, locals=ns)\n150     6\n151 \n152     In order to have the ``O`` interpreted as a Symbol, identify it as such\n153     in the namespace dictionary. This can be done in a variety of ways; all\n154     three of the following are possibilities:\n155 \n156     >>> from sympy import Symbol\n157     >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n158     >>> exec_('from sympy.abc import O', ns)  # method 2\n159     >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n160     >>> sympify(\"O + 1\", locals=ns)\n161     O + 1\n162 \n163     If you want *all* single-letter and Greek-letter variables to be symbols\n164     then you can use the clashing-symbols dictionaries that have been defined\n165     there as private variables: _clash1 (single-letter variables), _clash2\n166     (the multi-letter Greek names) or _clash (both single and multi-letter\n167     names that are defined in abc).\n168 \n169     >>> from sympy.abc import _clash1\n170     >>> _clash1\n171     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}\n172     >>> sympify('I & Q', _clash1)\n173     I & Q\n174 \n175     Strict\n176     ------\n177 \n178     If the option ``strict`` is set to ``True``, only the types for which an\n179     explicit conversion has been defined are converted. In the other\n180     cases, a SympifyError is raised.\n181 \n182     >>> print(sympify(None))\n183     None\n184     >>> sympify(None, strict=True)\n185     Traceback (most recent call last):\n186     ...\n187     SympifyError: SympifyError: None\n188 \n189     Evaluation\n190     ----------\n191 \n192     If the option ``evaluate`` is set to ``False``, then arithmetic and\n193     operators will be converted into their SymPy equivalents and the\n194     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n195     be denested first. This is done via an AST transformation that replaces\n196     operators with their SymPy equivalents, so if an operand redefines any\n197     of those operations, the redefined operators will not be used.\n198 \n199     >>> sympify('2**2 / 3 + 5')\n200     19/3\n201     >>> sympify('2**2 / 3 + 5', evaluate=False)\n202     2**2/3 + 5\n203 \n204     Extending\n205     ---------\n206 \n207     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n208     just define a ``_sympy_`` method to your class. You can do that even to\n209     classes that you do not own by subclassing or adding the method at runtime.\n210 \n211     >>> from sympy import Matrix\n212     >>> class MyList1(object):\n213     ...     def __iter__(self):\n214     ...         yield 1\n215     ...         yield 2\n216     ...         return\n217     ...     def __getitem__(self, i): return list(self)[i]\n218     ...     def _sympy_(self): return Matrix(self)\n219     >>> sympify(MyList1())\n220     Matrix([\n221     [1],\n222     [2]])\n223 \n224     If you do not have control over the class definition you could also use the\n225     ``converter`` global dictionary. The key is the class and the value is a\n226     function that takes a single argument and returns the desired SymPy\n227     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n228 \n229     >>> class MyList2(object):   # XXX Do not do this if you control the class!\n230     ...     def __iter__(self):  #     Use _sympy_!\n231     ...         yield 1\n232     ...         yield 2\n233     ...         return\n234     ...     def __getitem__(self, i): return list(self)[i]\n235     >>> from sympy.core.sympify import converter\n236     >>> converter[MyList2] = lambda x: Matrix(x)\n237     >>> sympify(MyList2())\n238     Matrix([\n239     [1],\n240     [2]])\n241 \n242     Notes\n243     =====\n244 \n245     The keywords ``rational`` and ``convert_xor`` are only used\n246     when the input is a string.\n247 \n248     Sometimes autosimplification during sympification results in expressions\n249     that are very different in structure than what was entered. Until such\n250     autosimplification is no longer done, the ``kernS`` function might be of\n251     some use. In the example below you can see how an expression reduces to\n252     -1 by autosimplification, but does not do so when ``kernS`` is used.\n253 \n254     >>> from sympy.core.sympify import kernS\n255     >>> from sympy.abc import x\n256     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n257     -1\n258     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n259     >>> sympify(s)\n260     -1\n261     >>> kernS(s)\n262     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n263 \n264     \"\"\"\n265     is_sympy = getattr(a, '__sympy__', None)\n266     if is_sympy is not None:\n267         return a\n268 \n269     if isinstance(a, CantSympify):\n270         raise SympifyError(a)\n271     cls = getattr(a, \"__class__\", None)\n272     if cls is None:\n273         cls = type(a)  # Probably an old-style class\n274     conv = converter.get(cls, None)\n275     if conv is not None:\n276         return conv(a)\n277 \n278     for superclass in getmro(cls):\n279         try:\n280             return converter[superclass](a)\n281         except KeyError:\n282             continue\n283 \n284     if cls is type(None):\n285         if strict:\n286             raise SympifyError(a)\n287         else:\n288             return a\n289 \n290     if evaluate is None:\n291         if global_evaluate[0] is False:\n292             evaluate = global_evaluate[0]\n293         else:\n294             evaluate = True\n295 \n296     # Support for basic numpy datatypes\n297     # Note that this check exists to avoid importing NumPy when not necessary\n298     if type(a).__module__ == 'numpy':\n299         import numpy as np\n300         if np.isscalar(a):\n301             return _convert_numpy_types(a, locals=locals,\n302                 convert_xor=convert_xor, strict=strict, rational=rational,\n303                 evaluate=evaluate)\n304 \n305     _sympy_ = getattr(a, \"_sympy_\", None)\n306     if _sympy_ is not None:\n307         try:\n308             return a._sympy_()\n309         # XXX: Catches AttributeError: 'SympyConverter' object has no\n310         # attribute 'tuple'\n311         # This is probably a bug somewhere but for now we catch it here.\n312         except AttributeError:\n313             pass\n314 \n315     if not strict:\n316         # Put numpy array conversion _before_ float/int, see\n317         # <https://github.com/sympy/sympy/issues/13924>.\n318         flat = getattr(a, \"flat\", None)\n319         if flat is not None:\n320             shape = getattr(a, \"shape\", None)\n321             if shape is not None:\n322                 from ..tensor.array import Array\n323                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n324 \n325     if not isinstance(a, string_types):\n326         for coerce in (float, int):\n327             try:\n328                 coerced = coerce(a)\n329             except (TypeError, ValueError):\n330                 continue\n331             # XXX: AttributeError only needed here for Py2\n332             except AttributeError:\n333                 continue\n334             try:\n335                 return sympify(coerced)\n336             except SympifyError:\n337                 continue\n338 \n339     if strict:\n340         raise SympifyError(a)\n341 \n342     if iterable(a):\n343         try:\n344             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n345                 rational=rational) for x in a])\n346         except TypeError:\n347             # Not all iterables are rebuildable with their type.\n348             pass\n349     if isinstance(a, dict):\n350         try:\n351             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n352                 rational=rational) for x in a.items()])\n353         except TypeError:\n354             # Not all iterables are rebuildable with their type.\n355             pass\n356 \n357     # At this point we were given an arbitrary expression\n358     # which does not inherit from Basic and doesn't implement\n359     # _sympy_ (which is a canonical and robust way to convert\n360     # anything to SymPy expression).\n361     #\n362     # As a last chance, we try to take \"a\"'s normal form via unicode()\n363     # and try to parse it. If it fails, then we have no luck and\n364     # return an exception\n365     try:\n366         from .compatibility import unicode\n367         a = unicode(a)\n368     except Exception as exc:\n369         raise SympifyError(a, exc)\n370 \n371     from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n372                                             standard_transformations)\n373     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n374     from sympy.parsing.sympy_parser import rationalize as t_rationalize\n375 \n376     transformations = standard_transformations\n377 \n378     if rational:\n379         transformations += (t_rationalize,)\n380     if convert_xor:\n381         transformations += (t_convert_xor,)\n382 \n383     try:\n384         a = a.replace('\\n', '')\n385         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n386     except (TokenError, SyntaxError) as exc:\n387         raise SympifyError('could not parse %r' % a, exc)\n388 \n389     return expr\n390 \n391 \n392 def _sympify(a):\n393     \"\"\"\n394     Short version of sympify for internal usage for __add__ and __eq__ methods\n395     where it is ok to allow some things (like Python integers and floats) in\n396     the expression. This excludes things (like strings) that are unwise to\n397     allow into such an expression.\n398 \n399     >>> from sympy import Integer\n400     >>> Integer(1) == 1\n401     True\n402 \n403     >>> Integer(1) == '1'\n404     False\n405 \n406     >>> from sympy.abc import x\n407     >>> x + 1\n408     x + 1\n409 \n410     >>> x + '1'\n411     Traceback (most recent call last):\n412     ...\n413     TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'\n414 \n415     see: sympify\n416 \n417     \"\"\"\n418     return sympify(a, strict=True)\n419 \n420 \n421 def kernS(s):\n422     \"\"\"Use a hack to try keep autosimplification from distributing a\n423     a number into an Add; this modification doesn't\n424     prevent the 2-arg Mul from becoming an Add, however.\n425 \n426     Examples\n427     ========\n428 \n429     >>> from sympy.core.sympify import kernS\n430     >>> from sympy.abc import x, y, z\n431 \n432     The 2-arg Mul distributes a number (or minus sign) across the terms\n433     of an expression, but kernS will prevent that:\n434 \n435     >>> 2*(x + y), -(x + 1)\n436     (2*x + 2*y, -x - 1)\n437     >>> kernS('2*(x + y)')\n438     2*(x + y)\n439     >>> kernS('-(x + 1)')\n440     -(x + 1)\n441 \n442     If use of the hack fails, the un-hacked string will be passed to sympify...\n443     and you get what you get.\n444 \n445     XXX This hack should not be necessary once issue 4596 has been resolved.\n446     \"\"\"\n447     import string\n448     from random import choice\n449     from sympy.core.symbol import Symbol\n450     hit = False\n451     quoted = '\"' in s or \"'\" in s\n452     if '(' in s and not quoted:\n453         if s.count('(') != s.count(\")\"):\n454             raise SympifyError('unmatched left parenthesis')\n455 \n456         # strip all space from s\n457         s = ''.join(s.split())\n458         olds = s\n459         # now use space to represent a symbol that\n460         # will\n461         # step 1. turn potential 2-arg Muls into 3-arg versions\n462         # 1a. *( -> * *(\n463         s = s.replace('*(', '* *(')\n464         # 1b. close up exponentials\n465         s = s.replace('** *', '**')\n466         # 2. handle the implied multiplication of a negated\n467         # parenthesized expression in two steps\n468         # 2a:  -(...)  -->  -( *(...)\n469         target = '-( *('\n470         s = s.replace('-(', target)\n471         # 2b: double the matching closing parenthesis\n472         # -( *(...)  -->  -( *(...))\n473         i = nest = 0\n474         assert target.endswith('(')  # assumption below\n475         while True:\n476             j = s.find(target, i)\n477             if j == -1:\n478                 break\n479             j += len(target) - 1\n480             for j in range(j, len(s)):\n481                 if s[j] == \"(\":\n482                     nest += 1\n483                 elif s[j] == \")\":\n484                     nest -= 1\n485                 if nest == 0:\n486                     break\n487             s = s[:j] + \")\" + s[j:]\n488             i = j + 2  # the first char after 2nd )\n489         if ' ' in s:\n490             # get a unique kern\n491             kern = '_'\n492             while kern in s:\n493                 kern += choice(string.ascii_letters + string.digits)\n494             s = s.replace(' ', kern)\n495         hit = kern in s\n496 \n497     for i in range(2):\n498         try:\n499             expr = sympify(s)\n500             break\n501         except:  # the kern might cause unknown errors, so use bare except\n502             if hit:\n503                 s = olds  # maybe it didn't like the kern; use un-kerned s\n504                 hit = False\n505                 continue\n506             expr = sympify(s)  # let original error raise\n507 \n508     if not hit:\n509         return expr\n510 \n511     rep = {Symbol(kern): 1}\n512     def _clear(expr):\n513         if isinstance(expr, (list, tuple, set)):\n514             return type(expr)([_clear(e) for e in expr])\n515         if hasattr(expr, 'subs'):\n516             return expr.subs(rep, hack2=True)\n517         return expr\n518     expr = _clear(expr)\n519     # hope that kern is not there anymore\n520     return expr\n",
        "intended_behavior": "Modify `sympify` to avoid executing `eval` on strings that are not verified to be safe SymPy expressions. This might involve additional checks or validations to ensure the string representation of an object can be safely converted into a SymPy expression. If a string does not meet these criteria, it should not be evaluated. Instead, `sympify` could either handle the input conservatively as an error or attempt non-evaluative parsing strategies that do not involve `eval`. For cases where `eval` remains necessary, implementing a sandboxed environment or using a safer evaluation strategy (e.g., AST parsing without execution) could mitigate risks. These changes aim to preserve the functionality of allowing flexible inputs to `sympify` while ensuring security and reliability."
    },
    {
        "rel_file_path": "sympy/parsing/sympy_parser.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/parsing/sympy_parser.py",
        "start": 1,
        "end": 1098,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Transform a string with Python-like source code into SymPy expression. \"\"\"\n2 \n3 from __future__ import print_function, division\n4 \n5 from tokenize import (generate_tokens, untokenize, TokenError,\n6     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)\n7 \n8 from keyword import iskeyword\n9 \n10 import ast\n11 import unicodedata\n12 \n13 from sympy.core.compatibility import exec_, StringIO, iterable\n14 from sympy.core.basic import Basic\n15 from sympy.core import Symbol\n16 from sympy.core.function import arity\n17 from sympy.utilities.misc import filldedent, func_name\n18 \n19 \n20 \n21 def _token_splittable(token):\n22     \"\"\"\n23     Predicate for whether a token name can be split into multiple tokens.\n24 \n25     A token is splittable if it does not contain an underscore character and\n26     it is not the name of a Greek letter. This is used to implicitly convert\n27     expressions like 'xyz' into 'x*y*z'.\n28     \"\"\"\n29     if '_' in token:\n30         return False\n31     else:\n32         try:\n33             return not unicodedata.lookup('GREEK SMALL LETTER ' + token)\n34         except KeyError:\n35             pass\n36     if len(token) > 1:\n37         return True\n38     return False\n39 \n40 \n41 def _token_callable(token, local_dict, global_dict, nextToken=None):\n42     \"\"\"\n43     Predicate for whether a token name represents a callable function.\n44 \n45     Essentially wraps ``callable``, but looks up the token name in the\n46     locals and globals.\n47     \"\"\"\n48     func = local_dict.get(token[1])\n49     if not func:\n50         func = global_dict.get(token[1])\n51     return callable(func) and not isinstance(func, Symbol)\n52 \n53 \n54 def _add_factorial_tokens(name, result):\n55     if result == [] or result[-1][1] == '(':\n56         raise TokenError()\n57 \n58     beginning = [(NAME, name), (OP, '(')]\n59     end = [(OP, ')')]\n60 \n61     diff = 0\n62     length = len(result)\n63 \n64     for index, token in enumerate(result[::-1]):\n65         toknum, tokval = token\n66         i = length - index - 1\n67 \n68         if tokval == ')':\n69             diff += 1\n70         elif tokval == '(':\n71             diff -= 1\n72 \n73         if diff == 0:\n74             if i - 1 >= 0 and result[i - 1][0] == NAME:\n75                 return result[:i - 1] + beginning + result[i - 1:] + end\n76             else:\n77                 return result[:i] + beginning + result[i:] + end\n78 \n79     return result\n80 \n81 \n82 class AppliedFunction(object):\n83     \"\"\"\n84     A group of tokens representing a function and its arguments.\n85 \n86     `exponent` is for handling the shorthand sin^2, ln^2, etc.\n87     \"\"\"\n88     def __init__(self, function, args, exponent=None):\n89         if exponent is None:\n90             exponent = []\n91         self.function = function\n92         self.args = args\n93         self.exponent = exponent\n94         self.items = ['function', 'args', 'exponent']\n95 \n96     def expand(self):\n97         \"\"\"Return a list of tokens representing the function\"\"\"\n98         result = []\n99         result.append(self.function)\n100         result.extend(self.args)\n101         return result\n102 \n103     def __getitem__(self, index):\n104         return getattr(self, self.items[index])\n105 \n106     def __repr__(self):\n107         return \"AppliedFunction(%s, %s, %s)\" % (self.function, self.args,\n108                                                 self.exponent)\n109 \n110 \n111 class ParenthesisGroup(list):\n112     \"\"\"List of tokens representing an expression in parentheses.\"\"\"\n113     pass\n114 \n115 \n116 def _flatten(result):\n117     result2 = []\n118     for tok in result:\n119         if isinstance(tok, AppliedFunction):\n120             result2.extend(tok.expand())\n121         else:\n122             result2.append(tok)\n123     return result2\n124 \n125 \n126 def _group_parentheses(recursor):\n127     def _inner(tokens, local_dict, global_dict):\n128         \"\"\"Group tokens between parentheses with ParenthesisGroup.\n129 \n130         Also processes those tokens recursively.\n131 \n132         \"\"\"\n133         result = []\n134         stacks = []\n135         stacklevel = 0\n136         for token in tokens:\n137             if token[0] == OP:\n138                 if token[1] == '(':\n139                     stacks.append(ParenthesisGroup([]))\n140                     stacklevel += 1\n141                 elif token[1] == ')':\n142                     stacks[-1].append(token)\n143                     stack = stacks.pop()\n144 \n145                     if len(stacks) > 0:\n146                         # We don't recurse here since the upper-level stack\n147                         # would reprocess these tokens\n148                         stacks[-1].extend(stack)\n149                     else:\n150                         # Recurse here to handle nested parentheses\n151                         # Strip off the outer parentheses to avoid an infinite loop\n152                         inner = stack[1:-1]\n153                         inner = recursor(inner,\n154                                          local_dict,\n155                                          global_dict)\n156                         parenGroup = [stack[0]] + inner + [stack[-1]]\n157                         result.append(ParenthesisGroup(parenGroup))\n158                     stacklevel -= 1\n159                     continue\n160             if stacklevel:\n161                 stacks[-1].append(token)\n162             else:\n163                 result.append(token)\n164         if stacklevel:\n165             raise TokenError(\"Mismatched parentheses\")\n166         return result\n167     return _inner\n168 \n169 \n170 def _apply_functions(tokens, local_dict, global_dict):\n171     \"\"\"Convert a NAME token + ParenthesisGroup into an AppliedFunction.\n172 \n173     Note that ParenthesisGroups, if not applied to any function, are\n174     converted back into lists of tokens.\n175 \n176     \"\"\"\n177     result = []\n178     symbol = None\n179     for tok in tokens:\n180         if tok[0] == NAME:\n181             symbol = tok\n182             result.append(tok)\n183         elif isinstance(tok, ParenthesisGroup):\n184             if symbol and _token_callable(symbol, local_dict, global_dict):\n185                 result[-1] = AppliedFunction(symbol, tok)\n186                 symbol = None\n187             else:\n188                 result.extend(tok)\n189         else:\n190             symbol = None\n191             result.append(tok)\n192     return result\n193 \n194 \n195 def _implicit_multiplication(tokens, local_dict, global_dict):\n196     \"\"\"Implicitly adds '*' tokens.\n197 \n198     Cases:\n199 \n200     - Two AppliedFunctions next to each other (\"sin(x)cos(x)\")\n201 \n202     - AppliedFunction next to an open parenthesis (\"sin x (cos x + 1)\")\n203 \n204     - A close parenthesis next to an AppliedFunction (\"(x+2)sin x\")\\\n205 \n206     - A close parenthesis next to an open parenthesis (\"(x+2)(x+3)\")\n207 \n208     - AppliedFunction next to an implicitly applied function (\"sin(x)cos x\")\n209 \n210     \"\"\"\n211     result = []\n212     for tok, nextTok in zip(tokens, tokens[1:]):\n213         result.append(tok)\n214         if (isinstance(tok, AppliedFunction) and\n215               isinstance(nextTok, AppliedFunction)):\n216             result.append((OP, '*'))\n217         elif (isinstance(tok, AppliedFunction) and\n218               nextTok[0] == OP and nextTok[1] == '('):\n219             # Applied function followed by an open parenthesis\n220             if tok.function[1] == \"Function\":\n221                 result[-1].function = (result[-1].function[0], 'Symbol')\n222             result.append((OP, '*'))\n223         elif (tok[0] == OP and tok[1] == ')' and\n224               isinstance(nextTok, AppliedFunction)):\n225             # Close parenthesis followed by an applied function\n226             result.append((OP, '*'))\n227         elif (tok[0] == OP and tok[1] == ')' and\n228               nextTok[0] == NAME):\n229             # Close parenthesis followed by an implicitly applied function\n230             result.append((OP, '*'))\n231         elif (tok[0] == nextTok[0] == OP\n232               and tok[1] == ')' and nextTok[1] == '('):\n233             # Close parenthesis followed by an open parenthesis\n234             result.append((OP, '*'))\n235         elif (isinstance(tok, AppliedFunction) and nextTok[0] == NAME):\n236             # Applied function followed by implicitly applied function\n237             result.append((OP, '*'))\n238         elif (tok[0] == NAME and\n239               not _token_callable(tok, local_dict, global_dict) and\n240               nextTok[0] == OP and nextTok[1] == '('):\n241             # Constant followed by parenthesis\n242             result.append((OP, '*'))\n243         elif (tok[0] == NAME and\n244               not _token_callable(tok, local_dict, global_dict) and\n245               nextTok[0] == NAME and\n246               not _token_callable(nextTok, local_dict, global_dict)):\n247             # Constant followed by constant\n248             result.append((OP, '*'))\n249         elif (tok[0] == NAME and\n250               not _token_callable(tok, local_dict, global_dict) and\n251               (isinstance(nextTok, AppliedFunction) or nextTok[0] == NAME)):\n252             # Constant followed by (implicitly applied) function\n253             result.append((OP, '*'))\n254     if tokens:\n255         result.append(tokens[-1])\n256     return result\n257 \n258 \n259 def _implicit_application(tokens, local_dict, global_dict):\n260     \"\"\"Adds parentheses as needed after functions.\"\"\"\n261     result = []\n262     appendParen = 0  # number of closing parentheses to add\n263     skip = 0  # number of tokens to delay before adding a ')' (to\n264               # capture **, ^, etc.)\n265     exponentSkip = False  # skipping tokens before inserting parentheses to\n266                           # work with function exponentiation\n267     for tok, nextTok in zip(tokens, tokens[1:]):\n268         result.append(tok)\n269         if (tok[0] == NAME and nextTok[0] not in [OP, ENDMARKER, NEWLINE]):\n270             if _token_callable(tok, local_dict, global_dict, nextTok):\n271                 result.append((OP, '('))\n272                 appendParen += 1\n273         # name followed by exponent - function exponentiation\n274         elif (tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**'):\n275             if _token_callable(tok, local_dict, global_dict):\n276                 exponentSkip = True\n277         elif exponentSkip:\n278             # if the last token added was an applied function (i.e. the\n279             # power of the function exponent) OR a multiplication (as\n280             # implicit multiplication would have added an extraneous\n281             # multiplication)\n282             if (isinstance(tok, AppliedFunction)\n283                 or (tok[0] == OP and tok[1] == '*')):\n284                 # don't add anything if the next token is a multiplication\n285                 # or if there's already a parenthesis (if parenthesis, still\n286                 # stop skipping tokens)\n287                 if not (nextTok[0] == OP and nextTok[1] == '*'):\n288                     if not(nextTok[0] == OP and nextTok[1] == '('):\n289                         result.append((OP, '('))\n290                         appendParen += 1\n291                     exponentSkip = False\n292         elif appendParen:\n293             if nextTok[0] == OP and nextTok[1] in ('^', '**', '*'):\n294                 skip = 1\n295                 continue\n296             if skip:\n297                 skip -= 1\n298                 continue\n299             result.append((OP, ')'))\n300             appendParen -= 1\n301 \n302     if tokens:\n303         result.append(tokens[-1])\n304 \n305     if appendParen:\n306         result.extend([(OP, ')')] * appendParen)\n307     return result\n308 \n309 \n310 def function_exponentiation(tokens, local_dict, global_dict):\n311     \"\"\"Allows functions to be exponentiated, e.g. ``cos**2(x)``.\n312 \n313     Examples\n314     ========\n315 \n316     >>> from sympy.parsing.sympy_parser import (parse_expr,\n317     ... standard_transformations, function_exponentiation)\n318     >>> transformations = standard_transformations + (function_exponentiation,)\n319     >>> parse_expr('sin**4(x)', transformations=transformations)\n320     sin(x)**4\n321     \"\"\"\n322     result = []\n323     exponent = []\n324     consuming_exponent = False\n325     level = 0\n326     for tok, nextTok in zip(tokens, tokens[1:]):\n327         if tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**':\n328             if _token_callable(tok, local_dict, global_dict):\n329                 consuming_exponent = True\n330         elif consuming_exponent:\n331             if tok[0] == NAME and tok[1] == 'Function':\n332                 tok = (NAME, 'Symbol')\n333             exponent.append(tok)\n334 \n335             # only want to stop after hitting )\n336             if tok[0] == nextTok[0] == OP and tok[1] == ')' and nextTok[1] == '(':\n337                 consuming_exponent = False\n338             # if implicit multiplication was used, we may have )*( instead\n339             if tok[0] == nextTok[0] == OP and tok[1] == '*' and nextTok[1] == '(':\n340                 consuming_exponent = False\n341                 del exponent[-1]\n342             continue\n343         elif exponent and not consuming_exponent:\n344             if tok[0] == OP:\n345                 if tok[1] == '(':\n346                     level += 1\n347                 elif tok[1] == ')':\n348                     level -= 1\n349             if level == 0:\n350                 result.append(tok)\n351                 result.extend(exponent)\n352                 exponent = []\n353                 continue\n354         result.append(tok)\n355     if tokens:\n356         result.append(tokens[-1])\n357     if exponent:\n358         result.extend(exponent)\n359     return result\n360 \n361 \n362 def split_symbols_custom(predicate):\n363     \"\"\"Creates a transformation that splits symbol names.\n364 \n365     ``predicate`` should return True if the symbol name is to be split.\n366 \n367     For instance, to retain the default behavior but avoid splitting certain\n368     symbol names, a predicate like this would work:\n369 \n370 \n371     >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,\n372     ... standard_transformations, implicit_multiplication,\n373     ... split_symbols_custom)\n374     >>> def can_split(symbol):\n375     ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):\n376     ...             return _token_splittable(symbol)\n377     ...     return False\n378     ...\n379     >>> transformation = split_symbols_custom(can_split)\n380     >>> parse_expr('unsplittable', transformations=standard_transformations +\n381     ... (transformation, implicit_multiplication))\n382     unsplittable\n383     \"\"\"\n384     def _split_symbols(tokens, local_dict, global_dict):\n385         result = []\n386         split = False\n387         split_previous=False\n388 \n389         for tok in tokens:\n390             if split_previous:\n391                 # throw out closing parenthesis of Symbol that was split\n392                 split_previous=False\n393                 continue\n394             split_previous=False\n395 \n396             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:\n397                 split = True\n398 \n399             elif split and tok[0] == NAME:\n400                 symbol = tok[1][1:-1]\n401 \n402                 if predicate(symbol):\n403                     tok_type = result[-2][1]  # Symbol or Function\n404                     del result[-2:]  # Get rid of the call to Symbol\n405 \n406                     i = 0\n407                     while i < len(symbol):\n408                         char = symbol[i]\n409                         if char in local_dict or char in global_dict:\n410                             result.extend([(NAME, \"%s\" % char)])\n411                         elif char.isdigit():\n412                             char = [char]\n413                             for i in range(i + 1, len(symbol)):\n414                                 if not symbol[i].isdigit():\n415                                   i -= 1\n416                                   break\n417                                 char.append(symbol[i])\n418                             char = ''.join(char)\n419                             result.extend([(NAME, 'Number'), (OP, '('),\n420                                            (NAME, \"'%s'\" % char), (OP, ')')])\n421                         else:\n422                             use = tok_type if i == len(symbol) else 'Symbol'\n423                             result.extend([(NAME, use), (OP, '('),\n424                                            (NAME, \"'%s'\" % char), (OP, ')')])\n425                         i += 1\n426 \n427                     # Set split_previous=True so will skip\n428                     # the closing parenthesis of the original Symbol\n429                     split = False\n430                     split_previous = True\n431                     continue\n432 \n433                 else:\n434                     split = False\n435 \n436             result.append(tok)\n437 \n438         return result\n439 \n440     return _split_symbols\n441 \n442 \n443 #: Splits symbol names for implicit multiplication.\n444 #:\n445 #: Intended to let expressions like ``xyz`` be parsed as ``x*y*z``. Does not\n446 #: split Greek character names, so ``theta`` will *not* become\n447 #: ``t*h*e*t*a``. Generally this should be used with\n448 #: ``implicit_multiplication``.\n449 split_symbols = split_symbols_custom(_token_splittable)\n450 \n451 \n452 def implicit_multiplication(result, local_dict, global_dict):\n453     \"\"\"Makes the multiplication operator optional in most cases.\n454 \n455     Use this before :func:`implicit_application`, otherwise expressions like\n456     ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.\n457 \n458     Examples\n459     ========\n460 \n461     >>> from sympy.parsing.sympy_parser import (parse_expr,\n462     ... standard_transformations, implicit_multiplication)\n463     >>> transformations = standard_transformations + (implicit_multiplication,)\n464     >>> parse_expr('3 x y', transformations=transformations)\n465     3*x*y\n466     \"\"\"\n467     # These are interdependent steps, so we don't expose them separately\n468     for step in (_group_parentheses(implicit_multiplication),\n469                  _apply_functions,\n470                  _implicit_multiplication):\n471         result = step(result, local_dict, global_dict)\n472 \n473     result = _flatten(result)\n474     return result\n475 \n476 \n477 def implicit_application(result, local_dict, global_dict):\n478     \"\"\"Makes parentheses optional in some cases for function calls.\n479 \n480     Use this after :func:`implicit_multiplication`, otherwise expressions\n481     like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than\n482     ``sin(2*x)``.\n483 \n484     Examples\n485     ========\n486 \n487     >>> from sympy.parsing.sympy_parser import (parse_expr,\n488     ... standard_transformations, implicit_application)\n489     >>> transformations = standard_transformations + (implicit_application,)\n490     >>> parse_expr('cot z + csc z', transformations=transformations)\n491     cot(z) + csc(z)\n492     \"\"\"\n493     for step in (_group_parentheses(implicit_application),\n494                  _apply_functions,\n495                  _implicit_application,):\n496         result = step(result, local_dict, global_dict)\n497 \n498     result = _flatten(result)\n499     return result\n500 \n501 \n502 def implicit_multiplication_application(result, local_dict, global_dict):\n503     \"\"\"Allows a slightly relaxed syntax.\n504 \n505     - Parentheses for single-argument method calls are optional.\n506 \n507     - Multiplication is implicit.\n508 \n509     - Symbol names can be split (i.e. spaces are not needed between\n510       symbols).\n511 \n512     - Functions can be exponentiated.\n513 \n514     Examples\n515     ========\n516 \n517     >>> from sympy.parsing.sympy_parser import (parse_expr,\n518     ... standard_transformations, implicit_multiplication_application)\n519     >>> parse_expr(\"10sin**2 x**2 + 3xyz + tan theta\",\n520     ... transformations=(standard_transformations +\n521     ... (implicit_multiplication_application,)))\n522     3*x*y*z + 10*sin(x**2)**2 + tan(theta)\n523 \n524     \"\"\"\n525     for step in (split_symbols, implicit_multiplication,\n526                  implicit_application, function_exponentiation):\n527         result = step(result, local_dict, global_dict)\n528 \n529     return result\n530 \n531 \n532 def auto_symbol(tokens, local_dict, global_dict):\n533     \"\"\"Inserts calls to ``Symbol``/``Function`` for undefined variables.\"\"\"\n534     result = []\n535     prevTok = (None, None)\n536 \n537     tokens.append((None, None))  # so zip traverses all tokens\n538     for tok, nextTok in zip(tokens, tokens[1:]):\n539         tokNum, tokVal = tok\n540         nextTokNum, nextTokVal = nextTok\n541         if tokNum == NAME:\n542             name = tokVal\n543 \n544             if (name in ['True', 'False', 'None']\n545                 or iskeyword(name)\n546                 # Don't convert attribute access\n547                 or (prevTok[0] == OP and prevTok[1] == '.')\n548                 # Don't convert keyword arguments\n549                 or (prevTok[0] == OP and prevTok[1] in ('(', ',')\n550                     and nextTokNum == OP and nextTokVal == '=')):\n551                 result.append((NAME, name))\n552                 continue\n553             elif name in local_dict:\n554                 if isinstance(local_dict[name], Symbol) and nextTokVal == '(':\n555                     result.extend([(NAME, 'Function'),\n556                                    (OP, '('),\n557                                    (NAME, repr(str(local_dict[name]))),\n558                                    (OP, ')')])\n559                 else:\n560                     result.append((NAME, name))\n561                 continue\n562             elif name in global_dict:\n563                 obj = global_dict[name]\n564                 if isinstance(obj, (Basic, type)) or callable(obj):\n565                     result.append((NAME, name))\n566                     continue\n567 \n568             result.extend([\n569                 (NAME, 'Symbol' if nextTokVal != '(' else 'Function'),\n570                 (OP, '('),\n571                 (NAME, repr(str(name))),\n572                 (OP, ')'),\n573             ])\n574         else:\n575             result.append((tokNum, tokVal))\n576 \n577         prevTok = (tokNum, tokVal)\n578 \n579     return result\n580 \n581 \n582 def lambda_notation(tokens, local_dict, global_dict):\n583     \"\"\"Substitutes \"lambda\" with its Sympy equivalent Lambda().\n584     However, the conversion doesn't take place if only \"lambda\"\n585     is passed because that is a syntax error.\n586 \n587     \"\"\"\n588     result = []\n589     flag = False\n590     toknum, tokval = tokens[0]\n591     tokLen = len(tokens)\n592 \n593     if toknum == NAME and tokval == 'lambda':\n594         if tokLen == 2 or tokLen == 3 and tokens[1][0] == NEWLINE:\n595             # In Python 3.6.7+, inputs without a newline get NEWLINE added to\n596             # the tokens\n597             result.extend(tokens)\n598         elif tokLen > 2:\n599             result.extend([\n600                 (NAME, 'Lambda'),\n601                 (OP, '('),\n602                 (OP, '('),\n603                 (OP, ')'),\n604                 (OP, ')'),\n605             ])\n606             for tokNum, tokVal in tokens[1:]:\n607                 if tokNum == OP and tokVal == ':':\n608                     tokVal = ','\n609                     flag = True\n610                 if not flag and tokNum == OP and tokVal in ['*', '**']:\n611                     raise TokenError(\"Starred arguments in lambda not supported\")\n612                 if flag:\n613                     result.insert(-1, (tokNum, tokVal))\n614                 else:\n615                     result.insert(-2, (tokNum, tokVal))\n616     else:\n617         result.extend(tokens)\n618 \n619     return result\n620 \n621 \n622 def factorial_notation(tokens, local_dict, global_dict):\n623     \"\"\"Allows standard notation for factorial.\"\"\"\n624     result = []\n625     nfactorial = 0\n626     for toknum, tokval in tokens:\n627         if toknum == ERRORTOKEN:\n628             op = tokval\n629             if op == '!':\n630                 nfactorial += 1\n631             else:\n632                 nfactorial = 0\n633                 result.append((OP, op))\n634         else:\n635             if nfactorial == 1:\n636                 result = _add_factorial_tokens('factorial', result)\n637             elif nfactorial == 2:\n638                 result = _add_factorial_tokens('factorial2', result)\n639             elif nfactorial > 2:\n640                 raise TokenError\n641             nfactorial = 0\n642             result.append((toknum, tokval))\n643     return result\n644 \n645 \n646 def convert_xor(tokens, local_dict, global_dict):\n647     \"\"\"Treats XOR, ``^``, as exponentiation, ``**``.\"\"\"\n648     result = []\n649     for toknum, tokval in tokens:\n650         if toknum == OP:\n651             if tokval == '^':\n652                 result.append((OP, '**'))\n653             else:\n654                 result.append((toknum, tokval))\n655         else:\n656             result.append((toknum, tokval))\n657 \n658     return result\n659 \n660 \n661 def repeated_decimals(tokens, local_dict, global_dict):\n662     \"\"\"\n663     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)\n664 \n665     Run this before auto_number.\n666 \n667     \"\"\"\n668     result = []\n669 \n670     def is_digit(s):\n671         return all(i in '0123456789_' for i in s)\n672 \n673     # num will running match any DECIMAL [ INTEGER ]\n674     num = []\n675     for toknum, tokval in tokens:\n676         if toknum == NUMBER:\n677             if (not num and '.' in tokval and 'e' not in tokval.lower() and\n678                 'j' not in tokval.lower()):\n679                 num.append((toknum, tokval))\n680             elif is_digit(tokval)and  len(num) == 2:\n681                 num.append((toknum, tokval))\n682             elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):\n683                 # Python 2 tokenizes 00123 as '00', '123'\n684                 # Python 3 tokenizes 01289 as '012', '89'\n685                 num.append((toknum, tokval))\n686             else:\n687                 num = []\n688         elif toknum == OP:\n689             if tokval == '[' and len(num) == 1:\n690                 num.append((OP, tokval))\n691             elif tokval == ']' and len(num) >= 3:\n692                 num.append((OP, tokval))\n693             elif tokval == '.' and not num:\n694                 # handle .[1]\n695                 num.append((NUMBER, '0.'))\n696             else:\n697                 num = []\n698         else:\n699             num = []\n700 \n701         result.append((toknum, tokval))\n702 \n703         if num and num[-1][1] == ']':\n704             # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,\n705             # and d/e = repetend\n706             result = result[:-len(num)]\n707             pre, post = num[0][1].split('.')\n708             repetend = num[2][1]\n709             if len(num) == 5:\n710                 repetend += num[3][1]\n711 \n712             pre = pre.replace('_', '')\n713             post = post.replace('_', '')\n714             repetend = repetend.replace('_', '')\n715 \n716             zeros = '0'*len(post)\n717             post, repetends = [w.lstrip('0') for w in [post, repetend]]\n718                                         # or else interpreted as octal\n719 \n720             a = pre or '0'\n721             b, c = post or '0', '1' + zeros\n722             d, e = repetends, ('9'*len(repetend)) + zeros\n723 \n724             seq = [\n725                 (OP, '('),\n726                     (NAME, 'Integer'),\n727                     (OP, '('),\n728                         (NUMBER, a),\n729                     (OP, ')'),\n730                     (OP, '+'),\n731                     (NAME, 'Rational'),\n732                     (OP, '('),\n733                         (NUMBER, b),\n734                         (OP, ','),\n735                         (NUMBER, c),\n736                     (OP, ')'),\n737                     (OP, '+'),\n738                     (NAME, 'Rational'),\n739                     (OP, '('),\n740                         (NUMBER, d),\n741                         (OP, ','),\n742                         (NUMBER, e),\n743                     (OP, ')'),\n744                 (OP, ')'),\n745             ]\n746             result.extend(seq)\n747             num = []\n748 \n749     return result\n750 \n751 \n752 def auto_number(tokens, local_dict, global_dict):\n753     \"\"\"\n754     Converts numeric literals to use SymPy equivalents.\n755 \n756     Complex numbers use ``I``, integer literals use ``Integer``, and float\n757     literals use ``Float``.\n758 \n759     \"\"\"\n760     result = []\n761 \n762     for toknum, tokval in tokens:\n763         if toknum == NUMBER:\n764             number = tokval\n765             postfix = []\n766 \n767             if number.endswith('j') or number.endswith('J'):\n768                 number = number[:-1]\n769                 postfix = [(OP, '*'), (NAME, 'I')]\n770 \n771             if '.' in number or (('e' in number or 'E' in number) and\n772                     not (number.startswith('0x') or number.startswith('0X'))):\n773                 seq = [(NAME, 'Float'), (OP, '('),\n774                     (NUMBER, repr(str(number))), (OP, ')')]\n775             else:\n776                 seq = [(NAME, 'Integer'), (OP, '('), (\n777                     NUMBER, number), (OP, ')')]\n778 \n779             result.extend(seq + postfix)\n780         else:\n781             result.append((toknum, tokval))\n782 \n783     return result\n784 \n785 \n786 def rationalize(tokens, local_dict, global_dict):\n787     \"\"\"Converts floats into ``Rational``. Run AFTER ``auto_number``.\"\"\"\n788     result = []\n789     passed_float = False\n790     for toknum, tokval in tokens:\n791         if toknum == NAME:\n792             if tokval == 'Float':\n793                 passed_float = True\n794                 tokval = 'Rational'\n795             result.append((toknum, tokval))\n796         elif passed_float == True and toknum == NUMBER:\n797             passed_float = False\n798             result.append((STRING, tokval))\n799         else:\n800             result.append((toknum, tokval))\n801 \n802     return result\n803 \n804 \n805 def _transform_equals_sign(tokens, local_dict, global_dict):\n806     \"\"\"Transforms the equals sign ``=`` to instances of Eq.\n807 \n808     This is a helper function for `convert_equals_signs`.\n809     Works with expressions containing one equals sign and no\n810     nesting. Expressions like `(1=2)=False` won't work with this\n811     and should be used with `convert_equals_signs`.\n812 \n813     Examples: 1=2     to Eq(1,2)\n814               1*2=x   to Eq(1*2, x)\n815 \n816     This does not deal with function arguments yet.\n817 \n818     \"\"\"\n819     result = []\n820     if (OP, \"=\") in tokens:\n821         result.append((NAME, \"Eq\"))\n822         result.append((OP, \"(\"))\n823         for index, token in enumerate(tokens):\n824             if token == (OP, \"=\"):\n825                 result.append((OP, \",\"))\n826                 continue\n827             result.append(token)\n828         result.append((OP, \")\"))\n829     else:\n830         result = tokens\n831     return result\n832 \n833 \n834 def convert_equals_signs(result, local_dict, global_dict):\n835     \"\"\" Transforms all the equals signs ``=`` to instances of Eq.\n836 \n837     Parses the equals signs in the expression and replaces them with\n838     appropriate Eq instances.Also works with nested equals signs.\n839 \n840     Does not yet play well with function arguments.\n841     For example, the expression `(x=y)` is ambiguous and can be interpreted\n842     as x being an argument to a function and `convert_equals_signs` won't\n843     work for this.\n844 \n845     See also\n846     ========\n847     convert_equality_operators\n848 \n849     Examples\n850     ========\n851 \n852     >>> from sympy.parsing.sympy_parser import (parse_expr,\n853     ... standard_transformations, convert_equals_signs)\n854     >>> parse_expr(\"1*2=x\", transformations=(\n855     ... standard_transformations + (convert_equals_signs,)))\n856     Eq(2, x)\n857     >>> parse_expr(\"(1*2=x)=False\", transformations=(\n858     ... standard_transformations + (convert_equals_signs,)))\n859     Eq(Eq(2, x), False)\n860 \n861     \"\"\"\n862     for step in (_group_parentheses(convert_equals_signs),\n863                   _apply_functions,\n864                   _transform_equals_sign):\n865         result = step(result, local_dict, global_dict)\n866 \n867     result = _flatten(result)\n868     return result\n869 \n870 \n871 #: Standard transformations for :func:`parse_expr`.\n872 #: Inserts calls to :class:`~.Symbol`, :class:`~.Integer`, and other SymPy\n873 #: datatypes and allows the use of standard factorial notation (e.g. ``x!``).\n874 standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,\n875     factorial_notation)\n876 \n877 \n878 def stringify_expr(s, local_dict, global_dict, transformations):\n879     \"\"\"\n880     Converts the string ``s`` to Python code, in ``local_dict``\n881 \n882     Generally, ``parse_expr`` should be used.\n883     \"\"\"\n884 \n885     tokens = []\n886     input_code = StringIO(s.strip())\n887     for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):\n888         tokens.append((toknum, tokval))\n889 \n890     for transform in transformations:\n891         tokens = transform(tokens, local_dict, global_dict)\n892 \n893     return untokenize(tokens)\n894 \n895 \n896 def eval_expr(code, local_dict, global_dict):\n897     \"\"\"\n898     Evaluate Python code generated by ``stringify_expr``.\n899 \n900     Generally, ``parse_expr`` should be used.\n901     \"\"\"\n902     expr = eval(\n903         code, global_dict, local_dict)  # take local objects in preference\n904 \n905     return expr\n906 \n907 \n908 def parse_expr(s, local_dict=None, transformations=standard_transformations,\n909                global_dict=None, evaluate=True):\n910     \"\"\"Converts the string ``s`` to a SymPy expression, in ``local_dict``\n911 \n912     Parameters\n913     ==========\n914 \n915     s : str\n916         The string to parse.\n917 \n918     local_dict : dict, optional\n919         A dictionary of local variables to use when parsing.\n920 \n921     global_dict : dict, optional\n922         A dictionary of global variables. By default, this is initialized\n923         with ``from sympy import *``; provide this parameter to override\n924         this behavior (for instance, to parse ``\"Q & S\"``).\n925 \n926     transformations : tuple, optional\n927         A tuple of transformation functions used to modify the tokens of the\n928         parsed expression before evaluation. The default transformations\n929         convert numeric literals into their SymPy equivalents, convert\n930         undefined variables into SymPy symbols, and allow the use of standard\n931         mathematical factorial notation (e.g. ``x!``).\n932 \n933     evaluate : bool, optional\n934         When False, the order of the arguments will remain as they were in the\n935         string and automatic simplification that would normally occur is\n936         suppressed. (see examples)\n937 \n938     Examples\n939     ========\n940 \n941     >>> from sympy.parsing.sympy_parser import parse_expr\n942     >>> parse_expr(\"1/2\")\n943     1/2\n944     >>> type(_)\n945     <class 'sympy.core.numbers.Half'>\n946     >>> from sympy.parsing.sympy_parser import standard_transformations,\\\\\n947     ... implicit_multiplication_application\n948     >>> transformations = (standard_transformations +\n949     ...     (implicit_multiplication_application,))\n950     >>> parse_expr(\"2x\", transformations=transformations)\n951     2*x\n952 \n953     When evaluate=False, some automatic simplifications will not occur:\n954 \n955     >>> parse_expr(\"2**3\"), parse_expr(\"2**3\", evaluate=False)\n956     (8, 2**3)\n957 \n958     In addition the order of the arguments will not be made canonical.\n959     This feature allows one to tell exactly how the expression was entered:\n960 \n961     >>> a = parse_expr('1 + x', evaluate=False)\n962     >>> b = parse_expr('x + 1', evaluate=0)\n963     >>> a == b\n964     False\n965     >>> a.args\n966     (1, x)\n967     >>> b.args\n968     (x, 1)\n969 \n970     See Also\n971     ========\n972 \n973     stringify_expr, eval_expr, standard_transformations,\n974     implicit_multiplication_application\n975 \n976     \"\"\"\n977 \n978     if local_dict is None:\n979         local_dict = {}\n980     elif not isinstance(local_dict, dict):\n981         raise TypeError('expecting local_dict to be a dict')\n982 \n983     if global_dict is None:\n984         global_dict = {}\n985         exec_('from sympy import *', global_dict)\n986     elif not isinstance(global_dict, dict):\n987         raise TypeError('expecting global_dict to be a dict')\n988 \n989     transformations = transformations or ()\n990     if transformations:\n991         if not iterable(transformations):\n992             raise TypeError(\n993                 '`transformations` should be a list of functions.')\n994         for _ in transformations:\n995             if not callable(_):\n996                 raise TypeError(filldedent('''\n997                     expected a function in `transformations`,\n998                     not %s''' % func_name(_)))\n999             if arity(_) != 3:\n1000                 raise TypeError(filldedent('''\n1001                     a transformation should be function that\n1002                     takes 3 arguments'''))\n1003     code = stringify_expr(s, local_dict, global_dict, transformations)\n1004 \n1005     if not evaluate:\n1006         code = compile(evaluateFalse(code), '<string>', 'eval')\n1007 \n1008     return eval_expr(code, local_dict, global_dict)\n1009 \n1010 \n1011 def evaluateFalse(s):\n1012     \"\"\"\n1013     Replaces operators with the SymPy equivalent and sets evaluate=False.\n1014     \"\"\"\n1015     node = ast.parse(s)\n1016     node = EvaluateFalseTransformer().visit(node)\n1017     # node is a Module, we want an Expression\n1018     node = ast.Expression(node.body[0].value)\n1019 \n1020     return ast.fix_missing_locations(node)\n1021 \n1022 \n1023 class EvaluateFalseTransformer(ast.NodeTransformer):\n1024     operators = {\n1025         ast.Add: 'Add',\n1026         ast.Mult: 'Mul',\n1027         ast.Pow: 'Pow',\n1028         ast.Sub: 'Add',\n1029         ast.Div: 'Mul',\n1030         ast.BitOr: 'Or',\n1031         ast.BitAnd: 'And',\n1032         ast.BitXor: 'Not',\n1033     }\n1034 \n1035     def flatten(self, args, func):\n1036         result = []\n1037         for arg in args:\n1038             if isinstance(arg, ast.Call):\n1039                 arg_func = arg.func\n1040                 if isinstance(arg_func, ast.Call):\n1041                     arg_func = arg_func.func\n1042                 if arg_func.id == func:\n1043                     result.extend(self.flatten(arg.args, func))\n1044                 else:\n1045                     result.append(arg)\n1046             else:\n1047                 result.append(arg)\n1048         return result\n1049 \n1050     def visit_BinOp(self, node):\n1051         if node.op.__class__ in self.operators:\n1052             sympy_class = self.operators[node.op.__class__]\n1053             right = self.visit(node.right)\n1054             left = self.visit(node.left)\n1055             if isinstance(node.left, ast.UnaryOp) and (isinstance(node.right, ast.UnaryOp) == 0) and sympy_class in ('Mul',):\n1056                 left, right = right, left\n1057             if isinstance(node.op, ast.Sub):\n1058                 right = ast.Call(\n1059                     func=ast.Name(id='Mul', ctx=ast.Load()),\n1060                     args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(1)), right],\n1061                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1062                     starargs=None,\n1063                     kwargs=None\n1064                 )\n1065             if isinstance(node.op, ast.Div):\n1066                 if isinstance(node.left, ast.UnaryOp):\n1067                     if isinstance(node.right,ast.UnaryOp):\n1068                         left, right = right, left\n1069                     left = ast.Call(\n1070                     func=ast.Name(id='Pow', ctx=ast.Load()),\n1071                     args=[left, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],\n1072                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1073                     starargs=None,\n1074                     kwargs=None\n1075                 )\n1076                 else:\n1077                     right = ast.Call(\n1078                     func=ast.Name(id='Pow', ctx=ast.Load()),\n1079                     args=[right, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],\n1080                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1081                     starargs=None,\n1082                     kwargs=None\n1083                 )\n1084 \n1085             new_node = ast.Call(\n1086                 func=ast.Name(id=sympy_class, ctx=ast.Load()),\n1087                 args=[left, right],\n1088                 keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1089                 starargs=None,\n1090                 kwargs=None\n1091             )\n1092 \n1093             if sympy_class in ('Add', 'Mul'):\n1094                 # Denest Add or Mul as appropriate\n1095                 new_node.args = self.flatten(new_node.args, sympy_class)\n1096 \n1097             return new_node\n1098         return node\n",
        "intended_behavior": "`parse_expr` should be adapted to include safety checks or robust parsing strategies that prevent the execution of potentially dangerous or unintended code. This includes validating input strings and potentially sanitizing inputs to remove or handle known dangerous patterns before parsing and evaluation. Moreover, `parse_expr` should handle cases where the `eval_expr` function is called, ensuring that any code passed to `eval_expr` has been verified as safe. In scenarios where evaluation could lead to unsafe behavior, `parse_expr` could fall back to error handling mechanisms that avoid execution while still providing useful feedback to the user."
    },
    {
        "rel_file_path": "sympy/parsing/sympy_parser.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/parsing/sympy_parser.py",
        "start": 1,
        "end": 1098,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Transform a string with Python-like source code into SymPy expression. \"\"\"\n2 \n3 from __future__ import print_function, division\n4 \n5 from tokenize import (generate_tokens, untokenize, TokenError,\n6     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)\n7 \n8 from keyword import iskeyword\n9 \n10 import ast\n11 import unicodedata\n12 \n13 from sympy.core.compatibility import exec_, StringIO, iterable\n14 from sympy.core.basic import Basic\n15 from sympy.core import Symbol\n16 from sympy.core.function import arity\n17 from sympy.utilities.misc import filldedent, func_name\n18 \n19 \n20 \n21 def _token_splittable(token):\n22     \"\"\"\n23     Predicate for whether a token name can be split into multiple tokens.\n24 \n25     A token is splittable if it does not contain an underscore character and\n26     it is not the name of a Greek letter. This is used to implicitly convert\n27     expressions like 'xyz' into 'x*y*z'.\n28     \"\"\"\n29     if '_' in token:\n30         return False\n31     else:\n32         try:\n33             return not unicodedata.lookup('GREEK SMALL LETTER ' + token)\n34         except KeyError:\n35             pass\n36     if len(token) > 1:\n37         return True\n38     return False\n39 \n40 \n41 def _token_callable(token, local_dict, global_dict, nextToken=None):\n42     \"\"\"\n43     Predicate for whether a token name represents a callable function.\n44 \n45     Essentially wraps ``callable``, but looks up the token name in the\n46     locals and globals.\n47     \"\"\"\n48     func = local_dict.get(token[1])\n49     if not func:\n50         func = global_dict.get(token[1])\n51     return callable(func) and not isinstance(func, Symbol)\n52 \n53 \n54 def _add_factorial_tokens(name, result):\n55     if result == [] or result[-1][1] == '(':\n56         raise TokenError()\n57 \n58     beginning = [(NAME, name), (OP, '(')]\n59     end = [(OP, ')')]\n60 \n61     diff = 0\n62     length = len(result)\n63 \n64     for index, token in enumerate(result[::-1]):\n65         toknum, tokval = token\n66         i = length - index - 1\n67 \n68         if tokval == ')':\n69             diff += 1\n70         elif tokval == '(':\n71             diff -= 1\n72 \n73         if diff == 0:\n74             if i - 1 >= 0 and result[i - 1][0] == NAME:\n75                 return result[:i - 1] + beginning + result[i - 1:] + end\n76             else:\n77                 return result[:i] + beginning + result[i:] + end\n78 \n79     return result\n80 \n81 \n82 class AppliedFunction(object):\n83     \"\"\"\n84     A group of tokens representing a function and its arguments.\n85 \n86     `exponent` is for handling the shorthand sin^2, ln^2, etc.\n87     \"\"\"\n88     def __init__(self, function, args, exponent=None):\n89         if exponent is None:\n90             exponent = []\n91         self.function = function\n92         self.args = args\n93         self.exponent = exponent\n94         self.items = ['function', 'args', 'exponent']\n95 \n96     def expand(self):\n97         \"\"\"Return a list of tokens representing the function\"\"\"\n98         result = []\n99         result.append(self.function)\n100         result.extend(self.args)\n101         return result\n102 \n103     def __getitem__(self, index):\n104         return getattr(self, self.items[index])\n105 \n106     def __repr__(self):\n107         return \"AppliedFunction(%s, %s, %s)\" % (self.function, self.args,\n108                                                 self.exponent)\n109 \n110 \n111 class ParenthesisGroup(list):\n112     \"\"\"List of tokens representing an expression in parentheses.\"\"\"\n113     pass\n114 \n115 \n116 def _flatten(result):\n117     result2 = []\n118     for tok in result:\n119         if isinstance(tok, AppliedFunction):\n120             result2.extend(tok.expand())\n121         else:\n122             result2.append(tok)\n123     return result2\n124 \n125 \n126 def _group_parentheses(recursor):\n127     def _inner(tokens, local_dict, global_dict):\n128         \"\"\"Group tokens between parentheses with ParenthesisGroup.\n129 \n130         Also processes those tokens recursively.\n131 \n132         \"\"\"\n133         result = []\n134         stacks = []\n135         stacklevel = 0\n136         for token in tokens:\n137             if token[0] == OP:\n138                 if token[1] == '(':\n139                     stacks.append(ParenthesisGroup([]))\n140                     stacklevel += 1\n141                 elif token[1] == ')':\n142                     stacks[-1].append(token)\n143                     stack = stacks.pop()\n144 \n145                     if len(stacks) > 0:\n146                         # We don't recurse here since the upper-level stack\n147                         # would reprocess these tokens\n148                         stacks[-1].extend(stack)\n149                     else:\n150                         # Recurse here to handle nested parentheses\n151                         # Strip off the outer parentheses to avoid an infinite loop\n152                         inner = stack[1:-1]\n153                         inner = recursor(inner,\n154                                          local_dict,\n155                                          global_dict)\n156                         parenGroup = [stack[0]] + inner + [stack[-1]]\n157                         result.append(ParenthesisGroup(parenGroup))\n158                     stacklevel -= 1\n159                     continue\n160             if stacklevel:\n161                 stacks[-1].append(token)\n162             else:\n163                 result.append(token)\n164         if stacklevel:\n165             raise TokenError(\"Mismatched parentheses\")\n166         return result\n167     return _inner\n168 \n169 \n170 def _apply_functions(tokens, local_dict, global_dict):\n171     \"\"\"Convert a NAME token + ParenthesisGroup into an AppliedFunction.\n172 \n173     Note that ParenthesisGroups, if not applied to any function, are\n174     converted back into lists of tokens.\n175 \n176     \"\"\"\n177     result = []\n178     symbol = None\n179     for tok in tokens:\n180         if tok[0] == NAME:\n181             symbol = tok\n182             result.append(tok)\n183         elif isinstance(tok, ParenthesisGroup):\n184             if symbol and _token_callable(symbol, local_dict, global_dict):\n185                 result[-1] = AppliedFunction(symbol, tok)\n186                 symbol = None\n187             else:\n188                 result.extend(tok)\n189         else:\n190             symbol = None\n191             result.append(tok)\n192     return result\n193 \n194 \n195 def _implicit_multiplication(tokens, local_dict, global_dict):\n196     \"\"\"Implicitly adds '*' tokens.\n197 \n198     Cases:\n199 \n200     - Two AppliedFunctions next to each other (\"sin(x)cos(x)\")\n201 \n202     - AppliedFunction next to an open parenthesis (\"sin x (cos x + 1)\")\n203 \n204     - A close parenthesis next to an AppliedFunction (\"(x+2)sin x\")\\\n205 \n206     - A close parenthesis next to an open parenthesis (\"(x+2)(x+3)\")\n207 \n208     - AppliedFunction next to an implicitly applied function (\"sin(x)cos x\")\n209 \n210     \"\"\"\n211     result = []\n212     for tok, nextTok in zip(tokens, tokens[1:]):\n213         result.append(tok)\n214         if (isinstance(tok, AppliedFunction) and\n215               isinstance(nextTok, AppliedFunction)):\n216             result.append((OP, '*'))\n217         elif (isinstance(tok, AppliedFunction) and\n218               nextTok[0] == OP and nextTok[1] == '('):\n219             # Applied function followed by an open parenthesis\n220             if tok.function[1] == \"Function\":\n221                 result[-1].function = (result[-1].function[0], 'Symbol')\n222             result.append((OP, '*'))\n223         elif (tok[0] == OP and tok[1] == ')' and\n224               isinstance(nextTok, AppliedFunction)):\n225             # Close parenthesis followed by an applied function\n226             result.append((OP, '*'))\n227         elif (tok[0] == OP and tok[1] == ')' and\n228               nextTok[0] == NAME):\n229             # Close parenthesis followed by an implicitly applied function\n230             result.append((OP, '*'))\n231         elif (tok[0] == nextTok[0] == OP\n232               and tok[1] == ')' and nextTok[1] == '('):\n233             # Close parenthesis followed by an open parenthesis\n234             result.append((OP, '*'))\n235         elif (isinstance(tok, AppliedFunction) and nextTok[0] == NAME):\n236             # Applied function followed by implicitly applied function\n237             result.append((OP, '*'))\n238         elif (tok[0] == NAME and\n239               not _token_callable(tok, local_dict, global_dict) and\n240               nextTok[0] == OP and nextTok[1] == '('):\n241             # Constant followed by parenthesis\n242             result.append((OP, '*'))\n243         elif (tok[0] == NAME and\n244               not _token_callable(tok, local_dict, global_dict) and\n245               nextTok[0] == NAME and\n246               not _token_callable(nextTok, local_dict, global_dict)):\n247             # Constant followed by constant\n248             result.append((OP, '*'))\n249         elif (tok[0] == NAME and\n250               not _token_callable(tok, local_dict, global_dict) and\n251               (isinstance(nextTok, AppliedFunction) or nextTok[0] == NAME)):\n252             # Constant followed by (implicitly applied) function\n253             result.append((OP, '*'))\n254     if tokens:\n255         result.append(tokens[-1])\n256     return result\n257 \n258 \n259 def _implicit_application(tokens, local_dict, global_dict):\n260     \"\"\"Adds parentheses as needed after functions.\"\"\"\n261     result = []\n262     appendParen = 0  # number of closing parentheses to add\n263     skip = 0  # number of tokens to delay before adding a ')' (to\n264               # capture **, ^, etc.)\n265     exponentSkip = False  # skipping tokens before inserting parentheses to\n266                           # work with function exponentiation\n267     for tok, nextTok in zip(tokens, tokens[1:]):\n268         result.append(tok)\n269         if (tok[0] == NAME and nextTok[0] not in [OP, ENDMARKER, NEWLINE]):\n270             if _token_callable(tok, local_dict, global_dict, nextTok):\n271                 result.append((OP, '('))\n272                 appendParen += 1\n273         # name followed by exponent - function exponentiation\n274         elif (tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**'):\n275             if _token_callable(tok, local_dict, global_dict):\n276                 exponentSkip = True\n277         elif exponentSkip:\n278             # if the last token added was an applied function (i.e. the\n279             # power of the function exponent) OR a multiplication (as\n280             # implicit multiplication would have added an extraneous\n281             # multiplication)\n282             if (isinstance(tok, AppliedFunction)\n283                 or (tok[0] == OP and tok[1] == '*')):\n284                 # don't add anything if the next token is a multiplication\n285                 # or if there's already a parenthesis (if parenthesis, still\n286                 # stop skipping tokens)\n287                 if not (nextTok[0] == OP and nextTok[1] == '*'):\n288                     if not(nextTok[0] == OP and nextTok[1] == '('):\n289                         result.append((OP, '('))\n290                         appendParen += 1\n291                     exponentSkip = False\n292         elif appendParen:\n293             if nextTok[0] == OP and nextTok[1] in ('^', '**', '*'):\n294                 skip = 1\n295                 continue\n296             if skip:\n297                 skip -= 1\n298                 continue\n299             result.append((OP, ')'))\n300             appendParen -= 1\n301 \n302     if tokens:\n303         result.append(tokens[-1])\n304 \n305     if appendParen:\n306         result.extend([(OP, ')')] * appendParen)\n307     return result\n308 \n309 \n310 def function_exponentiation(tokens, local_dict, global_dict):\n311     \"\"\"Allows functions to be exponentiated, e.g. ``cos**2(x)``.\n312 \n313     Examples\n314     ========\n315 \n316     >>> from sympy.parsing.sympy_parser import (parse_expr,\n317     ... standard_transformations, function_exponentiation)\n318     >>> transformations = standard_transformations + (function_exponentiation,)\n319     >>> parse_expr('sin**4(x)', transformations=transformations)\n320     sin(x)**4\n321     \"\"\"\n322     result = []\n323     exponent = []\n324     consuming_exponent = False\n325     level = 0\n326     for tok, nextTok in zip(tokens, tokens[1:]):\n327         if tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**':\n328             if _token_callable(tok, local_dict, global_dict):\n329                 consuming_exponent = True\n330         elif consuming_exponent:\n331             if tok[0] == NAME and tok[1] == 'Function':\n332                 tok = (NAME, 'Symbol')\n333             exponent.append(tok)\n334 \n335             # only want to stop after hitting )\n336             if tok[0] == nextTok[0] == OP and tok[1] == ')' and nextTok[1] == '(':\n337                 consuming_exponent = False\n338             # if implicit multiplication was used, we may have )*( instead\n339             if tok[0] == nextTok[0] == OP and tok[1] == '*' and nextTok[1] == '(':\n340                 consuming_exponent = False\n341                 del exponent[-1]\n342             continue\n343         elif exponent and not consuming_exponent:\n344             if tok[0] == OP:\n345                 if tok[1] == '(':\n346                     level += 1\n347                 elif tok[1] == ')':\n348                     level -= 1\n349             if level == 0:\n350                 result.append(tok)\n351                 result.extend(exponent)\n352                 exponent = []\n353                 continue\n354         result.append(tok)\n355     if tokens:\n356         result.append(tokens[-1])\n357     if exponent:\n358         result.extend(exponent)\n359     return result\n360 \n361 \n362 def split_symbols_custom(predicate):\n363     \"\"\"Creates a transformation that splits symbol names.\n364 \n365     ``predicate`` should return True if the symbol name is to be split.\n366 \n367     For instance, to retain the default behavior but avoid splitting certain\n368     symbol names, a predicate like this would work:\n369 \n370 \n371     >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,\n372     ... standard_transformations, implicit_multiplication,\n373     ... split_symbols_custom)\n374     >>> def can_split(symbol):\n375     ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):\n376     ...             return _token_splittable(symbol)\n377     ...     return False\n378     ...\n379     >>> transformation = split_symbols_custom(can_split)\n380     >>> parse_expr('unsplittable', transformations=standard_transformations +\n381     ... (transformation, implicit_multiplication))\n382     unsplittable\n383     \"\"\"\n384     def _split_symbols(tokens, local_dict, global_dict):\n385         result = []\n386         split = False\n387         split_previous=False\n388 \n389         for tok in tokens:\n390             if split_previous:\n391                 # throw out closing parenthesis of Symbol that was split\n392                 split_previous=False\n393                 continue\n394             split_previous=False\n395 \n396             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:\n397                 split = True\n398 \n399             elif split and tok[0] == NAME:\n400                 symbol = tok[1][1:-1]\n401 \n402                 if predicate(symbol):\n403                     tok_type = result[-2][1]  # Symbol or Function\n404                     del result[-2:]  # Get rid of the call to Symbol\n405 \n406                     i = 0\n407                     while i < len(symbol):\n408                         char = symbol[i]\n409                         if char in local_dict or char in global_dict:\n410                             result.extend([(NAME, \"%s\" % char)])\n411                         elif char.isdigit():\n412                             char = [char]\n413                             for i in range(i + 1, len(symbol)):\n414                                 if not symbol[i].isdigit():\n415                                   i -= 1\n416                                   break\n417                                 char.append(symbol[i])\n418                             char = ''.join(char)\n419                             result.extend([(NAME, 'Number'), (OP, '('),\n420                                            (NAME, \"'%s'\" % char), (OP, ')')])\n421                         else:\n422                             use = tok_type if i == len(symbol) else 'Symbol'\n423                             result.extend([(NAME, use), (OP, '('),\n424                                            (NAME, \"'%s'\" % char), (OP, ')')])\n425                         i += 1\n426 \n427                     # Set split_previous=True so will skip\n428                     # the closing parenthesis of the original Symbol\n429                     split = False\n430                     split_previous = True\n431                     continue\n432 \n433                 else:\n434                     split = False\n435 \n436             result.append(tok)\n437 \n438         return result\n439 \n440     return _split_symbols\n441 \n442 \n443 #: Splits symbol names for implicit multiplication.\n444 #:\n445 #: Intended to let expressions like ``xyz`` be parsed as ``x*y*z``. Does not\n446 #: split Greek character names, so ``theta`` will *not* become\n447 #: ``t*h*e*t*a``. Generally this should be used with\n448 #: ``implicit_multiplication``.\n449 split_symbols = split_symbols_custom(_token_splittable)\n450 \n451 \n452 def implicit_multiplication(result, local_dict, global_dict):\n453     \"\"\"Makes the multiplication operator optional in most cases.\n454 \n455     Use this before :func:`implicit_application`, otherwise expressions like\n456     ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.\n457 \n458     Examples\n459     ========\n460 \n461     >>> from sympy.parsing.sympy_parser import (parse_expr,\n462     ... standard_transformations, implicit_multiplication)\n463     >>> transformations = standard_transformations + (implicit_multiplication,)\n464     >>> parse_expr('3 x y', transformations=transformations)\n465     3*x*y\n466     \"\"\"\n467     # These are interdependent steps, so we don't expose them separately\n468     for step in (_group_parentheses(implicit_multiplication),\n469                  _apply_functions,\n470                  _implicit_multiplication):\n471         result = step(result, local_dict, global_dict)\n472 \n473     result = _flatten(result)\n474     return result\n475 \n476 \n477 def implicit_application(result, local_dict, global_dict):\n478     \"\"\"Makes parentheses optional in some cases for function calls.\n479 \n480     Use this after :func:`implicit_multiplication`, otherwise expressions\n481     like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than\n482     ``sin(2*x)``.\n483 \n484     Examples\n485     ========\n486 \n487     >>> from sympy.parsing.sympy_parser import (parse_expr,\n488     ... standard_transformations, implicit_application)\n489     >>> transformations = standard_transformations + (implicit_application,)\n490     >>> parse_expr('cot z + csc z', transformations=transformations)\n491     cot(z) + csc(z)\n492     \"\"\"\n493     for step in (_group_parentheses(implicit_application),\n494                  _apply_functions,\n495                  _implicit_application,):\n496         result = step(result, local_dict, global_dict)\n497 \n498     result = _flatten(result)\n499     return result\n500 \n501 \n502 def implicit_multiplication_application(result, local_dict, global_dict):\n503     \"\"\"Allows a slightly relaxed syntax.\n504 \n505     - Parentheses for single-argument method calls are optional.\n506 \n507     - Multiplication is implicit.\n508 \n509     - Symbol names can be split (i.e. spaces are not needed between\n510       symbols).\n511 \n512     - Functions can be exponentiated.\n513 \n514     Examples\n515     ========\n516 \n517     >>> from sympy.parsing.sympy_parser import (parse_expr,\n518     ... standard_transformations, implicit_multiplication_application)\n519     >>> parse_expr(\"10sin**2 x**2 + 3xyz + tan theta\",\n520     ... transformations=(standard_transformations +\n521     ... (implicit_multiplication_application,)))\n522     3*x*y*z + 10*sin(x**2)**2 + tan(theta)\n523 \n524     \"\"\"\n525     for step in (split_symbols, implicit_multiplication,\n526                  implicit_application, function_exponentiation):\n527         result = step(result, local_dict, global_dict)\n528 \n529     return result\n530 \n531 \n532 def auto_symbol(tokens, local_dict, global_dict):\n533     \"\"\"Inserts calls to ``Symbol``/``Function`` for undefined variables.\"\"\"\n534     result = []\n535     prevTok = (None, None)\n536 \n537     tokens.append((None, None))  # so zip traverses all tokens\n538     for tok, nextTok in zip(tokens, tokens[1:]):\n539         tokNum, tokVal = tok\n540         nextTokNum, nextTokVal = nextTok\n541         if tokNum == NAME:\n542             name = tokVal\n543 \n544             if (name in ['True', 'False', 'None']\n545                 or iskeyword(name)\n546                 # Don't convert attribute access\n547                 or (prevTok[0] == OP and prevTok[1] == '.')\n548                 # Don't convert keyword arguments\n549                 or (prevTok[0] == OP and prevTok[1] in ('(', ',')\n550                     and nextTokNum == OP and nextTokVal == '=')):\n551                 result.append((NAME, name))\n552                 continue\n553             elif name in local_dict:\n554                 if isinstance(local_dict[name], Symbol) and nextTokVal == '(':\n555                     result.extend([(NAME, 'Function'),\n556                                    (OP, '('),\n557                                    (NAME, repr(str(local_dict[name]))),\n558                                    (OP, ')')])\n559                 else:\n560                     result.append((NAME, name))\n561                 continue\n562             elif name in global_dict:\n563                 obj = global_dict[name]\n564                 if isinstance(obj, (Basic, type)) or callable(obj):\n565                     result.append((NAME, name))\n566                     continue\n567 \n568             result.extend([\n569                 (NAME, 'Symbol' if nextTokVal != '(' else 'Function'),\n570                 (OP, '('),\n571                 (NAME, repr(str(name))),\n572                 (OP, ')'),\n573             ])\n574         else:\n575             result.append((tokNum, tokVal))\n576 \n577         prevTok = (tokNum, tokVal)\n578 \n579     return result\n580 \n581 \n582 def lambda_notation(tokens, local_dict, global_dict):\n583     \"\"\"Substitutes \"lambda\" with its Sympy equivalent Lambda().\n584     However, the conversion doesn't take place if only \"lambda\"\n585     is passed because that is a syntax error.\n586 \n587     \"\"\"\n588     result = []\n589     flag = False\n590     toknum, tokval = tokens[0]\n591     tokLen = len(tokens)\n592 \n593     if toknum == NAME and tokval == 'lambda':\n594         if tokLen == 2 or tokLen == 3 and tokens[1][0] == NEWLINE:\n595             # In Python 3.6.7+, inputs without a newline get NEWLINE added to\n596             # the tokens\n597             result.extend(tokens)\n598         elif tokLen > 2:\n599             result.extend([\n600                 (NAME, 'Lambda'),\n601                 (OP, '('),\n602                 (OP, '('),\n603                 (OP, ')'),\n604                 (OP, ')'),\n605             ])\n606             for tokNum, tokVal in tokens[1:]:\n607                 if tokNum == OP and tokVal == ':':\n608                     tokVal = ','\n609                     flag = True\n610                 if not flag and tokNum == OP and tokVal in ['*', '**']:\n611                     raise TokenError(\"Starred arguments in lambda not supported\")\n612                 if flag:\n613                     result.insert(-1, (tokNum, tokVal))\n614                 else:\n615                     result.insert(-2, (tokNum, tokVal))\n616     else:\n617         result.extend(tokens)\n618 \n619     return result\n620 \n621 \n622 def factorial_notation(tokens, local_dict, global_dict):\n623     \"\"\"Allows standard notation for factorial.\"\"\"\n624     result = []\n625     nfactorial = 0\n626     for toknum, tokval in tokens:\n627         if toknum == ERRORTOKEN:\n628             op = tokval\n629             if op == '!':\n630                 nfactorial += 1\n631             else:\n632                 nfactorial = 0\n633                 result.append((OP, op))\n634         else:\n635             if nfactorial == 1:\n636                 result = _add_factorial_tokens('factorial', result)\n637             elif nfactorial == 2:\n638                 result = _add_factorial_tokens('factorial2', result)\n639             elif nfactorial > 2:\n640                 raise TokenError\n641             nfactorial = 0\n642             result.append((toknum, tokval))\n643     return result\n644 \n645 \n646 def convert_xor(tokens, local_dict, global_dict):\n647     \"\"\"Treats XOR, ``^``, as exponentiation, ``**``.\"\"\"\n648     result = []\n649     for toknum, tokval in tokens:\n650         if toknum == OP:\n651             if tokval == '^':\n652                 result.append((OP, '**'))\n653             else:\n654                 result.append((toknum, tokval))\n655         else:\n656             result.append((toknum, tokval))\n657 \n658     return result\n659 \n660 \n661 def repeated_decimals(tokens, local_dict, global_dict):\n662     \"\"\"\n663     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)\n664 \n665     Run this before auto_number.\n666 \n667     \"\"\"\n668     result = []\n669 \n670     def is_digit(s):\n671         return all(i in '0123456789_' for i in s)\n672 \n673     # num will running match any DECIMAL [ INTEGER ]\n674     num = []\n675     for toknum, tokval in tokens:\n676         if toknum == NUMBER:\n677             if (not num and '.' in tokval and 'e' not in tokval.lower() and\n678                 'j' not in tokval.lower()):\n679                 num.append((toknum, tokval))\n680             elif is_digit(tokval)and  len(num) == 2:\n681                 num.append((toknum, tokval))\n682             elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):\n683                 # Python 2 tokenizes 00123 as '00', '123'\n684                 # Python 3 tokenizes 01289 as '012', '89'\n685                 num.append((toknum, tokval))\n686             else:\n687                 num = []\n688         elif toknum == OP:\n689             if tokval == '[' and len(num) == 1:\n690                 num.append((OP, tokval))\n691             elif tokval == ']' and len(num) >= 3:\n692                 num.append((OP, tokval))\n693             elif tokval == '.' and not num:\n694                 # handle .[1]\n695                 num.append((NUMBER, '0.'))\n696             else:\n697                 num = []\n698         else:\n699             num = []\n700 \n701         result.append((toknum, tokval))\n702 \n703         if num and num[-1][1] == ']':\n704             # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,\n705             # and d/e = repetend\n706             result = result[:-len(num)]\n707             pre, post = num[0][1].split('.')\n708             repetend = num[2][1]\n709             if len(num) == 5:\n710                 repetend += num[3][1]\n711 \n712             pre = pre.replace('_', '')\n713             post = post.replace('_', '')\n714             repetend = repetend.replace('_', '')\n715 \n716             zeros = '0'*len(post)\n717             post, repetends = [w.lstrip('0') for w in [post, repetend]]\n718                                         # or else interpreted as octal\n719 \n720             a = pre or '0'\n721             b, c = post or '0', '1' + zeros\n722             d, e = repetends, ('9'*len(repetend)) + zeros\n723 \n724             seq = [\n725                 (OP, '('),\n726                     (NAME, 'Integer'),\n727                     (OP, '('),\n728                         (NUMBER, a),\n729                     (OP, ')'),\n730                     (OP, '+'),\n731                     (NAME, 'Rational'),\n732                     (OP, '('),\n733                         (NUMBER, b),\n734                         (OP, ','),\n735                         (NUMBER, c),\n736                     (OP, ')'),\n737                     (OP, '+'),\n738                     (NAME, 'Rational'),\n739                     (OP, '('),\n740                         (NUMBER, d),\n741                         (OP, ','),\n742                         (NUMBER, e),\n743                     (OP, ')'),\n744                 (OP, ')'),\n745             ]\n746             result.extend(seq)\n747             num = []\n748 \n749     return result\n750 \n751 \n752 def auto_number(tokens, local_dict, global_dict):\n753     \"\"\"\n754     Converts numeric literals to use SymPy equivalents.\n755 \n756     Complex numbers use ``I``, integer literals use ``Integer``, and float\n757     literals use ``Float``.\n758 \n759     \"\"\"\n760     result = []\n761 \n762     for toknum, tokval in tokens:\n763         if toknum == NUMBER:\n764             number = tokval\n765             postfix = []\n766 \n767             if number.endswith('j') or number.endswith('J'):\n768                 number = number[:-1]\n769                 postfix = [(OP, '*'), (NAME, 'I')]\n770 \n771             if '.' in number or (('e' in number or 'E' in number) and\n772                     not (number.startswith('0x') or number.startswith('0X'))):\n773                 seq = [(NAME, 'Float'), (OP, '('),\n774                     (NUMBER, repr(str(number))), (OP, ')')]\n775             else:\n776                 seq = [(NAME, 'Integer'), (OP, '('), (\n777                     NUMBER, number), (OP, ')')]\n778 \n779             result.extend(seq + postfix)\n780         else:\n781             result.append((toknum, tokval))\n782 \n783     return result\n784 \n785 \n786 def rationalize(tokens, local_dict, global_dict):\n787     \"\"\"Converts floats into ``Rational``. Run AFTER ``auto_number``.\"\"\"\n788     result = []\n789     passed_float = False\n790     for toknum, tokval in tokens:\n791         if toknum == NAME:\n792             if tokval == 'Float':\n793                 passed_float = True\n794                 tokval = 'Rational'\n795             result.append((toknum, tokval))\n796         elif passed_float == True and toknum == NUMBER:\n797             passed_float = False\n798             result.append((STRING, tokval))\n799         else:\n800             result.append((toknum, tokval))\n801 \n802     return result\n803 \n804 \n805 def _transform_equals_sign(tokens, local_dict, global_dict):\n806     \"\"\"Transforms the equals sign ``=`` to instances of Eq.\n807 \n808     This is a helper function for `convert_equals_signs`.\n809     Works with expressions containing one equals sign and no\n810     nesting. Expressions like `(1=2)=False` won't work with this\n811     and should be used with `convert_equals_signs`.\n812 \n813     Examples: 1=2     to Eq(1,2)\n814               1*2=x   to Eq(1*2, x)\n815 \n816     This does not deal with function arguments yet.\n817 \n818     \"\"\"\n819     result = []\n820     if (OP, \"=\") in tokens:\n821         result.append((NAME, \"Eq\"))\n822         result.append((OP, \"(\"))\n823         for index, token in enumerate(tokens):\n824             if token == (OP, \"=\"):\n825                 result.append((OP, \",\"))\n826                 continue\n827             result.append(token)\n828         result.append((OP, \")\"))\n829     else:\n830         result = tokens\n831     return result\n832 \n833 \n834 def convert_equals_signs(result, local_dict, global_dict):\n835     \"\"\" Transforms all the equals signs ``=`` to instances of Eq.\n836 \n837     Parses the equals signs in the expression and replaces them with\n838     appropriate Eq instances.Also works with nested equals signs.\n839 \n840     Does not yet play well with function arguments.\n841     For example, the expression `(x=y)` is ambiguous and can be interpreted\n842     as x being an argument to a function and `convert_equals_signs` won't\n843     work for this.\n844 \n845     See also\n846     ========\n847     convert_equality_operators\n848 \n849     Examples\n850     ========\n851 \n852     >>> from sympy.parsing.sympy_parser import (parse_expr,\n853     ... standard_transformations, convert_equals_signs)\n854     >>> parse_expr(\"1*2=x\", transformations=(\n855     ... standard_transformations + (convert_equals_signs,)))\n856     Eq(2, x)\n857     >>> parse_expr(\"(1*2=x)=False\", transformations=(\n858     ... standard_transformations + (convert_equals_signs,)))\n859     Eq(Eq(2, x), False)\n860 \n861     \"\"\"\n862     for step in (_group_parentheses(convert_equals_signs),\n863                   _apply_functions,\n864                   _transform_equals_sign):\n865         result = step(result, local_dict, global_dict)\n866 \n867     result = _flatten(result)\n868     return result\n869 \n870 \n871 #: Standard transformations for :func:`parse_expr`.\n872 #: Inserts calls to :class:`~.Symbol`, :class:`~.Integer`, and other SymPy\n873 #: datatypes and allows the use of standard factorial notation (e.g. ``x!``).\n874 standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,\n875     factorial_notation)\n876 \n877 \n878 def stringify_expr(s, local_dict, global_dict, transformations):\n879     \"\"\"\n880     Converts the string ``s`` to Python code, in ``local_dict``\n881 \n882     Generally, ``parse_expr`` should be used.\n883     \"\"\"\n884 \n885     tokens = []\n886     input_code = StringIO(s.strip())\n887     for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):\n888         tokens.append((toknum, tokval))\n889 \n890     for transform in transformations:\n891         tokens = transform(tokens, local_dict, global_dict)\n892 \n893     return untokenize(tokens)\n894 \n895 \n896 def eval_expr(code, local_dict, global_dict):\n897     \"\"\"\n898     Evaluate Python code generated by ``stringify_expr``.\n899 \n900     Generally, ``parse_expr`` should be used.\n901     \"\"\"\n902     expr = eval(\n903         code, global_dict, local_dict)  # take local objects in preference\n904 \n905     return expr\n906 \n907 \n908 def parse_expr(s, local_dict=None, transformations=standard_transformations,\n909                global_dict=None, evaluate=True):\n910     \"\"\"Converts the string ``s`` to a SymPy expression, in ``local_dict``\n911 \n912     Parameters\n913     ==========\n914 \n915     s : str\n916         The string to parse.\n917 \n918     local_dict : dict, optional\n919         A dictionary of local variables to use when parsing.\n920 \n921     global_dict : dict, optional\n922         A dictionary of global variables. By default, this is initialized\n923         with ``from sympy import *``; provide this parameter to override\n924         this behavior (for instance, to parse ``\"Q & S\"``).\n925 \n926     transformations : tuple, optional\n927         A tuple of transformation functions used to modify the tokens of the\n928         parsed expression before evaluation. The default transformations\n929         convert numeric literals into their SymPy equivalents, convert\n930         undefined variables into SymPy symbols, and allow the use of standard\n931         mathematical factorial notation (e.g. ``x!``).\n932 \n933     evaluate : bool, optional\n934         When False, the order of the arguments will remain as they were in the\n935         string and automatic simplification that would normally occur is\n936         suppressed. (see examples)\n937 \n938     Examples\n939     ========\n940 \n941     >>> from sympy.parsing.sympy_parser import parse_expr\n942     >>> parse_expr(\"1/2\")\n943     1/2\n944     >>> type(_)\n945     <class 'sympy.core.numbers.Half'>\n946     >>> from sympy.parsing.sympy_parser import standard_transformations,\\\\\n947     ... implicit_multiplication_application\n948     >>> transformations = (standard_transformations +\n949     ...     (implicit_multiplication_application,))\n950     >>> parse_expr(\"2x\", transformations=transformations)\n951     2*x\n952 \n953     When evaluate=False, some automatic simplifications will not occur:\n954 \n955     >>> parse_expr(\"2**3\"), parse_expr(\"2**3\", evaluate=False)\n956     (8, 2**3)\n957 \n958     In addition the order of the arguments will not be made canonical.\n959     This feature allows one to tell exactly how the expression was entered:\n960 \n961     >>> a = parse_expr('1 + x', evaluate=False)\n962     >>> b = parse_expr('x + 1', evaluate=0)\n963     >>> a == b\n964     False\n965     >>> a.args\n966     (1, x)\n967     >>> b.args\n968     (x, 1)\n969 \n970     See Also\n971     ========\n972 \n973     stringify_expr, eval_expr, standard_transformations,\n974     implicit_multiplication_application\n975 \n976     \"\"\"\n977 \n978     if local_dict is None:\n979         local_dict = {}\n980     elif not isinstance(local_dict, dict):\n981         raise TypeError('expecting local_dict to be a dict')\n982 \n983     if global_dict is None:\n984         global_dict = {}\n985         exec_('from sympy import *', global_dict)\n986     elif not isinstance(global_dict, dict):\n987         raise TypeError('expecting global_dict to be a dict')\n988 \n989     transformations = transformations or ()\n990     if transformations:\n991         if not iterable(transformations):\n992             raise TypeError(\n993                 '`transformations` should be a list of functions.')\n994         for _ in transformations:\n995             if not callable(_):\n996                 raise TypeError(filldedent('''\n997                     expected a function in `transformations`,\n998                     not %s''' % func_name(_)))\n999             if arity(_) != 3:\n1000                 raise TypeError(filldedent('''\n1001                     a transformation should be function that\n1002                     takes 3 arguments'''))\n1003     code = stringify_expr(s, local_dict, global_dict, transformations)\n1004 \n1005     if not evaluate:\n1006         code = compile(evaluateFalse(code), '<string>', 'eval')\n1007 \n1008     return eval_expr(code, local_dict, global_dict)\n1009 \n1010 \n1011 def evaluateFalse(s):\n1012     \"\"\"\n1013     Replaces operators with the SymPy equivalent and sets evaluate=False.\n1014     \"\"\"\n1015     node = ast.parse(s)\n1016     node = EvaluateFalseTransformer().visit(node)\n1017     # node is a Module, we want an Expression\n1018     node = ast.Expression(node.body[0].value)\n1019 \n1020     return ast.fix_missing_locations(node)\n1021 \n1022 \n1023 class EvaluateFalseTransformer(ast.NodeTransformer):\n1024     operators = {\n1025         ast.Add: 'Add',\n1026         ast.Mult: 'Mul',\n1027         ast.Pow: 'Pow',\n1028         ast.Sub: 'Add',\n1029         ast.Div: 'Mul',\n1030         ast.BitOr: 'Or',\n1031         ast.BitAnd: 'And',\n1032         ast.BitXor: 'Not',\n1033     }\n1034 \n1035     def flatten(self, args, func):\n1036         result = []\n1037         for arg in args:\n1038             if isinstance(arg, ast.Call):\n1039                 arg_func = arg.func\n1040                 if isinstance(arg_func, ast.Call):\n1041                     arg_func = arg_func.func\n1042                 if arg_func.id == func:\n1043                     result.extend(self.flatten(arg.args, func))\n1044                 else:\n1045                     result.append(arg)\n1046             else:\n1047                 result.append(arg)\n1048         return result\n1049 \n1050     def visit_BinOp(self, node):\n1051         if node.op.__class__ in self.operators:\n1052             sympy_class = self.operators[node.op.__class__]\n1053             right = self.visit(node.right)\n1054             left = self.visit(node.left)\n1055             if isinstance(node.left, ast.UnaryOp) and (isinstance(node.right, ast.UnaryOp) == 0) and sympy_class in ('Mul',):\n1056                 left, right = right, left\n1057             if isinstance(node.op, ast.Sub):\n1058                 right = ast.Call(\n1059                     func=ast.Name(id='Mul', ctx=ast.Load()),\n1060                     args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(1)), right],\n1061                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1062                     starargs=None,\n1063                     kwargs=None\n1064                 )\n1065             if isinstance(node.op, ast.Div):\n1066                 if isinstance(node.left, ast.UnaryOp):\n1067                     if isinstance(node.right,ast.UnaryOp):\n1068                         left, right = right, left\n1069                     left = ast.Call(\n1070                     func=ast.Name(id='Pow', ctx=ast.Load()),\n1071                     args=[left, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],\n1072                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1073                     starargs=None,\n1074                     kwargs=None\n1075                 )\n1076                 else:\n1077                     right = ast.Call(\n1078                     func=ast.Name(id='Pow', ctx=ast.Load()),\n1079                     args=[right, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],\n1080                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1081                     starargs=None,\n1082                     kwargs=None\n1083                 )\n1084 \n1085             new_node = ast.Call(\n1086                 func=ast.Name(id=sympy_class, ctx=ast.Load()),\n1087                 args=[left, right],\n1088                 keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],\n1089                 starargs=None,\n1090                 kwargs=None\n1091             )\n1092 \n1093             if sympy_class in ('Add', 'Mul'):\n1094                 # Denest Add or Mul as appropriate\n1095                 new_node.args = self.flatten(new_node.args, sympy_class)\n1096 \n1097             return new_node\n1098         return node\n",
        "intended_behavior": "Within `eval_expr`, introduce additional safeguards against executing unverified code. This may include verifying the contents of the `code` parameter against a set of allowed operations and structures before allowing `eval` to execute. Additionally, implementing a more restricted execution context for `eval` can limit potential damage from malicious or unintended code execution. This context could limit the available namespaces and restrict execution capabilities to purely mathematical evaluations, thus reducing risk."
    }
]