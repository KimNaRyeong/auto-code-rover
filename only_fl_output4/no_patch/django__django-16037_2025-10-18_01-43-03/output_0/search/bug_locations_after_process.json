[
    {
        "rel_file_path": "django/forms/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/models.py",
        "start": 1,
        "end": 1659,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Helper functions for creating Form classes from Django models\n3 and database field objects.\n4 \"\"\"\n5 from itertools import chain\n6 \n7 from django.core.exceptions import (\n8     NON_FIELD_ERRORS,\n9     FieldError,\n10     ImproperlyConfigured,\n11     ValidationError,\n12 )\n13 from django.forms.fields import ChoiceField, Field\n14 from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n15 from django.forms.formsets import BaseFormSet, formset_factory\n16 from django.forms.utils import ErrorList\n17 from django.forms.widgets import (\n18     HiddenInput,\n19     MultipleHiddenInput,\n20     RadioSelect,\n21     SelectMultiple,\n22 )\n23 from django.utils.text import capfirst, get_text_list\n24 from django.utils.translation import gettext\n25 from django.utils.translation import gettext_lazy as _\n26 \n27 __all__ = (\n28     \"ModelForm\",\n29     \"BaseModelForm\",\n30     \"model_to_dict\",\n31     \"fields_for_model\",\n32     \"ModelChoiceField\",\n33     \"ModelMultipleChoiceField\",\n34     \"ALL_FIELDS\",\n35     \"BaseModelFormSet\",\n36     \"modelformset_factory\",\n37     \"BaseInlineFormSet\",\n38     \"inlineformset_factory\",\n39     \"modelform_factory\",\n40 )\n41 \n42 ALL_FIELDS = \"__all__\"\n43 \n44 \n45 def construct_instance(form, instance, fields=None, exclude=None):\n46     \"\"\"\n47     Construct and return a model instance from the bound ``form``'s\n48     ``cleaned_data``, but do not save the returned instance to the database.\n49     \"\"\"\n50     from django.db import models\n51 \n52     opts = instance._meta\n53 \n54     cleaned_data = form.cleaned_data\n55     file_field_list = []\n56     for f in opts.fields:\n57         if (\n58             not f.editable\n59             or isinstance(f, models.AutoField)\n60             or f.name not in cleaned_data\n61         ):\n62             continue\n63         if fields is not None and f.name not in fields:\n64             continue\n65         if exclude and f.name in exclude:\n66             continue\n67         # Leave defaults for fields that aren't in POST data, except for\n68         # checkbox inputs because they don't appear in POST data if not checked.\n69         if (\n70             f.has_default()\n71             and form[f.name].field.widget.value_omitted_from_data(\n72                 form.data, form.files, form.add_prefix(f.name)\n73             )\n74             and cleaned_data.get(f.name) in form[f.name].field.empty_values\n75         ):\n76             continue\n77         # Defer saving file-type fields until after the other fields, so a\n78         # callable upload_to can use the values from other fields.\n79         if isinstance(f, models.FileField):\n80             file_field_list.append(f)\n81         else:\n82             f.save_form_data(instance, cleaned_data[f.name])\n83 \n84     for f in file_field_list:\n85         f.save_form_data(instance, cleaned_data[f.name])\n86 \n87     return instance\n88 \n89 \n90 # ModelForms #################################################################\n91 \n92 \n93 def model_to_dict(instance, fields=None, exclude=None):\n94     \"\"\"\n95     Return a dict containing the data in ``instance`` suitable for passing as\n96     a Form's ``initial`` keyword argument.\n97 \n98     ``fields`` is an optional list of field names. If provided, return only the\n99     named.\n100 \n101     ``exclude`` is an optional list of field names. If provided, exclude the\n102     named from the returned dict, even if they are listed in the ``fields``\n103     argument.\n104     \"\"\"\n105     opts = instance._meta\n106     data = {}\n107     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):\n108         if not getattr(f, \"editable\", False):\n109             continue\n110         if fields is not None and f.name not in fields:\n111             continue\n112         if exclude and f.name in exclude:\n113             continue\n114         data[f.name] = f.value_from_object(instance)\n115     return data\n116 \n117 \n118 def apply_limit_choices_to_to_formfield(formfield):\n119     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n120     from django.db.models import Exists, OuterRef, Q\n121 \n122     if hasattr(formfield, \"queryset\") and hasattr(formfield, \"get_limit_choices_to\"):\n123         limit_choices_to = formfield.get_limit_choices_to()\n124         if limit_choices_to:\n125             complex_filter = limit_choices_to\n126             if not isinstance(complex_filter, Q):\n127                 complex_filter = Q(**limit_choices_to)\n128             complex_filter &= Q(pk=OuterRef(\"pk\"))\n129             # Use Exists() to avoid potential duplicates.\n130             formfield.queryset = formfield.queryset.filter(\n131                 Exists(formfield.queryset.model._base_manager.filter(complex_filter)),\n132             )\n133 \n134 \n135 def fields_for_model(\n136     model,\n137     fields=None,\n138     exclude=None,\n139     widgets=None,\n140     formfield_callback=None,\n141     localized_fields=None,\n142     labels=None,\n143     help_texts=None,\n144     error_messages=None,\n145     field_classes=None,\n146     *,\n147     apply_limit_choices_to=True,\n148 ):\n149     \"\"\"\n150     Return a dictionary containing form fields for the given model.\n151 \n152     ``fields`` is an optional list of field names. If provided, return only the\n153     named fields.\n154 \n155     ``exclude`` is an optional list of field names. If provided, exclude the\n156     named fields from the returned fields, even if they are listed in the\n157     ``fields`` argument.\n158 \n159     ``widgets`` is a dictionary of model field names mapped to a widget.\n160 \n161     ``formfield_callback`` is a callable that takes a model field and returns\n162     a form field.\n163 \n164     ``localized_fields`` is a list of names of fields which should be localized.\n165 \n166     ``labels`` is a dictionary of model field names mapped to a label.\n167 \n168     ``help_texts`` is a dictionary of model field names mapped to a help text.\n169 \n170     ``error_messages`` is a dictionary of model field names mapped to a\n171     dictionary of error messages.\n172 \n173     ``field_classes`` is a dictionary of model field names mapped to a form\n174     field class.\n175 \n176     ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to\n177     should be applied to a field's queryset.\n178     \"\"\"\n179     field_dict = {}\n180     ignored = []\n181     opts = model._meta\n182     # Avoid circular import\n183     from django.db.models import Field as ModelField\n184 \n185     sortable_private_fields = [\n186         f for f in opts.private_fields if isinstance(f, ModelField)\n187     ]\n188     for f in sorted(\n189         chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)\n190     ):\n191         if not getattr(f, \"editable\", False):\n192             if (\n193                 fields is not None\n194                 and f.name in fields\n195                 and (exclude is None or f.name not in exclude)\n196             ):\n197                 raise FieldError(\n198                     \"'%s' cannot be specified for %s model form as it is a \"\n199                     \"non-editable field\" % (f.name, model.__name__)\n200                 )\n201             continue\n202         if fields is not None and f.name not in fields:\n203             continue\n204         if exclude and f.name in exclude:\n205             continue\n206 \n207         kwargs = {}\n208         if widgets and f.name in widgets:\n209             kwargs[\"widget\"] = widgets[f.name]\n210         if localized_fields == ALL_FIELDS or (\n211             localized_fields and f.name in localized_fields\n212         ):\n213             kwargs[\"localize\"] = True\n214         if labels and f.name in labels:\n215             kwargs[\"label\"] = labels[f.name]\n216         if help_texts and f.name in help_texts:\n217             kwargs[\"help_text\"] = help_texts[f.name]\n218         if error_messages and f.name in error_messages:\n219             kwargs[\"error_messages\"] = error_messages[f.name]\n220         if field_classes and f.name in field_classes:\n221             kwargs[\"form_class\"] = field_classes[f.name]\n222 \n223         if formfield_callback is None:\n224             formfield = f.formfield(**kwargs)\n225         elif not callable(formfield_callback):\n226             raise TypeError(\"formfield_callback must be a function or callable\")\n227         else:\n228             formfield = formfield_callback(f, **kwargs)\n229 \n230         if formfield:\n231             if apply_limit_choices_to:\n232                 apply_limit_choices_to_to_formfield(formfield)\n233             field_dict[f.name] = formfield\n234         else:\n235             ignored.append(f.name)\n236     if fields:\n237         field_dict = {\n238             f: field_dict.get(f)\n239             for f in fields\n240             if (not exclude or f not in exclude) and f not in ignored\n241         }\n242     return field_dict\n243 \n244 \n245 class ModelFormOptions:\n246     def __init__(self, options=None):\n247         self.model = getattr(options, \"model\", None)\n248         self.fields = getattr(options, \"fields\", None)\n249         self.exclude = getattr(options, \"exclude\", None)\n250         self.widgets = getattr(options, \"widgets\", None)\n251         self.localized_fields = getattr(options, \"localized_fields\", None)\n252         self.labels = getattr(options, \"labels\", None)\n253         self.help_texts = getattr(options, \"help_texts\", None)\n254         self.error_messages = getattr(options, \"error_messages\", None)\n255         self.field_classes = getattr(options, \"field_classes\", None)\n256         self.formfield_callback = getattr(options, \"formfield_callback\", None)\n257 \n258 \n259 class ModelFormMetaclass(DeclarativeFieldsMetaclass):\n260     def __new__(mcs, name, bases, attrs):\n261         new_class = super().__new__(mcs, name, bases, attrs)\n262 \n263         if bases == (BaseModelForm,):\n264             return new_class\n265 \n266         opts = new_class._meta = ModelFormOptions(getattr(new_class, \"Meta\", None))\n267 \n268         # We check if a string was passed to `fields` or `exclude`,\n269         # which is likely to be a mistake where the user typed ('foo') instead\n270         # of ('foo',)\n271         for opt in [\"fields\", \"exclude\", \"localized_fields\"]:\n272             value = getattr(opts, opt)\n273             if isinstance(value, str) and value != ALL_FIELDS:\n274                 msg = (\n275                     \"%(model)s.Meta.%(opt)s cannot be a string. \"\n276                     \"Did you mean to type: ('%(value)s',)?\"\n277                     % {\n278                         \"model\": new_class.__name__,\n279                         \"opt\": opt,\n280                         \"value\": value,\n281                     }\n282                 )\n283                 raise TypeError(msg)\n284 \n285         if opts.model:\n286             # If a model is defined, extract form fields from it.\n287             if opts.fields is None and opts.exclude is None:\n288                 raise ImproperlyConfigured(\n289                     \"Creating a ModelForm without either the 'fields' attribute \"\n290                     \"or the 'exclude' attribute is prohibited; form %s \"\n291                     \"needs updating.\" % name\n292                 )\n293 \n294             if opts.fields == ALL_FIELDS:\n295                 # Sentinel for fields_for_model to indicate \"get the list of\n296                 # fields from the model\"\n297                 opts.fields = None\n298 \n299             fields = fields_for_model(\n300                 opts.model,\n301                 opts.fields,\n302                 opts.exclude,\n303                 opts.widgets,\n304                 opts.formfield_callback,\n305                 opts.localized_fields,\n306                 opts.labels,\n307                 opts.help_texts,\n308                 opts.error_messages,\n309                 opts.field_classes,\n310                 # limit_choices_to will be applied during ModelForm.__init__().\n311                 apply_limit_choices_to=False,\n312             )\n313 \n314             # make sure opts.fields doesn't specify an invalid field\n315             none_model_fields = {k for k, v in fields.items() if not v}\n316             missing_fields = none_model_fields.difference(new_class.declared_fields)\n317             if missing_fields:\n318                 message = \"Unknown field(s) (%s) specified for %s\"\n319                 message = message % (\", \".join(missing_fields), opts.model.__name__)\n320                 raise FieldError(message)\n321             # Override default model fields with any custom declared ones\n322             # (plus, include all the other declared fields).\n323             fields.update(new_class.declared_fields)\n324         else:\n325             fields = new_class.declared_fields\n326 \n327         new_class.base_fields = fields\n328 \n329         return new_class\n330 \n331 \n332 class BaseModelForm(BaseForm):\n333     def __init__(\n334         self,\n335         data=None,\n336         files=None,\n337         auto_id=\"id_%s\",\n338         prefix=None,\n339         initial=None,\n340         error_class=ErrorList,\n341         label_suffix=None,\n342         empty_permitted=False,\n343         instance=None,\n344         use_required_attribute=None,\n345         renderer=None,\n346     ):\n347         opts = self._meta\n348         if opts.model is None:\n349             raise ValueError(\"ModelForm has no model class specified.\")\n350         if instance is None:\n351             # if we didn't get an instance, instantiate a new one\n352             self.instance = opts.model()\n353             object_data = {}\n354         else:\n355             self.instance = instance\n356             object_data = model_to_dict(instance, opts.fields, opts.exclude)\n357         # if initial was provided, it should override the values from instance\n358         if initial is not None:\n359             object_data.update(initial)\n360         # self._validate_unique will be set to True by BaseModelForm.clean().\n361         # It is False by default so overriding self.clean() and failing to call\n362         # super will stop validate_unique from being called.\n363         self._validate_unique = False\n364         super().__init__(\n365             data,\n366             files,\n367             auto_id,\n368             prefix,\n369             object_data,\n370             error_class,\n371             label_suffix,\n372             empty_permitted,\n373             use_required_attribute=use_required_attribute,\n374             renderer=renderer,\n375         )\n376         for formfield in self.fields.values():\n377             apply_limit_choices_to_to_formfield(formfield)\n378 \n379     def _get_validation_exclusions(self):\n380         \"\"\"\n381         For backwards-compatibility, exclude several types of fields from model\n382         validation. See tickets #12507, #12521, #12553.\n383         \"\"\"\n384         exclude = set()\n385         # Build up a list of fields that should be excluded from model field\n386         # validation and unique checks.\n387         for f in self.instance._meta.fields:\n388             field = f.name\n389             # Exclude fields that aren't on the form. The developer may be\n390             # adding these values to the model after form validation.\n391             if field not in self.fields:\n392                 exclude.add(f.name)\n393 \n394             # Don't perform model validation on fields that were defined\n395             # manually on the form and excluded via the ModelForm's Meta\n396             # class. See #12901.\n397             elif self._meta.fields and field not in self._meta.fields:\n398                 exclude.add(f.name)\n399             elif self._meta.exclude and field in self._meta.exclude:\n400                 exclude.add(f.name)\n401 \n402             # Exclude fields that failed form validation. There's no need for\n403             # the model fields to validate them as well.\n404             elif field in self._errors:\n405                 exclude.add(f.name)\n406 \n407             # Exclude empty fields that are not required by the form, if the\n408             # underlying model field is required. This keeps the model field\n409             # from raising a required error. Note: don't exclude the field from\n410             # validation if the model field allows blanks. If it does, the blank\n411             # value may be included in a unique check, so cannot be excluded\n412             # from validation.\n413             else:\n414                 form_field = self.fields[field]\n415                 field_value = self.cleaned_data.get(field)\n416                 if (\n417                     not f.blank\n418                     and not form_field.required\n419                     and field_value in form_field.empty_values\n420                 ):\n421                     exclude.add(f.name)\n422         return exclude\n423 \n424     def clean(self):\n425         self._validate_unique = True\n426         return self.cleaned_data\n427 \n428     def _update_errors(self, errors):\n429         # Override any validation error messages defined at the model level\n430         # with those defined at the form level.\n431         opts = self._meta\n432 \n433         # Allow the model generated by construct_instance() to raise\n434         # ValidationError and have them handled in the same way as others.\n435         if hasattr(errors, \"error_dict\"):\n436             error_dict = errors.error_dict\n437         else:\n438             error_dict = {NON_FIELD_ERRORS: errors}\n439 \n440         for field, messages in error_dict.items():\n441             if (\n442                 field == NON_FIELD_ERRORS\n443                 and opts.error_messages\n444                 and NON_FIELD_ERRORS in opts.error_messages\n445             ):\n446                 error_messages = opts.error_messages[NON_FIELD_ERRORS]\n447             elif field in self.fields:\n448                 error_messages = self.fields[field].error_messages\n449             else:\n450                 continue\n451 \n452             for message in messages:\n453                 if (\n454                     isinstance(message, ValidationError)\n455                     and message.code in error_messages\n456                 ):\n457                     message.message = error_messages[message.code]\n458 \n459         self.add_error(None, errors)\n460 \n461     def _post_clean(self):\n462         opts = self._meta\n463 \n464         exclude = self._get_validation_exclusions()\n465 \n466         # Foreign Keys being used to represent inline relationships\n467         # are excluded from basic field value validation. This is for two\n468         # reasons: firstly, the value may not be supplied (#12507; the\n469         # case of providing new values to the admin); secondly the\n470         # object being referred to may not yet fully exist (#12749).\n471         # However, these fields *must* be included in uniqueness checks,\n472         # so this can't be part of _get_validation_exclusions().\n473         for name, field in self.fields.items():\n474             if isinstance(field, InlineForeignKeyField):\n475                 exclude.add(name)\n476 \n477         try:\n478             self.instance = construct_instance(\n479                 self, self.instance, opts.fields, opts.exclude\n480             )\n481         except ValidationError as e:\n482             self._update_errors(e)\n483 \n484         try:\n485             self.instance.full_clean(exclude=exclude, validate_unique=False)\n486         except ValidationError as e:\n487             self._update_errors(e)\n488 \n489         # Validate uniqueness if needed.\n490         if self._validate_unique:\n491             self.validate_unique()\n492 \n493     def validate_unique(self):\n494         \"\"\"\n495         Call the instance's validate_unique() method and update the form's\n496         validation errors if any were raised.\n497         \"\"\"\n498         exclude = self._get_validation_exclusions()\n499         try:\n500             self.instance.validate_unique(exclude=exclude)\n501         except ValidationError as e:\n502             self._update_errors(e)\n503 \n504     def _save_m2m(self):\n505         \"\"\"\n506         Save the many-to-many fields and generic relations for this form.\n507         \"\"\"\n508         cleaned_data = self.cleaned_data\n509         exclude = self._meta.exclude\n510         fields = self._meta.fields\n511         opts = self.instance._meta\n512         # Note that for historical reasons we want to include also\n513         # private_fields here. (GenericRelation was previously a fake\n514         # m2m field).\n515         for f in chain(opts.many_to_many, opts.private_fields):\n516             if not hasattr(f, \"save_form_data\"):\n517                 continue\n518             if fields and f.name not in fields:\n519                 continue\n520             if exclude and f.name in exclude:\n521                 continue\n522             if f.name in cleaned_data:\n523                 f.save_form_data(self.instance, cleaned_data[f.name])\n524 \n525     def save(self, commit=True):\n526         \"\"\"\n527         Save this form's self.instance object if commit=True. Otherwise, add\n528         a save_m2m() method to the form which can be called after the instance\n529         is saved manually at a later time. Return the model instance.\n530         \"\"\"\n531         if self.errors:\n532             raise ValueError(\n533                 \"The %s could not be %s because the data didn't validate.\"\n534                 % (\n535                     self.instance._meta.object_name,\n536                     \"created\" if self.instance._state.adding else \"changed\",\n537                 )\n538             )\n539         if commit:\n540             # If committing, save the instance and the m2m data immediately.\n541             self.instance.save()\n542             self._save_m2m()\n543         else:\n544             # If not committing, add a method to the form to allow deferred\n545             # saving of m2m data.\n546             self.save_m2m = self._save_m2m\n547         return self.instance\n548 \n549     save.alters_data = True\n550 \n551 \n552 class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n553     pass\n554 \n555 \n556 def modelform_factory(\n557     model,\n558     form=ModelForm,\n559     fields=None,\n560     exclude=None,\n561     formfield_callback=None,\n562     widgets=None,\n563     localized_fields=None,\n564     labels=None,\n565     help_texts=None,\n566     error_messages=None,\n567     field_classes=None,\n568 ):\n569     \"\"\"\n570     Return a ModelForm containing form fields for the given model. You can\n571     optionally pass a `form` argument to use as a starting point for\n572     constructing the ModelForm.\n573 \n574     ``fields`` is an optional list of field names. If provided, include only\n575     the named fields in the returned fields. If omitted or '__all__', use all\n576     fields.\n577 \n578     ``exclude`` is an optional list of field names. If provided, exclude the\n579     named fields from the returned fields, even if they are listed in the\n580     ``fields`` argument.\n581 \n582     ``widgets`` is a dictionary of model field names mapped to a widget.\n583 \n584     ``localized_fields`` is a list of names of fields which should be localized.\n585 \n586     ``formfield_callback`` is a callable that takes a model field and returns\n587     a form field.\n588 \n589     ``labels`` is a dictionary of model field names mapped to a label.\n590 \n591     ``help_texts`` is a dictionary of model field names mapped to a help text.\n592 \n593     ``error_messages`` is a dictionary of model field names mapped to a\n594     dictionary of error messages.\n595 \n596     ``field_classes`` is a dictionary of model field names mapped to a form\n597     field class.\n598     \"\"\"\n599     # Create the inner Meta class. FIXME: ideally, we should be able to\n600     # construct a ModelForm without creating and passing in a temporary\n601     # inner class.\n602 \n603     # Build up a list of attributes that the Meta object will have.\n604     attrs = {\"model\": model}\n605     if fields is not None:\n606         attrs[\"fields\"] = fields\n607     if exclude is not None:\n608         attrs[\"exclude\"] = exclude\n609     if widgets is not None:\n610         attrs[\"widgets\"] = widgets\n611     if localized_fields is not None:\n612         attrs[\"localized_fields\"] = localized_fields\n613     if labels is not None:\n614         attrs[\"labels\"] = labels\n615     if help_texts is not None:\n616         attrs[\"help_texts\"] = help_texts\n617     if error_messages is not None:\n618         attrs[\"error_messages\"] = error_messages\n619     if field_classes is not None:\n620         attrs[\"field_classes\"] = field_classes\n621 \n622     # If parent form class already has an inner Meta, the Meta we're\n623     # creating needs to inherit from the parent's inner meta.\n624     bases = (form.Meta,) if hasattr(form, \"Meta\") else ()\n625     Meta = type(\"Meta\", bases, attrs)\n626     if formfield_callback:\n627         Meta.formfield_callback = staticmethod(formfield_callback)\n628     # Give this new form class a reasonable name.\n629     class_name = model.__name__ + \"Form\"\n630 \n631     # Class attributes for the new form class.\n632     form_class_attrs = {\"Meta\": Meta}\n633 \n634     if getattr(Meta, \"fields\", None) is None and getattr(Meta, \"exclude\", None) is None:\n635         raise ImproperlyConfigured(\n636             \"Calling modelform_factory without defining 'fields' or \"\n637             \"'exclude' explicitly is prohibited.\"\n638         )\n639 \n640     # Instantiate type(form) in order to use the same metaclass as form.\n641     return type(form)(class_name, (form,), form_class_attrs)\n642 \n643 \n644 # ModelFormSets ##############################################################\n645 \n646 \n647 class BaseModelFormSet(BaseFormSet):\n648     \"\"\"\n649     A ``FormSet`` for editing a queryset and/or adding new objects to it.\n650     \"\"\"\n651 \n652     model = None\n653     edit_only = False\n654 \n655     # Set of fields that must be unique among forms of this set.\n656     unique_fields = set()\n657 \n658     def __init__(\n659         self,\n660         data=None,\n661         files=None,\n662         auto_id=\"id_%s\",\n663         prefix=None,\n664         queryset=None,\n665         *,\n666         initial=None,\n667         **kwargs,\n668     ):\n669         self.queryset = queryset\n670         self.initial_extra = initial\n671         super().__init__(\n672             **{\n673                 \"data\": data,\n674                 \"files\": files,\n675                 \"auto_id\": auto_id,\n676                 \"prefix\": prefix,\n677                 **kwargs,\n678             }\n679         )\n680 \n681     def initial_form_count(self):\n682         \"\"\"Return the number of forms that are required in this FormSet.\"\"\"\n683         if not self.is_bound:\n684             return len(self.get_queryset())\n685         return super().initial_form_count()\n686 \n687     def _existing_object(self, pk):\n688         if not hasattr(self, \"_object_dict\"):\n689             self._object_dict = {o.pk: o for o in self.get_queryset()}\n690         return self._object_dict.get(pk)\n691 \n692     def _get_to_python(self, field):\n693         \"\"\"\n694         If the field is a related field, fetch the concrete field's (that\n695         is, the ultimate pointed-to field's) to_python.\n696         \"\"\"\n697         while field.remote_field is not None:\n698             field = field.remote_field.get_related_field()\n699         return field.to_python\n700 \n701     def _construct_form(self, i, **kwargs):\n702         pk_required = i < self.initial_form_count()\n703         if pk_required:\n704             if self.is_bound:\n705                 pk_key = \"%s-%s\" % (self.add_prefix(i), self.model._meta.pk.name)\n706                 try:\n707                     pk = self.data[pk_key]\n708                 except KeyError:\n709                     # The primary key is missing. The user may have tampered\n710                     # with POST data.\n711                     pass\n712                 else:\n713                     to_python = self._get_to_python(self.model._meta.pk)\n714                     try:\n715                         pk = to_python(pk)\n716                     except ValidationError:\n717                         # The primary key exists but is an invalid value. The\n718                         # user may have tampered with POST data.\n719                         pass\n720                     else:\n721                         kwargs[\"instance\"] = self._existing_object(pk)\n722             else:\n723                 kwargs[\"instance\"] = self.get_queryset()[i]\n724         elif self.initial_extra:\n725             # Set initial values for extra forms\n726             try:\n727                 kwargs[\"initial\"] = self.initial_extra[i - self.initial_form_count()]\n728             except IndexError:\n729                 pass\n730         form = super()._construct_form(i, **kwargs)\n731         if pk_required:\n732             form.fields[self.model._meta.pk.name].required = True\n733         return form\n734 \n735     def get_queryset(self):\n736         if not hasattr(self, \"_queryset\"):\n737             if self.queryset is not None:\n738                 qs = self.queryset\n739             else:\n740                 qs = self.model._default_manager.get_queryset()\n741 \n742             # If the queryset isn't already ordered we need to add an\n743             # artificial ordering here to make sure that all formsets\n744             # constructed from this queryset have the same form order.\n745             if not qs.ordered:\n746                 qs = qs.order_by(self.model._meta.pk.name)\n747 \n748             # Removed queryset limiting here. As per discussion re: #13023\n749             # on django-dev, max_num should not prevent existing\n750             # related objects/inlines from being displayed.\n751             self._queryset = qs\n752         return self._queryset\n753 \n754     def save_new(self, form, commit=True):\n755         \"\"\"Save and return a new model instance for the given form.\"\"\"\n756         return form.save(commit=commit)\n757 \n758     def save_existing(self, form, instance, commit=True):\n759         \"\"\"Save and return an existing model instance for the given form.\"\"\"\n760         return form.save(commit=commit)\n761 \n762     def delete_existing(self, obj, commit=True):\n763         \"\"\"Deletes an existing model instance.\"\"\"\n764         if commit:\n765             obj.delete()\n766 \n767     def save(self, commit=True):\n768         \"\"\"\n769         Save model instances for every form, adding and changing instances\n770         as necessary, and return the list of instances.\n771         \"\"\"\n772         if not commit:\n773             self.saved_forms = []\n774 \n775             def save_m2m():\n776                 for form in self.saved_forms:\n777                     form.save_m2m()\n778 \n779             self.save_m2m = save_m2m\n780         if self.edit_only:\n781             return self.save_existing_objects(commit)\n782         else:\n783             return self.save_existing_objects(commit) + self.save_new_objects(commit)\n784 \n785     save.alters_data = True\n786 \n787     def clean(self):\n788         self.validate_unique()\n789 \n790     def validate_unique(self):\n791         # Collect unique_checks and date_checks to run from all the forms.\n792         all_unique_checks = set()\n793         all_date_checks = set()\n794         forms_to_delete = self.deleted_forms\n795         valid_forms = [\n796             form\n797             for form in self.forms\n798             if form.is_valid() and form not in forms_to_delete\n799         ]\n800         for form in valid_forms:\n801             exclude = form._get_validation_exclusions()\n802             unique_checks, date_checks = form.instance._get_unique_checks(\n803                 exclude=exclude,\n804                 include_meta_constraints=True,\n805             )\n806             all_unique_checks.update(unique_checks)\n807             all_date_checks.update(date_checks)\n808 \n809         errors = []\n810         # Do each of the unique checks (unique and unique_together)\n811         for uclass, unique_check in all_unique_checks:\n812             seen_data = set()\n813             for form in valid_forms:\n814                 # Get the data for the set of fields that must be unique among\n815                 # the forms.\n816                 row_data = (\n817                     field if field in self.unique_fields else form.cleaned_data[field]\n818                     for field in unique_check\n819                     if field in form.cleaned_data\n820                 )\n821                 # Reduce Model instances to their primary key values\n822                 row_data = tuple(\n823                     d._get_pk_val() if hasattr(d, \"_get_pk_val\")\n824                     # Prevent \"unhashable type: list\" errors later on.\n825                     else tuple(d) if isinstance(d, list) else d\n826                     for d in row_data\n827                 )\n828                 if row_data and None not in row_data:\n829                     # if we've already seen it then we have a uniqueness failure\n830                     if row_data in seen_data:\n831                         # poke error messages into the right places and mark\n832                         # the form as invalid\n833                         errors.append(self.get_unique_error_message(unique_check))\n834                         form._errors[NON_FIELD_ERRORS] = self.error_class(\n835                             [self.get_form_error()],\n836                             renderer=self.renderer,\n837                         )\n838                         # Remove the data from the cleaned_data dict since it\n839                         # was invalid.\n840                         for field in unique_check:\n841                             if field in form.cleaned_data:\n842                                 del form.cleaned_data[field]\n843                     # mark the data as seen\n844                     seen_data.add(row_data)\n845         # iterate over each of the date checks now\n846         for date_check in all_date_checks:\n847             seen_data = set()\n848             uclass, lookup, field, unique_for = date_check\n849             for form in valid_forms:\n850                 # see if we have data for both fields\n851                 if (\n852                     form.cleaned_data\n853                     and form.cleaned_data[field] is not None\n854                     and form.cleaned_data[unique_for] is not None\n855                 ):\n856                     # if it's a date lookup we need to get the data for all the fields\n857                     if lookup == \"date\":\n858                         date = form.cleaned_data[unique_for]\n859                         date_data = (date.year, date.month, date.day)\n860                     # otherwise it's just the attribute on the date/datetime\n861                     # object\n862                     else:\n863                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)\n864                     data = (form.cleaned_data[field],) + date_data\n865                     # if we've already seen it then we have a uniqueness failure\n866                     if data in seen_data:\n867                         # poke error messages into the right places and mark\n868                         # the form as invalid\n869                         errors.append(self.get_date_error_message(date_check))\n870                         form._errors[NON_FIELD_ERRORS] = self.error_class(\n871                             [self.get_form_error()],\n872                             renderer=self.renderer,\n873                         )\n874                         # Remove the data from the cleaned_data dict since it\n875                         # was invalid.\n876                         del form.cleaned_data[field]\n877                     # mark the data as seen\n878                     seen_data.add(data)\n879 \n880         if errors:\n881             raise ValidationError(errors)\n882 \n883     def get_unique_error_message(self, unique_check):\n884         if len(unique_check) == 1:\n885             return gettext(\"Please correct the duplicate data for %(field)s.\") % {\n886                 \"field\": unique_check[0],\n887             }\n888         else:\n889             return gettext(\n890                 \"Please correct the duplicate data for %(field)s, which must be unique.\"\n891             ) % {\n892                 \"field\": get_text_list(unique_check, _(\"and\")),\n893             }\n894 \n895     def get_date_error_message(self, date_check):\n896         return gettext(\n897             \"Please correct the duplicate data for %(field_name)s \"\n898             \"which must be unique for the %(lookup)s in %(date_field)s.\"\n899         ) % {\n900             \"field_name\": date_check[2],\n901             \"date_field\": date_check[3],\n902             \"lookup\": str(date_check[1]),\n903         }\n904 \n905     def get_form_error(self):\n906         return gettext(\"Please correct the duplicate values below.\")\n907 \n908     def save_existing_objects(self, commit=True):\n909         self.changed_objects = []\n910         self.deleted_objects = []\n911         if not self.initial_forms:\n912             return []\n913 \n914         saved_instances = []\n915         forms_to_delete = self.deleted_forms\n916         for form in self.initial_forms:\n917             obj = form.instance\n918             # If the pk is None, it means either:\n919             # 1. The object is an unexpected empty model, created by invalid\n920             #    POST data such as an object outside the formset's queryset.\n921             # 2. The object was already deleted from the database.\n922             if obj.pk is None:\n923                 continue\n924             if form in forms_to_delete:\n925                 self.deleted_objects.append(obj)\n926                 self.delete_existing(obj, commit=commit)\n927             elif form.has_changed():\n928                 self.changed_objects.append((obj, form.changed_data))\n929                 saved_instances.append(self.save_existing(form, obj, commit=commit))\n930                 if not commit:\n931                     self.saved_forms.append(form)\n932         return saved_instances\n933 \n934     def save_new_objects(self, commit=True):\n935         self.new_objects = []\n936         for form in self.extra_forms:\n937             if not form.has_changed():\n938                 continue\n939             # If someone has marked an add form for deletion, don't save the\n940             # object.\n941             if self.can_delete and self._should_delete_form(form):\n942                 continue\n943             self.new_objects.append(self.save_new(form, commit=commit))\n944             if not commit:\n945                 self.saved_forms.append(form)\n946         return self.new_objects\n947 \n948     def add_fields(self, form, index):\n949         \"\"\"Add a hidden field for the object's primary key.\"\"\"\n950         from django.db.models import AutoField, ForeignKey, OneToOneField\n951 \n952         self._pk_field = pk = self.model._meta.pk\n953         # If a pk isn't editable, then it won't be on the form, so we need to\n954         # add it here so we can tell which object is which when we get the\n955         # data back. Generally, pk.editable should be false, but for some\n956         # reason, auto_created pk fields and AutoField's editable attribute is\n957         # True, so check for that as well.\n958 \n959         def pk_is_not_editable(pk):\n960             return (\n961                 (not pk.editable)\n962                 or (pk.auto_created or isinstance(pk, AutoField))\n963                 or (\n964                     pk.remote_field\n965                     and pk.remote_field.parent_link\n966                     and pk_is_not_editable(pk.remote_field.model._meta.pk)\n967                 )\n968             )\n969 \n970         if pk_is_not_editable(pk) or pk.name not in form.fields:\n971             if form.is_bound:\n972                 # If we're adding the related instance, ignore its primary key\n973                 # as it could be an auto-generated default which isn't actually\n974                 # in the database.\n975                 pk_value = None if form.instance._state.adding else form.instance.pk\n976             else:\n977                 try:\n978                     if index is not None:\n979                         pk_value = self.get_queryset()[index].pk\n980                     else:\n981                         pk_value = None\n982                 except IndexError:\n983                     pk_value = None\n984             if isinstance(pk, (ForeignKey, OneToOneField)):\n985                 qs = pk.remote_field.model._default_manager.get_queryset()\n986             else:\n987                 qs = self.model._default_manager.get_queryset()\n988             qs = qs.using(form.instance._state.db)\n989             if form._meta.widgets:\n990                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)\n991             else:\n992                 widget = HiddenInput\n993             form.fields[self._pk_field.name] = ModelChoiceField(\n994                 qs, initial=pk_value, required=False, widget=widget\n995             )\n996         super().add_fields(form, index)\n997 \n998 \n999 def modelformset_factory(\n1000     model,\n1001     form=ModelForm,\n1002     formfield_callback=None,\n1003     formset=BaseModelFormSet,\n1004     extra=1,\n1005     can_delete=False,\n1006     can_order=False,\n1007     max_num=None,\n1008     fields=None,\n1009     exclude=None,\n1010     widgets=None,\n1011     validate_max=False,\n1012     localized_fields=None,\n1013     labels=None,\n1014     help_texts=None,\n1015     error_messages=None,\n1016     min_num=None,\n1017     validate_min=False,\n1018     field_classes=None,\n1019     absolute_max=None,\n1020     can_delete_extra=True,\n1021     renderer=None,\n1022     edit_only=False,\n1023 ):\n1024     \"\"\"Return a FormSet class for the given Django model class.\"\"\"\n1025     meta = getattr(form, \"Meta\", None)\n1026     if (\n1027         getattr(meta, \"fields\", fields) is None\n1028         and getattr(meta, \"exclude\", exclude) is None\n1029     ):\n1030         raise ImproperlyConfigured(\n1031             \"Calling modelformset_factory without defining 'fields' or \"\n1032             \"'exclude' explicitly is prohibited.\"\n1033         )\n1034 \n1035     form = modelform_factory(\n1036         model,\n1037         form=form,\n1038         fields=fields,\n1039         exclude=exclude,\n1040         formfield_callback=formfield_callback,\n1041         widgets=widgets,\n1042         localized_fields=localized_fields,\n1043         labels=labels,\n1044         help_texts=help_texts,\n1045         error_messages=error_messages,\n1046         field_classes=field_classes,\n1047     )\n1048     FormSet = formset_factory(\n1049         form,\n1050         formset,\n1051         extra=extra,\n1052         min_num=min_num,\n1053         max_num=max_num,\n1054         can_order=can_order,\n1055         can_delete=can_delete,\n1056         validate_min=validate_min,\n1057         validate_max=validate_max,\n1058         absolute_max=absolute_max,\n1059         can_delete_extra=can_delete_extra,\n1060         renderer=renderer,\n1061     )\n1062     FormSet.model = model\n1063     FormSet.edit_only = edit_only\n1064     return FormSet\n1065 \n1066 \n1067 # InlineFormSets #############################################################\n1068 \n1069 \n1070 class BaseInlineFormSet(BaseModelFormSet):\n1071     \"\"\"A formset for child objects related to a parent.\"\"\"\n1072 \n1073     def __init__(\n1074         self,\n1075         data=None,\n1076         files=None,\n1077         instance=None,\n1078         save_as_new=False,\n1079         prefix=None,\n1080         queryset=None,\n1081         **kwargs,\n1082     ):\n1083         if instance is None:\n1084             self.instance = self.fk.remote_field.model()\n1085         else:\n1086             self.instance = instance\n1087         self.save_as_new = save_as_new\n1088         if queryset is None:\n1089             queryset = self.model._default_manager\n1090         if self.instance.pk is not None:\n1091             qs = queryset.filter(**{self.fk.name: self.instance})\n1092         else:\n1093             qs = queryset.none()\n1094         self.unique_fields = {self.fk.name}\n1095         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n1096 \n1097         # Add the generated field to form._meta.fields if it's defined to make\n1098         # sure validation isn't skipped on that field.\n1099         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:\n1100             if isinstance(self.form._meta.fields, tuple):\n1101                 self.form._meta.fields = list(self.form._meta.fields)\n1102             self.form._meta.fields.append(self.fk.name)\n1103 \n1104     def initial_form_count(self):\n1105         if self.save_as_new:\n1106             return 0\n1107         return super().initial_form_count()\n1108 \n1109     def _construct_form(self, i, **kwargs):\n1110         form = super()._construct_form(i, **kwargs)\n1111         if self.save_as_new:\n1112             mutable = getattr(form.data, \"_mutable\", None)\n1113             # Allow modifying an immutable QueryDict.\n1114             if mutable is not None:\n1115                 form.data._mutable = True\n1116             # Remove the primary key from the form's data, we are only\n1117             # creating new instances\n1118             form.data[form.add_prefix(self._pk_field.name)] = None\n1119             # Remove the foreign key from the form's data\n1120             form.data[form.add_prefix(self.fk.name)] = None\n1121             if mutable is not None:\n1122                 form.data._mutable = mutable\n1123 \n1124         # Set the fk value here so that the form can do its validation.\n1125         fk_value = self.instance.pk\n1126         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n1127             fk_value = getattr(self.instance, self.fk.remote_field.field_name)\n1128             fk_value = getattr(fk_value, \"pk\", fk_value)\n1129         setattr(form.instance, self.fk.get_attname(), fk_value)\n1130         return form\n1131 \n1132     @classmethod\n1133     def get_default_prefix(cls):\n1134         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace(\"+\", \"\")\n1135 \n1136     def save_new(self, form, commit=True):\n1137         # Ensure the latest copy of the related instance is present on each\n1138         # form (it may have been saved after the formset was originally\n1139         # instantiated).\n1140         setattr(form.instance, self.fk.name, self.instance)\n1141         return super().save_new(form, commit=commit)\n1142 \n1143     def add_fields(self, form, index):\n1144         super().add_fields(form, index)\n1145         if self._pk_field == self.fk:\n1146             name = self._pk_field.name\n1147             kwargs = {\"pk_field\": True}\n1148         else:\n1149             # The foreign key field might not be on the form, so we poke at the\n1150             # Model field to get the label, since we need that for error messages.\n1151             name = self.fk.name\n1152             kwargs = {\n1153                 \"label\": getattr(\n1154                     form.fields.get(name), \"label\", capfirst(self.fk.verbose_name)\n1155                 )\n1156             }\n1157 \n1158         # The InlineForeignKeyField assumes that the foreign key relation is\n1159         # based on the parent model's pk. If this isn't the case, set to_field\n1160         # to correctly resolve the initial form value.\n1161         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n1162             kwargs[\"to_field\"] = self.fk.remote_field.field_name\n1163 \n1164         # If we're adding a new object, ignore a parent's auto-generated key\n1165         # as it will be regenerated on the save request.\n1166         if self.instance._state.adding:\n1167             if kwargs.get(\"to_field\") is not None:\n1168                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n1169             else:\n1170                 to_field = self.instance._meta.pk\n1171             if to_field.has_default():\n1172                 setattr(self.instance, to_field.attname, None)\n1173 \n1174         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n1175 \n1176     def get_unique_error_message(self, unique_check):\n1177         unique_check = [field for field in unique_check if field != self.fk.name]\n1178         return super().get_unique_error_message(unique_check)\n1179 \n1180 \n1181 def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\n1182     \"\"\"\n1183     Find and return the ForeignKey from model to parent if there is one\n1184     (return None if can_fail is True and no such field exists). If fk_name is\n1185     provided, assume it is the name of the ForeignKey field. Unless can_fail is\n1186     True, raise an exception if there isn't a ForeignKey from model to\n1187     parent_model.\n1188     \"\"\"\n1189     # avoid circular import\n1190     from django.db.models import ForeignKey\n1191 \n1192     opts = model._meta\n1193     if fk_name:\n1194         fks_to_parent = [f for f in opts.fields if f.name == fk_name]\n1195         if len(fks_to_parent) == 1:\n1196             fk = fks_to_parent[0]\n1197             parent_list = parent_model._meta.get_parent_list()\n1198             if (\n1199                 not isinstance(fk, ForeignKey)\n1200                 or (\n1201                     # ForeignKey to proxy models.\n1202                     fk.remote_field.model._meta.proxy\n1203                     and fk.remote_field.model._meta.proxy_for_model not in parent_list\n1204                 )\n1205                 or (\n1206                     # ForeignKey to concrete models.\n1207                     not fk.remote_field.model._meta.proxy\n1208                     and fk.remote_field.model != parent_model\n1209                     and fk.remote_field.model not in parent_list\n1210                 )\n1211             ):\n1212                 raise ValueError(\n1213                     \"fk_name '%s' is not a ForeignKey to '%s'.\"\n1214                     % (fk_name, parent_model._meta.label)\n1215                 )\n1216         elif not fks_to_parent:\n1217             raise ValueError(\n1218                 \"'%s' has no field named '%s'.\" % (model._meta.label, fk_name)\n1219             )\n1220     else:\n1221         # Try to discover what the ForeignKey from model to parent_model is\n1222         parent_list = parent_model._meta.get_parent_list()\n1223         fks_to_parent = [\n1224             f\n1225             for f in opts.fields\n1226             if isinstance(f, ForeignKey)\n1227             and (\n1228                 f.remote_field.model == parent_model\n1229                 or f.remote_field.model in parent_list\n1230                 or (\n1231                     f.remote_field.model._meta.proxy\n1232                     and f.remote_field.model._meta.proxy_for_model in parent_list\n1233                 )\n1234             )\n1235         ]\n1236         if len(fks_to_parent) == 1:\n1237             fk = fks_to_parent[0]\n1238         elif not fks_to_parent:\n1239             if can_fail:\n1240                 return\n1241             raise ValueError(\n1242                 \"'%s' has no ForeignKey to '%s'.\"\n1243                 % (\n1244                     model._meta.label,\n1245                     parent_model._meta.label,\n1246                 )\n1247             )\n1248         else:\n1249             raise ValueError(\n1250                 \"'%s' has more than one ForeignKey to '%s'. You must specify \"\n1251                 \"a 'fk_name' attribute.\"\n1252                 % (\n1253                     model._meta.label,\n1254                     parent_model._meta.label,\n1255                 )\n1256             )\n1257     return fk\n1258 \n1259 \n1260 def inlineformset_factory(\n1261     parent_model,\n1262     model,\n1263     form=ModelForm,\n1264     formset=BaseInlineFormSet,\n1265     fk_name=None,\n1266     fields=None,\n1267     exclude=None,\n1268     extra=3,\n1269     can_order=False,\n1270     can_delete=True,\n1271     max_num=None,\n1272     formfield_callback=None,\n1273     widgets=None,\n1274     validate_max=False,\n1275     localized_fields=None,\n1276     labels=None,\n1277     help_texts=None,\n1278     error_messages=None,\n1279     min_num=None,\n1280     validate_min=False,\n1281     field_classes=None,\n1282     absolute_max=None,\n1283     can_delete_extra=True,\n1284     renderer=None,\n1285     edit_only=False,\n1286 ):\n1287     \"\"\"\n1288     Return an ``InlineFormSet`` for the given kwargs.\n1289 \n1290     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``\n1291     to ``parent_model``.\n1292     \"\"\"\n1293     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)\n1294     # enforce a max_num=1 when the foreign key to the parent model is unique.\n1295     if fk.unique:\n1296         max_num = 1\n1297     kwargs = {\n1298         \"form\": form,\n1299         \"formfield_callback\": formfield_callback,\n1300         \"formset\": formset,\n1301         \"extra\": extra,\n1302         \"can_delete\": can_delete,\n1303         \"can_order\": can_order,\n1304         \"fields\": fields,\n1305         \"exclude\": exclude,\n1306         \"min_num\": min_num,\n1307         \"max_num\": max_num,\n1308         \"widgets\": widgets,\n1309         \"validate_min\": validate_min,\n1310         \"validate_max\": validate_max,\n1311         \"localized_fields\": localized_fields,\n1312         \"labels\": labels,\n1313         \"help_texts\": help_texts,\n1314         \"error_messages\": error_messages,\n1315         \"field_classes\": field_classes,\n1316         \"absolute_max\": absolute_max,\n1317         \"can_delete_extra\": can_delete_extra,\n1318         \"renderer\": renderer,\n1319         \"edit_only\": edit_only,\n1320     }\n1321     FormSet = modelformset_factory(model, **kwargs)\n1322     FormSet.fk = fk\n1323     return FormSet\n1324 \n1325 \n1326 # Fields #####################################################################\n1327 \n1328 \n1329 class InlineForeignKeyField(Field):\n1330     \"\"\"\n1331     A basic integer field that deals with validating the given value to a\n1332     given parent instance in an inline.\n1333     \"\"\"\n1334 \n1335     widget = HiddenInput\n1336     default_error_messages = {\n1337         \"invalid_choice\": _(\"The inline value did not match the parent instance.\"),\n1338     }\n1339 \n1340     def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):\n1341         self.parent_instance = parent_instance\n1342         self.pk_field = pk_field\n1343         self.to_field = to_field\n1344         if self.parent_instance is not None:\n1345             if self.to_field:\n1346                 kwargs[\"initial\"] = getattr(self.parent_instance, self.to_field)\n1347             else:\n1348                 kwargs[\"initial\"] = self.parent_instance.pk\n1349         kwargs[\"required\"] = False\n1350         super().__init__(*args, **kwargs)\n1351 \n1352     def clean(self, value):\n1353         if value in self.empty_values:\n1354             if self.pk_field:\n1355                 return None\n1356             # if there is no value act as we did before.\n1357             return self.parent_instance\n1358         # ensure the we compare the values as equal types.\n1359         if self.to_field:\n1360             orig = getattr(self.parent_instance, self.to_field)\n1361         else:\n1362             orig = self.parent_instance.pk\n1363         if str(value) != str(orig):\n1364             raise ValidationError(\n1365                 self.error_messages[\"invalid_choice\"], code=\"invalid_choice\"\n1366             )\n1367         return self.parent_instance\n1368 \n1369     def has_changed(self, initial, data):\n1370         return False\n1371 \n1372 \n1373 class ModelChoiceIteratorValue:\n1374     def __init__(self, value, instance):\n1375         self.value = value\n1376         self.instance = instance\n1377 \n1378     def __str__(self):\n1379         return str(self.value)\n1380 \n1381     def __hash__(self):\n1382         return hash(self.value)\n1383 \n1384     def __eq__(self, other):\n1385         if isinstance(other, ModelChoiceIteratorValue):\n1386             other = other.value\n1387         return self.value == other\n1388 \n1389 \n1390 class ModelChoiceIterator:\n1391     def __init__(self, field):\n1392         self.field = field\n1393         self.queryset = field.queryset\n1394 \n1395     def __iter__(self):\n1396         if self.field.empty_label is not None:\n1397             yield (\"\", self.field.empty_label)\n1398         queryset = self.queryset\n1399         # Can't use iterator() when queryset uses prefetch_related()\n1400         if not queryset._prefetch_related_lookups:\n1401             queryset = queryset.iterator()\n1402         for obj in queryset:\n1403             yield self.choice(obj)\n1404 \n1405     def __len__(self):\n1406         # count() adds a query but uses less memory since the QuerySet results\n1407         # won't be cached. In most cases, the choices will only be iterated on,\n1408         # and __len__() won't be called.\n1409         return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n1410 \n1411     def __bool__(self):\n1412         return self.field.empty_label is not None or self.queryset.exists()\n1413 \n1414     def choice(self, obj):\n1415         return (\n1416             ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),\n1417             self.field.label_from_instance(obj),\n1418         )\n1419 \n1420 \n1421 class ModelChoiceField(ChoiceField):\n1422     \"\"\"A ChoiceField whose choices are a model QuerySet.\"\"\"\n1423 \n1424     # This class is a subclass of ChoiceField for purity, but it doesn't\n1425     # actually use any of ChoiceField's implementation.\n1426     default_error_messages = {\n1427         \"invalid_choice\": _(\n1428             \"Select a valid choice. That choice is not one of the available choices.\"\n1429         ),\n1430     }\n1431     iterator = ModelChoiceIterator\n1432 \n1433     def __init__(\n1434         self,\n1435         queryset,\n1436         *,\n1437         empty_label=\"---------\",\n1438         required=True,\n1439         widget=None,\n1440         label=None,\n1441         initial=None,\n1442         help_text=\"\",\n1443         to_field_name=None,\n1444         limit_choices_to=None,\n1445         blank=False,\n1446         **kwargs,\n1447     ):\n1448         # Call Field instead of ChoiceField __init__() because we don't need\n1449         # ChoiceField.__init__().\n1450         Field.__init__(\n1451             self,\n1452             required=required,\n1453             widget=widget,\n1454             label=label,\n1455             initial=initial,\n1456             help_text=help_text,\n1457             **kwargs,\n1458         )\n1459         if (required and initial is not None) or (\n1460             isinstance(self.widget, RadioSelect) and not blank\n1461         ):\n1462             self.empty_label = None\n1463         else:\n1464             self.empty_label = empty_label\n1465         self.queryset = queryset\n1466         self.limit_choices_to = limit_choices_to  # limit the queryset later.\n1467         self.to_field_name = to_field_name\n1468 \n1469     def get_limit_choices_to(self):\n1470         \"\"\"\n1471         Return ``limit_choices_to`` for this form field.\n1472 \n1473         If it is a callable, invoke it and return the result.\n1474         \"\"\"\n1475         if callable(self.limit_choices_to):\n1476             return self.limit_choices_to()\n1477         return self.limit_choices_to\n1478 \n1479     def __deepcopy__(self, memo):\n1480         result = super(ChoiceField, self).__deepcopy__(memo)\n1481         # Need to force a new ModelChoiceIterator to be created, bug #11183\n1482         if self.queryset is not None:\n1483             result.queryset = self.queryset.all()\n1484         return result\n1485 \n1486     def _get_queryset(self):\n1487         return self._queryset\n1488 \n1489     def _set_queryset(self, queryset):\n1490         self._queryset = None if queryset is None else queryset.all()\n1491         self.widget.choices = self.choices\n1492 \n1493     queryset = property(_get_queryset, _set_queryset)\n1494 \n1495     # this method will be used to create object labels by the QuerySetIterator.\n1496     # Override it to customize the label.\n1497     def label_from_instance(self, obj):\n1498         \"\"\"\n1499         Convert objects into strings and generate the labels for the choices\n1500         presented by this object. Subclasses can override this method to\n1501         customize the display of the choices.\n1502         \"\"\"\n1503         return str(obj)\n1504 \n1505     def _get_choices(self):\n1506         # If self._choices is set, then somebody must have manually set\n1507         # the property self.choices. In this case, just return self._choices.\n1508         if hasattr(self, \"_choices\"):\n1509             return self._choices\n1510 \n1511         # Otherwise, execute the QuerySet in self.queryset to determine the\n1512         # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n1513         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n1514         # time _get_choices() is called (and, thus, each time self.choices is\n1515         # accessed) so that we can ensure the QuerySet has not been consumed. This\n1516         # construct might look complicated but it allows for lazy evaluation of\n1517         # the queryset.\n1518         return self.iterator(self)\n1519 \n1520     choices = property(_get_choices, ChoiceField._set_choices)\n1521 \n1522     def prepare_value(self, value):\n1523         if hasattr(value, \"_meta\"):\n1524             if self.to_field_name:\n1525                 return value.serializable_value(self.to_field_name)\n1526             else:\n1527                 return value.pk\n1528         return super().prepare_value(value)\n1529 \n1530     def to_python(self, value):\n1531         if value in self.empty_values:\n1532             return None\n1533         try:\n1534             key = self.to_field_name or \"pk\"\n1535             if isinstance(value, self.queryset.model):\n1536                 value = getattr(value, key)\n1537             value = self.queryset.get(**{key: value})\n1538         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n1539             raise ValidationError(\n1540                 self.error_messages[\"invalid_choice\"],\n1541                 code=\"invalid_choice\",\n1542                 params={\"value\": value},\n1543             )\n1544         return value\n1545 \n1546     def validate(self, value):\n1547         return Field.validate(self, value)\n1548 \n1549     def has_changed(self, initial, data):\n1550         if self.disabled:\n1551             return False\n1552         initial_value = initial if initial is not None else \"\"\n1553         data_value = data if data is not None else \"\"\n1554         return str(self.prepare_value(initial_value)) != str(data_value)\n1555 \n1556 \n1557 class ModelMultipleChoiceField(ModelChoiceField):\n1558     \"\"\"A MultipleChoiceField whose choices are a model QuerySet.\"\"\"\n1559 \n1560     widget = SelectMultiple\n1561     hidden_widget = MultipleHiddenInput\n1562     default_error_messages = {\n1563         \"invalid_list\": _(\"Enter a list of values.\"),\n1564         \"invalid_choice\": _(\n1565             \"Select a valid choice. %(value)s is not one of the available choices.\"\n1566         ),\n1567         \"invalid_pk_value\": _(\"\u201c%(pk)s\u201d is not a valid value.\"),\n1568     }\n1569 \n1570     def __init__(self, queryset, **kwargs):\n1571         super().__init__(queryset, empty_label=None, **kwargs)\n1572 \n1573     def to_python(self, value):\n1574         if not value:\n1575             return []\n1576         return list(self._check_values(value))\n1577 \n1578     def clean(self, value):\n1579         value = self.prepare_value(value)\n1580         if self.required and not value:\n1581             raise ValidationError(self.error_messages[\"required\"], code=\"required\")\n1582         elif not self.required and not value:\n1583             return self.queryset.none()\n1584         if not isinstance(value, (list, tuple)):\n1585             raise ValidationError(\n1586                 self.error_messages[\"invalid_list\"],\n1587                 code=\"invalid_list\",\n1588             )\n1589         qs = self._check_values(value)\n1590         # Since this overrides the inherited ModelChoiceField.clean\n1591         # we run custom validators here\n1592         self.run_validators(value)\n1593         return qs\n1594 \n1595     def _check_values(self, value):\n1596         \"\"\"\n1597         Given a list of possible PK values, return a QuerySet of the\n1598         corresponding objects. Raise a ValidationError if a given value is\n1599         invalid (not a valid PK, not in the queryset, etc.)\n1600         \"\"\"\n1601         key = self.to_field_name or \"pk\"\n1602         # deduplicate given values to avoid creating many querysets or\n1603         # requiring the database backend deduplicate efficiently.\n1604         try:\n1605             value = frozenset(value)\n1606         except TypeError:\n1607             # list of lists isn't hashable, for example\n1608             raise ValidationError(\n1609                 self.error_messages[\"invalid_list\"],\n1610                 code=\"invalid_list\",\n1611             )\n1612         for pk in value:\n1613             try:\n1614                 self.queryset.filter(**{key: pk})\n1615             except (ValueError, TypeError):\n1616                 raise ValidationError(\n1617                     self.error_messages[\"invalid_pk_value\"],\n1618                     code=\"invalid_pk_value\",\n1619                     params={\"pk\": pk},\n1620                 )\n1621         qs = self.queryset.filter(**{\"%s__in\" % key: value})\n1622         pks = {str(getattr(o, key)) for o in qs}\n1623         for val in value:\n1624             if str(val) not in pks:\n1625                 raise ValidationError(\n1626                     self.error_messages[\"invalid_choice\"],\n1627                     code=\"invalid_choice\",\n1628                     params={\"value\": val},\n1629                 )\n1630         return qs\n1631 \n1632     def prepare_value(self, value):\n1633         if (\n1634             hasattr(value, \"__iter__\")\n1635             and not isinstance(value, str)\n1636             and not hasattr(value, \"_meta\")\n1637         ):\n1638             prepare_value = super().prepare_value\n1639             return [prepare_value(v) for v in value]\n1640         return super().prepare_value(value)\n1641 \n1642     def has_changed(self, initial, data):\n1643         if self.disabled:\n1644             return False\n1645         if initial is None:\n1646             initial = []\n1647         if data is None:\n1648             data = []\n1649         if len(initial) != len(data):\n1650             return True\n1651         initial_set = {str(value) for value in self.prepare_value(initial)}\n1652         data_set = {str(value) for value in data}\n1653         return data_set != initial_set\n1654 \n1655 \n1656 def modelform_defines_fields(form_class):\n1657     return hasattr(form_class, \"_meta\") and (\n1658         form_class._meta.fields is not None or form_class._meta.exclude is not None\n1659     )\n",
        "intended_behavior": "This method should structure its query in such a way that any call to annotate() with Count() on liked_by or any other field correctly accounts for Django's requirements that subqueries return the appropriate number of columns. Specifically, ensure subqueries used in annotations target only the necessary fields to count or check existence, possibly utilizing Subquery objects with explicitly defined outputs."
    }
]