diff --git a/sympy/functions/elementary/integers.py b/sympy/functions/elementary/integers.py
--- a/sympy/functions/elementary/integers.py
+++ b/sympy/functions/elementary/integers.py
@@ -3,9 +3,11 @@
 from sympy.core import Add, S
 from sympy.core.evalf import get_integer_part, PrecisionExhausted
 from sympy.core.function import Function
+from sympy.core.logic import fuzzy_or
 from sympy.core.numbers import Integer
-from sympy.core.relational import Gt, Lt, Ge, Le
+from sympy.core.relational import Gt, Lt, Ge, Le, Relational
 from sympy.core.symbol import Symbol
+from sympy.core.sympify import _sympify
 
 
 ###############################################################################
@@ -155,6 +157,8 @@ def _eval_Eq(self, other):
     def __le__(self, other):
         if self.args[0] == other and other.is_real:
             return S.true
+        if other is S.Infinity and self.is_finite:
+            return S.true
         return Le(self, other, evaluate=False)
 
     def __gt__(self, other):
@@ -244,6 +248,8 @@ def __lt__(self, other):
     def __ge__(self, other):
         if self.args[0] == other and other.is_real:
             return S.true
+        if other is S.NegativeInfinity and self.is_real:
+            return S.true
         return Ge(self, other, evaluate=False)
 
 
@@ -309,7 +315,7 @@ def _eval(arg):
                 if arg is S.NaN:
                     return S.NaN
                 elif arg is S.ComplexInfinity:
-                    return None
+                    return S.NaN
                 else:
                     return arg - floor(arg)
             return cls(arg, evaluate=False)
@@ -343,3 +349,85 @@ def _eval_Eq(self, other):
             if (self.rewrite(floor) == other) or \
                     (self.rewrite(ceiling) == other):
                 return S.true
+            # Check if other < 0
+            if other.is_extended_negative:
+                return S.false
+            # Check if other >= 1
+            res = self._value_one_or_more(other)
+            if res is not None:
+                return S.false
+
+    def _eval_is_finite(self):
+        return True
+
+    def _eval_is_real(self):
+        return self.args[0].is_extended_real
+
+    def _eval_is_imaginary(self):
+        return self.args[0].is_imaginary
+
+    def _eval_is_integer(self):
+        return self.args[0].is_integer
+
+    def _eval_is_zero(self):
+        return fuzzy_or([self.args[0].is_zero, self.args[0].is_integer])
+
+    def _eval_is_negative(self):
+        return False
+
+    def __ge__(self, other):
+        if self.is_extended_real:
+            other = _sympify(other)
+            # Check if other <= 0
+            if other.is_extended_nonpositive:
+                return S.true
+            # Check if other >= 1
+            res = self._value_one_or_more(other)
+            if res is not None:
+                return not(res)
+        return Ge(self, other, evaluate=False)
+
+    def __gt__(self, other):
+        if self.is_extended_real:
+            other = _sympify(other)
+            # Check if other < 0
+            res = self._value_one_or_more(other)
+            if res is not None:
+                return not(res)
+            # Check if other >= 1
+            if other.is_extended_negative:
+                return S.true
+        return Gt(self, other, evaluate=False)
+
+    def __le__(self, other):
+        if self.is_extended_real:
+            other = _sympify(other)
+            # Check if other < 0
+            if other.is_extended_negative:
+                return S.false
+            # Check if other >= 1
+            res = self._value_one_or_more(other)
+            if res is not None:
+                return res
+        return Le(self, other, evaluate=False)
+
+    def __lt__(self, other):
+        if self.is_extended_real:
+            other = _sympify(other)
+            # Check if other <= 0
+            if other.is_extended_nonpositive:
+                return S.false
+            # Check if other >= 1
+            res = self._value_one_or_more(other)
+            if res is not None:
+                return res
+        return Lt(self, other, evaluate=False)
+
+    def _value_one_or_more(self, other):
+        if other.is_extended_real:
+            if other.is_number:
+                res = other >= 1
+                if res and not isinstance(res, Relational):
+                    return S.true
+            if other.is_integer and other.is_positive:
+                return S.true
diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py
--- a/sympy/printing/latex.py
+++ b/sympy/printing/latex.py
@@ -1733,6 +1733,13 @@ def _print_TensorIndex(self, expr):
     def _print_UniversalSet(self, expr):
         return r"\mathbb{U}"
 
+    def _print_frac(self, expr, exp=None):
+        if exp is None:
+            return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
+        else:
+            return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
+                    self._print(expr.args[0]), self._print(exp))
+
     def _print_tuple(self, expr):
         if self._settings['decimal_separator'] =='comma':
             return r"\left( %s\right)" % \
