2025-10-17 23:53:18.131 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 23:53:23.084 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=256, output_tokens=12, cost=0.002920
2025-10-17 23:53:23.092 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 23:53:23.096 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:53:33.685 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=559, output_tokens=436, cost=0.018670
2025-10-17 23:53:33.691 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:53:36.455 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=54, cost=0.009520
2025-10-17 23:53:36.455 | DEBUG    | Extracted a valid json.
2025-10-17 23:53:36.456 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"If you want to create a recursive relationship, use ForeignKey\")",
        "search_method(\"validate_through_fields\")",
        "search_code(\"symmetrical=False\")"
    ],
    "bug_locations": []
}
2025-10-17 23:53:36.495 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 23:53:36.496 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 23:53:48.335 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1443, output_tokens=586, cost=0.032010
2025-10-17 23:53:48.341 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:53:55.277 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2245, output_tokens=324, cost=0.032170
2025-10-17 23:53:55.281 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:54:03.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=678, output_tokens=323, cost=0.016470
2025-10-17 23:54:03.662 | DEBUG    | Extracted a valid json.
2025-10-17 23:54:03.662 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "ManyToManyField",
            "method": "_check_relationship_model",
            "intended_behavior": "The intended behavior at this location is to correct the guidance provided in the hint to developers configuring many-to-many relationships. This involves two main corrections:\n1. Updating the hint to correctly reference `ManyToManyField` instead of `ForeignKey`: The erroneous suggestion of using `ForeignKey` with parameters `symmetrical=False, through=\"%s\"` should be replaced with accurate instructions referring to configuring a `ManyToManyField` for recursive relationships. This means rephrasing the hint to guide users towards using `ManyToManyField` with the appropriate parameters for setting up such a relationship.\n2. Clarifying the relevance of `symmetrical=False`: Given that setting `symmetrical=False` is no longer required for recursive relationships with an intermediary model since Django 3.0, the hint should omit this outdated requirement. If it's considered necessary to mention it for users working with versions prior to Django 3.0, it should be clearly annotated as such, to avoid confusion for developers working with newer versions of Django.\n\nThe correction ensures that developers receive accurate and helpful guidance when configuring many-to-many relationships in Django, particularly in advanced scenarios involving recursive relationships and intermediary models. It retains the functionality of the `_check_relationship_model` method in validating the setup of `ManyToManyField` but with updated and correct information."
        }
    ]
}
2025-10-17 23:54:03.667 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>_check_relationship_model</method>
<code>
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors

</code><intended_behavior>The intended behavior at this location is to correct the guidance provided in the hint to developers configuring many-to-many relationships. This involves two main corrections:
1. Updating the hint to correctly reference `ManyToManyField` instead of `ForeignKey`: The erroneous suggestion of using `ForeignKey` with parameters `symmetrical=False, through="%s"` should be replaced with accurate instructions referring to configuring a `ManyToManyField` for recursive relationships. This means rephrasing the hint to guide users towards using `ManyToManyField` with the appropriate parameters for setting up such a relationship.
2. Clarifying the relevance of `symmetrical=False`: Given that setting `symmetrical=False` is no longer required for recursive relationships with an intermediary model since Django 3.0, the hint should omit this outdated requirement. If it's considered necessary to mention it for users working with versions prior to Django 3.0, it should be clearly annotated as such, to avoid confusion for developers working with newer versions of Django.

The correction ensures that developers receive accurate and helpful guidance when configuring many-to-many relationships in Django, particularly in advanced scenarios involving recursive relationships and intermediary models. It retains the functionality of the `_check_relationship_model` method in validating the setup of `ManyToManyField` but with updated and correct information.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = "%s.%s" % (
1483                 self.remote_field.model._meta.app_label,
1484                 self.remote_field.model._meta.object_name,
1485             )
1486         if getattr(self.remote_field, 'through', None) is not None:
1487             if isinstance(self.remote_field.through, str):
1488                 kwargs['through'] = self.remote_field.through
1489             elif not self.remote_field.through._meta.auto_created:
1490                 kwargs['through'] = "%s.%s" % (
1491                     self.remote_field.through._meta.app_label,
1492                     self.remote_field.through._meta.object_name,
1493                 )
1494         # If swappable is True, then see if we're actually pointing to the target
1495         # of a swap.
1496         swappable_setting = self.swappable_setting
1497         if swappable_setting is not None:
1498             # If it's already a settings reference, error.
1499             if hasattr(kwargs['to'], "setting_name"):
1500                 if kwargs['to'].setting_name != swappable_setting:
1501                     raise ValueError(
1502                         "Cannot deconstruct a ManyToManyField pointing to a "
1503                         "model that is swapped in place of more than one model "
1504                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1505                     )
1506 
1507             kwargs['to'] = SettingsReference(
1508                 kwargs['to'],
1509                 swappable_setting,
1510             )
1511         return name, path, args, kwargs
1512 
1513     def _get_path_info(self, direct=False, filtered_relation=None):
1514         """Called by both direct and indirect m2m traversal."""
1515         int_model = self.remote_field.through
1516         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1517         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1518         if direct:
1519             join1infos = linkfield1.get_reverse_path_info()
1520             join2infos = linkfield2.get_path_info(filtered_relation)
1521         else:
1522             join1infos = linkfield2.get_reverse_path_info()
1523             join2infos = linkfield1.get_path_info(filtered_relation)
1524 
1525         # Get join infos between the last model of join 1 and the first model
1526         # of join 2. Assume the only reason these may differ is due to model
1527         # inheritance.
1528         join1_final = join1infos[-1].to_opts
1529         join2_initial = join2infos[0].from_opts
1530         if join1_final is join2_initial:
1531             intermediate_infos = []
1532         elif issubclass(join1_final.model, join2_initial.model):
1533             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1534         else:
1535             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1536 
1537         return [*join1infos, *intermediate_infos, *join2infos]
1538 
1539     def get_path_info(self, filtered_relation=None):
1540         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1541 
1542     def get_reverse_path_info(self, filtered_relation=None):
1543         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1544 
1545     def _get_m2m_db_table(self, opts):
1546         """
1547         Function that can be curried to provide the m2m table name for this
1548         relation.
1549         """
1550         if self.remote_field.through is not None:
1551             return self.remote_field.through._meta.db_table
1552         elif self.db_table:
1553             return self.db_table
1554         else:
1555             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1556             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1557 
1558     def _get_m2m_attr(self, related, attr):
1559         """
1560         Function that can be curried to provide the source accessor or DB
1561         column name for the m2m table.
1562         """
1563         cache_attr = '_m2m_%s_cache' % attr
1564         if hasattr(self, cache_attr):
1565             return getattr(self, cache_attr)
1566         if self.remote_field.through_fields is not None:
1567             link_field_name = self.remote_field.through_fields[0]
1568         else:
1569             link_field_name = None
1570         for f in self.remote_field.through._meta.fields:
1571             if (f.is_relation and f.remote_field.model == related.related_model and
1572                     (link_field_name is None or link_field_name == f.name)):
1573                 setattr(self, cache_attr, getattr(f, attr))
1574                 return getattr(self, cache_attr)
1575 
1576     def _get_m2m_reverse_attr(self, related, attr):
1577         """
1578         Function that can be curried to provide the related accessor or DB
1579         column name for the m2m table.
1580         """
1581         cache_attr = '_m2m_reverse_%s_cache' % attr
1582         if hasattr(self, cache_attr):
1583             return getattr(self, cache_attr)
1584         found = False
1585         if self.remote_field.through_fields is not None:
1586             link_field_name = self.remote_field.through_fields[1]
1587         else:
1588             link_field_name = None
1589         for f in self.remote_field.through._meta.fields:
1590             if f.is_relation and f.remote_field.model == related.model:
1591                 if link_field_name is None and related.related_model == related.model:
1592                     # If this is an m2m-intermediate to self,
1593                     # the first foreign key you find will be
1594                     # the source column. Keep searching for
1595                     # the second foreign key.
1596                     if found:
1597                         setattr(self, cache_attr, getattr(f, attr))
1598                         break
1599                     else:
1600                         found = True
1601                 elif link_field_name is None or link_field_name == f.name:
1602                     setattr(self, cache_attr, getattr(f, attr))
1603                     break
1604         return getattr(self, cache_attr)
1605 
1606     def contribute_to_class(self, cls, name, **kwargs):
1607         # To support multiple relations to self, it's useful to have a non-None
1608         # related name on symmetrical relations for internal reasons. The
1609         # concept doesn't make a lot of sense externally ("you want me to
1610         # specify *what* on my non-reversible relation?!"), so we set it up
1611         # automatically. The funky name reduces the chance of an accidental
1612         # clash.
1613         if self.remote_field.symmetrical and (
1614             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1615             self.remote_field.model == cls._meta.object_name
1616         ):
1617             self.remote_field.related_name = "%s_rel_+" % name
1618         elif self.remote_field.is_hidden():
1619             # If the backwards relation is disabled, replace the original
1620             # related_name with one generated from the m2m field name. Django
1621             # still uses backwards relations internally and we need to avoid
1622             # clashes between multiple m2m fields with related_name == '+'.
1623             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1624 
1625         super().contribute_to_class(cls, name, **kwargs)
1626 
1627         # The intermediate m2m model is not auto created if:
1628         #  1) There is a manually specified intermediate, or
1629         #  2) The class owning the m2m field is abstract.
1630         #  3) The class owning the m2m field has been swapped out.
1631         if not cls._meta.abstract:
1632             if self.remote_field.through:
1633                 def resolve_through_model(_, model, field):
1634                     field.remote_field.through = model
1635                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1636             elif not cls._meta.swapped:
1637                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1638 
1639         # Add the descriptor for the m2m relation.
1640         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1641 
1642         # Set up the accessor for the m2m table name for the relation.
1643         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1644 
1645     def contribute_to_related_class(self, cls, related):
1646         # Internal M2Ms (i.e., those with a related name ending with '+')
1647         # and swapped models don't get a related descriptor.
1648         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1649             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1650 
1651         # Set up the accessors for the column names on the m2m table.
1652         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1653         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1654 
1655         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1656         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1657 
1658         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1659         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1660         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1661         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1662 
1663     def set_attributes_from_rel(self):
1664         pass
1665 
1666     def value_from_object(self, obj):
1667         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1668 
1669     def save_form_data(self, instance, data):
1670         getattr(instance, self.attname).set(data)
1671 
1672     def formfield(self, *, using=None, **kwargs):
1673         defaults = {
1674             'form_class': forms.ModelMultipleChoiceField,
1675             'queryset': self.remote_field.model._default_manager.using(using),
1676             **kwargs,
1677         }
1678         # If initial is passed in, it's a list of related objects, but the
1679         # MultipleChoiceField takes a list of IDs.
1680         if defaults.get('initial') is not None:
1681             initial = defaults['initial']
1682             if callable(initial):
1683                 initial = initial()
1684             defaults['initial'] = [i.pk for i in initial]
1685         return super().formfield(**defaults)
1686 
1687     def db_check(self, connection):
1688         return None
1689 
1690     def db_type(self, connection):
1691         # A ManyToManyField is not represented by a single column,
1692         # so return None.
1693         return None
1694 
1695     def db_parameters(self, connection):
1696         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 23:54:03.667 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>_check_relationship_model</method>
<code>
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors

</code><intended_behavior>The intended behavior at this location is to correct the guidance provided in the hint to developers configuring many-to-many relationships. This involves two main corrections:
1. Updating the hint to correctly reference `ManyToManyField` instead of `ForeignKey`: The erroneous suggestion of using `ForeignKey` with parameters `symmetrical=False, through="%s"` should be replaced with accurate instructions referring to configuring a `ManyToManyField` for recursive relationships. This means rephrasing the hint to guide users towards using `ManyToManyField` with the appropriate parameters for setting up such a relationship.
2. Clarifying the relevance of `symmetrical=False`: Given that setting `symmetrical=False` is no longer required for recursive relationships with an intermediary model since Django 3.0, the hint should omit this outdated requirement. If it's considered necessary to mention it for users working with versions prior to Django 3.0, it should be clearly annotated as such, to avoid confusion for developers working with newer versions of Django.

The correction ensures that developers receive accurate and helpful guidance when configuring many-to-many relationships in Django, particularly in advanced scenarios involving recursive relationships and intermediary models. It retains the functionality of the `_check_relationship_model` method in validating the setup of `ManyToManyField` but with updated and correct information.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ForeignKey("%s", symmetrical=False, through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = "%s.%s" % (
1483                 self.remote_field.model._meta.app_label,
1484                 self.remote_field.model._meta.object_name,
1485             )
1486         if getattr(self.remote_field, 'through', None) is not None:
1487             if isinstance(self.remote_field.through, str):
1488                 kwargs['through'] = self.remote_field.through
1489             elif not self.remote_field.through._meta.auto_created:
1490                 kwargs['through'] = "%s.%s" % (
1491                     self.remote_field.through._meta.app_label,
1492                     self.remote_field.through._meta.object_name,
1493                 )
1494         # If swappable is True, then see if we're actually pointing to the target
1495         # of a swap.
1496         swappable_setting = self.swappable_setting
1497         if swappable_setting is not None:
1498             # If it's already a settings reference, error.
1499             if hasattr(kwargs['to'], "setting_name"):
1500                 if kwargs['to'].setting_name != swappable_setting:
1501                     raise ValueError(
1502                         "Cannot deconstruct a ManyToManyField pointing to a "
1503                         "model that is swapped in place of more than one model "
1504                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1505                     )
1506 
1507             kwargs['to'] = SettingsReference(
1508                 kwargs['to'],
1509                 swappable_setting,
1510             )
1511         return name, path, args, kwargs
1512 
1513     def _get_path_info(self, direct=False, filtered_relation=None):
1514         """Called by both direct and indirect m2m traversal."""
1515         int_model = self.remote_field.through
1516         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1517         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1518         if direct:
1519             join1infos = linkfield1.get_reverse_path_info()
1520             join2infos = linkfield2.get_path_info(filtered_relation)
1521         else:
1522             join1infos = linkfield2.get_reverse_path_info()
1523             join2infos = linkfield1.get_path_info(filtered_relation)
1524 
1525         # Get join infos between the last model of join 1 and the first model
1526         # of join 2. Assume the only reason these may differ is due to model
1527         # inheritance.
1528         join1_final = join1infos[-1].to_opts
1529         join2_initial = join2infos[0].from_opts
1530         if join1_final is join2_initial:
1531             intermediate_infos = []
1532         elif issubclass(join1_final.model, join2_initial.model):
1533             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1534         else:
1535             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1536 
1537         return [*join1infos, *intermediate_infos, *join2infos]
1538 
1539     def get_path_info(self, filtered_relation=None):
1540         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1541 
1542     def get_reverse_path_info(self, filtered_relation=None):
1543         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1544 
1545     def _get_m2m_db_table(self, opts):
1546         """
1547         Function that can be curried to provide the m2m table name for this
1548         relation.
1549         """
1550         if self.remote_field.through is not None:
1551             return self.remote_field.through._meta.db_table
1552         elif self.db_table:
1553             return self.db_table
1554         else:
1555             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1556             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1557 
1558     def _get_m2m_attr(self, related, attr):
1559         """
1560         Function that can be curried to provide the source accessor or DB
1561         column name for the m2m table.
1562         """
1563         cache_attr = '_m2m_%s_cache' % attr
1564         if hasattr(self, cache_attr):
1565             return getattr(self, cache_attr)
1566         if self.remote_field.through_fields is not None:
1567             link_field_name = self.remote_field.through_fields[0]
1568         else:
1569             link_field_name = None
1570         for f in self.remote_field.through._meta.fields:
1571             if (f.is_relation and f.remote_field.model == related.related_model and
1572                     (link_field_name is None or link_field_name == f.name)):
1573                 setattr(self, cache_attr, getattr(f, attr))
1574                 return getattr(self, cache_attr)
1575 
1576     def _get_m2m_reverse_attr(self, related, attr):
1577         """
1578         Function that can be curried to provide the related accessor or DB
1579         column name for the m2m table.
1580         """
1581         cache_attr = '_m2m_reverse_%s_cache' % attr
1582         if hasattr(self, cache_attr):
1583             return getattr(self, cache_attr)
1584         found = False
1585         if self.remote_field.through_fields is not None:
1586             link_field_name = self.remote_field.through_fields[1]
1587         else:
1588             link_field_name = None
1589         for f in self.remote_field.through._meta.fields:
1590             if f.is_relation and f.remote_field.model == related.model:
1591                 if link_field_name is None and related.related_model == related.model:
1592                     # If this is an m2m-intermediate to self,
1593                     # the first foreign key you find will be
1594                     # the source column. Keep searching for
1595                     # the second foreign key.
1596                     if found:
1597                         setattr(self, cache_attr, getattr(f, attr))
1598                         break
1599                     else:
1600                         found = True
1601                 elif link_field_name is None or link_field_name == f.name:
1602                     setattr(self, cache_attr, getattr(f, attr))
1603                     break
1604         return getattr(self, cache_attr)
1605 
1606     def contribute_to_class(self, cls, name, **kwargs):
1607         # To support multiple relations to self, it's useful to have a non-None
1608         # related name on symmetrical relations for internal reasons. The
1609         # concept doesn't make a lot of sense externally ("you want me to
1610         # specify *what* on my non-reversible relation?!"), so we set it up
1611         # automatically. The funky name reduces the chance of an accidental
1612         # clash.
1613         if self.remote_field.symmetrical and (
1614             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1615             self.remote_field.model == cls._meta.object_name
1616         ):
1617             self.remote_field.related_name = "%s_rel_+" % name
1618         elif self.remote_field.is_hidden():
1619             # If the backwards relation is disabled, replace the original
1620             # related_name with one generated from the m2m field name. Django
1621             # still uses backwards relations internally and we need to avoid
1622             # clashes between multiple m2m fields with related_name == '+'.
1623             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1624 
1625         super().contribute_to_class(cls, name, **kwargs)
1626 
1627         # The intermediate m2m model is not auto created if:
1628         #  1) There is a manually specified intermediate, or
1629         #  2) The class owning the m2m field is abstract.
1630         #  3) The class owning the m2m field has been swapped out.
1631         if not cls._meta.abstract:
1632             if self.remote_field.through:
1633                 def resolve_through_model(_, model, field):
1634                     field.remote_field.through = model
1635                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1636             elif not cls._meta.swapped:
1637                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1638 
1639         # Add the descriptor for the m2m relation.
1640         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1641 
1642         # Set up the accessor for the m2m table name for the relation.
1643         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1644 
1645     def contribute_to_related_class(self, cls, related):
1646         # Internal M2Ms (i.e., those with a related name ending with '+')
1647         # and swapped models don't get a related descriptor.
1648         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1649             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1650 
1651         # Set up the accessors for the column names on the m2m table.
1652         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1653         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1654 
1655         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1656         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1657 
1658         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1659         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1660         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1661         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1662 
1663     def set_attributes_from_rel(self):
1664         pass
1665 
1666     def value_from_object(self, obj):
1667         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1668 
1669     def save_form_data(self, instance, data):
1670         getattr(instance, self.attname).set(data)
1671 
1672     def formfield(self, *, using=None, **kwargs):
1673         defaults = {
1674             'form_class': forms.ModelMultipleChoiceField,
1675             'queryset': self.remote_field.model._default_manager.using(using),
1676             **kwargs,
1677         }
1678         # If initial is passed in, it's a list of related objects, but the
1679         # MultipleChoiceField takes a list of IDs.
1680         if defaults.get('initial') is not None:
1681             initial = defaults['initial']
1682             if callable(initial):
1683                 initial = initial()
1684             defaults['initial'] = [i.pk for i in initial]
1685         return super().formfield(**defaults)
1686 
1687     def db_check(self, connection):
1688         return None
1689 
1690     def db_type(self, connection):
1691         # A ManyToManyField is not represented by a single column,
1692         # so return None.
1693         return None
1694 
1695     def db_parameters(self, connection):
1696         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 23:54:03.667 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 23:54:03.667 | INFO     | Search-only: skipping patch selection
2025-10-17 23:54:03.803 | INFO     | Task django__django-12497 completed successfully.
2025-10-17 23:54:03.804 | INFO     | No patch generated. You can try running ACR again.
