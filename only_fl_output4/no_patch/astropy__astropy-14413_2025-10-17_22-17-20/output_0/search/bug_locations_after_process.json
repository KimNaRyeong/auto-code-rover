[
    {
        "rel_file_path": "astropy/units/format/console.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.1/astropy/units/format/console.py",
        "start": 1,
        "end": 102,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 \"\"\"\n4 Handles the \"Console\" unit format.\n5 \"\"\"\n6 \n7 \n8 from . import base, core, utils\n9 \n10 \n11 class Console(base.Base):\n12     \"\"\"\n13     Output-only format for to display pretty formatting at the\n14     console.\n15 \n16     For example::\n17 \n18       >>> import astropy.units as u\n19       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP\n20       2.1798721*10^-18m^2 kg s^-2\n21       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP\n22                        m^2 kg\n23       2.1798721*10^-18 ------\n24                         s^2\n25     \"\"\"\n26 \n27     _times = \"*\"\n28     _line = \"-\"\n29 \n30     @classmethod\n31     def _get_unit_name(cls, unit):\n32         return unit.get_format_name(\"console\")\n33 \n34     @classmethod\n35     def _format_superscript(cls, number):\n36         return f\"^{number}\"\n37 \n38     @classmethod\n39     def _format_unit_list(cls, units):\n40         out = []\n41         for base_, power in units:\n42             if power == 1:\n43                 out.append(cls._get_unit_name(base_))\n44             else:\n45                 out.append(\n46                     cls._get_unit_name(base_)\n47                     + cls._format_superscript(utils.format_power(power))\n48                 )\n49         return \" \".join(out)\n50 \n51     @classmethod\n52     def format_exponential_notation(cls, val):\n53         m, ex = utils.split_mantissa_exponent(val)\n54 \n55         parts = []\n56         if m:\n57             parts.append(m)\n58 \n59         if ex:\n60             parts.append(f\"10{cls._format_superscript(ex)}\")\n61 \n62         return cls._times.join(parts)\n63 \n64     @classmethod\n65     def to_string(cls, unit, inline=True):\n66         if isinstance(unit, core.CompositeUnit):\n67             if unit.scale == 1:\n68                 s = \"\"\n69             else:\n70                 s = cls.format_exponential_notation(unit.scale)\n71 \n72             if len(unit.bases):\n73                 if inline:\n74                     nominator = zip(unit.bases, unit.powers)\n75                     denominator = []\n76                 else:\n77                     nominator, denominator = utils.get_grouped_by_powers(\n78                         unit.bases, unit.powers\n79                     )\n80                 if len(denominator):\n81                     if len(nominator):\n82                         nominator = cls._format_unit_list(nominator)\n83                     else:\n84                         nominator = \"1\"\n85                     denominator = cls._format_unit_list(denominator)\n86                     fraclength = max(len(nominator), len(denominator))\n87                     f = f\"{{0:^{len(s)}s}} {{1:^{fraclength}s}}\"\n88 \n89                     lines = [\n90                         f.format(\"\", nominator),\n91                         f.format(s, cls._line * fraclength),\n92                         f.format(\"\", denominator),\n93                     ]\n94 \n95                     s = \"\\n\".join(lines)\n96                 else:\n97                     nominator = cls._format_unit_list(nominator)\n98                     s += nominator\n99         elif isinstance(unit, core.NamedUnit):\n100             s = cls._get_unit_name(unit)\n101 \n102         return s\n",
        "intended_behavior": "The method responsible for formatting units in console format should ensure that it does not prepend a space to the unit string unless necessary for proper formatting. This behavior should be consistent, regardless of whether a unit scale factor is present or not. Adjustments might be needed to the logic that inserts spaces to only do so when part of the unit representation requires it, not as a default behavior for all unit strings."
    },
    {
        "rel_file_path": "astropy/units/core.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.1/astropy/units/core.py",
        "start": 1,
        "end": 2649,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 \"\"\"\n4 Core units classes and functions.\n5 \"\"\"\n6 \n7 \n8 import inspect\n9 import operator\n10 import textwrap\n11 import warnings\n12 \n13 import numpy as np\n14 \n15 from astropy.utils.decorators import lazyproperty\n16 from astropy.utils.exceptions import AstropyWarning\n17 from astropy.utils.misc import isiterable\n18 \n19 from . import format as unit_format\n20 from .utils import (\n21     is_effectively_unity,\n22     resolve_fractions,\n23     sanitize_scale,\n24     validate_power,\n25 )\n26 \n27 __all__ = [\n28     \"UnitsError\",\n29     \"UnitsWarning\",\n30     \"UnitConversionError\",\n31     \"UnitTypeError\",\n32     \"UnitBase\",\n33     \"NamedUnit\",\n34     \"IrreducibleUnit\",\n35     \"Unit\",\n36     \"CompositeUnit\",\n37     \"PrefixUnit\",\n38     \"UnrecognizedUnit\",\n39     \"def_unit\",\n40     \"get_current_unit_registry\",\n41     \"set_enabled_units\",\n42     \"add_enabled_units\",\n43     \"set_enabled_equivalencies\",\n44     \"add_enabled_equivalencies\",\n45     \"set_enabled_aliases\",\n46     \"add_enabled_aliases\",\n47     \"dimensionless_unscaled\",\n48     \"one\",\n49 ]\n50 \n51 UNITY = 1.0\n52 \n53 \n54 def _flatten_units_collection(items):\n55     \"\"\"\n56     Given a list of sequences, modules or dictionaries of units, or\n57     single units, return a flat set of all the units found.\n58     \"\"\"\n59     if not isinstance(items, list):\n60         items = [items]\n61 \n62     result = set()\n63     for item in items:\n64         if isinstance(item, UnitBase):\n65             result.add(item)\n66         else:\n67             if isinstance(item, dict):\n68                 units = item.values()\n69             elif inspect.ismodule(item):\n70                 units = vars(item).values()\n71             elif isiterable(item):\n72                 units = item\n73             else:\n74                 continue\n75 \n76             for unit in units:\n77                 if isinstance(unit, UnitBase):\n78                     result.add(unit)\n79 \n80     return result\n81 \n82 \n83 def _normalize_equivalencies(equivalencies):\n84     \"\"\"Normalizes equivalencies ensuring each is a 4-tuple.\n85 \n86     The resulting tuple is of the form::\n87 \n88         (from_unit, to_unit, forward_func, backward_func)\n89 \n90     Parameters\n91     ----------\n92     equivalencies : list of equivalency pairs\n93 \n94     Raises\n95     ------\n96     ValueError if an equivalency cannot be interpreted\n97     \"\"\"\n98     if equivalencies is None:\n99         return []\n100 \n101     normalized = []\n102 \n103     for i, equiv in enumerate(equivalencies):\n104         if len(equiv) == 2:\n105             funit, tunit = equiv\n106             a = b = lambda x: x\n107         elif len(equiv) == 3:\n108             funit, tunit, a = equiv\n109             b = a\n110         elif len(equiv) == 4:\n111             funit, tunit, a, b = equiv\n112         else:\n113             raise ValueError(f\"Invalid equivalence entry {i}: {equiv!r}\")\n114         if not (\n115             funit is Unit(funit)\n116             and (tunit is None or tunit is Unit(tunit))\n117             and callable(a)\n118             and callable(b)\n119         ):\n120             raise ValueError(f\"Invalid equivalence entry {i}: {equiv!r}\")\n121         normalized.append((funit, tunit, a, b))\n122 \n123     return normalized\n124 \n125 \n126 class _UnitRegistry:\n127     \"\"\"\n128     Manages a registry of the enabled units.\n129     \"\"\"\n130 \n131     def __init__(self, init=[], equivalencies=[], aliases={}):\n132         if isinstance(init, _UnitRegistry):\n133             # If passed another registry we don't need to rebuild everything.\n134             # but because these are mutable types we don't want to create\n135             # conflicts so everything needs to be copied.\n136             self._equivalencies = init._equivalencies.copy()\n137             self._aliases = init._aliases.copy()\n138             self._all_units = init._all_units.copy()\n139             self._registry = init._registry.copy()\n140             self._non_prefix_units = init._non_prefix_units.copy()\n141             # The physical type is a dictionary containing sets as values.\n142             # All of these must be copied otherwise we could alter the old\n143             # registry.\n144             self._by_physical_type = {\n145                 k: v.copy() for k, v in init._by_physical_type.items()\n146             }\n147 \n148         else:\n149             self._reset_units()\n150             self._reset_equivalencies()\n151             self._reset_aliases()\n152             self.add_enabled_units(init)\n153             self.add_enabled_equivalencies(equivalencies)\n154             self.add_enabled_aliases(aliases)\n155 \n156     def _reset_units(self):\n157         self._all_units = set()\n158         self._non_prefix_units = set()\n159         self._registry = {}\n160         self._by_physical_type = {}\n161 \n162     def _reset_equivalencies(self):\n163         self._equivalencies = set()\n164 \n165     def _reset_aliases(self):\n166         self._aliases = {}\n167 \n168     @property\n169     def registry(self):\n170         return self._registry\n171 \n172     @property\n173     def all_units(self):\n174         return self._all_units\n175 \n176     @property\n177     def non_prefix_units(self):\n178         return self._non_prefix_units\n179 \n180     def set_enabled_units(self, units):\n181         \"\"\"\n182         Sets the units enabled in the unit registry.\n183 \n184         These units are searched when using\n185         `UnitBase.find_equivalent_units`, for example.\n186 \n187         Parameters\n188         ----------\n189         units : list of sequence, dict, or module\n190             This is a list of things in which units may be found\n191             (sequences, dicts or modules), or units themselves.  The\n192             entire set will be \"enabled\" for searching through by\n193             methods like `UnitBase.find_equivalent_units` and\n194             `UnitBase.compose`.\n195         \"\"\"\n196         self._reset_units()\n197         return self.add_enabled_units(units)\n198 \n199     def add_enabled_units(self, units):\n200         \"\"\"\n201         Adds to the set of units enabled in the unit registry.\n202 \n203         These units are searched when using\n204         `UnitBase.find_equivalent_units`, for example.\n205 \n206         Parameters\n207         ----------\n208         units : list of sequence, dict, or module\n209             This is a list of things in which units may be found\n210             (sequences, dicts or modules), or units themselves.  The\n211             entire set will be added to the \"enabled\" set for\n212             searching through by methods like\n213             `UnitBase.find_equivalent_units` and `UnitBase.compose`.\n214         \"\"\"\n215         units = _flatten_units_collection(units)\n216 \n217         for unit in units:\n218             # Loop through all of the names first, to ensure all of them\n219             # are new, then add them all as a single \"transaction\" below.\n220             for st in unit._names:\n221                 if st in self._registry and unit != self._registry[st]:\n222                     raise ValueError(\n223                         f\"Object with name {st!r} already exists in namespace. \"\n224                         \"Filter the set of units to avoid name clashes before \"\n225                         \"enabling them.\"\n226                     )\n227 \n228             for st in unit._names:\n229                 self._registry[st] = unit\n230 \n231             self._all_units.add(unit)\n232             if not isinstance(unit, PrefixUnit):\n233                 self._non_prefix_units.add(unit)\n234 \n235             hash = unit._get_physical_type_id()\n236             self._by_physical_type.setdefault(hash, set()).add(unit)\n237 \n238     def get_units_with_physical_type(self, unit):\n239         \"\"\"\n240         Get all units in the registry with the same physical type as\n241         the given unit.\n242 \n243         Parameters\n244         ----------\n245         unit : UnitBase instance\n246         \"\"\"\n247         return self._by_physical_type.get(unit._get_physical_type_id(), set())\n248 \n249     @property\n250     def equivalencies(self):\n251         return list(self._equivalencies)\n252 \n253     def set_enabled_equivalencies(self, equivalencies):\n254         \"\"\"\n255         Sets the equivalencies enabled in the unit registry.\n256 \n257         These equivalencies are used if no explicit equivalencies are given,\n258         both in unit conversion and in finding equivalent units.\n259 \n260         This is meant in particular for allowing angles to be dimensionless.\n261         Use with care.\n262 \n263         Parameters\n264         ----------\n265         equivalencies : list of tuple\n266             List of equivalent pairs, e.g., as returned by\n267             `~astropy.units.equivalencies.dimensionless_angles`.\n268         \"\"\"\n269         self._reset_equivalencies()\n270         return self.add_enabled_equivalencies(equivalencies)\n271 \n272     def add_enabled_equivalencies(self, equivalencies):\n273         \"\"\"\n274         Adds to the set of equivalencies enabled in the unit registry.\n275 \n276         These equivalencies are used if no explicit equivalencies are given,\n277         both in unit conversion and in finding equivalent units.\n278 \n279         This is meant in particular for allowing angles to be dimensionless.\n280         Use with care.\n281 \n282         Parameters\n283         ----------\n284         equivalencies : list of tuple\n285             List of equivalent pairs, e.g., as returned by\n286             `~astropy.units.equivalencies.dimensionless_angles`.\n287         \"\"\"\n288         # pre-normalize list to help catch mistakes\n289         equivalencies = _normalize_equivalencies(equivalencies)\n290         self._equivalencies |= set(equivalencies)\n291 \n292     @property\n293     def aliases(self):\n294         return self._aliases\n295 \n296     def set_enabled_aliases(self, aliases):\n297         \"\"\"\n298         Set aliases for units.\n299 \n300         Parameters\n301         ----------\n302         aliases : dict of str, Unit\n303             The aliases to set. The keys must be the string aliases, and values\n304             must be the `astropy.units.Unit` that the alias will be mapped to.\n305 \n306         Raises\n307         ------\n308         ValueError\n309             If the alias already defines a different unit.\n310 \n311         \"\"\"\n312         self._reset_aliases()\n313         self.add_enabled_aliases(aliases)\n314 \n315     def add_enabled_aliases(self, aliases):\n316         \"\"\"\n317         Add aliases for units.\n318 \n319         Parameters\n320         ----------\n321         aliases : dict of str, Unit\n322             The aliases to add. The keys must be the string aliases, and values\n323             must be the `astropy.units.Unit` that the alias will be mapped to.\n324 \n325         Raises\n326         ------\n327         ValueError\n328             If the alias already defines a different unit.\n329 \n330         \"\"\"\n331         for alias, unit in aliases.items():\n332             if alias in self._registry and unit != self._registry[alias]:\n333                 raise ValueError(\n334                     f\"{alias} already means {self._registry[alias]}, so \"\n335                     f\"cannot be used as an alias for {unit}.\"\n336                 )\n337             if alias in self._aliases and unit != self._aliases[alias]:\n338                 raise ValueError(\n339                     f\"{alias} already is an alias for {self._aliases[alias]}, so \"\n340                     f\"cannot be used as an alias for {unit}.\"\n341                 )\n342 \n343         for alias, unit in aliases.items():\n344             if alias not in self._registry and alias not in self._aliases:\n345                 self._aliases[alias] = unit\n346 \n347 \n348 class _UnitContext:\n349     def __init__(self, init=[], equivalencies=[]):\n350         _unit_registries.append(_UnitRegistry(init=init, equivalencies=equivalencies))\n351 \n352     def __enter__(self):\n353         pass\n354 \n355     def __exit__(self, type, value, tb):\n356         _unit_registries.pop()\n357 \n358 \n359 _unit_registries = [_UnitRegistry()]\n360 \n361 \n362 def get_current_unit_registry():\n363     return _unit_registries[-1]\n364 \n365 \n366 def set_enabled_units(units):\n367     \"\"\"\n368     Sets the units enabled in the unit registry.\n369 \n370     These units are searched when using\n371     `UnitBase.find_equivalent_units`, for example.\n372 \n373     This may be used either permanently, or as a context manager using\n374     the ``with`` statement (see example below).\n375 \n376     Parameters\n377     ----------\n378     units : list of sequence, dict, or module\n379         This is a list of things in which units may be found\n380         (sequences, dicts or modules), or units themselves.  The\n381         entire set will be \"enabled\" for searching through by methods\n382         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.\n383 \n384     Examples\n385     --------\n386     >>> from astropy import units as u\n387     >>> with u.set_enabled_units([u.pc]):\n388     ...     u.m.find_equivalent_units()\n389     ...\n390       Primary name | Unit definition | Aliases\n391     [\n392       pc           | 3.08568e+16 m   | parsec  ,\n393     ]\n394     >>> u.m.find_equivalent_units()\n395       Primary name | Unit definition | Aliases\n396     [\n397       AU           | 1.49598e+11 m   | au, astronomical_unit            ,\n398       Angstrom     | 1e-10 m         | AA, angstrom                     ,\n399       cm           | 0.01 m          | centimeter                       ,\n400       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,\n401       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,\n402       lsec         | 2.99792e+08 m   | lightsecond                      ,\n403       lyr          | 9.46073e+15 m   | lightyear                        ,\n404       m            | irreducible     | meter                            ,\n405       micron       | 1e-06 m         |                                  ,\n406       pc           | 3.08568e+16 m   | parsec                           ,\n407       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,\n408     ]\n409     \"\"\"\n410     # get a context with a new registry, using equivalencies of the current one\n411     context = _UnitContext(equivalencies=get_current_unit_registry().equivalencies)\n412     # in this new current registry, enable the units requested\n413     get_current_unit_registry().set_enabled_units(units)\n414     return context\n415 \n416 \n417 def add_enabled_units(units):\n418     \"\"\"\n419     Adds to the set of units enabled in the unit registry.\n420 \n421     These units are searched when using\n422     `UnitBase.find_equivalent_units`, for example.\n423 \n424     This may be used either permanently, or as a context manager using\n425     the ``with`` statement (see example below).\n426 \n427     Parameters\n428     ----------\n429     units : list of sequence, dict, or module\n430         This is a list of things in which units may be found\n431         (sequences, dicts or modules), or units themselves.  The\n432         entire set will be added to the \"enabled\" set for searching\n433         through by methods like `UnitBase.find_equivalent_units` and\n434         `UnitBase.compose`.\n435 \n436     Examples\n437     --------\n438     >>> from astropy import units as u\n439     >>> from astropy.units import imperial\n440     >>> with u.add_enabled_units(imperial):\n441     ...     u.m.find_equivalent_units()\n442     ...\n443       Primary name | Unit definition | Aliases\n444     [\n445       AU           | 1.49598e+11 m   | au, astronomical_unit            ,\n446       Angstrom     | 1e-10 m         | AA, angstrom                     ,\n447       cm           | 0.01 m          | centimeter                       ,\n448       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,\n449       ft           | 0.3048 m        | foot                             ,\n450       fur          | 201.168 m       | furlong                          ,\n451       inch         | 0.0254 m        |                                  ,\n452       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,\n453       lsec         | 2.99792e+08 m   | lightsecond                      ,\n454       lyr          | 9.46073e+15 m   | lightyear                        ,\n455       m            | irreducible     | meter                            ,\n456       mi           | 1609.34 m       | mile                             ,\n457       micron       | 1e-06 m         |                                  ,\n458       mil          | 2.54e-05 m      | thou                             ,\n459       nmi          | 1852 m          | nauticalmile, NM                 ,\n460       pc           | 3.08568e+16 m   | parsec                           ,\n461       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,\n462       yd           | 0.9144 m        | yard                             ,\n463     ]\n464     \"\"\"\n465     # get a context with a new registry, which is a copy of the current one\n466     context = _UnitContext(get_current_unit_registry())\n467     # in this new current registry, enable the further units requested\n468     get_current_unit_registry().add_enabled_units(units)\n469     return context\n470 \n471 \n472 def set_enabled_equivalencies(equivalencies):\n473     \"\"\"\n474     Sets the equivalencies enabled in the unit registry.\n475 \n476     These equivalencies are used if no explicit equivalencies are given,\n477     both in unit conversion and in finding equivalent units.\n478 \n479     This is meant in particular for allowing angles to be dimensionless.\n480     Use with care.\n481 \n482     Parameters\n483     ----------\n484     equivalencies : list of tuple\n485         list of equivalent pairs, e.g., as returned by\n486         `~astropy.units.equivalencies.dimensionless_angles`.\n487 \n488     Examples\n489     --------\n490     Exponentiation normally requires dimensionless quantities.  To avoid\n491     problems with complex phases::\n492 \n493         >>> from astropy import units as u\n494         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):\n495         ...     phase = 0.5 * u.cycle\n496         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP\n497         <Quantity -1.+1.2246468e-16j>\n498     \"\"\"\n499     # get a context with a new registry, using all units of the current one\n500     context = _UnitContext(get_current_unit_registry())\n501     # in this new current registry, enable the equivalencies requested\n502     get_current_unit_registry().set_enabled_equivalencies(equivalencies)\n503     return context\n504 \n505 \n506 def add_enabled_equivalencies(equivalencies):\n507     \"\"\"\n508     Adds to the equivalencies enabled in the unit registry.\n509 \n510     These equivalencies are used if no explicit equivalencies are given,\n511     both in unit conversion and in finding equivalent units.\n512 \n513     This is meant in particular for allowing angles to be dimensionless.\n514     Since no equivalencies are enabled by default, generally it is recommended\n515     to use `set_enabled_equivalencies`.\n516 \n517     Parameters\n518     ----------\n519     equivalencies : list of tuple\n520         list of equivalent pairs, e.g., as returned by\n521         `~astropy.units.equivalencies.dimensionless_angles`.\n522     \"\"\"\n523     # get a context with a new registry, which is a copy of the current one\n524     context = _UnitContext(get_current_unit_registry())\n525     # in this new current registry, enable the further equivalencies requested\n526     get_current_unit_registry().add_enabled_equivalencies(equivalencies)\n527     return context\n528 \n529 \n530 def set_enabled_aliases(aliases):\n531     \"\"\"\n532     Set aliases for units.\n533 \n534     This is useful for handling alternate spellings for units, or\n535     misspelled units in files one is trying to read.\n536 \n537     Parameters\n538     ----------\n539     aliases : dict of str, Unit\n540         The aliases to set. The keys must be the string aliases, and values\n541         must be the `astropy.units.Unit` that the alias will be mapped to.\n542 \n543     Raises\n544     ------\n545     ValueError\n546         If the alias already defines a different unit.\n547 \n548     Examples\n549     --------\n550     To temporarily allow for a misspelled 'Angstroem' unit::\n551 \n552         >>> from astropy import units as u\n553         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):\n554         ...     print(u.Unit(\"Angstroem\", parse_strict=\"raise\") == u.Angstrom)\n555         True\n556 \n557     \"\"\"\n558     # get a context with a new registry, which is a copy of the current one\n559     context = _UnitContext(get_current_unit_registry())\n560     # in this new current registry, enable the further equivalencies requested\n561     get_current_unit_registry().set_enabled_aliases(aliases)\n562     return context\n563 \n564 \n565 def add_enabled_aliases(aliases):\n566     \"\"\"\n567     Add aliases for units.\n568 \n569     This is useful for handling alternate spellings for units, or\n570     misspelled units in files one is trying to read.\n571 \n572     Since no aliases are enabled by default, generally it is recommended\n573     to use `set_enabled_aliases`.\n574 \n575     Parameters\n576     ----------\n577     aliases : dict of str, Unit\n578         The aliases to add. The keys must be the string aliases, and values\n579         must be the `astropy.units.Unit` that the alias will be mapped to.\n580 \n581     Raises\n582     ------\n583     ValueError\n584         If the alias already defines a different unit.\n585 \n586     Examples\n587     --------\n588     To temporarily allow for a misspelled 'Angstroem' unit::\n589 \n590         >>> from astropy import units as u\n591         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):\n592         ...     print(u.Unit(\"Angstroem\", parse_strict=\"raise\") == u.Angstrom)\n593         True\n594 \n595     \"\"\"\n596     # get a context with a new registry, which is a copy of the current one\n597     context = _UnitContext(get_current_unit_registry())\n598     # in this new current registry, enable the further equivalencies requested\n599     get_current_unit_registry().add_enabled_aliases(aliases)\n600     return context\n601 \n602 \n603 class UnitsError(Exception):\n604     \"\"\"\n605     The base class for unit-specific exceptions.\n606     \"\"\"\n607 \n608 \n609 class UnitScaleError(UnitsError, ValueError):\n610     \"\"\"\n611     Used to catch the errors involving scaled units,\n612     which are not recognized by FITS format.\n613     \"\"\"\n614 \n615     pass\n616 \n617 \n618 class UnitConversionError(UnitsError, ValueError):\n619     \"\"\"\n620     Used specifically for errors related to converting between units or\n621     interpreting units in terms of other units.\n622     \"\"\"\n623 \n624 \n625 class UnitTypeError(UnitsError, TypeError):\n626     \"\"\"\n627     Used specifically for errors in setting to units not allowed by a class.\n628 \n629     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`\n630     instances were set to a non-angular unit.\n631     \"\"\"\n632 \n633 \n634 class UnitsWarning(AstropyWarning):\n635     \"\"\"\n636     The base class for unit-specific warnings.\n637     \"\"\"\n638 \n639 \n640 class UnitBase:\n641     \"\"\"\n642     Abstract base class for units.\n643 \n644     Most of the arithmetic operations on units are defined in this\n645     base class.\n646 \n647     Should not be instantiated by users directly.\n648     \"\"\"\n649 \n650     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy\n651     # arrays to avoid element-wise multiplication.\n652     __array_priority__ = 1000\n653 \n654     _hash = None\n655     _type_id = None\n656 \n657     def __deepcopy__(self, memo):\n658         # This may look odd, but the units conversion will be very\n659         # broken after deep-copying if we don't guarantee that a given\n660         # physical unit corresponds to only one instance\n661         return self\n662 \n663     def _repr_latex_(self):\n664         \"\"\"\n665         Generate latex representation of unit name.  This is used by\n666         the IPython notebook to print a unit with a nice layout.\n667 \n668         Returns\n669         -------\n670         Latex string\n671         \"\"\"\n672         return unit_format.Latex.to_string(self)\n673 \n674     def __bytes__(self):\n675         \"\"\"Return string representation for unit.\"\"\"\n676         return unit_format.Generic.to_string(self).encode(\"unicode_escape\")\n677 \n678     def __str__(self):\n679         \"\"\"Return string representation for unit.\"\"\"\n680         return unit_format.Generic.to_string(self)\n681 \n682     def __repr__(self):\n683         string = unit_format.Generic.to_string(self)\n684 \n685         return f'Unit(\"{string}\")'\n686 \n687     def _get_physical_type_id(self):\n688         \"\"\"\n689         Returns an identifier that uniquely identifies the physical\n690         type of this unit.  It is comprised of the bases and powers of\n691         this unit, without the scale.  Since it is hashable, it is\n692         useful as a dictionary key.\n693         \"\"\"\n694         if self._type_id is None:\n695             unit = self.decompose()\n696             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))\n697 \n698         return self._type_id\n699 \n700     @property\n701     def names(self):\n702         \"\"\"\n703         Returns all of the names associated with this unit.\n704         \"\"\"\n705         raise AttributeError(\n706             \"Can not get names from unnamed units. Perhaps you meant to_string()?\"\n707         )\n708 \n709     @property\n710     def name(self):\n711         \"\"\"\n712         Returns the canonical (short) name associated with this unit.\n713         \"\"\"\n714         raise AttributeError(\n715             \"Can not get names from unnamed units. Perhaps you meant to_string()?\"\n716         )\n717 \n718     @property\n719     def aliases(self):\n720         \"\"\"\n721         Returns the alias (long) names for this unit.\n722         \"\"\"\n723         raise AttributeError(\n724             \"Can not get aliases from unnamed units. Perhaps you meant to_string()?\"\n725         )\n726 \n727     @property\n728     def scale(self):\n729         \"\"\"\n730         Return the scale of the unit.\n731         \"\"\"\n732         return 1.0\n733 \n734     @property\n735     def bases(self):\n736         \"\"\"\n737         Return the bases of the unit.\n738         \"\"\"\n739         return [self]\n740 \n741     @property\n742     def powers(self):\n743         \"\"\"\n744         Return the powers of the unit.\n745         \"\"\"\n746         return [1]\n747 \n748     def to_string(self, format=unit_format.Generic, **kwargs):\n749         \"\"\"Output the unit in the given format as a string.\n750 \n751         Parameters\n752         ----------\n753         format : `astropy.units.format.Base` instance or str\n754             The name of a format or a formatter object.  If not\n755             provided, defaults to the generic format.\n756 \n757         **kwargs :\n758             Further options forwarded to the formatter. Currently\n759             recognized is **inline** (:class:`bool`) for the\n760             ``\"latex\"``, ``\"console\"``, and``\"unicode\"`` formats.\n761 \n762         \"\"\"\n763         f = unit_format.get_format(format)\n764         return f.to_string(self, **kwargs)\n765 \n766     def __format__(self, format_spec):\n767         \"\"\"Try to format units using a formatter.\"\"\"\n768         try:\n769             return self.to_string(format=format_spec)\n770         except ValueError:\n771             return format(str(self), format_spec)\n772 \n773     @staticmethod\n774     def _normalize_equivalencies(equivalencies):\n775         \"\"\"Normalizes equivalencies, ensuring each is a 4-tuple.\n776 \n777         The resulting tuple is of the form::\n778 \n779             (from_unit, to_unit, forward_func, backward_func)\n780 \n781         Parameters\n782         ----------\n783         equivalencies : list of equivalency pairs, or None\n784 \n785         Returns\n786         -------\n787         A normalized list, including possible global defaults set by, e.g.,\n788         `set_enabled_equivalencies`, except when `equivalencies`=`None`,\n789         in which case the returned list is always empty.\n790 \n791         Raises\n792         ------\n793         ValueError if an equivalency cannot be interpreted\n794         \"\"\"\n795         normalized = _normalize_equivalencies(equivalencies)\n796         if equivalencies is not None:\n797             normalized += get_current_unit_registry().equivalencies\n798 \n799         return normalized\n800 \n801     def __pow__(self, p):\n802         p = validate_power(p)\n803         return CompositeUnit(1, [self], [p], _error_check=False)\n804 \n805     def __truediv__(self, m):\n806         if isinstance(m, (bytes, str)):\n807             m = Unit(m)\n808 \n809         if isinstance(m, UnitBase):\n810             if m.is_unity():\n811                 return self\n812             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)\n813 \n814         try:\n815             # Cannot handle this as Unit, re-try as Quantity\n816             from .quantity import Quantity\n817 \n818             return Quantity(1, self) / m\n819         except TypeError:\n820             return NotImplemented\n821 \n822     def __rtruediv__(self, m):\n823         if isinstance(m, (bytes, str)):\n824             return Unit(m) / self\n825 \n826         try:\n827             # Cannot handle this as Unit.  Here, m cannot be a Quantity,\n828             # so we make it into one, fasttracking when it does not have a\n829             # unit, for the common case of <array> / <unit>.\n830             from .quantity import Quantity\n831 \n832             if hasattr(m, \"unit\"):\n833                 result = Quantity(m)\n834                 result /= self\n835                 return result\n836             else:\n837                 return Quantity(m, self ** (-1))\n838         except TypeError:\n839             return NotImplemented\n840 \n841     def __mul__(self, m):\n842         if isinstance(m, (bytes, str)):\n843             m = Unit(m)\n844 \n845         if isinstance(m, UnitBase):\n846             if m.is_unity():\n847                 return self\n848             elif self.is_unity():\n849                 return m\n850             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)\n851 \n852         # Cannot handle this as Unit, re-try as Quantity.\n853         try:\n854             from .quantity import Quantity\n855 \n856             return Quantity(1, unit=self) * m\n857         except TypeError:\n858             return NotImplemented\n859 \n860     def __rmul__(self, m):\n861         if isinstance(m, (bytes, str)):\n862             return Unit(m) * self\n863 \n864         # Cannot handle this as Unit.  Here, m cannot be a Quantity,\n865         # so we make it into one, fasttracking when it does not have a unit\n866         # for the common case of <array> * <unit>.\n867         try:\n868             from .quantity import Quantity\n869 \n870             if hasattr(m, \"unit\"):\n871                 result = Quantity(m)\n872                 result *= self\n873                 return result\n874             else:\n875                 return Quantity(m, unit=self)\n876         except TypeError:\n877             return NotImplemented\n878 \n879     def __rlshift__(self, m):\n880         try:\n881             from .quantity import Quantity\n882 \n883             return Quantity(m, self, copy=False, subok=True)\n884         except Exception:\n885             return NotImplemented\n886 \n887     def __rrshift__(self, m):\n888         warnings.warn(\n889             \">> is not implemented. Did you mean to convert \"\n890             f\"to a Quantity with unit {m} using '<<'?\",\n891             AstropyWarning,\n892         )\n893         return NotImplemented\n894 \n895     def __hash__(self):\n896         if self._hash is None:\n897             parts = (\n898                 [str(self.scale)]\n899                 + [x.name for x in self.bases]\n900                 + [str(x) for x in self.powers]\n901             )\n902             self._hash = hash(tuple(parts))\n903         return self._hash\n904 \n905     def __getstate__(self):\n906         # If we get pickled, we should *not* store the memoized members since\n907         # hashes of strings vary between sessions.\n908         state = self.__dict__.copy()\n909         state.pop(\"_hash\", None)\n910         state.pop(\"_type_id\", None)\n911         return state\n912 \n913     def __eq__(self, other):\n914         if self is other:\n915             return True\n916 \n917         try:\n918             other = Unit(other, parse_strict=\"silent\")\n919         except (ValueError, UnitsError, TypeError):\n920             return NotImplemented\n921 \n922         # Other is unit-like, but the test below requires it is a UnitBase\n923         # instance; if it is not, give up (so that other can try).\n924         if not isinstance(other, UnitBase):\n925             return NotImplemented\n926 \n927         try:\n928             return is_effectively_unity(self._to(other))\n929         except UnitsError:\n930             return False\n931 \n932     def __ne__(self, other):\n933         return not (self == other)\n934 \n935     def __le__(self, other):\n936         scale = self._to(Unit(other))\n937         return scale <= 1.0 or is_effectively_unity(scale)\n938 \n939     def __ge__(self, other):\n940         scale = self._to(Unit(other))\n941         return scale >= 1.0 or is_effectively_unity(scale)\n942 \n943     def __lt__(self, other):\n944         return not (self >= other)\n945 \n946     def __gt__(self, other):\n947         return not (self <= other)\n948 \n949     def __neg__(self):\n950         return self * -1.0\n951 \n952     def is_equivalent(self, other, equivalencies=[]):\n953         \"\"\"\n954         Returns `True` if this unit is equivalent to ``other``.\n955 \n956         Parameters\n957         ----------\n958         other : `~astropy.units.Unit`, str, or tuple\n959             The unit to convert to. If a tuple of units is specified, this\n960             method returns true if the unit matches any of those in the tuple.\n961 \n962         equivalencies : list of tuple\n963             A list of equivalence pairs to try if the units are not\n964             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n965             This list is in addition to possible global defaults set by, e.g.,\n966             `set_enabled_equivalencies`.\n967             Use `None` to turn off all equivalencies.\n968 \n969         Returns\n970         -------\n971         bool\n972         \"\"\"\n973         equivalencies = self._normalize_equivalencies(equivalencies)\n974 \n975         if isinstance(other, tuple):\n976             return any(self.is_equivalent(u, equivalencies) for u in other)\n977 \n978         other = Unit(other, parse_strict=\"silent\")\n979 \n980         return self._is_equivalent(other, equivalencies)\n981 \n982     def _is_equivalent(self, other, equivalencies=[]):\n983         \"\"\"Returns `True` if this unit is equivalent to `other`.\n984         See `is_equivalent`, except that a proper Unit object should be\n985         given (i.e., no string) and that the equivalency list should be\n986         normalized using `_normalize_equivalencies`.\n987         \"\"\"\n988         if isinstance(other, UnrecognizedUnit):\n989             return False\n990 \n991         if self._get_physical_type_id() == other._get_physical_type_id():\n992             return True\n993         elif len(equivalencies):\n994             unit = self.decompose()\n995             other = other.decompose()\n996             for a, b, forward, backward in equivalencies:\n997                 if b is None:\n998                     # after canceling, is what's left convertible\n999                     # to dimensionless (according to the equivalency)?\n1000                     try:\n1001                         (other / unit).decompose([a])\n1002                         return True\n1003                     except Exception:\n1004                         pass\n1005                 elif (a._is_equivalent(unit) and b._is_equivalent(other)) or (\n1006                     b._is_equivalent(unit) and a._is_equivalent(other)\n1007                 ):\n1008                     return True\n1009 \n1010         return False\n1011 \n1012     def _apply_equivalencies(self, unit, other, equivalencies):\n1013         \"\"\"\n1014         Internal function (used from `_get_converter`) to apply\n1015         equivalence pairs.\n1016         \"\"\"\n1017 \n1018         def make_converter(scale1, func, scale2):\n1019             def convert(v):\n1020                 return func(_condition_arg(v) / scale1) * scale2\n1021 \n1022             return convert\n1023 \n1024         for funit, tunit, a, b in equivalencies:\n1025             if tunit is None:\n1026                 ratio = other.decompose() / unit.decompose()\n1027                 try:\n1028                     ratio_in_funit = ratio.decompose([funit])\n1029                     return make_converter(ratio_in_funit.scale, a, 1.0)\n1030                 except UnitsError:\n1031                     pass\n1032             else:\n1033                 try:\n1034                     scale1 = funit._to(unit)\n1035                     scale2 = tunit._to(other)\n1036                     return make_converter(scale1, a, scale2)\n1037                 except UnitsError:\n1038                     pass\n1039                 try:\n1040                     scale1 = tunit._to(unit)\n1041                     scale2 = funit._to(other)\n1042                     return make_converter(scale1, b, scale2)\n1043                 except UnitsError:\n1044                     pass\n1045 \n1046         def get_err_str(unit):\n1047             unit_str = unit.to_string(\"unscaled\")\n1048             physical_type = unit.physical_type\n1049             if physical_type != \"unknown\":\n1050                 unit_str = f\"'{unit_str}' ({physical_type})\"\n1051             else:\n1052                 unit_str = f\"'{unit_str}'\"\n1053             return unit_str\n1054 \n1055         unit_str = get_err_str(unit)\n1056         other_str = get_err_str(other)\n1057 \n1058         raise UnitConversionError(f\"{unit_str} and {other_str} are not convertible\")\n1059 \n1060     def _get_converter(self, other, equivalencies=[]):\n1061         \"\"\"Get a converter for values in ``self`` to ``other``.\n1062 \n1063         If no conversion is necessary, returns ``unit_scale_converter``\n1064         (which is used as a check in quantity helpers).\n1065 \n1066         \"\"\"\n1067         # First see if it is just a scaling.\n1068         try:\n1069             scale = self._to(other)\n1070         except UnitsError:\n1071             pass\n1072         else:\n1073             if scale == 1.0:\n1074                 return unit_scale_converter\n1075             else:\n1076                 return lambda val: scale * _condition_arg(val)\n1077 \n1078         # if that doesn't work, maybe we can do it with equivalencies?\n1079         try:\n1080             return self._apply_equivalencies(\n1081                 self, other, self._normalize_equivalencies(equivalencies)\n1082             )\n1083         except UnitsError as exc:\n1084             # Last hope: maybe other knows how to do it?\n1085             # We assume the equivalencies have the unit itself as first item.\n1086             # TODO: maybe better for other to have a `_back_converter` method?\n1087             if hasattr(other, \"equivalencies\"):\n1088                 for funit, tunit, a, b in other.equivalencies:\n1089                     if other is funit:\n1090                         try:\n1091                             converter = self._get_converter(tunit, equivalencies)\n1092                         except Exception:\n1093                             pass\n1094                         else:\n1095                             return lambda v: b(converter(v))\n1096 \n1097             raise exc\n1098 \n1099     def _to(self, other):\n1100         \"\"\"\n1101         Returns the scale to the specified unit.\n1102 \n1103         See `to`, except that a Unit object should be given (i.e., no\n1104         string), and that all defaults are used, i.e., no\n1105         equivalencies and value=1.\n1106         \"\"\"\n1107         # There are many cases where we just want to ensure a Quantity is\n1108         # of a particular unit, without checking whether it's already in\n1109         # a particular unit.  If we're being asked to convert from a unit\n1110         # to itself, we can short-circuit all of this.\n1111         if self is other:\n1112             return 1.0\n1113 \n1114         # Don't presume decomposition is possible; e.g.,\n1115         # conversion to function units is through equivalencies.\n1116         if isinstance(other, UnitBase):\n1117             self_decomposed = self.decompose()\n1118             other_decomposed = other.decompose()\n1119 \n1120             # Check quickly whether equivalent.  This is faster than\n1121             # `is_equivalent`, because it doesn't generate the entire\n1122             # physical type list of both units.  In other words it \"fails\n1123             # fast\".\n1124             if self_decomposed.powers == other_decomposed.powers and all(\n1125                 self_base is other_base\n1126                 for (self_base, other_base) in zip(\n1127                     self_decomposed.bases, other_decomposed.bases\n1128                 )\n1129             ):\n1130                 return self_decomposed.scale / other_decomposed.scale\n1131 \n1132         raise UnitConversionError(f\"'{self!r}' is not a scaled version of '{other!r}'\")\n1133 \n1134     def to(self, other, value=UNITY, equivalencies=[]):\n1135         \"\"\"\n1136         Return the converted values in the specified unit.\n1137 \n1138         Parameters\n1139         ----------\n1140         other : unit-like\n1141             The unit to convert to.\n1142 \n1143         value : int, float, or scalar array-like, optional\n1144             Value(s) in the current unit to be converted to the\n1145             specified unit.  If not provided, defaults to 1.0\n1146 \n1147         equivalencies : list of tuple\n1148             A list of equivalence pairs to try if the units are not\n1149             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n1150             This list is in addition to possible global defaults set by, e.g.,\n1151             `set_enabled_equivalencies`.\n1152             Use `None` to turn off all equivalencies.\n1153 \n1154         Returns\n1155         -------\n1156         values : scalar or array\n1157             Converted value(s). Input value sequences are returned as\n1158             numpy arrays.\n1159 \n1160         Raises\n1161         ------\n1162         UnitsError\n1163             If units are inconsistent\n1164         \"\"\"\n1165         if other is self and value is UNITY:\n1166             return UNITY\n1167         else:\n1168             return self._get_converter(Unit(other), equivalencies)(value)\n1169 \n1170     def in_units(self, other, value=1.0, equivalencies=[]):\n1171         \"\"\"\n1172         Alias for `to` for backward compatibility with pynbody.\n1173         \"\"\"\n1174         return self.to(other, value=value, equivalencies=equivalencies)\n1175 \n1176     def decompose(self, bases=set()):\n1177         \"\"\"\n1178         Return a unit object composed of only irreducible units.\n1179 \n1180         Parameters\n1181         ----------\n1182         bases : sequence of UnitBase, optional\n1183             The bases to decompose into.  When not provided,\n1184             decomposes down to any irreducible units.  When provided,\n1185             the decomposed result will only contain the given units.\n1186             This will raises a `UnitsError` if it's not possible\n1187             to do so.\n1188 \n1189         Returns\n1190         -------\n1191         unit : `~astropy.units.CompositeUnit`\n1192             New object containing only irreducible unit objects.\n1193         \"\"\"\n1194         raise NotImplementedError()\n1195 \n1196     def _compose(\n1197         self, equivalencies=[], namespace=[], max_depth=2, depth=0, cached_results=None\n1198     ):\n1199         def is_final_result(unit):\n1200             # Returns True if this result contains only the expected\n1201             # units\n1202             return all(base in namespace for base in unit.bases)\n1203 \n1204         unit = self.decompose()\n1205         key = hash(unit)\n1206 \n1207         cached = cached_results.get(key)\n1208         if cached is not None:\n1209             if isinstance(cached, Exception):\n1210                 raise cached\n1211             return cached\n1212 \n1213         # Prevent too many levels of recursion\n1214         # And special case for dimensionless unit\n1215         if depth >= max_depth:\n1216             cached_results[key] = [unit]\n1217             return [unit]\n1218 \n1219         # Make a list including all of the equivalent units\n1220         units = [unit]\n1221         for funit, tunit, a, b in equivalencies:\n1222             if tunit is not None:\n1223                 if self._is_equivalent(funit):\n1224                     scale = funit.decompose().scale / unit.scale\n1225                     units.append(Unit(a(1.0 / scale) * tunit).decompose())\n1226                 elif self._is_equivalent(tunit):\n1227                     scale = tunit.decompose().scale / unit.scale\n1228                     units.append(Unit(b(1.0 / scale) * funit).decompose())\n1229             else:\n1230                 if self._is_equivalent(funit):\n1231                     units.append(Unit(unit.scale))\n1232 \n1233         # Store partial results\n1234         partial_results = []\n1235         # Store final results that reduce to a single unit or pair of\n1236         # units\n1237         if len(unit.bases) == 0:\n1238             final_results = [{unit}, set()]\n1239         else:\n1240             final_results = [set(), set()]\n1241 \n1242         for tunit in namespace:\n1243             tunit_decomposed = tunit.decompose()\n1244             for u in units:\n1245                 # If the unit is a base unit, look for an exact match\n1246                 # to one of the bases of the target unit.  If found,\n1247                 # factor by the same power as the target unit's base.\n1248                 # This allows us to factor out fractional powers\n1249                 # without needing to do an exhaustive search.\n1250                 if len(tunit_decomposed.bases) == 1:\n1251                     for base, power in zip(u.bases, u.powers):\n1252                         if tunit_decomposed._is_equivalent(base):\n1253                             tunit = tunit**power\n1254                             tunit_decomposed = tunit_decomposed**power\n1255                             break\n1256 \n1257                 composed = (u / tunit_decomposed).decompose()\n1258                 factored = composed * tunit\n1259                 len_bases = len(composed.bases)\n1260                 if is_final_result(factored) and len_bases <= 1:\n1261                     final_results[len_bases].add(factored)\n1262                 else:\n1263                     partial_results.append((len_bases, composed, tunit))\n1264 \n1265         # Do we have any minimal results?\n1266         for final_result in final_results:\n1267             if len(final_result):\n1268                 results = final_results[0].union(final_results[1])\n1269                 cached_results[key] = results\n1270                 return results\n1271 \n1272         partial_results.sort(key=operator.itemgetter(0))\n1273 \n1274         # ...we have to recurse and try to further compose\n1275         results = []\n1276         for len_bases, composed, tunit in partial_results:\n1277             try:\n1278                 composed_list = composed._compose(\n1279                     equivalencies=equivalencies,\n1280                     namespace=namespace,\n1281                     max_depth=max_depth,\n1282                     depth=depth + 1,\n1283                     cached_results=cached_results,\n1284                 )\n1285             except UnitsError:\n1286                 composed_list = []\n1287             for subcomposed in composed_list:\n1288                 results.append((len(subcomposed.bases), subcomposed, tunit))\n1289 \n1290         if len(results):\n1291             results.sort(key=operator.itemgetter(0))\n1292 \n1293             min_length = results[0][0]\n1294             subresults = set()\n1295             for len_bases, composed, tunit in results:\n1296                 if len_bases > min_length:\n1297                     break\n1298                 else:\n1299                     factored = composed * tunit\n1300                     if is_final_result(factored):\n1301                         subresults.add(factored)\n1302 \n1303             if len(subresults):\n1304                 cached_results[key] = subresults\n1305                 return subresults\n1306 \n1307         if not is_final_result(self):\n1308             result = UnitsError(\n1309                 f\"Cannot represent unit {self} in terms of the given units\"\n1310             )\n1311             cached_results[key] = result\n1312             raise result\n1313 \n1314         cached_results[key] = [self]\n1315         return [self]\n1316 \n1317     def compose(\n1318         self, equivalencies=[], units=None, max_depth=2, include_prefix_units=None\n1319     ):\n1320         \"\"\"\n1321         Return the simplest possible composite unit(s) that represent\n1322         the given unit.  Since there may be multiple equally simple\n1323         compositions of the unit, a list of units is always returned.\n1324 \n1325         Parameters\n1326         ----------\n1327         equivalencies : list of tuple\n1328             A list of equivalence pairs to also list.  See\n1329             :ref:`astropy:unit_equivalencies`.\n1330             This list is in addition to possible global defaults set by, e.g.,\n1331             `set_enabled_equivalencies`.\n1332             Use `None` to turn off all equivalencies.\n1333 \n1334         units : set of `~astropy.units.Unit`, optional\n1335             If not provided, any known units may be used to compose\n1336             into.  Otherwise, ``units`` is a dict, module or sequence\n1337             containing the units to compose into.\n1338 \n1339         max_depth : int, optional\n1340             The maximum recursion depth to use when composing into\n1341             composite units.\n1342 \n1343         include_prefix_units : bool, optional\n1344             When `True`, include prefixed units in the result.\n1345             Default is `True` if a sequence is passed in to ``units``,\n1346             `False` otherwise.\n1347 \n1348         Returns\n1349         -------\n1350         units : list of `CompositeUnit`\n1351             A list of candidate compositions.  These will all be\n1352             equally simple, but it may not be possible to\n1353             automatically determine which of the candidates are\n1354             better.\n1355         \"\"\"\n1356         # if units parameter is specified and is a sequence (list|tuple),\n1357         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]\n1358         if include_prefix_units is None:\n1359             include_prefix_units = isinstance(units, (list, tuple))\n1360 \n1361         # Pre-normalize the equivalencies list\n1362         equivalencies = self._normalize_equivalencies(equivalencies)\n1363 \n1364         # The namespace of units to compose into should be filtered to\n1365         # only include units with bases in common with self, otherwise\n1366         # they can't possibly provide useful results.  Having too many\n1367         # destination units greatly increases the search space.\n1368 \n1369         def has_bases_in_common(a, b):\n1370             if len(a.bases) == 0 and len(b.bases) == 0:\n1371                 return True\n1372             for ab in a.bases:\n1373                 for bb in b.bases:\n1374                     if ab == bb:\n1375                         return True\n1376             return False\n1377 \n1378         def has_bases_in_common_with_equiv(unit, other):\n1379             if has_bases_in_common(unit, other):\n1380                 return True\n1381             for funit, tunit, a, b in equivalencies:\n1382                 if tunit is not None:\n1383                     if unit._is_equivalent(funit):\n1384                         if has_bases_in_common(tunit.decompose(), other):\n1385                             return True\n1386                     elif unit._is_equivalent(tunit):\n1387                         if has_bases_in_common(funit.decompose(), other):\n1388                             return True\n1389                 else:\n1390                     if unit._is_equivalent(funit):\n1391                         if has_bases_in_common(dimensionless_unscaled, other):\n1392                             return True\n1393             return False\n1394 \n1395         def filter_units(units):\n1396             filtered_namespace = set()\n1397             for tunit in units:\n1398                 if (\n1399                     isinstance(tunit, UnitBase)\n1400                     and (include_prefix_units or not isinstance(tunit, PrefixUnit))\n1401                     and has_bases_in_common_with_equiv(decomposed, tunit.decompose())\n1402                 ):\n1403                     filtered_namespace.add(tunit)\n1404             return filtered_namespace\n1405 \n1406         decomposed = self.decompose()\n1407 \n1408         if units is None:\n1409             units = filter_units(self._get_units_with_same_physical_type(equivalencies))\n1410             if len(units) == 0:\n1411                 units = get_current_unit_registry().non_prefix_units\n1412         elif isinstance(units, dict):\n1413             units = set(filter_units(units.values()))\n1414         elif inspect.ismodule(units):\n1415             units = filter_units(vars(units).values())\n1416         else:\n1417             units = filter_units(_flatten_units_collection(units))\n1418 \n1419         def sort_results(results):\n1420             if not len(results):\n1421                 return []\n1422 \n1423             # Sort the results so the simplest ones appear first.\n1424             # Simplest is defined as \"the minimum sum of absolute\n1425             # powers\" (i.e. the fewest bases), and preference should\n1426             # be given to results where the sum of powers is positive\n1427             # and the scale is exactly equal to 1.0\n1428             results = list(results)\n1429             results.sort(key=lambda x: np.abs(x.scale))\n1430             results.sort(key=lambda x: np.sum(np.abs(x.powers)))\n1431             results.sort(key=lambda x: np.sum(x.powers) < 0.0)\n1432             results.sort(key=lambda x: not is_effectively_unity(x.scale))\n1433 \n1434             last_result = results[0]\n1435             filtered = [last_result]\n1436             for result in results[1:]:\n1437                 if str(result) != str(last_result):\n1438                     filtered.append(result)\n1439                 last_result = result\n1440 \n1441             return filtered\n1442 \n1443         return sort_results(\n1444             self._compose(\n1445                 equivalencies=equivalencies,\n1446                 namespace=units,\n1447                 max_depth=max_depth,\n1448                 depth=0,\n1449                 cached_results={},\n1450             )\n1451         )\n1452 \n1453     def to_system(self, system):\n1454         \"\"\"\n1455         Converts this unit into ones belonging to the given system.\n1456         Since more than one result may be possible, a list is always\n1457         returned.\n1458 \n1459         Parameters\n1460         ----------\n1461         system : module\n1462             The module that defines the unit system.  Commonly used\n1463             ones include `astropy.units.si` and `astropy.units.cgs`.\n1464 \n1465             To use your own module it must contain unit objects and a\n1466             sequence member named ``bases`` containing the base units of\n1467             the system.\n1468 \n1469         Returns\n1470         -------\n1471         units : list of `CompositeUnit`\n1472             The list is ranked so that units containing only the base\n1473             units of that system will appear first.\n1474         \"\"\"\n1475         bases = set(system.bases)\n1476 \n1477         def score(compose):\n1478             # In case that compose._bases has no elements we return\n1479             # 'np.inf' as 'score value'.  It does not really matter which\n1480             # number we would return. This case occurs for instance for\n1481             # dimensionless quantities:\n1482             compose_bases = compose.bases\n1483             if len(compose_bases) == 0:\n1484                 return np.inf\n1485             else:\n1486                 sum = 0\n1487                 for base in compose_bases:\n1488                     if base in bases:\n1489                         sum += 1\n1490 \n1491                 return sum / float(len(compose_bases))\n1492 \n1493         x = self.decompose(bases=bases)\n1494         composed = x.compose(units=system)\n1495         composed = sorted(composed, key=score, reverse=True)\n1496         return composed\n1497 \n1498     @lazyproperty\n1499     def si(self):\n1500         \"\"\"\n1501         Returns a copy of the current `Unit` instance in SI units.\n1502         \"\"\"\n1503         from . import si\n1504 \n1505         return self.to_system(si)[0]\n1506 \n1507     @lazyproperty\n1508     def cgs(self):\n1509         \"\"\"\n1510         Returns a copy of the current `Unit` instance with CGS units.\n1511         \"\"\"\n1512         from . import cgs\n1513 \n1514         return self.to_system(cgs)[0]\n1515 \n1516     @property\n1517     def physical_type(self):\n1518         \"\"\"\n1519         Physical type(s) dimensionally compatible with the unit.\n1520 \n1521         Returns\n1522         -------\n1523         `~astropy.units.physical.PhysicalType`\n1524             A representation of the physical type(s) of a unit.\n1525 \n1526         Examples\n1527         --------\n1528         >>> from astropy import units as u\n1529         >>> u.m.physical_type\n1530         PhysicalType('length')\n1531         >>> (u.m ** 2 / u.s).physical_type\n1532         PhysicalType({'diffusivity', 'kinematic viscosity'})\n1533 \n1534         Physical types can be compared to other physical types\n1535         (recommended in packages) or to strings.\n1536 \n1537         >>> area = (u.m ** 2).physical_type\n1538         >>> area == u.m.physical_type ** 2\n1539         True\n1540         >>> area == \"area\"\n1541         True\n1542 \n1543         `~astropy.units.physical.PhysicalType` objects can be used for\n1544         dimensional analysis.\n1545 \n1546         >>> number_density = u.m.physical_type ** -3\n1547         >>> velocity = (u.m / u.s).physical_type\n1548         >>> number_density * velocity\n1549         PhysicalType('particle flux')\n1550         \"\"\"\n1551         from . import physical\n1552 \n1553         return physical.get_physical_type(self)\n1554 \n1555     def _get_units_with_same_physical_type(self, equivalencies=[]):\n1556         \"\"\"\n1557         Return a list of registered units with the same physical type\n1558         as this unit.\n1559 \n1560         This function is used by Quantity to add its built-in\n1561         conversions to equivalent units.\n1562 \n1563         This is a private method, since end users should be encouraged\n1564         to use the more powerful `compose` and `find_equivalent_units`\n1565         methods (which use this under the hood).\n1566 \n1567         Parameters\n1568         ----------\n1569         equivalencies : list of tuple\n1570             A list of equivalence pairs to also pull options from.\n1571             See :ref:`astropy:unit_equivalencies`.  It must already be\n1572             normalized using `_normalize_equivalencies`.\n1573         \"\"\"\n1574         unit_registry = get_current_unit_registry()\n1575         units = set(unit_registry.get_units_with_physical_type(self))\n1576         for funit, tunit, a, b in equivalencies:\n1577             if tunit is not None:\n1578                 if self.is_equivalent(funit) and tunit not in units:\n1579                     units.update(unit_registry.get_units_with_physical_type(tunit))\n1580                 if self._is_equivalent(tunit) and funit not in units:\n1581                     units.update(unit_registry.get_units_with_physical_type(funit))\n1582             else:\n1583                 if self.is_equivalent(funit):\n1584                     units.add(dimensionless_unscaled)\n1585         return units\n1586 \n1587     class EquivalentUnitsList(list):\n1588         \"\"\"\n1589         A class to handle pretty-printing the result of\n1590         `find_equivalent_units`.\n1591         \"\"\"\n1592 \n1593         HEADING_NAMES = (\"Primary name\", \"Unit definition\", \"Aliases\")\n1594         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant\n1595         NO_EQUIV_UNITS_MSG = \"There are no equivalent units\"\n1596 \n1597         def __repr__(self):\n1598             if len(self) == 0:\n1599                 return self.NO_EQUIV_UNITS_MSG\n1600             else:\n1601                 lines = self._process_equivalent_units(self)\n1602                 lines.insert(0, self.HEADING_NAMES)\n1603                 widths = [0] * self.ROW_LEN\n1604                 for line in lines:\n1605                     for i, col in enumerate(line):\n1606                         widths[i] = max(widths[i], len(col))\n1607 \n1608                 f = \"  {{0:<{}s}} | {{1:<{}s}} | {{2:<{}s}}\".format(*widths)\n1609                 lines = [f.format(*line) for line in lines]\n1610                 lines = lines[0:1] + [\"[\"] + [f\"{x} ,\" for x in lines[1:]] + [\"]\"]\n1611                 return \"\\n\".join(lines)\n1612 \n1613         def _repr_html_(self):\n1614             \"\"\"\n1615             Outputs a HTML table representation within Jupyter notebooks.\n1616             \"\"\"\n1617             if len(self) == 0:\n1618                 return f\"<p>{self.NO_EQUIV_UNITS_MSG}</p>\"\n1619             else:\n1620                 # HTML tags to use to compose the table in HTML\n1621                 blank_table = '<table style=\"width:50%\">{}</table>'\n1622                 blank_row_container = \"<tr>{}</tr>\"\n1623                 heading_row_content = \"<th>{}</th>\" * self.ROW_LEN\n1624                 data_row_content = \"<td>{}</td>\" * self.ROW_LEN\n1625 \n1626                 # The HTML will be rendered & the table is simple, so don't\n1627                 # bother to include newlines & indentation for the HTML code.\n1628                 heading_row = blank_row_container.format(\n1629                     heading_row_content.format(*self.HEADING_NAMES)\n1630                 )\n1631                 data_rows = self._process_equivalent_units(self)\n1632                 all_rows = heading_row\n1633                 for row in data_rows:\n1634                     html_row = blank_row_container.format(data_row_content.format(*row))\n1635                     all_rows += html_row\n1636                 return blank_table.format(all_rows)\n1637 \n1638         @staticmethod\n1639         def _process_equivalent_units(equiv_units_data):\n1640             \"\"\"\n1641             Extract attributes, and sort, the equivalent units pre-formatting.\n1642             \"\"\"\n1643             processed_equiv_units = []\n1644             for u in equiv_units_data:\n1645                 irred = u.decompose().to_string()\n1646                 if irred == u.name:\n1647                     irred = \"irreducible\"\n1648                 processed_equiv_units.append((u.name, irred, \", \".join(u.aliases)))\n1649             processed_equiv_units.sort()\n1650             return processed_equiv_units\n1651 \n1652     def find_equivalent_units(\n1653         self, equivalencies=[], units=None, include_prefix_units=False\n1654     ):\n1655         \"\"\"\n1656         Return a list of all the units that are the same type as ``self``.\n1657 \n1658         Parameters\n1659         ----------\n1660         equivalencies : list of tuple\n1661             A list of equivalence pairs to also list.  See\n1662             :ref:`astropy:unit_equivalencies`.\n1663             Any list given, including an empty one, supersedes global defaults\n1664             that may be in effect (as set by `set_enabled_equivalencies`)\n1665 \n1666         units : set of `~astropy.units.Unit`, optional\n1667             If not provided, all defined units will be searched for\n1668             equivalencies.  Otherwise, may be a dict, module or\n1669             sequence containing the units to search for equivalencies.\n1670 \n1671         include_prefix_units : bool, optional\n1672             When `True`, include prefixed units in the result.\n1673             Default is `False`.\n1674 \n1675         Returns\n1676         -------\n1677         units : list of `UnitBase`\n1678             A list of unit objects that match ``u``.  A subclass of\n1679             `list` (``EquivalentUnitsList``) is returned that\n1680             pretty-prints the list of units when output.\n1681         \"\"\"\n1682         results = self.compose(\n1683             equivalencies=equivalencies,\n1684             units=units,\n1685             max_depth=1,\n1686             include_prefix_units=include_prefix_units,\n1687         )\n1688         results = {x.bases[0] for x in results if len(x.bases) == 1}\n1689         return self.EquivalentUnitsList(results)\n1690 \n1691     def is_unity(self):\n1692         \"\"\"\n1693         Returns `True` if the unit is unscaled and dimensionless.\n1694         \"\"\"\n1695         return False\n1696 \n1697 \n1698 class NamedUnit(UnitBase):\n1699     \"\"\"\n1700     The base class of units that have a name.\n1701 \n1702     Parameters\n1703     ----------\n1704     st : str, list of str, 2-tuple\n1705         The name of the unit.  If a list of strings, the first element\n1706         is the canonical (short) name, and the rest of the elements\n1707         are aliases.  If a tuple of lists, the first element is a list\n1708         of short names, and the second element is a list of long\n1709         names; all but the first short name are considered \"aliases\".\n1710         Each name *should* be a valid Python identifier to make it\n1711         easy to access, but this is not required.\n1712 \n1713     namespace : dict, optional\n1714         When provided, inject the unit, and all of its aliases, in the\n1715         given namespace dictionary.  If a unit by the same name is\n1716         already in the namespace, a ValueError is raised.\n1717 \n1718     doc : str, optional\n1719         A docstring describing the unit.\n1720 \n1721     format : dict, optional\n1722         A mapping to format-specific representations of this unit.\n1723         For example, for the ``Ohm`` unit, it might be nice to have it\n1724         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n1725         case, `format` argument should be set to::\n1726 \n1727             {'latex': r'\\\\Omega'}\n1728 \n1729     Raises\n1730     ------\n1731     ValueError\n1732         If any of the given unit names are already in the registry.\n1733 \n1734     ValueError\n1735         If any of the given unit names are not valid Python tokens.\n1736     \"\"\"\n1737 \n1738     def __init__(self, st, doc=None, format=None, namespace=None):\n1739         UnitBase.__init__(self)\n1740 \n1741         if isinstance(st, (bytes, str)):\n1742             self._names = [st]\n1743             self._short_names = [st]\n1744             self._long_names = []\n1745         elif isinstance(st, tuple):\n1746             if not len(st) == 2:\n1747                 raise ValueError(\"st must be string, list or 2-tuple\")\n1748             self._names = st[0] + [n for n in st[1] if n not in st[0]]\n1749             if not len(self._names):\n1750                 raise ValueError(\"must provide at least one name\")\n1751             self._short_names = st[0][:]\n1752             self._long_names = st[1][:]\n1753         else:\n1754             if len(st) == 0:\n1755                 raise ValueError(\"st list must have at least one entry\")\n1756             self._names = st[:]\n1757             self._short_names = [st[0]]\n1758             self._long_names = st[1:]\n1759 \n1760         if format is None:\n1761             format = {}\n1762         self._format = format\n1763 \n1764         if doc is None:\n1765             doc = self._generate_doc()\n1766         else:\n1767             doc = textwrap.dedent(doc)\n1768             doc = textwrap.fill(doc)\n1769 \n1770         self.__doc__ = doc\n1771 \n1772         self._inject(namespace)\n1773 \n1774     def _generate_doc(self):\n1775         \"\"\"\n1776         Generate a docstring for the unit if the user didn't supply\n1777         one.  This is only used from the constructor and may be\n1778         overridden in subclasses.\n1779         \"\"\"\n1780         names = self.names\n1781         if len(self.names) > 1:\n1782             return f\"{names[1]} ({names[0]})\"\n1783         else:\n1784             return names[0]\n1785 \n1786     def get_format_name(self, format):\n1787         \"\"\"\n1788         Get a name for this unit that is specific to a particular\n1789         format.\n1790 \n1791         Uses the dictionary passed into the `format` kwarg in the\n1792         constructor.\n1793 \n1794         Parameters\n1795         ----------\n1796         format : str\n1797             The name of the format\n1798 \n1799         Returns\n1800         -------\n1801         name : str\n1802             The name of the unit for the given format.\n1803         \"\"\"\n1804         return self._format.get(format, self.name)\n1805 \n1806     @property\n1807     def names(self):\n1808         \"\"\"\n1809         Returns all of the names associated with this unit.\n1810         \"\"\"\n1811         return self._names\n1812 \n1813     @property\n1814     def name(self):\n1815         \"\"\"\n1816         Returns the canonical (short) name associated with this unit.\n1817         \"\"\"\n1818         return self._names[0]\n1819 \n1820     @property\n1821     def aliases(self):\n1822         \"\"\"\n1823         Returns the alias (long) names for this unit.\n1824         \"\"\"\n1825         return self._names[1:]\n1826 \n1827     @property\n1828     def short_names(self):\n1829         \"\"\"\n1830         Returns all of the short names associated with this unit.\n1831         \"\"\"\n1832         return self._short_names\n1833 \n1834     @property\n1835     def long_names(self):\n1836         \"\"\"\n1837         Returns all of the long names associated with this unit.\n1838         \"\"\"\n1839         return self._long_names\n1840 \n1841     def _inject(self, namespace=None):\n1842         \"\"\"\n1843         Injects the unit, and all of its aliases, in the given\n1844         namespace dictionary.\n1845         \"\"\"\n1846         if namespace is None:\n1847             return\n1848 \n1849         # Loop through all of the names first, to ensure all of them\n1850         # are new, then add them all as a single \"transaction\" below.\n1851         for name in self._names:\n1852             if name in namespace and self != namespace[name]:\n1853                 raise ValueError(\n1854                     f\"Object with name {name!r} already exists in \"\n1855                     f\"given namespace ({namespace[name]!r}).\"\n1856                 )\n1857 \n1858         for name in self._names:\n1859             namespace[name] = self\n1860 \n1861 \n1862 def _recreate_irreducible_unit(cls, names, registered):\n1863     \"\"\"\n1864     This is used to reconstruct units when passed around by\n1865     multiprocessing.\n1866     \"\"\"\n1867     registry = get_current_unit_registry().registry\n1868     if names[0] in registry:\n1869         # If in local registry return that object.\n1870         return registry[names[0]]\n1871     else:\n1872         # otherwise, recreate the unit.\n1873         unit = cls(names)\n1874         if registered:\n1875             # If not in local registry but registered in origin registry,\n1876             # enable unit in local registry.\n1877             get_current_unit_registry().add_enabled_units([unit])\n1878 \n1879         return unit\n1880 \n1881 \n1882 class IrreducibleUnit(NamedUnit):\n1883     \"\"\"\n1884     Irreducible units are the units that all other units are defined\n1885     in terms of.\n1886 \n1887     Examples are meters, seconds, kilograms, amperes, etc.  There is\n1888     only once instance of such a unit per type.\n1889     \"\"\"\n1890 \n1891     def __reduce__(self):\n1892         # When IrreducibleUnit objects are passed to other processes\n1893         # over multiprocessing, they need to be recreated to be the\n1894         # ones already in the subprocesses' namespace, not new\n1895         # objects, or they will be considered \"unconvertible\".\n1896         # Therefore, we have a custom pickler/unpickler that\n1897         # understands how to recreate the Unit on the other side.\n1898         registry = get_current_unit_registry().registry\n1899         return (\n1900             _recreate_irreducible_unit,\n1901             (self.__class__, list(self.names), self.name in registry),\n1902             self.__getstate__(),\n1903         )\n1904 \n1905     @property\n1906     def represents(self):\n1907         \"\"\"The unit that this named unit represents.\n1908 \n1909         For an irreducible unit, that is always itself.\n1910         \"\"\"\n1911         return self\n1912 \n1913     def decompose(self, bases=set()):\n1914         if len(bases) and self not in bases:\n1915             for base in bases:\n1916                 try:\n1917                     scale = self._to(base)\n1918                 except UnitsError:\n1919                     pass\n1920                 else:\n1921                     if is_effectively_unity(scale):\n1922                         return base\n1923                     else:\n1924                         return CompositeUnit(scale, [base], [1], _error_check=False)\n1925 \n1926             raise UnitConversionError(\n1927                 f\"Unit {self} can not be decomposed into the requested bases\"\n1928             )\n1929 \n1930         return self\n1931 \n1932 \n1933 class UnrecognizedUnit(IrreducibleUnit):\n1934     \"\"\"\n1935     A unit that did not parse correctly.  This allows for\n1936     round-tripping it as a string, but no unit operations actually work\n1937     on it.\n1938 \n1939     Parameters\n1940     ----------\n1941     st : str\n1942         The name of the unit.\n1943     \"\"\"\n1944 \n1945     # For UnrecognizedUnits, we want to use \"standard\" Python\n1946     # pickling, not the special case that is used for\n1947     # IrreducibleUnits.\n1948     __reduce__ = object.__reduce__\n1949 \n1950     def __repr__(self):\n1951         return f\"UnrecognizedUnit({str(self)})\"\n1952 \n1953     def __bytes__(self):\n1954         return self.name.encode(\"ascii\", \"replace\")\n1955 \n1956     def __str__(self):\n1957         return self.name\n1958 \n1959     def to_string(self, format=None):\n1960         return self.name\n1961 \n1962     def _unrecognized_operator(self, *args, **kwargs):\n1963         raise ValueError(\n1964             f\"The unit {self.name!r} is unrecognized, so all arithmetic operations \"\n1965             \"with it are invalid.\"\n1966         )\n1967 \n1968     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = _unrecognized_operator\n1969     __lt__ = __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator\n1970 \n1971     def __eq__(self, other):\n1972         try:\n1973             other = Unit(other, parse_strict=\"silent\")\n1974         except (ValueError, UnitsError, TypeError):\n1975             return NotImplemented\n1976 \n1977         return isinstance(other, type(self)) and self.name == other.name\n1978 \n1979     def __ne__(self, other):\n1980         return not (self == other)\n1981 \n1982     def is_equivalent(self, other, equivalencies=None):\n1983         self._normalize_equivalencies(equivalencies)\n1984         return self == other\n1985 \n1986     def _get_converter(self, other, equivalencies=None):\n1987         self._normalize_equivalencies(equivalencies)\n1988         raise ValueError(\n1989             f\"The unit {self.name!r} is unrecognized.  It can not be converted \"\n1990             \"to other units.\"\n1991         )\n1992 \n1993     def get_format_name(self, format):\n1994         return self.name\n1995 \n1996     def is_unity(self):\n1997         return False\n1998 \n1999 \n2000 class _UnitMetaClass(type):\n2001     \"\"\"\n2002     This metaclass exists because the Unit constructor should\n2003     sometimes return instances that already exist.  This \"overrides\"\n2004     the constructor before the new instance is actually created, so we\n2005     can return an existing one.\n2006     \"\"\"\n2007 \n2008     def __call__(\n2009         self,\n2010         s=\"\",\n2011         represents=None,\n2012         format=None,\n2013         namespace=None,\n2014         doc=None,\n2015         parse_strict=\"raise\",\n2016     ):\n2017         # Short-circuit if we're already a unit\n2018         if hasattr(s, \"_get_physical_type_id\"):\n2019             return s\n2020 \n2021         # turn possible Quantity input for s or represents into a Unit\n2022         from .quantity import Quantity\n2023 \n2024         if isinstance(represents, Quantity):\n2025             if is_effectively_unity(represents.value):\n2026                 represents = represents.unit\n2027             else:\n2028                 represents = CompositeUnit(\n2029                     represents.value * represents.unit.scale,\n2030                     bases=represents.unit.bases,\n2031                     powers=represents.unit.powers,\n2032                     _error_check=False,\n2033                 )\n2034 \n2035         if isinstance(s, Quantity):\n2036             if is_effectively_unity(s.value):\n2037                 s = s.unit\n2038             else:\n2039                 s = CompositeUnit(\n2040                     s.value * s.unit.scale,\n2041                     bases=s.unit.bases,\n2042                     powers=s.unit.powers,\n2043                     _error_check=False,\n2044                 )\n2045 \n2046         # now decide what we really need to do; define derived Unit?\n2047         if isinstance(represents, UnitBase):\n2048             # This has the effect of calling the real __new__ and\n2049             # __init__ on the Unit class.\n2050             return super().__call__(\n2051                 s, represents, format=format, namespace=namespace, doc=doc\n2052             )\n2053 \n2054         # or interpret a Quantity (now became unit), string or number?\n2055         if isinstance(s, UnitBase):\n2056             return s\n2057 \n2058         elif isinstance(s, (bytes, str)):\n2059             if len(s.strip()) == 0:\n2060                 # Return the NULL unit\n2061                 return dimensionless_unscaled\n2062 \n2063             if format is None:\n2064                 format = unit_format.Generic\n2065 \n2066             f = unit_format.get_format(format)\n2067             if isinstance(s, bytes):\n2068                 s = s.decode(\"ascii\")\n2069 \n2070             try:\n2071                 return f.parse(s)\n2072             except NotImplementedError:\n2073                 raise\n2074             except Exception as e:\n2075                 if parse_strict == \"silent\":\n2076                     pass\n2077                 else:\n2078                     # Deliberately not issubclass here. Subclasses\n2079                     # should use their name.\n2080                     if f is not unit_format.Generic:\n2081                         format_clause = f.name + \" \"\n2082                     else:\n2083                         format_clause = \"\"\n2084                     msg = (\n2085                         f\"'{s}' did not parse as {format_clause}unit: {str(e)} \"\n2086                         \"If this is meant to be a custom unit, \"\n2087                         \"define it with 'u.def_unit'. To have it \"\n2088                         \"recognized inside a file reader or other code, \"\n2089                         \"enable it with 'u.add_enabled_units'. \"\n2090                         \"For details, see \"\n2091                         \"https://docs.astropy.org/en/latest/units/combining_and_defining.html\"\n2092                     )\n2093                     if parse_strict == \"raise\":\n2094                         raise ValueError(msg)\n2095                     elif parse_strict == \"warn\":\n2096                         warnings.warn(msg, UnitsWarning)\n2097                     else:\n2098                         raise ValueError(\n2099                             \"'parse_strict' must be 'warn', 'raise' or 'silent'\"\n2100                         )\n2101                 return UnrecognizedUnit(s)\n2102 \n2103         elif isinstance(s, (int, float, np.floating, np.integer)):\n2104             return CompositeUnit(s, [], [], _error_check=False)\n2105 \n2106         elif isinstance(s, tuple):\n2107             from .structured import StructuredUnit\n2108 \n2109             return StructuredUnit(s)\n2110 \n2111         elif s is None:\n2112             raise TypeError(\"None is not a valid Unit\")\n2113 \n2114         else:\n2115             raise TypeError(f\"{s} can not be converted to a Unit\")\n2116 \n2117 \n2118 class Unit(NamedUnit, metaclass=_UnitMetaClass):\n2119     \"\"\"\n2120     The main unit class.\n2121 \n2122     There are a number of different ways to construct a Unit, but\n2123     always returns a `UnitBase` instance.  If the arguments refer to\n2124     an already-existing unit, that existing unit instance is returned,\n2125     rather than a new one.\n2126 \n2127     - From a string::\n2128 \n2129         Unit(s, format=None, parse_strict='silent')\n2130 \n2131       Construct from a string representing a (possibly compound) unit.\n2132 \n2133       The optional `format` keyword argument specifies the format the\n2134       string is in, by default ``\"generic\"``.  For a description of\n2135       the available formats, see `astropy.units.format`.\n2136 \n2137       The optional ``parse_strict`` keyword controls what happens when an\n2138       unrecognized unit string is passed in.  It may be one of the following:\n2139 \n2140          - ``'raise'``: (default) raise a ValueError exception.\n2141 \n2142          - ``'warn'``: emit a Warning, and return an\n2143            `UnrecognizedUnit` instance.\n2144 \n2145          - ``'silent'``: return an `UnrecognizedUnit` instance.\n2146 \n2147     - From a number::\n2148 \n2149         Unit(number)\n2150 \n2151       Creates a dimensionless unit.\n2152 \n2153     - From a `UnitBase` instance::\n2154 \n2155         Unit(unit)\n2156 \n2157       Returns the given unit unchanged.\n2158 \n2159     - From no arguments::\n2160 \n2161         Unit()\n2162 \n2163       Returns the dimensionless unit.\n2164 \n2165     - The last form, which creates a new `Unit` is described in detail\n2166       below.\n2167 \n2168     See also: https://docs.astropy.org/en/stable/units/\n2169 \n2170     Parameters\n2171     ----------\n2172     st : str or list of str\n2173         The name of the unit.  If a list, the first element is the\n2174         canonical (short) name, and the rest of the elements are\n2175         aliases.\n2176 \n2177     represents : UnitBase instance\n2178         The unit that this named unit represents.\n2179 \n2180     doc : str, optional\n2181         A docstring describing the unit.\n2182 \n2183     format : dict, optional\n2184         A mapping to format-specific representations of this unit.\n2185         For example, for the ``Ohm`` unit, it might be nice to have it\n2186         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n2187         case, `format` argument should be set to::\n2188 \n2189             {'latex': r'\\\\Omega'}\n2190 \n2191     namespace : dict, optional\n2192         When provided, inject the unit (and all of its aliases) into\n2193         the given namespace.\n2194 \n2195     Raises\n2196     ------\n2197     ValueError\n2198         If any of the given unit names are already in the registry.\n2199 \n2200     ValueError\n2201         If any of the given unit names are not valid Python tokens.\n2202     \"\"\"\n2203 \n2204     def __init__(self, st, represents=None, doc=None, format=None, namespace=None):\n2205         represents = Unit(represents)\n2206         self._represents = represents\n2207 \n2208         NamedUnit.__init__(self, st, namespace=namespace, doc=doc, format=format)\n2209 \n2210     @property\n2211     def represents(self):\n2212         \"\"\"The unit that this named unit represents.\"\"\"\n2213         return self._represents\n2214 \n2215     def decompose(self, bases=set()):\n2216         return self._represents.decompose(bases=bases)\n2217 \n2218     def is_unity(self):\n2219         return self._represents.is_unity()\n2220 \n2221     def __hash__(self):\n2222         if self._hash is None:\n2223             self._hash = hash((self.name, self._represents))\n2224         return self._hash\n2225 \n2226     @classmethod\n2227     def _from_physical_type_id(cls, physical_type_id):\n2228         # get string bases and powers from the ID tuple\n2229         bases = [cls(base) for base, _ in physical_type_id]\n2230         powers = [power for _, power in physical_type_id]\n2231 \n2232         if len(physical_type_id) == 1 and powers[0] == 1:\n2233             unit = bases[0]\n2234         else:\n2235             unit = CompositeUnit(1, bases, powers, _error_check=False)\n2236 \n2237         return unit\n2238 \n2239 \n2240 class PrefixUnit(Unit):\n2241     \"\"\"\n2242     A unit that is simply a SI-prefixed version of another unit.\n2243 \n2244     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.\n2245 \n2246     The constructor is the same as for `Unit`.\n2247     \"\"\"\n2248 \n2249 \n2250 class CompositeUnit(UnitBase):\n2251     \"\"\"\n2252     Create a composite unit using expressions of previously defined\n2253     units.\n2254 \n2255     Direct use of this class is not recommended. Instead use the\n2256     factory function `Unit` and arithmetic operators to compose\n2257     units.\n2258 \n2259     Parameters\n2260     ----------\n2261     scale : number\n2262         A scaling factor for the unit.\n2263 \n2264     bases : sequence of `UnitBase`\n2265         A sequence of units this unit is composed of.\n2266 \n2267     powers : sequence of numbers\n2268         A sequence of powers (in parallel with ``bases``) for each\n2269         of the base units.\n2270     \"\"\"\n2271 \n2272     _decomposed_cache = None\n2273 \n2274     def __init__(\n2275         self,\n2276         scale,\n2277         bases,\n2278         powers,\n2279         decompose=False,\n2280         decompose_bases=set(),\n2281         _error_check=True,\n2282     ):\n2283         # There are many cases internal to astropy.units where we\n2284         # already know that all the bases are Unit objects, and the\n2285         # powers have been validated.  In those cases, we can skip the\n2286         # error checking for performance reasons.  When the private\n2287         # kwarg `_error_check` is False, the error checking is turned\n2288         # off.\n2289         if _error_check:\n2290             for base in bases:\n2291                 if not isinstance(base, UnitBase):\n2292                     raise TypeError(\"bases must be sequence of UnitBase instances\")\n2293             powers = [validate_power(p) for p in powers]\n2294 \n2295         if not decompose and len(bases) == 1 and powers[0] >= 0:\n2296             # Short-cut; with one unit there's nothing to expand and gather,\n2297             # as that has happened already when creating the unit.  But do only\n2298             # positive powers, since for negative powers we need to re-sort.\n2299             unit = bases[0]\n2300             power = powers[0]\n2301             if power == 1:\n2302                 scale *= unit.scale\n2303                 self._bases = unit.bases\n2304                 self._powers = unit.powers\n2305             elif power == 0:\n2306                 self._bases = []\n2307                 self._powers = []\n2308             else:\n2309                 scale *= unit.scale**power\n2310                 self._bases = unit.bases\n2311                 self._powers = [\n2312                     operator.mul(*resolve_fractions(p, power)) for p in unit.powers\n2313                 ]\n2314 \n2315             self._scale = sanitize_scale(scale)\n2316         else:\n2317             # Regular case: use inputs as preliminary scale, bases, and powers,\n2318             # then \"expand and gather\" identical bases, sanitize the scale, &c.\n2319             self._scale = scale\n2320             self._bases = bases\n2321             self._powers = powers\n2322             self._expand_and_gather(decompose=decompose, bases=decompose_bases)\n2323 \n2324     def __repr__(self):\n2325         if len(self._bases):\n2326             return super().__repr__()\n2327         else:\n2328             if self._scale != 1.0:\n2329                 return f\"Unit(dimensionless with a scale of {self._scale})\"\n2330             else:\n2331                 return \"Unit(dimensionless)\"\n2332 \n2333     @property\n2334     def scale(self):\n2335         \"\"\"\n2336         Return the scale of the composite unit.\n2337         \"\"\"\n2338         return self._scale\n2339 \n2340     @property\n2341     def bases(self):\n2342         \"\"\"\n2343         Return the bases of the composite unit.\n2344         \"\"\"\n2345         return self._bases\n2346 \n2347     @property\n2348     def powers(self):\n2349         \"\"\"\n2350         Return the powers of the composite unit.\n2351         \"\"\"\n2352         return self._powers\n2353 \n2354     def _expand_and_gather(self, decompose=False, bases=set()):\n2355         def add_unit(unit, power, scale):\n2356             if bases and unit not in bases:\n2357                 for base in bases:\n2358                     try:\n2359                         scale *= unit._to(base) ** power\n2360                     except UnitsError:\n2361                         pass\n2362                     else:\n2363                         unit = base\n2364                         break\n2365 \n2366             if unit in new_parts:\n2367                 a, b = resolve_fractions(new_parts[unit], power)\n2368                 new_parts[unit] = a + b\n2369             else:\n2370                 new_parts[unit] = power\n2371             return scale\n2372 \n2373         new_parts = {}\n2374         scale = self._scale\n2375 \n2376         for b, p in zip(self._bases, self._powers):\n2377             if decompose and b not in bases:\n2378                 b = b.decompose(bases=bases)\n2379 \n2380             if isinstance(b, CompositeUnit):\n2381                 scale *= b._scale**p\n2382                 for b_sub, p_sub in zip(b._bases, b._powers):\n2383                     a, b = resolve_fractions(p_sub, p)\n2384                     scale = add_unit(b_sub, a * b, scale)\n2385             else:\n2386                 scale = add_unit(b, p, scale)\n2387 \n2388         new_parts = [x for x in new_parts.items() if x[1] != 0]\n2389         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\n2390 \n2391         self._bases = [x[0] for x in new_parts]\n2392         self._powers = [x[1] for x in new_parts]\n2393         self._scale = sanitize_scale(scale)\n2394 \n2395     def __copy__(self):\n2396         \"\"\"\n2397         For compatibility with python copy module.\n2398         \"\"\"\n2399         return CompositeUnit(self._scale, self._bases[:], self._powers[:])\n2400 \n2401     def decompose(self, bases=set()):\n2402         if len(bases) == 0 and self._decomposed_cache is not None:\n2403             return self._decomposed_cache\n2404 \n2405         for base in self.bases:\n2406             if not isinstance(base, IrreducibleUnit) or (\n2407                 len(bases) and base not in bases\n2408             ):\n2409                 break\n2410         else:\n2411             if len(bases) == 0:\n2412                 self._decomposed_cache = self\n2413             return self\n2414 \n2415         x = CompositeUnit(\n2416             self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases\n2417         )\n2418         if len(bases) == 0:\n2419             self._decomposed_cache = x\n2420         return x\n2421 \n2422     def is_unity(self):\n2423         unit = self.decompose()\n2424         return len(unit.bases) == 0 and unit.scale == 1.0\n2425 \n2426 \n2427 si_prefixes = [\n2428     ([\"Q\"], [\"quetta\"], 1e30),\n2429     ([\"R\"], [\"ronna\"], 1e27),\n2430     ([\"Y\"], [\"yotta\"], 1e24),\n2431     ([\"Z\"], [\"zetta\"], 1e21),\n2432     ([\"E\"], [\"exa\"], 1e18),\n2433     ([\"P\"], [\"peta\"], 1e15),\n2434     ([\"T\"], [\"tera\"], 1e12),\n2435     ([\"G\"], [\"giga\"], 1e9),\n2436     ([\"M\"], [\"mega\"], 1e6),\n2437     ([\"k\"], [\"kilo\"], 1e3),\n2438     ([\"h\"], [\"hecto\"], 1e2),\n2439     ([\"da\"], [\"deka\", \"deca\"], 1e1),\n2440     ([\"d\"], [\"deci\"], 1e-1),\n2441     ([\"c\"], [\"centi\"], 1e-2),\n2442     ([\"m\"], [\"milli\"], 1e-3),\n2443     ([\"u\"], [\"micro\"], 1e-6),\n2444     ([\"n\"], [\"nano\"], 1e-9),\n2445     ([\"p\"], [\"pico\"], 1e-12),\n2446     ([\"f\"], [\"femto\"], 1e-15),\n2447     ([\"a\"], [\"atto\"], 1e-18),\n2448     ([\"z\"], [\"zepto\"], 1e-21),\n2449     ([\"y\"], [\"yocto\"], 1e-24),\n2450     ([\"r\"], [\"ronto\"], 1e-27),\n2451     ([\"q\"], [\"quecto\"], 1e-30),\n2452 ]\n2453 \n2454 \n2455 binary_prefixes = [\n2456     ([\"Ki\"], [\"kibi\"], 2**10),\n2457     ([\"Mi\"], [\"mebi\"], 2**20),\n2458     ([\"Gi\"], [\"gibi\"], 2**30),\n2459     ([\"Ti\"], [\"tebi\"], 2**40),\n2460     ([\"Pi\"], [\"pebi\"], 2**50),\n2461     ([\"Ei\"], [\"exbi\"], 2**60),\n2462 ]\n2463 \n2464 \n2465 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):\n2466     \"\"\"\n2467     Set up all of the standard metric prefixes for a unit.  This\n2468     function should not be used directly, but instead use the\n2469     `prefixes` kwarg on `def_unit`.\n2470 \n2471     Parameters\n2472     ----------\n2473     excludes : list of str, optional\n2474         Any prefixes to exclude from creation to avoid namespace\n2475         collisions.\n2476 \n2477     namespace : dict, optional\n2478         When provided, inject the unit (and all of its aliases) into\n2479         the given namespace dictionary.\n2480 \n2481     prefixes : list, optional\n2482         When provided, it is a list of prefix definitions of the form:\n2483 \n2484             (short_names, long_tables, factor)\n2485     \"\"\"\n2486     if prefixes is True:\n2487         prefixes = si_prefixes\n2488     elif prefixes is False:\n2489         prefixes = []\n2490 \n2491     for short, full, factor in prefixes:\n2492         names = []\n2493         format = {}\n2494         for prefix in short:\n2495             if prefix in excludes:\n2496                 continue\n2497 \n2498             for alias in u.short_names:\n2499                 names.append(prefix + alias)\n2500 \n2501                 # This is a hack to use Greek mu as a prefix\n2502                 # for some formatters.\n2503                 if prefix == \"u\":\n2504                     format[\"latex\"] = r\"\\mu \" + u.get_format_name(\"latex\")\n2505                     format[\"unicode\"] = \"\\N{MICRO SIGN}\" + u.get_format_name(\"unicode\")\n2506 \n2507                 for key, val in u._format.items():\n2508                     format.setdefault(key, prefix + val)\n2509 \n2510         for prefix in full:\n2511             if prefix in excludes:\n2512                 continue\n2513 \n2514             for alias in u.long_names:\n2515                 names.append(prefix + alias)\n2516 \n2517         if len(names):\n2518             PrefixUnit(\n2519                 names,\n2520                 CompositeUnit(factor, [u], [1], _error_check=False),\n2521                 namespace=namespace,\n2522                 format=format,\n2523             )\n2524 \n2525 \n2526 def def_unit(\n2527     s,\n2528     represents=None,\n2529     doc=None,\n2530     format=None,\n2531     prefixes=False,\n2532     exclude_prefixes=[],\n2533     namespace=None,\n2534 ):\n2535     \"\"\"\n2536     Factory function for defining new units.\n2537 \n2538     Parameters\n2539     ----------\n2540     s : str or list of str\n2541         The name of the unit.  If a list, the first element is the\n2542         canonical (short) name, and the rest of the elements are\n2543         aliases.\n2544 \n2545     represents : UnitBase instance, optional\n2546         The unit that this named unit represents.  If not provided,\n2547         a new `IrreducibleUnit` is created.\n2548 \n2549     doc : str, optional\n2550         A docstring describing the unit.\n2551 \n2552     format : dict, optional\n2553         A mapping to format-specific representations of this unit.\n2554         For example, for the ``Ohm`` unit, it might be nice to\n2555         have it displayed as ``\\\\Omega`` by the ``latex``\n2556         formatter.  In that case, `format` argument should be set\n2557         to::\n2558 \n2559             {'latex': r'\\\\Omega'}\n2560 \n2561     prefixes : bool or list, optional\n2562         When `True`, generate all of the SI prefixed versions of the\n2563         unit as well.  For example, for a given unit ``m``, will\n2564         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of\n2565         prefix definitions of the form:\n2566 \n2567             (short_names, long_tables, factor)\n2568 \n2569         Default is `False`.  This function always returns the base\n2570         unit object, even if multiple scaled versions of the unit were\n2571         created.\n2572 \n2573     exclude_prefixes : list of str, optional\n2574         If any of the SI prefixes need to be excluded, they may be\n2575         listed here.  For example, ``Pa`` can be interpreted either as\n2576         \"petaannum\" or \"Pascal\".  Therefore, when defining the\n2577         prefixes for ``a``, ``exclude_prefixes`` should be set to\n2578         ``[\"P\"]``.\n2579 \n2580     namespace : dict, optional\n2581         When provided, inject the unit (and all of its aliases and\n2582         prefixes), into the given namespace dictionary.\n2583 \n2584     Returns\n2585     -------\n2586     unit : `~astropy.units.UnitBase`\n2587         The newly-defined unit, or a matching unit that was already\n2588         defined.\n2589     \"\"\"\n2590     if represents is not None:\n2591         result = Unit(s, represents, namespace=namespace, doc=doc, format=format)\n2592     else:\n2593         result = IrreducibleUnit(s, namespace=namespace, doc=doc, format=format)\n2594 \n2595     if prefixes:\n2596         _add_prefixes(\n2597             result, excludes=exclude_prefixes, namespace=namespace, prefixes=prefixes\n2598         )\n2599     return result\n2600 \n2601 \n2602 def _condition_arg(value):\n2603     \"\"\"\n2604     Validate value is acceptable for conversion purposes.\n2605 \n2606     Will convert into an array if not a scalar, and can be converted\n2607     into an array\n2608 \n2609     Parameters\n2610     ----------\n2611     value : int or float value, or sequence of such values\n2612 \n2613     Returns\n2614     -------\n2615     Scalar value or numpy array\n2616 \n2617     Raises\n2618     ------\n2619     ValueError\n2620         If value is not as expected\n2621     \"\"\"\n2622     if isinstance(value, (np.ndarray, float, int, complex, np.void)):\n2623         return value\n2624 \n2625     avalue = np.array(value)\n2626     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n2627         raise ValueError(\n2628             \"Value not scalar compatible or convertible to \"\n2629             \"an int, float, or complex array\"\n2630         )\n2631     return avalue\n2632 \n2633 \n2634 def unit_scale_converter(val):\n2635     \"\"\"Function that just multiplies the value by unity.\n2636 \n2637     This is a separate function so it can be recognized and\n2638     discarded in unit conversion.\n2639     \"\"\"\n2640     return 1.0 * _condition_arg(val)\n2641 \n2642 \n2643 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)\n2644 # Abbreviation of the above, see #1980\n2645 one = dimensionless_unscaled\n2646 \n2647 # Maintain error in old location for backward compatibility\n2648 # TODO: Is this still needed? Should there be a deprecation warning?\n2649 unit_format.fits.UnitScaleError = UnitScaleError\n",
        "intended_behavior": "The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format."
    },
    {
        "rel_file_path": "astropy/units/quantity.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.1/astropy/units/quantity.py",
        "start": 1,
        "end": 2259,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \"\"\"\n3 This module defines the `Quantity` object, which represents a number with some\n4 associated units. `Quantity` objects support operations like ordinary numbers,\n5 but will deal with unit conversions internally.\n6 \"\"\"\n7 \n8 # STDLIB\n9 import numbers\n10 import operator\n11 import re\n12 import warnings\n13 from fractions import Fraction\n14 \n15 # THIRD PARTY\n16 import numpy as np\n17 \n18 # LOCAL\n19 from astropy import config as _config\n20 from astropy.utils.compat import NUMPY_LT_1_22\n21 from astropy.utils.data_info import ParentDtypeInfo\n22 from astropy.utils.decorators import deprecated\n23 from astropy.utils.exceptions import AstropyWarning\n24 from astropy.utils.misc import isiterable\n25 \n26 from .core import (\n27     Unit,\n28     UnitBase,\n29     UnitConversionError,\n30     UnitsError,\n31     UnitTypeError,\n32     dimensionless_unscaled,\n33     get_current_unit_registry,\n34 )\n35 from .format import Base, Latex\n36 from .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit\n37 from .quantity_helper.function_helpers import (\n38     DISPATCHED_FUNCTIONS,\n39     FUNCTION_HELPERS,\n40     SUBCLASS_SAFE_FUNCTIONS,\n41     UNSUPPORTED_FUNCTIONS,\n42 )\n43 from .structured import StructuredUnit, _structured_unit_like_dtype\n44 from .utils import is_effectively_unity\n45 \n46 __all__ = [\n47     \"Quantity\",\n48     \"SpecificTypeQuantity\",\n49     \"QuantityInfoBase\",\n50     \"QuantityInfo\",\n51     \"allclose\",\n52     \"isclose\",\n53 ]\n54 \n55 \n56 # We don't want to run doctests in the docstrings we inherit from Numpy\n57 __doctest_skip__ = [\"Quantity.*\"]\n58 \n59 _UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\n60 _UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\n61 \n62 \n63 class Conf(_config.ConfigNamespace):\n64     \"\"\"\n65     Configuration parameters for Quantity.\n66     \"\"\"\n67 \n68     latex_array_threshold = _config.ConfigItem(\n69         100,\n70         \"The maximum size an array Quantity can be before its LaTeX \"\n71         'representation for IPython gets \"summarized\" (meaning only the first '\n72         'and last few elements are shown with \"...\" between). Setting this to a '\n73         \"negative number means that the value will instead be whatever numpy \"\n74         \"gets from get_printoptions.\",\n75     )\n76 \n77 \n78 conf = Conf()\n79 \n80 \n81 class QuantityIterator:\n82     \"\"\"\n83     Flat iterator object to iterate over Quantities.\n84 \n85     A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity\n86     ``q``.  It allows iterating over the array as if it were a 1-D array,\n87     either in a for-loop or by calling its `next` method.\n88 \n89     Iteration is done in C-contiguous style, with the last index varying the\n90     fastest. The iterator can also be indexed using basic slicing or\n91     advanced indexing.\n92 \n93     See Also\n94     --------\n95     Quantity.flatten : Returns a flattened copy of an array.\n96 \n97     Notes\n98     -----\n99     `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It\n100     is not exported by the `~astropy.units` module.  Instead of\n101     instantiating a `QuantityIterator` directly, use `Quantity.flat`.\n102     \"\"\"\n103 \n104     def __init__(self, q):\n105         self._quantity = q\n106         self._dataiter = q.view(np.ndarray).flat\n107 \n108     def __iter__(self):\n109         return self\n110 \n111     def __getitem__(self, indx):\n112         out = self._dataiter.__getitem__(indx)\n113         # For single elements, ndarray.flat.__getitem__ returns scalars; these\n114         # need a new view as a Quantity.\n115         if isinstance(out, type(self._quantity)):\n116             return out\n117         else:\n118             return self._quantity._new_view(out)\n119 \n120     def __setitem__(self, index, value):\n121         self._dataiter[index] = self._quantity._to_own_unit(value)\n122 \n123     def __next__(self):\n124         \"\"\"\n125         Return the next value, or raise StopIteration.\n126         \"\"\"\n127         out = next(self._dataiter)\n128         # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.\n129         return self._quantity._new_view(out)\n130 \n131     next = __next__\n132 \n133     def __len__(self):\n134         return len(self._dataiter)\n135 \n136     #### properties and methods to match `numpy.ndarray.flatiter` ####\n137 \n138     @property\n139     def base(self):\n140         \"\"\"A reference to the array that is iterated over.\"\"\"\n141         return self._quantity\n142 \n143     @property\n144     def coords(self):\n145         \"\"\"An N-dimensional tuple of current coordinates.\"\"\"\n146         return self._dataiter.coords\n147 \n148     @property\n149     def index(self):\n150         \"\"\"Current flat index into the array.\"\"\"\n151         return self._dataiter.index\n152 \n153     def copy(self):\n154         \"\"\"Get a copy of the iterator as a 1-D array.\"\"\"\n155         return self._quantity.flatten()\n156 \n157 \n158 class QuantityInfoBase(ParentDtypeInfo):\n159     # This is on a base class rather than QuantityInfo directly, so that\n160     # it can be used for EarthLocationInfo yet make clear that that class\n161     # should not be considered a typical Quantity subclass by Table.\n162     attrs_from_parent = {\"dtype\", \"unit\"}  # dtype and unit taken from parent\n163     _supports_indexing = True\n164 \n165     @staticmethod\n166     def default_format(val):\n167         return f\"{val.value}\"\n168 \n169     @staticmethod\n170     def possible_string_format_functions(format_):\n171         \"\"\"Iterate through possible string-derived format functions.\n172 \n173         A string can either be a format specifier for the format built-in,\n174         a new-style format string, or an old-style format string.\n175 \n176         This method is overridden in order to suppress printing the unit\n177         in each row since it is already at the top in the column header.\n178         \"\"\"\n179         yield lambda format_, val: format(val.value, format_)\n180         yield lambda format_, val: format_.format(val.value)\n181         yield lambda format_, val: format_ % val.value\n182 \n183 \n184 class QuantityInfo(QuantityInfoBase):\n185     \"\"\"\n186     Container for meta information like name, description, format.  This is\n187     required when the object is used as a mixin column within a table, but can\n188     be used as a general way to store meta information.\n189     \"\"\"\n190 \n191     _represent_as_dict_attrs = (\"value\", \"unit\")\n192     _construct_from_dict_args = [\"value\"]\n193     _represent_as_dict_primary_data = \"value\"\n194 \n195     def new_like(self, cols, length, metadata_conflicts=\"warn\", name=None):\n196         \"\"\"\n197         Return a new Quantity instance which is consistent with the\n198         input ``cols`` and has ``length`` rows.\n199 \n200         This is intended for creating an empty column object whose elements can\n201         be set in-place for table operations like join or vstack.\n202 \n203         Parameters\n204         ----------\n205         cols : list\n206             List of input columns\n207         length : int\n208             Length of the output column object\n209         metadata_conflicts : str ('warn'|'error'|'silent')\n210             How to handle metadata conflicts\n211         name : str\n212             Output column name\n213 \n214         Returns\n215         -------\n216         col : `~astropy.units.Quantity` (or subclass)\n217             Empty instance of this class consistent with ``cols``\n218 \n219         \"\"\"\n220         # Get merged info attributes like shape, dtype, format, description, etc.\n221         attrs = self.merge_cols_attributes(\n222             cols, metadata_conflicts, name, (\"meta\", \"format\", \"description\")\n223         )\n224 \n225         # Make an empty quantity using the unit of the last one.\n226         shape = (length,) + attrs.pop(\"shape\")\n227         dtype = attrs.pop(\"dtype\")\n228         # Use zeros so we do not get problems for Quantity subclasses such\n229         # as Longitude and Latitude, which cannot take arbitrary values.\n230         data = np.zeros(shape=shape, dtype=dtype)\n231         # Get arguments needed to reconstruct class\n232         map = {\n233             key: (data if key == \"value\" else getattr(cols[-1], key))\n234             for key in self._represent_as_dict_attrs\n235         }\n236         map[\"copy\"] = False\n237         out = self._construct_from_dict(map)\n238 \n239         # Set remaining info attributes\n240         for attr, value in attrs.items():\n241             setattr(out.info, attr, value)\n242 \n243         return out\n244 \n245     def get_sortable_arrays(self):\n246         \"\"\"\n247         Return a list of arrays which can be lexically sorted to represent\n248         the order of the parent column.\n249 \n250         For Quantity this is just the quantity itself.\n251 \n252 \n253         Returns\n254         -------\n255         arrays : list of ndarray\n256         \"\"\"\n257         return [self._parent]\n258 \n259 \n260 class Quantity(np.ndarray):\n261     \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\n262 \n263     See also: https://docs.astropy.org/en/stable/units/quantity.html\n264 \n265     Parameters\n266     ----------\n267     value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str\n268         The numerical value of this quantity in the units given by unit.  If a\n269         `Quantity` or sequence of them (or any other valid object with a\n270         ``unit`` attribute), creates a new `Quantity` object, converting to\n271         `unit` units as needed.  If a string, it is converted to a number or\n272         `Quantity`, depending on whether a unit is present.\n273 \n274     unit : unit-like\n275         An object that represents the unit associated with the input value.\n276         Must be an `~astropy.units.UnitBase` object or a string parseable by\n277         the :mod:`~astropy.units` package.\n278 \n279     dtype : ~numpy.dtype, optional\n280         The dtype of the resulting Numpy array or scalar that will\n281         hold the value.  If not provided, it is determined from the input,\n282         except that any integer and (non-Quantity) object inputs are converted\n283         to float by default.\n284         If `None`, the normal `numpy.dtype` introspection is used, e.g.\n285         preventing upcasting of integers.\n286 \n287     copy : bool, optional\n288         If `True` (default), then the value is copied.  Otherwise, a copy will\n289         only be made if ``__array__`` returns a copy, if value is a nested\n290         sequence, or if a copy is needed to satisfy an explicitly given\n291         ``dtype``.  (The `False` option is intended mostly for internal use,\n292         to speed up initialization where a copy is known to have been made.\n293         Use with care.)\n294 \n295     order : {'C', 'F', 'A'}, optional\n296         Specify the order of the array.  As in `~numpy.array`.  This parameter\n297         is ignored if the input is a `Quantity` and ``copy=False``.\n298 \n299     subok : bool, optional\n300         If `False` (default), the returned array will be forced to be a\n301         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\n302         or a subclass appropriate for the unit will be used (such as\n303         `~astropy.units.Dex` for ``u.dex(u.AA)``).\n304 \n305     ndmin : int, optional\n306         Specifies the minimum number of dimensions that the resulting array\n307         should have.  Ones will be prepended to the shape as needed to meet\n308         this requirement.  This parameter is ignored if the input is a\n309         `Quantity` and ``copy=False``.\n310 \n311     Raises\n312     ------\n313     TypeError\n314         If the value provided is not a Python numeric type.\n315     TypeError\n316         If the unit provided is not either a :class:`~astropy.units.Unit`\n317         object or a parseable string unit.\n318 \n319     Notes\n320     -----\n321     Quantities can also be created by multiplying a number or array with a\n322     :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/\n323 \n324     Unless the ``dtype`` argument is explicitly specified, integer\n325     or (non-Quantity) object inputs are converted to `float` by default.\n326     \"\"\"\n327 \n328     # Need to set a class-level default for _equivalencies, or\n329     # Constants can not initialize properly\n330     _equivalencies = []\n331 \n332     # Default unit for initialization; can be overridden by subclasses,\n333     # possibly to `None` to indicate there is no default unit.\n334     _default_unit = dimensionless_unscaled\n335 \n336     # Ensures views have an undefined unit.\n337     _unit = None\n338 \n339     __array_priority__ = 10000\n340 \n341     def __class_getitem__(cls, unit_shape_dtype):\n342         \"\"\"Quantity Type Hints.\n343 \n344         Unit-aware type hints are ``Annotated`` objects that encode the class,\n345         the unit, and possibly shape and dtype information, depending on the\n346         python and :mod:`numpy` versions.\n347 \n348         Schematically, ``Annotated[cls[shape, dtype], unit]``\n349 \n350         As a classmethod, the type is the class, ie ``Quantity``\n351         produces an ``Annotated[Quantity, ...]`` while a subclass\n352         like :class:`~astropy.coordinates.Angle` returns\n353         ``Annotated[Angle, ...]``.\n354 \n355         Parameters\n356         ----------\n357         unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple\n358             Unit specification, can be the physical type (ie str or class).\n359             If tuple, then the first element is the unit specification\n360             and all other elements are for `numpy.ndarray` type annotations.\n361             Whether they are included depends on the python and :mod:`numpy`\n362             versions.\n363 \n364         Returns\n365         -------\n366         `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`\n367             Return type in this preference order:\n368             * if python v3.9+ : `typing.Annotated`\n369             * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`\n370             * `astropy.units.Unit` or `astropy.units.PhysicalType`\n371 \n372         Raises\n373         ------\n374         TypeError\n375             If the unit/physical_type annotation is not Unit-like or\n376             PhysicalType-like.\n377 \n378         Examples\n379         --------\n380         Create a unit-aware Quantity type annotation\n381 \n382             >>> Quantity[Unit(\"s\")]\n383             Annotated[Quantity, Unit(\"s\")]\n384 \n385         See Also\n386         --------\n387         `~astropy.units.quantity_input`\n388             Use annotations for unit checks on function arguments and results.\n389 \n390         Notes\n391         -----\n392         With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also\n393         static-type compatible.\n394         \"\"\"\n395         # LOCAL\n396         from ._typing import HAS_ANNOTATED, Annotated\n397 \n398         # process whether [unit] or [unit, shape, ptype]\n399         if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype\n400             target = unit_shape_dtype[0]\n401             shape_dtype = unit_shape_dtype[1:]\n402         else:  # just unit\n403             target = unit_shape_dtype\n404             shape_dtype = ()\n405 \n406         # Allowed unit/physical types. Errors if neither.\n407         try:\n408             unit = Unit(target)\n409         except (TypeError, ValueError):\n410             from astropy.units.physical import get_physical_type\n411 \n412             try:\n413                 unit = get_physical_type(target)\n414             except (TypeError, ValueError, KeyError):  # KeyError for Enum\n415                 raise TypeError(\n416                     \"unit annotation is not a Unit or PhysicalType\"\n417                 ) from None\n418 \n419         # Allow to sort of work for python 3.8- / no typing_extensions\n420         # instead of bailing out, return the unit for `quantity_input`\n421         if not HAS_ANNOTATED:\n422             warnings.warn(\n423                 \"Quantity annotations are valid static type annotations only\"\n424                 \" if Python is v3.9+ or `typing_extensions` is installed.\"\n425             )\n426             return unit\n427 \n428         # Quantity does not (yet) properly extend the NumPy generics types,\n429         # introduced in numpy v1.22+, instead just including the unit info as\n430         # metadata using Annotated.\n431         # TODO: ensure we do interact with NDArray.__class_getitem__.\n432         return Annotated.__class_getitem__((cls, unit))\n433 \n434     def __new__(\n435         cls,\n436         value,\n437         unit=None,\n438         dtype=np.inexact,\n439         copy=True,\n440         order=None,\n441         subok=False,\n442         ndmin=0,\n443     ):\n444         if unit is not None:\n445             # convert unit first, to avoid multiple string->unit conversions\n446             unit = Unit(unit)\n447 \n448         # inexact -> upcast to float dtype\n449         float_default = dtype is np.inexact\n450         if float_default:\n451             dtype = None\n452 \n453         # optimize speed for Quantity with no dtype given, copy=False\n454         if isinstance(value, Quantity):\n455             if unit is not None and unit is not value.unit:\n456                 value = value.to(unit)\n457                 # the above already makes a copy (with float dtype)\n458                 copy = False\n459 \n460             if type(value) is not cls and not (subok and isinstance(value, cls)):\n461                 value = value.view(cls)\n462 \n463             if float_default and value.dtype.kind in \"iu\":\n464                 dtype = float\n465 \n466             return np.array(\n467                 value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\n468             )\n469 \n470         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\n471         # To ensure array remains fast, we short-circuit it.\n472         value_unit = None\n473         if not isinstance(value, np.ndarray):\n474             if isinstance(value, str):\n475                 # The first part of the regex string matches any integer/float;\n476                 # the second parts adds possible trailing .+-, which will break\n477                 # the float function below and ensure things like 1.2.3deg\n478                 # will not work.\n479                 pattern = (\n480                     r\"\\s*[+-]?\"\n481                     r\"((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|\"\n482                     r\"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))\"\n483                     r\"([eE][+-]?\\d+)?\"\n484                     r\"[.+-]?\"\n485                 )\n486 \n487                 v = re.match(pattern, value)\n488                 unit_string = None\n489                 try:\n490                     value = float(v.group())\n491 \n492                 except Exception:\n493                     raise TypeError(\n494                         f'Cannot parse \"{value}\" as a {cls.__name__}. It does not '\n495                         \"start with a number.\"\n496                     )\n497 \n498                 unit_string = v.string[v.end() :].strip()\n499                 if unit_string:\n500                     value_unit = Unit(unit_string)\n501                     if unit is None:\n502                         unit = value_unit  # signal no conversion needed below.\n503 \n504             elif isiterable(value) and len(value) > 0:\n505                 # Iterables like lists and tuples.\n506                 if all(isinstance(v, Quantity) for v in value):\n507                     # If a list/tuple containing only quantities, convert all\n508                     # to the same unit.\n509                     if unit is None:\n510                         unit = value[0].unit\n511                     value = [q.to_value(unit) for q in value]\n512                     value_unit = unit  # signal below that conversion has been done\n513                 elif (\n514                     dtype is None\n515                     and not hasattr(value, \"dtype\")\n516                     and isinstance(unit, StructuredUnit)\n517                 ):\n518                     # Special case for list/tuple of values and a structured unit:\n519                     # ``np.array(value, dtype=None)`` would treat tuples as lower\n520                     # levels of the array, rather than as elements of a structured\n521                     # array, so we use the structure of the unit to help infer the\n522                     # structured dtype of the value.\n523                     dtype = unit._recursively_get_dtype(value)\n524 \n525         using_default_unit = False\n526         if value_unit is None:\n527             # If the value has a `unit` attribute and if not None\n528             # (for Columns with uninitialized unit), treat it like a quantity.\n529             value_unit = getattr(value, \"unit\", None)\n530             if value_unit is None:\n531                 # Default to dimensionless for no (initialized) unit attribute.\n532                 if unit is None:\n533                     using_default_unit = True\n534                     unit = cls._default_unit\n535                 value_unit = unit  # signal below that no conversion is needed\n536             else:\n537                 try:\n538                     value_unit = Unit(value_unit)\n539                 except Exception as exc:\n540                     raise TypeError(\n541                         f\"The unit attribute {value.unit!r} of the input could \"\n542                         \"not be parsed as an astropy Unit.\"\n543                     ) from exc\n544 \n545                 if unit is None:\n546                     unit = value_unit\n547                 elif unit is not value_unit:\n548                     copy = False  # copy will be made in conversion at end\n549 \n550         value = np.array(\n551             value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin\n552         )\n553 \n554         # For no-user-input unit, make sure the constructed unit matches the\n555         # structure of the data.\n556         if using_default_unit and value.dtype.names is not None:\n557             unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\n558 \n559         # check that array contains numbers or long int objects\n560         if value.dtype.kind in \"OSU\" and not (\n561             value.dtype.kind == \"O\" and isinstance(value.item(0), numbers.Number)\n562         ):\n563             raise TypeError(\"The value must be a valid Python or Numpy numeric type.\")\n564 \n565         # by default, cast any integer, boolean, etc., to float\n566         if float_default and value.dtype.kind in \"iuO\":\n567             value = value.astype(float)\n568 \n569         # if we allow subclasses, allow a class from the unit.\n570         if subok:\n571             qcls = getattr(unit, \"_quantity_class\", cls)\n572             if issubclass(qcls, cls):\n573                 cls = qcls\n574 \n575         value = value.view(cls)\n576         value._set_unit(value_unit)\n577         if unit is value_unit:\n578             return value\n579         else:\n580             # here we had non-Quantity input that had a \"unit\" attribute\n581             # with a unit different from the desired one.  So, convert.\n582             return value.to(unit)\n583 \n584     def __array_finalize__(self, obj):\n585         # Check whether super().__array_finalize should be called\n586         # (sadly, ndarray.__array_finalize__ is None; we cannot be sure\n587         # what is above us).\n588         super_array_finalize = super().__array_finalize__\n589         if super_array_finalize is not None:\n590             super_array_finalize(obj)\n591 \n592         # If we're a new object or viewing an ndarray, nothing has to be done.\n593         if obj is None or obj.__class__ is np.ndarray:\n594             return\n595 \n596         # If our unit is not set and obj has a valid one, use it.\n597         if self._unit is None:\n598             unit = getattr(obj, \"_unit\", None)\n599             if unit is not None:\n600                 self._set_unit(unit)\n601 \n602         # Copy info if the original had `info` defined.  Because of the way the\n603         # DataInfo works, `'info' in obj.__dict__` is False until the\n604         # `info` attribute is accessed or set.\n605         if \"info\" in obj.__dict__:\n606             self.info = obj.info\n607 \n608     def __array_wrap__(self, obj, context=None):\n609         if context is None:\n610             # Methods like .squeeze() created a new `ndarray` and then call\n611             # __array_wrap__ to turn the array into self's subclass.\n612             return self._new_view(obj)\n613 \n614         raise NotImplementedError(\n615             \"__array_wrap__ should not be used with a context any more since all \"\n616             \"use should go through array_function. Please raise an issue on \"\n617             \"https://github.com/astropy/astropy\"\n618         )\n619 \n620     def __array_ufunc__(self, function, method, *inputs, **kwargs):\n621         \"\"\"Wrap numpy ufuncs, taking care of units.\n622 \n623         Parameters\n624         ----------\n625         function : callable\n626             ufunc to wrap.\n627         method : str\n628             Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\n629         inputs : tuple\n630             Input arrays.\n631         kwargs : keyword arguments\n632             As passed on, with ``out`` containing possible quantity output.\n633 \n634         Returns\n635         -------\n636         result : `~astropy.units.Quantity` or `NotImplemented`\n637             Results of the ufunc, with the unit set properly.\n638         \"\"\"\n639         # Determine required conversion functions -- to bring the unit of the\n640         # input to that expected (e.g., radian for np.sin), or to get\n641         # consistent units between two inputs (e.g., in np.add) --\n642         # and the unit of the result (or tuple of units for nout > 1).\n643         try:\n644             converters, unit = converters_and_unit(function, method, *inputs)\n645 \n646             out = kwargs.get(\"out\", None)\n647             # Avoid loop back by turning any Quantity output into array views.\n648             if out is not None:\n649                 # If pre-allocated output is used, check it is suitable.\n650                 # This also returns array view, to ensure we don't loop back.\n651                 if function.nout == 1:\n652                     out = out[0]\n653                 out_array = check_output(out, unit, inputs, function=function)\n654                 # Ensure output argument remains a tuple.\n655                 kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\n656 \n657             if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\n658                 # Special-case for initial argument for reductions like\n659                 # np.add.reduce.  This should be converted to the output unit as\n660                 # well, which is typically the same as the input unit (but can\n661                 # in principle be different: unitless for np.equal, radian\n662                 # for np.arctan2, though those are not necessarily useful!)\n663                 kwargs[\"initial\"] = self._to_own_unit(\n664                     kwargs[\"initial\"], check_precision=False, unit=unit\n665                 )\n666 \n667             # Same for inputs, but here also convert if necessary.\n668             arrays = []\n669             for input_, converter in zip(inputs, converters):\n670                 input_ = getattr(input_, \"value\", input_)\n671                 arrays.append(converter(input_) if converter else input_)\n672 \n673             # Call our superclass's __array_ufunc__\n674             result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n675             # If unit is None, a plain array is expected (e.g., comparisons), which\n676             # means we're done.\n677             # We're also done if the result was None (for method 'at') or\n678             # NotImplemented, which can happen if other inputs/outputs override\n679             # __array_ufunc__; hopefully, they can then deal with us.\n680             if unit is None or result is None or result is NotImplemented:\n681                 return result\n682 \n683             return self._result_as_quantity(result, unit, out)\n684 \n685         except (TypeError, ValueError) as e:\n686             out_normalized = kwargs.get(\"out\", tuple())\n687             inputs_and_outputs = inputs + out_normalized\n688             ignored_ufunc = (\n689                 None,\n690                 np.ndarray.__array_ufunc__,\n691                 type(self).__array_ufunc__,\n692             )\n693             if not all(\n694                 getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\n695                 for io in inputs_and_outputs\n696             ):\n697                 return NotImplemented\n698             else:\n699                 raise e\n700 \n701     def _result_as_quantity(self, result, unit, out):\n702         \"\"\"Turn result into a quantity with the given unit.\n703 \n704         If no output is given, it will take a view of the array as a quantity,\n705         and set the unit.  If output is given, those should be quantity views\n706         of the result arrays, and the function will just set the unit.\n707 \n708         Parameters\n709         ----------\n710         result : ndarray or tuple thereof\n711             Array(s) which need to be turned into quantity.\n712         unit : `~astropy.units.Unit`\n713             Unit for the quantities to be returned (or `None` if the result\n714             should not be a quantity).  Should be tuple if result is a tuple.\n715         out : `~astropy.units.Quantity` or None\n716             Possible output quantity. Should be `None` or a tuple if result\n717             is a tuple.\n718 \n719         Returns\n720         -------\n721         out : `~astropy.units.Quantity`\n722            With units set.\n723         \"\"\"\n724         if isinstance(result, (tuple, list)):\n725             if out is None:\n726                 out = (None,) * len(result)\n727             return result.__class__(\n728                 self._result_as_quantity(result_, unit_, out_)\n729                 for (result_, unit_, out_) in zip(result, unit, out)\n730             )\n731 \n732         if out is None:\n733             # View the result array as a Quantity with the proper unit.\n734             return (\n735                 result if unit is None else self._new_view(result, unit, finalize=False)\n736             )\n737 \n738         elif isinstance(out, Quantity):\n739             # For given Quantity output, just set the unit. We know the unit\n740             # is not None and the output is of the correct Quantity subclass,\n741             # as it was passed through check_output.\n742             # (We cannot do this unconditionally, though, since it is possible\n743             # for out to be ndarray and the unit to be dimensionless.)\n744             out._set_unit(unit)\n745 \n746         return out\n747 \n748     def __quantity_subclass__(self, unit):\n749         \"\"\"\n750         Overridden by subclasses to change what kind of view is\n751         created based on the output unit of an operation.\n752 \n753         Parameters\n754         ----------\n755         unit : UnitBase\n756             The unit for which the appropriate class should be returned\n757 \n758         Returns\n759         -------\n760         tuple :\n761             - `~astropy.units.Quantity` subclass\n762             - bool: True if subclasses of the given class are ok\n763         \"\"\"\n764         return Quantity, True\n765 \n766     def _new_view(self, obj=None, unit=None, finalize=True):\n767         \"\"\"Create a Quantity view of some array-like input, and set the unit.\n768 \n769         By default, return a view of ``obj`` of the same class as ``self`` and\n770         with the same unit.  Subclasses can override the type of class for a\n771         given unit using ``__quantity_subclass__``, and can ensure properties\n772         other than the unit are copied using ``__array_finalize__``.\n773 \n774         If the given unit defines a ``_quantity_class`` of which ``self``\n775         is not an instance, a view using this class is taken.\n776 \n777         Parameters\n778         ----------\n779         obj : ndarray or scalar, optional\n780             The array to create a view of.  If obj is a numpy or python scalar,\n781             it will be converted to an array scalar.  By default, ``self``\n782             is converted.\n783 \n784         unit : unit-like, optional\n785             The unit of the resulting object.  It is used to select a\n786             subclass, and explicitly assigned to the view if given.\n787             If not given, the subclass and unit will be that of ``self``.\n788 \n789         finalize : bool, optional\n790             Whether to call ``__array_finalize__`` to transfer properties from\n791             ``self`` to the new view of ``obj`` (e.g., ``info`` for all\n792             subclasses, or ``_wrap_angle`` for `~astropy.coordinates.Latitude`).\n793             Default: `True`, as appropriate for, e.g., unit conversions or slicing,\n794             where the nature of the object does not change.\n795 \n796         Returns\n797         -------\n798         view : `~astropy.units.Quantity` subclass\n799 \n800         \"\"\"\n801         # Determine the unit and quantity subclass that we need for the view.\n802         if unit is None:\n803             unit = self.unit\n804             quantity_subclass = self.__class__\n805         elif unit is self.unit and self.__class__ is Quantity:\n806             # The second part is because we should not presume what other\n807             # classes want to do for the same unit.  E.g., Constant will\n808             # always want to fall back to Quantity, and relies on going\n809             # through `__quantity_subclass__`.\n810             quantity_subclass = Quantity\n811         else:\n812             unit = Unit(unit)\n813             quantity_subclass = getattr(unit, \"_quantity_class\", Quantity)\n814             if isinstance(self, quantity_subclass):\n815                 quantity_subclass, subok = self.__quantity_subclass__(unit)\n816                 if subok:\n817                     quantity_subclass = self.__class__\n818 \n819         # We only want to propagate information from ``self`` to our new view,\n820         # so obj should be a regular array.  By using ``np.array``, we also\n821         # convert python and numpy scalars, which cannot be viewed as arrays\n822         # and thus not as Quantity either, to zero-dimensional arrays.\n823         # (These are turned back into scalar in `.value`)\n824         # Note that for an ndarray input, the np.array call takes only double\n825         # ``obj.__class is np.ndarray``. So, not worth special-casing.\n826         if obj is None:\n827             obj = self.view(np.ndarray)\n828         else:\n829             obj = np.array(obj, copy=False, subok=True)\n830 \n831         # Take the view, set the unit, and update possible other properties\n832         # such as ``info``, ``wrap_angle`` in `Longitude`, etc.\n833         view = obj.view(quantity_subclass)\n834         view._set_unit(unit)\n835         if finalize:\n836             view.__array_finalize__(self)\n837         return view\n838 \n839     def _set_unit(self, unit):\n840         \"\"\"Set the unit.\n841 \n842         This is used anywhere the unit is set or modified, i.e., in the\n843         initializer, in ``__imul__`` and ``__itruediv__`` for in-place\n844         multiplication and division by another unit, as well as in\n845         ``__array_finalize__`` for wrapping up views.  For Quantity, it just\n846         sets the unit, but subclasses can override it to check that, e.g.,\n847         a unit is consistent.\n848         \"\"\"\n849         if not isinstance(unit, UnitBase):\n850             if isinstance(self._unit, StructuredUnit) or isinstance(\n851                 unit, StructuredUnit\n852             ):\n853                 unit = StructuredUnit(unit, self.dtype)\n854             else:\n855                 # Trying to go through a string ensures that, e.g., Magnitudes with\n856                 # dimensionless physical unit become Quantity with units of mag.\n857                 unit = Unit(str(unit), parse_strict=\"silent\")\n858                 if not isinstance(unit, (UnitBase, StructuredUnit)):\n859                     raise UnitTypeError(\n860                         f\"{self.__class__.__name__} instances require normal units, \"\n861                         f\"not {unit.__class__} instances.\"\n862                     )\n863 \n864         self._unit = unit\n865 \n866     def __deepcopy__(self, memo):\n867         # If we don't define this, ``copy.deepcopy(quantity)`` will\n868         # return a bare Numpy array.\n869         return self.copy()\n870 \n871     def __reduce__(self):\n872         # patch to pickle Quantity objects (ndarray subclasses), see\n873         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\n874 \n875         object_state = list(super().__reduce__())\n876         object_state[2] = (object_state[2], self.__dict__)\n877         return tuple(object_state)\n878 \n879     def __setstate__(self, state):\n880         # patch to unpickle Quantity objects (ndarray subclasses), see\n881         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html\n882 \n883         nd_state, own_state = state\n884         super().__setstate__(nd_state)\n885         self.__dict__.update(own_state)\n886 \n887     info = QuantityInfo()\n888 \n889     def _to_value(self, unit, equivalencies=[]):\n890         \"\"\"Helper method for to and to_value.\"\"\"\n891         if equivalencies == []:\n892             equivalencies = self._equivalencies\n893         if not self.dtype.names or isinstance(self.unit, StructuredUnit):\n894             # Standard path, let unit to do work.\n895             return self.unit.to(\n896                 unit, self.view(np.ndarray), equivalencies=equivalencies\n897             )\n898 \n899         else:\n900             # The .to() method of a simple unit cannot convert a structured\n901             # dtype, so we work around it, by recursing.\n902             # TODO: deprecate this?\n903             # Convert simple to Structured on initialization?\n904             result = np.empty_like(self.view(np.ndarray))\n905             for name in self.dtype.names:\n906                 result[name] = self[name]._to_value(unit, equivalencies)\n907             return result\n908 \n909     def to(self, unit, equivalencies=[], copy=True):\n910         \"\"\"\n911         Return a new `~astropy.units.Quantity` object with the specified unit.\n912 \n913         Parameters\n914         ----------\n915         unit : unit-like\n916             An object that represents the unit to convert to. Must be\n917             an `~astropy.units.UnitBase` object or a string parseable\n918             by the `~astropy.units` package.\n919 \n920         equivalencies : list of tuple\n921             A list of equivalence pairs to try if the units are not\n922             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n923             If not provided or ``[]``, class default equivalencies will be used\n924             (none for `~astropy.units.Quantity`, but may be set for subclasses)\n925             If `None`, no equivalencies will be applied at all, not even any\n926             set globally or within a context.\n927 \n928         copy : bool, optional\n929             If `True` (default), then the value is copied.  Otherwise, a copy\n930             will only be made if necessary.\n931 \n932         See Also\n933         --------\n934         to_value : get the numerical value in a given unit.\n935         \"\"\"\n936         # We don't use `to_value` below since we always want to make a copy\n937         # and don't want to slow down this method (esp. the scalar case).\n938         unit = Unit(unit)\n939         if copy:\n940             # Avoid using to_value to ensure that we make a copy. We also\n941             # don't want to slow down this method (esp. the scalar case).\n942             value = self._to_value(unit, equivalencies)\n943         else:\n944             # to_value only copies if necessary\n945             value = self.to_value(unit, equivalencies)\n946         return self._new_view(value, unit)\n947 \n948     def to_value(self, unit=None, equivalencies=[]):\n949         \"\"\"\n950         The numerical value, possibly in a different unit.\n951 \n952         Parameters\n953         ----------\n954         unit : unit-like, optional\n955             The unit in which the value should be given. If not given or `None`,\n956             use the current unit.\n957 \n958         equivalencies : list of tuple, optional\n959             A list of equivalence pairs to try if the units are not directly\n960             convertible (see :ref:`astropy:unit_equivalencies`). If not provided\n961             or ``[]``, class default equivalencies will be used (none for\n962             `~astropy.units.Quantity`, but may be set for subclasses).\n963             If `None`, no equivalencies will be applied at all, not even any\n964             set globally or within a context.\n965 \n966         Returns\n967         -------\n968         value : ndarray or scalar\n969             The value in the units specified. For arrays, this will be a view\n970             of the data if no unit conversion was necessary.\n971 \n972         See Also\n973         --------\n974         to : Get a new instance in a different unit.\n975         \"\"\"\n976         if unit is None or unit is self.unit:\n977             value = self.view(np.ndarray)\n978         elif not self.dtype.names:\n979             # For non-structured, we attempt a short-cut, where we just get\n980             # the scale.  If that is 1, we do not have to do anything.\n981             unit = Unit(unit)\n982             # We want a view if the unit does not change.  One could check\n983             # with \"==\", but that calculates the scale that we need anyway.\n984             # TODO: would be better for `unit.to` to have an in-place flag.\n985             try:\n986                 scale = self.unit._to(unit)\n987             except Exception:\n988                 # Short-cut failed; try default (maybe equivalencies help).\n989                 value = self._to_value(unit, equivalencies)\n990             else:\n991                 value = self.view(np.ndarray)\n992                 if not is_effectively_unity(scale):\n993                     # not in-place!\n994                     value = value * scale\n995         else:\n996             # For structured arrays, we go the default route.\n997             value = self._to_value(unit, equivalencies)\n998 \n999         # Index with empty tuple to decay array scalars in to numpy scalars.\n1000         return value if value.shape else value[()]\n1001 \n1002     value = property(\n1003         to_value,\n1004         doc=\"\"\"The numerical value of this instance.\n1005 \n1006     See also\n1007     --------\n1008     to_value : Get the numerical value in a given unit.\n1009     \"\"\",\n1010     )\n1011 \n1012     @property\n1013     def unit(self):\n1014         \"\"\"\n1015         A `~astropy.units.UnitBase` object representing the unit of this\n1016         quantity.\n1017         \"\"\"\n1018         return self._unit\n1019 \n1020     @property\n1021     def equivalencies(self):\n1022         \"\"\"\n1023         A list of equivalencies that will be applied by default during\n1024         unit conversions.\n1025         \"\"\"\n1026         return self._equivalencies\n1027 \n1028     def _recursively_apply(self, func):\n1029         \"\"\"Apply function recursively to every field.\n1030 \n1031         Returns a copy with the result.\n1032         \"\"\"\n1033         result = np.empty_like(self)\n1034         result_value = result.view(np.ndarray)\n1035         result_unit = ()\n1036         for name in self.dtype.names:\n1037             part = func(self[name])\n1038             result_value[name] = part.value\n1039             result_unit += (part.unit,)\n1040 \n1041         result._set_unit(result_unit)\n1042         return result\n1043 \n1044     @property\n1045     def si(self):\n1046         \"\"\"\n1047         Returns a copy of the current `Quantity` instance with SI units. The\n1048         value of the resulting object will be scaled.\n1049         \"\"\"\n1050         if self.dtype.names:\n1051             return self._recursively_apply(operator.attrgetter(\"si\"))\n1052         si_unit = self.unit.si\n1053         return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)\n1054 \n1055     @property\n1056     def cgs(self):\n1057         \"\"\"\n1058         Returns a copy of the current `Quantity` instance with CGS units. The\n1059         value of the resulting object will be scaled.\n1060         \"\"\"\n1061         if self.dtype.names:\n1062             return self._recursively_apply(operator.attrgetter(\"cgs\"))\n1063         cgs_unit = self.unit.cgs\n1064         return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)\n1065 \n1066     @property\n1067     def isscalar(self):\n1068         \"\"\"\n1069         True if the `value` of this quantity is a scalar, or False if it\n1070         is an array-like object.\n1071 \n1072         .. note::\n1073             This is subtly different from `numpy.isscalar` in that\n1074             `numpy.isscalar` returns False for a zero-dimensional array\n1075             (e.g. ``np.array(1)``), while this is True for quantities,\n1076             since quantities cannot represent true numpy scalars.\n1077         \"\"\"\n1078         return not self.shape\n1079 \n1080     # This flag controls whether convenience conversion members, such\n1081     # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is\n1082     # not turned on on Quantity itself, but is on some subclasses of\n1083     # Quantity, such as `astropy.coordinates.Angle`.\n1084     _include_easy_conversion_members = False\n1085 \n1086     def __dir__(self):\n1087         \"\"\"\n1088         Quantities are able to directly convert to other units that\n1089         have the same physical type.  This function is implemented in\n1090         order to make autocompletion still work correctly in IPython.\n1091         \"\"\"\n1092         if not self._include_easy_conversion_members:\n1093             return super().__dir__()\n1094 \n1095         dir_values = set(super().__dir__())\n1096         equivalencies = Unit._normalize_equivalencies(self.equivalencies)\n1097         for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):\n1098             dir_values.update(equivalent.names)\n1099         return sorted(dir_values)\n1100 \n1101     def __getattr__(self, attr):\n1102         \"\"\"\n1103         Quantities are able to directly convert to other units that\n1104         have the same physical type.\n1105         \"\"\"\n1106         if not self._include_easy_conversion_members:\n1107             raise AttributeError(\n1108                 f\"'{self.__class__.__name__}' object has no '{attr}' member\"\n1109             )\n1110 \n1111         def get_virtual_unit_attribute():\n1112             registry = get_current_unit_registry().registry\n1113             to_unit = registry.get(attr, None)\n1114             if to_unit is None:\n1115                 return None\n1116 \n1117             try:\n1118                 return self.unit.to(\n1119                     to_unit, self.value, equivalencies=self.equivalencies\n1120                 )\n1121             except UnitsError:\n1122                 return None\n1123 \n1124         value = get_virtual_unit_attribute()\n1125 \n1126         if value is None:\n1127             raise AttributeError(\n1128                 f\"{self.__class__.__name__} instance has no attribute '{attr}'\"\n1129             )\n1130         else:\n1131             return value\n1132 \n1133     # Equality needs to be handled explicitly as ndarray.__eq__ gives\n1134     # DeprecationWarnings on any error, which is distracting, and does not\n1135     # deal well with structured arrays (nor does the ufunc).\n1136     def __eq__(self, other):\n1137         try:\n1138             other_value = self._to_own_unit(other)\n1139         except UnitsError:\n1140             return False\n1141         except Exception:\n1142             return NotImplemented\n1143         return self.value.__eq__(other_value)\n1144 \n1145     def __ne__(self, other):\n1146         try:\n1147             other_value = self._to_own_unit(other)\n1148         except UnitsError:\n1149             return True\n1150         except Exception:\n1151             return NotImplemented\n1152         return self.value.__ne__(other_value)\n1153 \n1154     # Unit conversion operator (<<).\n1155     def __lshift__(self, other):\n1156         try:\n1157             other = Unit(other, parse_strict=\"silent\")\n1158         except UnitTypeError:\n1159             return NotImplemented\n1160 \n1161         return self.__class__(self, other, copy=False, subok=True)\n1162 \n1163     def __ilshift__(self, other):\n1164         try:\n1165             other = Unit(other, parse_strict=\"silent\")\n1166         except UnitTypeError:\n1167             return NotImplemented  # try other.__rlshift__(self)\n1168 \n1169         try:\n1170             factor = self.unit._to(other)\n1171         except UnitConversionError:  # incompatible, or requires an Equivalency\n1172             return NotImplemented\n1173         except AttributeError:  # StructuredUnit does not have `_to`\n1174             # In principle, in-place might be possible.\n1175             return NotImplemented\n1176 \n1177         view = self.view(np.ndarray)\n1178         try:\n1179             view *= factor  # operates on view\n1180         except TypeError:\n1181             # The error is `numpy.core._exceptions._UFuncOutputCastingError`,\n1182             # which inherits from `TypeError`.\n1183             return NotImplemented\n1184 \n1185         self._set_unit(other)\n1186         return self\n1187 \n1188     def __rlshift__(self, other):\n1189         if not self.isscalar:\n1190             return NotImplemented\n1191         return Unit(self).__rlshift__(other)\n1192 \n1193     # Give warning for other >> self, since probably other << self was meant.\n1194     def __rrshift__(self, other):\n1195         warnings.warn(\n1196             \">> is not implemented. Did you mean to convert \"\n1197             \"something to this quantity as a unit using '<<'?\",\n1198             AstropyWarning,\n1199         )\n1200         return NotImplemented\n1201 \n1202     # Also define __rshift__ and __irshift__ so we override default ndarray\n1203     # behaviour, but instead of emitting a warning here, let it be done by\n1204     # other (which likely is a unit if this was a mistake).\n1205     def __rshift__(self, other):\n1206         return NotImplemented\n1207 \n1208     def __irshift__(self, other):\n1209         return NotImplemented\n1210 \n1211     # Arithmetic operations\n1212     def __mul__(self, other):\n1213         \"\"\"Multiplication between `Quantity` objects and other objects.\"\"\"\n1214         if isinstance(other, (UnitBase, str)):\n1215             try:\n1216                 return self._new_view(\n1217                     self.value.copy(), other * self.unit, finalize=False\n1218                 )\n1219             except UnitsError:  # let other try to deal with it\n1220                 return NotImplemented\n1221 \n1222         return super().__mul__(other)\n1223 \n1224     def __imul__(self, other):\n1225         \"\"\"In-place multiplication between `Quantity` objects and others.\"\"\"\n1226         if isinstance(other, (UnitBase, str)):\n1227             self._set_unit(other * self.unit)\n1228             return self\n1229 \n1230         return super().__imul__(other)\n1231 \n1232     def __rmul__(self, other):\n1233         \"\"\"\n1234         Right Multiplication between `Quantity` objects and other objects.\n1235         \"\"\"\n1236         return self.__mul__(other)\n1237 \n1238     def __truediv__(self, other):\n1239         \"\"\"Division between `Quantity` objects and other objects.\"\"\"\n1240         if isinstance(other, (UnitBase, str)):\n1241             try:\n1242                 return self._new_view(\n1243                     self.value.copy(), self.unit / other, finalize=False\n1244                 )\n1245             except UnitsError:  # let other try to deal with it\n1246                 return NotImplemented\n1247 \n1248         return super().__truediv__(other)\n1249 \n1250     def __itruediv__(self, other):\n1251         \"\"\"Inplace division between `Quantity` objects and other objects.\"\"\"\n1252         if isinstance(other, (UnitBase, str)):\n1253             self._set_unit(self.unit / other)\n1254             return self\n1255 \n1256         return super().__itruediv__(other)\n1257 \n1258     def __rtruediv__(self, other):\n1259         \"\"\"Right Division between `Quantity` objects and other objects.\"\"\"\n1260         if isinstance(other, (UnitBase, str)):\n1261             return self._new_view(1.0 / self.value, other / self.unit, finalize=False)\n1262 \n1263         return super().__rtruediv__(other)\n1264 \n1265     def __pow__(self, other):\n1266         if isinstance(other, Fraction):\n1267             # Avoid getting object arrays by raising the value to a Fraction.\n1268             return self._new_view(\n1269                 self.value ** float(other), self.unit**other, finalize=False\n1270             )\n1271 \n1272         return super().__pow__(other)\n1273 \n1274     # other overrides of special functions\n1275     def __hash__(self):\n1276         return hash(self.value) ^ hash(self.unit)\n1277 \n1278     def __iter__(self):\n1279         if self.isscalar:\n1280             raise TypeError(\n1281                 f\"'{self.__class__.__name__}' object with a scalar value is not\"\n1282                 \" iterable\"\n1283             )\n1284 \n1285         # Otherwise return a generator\n1286         def quantity_iter():\n1287             for val in self.value:\n1288                 yield self._new_view(val)\n1289 \n1290         return quantity_iter()\n1291 \n1292     def __getitem__(self, key):\n1293         if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\n1294             return self._new_view(\n1295                 self.view(np.ndarray)[key], self.unit[key], finalize=False\n1296             )\n1297 \n1298         try:\n1299             out = super().__getitem__(key)\n1300         except IndexError:\n1301             # We want zero-dimensional Quantity objects to behave like scalars,\n1302             # so they should raise a TypeError rather than an IndexError.\n1303             if self.isscalar:\n1304                 raise TypeError(\n1305                     f\"'{self.__class__.__name__}' object with a scalar value \"\n1306                     \"does not support indexing\"\n1307                 )\n1308             else:\n1309                 raise\n1310         # For single elements, ndarray.__getitem__ returns scalars; these\n1311         # need a new view as a Quantity.\n1312         if not isinstance(out, np.ndarray):\n1313             out = self._new_view(out)\n1314         return out\n1315 \n1316     def __setitem__(self, i, value):\n1317         if isinstance(i, str):\n1318             # Indexing will cause a different unit, so by doing this in\n1319             # two steps we effectively try with the right unit.\n1320             self[i][...] = value\n1321             return\n1322 \n1323         # update indices in info if the info property has been accessed\n1324         # (in which case 'info' in self.__dict__ is True; this is guaranteed\n1325         # to be the case if we're part of a table).\n1326         if not self.isscalar and \"info\" in self.__dict__:\n1327             self.info.adjust_indices(i, value, len(self))\n1328         self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))\n1329 \n1330     # __contains__ is OK\n1331 \n1332     def __bool__(self):\n1333         \"\"\"This method raises ValueError, since truthiness of quantities is ambiguous,\n1334         especially for logarithmic units and temperatures. Use explicit comparisons.\n1335         \"\"\"\n1336         raise ValueError(\n1337             f\"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units\"\n1338             \" and temperatures. Use explicit comparisons.\"\n1339         )\n1340 \n1341     def __len__(self):\n1342         if self.isscalar:\n1343             raise TypeError(\n1344                 f\"'{self.__class__.__name__}' object with a scalar value has no len()\"\n1345             )\n1346         else:\n1347             return len(self.value)\n1348 \n1349     # Numerical types\n1350     def __float__(self):\n1351         try:\n1352             return float(self.to_value(dimensionless_unscaled))\n1353         except (UnitsError, TypeError):\n1354             raise TypeError(\n1355                 \"only dimensionless scalar quantities can be \"\n1356                 \"converted to Python scalars\"\n1357             )\n1358 \n1359     def __int__(self):\n1360         try:\n1361             return int(self.to_value(dimensionless_unscaled))\n1362         except (UnitsError, TypeError):\n1363             raise TypeError(\n1364                 \"only dimensionless scalar quantities can be \"\n1365                 \"converted to Python scalars\"\n1366             )\n1367 \n1368     def __index__(self):\n1369         # for indices, we do not want to mess around with scaling at all,\n1370         # so unlike for float, int, we insist here on unscaled dimensionless\n1371         try:\n1372             assert self.unit.is_unity()\n1373             return self.value.__index__()\n1374         except Exception:\n1375             raise TypeError(\n1376                 \"only integer dimensionless scalar quantities \"\n1377                 \"can be converted to a Python index\"\n1378             )\n1379 \n1380     # TODO: we may want to add a hook for dimensionless quantities?\n1381     @property\n1382     def _unitstr(self):\n1383         if self.unit is None:\n1384             unitstr = _UNIT_NOT_INITIALISED\n1385         else:\n1386             unitstr = str(self.unit)\n1387 \n1388         if unitstr:\n1389             unitstr = \" \" + unitstr\n1390 \n1391         return unitstr\n1392 \n1393     def to_string(self, unit=None, precision=None, format=None, subfmt=None):\n1394         \"\"\"\n1395         Generate a string representation of the quantity and its unit.\n1396 \n1397         The behavior of this function can be altered via the\n1398         `numpy.set_printoptions` function and its various keywords.  The\n1399         exception to this is the ``threshold`` keyword, which is controlled via\n1400         the ``[units.quantity]`` configuration item ``latex_array_threshold``.\n1401         This is treated separately because the numpy default of 1000 is too big\n1402         for most browsers to handle.\n1403 \n1404         Parameters\n1405         ----------\n1406         unit : unit-like, optional\n1407             Specifies the unit.  If not provided,\n1408             the unit used to initialize the quantity will be used.\n1409 \n1410         precision : number, optional\n1411             The level of decimal precision. If `None`, or not provided,\n1412             it will be determined from NumPy print options.\n1413 \n1414         format : str, optional\n1415             The format of the result. If not provided, an unadorned\n1416             string is returned. Supported values are:\n1417 \n1418             - 'latex': Return a LaTeX-formatted string\n1419 \n1420             - 'latex_inline': Return a LaTeX-formatted string that uses\n1421               negative exponents instead of fractions\n1422 \n1423         subfmt : str, optional\n1424             Subformat of the result. For the moment, only used for\n1425             ``format='latex'`` and ``format='latex_inline'``. Supported\n1426             values are:\n1427 \n1428             - 'inline': Use ``$ ... $`` as delimiters.\n1429 \n1430             - 'display': Use ``$\\\\displaystyle ... $`` as delimiters.\n1431 \n1432         Returns\n1433         -------\n1434         str\n1435             A string with the contents of this Quantity\n1436         \"\"\"\n1437         if unit is not None and unit != self.unit:\n1438             return self.to(unit).to_string(\n1439                 unit=None, precision=precision, format=format, subfmt=subfmt\n1440             )\n1441 \n1442         formats = {\n1443             None: None,\n1444             \"latex\": {\n1445                 None: (\"$\", \"$\"),\n1446                 \"inline\": (\"$\", \"$\"),\n1447                 \"display\": (r\"$\\displaystyle \", r\"$\"),\n1448             },\n1449         }\n1450         formats[\"latex_inline\"] = formats[\"latex\"]\n1451 \n1452         if format not in formats:\n1453             raise ValueError(f\"Unknown format '{format}'\")\n1454         elif format is None:\n1455             if precision is None:\n1456                 # Use default formatting settings\n1457                 return f\"{self.value}{self._unitstr:s}\"\n1458             else:\n1459                 # np.array2string properly formats arrays as well as scalars\n1460                 return (\n1461                     np.array2string(self.value, precision=precision, floatmode=\"fixed\")\n1462                     + self._unitstr\n1463                 )\n1464 \n1465         # else, for the moment we assume format=\"latex\" or \"latex_inline\".\n1466 \n1467         # Set the precision if set, otherwise use numpy default\n1468         pops = np.get_printoptions()\n1469         format_spec = f\".{precision if precision is not None else pops['precision']}g\"\n1470 \n1471         def float_formatter(value):\n1472             return Latex.format_exponential_notation(value, format_spec=format_spec)\n1473 \n1474         def complex_formatter(value):\n1475             return \"({}{}i)\".format(\n1476                 Latex.format_exponential_notation(value.real, format_spec=format_spec),\n1477                 Latex.format_exponential_notation(\n1478                     value.imag, format_spec=\"+\" + format_spec\n1479                 ),\n1480             )\n1481 \n1482         # The view is needed for the scalar case - self.value might be float.\n1483         latex_value = np.array2string(\n1484             self.view(np.ndarray),\n1485             threshold=(\n1486                 conf.latex_array_threshold\n1487                 if conf.latex_array_threshold > -1\n1488                 else pops[\"threshold\"]\n1489             ),\n1490             formatter={\n1491                 \"float_kind\": float_formatter,\n1492                 \"complex_kind\": complex_formatter,\n1493             },\n1494             max_line_width=np.inf,\n1495             separator=\",~\",\n1496         )\n1497 \n1498         latex_value = latex_value.replace(\"...\", r\"\\dots\")\n1499 \n1500         # Format unit\n1501         # [1:-1] strips the '$' on either side needed for math mode\n1502         if self.unit is None:\n1503             latex_unit = _UNIT_NOT_INITIALISED\n1504         elif format == \"latex\":\n1505             latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode\n1506         elif format == \"latex_inline\":\n1507             latex_unit = self.unit.to_string(format=\"latex_inline\")[1:-1]\n1508 \n1509         delimiter_left, delimiter_right = formats[format][subfmt]\n1510 \n1511         return rf\"{delimiter_left}{latex_value} \\; {latex_unit}{delimiter_right}\"\n1512 \n1513     def __str__(self):\n1514         return self.to_string()\n1515 \n1516     def __repr__(self):\n1517         prefixstr = \"<\" + self.__class__.__name__ + \" \"\n1518         arrstr = np.array2string(\n1519             self.view(np.ndarray), separator=\", \", prefix=prefixstr\n1520         )\n1521         return f\"{prefixstr}{arrstr}{self._unitstr:s}>\"\n1522 \n1523     def _repr_latex_(self):\n1524         \"\"\"\n1525         Generate a latex representation of the quantity and its unit.\n1526 \n1527         Returns\n1528         -------\n1529         lstr\n1530             A LaTeX string with the contents of this Quantity\n1531         \"\"\"\n1532         # NOTE: This should change to display format in a future release\n1533         return self.to_string(format=\"latex\", subfmt=\"inline\")\n1534 \n1535     def __format__(self, format_spec):\n1536         try:\n1537             return self.to_string(format=format_spec)\n1538         except ValueError:\n1539             # We might have a unit format not implemented in `to_string()`.\n1540             if format_spec in Base.registry:\n1541                 if self.unit is dimensionless_unscaled:\n1542                     return f\"{self.value}\"\n1543                 else:\n1544                     return f\"{self.value} {format(self.unit, format_spec)}\"\n1545             # Can the value be formatted on its own?\n1546             try:\n1547                 return f\"{format(self.value, format_spec)}{self._unitstr:s}\"\n1548             except ValueError:\n1549                 # Format the whole thing as a single string.\n1550                 return format(f\"{self.value}{self._unitstr:s}\", format_spec)\n1551 \n1552     def decompose(self, bases=[]):\n1553         \"\"\"\n1554         Generates a new `Quantity` with the units\n1555         decomposed. Decomposed units have only irreducible units in\n1556         them (see `astropy.units.UnitBase.decompose`).\n1557 \n1558         Parameters\n1559         ----------\n1560         bases : sequence of `~astropy.units.UnitBase`, optional\n1561             The bases to decompose into.  When not provided,\n1562             decomposes down to any irreducible units.  When provided,\n1563             the decomposed result will only contain the given units.\n1564             This will raises a `~astropy.units.UnitsError` if it's not possible\n1565             to do so.\n1566 \n1567         Returns\n1568         -------\n1569         newq : `~astropy.units.Quantity`\n1570             A new object equal to this quantity with units decomposed.\n1571         \"\"\"\n1572         return self._decompose(False, bases=bases)\n1573 \n1574     def _decompose(self, allowscaledunits=False, bases=[]):\n1575         \"\"\"\n1576         Generates a new `Quantity` with the units decomposed. Decomposed\n1577         units have only irreducible units in them (see\n1578         `astropy.units.UnitBase.decompose`).\n1579 \n1580         Parameters\n1581         ----------\n1582         allowscaledunits : bool\n1583             If True, the resulting `Quantity` may have a scale factor\n1584             associated with it.  If False, any scaling in the unit will\n1585             be subsumed into the value of the resulting `Quantity`\n1586 \n1587         bases : sequence of UnitBase, optional\n1588             The bases to decompose into.  When not provided,\n1589             decomposes down to any irreducible units.  When provided,\n1590             the decomposed result will only contain the given units.\n1591             This will raises a `~astropy.units.UnitsError` if it's not possible\n1592             to do so.\n1593 \n1594         Returns\n1595         -------\n1596         newq : `~astropy.units.Quantity`\n1597             A new object equal to this quantity with units decomposed.\n1598 \n1599         \"\"\"\n1600         new_unit = self.unit.decompose(bases=bases)\n1601 \n1602         # Be careful here because self.value usually is a view of self;\n1603         # be sure that the original value is not being modified.\n1604         if not allowscaledunits and hasattr(new_unit, \"scale\"):\n1605             new_value = self.value * new_unit.scale\n1606             new_unit = new_unit / new_unit.scale\n1607             return self._new_view(new_value, new_unit)\n1608         else:\n1609             return self._new_view(self.copy(), new_unit)\n1610 \n1611     # These functions need to be overridden to take into account the units\n1612     # Array conversion\n1613     # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion\n1614 \n1615     def item(self, *args):\n1616         \"\"\"Copy an element of an array to a scalar Quantity and return it.\n1617 \n1618         Like :meth:`~numpy.ndarray.item` except that it always\n1619         returns a `Quantity`, not a Python scalar.\n1620 \n1621         \"\"\"\n1622         return self._new_view(super().item(*args))\n1623 \n1624     def tolist(self):\n1625         raise NotImplementedError(\n1626             \"cannot make a list of Quantities. Get list of values with\"\n1627             \" q.value.tolist().\"\n1628         )\n1629 \n1630     def _to_own_unit(self, value, check_precision=True, *, unit=None):\n1631         \"\"\"Convert value to one's own unit (or that given).\n1632 \n1633         Here, non-quantities are treated as dimensionless, and care is taken\n1634         for values of 0, infinity or nan, which are allowed to have any unit.\n1635 \n1636         Parameters\n1637         ----------\n1638         value : anything convertible to `~astropy.units.Quantity`\n1639             The value to be converted to the requested unit.\n1640         check_precision : bool\n1641             Whether to forbid conversion of float to integer if that changes\n1642             the input number.  Default: `True`.\n1643         unit : `~astropy.units.Unit` or None\n1644             The unit to convert to.  By default, the unit of ``self``.\n1645 \n1646         Returns\n1647         -------\n1648         value : number or `~numpy.ndarray`\n1649             In the requested units.\n1650 \n1651         \"\"\"\n1652         if unit is None:\n1653             unit = self.unit\n1654         try:\n1655             _value = value.to_value(unit)\n1656         except AttributeError:\n1657             # We're not a Quantity.\n1658             # First remove two special cases (with a fast test):\n1659             # 1) Maybe masked printing? MaskedArray with quantities does not\n1660             # work very well, but no reason to break even repr and str.\n1661             # 2) np.ma.masked? useful if we're a MaskedQuantity.\n1662             if value is np.ma.masked or (\n1663                 value is np.ma.masked_print_option and self.dtype.kind == \"O\"\n1664             ):\n1665                 return value\n1666             # Now, let's try a more general conversion.\n1667             # Plain arrays will be converted to dimensionless in the process,\n1668             # but anything with a unit attribute will use that.\n1669             try:\n1670                 as_quantity = Quantity(value)\n1671                 _value = as_quantity.to_value(unit)\n1672             except UnitsError:\n1673                 # last chance: if this was not something with a unit\n1674                 # and is all 0, inf, or nan, we treat it as arbitrary unit.\n1675                 if not hasattr(value, \"unit\") and can_have_arbitrary_unit(\n1676                     as_quantity.value\n1677                 ):\n1678                     _value = as_quantity.value\n1679                 else:\n1680                     raise\n1681 \n1682         if self.dtype.kind == \"i\" and check_precision:\n1683             # If, e.g., we are casting float to int, we want to fail if\n1684             # precision is lost, but let things pass if it works.\n1685             _value = np.array(_value, copy=False, subok=True)\n1686             if not np.can_cast(_value.dtype, self.dtype):\n1687                 self_dtype_array = np.array(_value, self.dtype, subok=True)\n1688                 if not np.all((self_dtype_array == _value) | np.isnan(_value)):\n1689                     raise TypeError(\n1690                         \"cannot convert value type to array type without precision loss\"\n1691                     )\n1692 \n1693         # Setting names to ensure things like equality work (note that\n1694         # above will have failed already if units did not match).\n1695         if self.dtype.names:\n1696             _value.dtype.names = self.dtype.names\n1697         return _value\n1698 \n1699     def itemset(self, *args):\n1700         if len(args) == 0:\n1701             raise ValueError(\"itemset must have at least one argument\")\n1702 \n1703         self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))\n1704 \n1705     def tostring(self, order=\"C\"):\n1706         \"\"\"Not implemented, use ``.value.tostring()`` instead.\"\"\"\n1707         raise NotImplementedError(\n1708             \"cannot write Quantities to string.  Write array with\"\n1709             \" q.value.tostring(...).\"\n1710         )\n1711 \n1712     def tobytes(self, order=\"C\"):\n1713         \"\"\"Not implemented, use ``.value.tobytes()`` instead.\"\"\"\n1714         raise NotImplementedError(\n1715             \"cannot write Quantities to bytes.  Write array with q.value.tobytes(...).\"\n1716         )\n1717 \n1718     def tofile(self, fid, sep=\"\", format=\"%s\"):\n1719         \"\"\"Not implemented, use ``.value.tofile()`` instead.\"\"\"\n1720         raise NotImplementedError(\n1721             \"cannot write Quantities to file.  Write array with q.value.tofile(...)\"\n1722         )\n1723 \n1724     def dump(self, file):\n1725         \"\"\"Not implemented, use ``.value.dump()`` instead.\"\"\"\n1726         raise NotImplementedError(\n1727             \"cannot dump Quantities to file.  Write array with q.value.dump()\"\n1728         )\n1729 \n1730     def dumps(self):\n1731         \"\"\"Not implemented, use ``.value.dumps()`` instead.\"\"\"\n1732         raise NotImplementedError(\n1733             \"cannot dump Quantities to string.  Write array with q.value.dumps()\"\n1734         )\n1735 \n1736     # astype, byteswap, copy, view, getfield, setflags OK as is\n1737 \n1738     def fill(self, value):\n1739         self.view(np.ndarray).fill(self._to_own_unit(value))\n1740 \n1741     # Shape manipulation: resize cannot be done (does not own data), but\n1742     # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only\n1743     # the flat iterator needs to be overwritten, otherwise single items are\n1744     # returned as numbers.\n1745     @property\n1746     def flat(self):\n1747         \"\"\"A 1-D iterator over the Quantity array.\n1748 \n1749         This returns a ``QuantityIterator`` instance, which behaves the same\n1750         as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,\n1751         and is similar to, but not a subclass of, Python's built-in iterator\n1752         object.\n1753         \"\"\"\n1754         return QuantityIterator(self)\n1755 \n1756     @flat.setter\n1757     def flat(self, value):\n1758         y = self.ravel()\n1759         y[:] = value\n1760 \n1761     # Item selection and manipulation\n1762     # repeat, sort, compress, diagonal OK\n1763     def take(self, indices, axis=None, out=None, mode=\"raise\"):\n1764         out = super().take(indices, axis=axis, out=out, mode=mode)\n1765         # For single elements, ndarray.take returns scalars; these\n1766         # need a new view as a Quantity.\n1767         if type(out) is not type(self):\n1768             out = self._new_view(out)\n1769         return out\n1770 \n1771     def put(self, indices, values, mode=\"raise\"):\n1772         self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)\n1773 \n1774     def choose(self, choices, out=None, mode=\"raise\"):\n1775         raise NotImplementedError(\n1776             \"cannot choose based on quantity.  Choose using array with\"\n1777             \" q.value.choose(...)\"\n1778         )\n1779 \n1780     # ensure we do not return indices as quantities\n1781     def argsort(self, axis=-1, kind=\"quicksort\", order=None):\n1782         return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)\n1783 \n1784     def searchsorted(self, v, *args, **kwargs):\n1785         return np.searchsorted(\n1786             np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs\n1787         )  # avoid numpy 1.6 problem\n1788 \n1789     if NUMPY_LT_1_22:\n1790 \n1791         def argmax(self, axis=None, out=None):\n1792             return self.view(np.ndarray).argmax(axis, out=out)\n1793 \n1794         def argmin(self, axis=None, out=None):\n1795             return self.view(np.ndarray).argmin(axis, out=out)\n1796 \n1797     else:\n1798 \n1799         def argmax(self, axis=None, out=None, *, keepdims=False):\n1800             return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)\n1801 \n1802         def argmin(self, axis=None, out=None, *, keepdims=False):\n1803             return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)\n1804 \n1805     def __array_function__(self, function, types, args, kwargs):\n1806         \"\"\"Wrap numpy functions, taking care of units.\n1807 \n1808         Parameters\n1809         ----------\n1810         function : callable\n1811             Numpy function to wrap\n1812         types : iterable of classes\n1813             Classes that provide an ``__array_function__`` override. Can\n1814             in principle be used to interact with other classes. Below,\n1815             mostly passed on to `~numpy.ndarray`, which can only interact\n1816             with subclasses.\n1817         args : tuple\n1818             Positional arguments provided in the function call.\n1819         kwargs : dict\n1820             Keyword arguments provided in the function call.\n1821 \n1822         Returns\n1823         -------\n1824         result: `~astropy.units.Quantity`, `~numpy.ndarray`\n1825             As appropriate for the function.  If the function is not\n1826             supported, `NotImplemented` is returned, which will lead to\n1827             a `TypeError` unless another argument overrode the function.\n1828 \n1829         Raises\n1830         ------\n1831         ~astropy.units.UnitsError\n1832             If operands have incompatible units.\n1833         \"\"\"\n1834         # A function should be in one of the following sets or dicts:\n1835         # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation\n1836         #    supports Quantity; we pass on to ndarray.__array_function__.\n1837         # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable\n1838         #    after converting quantities to arrays with suitable units,\n1839         #    and possibly setting units on the result.\n1840         # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but\n1841         #    requires a Quantity-specific implementation.\n1842         # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.\n1843         # For now, since we may not yet have complete coverage, if a\n1844         # function is in none of the above, we simply call the numpy\n1845         # implementation.\n1846         if function in SUBCLASS_SAFE_FUNCTIONS:\n1847             return super().__array_function__(function, types, args, kwargs)\n1848 \n1849         elif function in FUNCTION_HELPERS:\n1850             function_helper = FUNCTION_HELPERS[function]\n1851             try:\n1852                 args, kwargs, unit, out = function_helper(*args, **kwargs)\n1853             except NotImplementedError:\n1854                 return self._not_implemented_or_raise(function, types)\n1855 \n1856             result = super().__array_function__(function, types, args, kwargs)\n1857             # Fall through to return section\n1858 \n1859         elif function in DISPATCHED_FUNCTIONS:\n1860             dispatched_function = DISPATCHED_FUNCTIONS[function]\n1861             try:\n1862                 result, unit, out = dispatched_function(*args, **kwargs)\n1863             except NotImplementedError:\n1864                 return self._not_implemented_or_raise(function, types)\n1865 \n1866             # Fall through to return section\n1867 \n1868         elif function in UNSUPPORTED_FUNCTIONS:\n1869             return NotImplemented\n1870 \n1871         else:\n1872             warnings.warn(\n1873                 f\"function '{function.__name__}' is not known to astropy's Quantity.\"\n1874                 \" Will run it anyway, hoping it will treat ndarray subclasses\"\n1875                 \" correctly. Please raise an issue at\"\n1876                 \" https://github.com/astropy/astropy/issues.\",\n1877                 AstropyWarning,\n1878             )\n1879             return super().__array_function__(function, types, args, kwargs)\n1880 \n1881         # If unit is None, a plain array is expected (e.g., boolean), which\n1882         # means we're done.\n1883         # We're also done if the result was NotImplemented, which can happen\n1884         # if other inputs/outputs override __array_function__;\n1885         # hopefully, they can then deal with us.\n1886         if unit is None or result is NotImplemented:\n1887             return result\n1888 \n1889         return self._result_as_quantity(result, unit, out=out)\n1890 \n1891     def _not_implemented_or_raise(self, function, types):\n1892         # Our function helper or dispatcher found that the function does not\n1893         # work with Quantity.  In principle, there may be another class that\n1894         # knows what to do with us, for which we should return NotImplemented.\n1895         # But if there is ndarray (or a non-Quantity subclass of it) around,\n1896         # it quite likely coerces, so we should just break.\n1897         if any(\n1898             issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types\n1899         ):\n1900             raise TypeError(\n1901                 f\"the Quantity implementation cannot handle {function} \"\n1902                 \"with the given arguments.\"\n1903             ) from None\n1904         else:\n1905             return NotImplemented\n1906 \n1907     # Calculation -- override ndarray methods to take into account units.\n1908     # We use the corresponding numpy functions to evaluate the results, since\n1909     # the methods do not always allow calling with keyword arguments.\n1910     # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives\n1911     # TypeError: 'a_max' is an invalid keyword argument for this function.\n1912     def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):\n1913         \"\"\"Wrap a numpy function that processes self, returning a Quantity.\n1914 \n1915         Parameters\n1916         ----------\n1917         function : callable\n1918             Numpy function to wrap.\n1919         args : positional arguments\n1920             Any positional arguments to the function beyond the first argument\n1921             (which will be set to ``self``).\n1922         kwargs : keyword arguments\n1923             Keyword arguments to the function.\n1924 \n1925         If present, the following arguments are treated specially:\n1926 \n1927         unit : `~astropy.units.Unit`\n1928             Unit of the output result.  If not given, the unit of ``self``.\n1929         out : `~astropy.units.Quantity`\n1930             A Quantity instance in which to store the output.\n1931 \n1932         Notes\n1933         -----\n1934         Output should always be assigned via a keyword argument, otherwise\n1935         no proper account of the unit is taken.\n1936 \n1937         Returns\n1938         -------\n1939         out : `~astropy.units.Quantity`\n1940             Result of the function call, with the unit set properly.\n1941         \"\"\"\n1942         if unit is None:\n1943             unit = self.unit\n1944         # Ensure we don't loop back by turning any Quantity into array views.\n1945         args = (self.value,) + tuple(\n1946             (arg.value if isinstance(arg, Quantity) else arg) for arg in args\n1947         )\n1948         if out is not None:\n1949             # If pre-allocated output is used, check it is suitable.\n1950             # This also returns array view, to ensure we don't loop back.\n1951             arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))\n1952             kwargs[\"out\"] = check_output(out, unit, arrays, function=function)\n1953         # Apply the function and turn it back into a Quantity.\n1954         result = function(*args, **kwargs)\n1955         return self._result_as_quantity(result, unit, out)\n1956 \n1957     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):\n1958         return self._wrap_function(np.trace, offset, axis1, axis2, dtype, out=out)\n1959 \n1960     def var(\n1961         self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\n1962     ):\n1963         return self._wrap_function(\n1964             np.var,\n1965             axis,\n1966             dtype,\n1967             out=out,\n1968             ddof=ddof,\n1969             keepdims=keepdims,\n1970             where=where,\n1971             unit=self.unit**2,\n1972         )\n1973 \n1974     def std(\n1975         self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True\n1976     ):\n1977         return self._wrap_function(\n1978             np.std, axis, dtype, out=out, ddof=ddof, keepdims=keepdims, where=where\n1979         )\n1980 \n1981     def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):\n1982         return self._wrap_function(\n1983             np.mean, axis, dtype, out=out, keepdims=keepdims, where=where\n1984         )\n1985 \n1986     def round(self, decimals=0, out=None):\n1987         return self._wrap_function(np.round, decimals, out=out)\n1988 \n1989     def dot(self, b, out=None):\n1990         result_unit = self.unit * getattr(b, \"unit\", dimensionless_unscaled)\n1991         return self._wrap_function(np.dot, b, out=out, unit=result_unit)\n1992 \n1993     # Calculation: override methods that do not make sense.\n1994 \n1995     def all(self, axis=None, out=None):\n1996         raise TypeError(\n1997             \"cannot evaluate truth value of quantities. \"\n1998             \"Evaluate array with q.value.all(...)\"\n1999         )\n2000 \n2001     def any(self, axis=None, out=None):\n2002         raise TypeError(\n2003             \"cannot evaluate truth value of quantities. \"\n2004             \"Evaluate array with q.value.any(...)\"\n2005         )\n2006 \n2007     # Calculation: numpy functions that can be overridden with methods.\n2008 \n2009     def diff(self, n=1, axis=-1):\n2010         return self._wrap_function(np.diff, n, axis)\n2011 \n2012     def ediff1d(self, to_end=None, to_begin=None):\n2013         return self._wrap_function(np.ediff1d, to_end, to_begin)\n2014 \n2015     if NUMPY_LT_1_22:\n2016 \n2017         @deprecated(\"5.3\", alternative=\"np.nansum\", obj_type=\"method\")\n2018         def nansum(self, axis=None, out=None, keepdims=False):\n2019             return self._wrap_function(np.nansum, axis, out=out, keepdims=keepdims)\n2020 \n2021     else:\n2022 \n2023         @deprecated(\"5.3\", alternative=\"np.nansum\", obj_type=\"method\")\n2024         def nansum(\n2025             self, axis=None, out=None, keepdims=False, *, initial=None, where=True\n2026         ):\n2027             if initial is not None:\n2028                 initial = self._to_own_unit(initial)\n2029             return self._wrap_function(\n2030                 np.nansum,\n2031                 axis,\n2032                 out=out,\n2033                 keepdims=keepdims,\n2034                 initial=initial,\n2035                 where=where,\n2036             )\n2037 \n2038     def insert(self, obj, values, axis=None):\n2039         \"\"\"\n2040         Insert values along the given axis before the given indices and return\n2041         a new `~astropy.units.Quantity` object.\n2042 \n2043         This is a thin wrapper around the `numpy.insert` function.\n2044 \n2045         Parameters\n2046         ----------\n2047         obj : int, slice or sequence of int\n2048             Object that defines the index or indices before which ``values`` is\n2049             inserted.\n2050         values : array-like\n2051             Values to insert.  If the type of ``values`` is different\n2052             from that of quantity, ``values`` is converted to the matching type.\n2053             ``values`` should be shaped so that it can be broadcast appropriately\n2054             The unit of ``values`` must be consistent with this quantity.\n2055         axis : int, optional\n2056             Axis along which to insert ``values``.  If ``axis`` is None then\n2057             the quantity array is flattened before insertion.\n2058 \n2059         Returns\n2060         -------\n2061         out : `~astropy.units.Quantity`\n2062             A copy of quantity with ``values`` inserted.  Note that the\n2063             insertion does not occur in-place: a new quantity array is returned.\n2064 \n2065         Examples\n2066         --------\n2067         >>> import astropy.units as u\n2068         >>> q = [1, 2] * u.m\n2069         >>> q.insert(0, 50 * u.cm)\n2070         <Quantity [ 0.5,  1.,  2.] m>\n2071 \n2072         >>> q = [[1, 2], [3, 4]] * u.m\n2073         >>> q.insert(1, [10, 20] * u.m, axis=0)\n2074         <Quantity [[  1.,  2.],\n2075                    [ 10., 20.],\n2076                    [  3.,  4.]] m>\n2077 \n2078         >>> q.insert(1, 10 * u.m, axis=1)\n2079         <Quantity [[  1., 10.,  2.],\n2080                    [  3., 10.,  4.]] m>\n2081 \n2082         \"\"\"\n2083         out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)\n2084         return self._new_view(out_array)\n2085 \n2086 \n2087 class SpecificTypeQuantity(Quantity):\n2088     \"\"\"Superclass for Quantities of specific physical type.\n2089 \n2090     Subclasses of these work just like :class:`~astropy.units.Quantity`, except\n2091     that they are for specific physical types (and may have methods that are\n2092     only appropriate for that type).  Astropy examples are\n2093     :class:`~astropy.coordinates.Angle` and\n2094     :class:`~astropy.coordinates.Distance`\n2095 \n2096     At a minimum, subclasses should set ``_equivalent_unit`` to the unit\n2097     associated with the physical type.\n2098     \"\"\"\n2099 \n2100     # The unit for the specific physical type.  Instances can only be created\n2101     # with units that are equivalent to this.\n2102     _equivalent_unit = None\n2103 \n2104     # The default unit used for views.  Even with `None`, views of arrays\n2105     # without units are possible, but will have an uninitialized unit.\n2106     _unit = None\n2107 \n2108     # Default unit for initialization through the constructor.\n2109     _default_unit = None\n2110 \n2111     # ensure that we get precedence over our superclass.\n2112     __array_priority__ = Quantity.__array_priority__ + 10\n2113 \n2114     def __quantity_subclass__(self, unit):\n2115         if unit.is_equivalent(self._equivalent_unit):\n2116             return type(self), True\n2117         else:\n2118             return super().__quantity_subclass__(unit)[0], False\n2119 \n2120     def _set_unit(self, unit):\n2121         if unit is None or not unit.is_equivalent(self._equivalent_unit):\n2122             raise UnitTypeError(\n2123                 \"{} instances require units equivalent to '{}'\".format(\n2124                     type(self).__name__, self._equivalent_unit\n2125                 )\n2126                 + (\n2127                     \", but no unit was given.\"\n2128                     if unit is None\n2129                     else f\", so cannot set it to '{unit}'.\"\n2130                 )\n2131             )\n2132 \n2133         super()._set_unit(unit)\n2134 \n2135 \n2136 def isclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs):\n2137     \"\"\"\n2138     Return a boolean array where two arrays are element-wise equal\n2139     within a tolerance.\n2140 \n2141     Parameters\n2142     ----------\n2143     a, b : array-like or `~astropy.units.Quantity`\n2144         Input values or arrays to compare\n2145     rtol : array-like or `~astropy.units.Quantity`\n2146         The relative tolerance for the comparison, which defaults to\n2147         ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\n2148         then it must be dimensionless.\n2149     atol : number or `~astropy.units.Quantity`\n2150         The absolute tolerance for the comparison.  The units (or lack\n2151         thereof) of ``a``, ``b``, and ``atol`` must be consistent with\n2152         each other.  If `None`, ``atol`` defaults to zero in the\n2153         appropriate units.\n2154     equal_nan : `bool`\n2155         Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\n2156         be considered equal to NaN\u2019s in ``b``.\n2157 \n2158     Notes\n2159     -----\n2160     This is a :class:`~astropy.units.Quantity`-aware version of\n2161     :func:`numpy.isclose`. However, this differs from the `numpy` function in\n2162     that the default for the absolute tolerance here is zero instead of\n2163     ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\n2164     *absolute* tolerance given two inputs that may have differently scaled\n2165     units.\n2166 \n2167     Raises\n2168     ------\n2169     `~astropy.units.UnitsError`\n2170         If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,\n2171         or if ``rtol`` is not dimensionless.\n2172 \n2173     See Also\n2174     --------\n2175     allclose\n2176     \"\"\"\n2177     unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)\n2178     return np.isclose(*unquantified_args, equal_nan=equal_nan, **kwargs)\n2179 \n2180 \n2181 def allclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs) -> bool:\n2182     \"\"\"\n2183     Whether two arrays are element-wise equal within a tolerance.\n2184 \n2185     Parameters\n2186     ----------\n2187     a, b : array-like or `~astropy.units.Quantity`\n2188         Input values or arrays to compare\n2189     rtol : array-like or `~astropy.units.Quantity`\n2190         The relative tolerance for the comparison, which defaults to\n2191         ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,\n2192         then it must be dimensionless.\n2193     atol : number or `~astropy.units.Quantity`\n2194         The absolute tolerance for the comparison.  The units (or lack\n2195         thereof) of ``a``, ``b``, and ``atol`` must be consistent with\n2196         each other.  If `None`, ``atol`` defaults to zero in the\n2197         appropriate units.\n2198     equal_nan : `bool`\n2199         Whether to compare NaN\u2019s as equal. If `True`, NaNs in ``a`` will\n2200         be considered equal to NaN\u2019s in ``b``.\n2201 \n2202     Notes\n2203     -----\n2204     This is a :class:`~astropy.units.Quantity`-aware version of\n2205     :func:`numpy.allclose`. However, this differs from the `numpy` function in\n2206     that the default for the absolute tolerance here is zero instead of\n2207     ``atol=1e-8`` in `numpy`, as there is no natural way to set a default\n2208     *absolute* tolerance given two inputs that may have differently scaled\n2209     units.\n2210 \n2211     Raises\n2212     ------\n2213     `~astropy.units.UnitsError`\n2214         If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,\n2215         or if ``rtol`` is not dimensionless.\n2216 \n2217     See Also\n2218     --------\n2219     isclose\n2220     \"\"\"\n2221     unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)\n2222     return np.allclose(*unquantified_args, equal_nan=equal_nan, **kwargs)\n2223 \n2224 \n2225 def _unquantify_allclose_arguments(actual, desired, rtol, atol):\n2226     actual = Quantity(actual, subok=True, copy=False)\n2227 \n2228     desired = Quantity(desired, subok=True, copy=False)\n2229     try:\n2230         desired = desired.to(actual.unit)\n2231     except UnitsError:\n2232         raise UnitsError(\n2233             f\"Units for 'desired' ({desired.unit}) and 'actual' \"\n2234             f\"({actual.unit}) are not convertible\"\n2235         )\n2236 \n2237     if atol is None:\n2238         # By default, we assume an absolute tolerance of zero in the\n2239         # appropriate units.  The default value of None for atol is\n2240         # needed because the units of atol must be consistent with the\n2241         # units for a and b.\n2242         atol = Quantity(0)\n2243     else:\n2244         atol = Quantity(atol, subok=True, copy=False)\n2245         try:\n2246             atol = atol.to(actual.unit)\n2247         except UnitsError:\n2248             raise UnitsError(\n2249                 f\"Units for 'atol' ({atol.unit}) and 'actual' \"\n2250                 f\"({actual.unit}) are not convertible\"\n2251             )\n2252 \n2253     rtol = Quantity(rtol, subok=True, copy=False)\n2254     try:\n2255         rtol = rtol.to(dimensionless_unscaled)\n2256     except Exception:\n2257         raise UnitsError(\"'rtol' should be dimensionless\")\n2258 \n2259     return actual.value, desired.value, rtol.value, atol.value\n",
        "intended_behavior": "The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format."
    }
]