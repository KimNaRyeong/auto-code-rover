2025-10-17 22:17:20.389 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 22:17:24.893 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=12, cost=0.004520
2025-10-17 22:17:37.906 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=596, output_tokens=517, cost=0.021470
2025-10-17 22:17:38.935 | INFO     | registered non reproducing test 0
2025-10-17 22:17:52.310 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1876, output_tokens=548, cost=0.035200
2025-10-17 22:17:53.304 | INFO     | registered non reproducing test 1
2025-10-17 22:18:07.084 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1909, output_tokens=654, cost=0.038710
2025-10-17 22:18:08.083 | INFO     | registered non reproducing test 2
2025-10-17 22:18:08.083 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 22:18:08.090 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:18:16.338 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=721, output_tokens=330, cost=0.017110
2025-10-17 22:18:16.345 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:18:19.120 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=52, cost=0.008400
2025-10-17 22:18:19.122 | DEBUG    | Extracted a valid json.
2025-10-17 22:18:19.122 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"to_string\")",
        "search_method(\"decompose\")",
        "search_code(\":unicode\")",
        "search_code(\":console\")"
    ],
    "bug_locations": []
}
2025-10-17 22:18:19.184 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 22:18:19.184 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 22:18:35.889 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1625, output_tokens=740, cost=0.038450
2025-10-17 22:18:35.902 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:18:44.557 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2581, output_tokens=347, cost=0.036220
2025-10-17 22:18:44.565 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:18:51.683 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=701, output_tokens=305, cost=0.016160
2025-10-17 22:18:51.684 | DEBUG    | Extracted a valid json.
2025-10-17 22:18:51.684 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/units/format/console.py",
            "class": "",
            "method": "",
            "intended_behavior": "The method responsible for formatting units in console format should ensure that it does not prepend a space to the unit string unless necessary for proper formatting. This behavior should be consistent, regardless of whether a unit scale factor is present or not. Adjustments might be needed to the logic that inserts spaces to only do so when part of the unit representation requires it, not as a default behavior for all unit strings."
        },
        {
            "file": "astropy/units/core.py",
            "class": "",
            "method": "decompose()",
            "intended_behavior": "The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format."
        },
        {
            "file": "astropy/units/quantity.py",
            "class": "",
            "method": "decompose()",
            "intended_behavior": "The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format."
        }
    ]
}
2025-10-17 22:18:51.700 | DEBUG    | Bug location extracted successfully: [<file>astropy/units/format/console.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Handles the "Console" unit format.
5 """
6 
7 
8 from . import base, core, utils
9 
10 
11 class Console(base.Base):
12     """
13     Output-only format for to display pretty formatting at the
14     console.
15 
16     For example::
17 
18       >>> import astropy.units as u
19       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP
20       2.1798721*10^-18m^2 kg s^-2
21       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP
22                        m^2 kg
23       2.1798721*10^-18 ------
24                         s^2
25     """
26 
27     _times = "*"
28     _line = "-"
29 
30     @classmethod
31     def _get_unit_name(cls, unit):
32         return unit.get_format_name("console")
33 
34     @classmethod
35     def _format_superscript(cls, number):
36         return f"^{number}"
37 
38     @classmethod
39     def _format_unit_list(cls, units):
40         out = []
41         for base_, power in units:
42             if power == 1:
43                 out.append(cls._get_unit_name(base_))
44             else:
45                 out.append(
46                     cls._get_unit_name(base_)
47                     + cls._format_superscript(utils.format_power(power))
48                 )
49         return " ".join(out)
50 
51     @classmethod
52     def format_exponential_notation(cls, val):
53         m, ex = utils.split_mantissa_exponent(val)
54 
55         parts = []
56         if m:
57             parts.append(m)
58 
59         if ex:
60             parts.append(f"10{cls._format_superscript(ex)}")
61 
62         return cls._times.join(parts)
63 
64     @classmethod
65     def to_string(cls, unit, inline=True):
66         if isinstance(unit, core.CompositeUnit):
67             if unit.scale == 1:
68                 s = ""
69             else:
70                 s = cls.format_exponential_notation(unit.scale)
71 
72             if len(unit.bases):
73                 if inline:
74                     nominator = zip(unit.bases, unit.powers)
75                     denominator = []
76                 else:
77                     nominator, denominator = utils.get_grouped_by_powers(
78                         unit.bases, unit.powers
79                     )
80                 if len(denominator):
81                     if len(nominator):
82                         nominator = cls._format_unit_list(nominator)
83                     else:
84                         nominator = "1"
85                     denominator = cls._format_unit_list(denominator)
86                     fraclength = max(len(nominator), len(denominator))
87                     f = f"{{0:^{len(s)}s}} {{1:^{fraclength}s}}"
88 
89                     lines = [
90                         f.format("", nominator),
91                         f.format(s, cls._line * fraclength),
92                         f.format("", denominator),
93                     ]
94 
95                     s = "\n".join(lines)
96                 else:
97                     nominator = cls._format_unit_list(nominator)
98                     s += nominator
99         elif isinstance(unit, core.NamedUnit):
100             s = cls._get_unit_name(unit)
101 
102         return s

</code><intended_behavior>The method responsible for formatting units in console format should ensure that it does not prepend a space to the unit string unless necessary for proper formatting. This behavior should be consistent, regardless of whether a unit scale factor is present or not. Adjustments might be needed to the logic that inserts spaces to only do so when part of the unit representation requires it, not as a default behavior for all unit strings.</intended_behavior>, <file>astropy/units/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Core units classes and functions.
5 """
6 
7 
8 import inspect
9 import operator
10 import textwrap
11 import warnings
12 
13 import numpy as np
14 
15 from astropy.utils.decorators import lazyproperty
16 from astropy.utils.exceptions import AstropyWarning
17 from astropy.utils.misc import isiterable
18 
19 from . import format as unit_format
20 from .utils import (
21     is_effectively_unity,
22     resolve_fractions,
23     sanitize_scale,
24     validate_power,
25 )
26 
27 __all__ = [
28     "UnitsError",
29     "UnitsWarning",
30     "UnitConversionError",
31     "UnitTypeError",
32     "UnitBase",
33     "NamedUnit",
34     "IrreducibleUnit",
35     "Unit",
36     "CompositeUnit",
37     "PrefixUnit",
38     "UnrecognizedUnit",
39     "def_unit",
40     "get_current_unit_registry",
41     "set_enabled_units",
42     "add_enabled_units",
43     "set_enabled_equivalencies",
44     "add_enabled_equivalencies",
45     "set_enabled_aliases",
46     "add_enabled_aliases",
47     "dimensionless_unscaled",
48     "one",
49 ]
50 
51 UNITY = 1.0
52 
53 
54 def _flatten_units_collection(items):
55     """
56     Given a list of sequences, modules or dictionaries of units, or
57     single units, return a flat set of all the units found.
58     """
59     if not isinstance(items, list):
60         items = [items]
61 
62     result = set()
63     for item in items:
64         if isinstance(item, UnitBase):
65             result.add(item)
66         else:
67             if isinstance(item, dict):
68                 units = item.values()
69             elif inspect.ismodule(item):
70                 units = vars(item).values()
71             elif isiterable(item):
72                 units = item
73             else:
74                 continue
75 
76             for unit in units:
77                 if isinstance(unit, UnitBase):
78                     result.add(unit)
79 
80     return result
81 
82 
83 def _normalize_equivalencies(equivalencies):
84     """Normalizes equivalencies ensuring each is a 4-tuple.
85 
86     The resulting tuple is of the form::
87 
88         (from_unit, to_unit, forward_func, backward_func)
89 
90     Parameters
91     ----------
92     equivalencies : list of equivalency pairs
93 
94     Raises
95     ------
96     ValueError if an equivalency cannot be interpreted
97     """
98     if equivalencies is None:
99         return []
100 
101     normalized = []
102 
103     for i, equiv in enumerate(equivalencies):
104         if len(equiv) == 2:
105             funit, tunit = equiv
106             a = b = lambda x: x
107         elif len(equiv) == 3:
108             funit, tunit, a = equiv
109             b = a
110         elif len(equiv) == 4:
111             funit, tunit, a, b = equiv
112         else:
113             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
114         if not (
115             funit is Unit(funit)
116             and (tunit is None or tunit is Unit(tunit))
117             and callable(a)
118             and callable(b)
119         ):
120             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
121         normalized.append((funit, tunit, a, b))
122 
123     return normalized
124 
125 
126 class _UnitRegistry:
127     """
128     Manages a registry of the enabled units.
129     """
130 
131     def __init__(self, init=[], equivalencies=[], aliases={}):
132         if isinstance(init, _UnitRegistry):
133             # If passed another registry we don't need to rebuild everything.
134             # but because these are mutable types we don't want to create
135             # conflicts so everything needs to be copied.
136             self._equivalencies = init._equivalencies.copy()
137             self._aliases = init._aliases.copy()
138             self._all_units = init._all_units.copy()
139             self._registry = init._registry.copy()
140             self._non_prefix_units = init._non_prefix_units.copy()
141             # The physical type is a dictionary containing sets as values.
142             # All of these must be copied otherwise we could alter the old
143             # registry.
144             self._by_physical_type = {
145                 k: v.copy() for k, v in init._by_physical_type.items()
146             }
147 
148         else:
149             self._reset_units()
150             self._reset_equivalencies()
151             self._reset_aliases()
152             self.add_enabled_units(init)
153             self.add_enabled_equivalencies(equivalencies)
154             self.add_enabled_aliases(aliases)
155 
156     def _reset_units(self):
157         self._all_units = set()
158         self._non_prefix_units = set()
159         self._registry = {}
160         self._by_physical_type = {}
161 
162     def _reset_equivalencies(self):
163         self._equivalencies = set()
164 
165     def _reset_aliases(self):
166         self._aliases = {}
167 
168     @property
169     def registry(self):
170         return self._registry
171 
172     @property
173     def all_units(self):
174         return self._all_units
175 
176     @property
177     def non_prefix_units(self):
178         return self._non_prefix_units
179 
180     def set_enabled_units(self, units):
181         """
182         Sets the units enabled in the unit registry.
183 
184         These units are searched when using
185         `UnitBase.find_equivalent_units`, for example.
186 
187         Parameters
188         ----------
189         units : list of sequence, dict, or module
190             This is a list of things in which units may be found
191             (sequences, dicts or modules), or units themselves.  The
192             entire set will be "enabled" for searching through by
193             methods like `UnitBase.find_equivalent_units` and
194             `UnitBase.compose`.
195         """
196         self._reset_units()
197         return self.add_enabled_units(units)
198 
199     def add_enabled_units(self, units):
200         """
201         Adds to the set of units enabled in the unit registry.
202 
203         These units are searched when using
204         `UnitBase.find_equivalent_units`, for example.
205 
206         Parameters
207         ----------
208         units : list of sequence, dict, or module
209             This is a list of things in which units may be found
210             (sequences, dicts or modules), or units themselves.  The
211             entire set will be added to the "enabled" set for
212             searching through by methods like
213             `UnitBase.find_equivalent_units` and `UnitBase.compose`.
214         """
215         units = _flatten_units_collection(units)
216 
217         for unit in units:
218             # Loop through all of the names first, to ensure all of them
219             # are new, then add them all as a single "transaction" below.
220             for st in unit._names:
221                 if st in self._registry and unit != self._registry[st]:
222                     raise ValueError(
223                         f"Object with name {st!r} already exists in namespace. "
224                         "Filter the set of units to avoid name clashes before "
225                         "enabling them."
226                     )
227 
228             for st in unit._names:
229                 self._registry[st] = unit
230 
231             self._all_units.add(unit)
232             if not isinstance(unit, PrefixUnit):
233                 self._non_prefix_units.add(unit)
234 
235             hash = unit._get_physical_type_id()
236             self._by_physical_type.setdefault(hash, set()).add(unit)
237 
238     def get_units_with_physical_type(self, unit):
239         """
240         Get all units in the registry with the same physical type as
241         the given unit.
242 
243         Parameters
244         ----------
245         unit : UnitBase instance
246         """
247         return self._by_physical_type.get(unit._get_physical_type_id(), set())
248 
249     @property
250     def equivalencies(self):
251         return list(self._equivalencies)
252 
253     def set_enabled_equivalencies(self, equivalencies):
254         """
255         Sets the equivalencies enabled in the unit registry.
256 
257         These equivalencies are used if no explicit equivalencies are given,
258         both in unit conversion and in finding equivalent units.
259 
260         This is meant in particular for allowing angles to be dimensionless.
261         Use with care.
262 
263         Parameters
264         ----------
265         equivalencies : list of tuple
266             List of equivalent pairs, e.g., as returned by
267             `~astropy.units.equivalencies.dimensionless_angles`.
268         """
269         self._reset_equivalencies()
270         return self.add_enabled_equivalencies(equivalencies)
271 
272     def add_enabled_equivalencies(self, equivalencies):
273         """
274         Adds to the set of equivalencies enabled in the unit registry.
275 
276         These equivalencies are used if no explicit equivalencies are given,
277         both in unit conversion and in finding equivalent units.
278 
279         This is meant in particular for allowing angles to be dimensionless.
280         Use with care.
281 
282         Parameters
283         ----------
284         equivalencies : list of tuple
285             List of equivalent pairs, e.g., as returned by
286             `~astropy.units.equivalencies.dimensionless_angles`.
287         """
288         # pre-normalize list to help catch mistakes
289         equivalencies = _normalize_equivalencies(equivalencies)
290         self._equivalencies |= set(equivalencies)
291 
292     @property
293     def aliases(self):
294         return self._aliases
295 
296     def set_enabled_aliases(self, aliases):
297         """
298         Set aliases for units.
299 
300         Parameters
301         ----------
302         aliases : dict of str, Unit
303             The aliases to set. The keys must be the string aliases, and values
304             must be the `astropy.units.Unit` that the alias will be mapped to.
305 
306         Raises
307         ------
308         ValueError
309             If the alias already defines a different unit.
310 
311         """
312         self._reset_aliases()
313         self.add_enabled_aliases(aliases)
314 
315     def add_enabled_aliases(self, aliases):
316         """
317         Add aliases for units.
318 
319         Parameters
320         ----------
321         aliases : dict of str, Unit
322             The aliases to add. The keys must be the string aliases, and values
323             must be the `astropy.units.Unit` that the alias will be mapped to.
324 
325         Raises
326         ------
327         ValueError
328             If the alias already defines a different unit.
329 
330         """
331         for alias, unit in aliases.items():
332             if alias in self._registry and unit != self._registry[alias]:
333                 raise ValueError(
334                     f"{alias} already means {self._registry[alias]}, so "
335                     f"cannot be used as an alias for {unit}."
336                 )
337             if alias in self._aliases and unit != self._aliases[alias]:
338                 raise ValueError(
339                     f"{alias} already is an alias for {self._aliases[alias]}, so "
340                     f"cannot be used as an alias for {unit}."
341                 )
342 
343         for alias, unit in aliases.items():
344             if alias not in self._registry and alias not in self._aliases:
345                 self._aliases[alias] = unit
346 
347 
348 class _UnitContext:
349     def __init__(self, init=[], equivalencies=[]):
350         _unit_registries.append(_UnitRegistry(init=init, equivalencies=equivalencies))
351 
352     def __enter__(self):
353         pass
354 
355     def __exit__(self, type, value, tb):
356         _unit_registries.pop()
357 
358 
359 _unit_registries = [_UnitRegistry()]
360 
361 
362 def get_current_unit_registry():
363     return _unit_registries[-1]
364 
365 
366 def set_enabled_units(units):
367     """
368     Sets the units enabled in the unit registry.
369 
370     These units are searched when using
371     `UnitBase.find_equivalent_units`, for example.
372 
373     This may be used either permanently, or as a context manager using
374     the ``with`` statement (see example below).
375 
376     Parameters
377     ----------
378     units : list of sequence, dict, or module
379         This is a list of things in which units may be found
380         (sequences, dicts or modules), or units themselves.  The
381         entire set will be "enabled" for searching through by methods
382         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.
383 
384     Examples
385     --------
386     >>> from astropy import units as u
387     >>> with u.set_enabled_units([u.pc]):
388     ...     u.m.find_equivalent_units()
389     ...
390       Primary name | Unit definition | Aliases
391     [
392       pc           | 3.08568e+16 m   | parsec  ,
393     ]
394     >>> u.m.find_equivalent_units()
395       Primary name | Unit definition | Aliases
396     [
397       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
398       Angstrom     | 1e-10 m         | AA, angstrom                     ,
399       cm           | 0.01 m          | centimeter                       ,
400       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
401       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
402       lsec         | 2.99792e+08 m   | lightsecond                      ,
403       lyr          | 9.46073e+15 m   | lightyear                        ,
404       m            | irreducible     | meter                            ,
405       micron       | 1e-06 m         |                                  ,
406       pc           | 3.08568e+16 m   | parsec                           ,
407       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
408     ]
409     """
410     # get a context with a new registry, using equivalencies of the current one
411     context = _UnitContext(equivalencies=get_current_unit_registry().equivalencies)
412     # in this new current registry, enable the units requested
413     get_current_unit_registry().set_enabled_units(units)
414     return context
415 
416 
417 def add_enabled_units(units):
418     """
419     Adds to the set of units enabled in the unit registry.
420 
421     These units are searched when using
422     `UnitBase.find_equivalent_units`, for example.
423 
424     This may be used either permanently, or as a context manager using
425     the ``with`` statement (see example below).
426 
427     Parameters
428     ----------
429     units : list of sequence, dict, or module
430         This is a list of things in which units may be found
431         (sequences, dicts or modules), or units themselves.  The
432         entire set will be added to the "enabled" set for searching
433         through by methods like `UnitBase.find_equivalent_units` and
434         `UnitBase.compose`.
435 
436     Examples
437     --------
438     >>> from astropy import units as u
439     >>> from astropy.units import imperial
440     >>> with u.add_enabled_units(imperial):
441     ...     u.m.find_equivalent_units()
442     ...
443       Primary name | Unit definition | Aliases
444     [
445       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
446       Angstrom     | 1e-10 m         | AA, angstrom                     ,
447       cm           | 0.01 m          | centimeter                       ,
448       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
449       ft           | 0.3048 m        | foot                             ,
450       fur          | 201.168 m       | furlong                          ,
451       inch         | 0.0254 m        |                                  ,
452       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
453       lsec         | 2.99792e+08 m   | lightsecond                      ,
454       lyr          | 9.46073e+15 m   | lightyear                        ,
455       m            | irreducible     | meter                            ,
456       mi           | 1609.34 m       | mile                             ,
457       micron       | 1e-06 m         |                                  ,
458       mil          | 2.54e-05 m      | thou                             ,
459       nmi          | 1852 m          | nauticalmile, NM                 ,
460       pc           | 3.08568e+16 m   | parsec                           ,
461       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
462       yd           | 0.9144 m        | yard                             ,
463     ]
464     """
465     # get a context with a new registry, which is a copy of the current one
466     context = _UnitContext(get_current_unit_registry())
467     # in this new current registry, enable the further units requested
468     get_current_unit_registry().add_enabled_units(units)
469     return context
470 
471 
472 def set_enabled_equivalencies(equivalencies):
473     """
474     Sets the equivalencies enabled in the unit registry.
475 
476     These equivalencies are used if no explicit equivalencies are given,
477     both in unit conversion and in finding equivalent units.
478 
479     This is meant in particular for allowing angles to be dimensionless.
480     Use with care.
481 
482     Parameters
483     ----------
484     equivalencies : list of tuple
485         list of equivalent pairs, e.g., as returned by
486         `~astropy.units.equivalencies.dimensionless_angles`.
487 
488     Examples
489     --------
490     Exponentiation normally requires dimensionless quantities.  To avoid
491     problems with complex phases::
492 
493         >>> from astropy import units as u
494         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):
495         ...     phase = 0.5 * u.cycle
496         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP
497         <Quantity -1.+1.2246468e-16j>
498     """
499     # get a context with a new registry, using all units of the current one
500     context = _UnitContext(get_current_unit_registry())
501     # in this new current registry, enable the equivalencies requested
502     get_current_unit_registry().set_enabled_equivalencies(equivalencies)
503     return context
504 
505 
506 def add_enabled_equivalencies(equivalencies):
507     """
508     Adds to the equivalencies enabled in the unit registry.
509 
510     These equivalencies are used if no explicit equivalencies are given,
511     both in unit conversion and in finding equivalent units.
512 
513     This is meant in particular for allowing angles to be dimensionless.
514     Since no equivalencies are enabled by default, generally it is recommended
515     to use `set_enabled_equivalencies`.
516 
517     Parameters
518     ----------
519     equivalencies : list of tuple
520         list of equivalent pairs, e.g., as returned by
521         `~astropy.units.equivalencies.dimensionless_angles`.
522     """
523     # get a context with a new registry, which is a copy of the current one
524     context = _UnitContext(get_current_unit_registry())
525     # in this new current registry, enable the further equivalencies requested
526     get_current_unit_registry().add_enabled_equivalencies(equivalencies)
527     return context
528 
529 
530 def set_enabled_aliases(aliases):
531     """
532     Set aliases for units.
533 
534     This is useful for handling alternate spellings for units, or
535     misspelled units in files one is trying to read.
536 
537     Parameters
538     ----------
539     aliases : dict of str, Unit
540         The aliases to set. The keys must be the string aliases, and values
541         must be the `astropy.units.Unit` that the alias will be mapped to.
542 
543     Raises
544     ------
545     ValueError
546         If the alias already defines a different unit.
547 
548     Examples
549     --------
550     To temporarily allow for a misspelled 'Angstroem' unit::
551 
552         >>> from astropy import units as u
553         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):
554         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
555         True
556 
557     """
558     # get a context with a new registry, which is a copy of the current one
559     context = _UnitContext(get_current_unit_registry())
560     # in this new current registry, enable the further equivalencies requested
561     get_current_unit_registry().set_enabled_aliases(aliases)
562     return context
563 
564 
565 def add_enabled_aliases(aliases):
566     """
567     Add aliases for units.
568 
569     This is useful for handling alternate spellings for units, or
570     misspelled units in files one is trying to read.
571 
572     Since no aliases are enabled by default, generally it is recommended
573     to use `set_enabled_aliases`.
574 
575     Parameters
576     ----------
577     aliases : dict of str, Unit
578         The aliases to add. The keys must be the string aliases, and values
579         must be the `astropy.units.Unit` that the alias will be mapped to.
580 
581     Raises
582     ------
583     ValueError
584         If the alias already defines a different unit.
585 
586     Examples
587     --------
588     To temporarily allow for a misspelled 'Angstroem' unit::
589 
590         >>> from astropy import units as u
591         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):
592         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
593         True
594 
595     """
596     # get a context with a new registry, which is a copy of the current one
597     context = _UnitContext(get_current_unit_registry())
598     # in this new current registry, enable the further equivalencies requested
599     get_current_unit_registry().add_enabled_aliases(aliases)
600     return context
601 
602 
603 class UnitsError(Exception):
604     """
605     The base class for unit-specific exceptions.
606     """
607 
608 
609 class UnitScaleError(UnitsError, ValueError):
610     """
611     Used to catch the errors involving scaled units,
612     which are not recognized by FITS format.
613     """
614 
615     pass
616 
617 
618 class UnitConversionError(UnitsError, ValueError):
619     """
620     Used specifically for errors related to converting between units or
621     interpreting units in terms of other units.
622     """
623 
624 
625 class UnitTypeError(UnitsError, TypeError):
626     """
627     Used specifically for errors in setting to units not allowed by a class.
628 
629     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`
630     instances were set to a non-angular unit.
631     """
632 
633 
634 class UnitsWarning(AstropyWarning):
635     """
636     The base class for unit-specific warnings.
637     """
638 
639 
640 class UnitBase:
641     """
642     Abstract base class for units.
643 
644     Most of the arithmetic operations on units are defined in this
645     base class.
646 
647     Should not be instantiated by users directly.
648     """
649 
650     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy
651     # arrays to avoid element-wise multiplication.
652     __array_priority__ = 1000
653 
654     _hash = None
655     _type_id = None
656 
657     def __deepcopy__(self, memo):
658         # This may look odd, but the units conversion will be very
659         # broken after deep-copying if we don't guarantee that a given
660         # physical unit corresponds to only one instance
661         return self
662 
663     def _repr_latex_(self):
664         """
665         Generate latex representation of unit name.  This is used by
666         the IPython notebook to print a unit with a nice layout.
667 
668         Returns
669         -------
670         Latex string
671         """
672         return unit_format.Latex.to_string(self)
673 
674     def __bytes__(self):
675         """Return string representation for unit."""
676         return unit_format.Generic.to_string(self).encode("unicode_escape")
677 
678     def __str__(self):
679         """Return string representation for unit."""
680         return unit_format.Generic.to_string(self)
681 
682     def __repr__(self):
683         string = unit_format.Generic.to_string(self)
684 
685         return f'Unit("{string}")'
686 
687     def _get_physical_type_id(self):
688         """
689         Returns an identifier that uniquely identifies the physical
690         type of this unit.  It is comprised of the bases and powers of
691         this unit, without the scale.  Since it is hashable, it is
692         useful as a dictionary key.
693         """
694         if self._type_id is None:
695             unit = self.decompose()
696             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))
697 
698         return self._type_id
699 
700     @property
701     def names(self):
702         """
703         Returns all of the names associated with this unit.
704         """
705         raise AttributeError(
706             "Can not get names from unnamed units. Perhaps you meant to_string()?"
707         )
708 
709     @property
710     def name(self):
711         """
712         Returns the canonical (short) name associated with this unit.
713         """
714         raise AttributeError(
715             "Can not get names from unnamed units. Perhaps you meant to_string()?"
716         )
717 
718     @property
719     def aliases(self):
720         """
721         Returns the alias (long) names for this unit.
722         """
723         raise AttributeError(
724             "Can not get aliases from unnamed units. Perhaps you meant to_string()?"
725         )
726 
727     @property
728     def scale(self):
729         """
730         Return the scale of the unit.
731         """
732         return 1.0
733 
734     @property
735     def bases(self):
736         """
737         Return the bases of the unit.
738         """
739         return [self]
740 
741     @property
742     def powers(self):
743         """
744         Return the powers of the unit.
745         """
746         return [1]
747 
748     def to_string(self, format=unit_format.Generic, **kwargs):
749         """Output the unit in the given format as a string.
750 
751         Parameters
752         ----------
753         format : `astropy.units.format.Base` instance or str
754             The name of a format or a formatter object.  If not
755             provided, defaults to the generic format.
756 
757         **kwargs :
758             Further options forwarded to the formatter. Currently
759             recognized is **inline** (:class:`bool`) for the
760             ``"latex"``, ``"console"``, and``"unicode"`` formats.
761 
762         """
763         f = unit_format.get_format(format)
764         return f.to_string(self, **kwargs)
765 
766     def __format__(self, format_spec):
767         """Try to format units using a formatter."""
768         try:
769             return self.to_string(format=format_spec)
770         except ValueError:
771             return format(str(self), format_spec)
772 
773     @staticmethod
774     def _normalize_equivalencies(equivalencies):
775         """Normalizes equivalencies, ensuring each is a 4-tuple.
776 
777         The resulting tuple is of the form::
778 
779             (from_unit, to_unit, forward_func, backward_func)
780 
781         Parameters
782         ----------
783         equivalencies : list of equivalency pairs, or None
784 
785         Returns
786         -------
787         A normalized list, including possible global defaults set by, e.g.,
788         `set_enabled_equivalencies`, except when `equivalencies`=`None`,
789         in which case the returned list is always empty.
790 
791         Raises
792         ------
793         ValueError if an equivalency cannot be interpreted
794         """
795         normalized = _normalize_equivalencies(equivalencies)
796         if equivalencies is not None:
797             normalized += get_current_unit_registry().equivalencies
798 
799         return normalized
800 
801     def __pow__(self, p):
802         p = validate_power(p)
803         return CompositeUnit(1, [self], [p], _error_check=False)
804 
805     def __truediv__(self, m):
806         if isinstance(m, (bytes, str)):
807             m = Unit(m)
808 
809         if isinstance(m, UnitBase):
810             if m.is_unity():
811                 return self
812             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)
813 
814         try:
815             # Cannot handle this as Unit, re-try as Quantity
816             from .quantity import Quantity
817 
818             return Quantity(1, self) / m
819         except TypeError:
820             return NotImplemented
821 
822     def __rtruediv__(self, m):
823         if isinstance(m, (bytes, str)):
824             return Unit(m) / self
825 
826         try:
827             # Cannot handle this as Unit.  Here, m cannot be a Quantity,
828             # so we make it into one, fasttracking when it does not have a
829             # unit, for the common case of <array> / <unit>.
830             from .quantity import Quantity
831 
832             if hasattr(m, "unit"):
833                 result = Quantity(m)
834                 result /= self
835                 return result
836             else:
837                 return Quantity(m, self ** (-1))
838         except TypeError:
839             return NotImplemented
840 
841     def __mul__(self, m):
842         if isinstance(m, (bytes, str)):
843             m = Unit(m)
844 
845         if isinstance(m, UnitBase):
846             if m.is_unity():
847                 return self
848             elif self.is_unity():
849                 return m
850             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)
851 
852         # Cannot handle this as Unit, re-try as Quantity.
853         try:
854             from .quantity import Quantity
855 
856             return Quantity(1, unit=self) * m
857         except TypeError:
858             return NotImplemented
859 
860     def __rmul__(self, m):
861         if isinstance(m, (bytes, str)):
862             return Unit(m) * self
863 
864         # Cannot handle this as Unit.  Here, m cannot be a Quantity,
865         # so we make it into one, fasttracking when it does not have a unit
866         # for the common case of <array> * <unit>.
867         try:
868             from .quantity import Quantity
869 
870             if hasattr(m, "unit"):
871                 result = Quantity(m)
872                 result *= self
873                 return result
874             else:
875                 return Quantity(m, unit=self)
876         except TypeError:
877             return NotImplemented
878 
879     def __rlshift__(self, m):
880         try:
881             from .quantity import Quantity
882 
883             return Quantity(m, self, copy=False, subok=True)
884         except Exception:
885             return NotImplemented
886 
887     def __rrshift__(self, m):
888         warnings.warn(
889             ">> is not implemented. Did you mean to convert "
890             f"to a Quantity with unit {m} using '<<'?",
891             AstropyWarning,
892         )
893         return NotImplemented
894 
895     def __hash__(self):
896         if self._hash is None:
897             parts = (
898                 [str(self.scale)]
899                 + [x.name for x in self.bases]
900                 + [str(x) for x in self.powers]
901             )
902             self._hash = hash(tuple(parts))
903         return self._hash
904 
905     def __getstate__(self):
906         # If we get pickled, we should *not* store the memoized members since
907         # hashes of strings vary between sessions.
908         state = self.__dict__.copy()
909         state.pop("_hash", None)
910         state.pop("_type_id", None)
911         return state
912 
913     def __eq__(self, other):
914         if self is other:
915             return True
916 
917         try:
918             other = Unit(other, parse_strict="silent")
919         except (ValueError, UnitsError, TypeError):
920             return NotImplemented
921 
922         # Other is unit-like, but the test below requires it is a UnitBase
923         # instance; if it is not, give up (so that other can try).
924         if not isinstance(other, UnitBase):
925             return NotImplemented
926 
927         try:
928             return is_effectively_unity(self._to(other))
929         except UnitsError:
930             return False
931 
932     def __ne__(self, other):
933         return not (self == other)
934 
935     def __le__(self, other):
936         scale = self._to(Unit(other))
937         return scale <= 1.0 or is_effectively_unity(scale)
938 
939     def __ge__(self, other):
940         scale = self._to(Unit(other))
941         return scale >= 1.0 or is_effectively_unity(scale)
942 
943     def __lt__(self, other):
944         return not (self >= other)
945 
946     def __gt__(self, other):
947         return not (self <= other)
948 
949     def __neg__(self):
950         return self * -1.0
951 
952     def is_equivalent(self, other, equivalencies=[]):
953         """
954         Returns `True` if this unit is equivalent to ``other``.
955 
956         Parameters
957         ----------
958         other : `~astropy.units.Unit`, str, or tuple
959             The unit to convert to. If a tuple of units is specified, this
960             method returns true if the unit matches any of those in the tuple.
961 
962         equivalencies : list of tuple
963             A list of equivalence pairs to try if the units are not
964             directly convertible.  See :ref:`astropy:unit_equivalencies`.
965             This list is in addition to possible global defaults set by, e.g.,
966             `set_enabled_equivalencies`.
967             Use `None` to turn off all equivalencies.
968 
969         Returns
970         -------
971         bool
972         """
973         equivalencies = self._normalize_equivalencies(equivalencies)
974 
975         if isinstance(other, tuple):
976             return any(self.is_equivalent(u, equivalencies) for u in other)
977 
978         other = Unit(other, parse_strict="silent")
979 
980         return self._is_equivalent(other, equivalencies)
981 
982     def _is_equivalent(self, other, equivalencies=[]):
983         """Returns `True` if this unit is equivalent to `other`.
984         See `is_equivalent`, except that a proper Unit object should be
985         given (i.e., no string) and that the equivalency list should be
986         normalized using `_normalize_equivalencies`.
987         """
988         if isinstance(other, UnrecognizedUnit):
989             return False
990 
991         if self._get_physical_type_id() == other._get_physical_type_id():
992             return True
993         elif len(equivalencies):
994             unit = self.decompose()
995             other = other.decompose()
996             for a, b, forward, backward in equivalencies:
997                 if b is None:
998                     # after canceling, is what's left convertible
999                     # to dimensionless (according to the equivalency)?
1000                     try:
1001                         (other / unit).decompose([a])
1002                         return True
1003                     except Exception:
1004                         pass
1005                 elif (a._is_equivalent(unit) and b._is_equivalent(other)) or (
1006                     b._is_equivalent(unit) and a._is_equivalent(other)
1007                 ):
1008                     return True
1009 
1010         return False
1011 
1012     def _apply_equivalencies(self, unit, other, equivalencies):
1013         """
1014         Internal function (used from `_get_converter`) to apply
1015         equivalence pairs.
1016         """
1017 
1018         def make_converter(scale1, func, scale2):
1019             def convert(v):
1020                 return func(_condition_arg(v) / scale1) * scale2
1021 
1022             return convert
1023 
1024         for funit, tunit, a, b in equivalencies:
1025             if tunit is None:
1026                 ratio = other.decompose() / unit.decompose()
1027                 try:
1028                     ratio_in_funit = ratio.decompose([funit])
1029                     return make_converter(ratio_in_funit.scale, a, 1.0)
1030                 except UnitsError:
1031                     pass
1032             else:
1033                 try:
1034                     scale1 = funit._to(unit)
1035                     scale2 = tunit._to(other)
1036                     return make_converter(scale1, a, scale2)
1037                 except UnitsError:
1038                     pass
1039                 try:
1040                     scale1 = tunit._to(unit)
1041                     scale2 = funit._to(other)
1042                     return make_converter(scale1, b, scale2)
1043                 except UnitsError:
1044                     pass
1045 
1046         def get_err_str(unit):
1047             unit_str = unit.to_string("unscaled")
1048             physical_type = unit.physical_type
1049             if physical_type != "unknown":
1050                 unit_str = f"'{unit_str}' ({physical_type})"
1051             else:
1052                 unit_str = f"'{unit_str}'"
1053             return unit_str
1054 
1055         unit_str = get_err_str(unit)
1056         other_str = get_err_str(other)
1057 
1058         raise UnitConversionError(f"{unit_str} and {other_str} are not convertible")
1059 
1060     def _get_converter(self, other, equivalencies=[]):
1061         """Get a converter for values in ``self`` to ``other``.
1062 
1063         If no conversion is necessary, returns ``unit_scale_converter``
1064         (which is used as a check in quantity helpers).
1065 
1066         """
1067         # First see if it is just a scaling.
1068         try:
1069             scale = self._to(other)
1070         except UnitsError:
1071             pass
1072         else:
1073             if scale == 1.0:
1074                 return unit_scale_converter
1075             else:
1076                 return lambda val: scale * _condition_arg(val)
1077 
1078         # if that doesn't work, maybe we can do it with equivalencies?
1079         try:
1080             return self._apply_equivalencies(
1081                 self, other, self._normalize_equivalencies(equivalencies)
1082             )
1083         except UnitsError as exc:
1084             # Last hope: maybe other knows how to do it?
1085             # We assume the equivalencies have the unit itself as first item.
1086             # TODO: maybe better for other to have a `_back_converter` method?
1087             if hasattr(other, "equivalencies"):
1088                 for funit, tunit, a, b in other.equivalencies:
1089                     if other is funit:
1090                         try:
1091                             converter = self._get_converter(tunit, equivalencies)
1092                         except Exception:
1093                             pass
1094                         else:
1095                             return lambda v: b(converter(v))
1096 
1097             raise exc
1098 
1099     def _to(self, other):
1100         """
1101         Returns the scale to the specified unit.
1102 
1103         See `to`, except that a Unit object should be given (i.e., no
1104         string), and that all defaults are used, i.e., no
1105         equivalencies and value=1.
1106         """
1107         # There are many cases where we just want to ensure a Quantity is
1108         # of a particular unit, without checking whether it's already in
1109         # a particular unit.  If we're being asked to convert from a unit
1110         # to itself, we can short-circuit all of this.
1111         if self is other:
1112             return 1.0
1113 
1114         # Don't presume decomposition is possible; e.g.,
1115         # conversion to function units is through equivalencies.
1116         if isinstance(other, UnitBase):
1117             self_decomposed = self.decompose()
1118             other_decomposed = other.decompose()
1119 
1120             # Check quickly whether equivalent.  This is faster than
1121             # `is_equivalent`, because it doesn't generate the entire
1122             # physical type list of both units.  In other words it "fails
1123             # fast".
1124             if self_decomposed.powers == other_decomposed.powers and all(
1125                 self_base is other_base
1126                 for (self_base, other_base) in zip(
1127                     self_decomposed.bases, other_decomposed.bases
1128                 )
1129             ):
1130                 return self_decomposed.scale / other_decomposed.scale
1131 
1132         raise UnitConversionError(f"'{self!r}' is not a scaled version of '{other!r}'")
1133 
1134     def to(self, other, value=UNITY, equivalencies=[]):
1135         """
1136         Return the converted values in the specified unit.
1137 
1138         Parameters
1139         ----------
1140         other : unit-like
1141             The unit to convert to.
1142 
1143         value : int, float, or scalar array-like, optional
1144             Value(s) in the current unit to be converted to the
1145             specified unit.  If not provided, defaults to 1.0
1146 
1147         equivalencies : list of tuple
1148             A list of equivalence pairs to try if the units are not
1149             directly convertible.  See :ref:`astropy:unit_equivalencies`.
1150             This list is in addition to possible global defaults set by, e.g.,
1151             `set_enabled_equivalencies`.
1152             Use `None` to turn off all equivalencies.
1153 
1154         Returns
1155         -------
1156         values : scalar or array
1157             Converted value(s). Input value sequences are returned as
1158             numpy arrays.
1159 
1160         Raises
1161         ------
1162         UnitsError
1163             If units are inconsistent
1164         """
1165         if other is self and value is UNITY:
1166             return UNITY
1167         else:
1168             return self._get_converter(Unit(other), equivalencies)(value)
1169 
1170     def in_units(self, other, value=1.0, equivalencies=[]):
1171         """
1172         Alias for `to` for backward compatibility with pynbody.
1173         """
1174         return self.to(other, value=value, equivalencies=equivalencies)
1175 
1176     def decompose(self, bases=set()):
1177         """
1178         Return a unit object composed of only irreducible units.
1179 
1180         Parameters
1181         ----------
1182         bases : sequence of UnitBase, optional
1183             The bases to decompose into.  When not provided,
1184             decomposes down to any irreducible units.  When provided,
1185             the decomposed result will only contain the given units.
1186             This will raises a `UnitsError` if it's not possible
1187             to do so.
1188 
1189         Returns
1190         -------
1191         unit : `~astropy.units.CompositeUnit`
1192             New object containing only irreducible unit objects.
1193         """
1194         raise NotImplementedError()
1195 
1196     def _compose(
1197         self, equivalencies=[], namespace=[], max_depth=2, depth=0, cached_results=None
1198     ):
1199         def is_final_result(unit):
1200             # Returns True if this result contains only the expected
1201             # units
1202             return all(base in namespace for base in unit.bases)
1203 
1204         unit = self.decompose()
1205         key = hash(unit)
1206 
1207         cached = cached_results.get(key)
1208         if cached is not None:
1209             if isinstance(cached, Exception):
1210                 raise cached
1211             return cached
1212 
1213         # Prevent too many levels of recursion
1214         # And special case for dimensionless unit
1215         if depth >= max_depth:
1216             cached_results[key] = [unit]
1217             return [unit]
1218 
1219         # Make a list including all of the equivalent units
1220         units = [unit]
1221         for funit, tunit, a, b in equivalencies:
1222             if tunit is not None:
1223                 if self._is_equivalent(funit):
1224                     scale = funit.decompose().scale / unit.scale
1225                     units.append(Unit(a(1.0 / scale) * tunit).decompose())
1226                 elif self._is_equivalent(tunit):
1227                     scale = tunit.decompose().scale / unit.scale
1228                     units.append(Unit(b(1.0 / scale) * funit).decompose())
1229             else:
1230                 if self._is_equivalent(funit):
1231                     units.append(Unit(unit.scale))
1232 
1233         # Store partial results
1234         partial_results = []
1235         # Store final results that reduce to a single unit or pair of
1236         # units
1237         if len(unit.bases) == 0:
1238             final_results = [{unit}, set()]
1239         else:
1240             final_results = [set(), set()]
1241 
1242         for tunit in namespace:
1243             tunit_decomposed = tunit.decompose()
1244             for u in units:
1245                 # If the unit is a base unit, look for an exact match
1246                 # to one of the bases of the target unit.  If found,
1247                 # factor by the same power as the target unit's base.
1248                 # This allows us to factor out fractional powers
1249                 # without needing to do an exhaustive search.
1250                 if len(tunit_decomposed.bases) == 1:
1251                     for base, power in zip(u.bases, u.powers):
1252                         if tunit_decomposed._is_equivalent(base):
1253                             tunit = tunit**power
1254                             tunit_decomposed = tunit_decomposed**power
1255                             break
1256 
1257                 composed = (u / tunit_decomposed).decompose()
1258                 factored = composed * tunit
1259                 len_bases = len(composed.bases)
1260                 if is_final_result(factored) and len_bases <= 1:
1261                     final_results[len_bases].add(factored)
1262                 else:
1263                     partial_results.append((len_bases, composed, tunit))
1264 
1265         # Do we have any minimal results?
1266         for final_result in final_results:
1267             if len(final_result):
1268                 results = final_results[0].union(final_results[1])
1269                 cached_results[key] = results
1270                 return results
1271 
1272         partial_results.sort(key=operator.itemgetter(0))
1273 
1274         # ...we have to recurse and try to further compose
1275         results = []
1276         for len_bases, composed, tunit in partial_results:
1277             try:
1278                 composed_list = composed._compose(
1279                     equivalencies=equivalencies,
1280                     namespace=namespace,
1281                     max_depth=max_depth,
1282                     depth=depth + 1,
1283                     cached_results=cached_results,
1284                 )
1285             except UnitsError:
1286                 composed_list = []
1287             for subcomposed in composed_list:
1288                 results.append((len(subcomposed.bases), subcomposed, tunit))
1289 
1290         if len(results):
1291             results.sort(key=operator.itemgetter(0))
1292 
1293             min_length = results[0][0]
1294             subresults = set()
1295             for len_bases, composed, tunit in results:
1296                 if len_bases > min_length:
1297                     break
1298                 else:
1299                     factored = composed * tunit
1300                     if is_final_result(factored):
1301                         subresults.add(factored)
1302 
1303             if len(subresults):
1304                 cached_results[key] = subresults
1305                 return subresults
1306 
1307         if not is_final_result(self):
1308             result = UnitsError(
1309                 f"Cannot represent unit {self} in terms of the given units"
1310             )
1311             cached_results[key] = result
1312             raise result
1313 
1314         cached_results[key] = [self]
1315         return [self]
1316 
1317     def compose(
1318         self, equivalencies=[], units=None, max_depth=2, include_prefix_units=None
1319     ):
1320         """
1321         Return the simplest possible composite unit(s) that represent
1322         the given unit.  Since there may be multiple equally simple
1323         compositions of the unit, a list of units is always returned.
1324 
1325         Parameters
1326         ----------
1327         equivalencies : list of tuple
1328             A list of equivalence pairs to also list.  See
1329             :ref:`astropy:unit_equivalencies`.
1330             This list is in addition to possible global defaults set by, e.g.,
1331             `set_enabled_equivalencies`.
1332             Use `None` to turn off all equivalencies.
1333 
1334         units : set of `~astropy.units.Unit`, optional
1335             If not provided, any known units may be used to compose
1336             into.  Otherwise, ``units`` is a dict, module or sequence
1337             containing the units to compose into.
1338 
1339         max_depth : int, optional
1340             The maximum recursion depth to use when composing into
1341             composite units.
1342 
1343         include_prefix_units : bool, optional
1344             When `True`, include prefixed units in the result.
1345             Default is `True` if a sequence is passed in to ``units``,
1346             `False` otherwise.
1347 
1348         Returns
1349         -------
1350         units : list of `CompositeUnit`
1351             A list of candidate compositions.  These will all be
1352             equally simple, but it may not be possible to
1353             automatically determine which of the candidates are
1354             better.
1355         """
1356         # if units parameter is specified and is a sequence (list|tuple),
1357         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]
1358         if include_prefix_units is None:
1359             include_prefix_units = isinstance(units, (list, tuple))
1360 
1361         # Pre-normalize the equivalencies list
1362         equivalencies = self._normalize_equivalencies(equivalencies)
1363 
1364         # The namespace of units to compose into should be filtered to
1365         # only include units with bases in common with self, otherwise
1366         # they can't possibly provide useful results.  Having too many
1367         # destination units greatly increases the search space.
1368 
1369         def has_bases_in_common(a, b):
1370             if len(a.bases) == 0 and len(b.bases) == 0:
1371                 return True
1372             for ab in a.bases:
1373                 for bb in b.bases:
1374                     if ab == bb:
1375                         return True
1376             return False
1377 
1378         def has_bases_in_common_with_equiv(unit, other):
1379             if has_bases_in_common(unit, other):
1380                 return True
1381             for funit, tunit, a, b in equivalencies:
1382                 if tunit is not None:
1383                     if unit._is_equivalent(funit):
1384                         if has_bases_in_common(tunit.decompose(), other):
1385                             return True
1386                     elif unit._is_equivalent(tunit):
1387                         if has_bases_in_common(funit.decompose(), other):
1388                             return True
1389                 else:
1390                     if unit._is_equivalent(funit):
1391                         if has_bases_in_common(dimensionless_unscaled, other):
1392                             return True
1393             return False
1394 
1395         def filter_units(units):
1396             filtered_namespace = set()
1397             for tunit in units:
1398                 if (
1399                     isinstance(tunit, UnitBase)
1400                     and (include_prefix_units or not isinstance(tunit, PrefixUnit))
1401                     and has_bases_in_common_with_equiv(decomposed, tunit.decompose())
1402                 ):
1403                     filtered_namespace.add(tunit)
1404             return filtered_namespace
1405 
1406         decomposed = self.decompose()
1407 
1408         if units is None:
1409             units = filter_units(self._get_units_with_same_physical_type(equivalencies))
1410             if len(units) == 0:
1411                 units = get_current_unit_registry().non_prefix_units
1412         elif isinstance(units, dict):
1413             units = set(filter_units(units.values()))
1414         elif inspect.ismodule(units):
1415             units = filter_units(vars(units).values())
1416         else:
1417             units = filter_units(_flatten_units_collection(units))
1418 
1419         def sort_results(results):
1420             if not len(results):
1421                 return []
1422 
1423             # Sort the results so the simplest ones appear first.
1424             # Simplest is defined as "the minimum sum of absolute
1425             # powers" (i.e. the fewest bases), and preference should
1426             # be given to results where the sum of powers is positive
1427             # and the scale is exactly equal to 1.0
1428             results = list(results)
1429             results.sort(key=lambda x: np.abs(x.scale))
1430             results.sort(key=lambda x: np.sum(np.abs(x.powers)))
1431             results.sort(key=lambda x: np.sum(x.powers) < 0.0)
1432             results.sort(key=lambda x: not is_effectively_unity(x.scale))
1433 
1434             last_result = results[0]
1435             filtered = [last_result]
1436             for result in results[1:]:
1437                 if str(result) != str(last_result):
1438                     filtered.append(result)
1439                 last_result = result
1440 
1441             return filtered
1442 
1443         return sort_results(
1444             self._compose(
1445                 equivalencies=equivalencies,
1446                 namespace=units,
1447                 max_depth=max_depth,
1448                 depth=0,
1449                 cached_results={},
1450             )
1451         )
1452 
1453     def to_system(self, system):
1454         """
1455         Converts this unit into ones belonging to the given system.
1456         Since more than one result may be possible, a list is always
1457         returned.
1458 
1459         Parameters
1460         ----------
1461         system : module
1462             The module that defines the unit system.  Commonly used
1463             ones include `astropy.units.si` and `astropy.units.cgs`.
1464 
1465             To use your own module it must contain unit objects and a
1466             sequence member named ``bases`` containing the base units of
1467             the system.
1468 
1469         Returns
1470         -------
1471         units : list of `CompositeUnit`
1472             The list is ranked so that units containing only the base
1473             units of that system will appear first.
1474         """
1475         bases = set(system.bases)
1476 
1477         def score(compose):
1478             # In case that compose._bases has no elements we return
1479             # 'np.inf' as 'score value'.  It does not really matter which
1480             # number we would return. This case occurs for instance for
1481             # dimensionless quantities:
1482             compose_bases = compose.bases
1483             if len(compose_bases) == 0:
1484                 return np.inf
1485             else:
1486                 sum = 0
1487                 for base in compose_bases:
1488                     if base in bases:
1489                         sum += 1
1490 
1491                 return sum / float(len(compose_bases))
1492 
1493         x = self.decompose(bases=bases)
1494         composed = x.compose(units=system)
1495         composed = sorted(composed, key=score, reverse=True)
1496         return composed
1497 
1498     @lazyproperty
1499     def si(self):
1500         """
1501         Returns a copy of the current `Unit` instance in SI units.
1502         """
1503         from . import si
1504 
1505         return self.to_system(si)[0]
1506 
1507     @lazyproperty
1508     def cgs(self):
1509         """
1510         Returns a copy of the current `Unit` instance with CGS units.
1511         """
1512         from . import cgs
1513 
1514         return self.to_system(cgs)[0]
1515 
1516     @property
1517     def physical_type(self):
1518         """
1519         Physical type(s) dimensionally compatible with the unit.
1520 
1521         Returns
1522         -------
1523         `~astropy.units.physical.PhysicalType`
1524             A representation of the physical type(s) of a unit.
1525 
1526         Examples
1527         --------
1528         >>> from astropy import units as u
1529         >>> u.m.physical_type
1530         PhysicalType('length')
1531         >>> (u.m ** 2 / u.s).physical_type
1532         PhysicalType({'diffusivity', 'kinematic viscosity'})
1533 
1534         Physical types can be compared to other physical types
1535         (recommended in packages) or to strings.
1536 
1537         >>> area = (u.m ** 2).physical_type
1538         >>> area == u.m.physical_type ** 2
1539         True
1540         >>> area == "area"
1541         True
1542 
1543         `~astropy.units.physical.PhysicalType` objects can be used for
1544         dimensional analysis.
1545 
1546         >>> number_density = u.m.physical_type ** -3
1547         >>> velocity = (u.m / u.s).physical_type
1548         >>> number_density * velocity
1549         PhysicalType('particle flux')
1550         """
1551         from . import physical
1552 
1553         return physical.get_physical_type(self)
1554 
1555     def _get_units_with_same_physical_type(self, equivalencies=[]):
1556         """
1557         Return a list of registered units with the same physical type
1558         as this unit.
1559 
1560         This function is used by Quantity to add its built-in
1561         conversions to equivalent units.
1562 
1563         This is a private method, since end users should be encouraged
1564         to use the more powerful `compose` and `find_equivalent_units`
1565         methods (which use this under the hood).
1566 
1567         Parameters
1568         ----------
1569         equivalencies : list of tuple
1570             A list of equivalence pairs to also pull options from.
1571             See :ref:`astropy:unit_equivalencies`.  It must already be
1572             normalized using `_normalize_equivalencies`.
1573         """
1574         unit_registry = get_current_unit_registry()
1575         units = set(unit_registry.get_units_with_physical_type(self))
1576         for funit, tunit, a, b in equivalencies:
1577             if tunit is not None:
1578                 if self.is_equivalent(funit) and tunit not in units:
1579                     units.update(unit_registry.get_units_with_physical_type(tunit))
1580                 if self._is_equivalent(tunit) and funit not in units:
1581                     units.update(unit_registry.get_units_with_physical_type(funit))
1582             else:
1583                 if self.is_equivalent(funit):
1584                     units.add(dimensionless_unscaled)
1585         return units
1586 
1587     class EquivalentUnitsList(list):
1588         """
1589         A class to handle pretty-printing the result of
1590         `find_equivalent_units`.
1591         """
1592 
1593         HEADING_NAMES = ("Primary name", "Unit definition", "Aliases")
1594         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant
1595         NO_EQUIV_UNITS_MSG = "There are no equivalent units"
1596 
1597         def __repr__(self):
1598             if len(self) == 0:
1599                 return self.NO_EQUIV_UNITS_MSG
1600             else:
1601                 lines = self._process_equivalent_units(self)
1602                 lines.insert(0, self.HEADING_NAMES)
1603                 widths = [0] * self.ROW_LEN
1604                 for line in lines:
1605                     for i, col in enumerate(line):
1606                         widths[i] = max(widths[i], len(col))
1607 
1608                 f = "  {{0:<{}s}} | {{1:<{}s}} | {{2:<{}s}}".format(*widths)
1609                 lines = [f.format(*line) for line in lines]
1610                 lines = lines[0:1] + ["["] + [f"{x} ," for x in lines[1:]] + ["]"]
1611                 return "\n".join(lines)
1612 
1613         def _repr_html_(self):
1614             """
1615             Outputs a HTML table representation within Jupyter notebooks.
1616             """
1617             if len(self) == 0:
1618                 return f"<p>{self.NO_EQUIV_UNITS_MSG}</p>"
1619             else:
1620                 # HTML tags to use to compose the table in HTML
1621                 blank_table = '<table style="width:50%">{}</table>'
1622                 blank_row_container = "<tr>{}</tr>"
1623                 heading_row_content = "<th>{}</th>" * self.ROW_LEN
1624                 data_row_content = "<td>{}</td>" * self.ROW_LEN
1625 
1626                 # The HTML will be rendered & the table is simple, so don't
1627                 # bother to include newlines & indentation for the HTML code.
1628                 heading_row = blank_row_container.format(
1629                     heading_row_content.format(*self.HEADING_NAMES)
1630                 )
1631                 data_rows = self._process_equivalent_units(self)
1632                 all_rows = heading_row
1633                 for row in data_rows:
1634                     html_row = blank_row_container.format(data_row_content.format(*row))
1635                     all_rows += html_row
1636                 return blank_table.format(all_rows)
1637 
1638         @staticmethod
1639         def _process_equivalent_units(equiv_units_data):
1640             """
1641             Extract attributes, and sort, the equivalent units pre-formatting.
1642             """
1643             processed_equiv_units = []
1644             for u in equiv_units_data:
1645                 irred = u.decompose().to_string()
1646                 if irred == u.name:
1647                     irred = "irreducible"
1648                 processed_equiv_units.append((u.name, irred, ", ".join(u.aliases)))
1649             processed_equiv_units.sort()
1650             return processed_equiv_units
1651 
1652     def find_equivalent_units(
1653         self, equivalencies=[], units=None, include_prefix_units=False
1654     ):
1655         """
1656         Return a list of all the units that are the same type as ``self``.
1657 
1658         Parameters
1659         ----------
1660         equivalencies : list of tuple
1661             A list of equivalence pairs to also list.  See
1662             :ref:`astropy:unit_equivalencies`.
1663             Any list given, including an empty one, supersedes global defaults
1664             that may be in effect (as set by `set_enabled_equivalencies`)
1665 
1666         units : set of `~astropy.units.Unit`, optional
1667             If not provided, all defined units will be searched for
1668             equivalencies.  Otherwise, may be a dict, module or
1669             sequence containing the units to search for equivalencies.
1670 
1671         include_prefix_units : bool, optional
1672             When `True`, include prefixed units in the result.
1673             Default is `False`.
1674 
1675         Returns
1676         -------
1677         units : list of `UnitBase`
1678             A list of unit objects that match ``u``.  A subclass of
1679             `list` (``EquivalentUnitsList``) is returned that
1680             pretty-prints the list of units when output.
1681         """
1682         results = self.compose(
1683             equivalencies=equivalencies,
1684             units=units,
1685             max_depth=1,
1686             include_prefix_units=include_prefix_units,
1687         )
1688         results = {x.bases[0] for x in results if len(x.bases) == 1}
1689         return self.EquivalentUnitsList(results)
1690 
1691     def is_unity(self):
1692         """
1693         Returns `True` if the unit is unscaled and dimensionless.
1694         """
1695         return False
1696 
1697 
1698 class NamedUnit(UnitBase):
1699     """
1700     The base class of units that have a name.
1701 
1702     Parameters
1703     ----------
1704     st : str, list of str, 2-tuple
1705         The name of the unit.  If a list of strings, the first element
1706         is the canonical (short) name, and the rest of the elements
1707         are aliases.  If a tuple of lists, the first element is a list
1708         of short names, and the second element is a list of long
1709         names; all but the first short name are considered "aliases".
1710         Each name *should* be a valid Python identifier to make it
1711         easy to access, but this is not required.
1712 
1713     namespace : dict, optional
1714         When provided, inject the unit, and all of its aliases, in the
1715         given namespace dictionary.  If a unit by the same name is
1716         already in the namespace, a ValueError is raised.
1717 
1718     doc : str, optional
1719         A docstring describing the unit.
1720 
1721     format : dict, optional
1722         A mapping to format-specific representations of this unit.
1723         For example, for the ``Ohm`` unit, it might be nice to have it
1724         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
1725         case, `format` argument should be set to::
1726 
1727             {'latex': r'\\Omega'}
1728 
1729     Raises
1730     ------
1731     ValueError
1732         If any of the given unit names are already in the registry.
1733 
1734     ValueError
1735         If any of the given unit names are not valid Python tokens.
1736     """
1737 
1738     def __init__(self, st, doc=None, format=None, namespace=None):
1739         UnitBase.__init__(self)
1740 
1741         if isinstance(st, (bytes, str)):
1742             self._names = [st]
1743             self._short_names = [st]
1744             self._long_names = []
1745         elif isinstance(st, tuple):
1746             if not len(st) == 2:
1747                 raise ValueError("st must be string, list or 2-tuple")
1748             self._names = st[0] + [n for n in st[1] if n not in st[0]]
1749             if not len(self._names):
1750                 raise ValueError("must provide at least one name")
1751             self._short_names = st[0][:]
1752             self._long_names = st[1][:]
1753         else:
1754             if len(st) == 0:
1755                 raise ValueError("st list must have at least one entry")
1756             self._names = st[:]
1757             self._short_names = [st[0]]
1758             self._long_names = st[1:]
1759 
1760         if format is None:
1761             format = {}
1762         self._format = format
1763 
1764         if doc is None:
1765             doc = self._generate_doc()
1766         else:
1767             doc = textwrap.dedent(doc)
1768             doc = textwrap.fill(doc)
1769 
1770         self.__doc__ = doc
1771 
1772         self._inject(namespace)
1773 
1774     def _generate_doc(self):
1775         """
1776         Generate a docstring for the unit if the user didn't supply
1777         one.  This is only used from the constructor and may be
1778         overridden in subclasses.
1779         """
1780         names = self.names
1781         if len(self.names) > 1:
1782             return f"{names[1]} ({names[0]})"
1783         else:
1784             return names[0]
1785 
1786     def get_format_name(self, format):
1787         """
1788         Get a name for this unit that is specific to a particular
1789         format.
1790 
1791         Uses the dictionary passed into the `format` kwarg in the
1792         constructor.
1793 
1794         Parameters
1795         ----------
1796         format : str
1797             The name of the format
1798 
1799         Returns
1800         -------
1801         name : str
1802             The name of the unit for the given format.
1803         """
1804         return self._format.get(format, self.name)
1805 
1806     @property
1807     def names(self):
1808         """
1809         Returns all of the names associated with this unit.
1810         """
1811         return self._names
1812 
1813     @property
1814     def name(self):
1815         """
1816         Returns the canonical (short) name associated with this unit.
1817         """
1818         return self._names[0]
1819 
1820     @property
1821     def aliases(self):
1822         """
1823         Returns the alias (long) names for this unit.
1824         """
1825         return self._names[1:]
1826 
1827     @property
1828     def short_names(self):
1829         """
1830         Returns all of the short names associated with this unit.
1831         """
1832         return self._short_names
1833 
1834     @property
1835     def long_names(self):
1836         """
1837         Returns all of the long names associated with this unit.
1838         """
1839         return self._long_names
1840 
1841     def _inject(self, namespace=None):
1842         """
1843         Injects the unit, and all of its aliases, in the given
1844         namespace dictionary.
1845         """
1846         if namespace is None:
1847             return
1848 
1849         # Loop through all of the names first, to ensure all of them
1850         # are new, then add them all as a single "transaction" below.
1851         for name in self._names:
1852             if name in namespace and self != namespace[name]:
1853                 raise ValueError(
1854                     f"Object with name {name!r} already exists in "
1855                     f"given namespace ({namespace[name]!r})."
1856                 )
1857 
1858         for name in self._names:
1859             namespace[name] = self
1860 
1861 
1862 def _recreate_irreducible_unit(cls, names, registered):
1863     """
1864     This is used to reconstruct units when passed around by
1865     multiprocessing.
1866     """
1867     registry = get_current_unit_registry().registry
1868     if names[0] in registry:
1869         # If in local registry return that object.
1870         return registry[names[0]]
1871     else:
1872         # otherwise, recreate the unit.
1873         unit = cls(names)
1874         if registered:
1875             # If not in local registry but registered in origin registry,
1876             # enable unit in local registry.
1877             get_current_unit_registry().add_enabled_units([unit])
1878 
1879         return unit
1880 
1881 
1882 class IrreducibleUnit(NamedUnit):
1883     """
1884     Irreducible units are the units that all other units are defined
1885     in terms of.
1886 
1887     Examples are meters, seconds, kilograms, amperes, etc.  There is
1888     only once instance of such a unit per type.
1889     """
1890 
1891     def __reduce__(self):
1892         # When IrreducibleUnit objects are passed to other processes
1893         # over multiprocessing, they need to be recreated to be the
1894         # ones already in the subprocesses' namespace, not new
1895         # objects, or they will be considered "unconvertible".
1896         # Therefore, we have a custom pickler/unpickler that
1897         # understands how to recreate the Unit on the other side.
1898         registry = get_current_unit_registry().registry
1899         return (
1900             _recreate_irreducible_unit,
1901             (self.__class__, list(self.names), self.name in registry),
1902             self.__getstate__(),
1903         )
1904 
1905     @property
1906     def represents(self):
1907         """The unit that this named unit represents.
1908 
1909         For an irreducible unit, that is always itself.
1910         """
1911         return self
1912 
1913     def decompose(self, bases=set()):
1914         if len(bases) and self not in bases:
1915             for base in bases:
1916                 try:
1917                     scale = self._to(base)
1918                 except UnitsError:
1919                     pass
1920                 else:
1921                     if is_effectively_unity(scale):
1922                         return base
1923                     else:
1924                         return CompositeUnit(scale, [base], [1], _error_check=False)
1925 
1926             raise UnitConversionError(
1927                 f"Unit {self} can not be decomposed into the requested bases"
1928             )
1929 
1930         return self
1931 
1932 
1933 class UnrecognizedUnit(IrreducibleUnit):
1934     """
1935     A unit that did not parse correctly.  This allows for
1936     round-tripping it as a string, but no unit operations actually work
1937     on it.
1938 
1939     Parameters
1940     ----------
1941     st : str
1942         The name of the unit.
1943     """
1944 
1945     # For UnrecognizedUnits, we want to use "standard" Python
1946     # pickling, not the special case that is used for
1947     # IrreducibleUnits.
1948     __reduce__ = object.__reduce__
1949 
1950     def __repr__(self):
1951         return f"UnrecognizedUnit({str(self)})"
1952 
1953     def __bytes__(self):
1954         return self.name.encode("ascii", "replace")
1955 
1956     def __str__(self):
1957         return self.name
1958 
1959     def to_string(self, format=None):
1960         return self.name
1961 
1962     def _unrecognized_operator(self, *args, **kwargs):
1963         raise ValueError(
1964             f"The unit {self.name!r} is unrecognized, so all arithmetic operations "
1965             "with it are invalid."
1966         )
1967 
1968     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = _unrecognized_operator
1969     __lt__ = __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator
1970 
1971     def __eq__(self, other):
1972         try:
1973             other = Unit(other, parse_strict="silent")
1974         except (ValueError, UnitsError, TypeError):
1975             return NotImplemented
1976 
1977         return isinstance(other, type(self)) and self.name == other.name
1978 
1979     def __ne__(self, other):
1980         return not (self == other)
1981 
1982     def is_equivalent(self, other, equivalencies=None):
1983         self._normalize_equivalencies(equivalencies)
1984         return self == other
1985 
1986     def _get_converter(self, other, equivalencies=None):
1987         self._normalize_equivalencies(equivalencies)
1988         raise ValueError(
1989             f"The unit {self.name!r} is unrecognized.  It can not be converted "
1990             "to other units."
1991         )
1992 
1993     def get_format_name(self, format):
1994         return self.name
1995 
1996     def is_unity(self):
1997         return False
1998 
1999 
2000 class _UnitMetaClass(type):
2001     """
2002     This metaclass exists because the Unit constructor should
2003     sometimes return instances that already exist.  This "overrides"
2004     the constructor before the new instance is actually created, so we
2005     can return an existing one.
2006     """
2007 
2008     def __call__(
2009         self,
2010         s="",
2011         represents=None,
2012         format=None,
2013         namespace=None,
2014         doc=None,
2015         parse_strict="raise",
2016     ):
2017         # Short-circuit if we're already a unit
2018         if hasattr(s, "_get_physical_type_id"):
2019             return s
2020 
2021         # turn possible Quantity input for s or represents into a Unit
2022         from .quantity import Quantity
2023 
2024         if isinstance(represents, Quantity):
2025             if is_effectively_unity(represents.value):
2026                 represents = represents.unit
2027             else:
2028                 represents = CompositeUnit(
2029                     represents.value * represents.unit.scale,
2030                     bases=represents.unit.bases,
2031                     powers=represents.unit.powers,
2032                     _error_check=False,
2033                 )
2034 
2035         if isinstance(s, Quantity):
2036             if is_effectively_unity(s.value):
2037                 s = s.unit
2038             else:
2039                 s = CompositeUnit(
2040                     s.value * s.unit.scale,
2041                     bases=s.unit.bases,
2042                     powers=s.unit.powers,
2043                     _error_check=False,
2044                 )
2045 
2046         # now decide what we really need to do; define derived Unit?
2047         if isinstance(represents, UnitBase):
2048             # This has the effect of calling the real __new__ and
2049             # __init__ on the Unit class.
2050             return super().__call__(
2051                 s, represents, format=format, namespace=namespace, doc=doc
2052             )
2053 
2054         # or interpret a Quantity (now became unit), string or number?
2055         if isinstance(s, UnitBase):
2056             return s
2057 
2058         elif isinstance(s, (bytes, str)):
2059             if len(s.strip()) == 0:
2060                 # Return the NULL unit
2061                 return dimensionless_unscaled
2062 
2063             if format is None:
2064                 format = unit_format.Generic
2065 
2066             f = unit_format.get_format(format)
2067             if isinstance(s, bytes):
2068                 s = s.decode("ascii")
2069 
2070             try:
2071                 return f.parse(s)
2072             except NotImplementedError:
2073                 raise
2074             except Exception as e:
2075                 if parse_strict == "silent":
2076                     pass
2077                 else:
2078                     # Deliberately not issubclass here. Subclasses
2079                     # should use their name.
2080                     if f is not unit_format.Generic:
2081                         format_clause = f.name + " "
2082                     else:
2083                         format_clause = ""
2084                     msg = (
2085                         f"'{s}' did not parse as {format_clause}unit: {str(e)} "
2086                         "If this is meant to be a custom unit, "
2087                         "define it with 'u.def_unit'. To have it "
2088                         "recognized inside a file reader or other code, "
2089                         "enable it with 'u.add_enabled_units'. "
2090                         "For details, see "
2091                         "https://docs.astropy.org/en/latest/units/combining_and_defining.html"
2092                     )
2093                     if parse_strict == "raise":
2094                         raise ValueError(msg)
2095                     elif parse_strict == "warn":
2096                         warnings.warn(msg, UnitsWarning)
2097                     else:
2098                         raise ValueError(
2099                             "'parse_strict' must be 'warn', 'raise' or 'silent'"
2100                         )
2101                 return UnrecognizedUnit(s)
2102 
2103         elif isinstance(s, (int, float, np.floating, np.integer)):
2104             return CompositeUnit(s, [], [], _error_check=False)
2105 
2106         elif isinstance(s, tuple):
2107             from .structured import StructuredUnit
2108 
2109             return StructuredUnit(s)
2110 
2111         elif s is None:
2112             raise TypeError("None is not a valid Unit")
2113 
2114         else:
2115             raise TypeError(f"{s} can not be converted to a Unit")
2116 
2117 
2118 class Unit(NamedUnit, metaclass=_UnitMetaClass):
2119     """
2120     The main unit class.
2121 
2122     There are a number of different ways to construct a Unit, but
2123     always returns a `UnitBase` instance.  If the arguments refer to
2124     an already-existing unit, that existing unit instance is returned,
2125     rather than a new one.
2126 
2127     - From a string::
2128 
2129         Unit(s, format=None, parse_strict='silent')
2130 
2131       Construct from a string representing a (possibly compound) unit.
2132 
2133       The optional `format` keyword argument specifies the format the
2134       string is in, by default ``"generic"``.  For a description of
2135       the available formats, see `astropy.units.format`.
2136 
2137       The optional ``parse_strict`` keyword controls what happens when an
2138       unrecognized unit string is passed in.  It may be one of the following:
2139 
2140          - ``'raise'``: (default) raise a ValueError exception.
2141 
2142          - ``'warn'``: emit a Warning, and return an
2143            `UnrecognizedUnit` instance.
2144 
2145          - ``'silent'``: return an `UnrecognizedUnit` instance.
2146 
2147     - From a number::
2148 
2149         Unit(number)
2150 
2151       Creates a dimensionless unit.
2152 
2153     - From a `UnitBase` instance::
2154 
2155         Unit(unit)
2156 
2157       Returns the given unit unchanged.
2158 
2159     - From no arguments::
2160 
2161         Unit()
2162 
2163       Returns the dimensionless unit.
2164 
2165     - The last form, which creates a new `Unit` is described in detail
2166       below.
2167 
2168     See also: https://docs.astropy.org/en/stable/units/
2169 
2170     Parameters
2171     ----------
2172     st : str or list of str
2173         The name of the unit.  If a list, the first element is the
2174         canonical (short) name, and the rest of the elements are
2175         aliases.
2176 
2177     represents : UnitBase instance
2178         The unit that this named unit represents.
2179 
2180     doc : str, optional
2181         A docstring describing the unit.
2182 
2183     format : dict, optional
2184         A mapping to format-specific representations of this unit.
2185         For example, for the ``Ohm`` unit, it might be nice to have it
2186         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
2187         case, `format` argument should be set to::
2188 
2189             {'latex': r'\\Omega'}
2190 
2191     namespace : dict, optional
2192         When provided, inject the unit (and all of its aliases) into
2193         the given namespace.
2194 
2195     Raises
2196     ------
2197     ValueError
2198         If any of the given unit names are already in the registry.
2199 
2200     ValueError
2201         If any of the given unit names are not valid Python tokens.
2202     """
2203 
2204     def __init__(self, st, represents=None, doc=None, format=None, namespace=None):
2205         represents = Unit(represents)
2206         self._represents = represents
2207 
2208         NamedUnit.__init__(self, st, namespace=namespace, doc=doc, format=format)
2209 
2210     @property
2211     def represents(self):
2212         """The unit that this named unit represents."""
2213         return self._represents
2214 
2215     def decompose(self, bases=set()):
2216         return self._represents.decompose(bases=bases)
2217 
2218     def is_unity(self):
2219         return self._represents.is_unity()
2220 
2221     def __hash__(self):
2222         if self._hash is None:
2223             self._hash = hash((self.name, self._represents))
2224         return self._hash
2225 
2226     @classmethod
2227     def _from_physical_type_id(cls, physical_type_id):
2228         # get string bases and powers from the ID tuple
2229         bases = [cls(base) for base, _ in physical_type_id]
2230         powers = [power for _, power in physical_type_id]
2231 
2232         if len(physical_type_id) == 1 and powers[0] == 1:
2233             unit = bases[0]
2234         else:
2235             unit = CompositeUnit(1, bases, powers, _error_check=False)
2236 
2237         return unit
2238 
2239 
2240 class PrefixUnit(Unit):
2241     """
2242     A unit that is simply a SI-prefixed version of another unit.
2243 
2244     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.
2245 
2246     The constructor is the same as for `Unit`.
2247     """
2248 
2249 
2250 class CompositeUnit(UnitBase):
2251     """
2252     Create a composite unit using expressions of previously defined
2253     units.
2254 
2255     Direct use of this class is not recommended. Instead use the
2256     factory function `Unit` and arithmetic operators to compose
2257     units.
2258 
2259     Parameters
2260     ----------
2261     scale : number
2262         A scaling factor for the unit.
2263 
2264     bases : sequence of `UnitBase`
2265         A sequence of units this unit is composed of.
2266 
2267     powers : sequence of numbers
2268         A sequence of powers (in parallel with ``bases``) for each
2269         of the base units.
2270     """
2271 
2272     _decomposed_cache = None
2273 
2274     def __init__(
2275         self,
2276         scale,
2277         bases,
2278         powers,
2279         decompose=False,
2280         decompose_bases=set(),
2281         _error_check=True,
2282     ):
2283         # There are many cases internal to astropy.units where we
2284         # already know that all the bases are Unit objects, and the
2285         # powers have been validated.  In those cases, we can skip the
2286         # error checking for performance reasons.  When the private
2287         # kwarg `_error_check` is False, the error checking is turned
2288         # off.
2289         if _error_check:
2290             for base in bases:
2291                 if not isinstance(base, UnitBase):
2292                     raise TypeError("bases must be sequence of UnitBase instances")
2293             powers = [validate_power(p) for p in powers]
2294 
2295         if not decompose and len(bases) == 1 and powers[0] >= 0:
2296             # Short-cut; with one unit there's nothing to expand and gather,
2297             # as that has happened already when creating the unit.  But do only
2298             # positive powers, since for negative powers we need to re-sort.
2299             unit = bases[0]
2300             power = powers[0]
2301             if power == 1:
2302                 scale *= unit.scale
2303                 self._bases = unit.bases
2304                 self._powers = unit.powers
2305             elif power == 0:
2306                 self._bases = []
2307                 self._powers = []
2308             else:
2309                 scale *= unit.scale**power
2310                 self._bases = unit.bases
2311                 self._powers = [
2312                     operator.mul(*resolve_fractions(p, power)) for p in unit.powers
2313                 ]
2314 
2315             self._scale = sanitize_scale(scale)
2316         else:
2317             # Regular case: use inputs as preliminary scale, bases, and powers,
2318             # then "expand and gather" identical bases, sanitize the scale, &c.
2319             self._scale = scale
2320             self._bases = bases
2321             self._powers = powers
2322             self._expand_and_gather(decompose=decompose, bases=decompose_bases)
2323 
2324     def __repr__(self):
2325         if len(self._bases):
2326             return super().__repr__()
2327         else:
2328             if self._scale != 1.0:
2329                 return f"Unit(dimensionless with a scale of {self._scale})"
2330             else:
2331                 return "Unit(dimensionless)"
2332 
2333     @property
2334     def scale(self):
2335         """
2336         Return the scale of the composite unit.
2337         """
2338         return self._scale
2339 
2340     @property
2341     def bases(self):
2342         """
2343         Return the bases of the composite unit.
2344         """
2345         return self._bases
2346 
2347     @property
2348     def powers(self):
2349         """
2350         Return the powers of the composite unit.
2351         """
2352         return self._powers
2353 
2354     def _expand_and_gather(self, decompose=False, bases=set()):
2355         def add_unit(unit, power, scale):
2356             if bases and unit not in bases:
2357                 for base in bases:
2358                     try:
2359                         scale *= unit._to(base) ** power
2360                     except UnitsError:
2361                         pass
2362                     else:
2363                         unit = base
2364                         break
2365 
2366             if unit in new_parts:
2367                 a, b = resolve_fractions(new_parts[unit], power)
2368                 new_parts[unit] = a + b
2369             else:
2370                 new_parts[unit] = power
2371             return scale
2372 
2373         new_parts = {}
2374         scale = self._scale
2375 
2376         for b, p in zip(self._bases, self._powers):
2377             if decompose and b not in bases:
2378                 b = b.decompose(bases=bases)
2379 
2380             if isinstance(b, CompositeUnit):
2381                 scale *= b._scale**p
2382                 for b_sub, p_sub in zip(b._bases, b._powers):
2383                     a, b = resolve_fractions(p_sub, p)
2384                     scale = add_unit(b_sub, a * b, scale)
2385             else:
2386                 scale = add_unit(b, p, scale)
2387 
2388         new_parts = [x for x in new_parts.items() if x[1] != 0]
2389         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], "name", "")))
2390 
2391         self._bases = [x[0] for x in new_parts]
2392         self._powers = [x[1] for x in new_parts]
2393         self._scale = sanitize_scale(scale)
2394 
2395     def __copy__(self):
2396         """
2397         For compatibility with python copy module.
2398         """
2399         return CompositeUnit(self._scale, self._bases[:], self._powers[:])
2400 
2401     def decompose(self, bases=set()):
2402         if len(bases) == 0 and self._decomposed_cache is not None:
2403             return self._decomposed_cache
2404 
2405         for base in self.bases:
2406             if not isinstance(base, IrreducibleUnit) or (
2407                 len(bases) and base not in bases
2408             ):
2409                 break
2410         else:
2411             if len(bases) == 0:
2412                 self._decomposed_cache = self
2413             return self
2414 
2415         x = CompositeUnit(
2416             self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases
2417         )
2418         if len(bases) == 0:
2419             self._decomposed_cache = x
2420         return x
2421 
2422     def is_unity(self):
2423         unit = self.decompose()
2424         return len(unit.bases) == 0 and unit.scale == 1.0
2425 
2426 
2427 si_prefixes = [
2428     (["Q"], ["quetta"], 1e30),
2429     (["R"], ["ronna"], 1e27),
2430     (["Y"], ["yotta"], 1e24),
2431     (["Z"], ["zetta"], 1e21),
2432     (["E"], ["exa"], 1e18),
2433     (["P"], ["peta"], 1e15),
2434     (["T"], ["tera"], 1e12),
2435     (["G"], ["giga"], 1e9),
2436     (["M"], ["mega"], 1e6),
2437     (["k"], ["kilo"], 1e3),
2438     (["h"], ["hecto"], 1e2),
2439     (["da"], ["deka", "deca"], 1e1),
2440     (["d"], ["deci"], 1e-1),
2441     (["c"], ["centi"], 1e-2),
2442     (["m"], ["milli"], 1e-3),
2443     (["u"], ["micro"], 1e-6),
2444     (["n"], ["nano"], 1e-9),
2445     (["p"], ["pico"], 1e-12),
2446     (["f"], ["femto"], 1e-15),
2447     (["a"], ["atto"], 1e-18),
2448     (["z"], ["zepto"], 1e-21),
2449     (["y"], ["yocto"], 1e-24),
2450     (["r"], ["ronto"], 1e-27),
2451     (["q"], ["quecto"], 1e-30),
2452 ]
2453 
2454 
2455 binary_prefixes = [
2456     (["Ki"], ["kibi"], 2**10),
2457     (["Mi"], ["mebi"], 2**20),
2458     (["Gi"], ["gibi"], 2**30),
2459     (["Ti"], ["tebi"], 2**40),
2460     (["Pi"], ["pebi"], 2**50),
2461     (["Ei"], ["exbi"], 2**60),
2462 ]
2463 
2464 
2465 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):
2466     """
2467     Set up all of the standard metric prefixes for a unit.  This
2468     function should not be used directly, but instead use the
2469     `prefixes` kwarg on `def_unit`.
2470 
2471     Parameters
2472     ----------
2473     excludes : list of str, optional
2474         Any prefixes to exclude from creation to avoid namespace
2475         collisions.
2476 
2477     namespace : dict, optional
2478         When provided, inject the unit (and all of its aliases) into
2479         the given namespace dictionary.
2480 
2481     prefixes : list, optional
2482         When provided, it is a list of prefix definitions of the form:
2483 
2484             (short_names, long_tables, factor)
2485     """
2486     if prefixes is True:
2487         prefixes = si_prefixes
2488     elif prefixes is False:
2489         prefixes = []
2490 
2491     for short, full, factor in prefixes:
2492         names = []
2493         format = {}
2494         for prefix in short:
2495             if prefix in excludes:
2496                 continue
2497 
2498             for alias in u.short_names:
2499                 names.append(prefix + alias)
2500 
2501                 # This is a hack to use Greek mu as a prefix
2502                 # for some formatters.
2503                 if prefix == "u":
2504                     format["latex"] = r"\mu " + u.get_format_name("latex")
2505                     format["unicode"] = "\N{MICRO SIGN}" + u.get_format_name("unicode")
2506 
2507                 for key, val in u._format.items():
2508                     format.setdefault(key, prefix + val)
2509 
2510         for prefix in full:
2511             if prefix in excludes:
2512                 continue
2513 
2514             for alias in u.long_names:
2515                 names.append(prefix + alias)
2516 
2517         if len(names):
2518             PrefixUnit(
2519                 names,
2520                 CompositeUnit(factor, [u], [1], _error_check=False),
2521                 namespace=namespace,
2522                 format=format,
2523             )
2524 
2525 
2526 def def_unit(
2527     s,
2528     represents=None,
2529     doc=None,
2530     format=None,
2531     prefixes=False,
2532     exclude_prefixes=[],
2533     namespace=None,
2534 ):
2535     """
2536     Factory function for defining new units.
2537 
2538     Parameters
2539     ----------
2540     s : str or list of str
2541         The name of the unit.  If a list, the first element is the
2542         canonical (short) name, and the rest of the elements are
2543         aliases.
2544 
2545     represents : UnitBase instance, optional
2546         The unit that this named unit represents.  If not provided,
2547         a new `IrreducibleUnit` is created.
2548 
2549     doc : str, optional
2550         A docstring describing the unit.
2551 
2552     format : dict, optional
2553         A mapping to format-specific representations of this unit.
2554         For example, for the ``Ohm`` unit, it might be nice to
2555         have it displayed as ``\\Omega`` by the ``latex``
2556         formatter.  In that case, `format` argument should be set
2557         to::
2558 
2559             {'latex': r'\\Omega'}
2560 
2561     prefixes : bool or list, optional
2562         When `True`, generate all of the SI prefixed versions of the
2563         unit as well.  For example, for a given unit ``m``, will
2564         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of
2565         prefix definitions of the form:
2566 
2567             (short_names, long_tables, factor)
2568 
2569         Default is `False`.  This function always returns the base
2570         unit object, even if multiple scaled versions of the unit were
2571         created.
2572 
2573     exclude_prefixes : list of str, optional
2574         If any of the SI prefixes need to be excluded, they may be
2575         listed here.  For example, ``Pa`` can be interpreted either as
2576         "petaannum" or "Pascal".  Therefore, when defining the
2577         prefixes for ``a``, ``exclude_prefixes`` should be set to
2578         ``["P"]``.
2579 
2580     namespace : dict, optional
2581         When provided, inject the unit (and all of its aliases and
2582         prefixes), into the given namespace dictionary.
2583 
2584     Returns
2585     -------
2586     unit : `~astropy.units.UnitBase`
2587         The newly-defined unit, or a matching unit that was already
2588         defined.
2589     """
2590     if represents is not None:
2591         result = Unit(s, represents, namespace=namespace, doc=doc, format=format)
2592     else:
2593         result = IrreducibleUnit(s, namespace=namespace, doc=doc, format=format)
2594 
2595     if prefixes:
2596         _add_prefixes(
2597             result, excludes=exclude_prefixes, namespace=namespace, prefixes=prefixes
2598         )
2599     return result
2600 
2601 
2602 def _condition_arg(value):
2603     """
2604     Validate value is acceptable for conversion purposes.
2605 
2606     Will convert into an array if not a scalar, and can be converted
2607     into an array
2608 
2609     Parameters
2610     ----------
2611     value : int or float value, or sequence of such values
2612 
2613     Returns
2614     -------
2615     Scalar value or numpy array
2616 
2617     Raises
2618     ------
2619     ValueError
2620         If value is not as expected
2621     """
2622     if isinstance(value, (np.ndarray, float, int, complex, np.void)):
2623         return value
2624 
2625     avalue = np.array(value)
2626     if avalue.dtype.kind not in ["i", "f", "c"]:
2627         raise ValueError(
2628             "Value not scalar compatible or convertible to "
2629             "an int, float, or complex array"
2630         )
2631     return avalue
2632 
2633 
2634 def unit_scale_converter(val):
2635     """Function that just multiplies the value by unity.
2636 
2637     This is a separate function so it can be recognized and
2638     discarded in unit conversion.
2639     """
2640     return 1.0 * _condition_arg(val)
2641 
2642 
2643 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)
2644 # Abbreviation of the above, see #1980
2645 one = dimensionless_unscaled
2646 
2647 # Maintain error in old location for backward compatibility
2648 # TODO: Is this still needed? Should there be a deprecation warning?
2649 unit_format.fits.UnitScaleError = UnitScaleError

</code><intended_behavior>The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format.</intended_behavior>, <file>astropy/units/quantity.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 """
3 This module defines the `Quantity` object, which represents a number with some
4 associated units. `Quantity` objects support operations like ordinary numbers,
5 but will deal with unit conversions internally.
6 """
7 
8 # STDLIB
9 import numbers
10 import operator
11 import re
12 import warnings
13 from fractions import Fraction
14 
15 # THIRD PARTY
16 import numpy as np
17 
18 # LOCAL
19 from astropy import config as _config
20 from astropy.utils.compat import NUMPY_LT_1_22
21 from astropy.utils.data_info import ParentDtypeInfo
22 from astropy.utils.decorators import deprecated
23 from astropy.utils.exceptions import AstropyWarning
24 from astropy.utils.misc import isiterable
25 
26 from .core import (
27     Unit,
28     UnitBase,
29     UnitConversionError,
30     UnitsError,
31     UnitTypeError,
32     dimensionless_unscaled,
33     get_current_unit_registry,
34 )
35 from .format import Base, Latex
36 from .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit
37 from .quantity_helper.function_helpers import (
38     DISPATCHED_FUNCTIONS,
39     FUNCTION_HELPERS,
40     SUBCLASS_SAFE_FUNCTIONS,
41     UNSUPPORTED_FUNCTIONS,
42 )
43 from .structured import StructuredUnit, _structured_unit_like_dtype
44 from .utils import is_effectively_unity
45 
46 __all__ = [
47     "Quantity",
48     "SpecificTypeQuantity",
49     "QuantityInfoBase",
50     "QuantityInfo",
51     "allclose",
52     "isclose",
53 ]
54 
55 
56 # We don't want to run doctests in the docstrings we inherit from Numpy
57 __doctest_skip__ = ["Quantity.*"]
58 
59 _UNIT_NOT_INITIALISED = "(Unit not initialised)"
60 _UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}
61 
62 
63 class Conf(_config.ConfigNamespace):
64     """
65     Configuration parameters for Quantity.
66     """
67 
68     latex_array_threshold = _config.ConfigItem(
69         100,
70         "The maximum size an array Quantity can be before its LaTeX "
71         'representation for IPython gets "summarized" (meaning only the first '
72         'and last few elements are shown with "..." between). Setting this to a '
73         "negative number means that the value will instead be whatever numpy "
74         "gets from get_printoptions.",
75     )
76 
77 
78 conf = Conf()
79 
80 
81 class QuantityIterator:
82     """
83     Flat iterator object to iterate over Quantities.
84 
85     A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity
86     ``q``.  It allows iterating over the array as if it were a 1-D array,
87     either in a for-loop or by calling its `next` method.
88 
89     Iteration is done in C-contiguous style, with the last index varying the
90     fastest. The iterator can also be indexed using basic slicing or
91     advanced indexing.
92 
93     See Also
94     --------
95     Quantity.flatten : Returns a flattened copy of an array.
96 
97     Notes
98     -----
99     `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It
100     is not exported by the `~astropy.units` module.  Instead of
101     instantiating a `QuantityIterator` directly, use `Quantity.flat`.
102     """
103 
104     def __init__(self, q):
105         self._quantity = q
106         self._dataiter = q.view(np.ndarray).flat
107 
108     def __iter__(self):
109         return self
110 
111     def __getitem__(self, indx):
112         out = self._dataiter.__getitem__(indx)
113         # For single elements, ndarray.flat.__getitem__ returns scalars; these
114         # need a new view as a Quantity.
115         if isinstance(out, type(self._quantity)):
116             return out
117         else:
118             return self._quantity._new_view(out)
119 
120     def __setitem__(self, index, value):
121         self._dataiter[index] = self._quantity._to_own_unit(value)
122 
123     def __next__(self):
124         """
125         Return the next value, or raise StopIteration.
126         """
127         out = next(self._dataiter)
128         # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.
129         return self._quantity._new_view(out)
130 
131     next = __next__
132 
133     def __len__(self):
134         return len(self._dataiter)
135 
136     #### properties and methods to match `numpy.ndarray.flatiter` ####
137 
138     @property
139     def base(self):
140         """A reference to the array that is iterated over."""
141         return self._quantity
142 
143     @property
144     def coords(self):
145         """An N-dimensional tuple of current coordinates."""
146         return self._dataiter.coords
147 
148     @property
149     def index(self):
150         """Current flat index into the array."""
151         return self._dataiter.index
152 
153     def copy(self):
154         """Get a copy of the iterator as a 1-D array."""
155         return self._quantity.flatten()
156 
157 
158 class QuantityInfoBase(ParentDtypeInfo):
159     # This is on a base class rather than QuantityInfo directly, so that
160     # it can be used for EarthLocationInfo yet make clear that that class
161     # should not be considered a typical Quantity subclass by Table.
162     attrs_from_parent = {"dtype", "unit"}  # dtype and unit taken from parent
163     _supports_indexing = True
164 
165     @staticmethod
166     def default_format(val):
167         return f"{val.value}"
168 
169     @staticmethod
170     def possible_string_format_functions(format_):
171         """Iterate through possible string-derived format functions.
172 
173         A string can either be a format specifier for the format built-in,
174         a new-style format string, or an old-style format string.
175 
176         This method is overridden in order to suppress printing the unit
177         in each row since it is already at the top in the column header.
178         """
179         yield lambda format_, val: format(val.value, format_)
180         yield lambda format_, val: format_.format(val.value)
181         yield lambda format_, val: format_ % val.value
182 
183 
184 class QuantityInfo(QuantityInfoBase):
185     """
186     Container for meta information like name, description, format.  This is
187     required when the object is used as a mixin column within a table, but can
188     be used as a general way to store meta information.
189     """
190 
191     _represent_as_dict_attrs = ("value", "unit")
192     _construct_from_dict_args = ["value"]
193     _represent_as_dict_primary_data = "value"
194 
195     def new_like(self, cols, length, metadata_conflicts="warn", name=None):
196         """
197         Return a new Quantity instance which is consistent with the
198         input ``cols`` and has ``length`` rows.
199 
200         This is intended for creating an empty column object whose elements can
201         be set in-place for table operations like join or vstack.
202 
203         Parameters
204         ----------
205         cols : list
206             List of input columns
207         length : int
208             Length of the output column object
209         metadata_conflicts : str ('warn'|'error'|'silent')
210             How to handle metadata conflicts
211         name : str
212             Output column name
213 
214         Returns
215         -------
216         col : `~astropy.units.Quantity` (or subclass)
217             Empty instance of this class consistent with ``cols``
218 
219         """
220         # Get merged info attributes like shape, dtype, format, description, etc.
221         attrs = self.merge_cols_attributes(
222             cols, metadata_conflicts, name, ("meta", "format", "description")
223         )
224 
225         # Make an empty quantity using the unit of the last one.
226         shape = (length,) + attrs.pop("shape")
227         dtype = attrs.pop("dtype")
228         # Use zeros so we do not get problems for Quantity subclasses such
229         # as Longitude and Latitude, which cannot take arbitrary values.
230         data = np.zeros(shape=shape, dtype=dtype)
231         # Get arguments needed to reconstruct class
232         map = {
233             key: (data if key == "value" else getattr(cols[-1], key))
234             for key in self._represent_as_dict_attrs
235         }
236         map["copy"] = False
237         out = self._construct_from_dict(map)
238 
239         # Set remaining info attributes
240         for attr, value in attrs.items():
241             setattr(out.info, attr, value)
242 
243         return out
244 
245     def get_sortable_arrays(self):
246         """
247         Return a list of arrays which can be lexically sorted to represent
248         the order of the parent column.
249 
250         For Quantity this is just the quantity itself.
251 
252 
253         Returns
254         -------
255         arrays : list of ndarray
256         """
257         return [self._parent]
258 
259 
260 class Quantity(np.ndarray):
261     """A `~astropy.units.Quantity` represents a number with some associated unit.
262 
263     See also: https://docs.astropy.org/en/stable/units/quantity.html
264 
265     Parameters
266     ----------
267     value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str
268         The numerical value of this quantity in the units given by unit.  If a
269         `Quantity` or sequence of them (or any other valid object with a
270         ``unit`` attribute), creates a new `Quantity` object, converting to
271         `unit` units as needed.  If a string, it is converted to a number or
272         `Quantity`, depending on whether a unit is present.
273 
274     unit : unit-like
275         An object that represents the unit associated with the input value.
276         Must be an `~astropy.units.UnitBase` object or a string parseable by
277         the :mod:`~astropy.units` package.
278 
279     dtype : ~numpy.dtype, optional
280         The dtype of the resulting Numpy array or scalar that will
281         hold the value.  If not provided, it is determined from the input,
282         except that any integer and (non-Quantity) object inputs are converted
283         to float by default.
284         If `None`, the normal `numpy.dtype` introspection is used, e.g.
285         preventing upcasting of integers.
286 
287     copy : bool, optional
288         If `True` (default), then the value is copied.  Otherwise, a copy will
289         only be made if ``__array__`` returns a copy, if value is a nested
290         sequence, or if a copy is needed to satisfy an explicitly given
291         ``dtype``.  (The `False` option is intended mostly for internal use,
292         to speed up initialization where a copy is known to have been made.
293         Use with care.)
294 
295     order : {'C', 'F', 'A'}, optional
296         Specify the order of the array.  As in `~numpy.array`.  This parameter
297         is ignored if the input is a `Quantity` and ``copy=False``.
298 
299     subok : bool, optional
300         If `False` (default), the returned array will be forced to be a
301         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,
302         or a subclass appropriate for the unit will be used (such as
303         `~astropy.units.Dex` for ``u.dex(u.AA)``).
304 
305     ndmin : int, optional
306         Specifies the minimum number of dimensions that the resulting array
307         should have.  Ones will be prepended to the shape as needed to meet
308         this requirement.  This parameter is ignored if the input is a
309         `Quantity` and ``copy=False``.
310 
311     Raises
312     ------
313     TypeError
314         If the value provided is not a Python numeric type.
315     TypeError
316         If the unit provided is not either a :class:`~astropy.units.Unit`
317         object or a parseable string unit.
318 
319     Notes
320     -----
321     Quantities can also be created by multiplying a number or array with a
322     :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/
323 
324     Unless the ``dtype`` argument is explicitly specified, integer
325     or (non-Quantity) object inputs are converted to `float` by default.
326     """
327 
328     # Need to set a class-level default for _equivalencies, or
329     # Constants can not initialize properly
330     _equivalencies = []
331 
332     # Default unit for initialization; can be overridden by subclasses,
333     # possibly to `None` to indicate there is no default unit.
334     _default_unit = dimensionless_unscaled
335 
336     # Ensures views have an undefined unit.
337     _unit = None
338 
339     __array_priority__ = 10000
340 
341     def __class_getitem__(cls, unit_shape_dtype):
342         """Quantity Type Hints.
343 
344         Unit-aware type hints are ``Annotated`` objects that encode the class,
345         the unit, and possibly shape and dtype information, depending on the
346         python and :mod:`numpy` versions.
347 
348         Schematically, ``Annotated[cls[shape, dtype], unit]``
349 
350         As a classmethod, the type is the class, ie ``Quantity``
351         produces an ``Annotated[Quantity, ...]`` while a subclass
352         like :class:`~astropy.coordinates.Angle` returns
353         ``Annotated[Angle, ...]``.
354 
355         Parameters
356         ----------
357         unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple
358             Unit specification, can be the physical type (ie str or class).
359             If tuple, then the first element is the unit specification
360             and all other elements are for `numpy.ndarray` type annotations.
361             Whether they are included depends on the python and :mod:`numpy`
362             versions.
363 
364         Returns
365         -------
366         `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`
367             Return type in this preference order:
368             * if python v3.9+ : `typing.Annotated`
369             * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`
370             * `astropy.units.Unit` or `astropy.units.PhysicalType`
371 
372         Raises
373         ------
374         TypeError
375             If the unit/physical_type annotation is not Unit-like or
376             PhysicalType-like.
377 
378         Examples
379         --------
380         Create a unit-aware Quantity type annotation
381 
382             >>> Quantity[Unit("s")]
383             Annotated[Quantity, Unit("s")]
384 
385         See Also
386         --------
387         `~astropy.units.quantity_input`
388             Use annotations for unit checks on function arguments and results.
389 
390         Notes
391         -----
392         With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also
393         static-type compatible.
394         """
395         # LOCAL
396         from ._typing import HAS_ANNOTATED, Annotated
397 
398         # process whether [unit] or [unit, shape, ptype]
399         if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype
400             target = unit_shape_dtype[0]
401             shape_dtype = unit_shape_dtype[1:]
402         else:  # just unit
403             target = unit_shape_dtype
404             shape_dtype = ()
405 
406         # Allowed unit/physical types. Errors if neither.
407         try:
408             unit = Unit(target)
409         except (TypeError, ValueError):
410             from astropy.units.physical import get_physical_type
411 
412             try:
413                 unit = get_physical_type(target)
414             except (TypeError, ValueError, KeyError):  # KeyError for Enum
415                 raise TypeError(
416                     "unit annotation is not a Unit or PhysicalType"
417                 ) from None
418 
419         # Allow to sort of work for python 3.8- / no typing_extensions
420         # instead of bailing out, return the unit for `quantity_input`
421         if not HAS_ANNOTATED:
422             warnings.warn(
423                 "Quantity annotations are valid static type annotations only"
424                 " if Python is v3.9+ or `typing_extensions` is installed."
425             )
426             return unit
427 
428         # Quantity does not (yet) properly extend the NumPy generics types,
429         # introduced in numpy v1.22+, instead just including the unit info as
430         # metadata using Annotated.
431         # TODO: ensure we do interact with NDArray.__class_getitem__.
432         return Annotated.__class_getitem__((cls, unit))
433 
434     def __new__(
435         cls,
436         value,
437         unit=None,
438         dtype=np.inexact,
439         copy=True,
440         order=None,
441         subok=False,
442         ndmin=0,
443     ):
444         if unit is not None:
445             # convert unit first, to avoid multiple string->unit conversions
446             unit = Unit(unit)
447 
448         # inexact -> upcast to float dtype
449         float_default = dtype is np.inexact
450         if float_default:
451             dtype = None
452 
453         # optimize speed for Quantity with no dtype given, copy=False
454         if isinstance(value, Quantity):
455             if unit is not None and unit is not value.unit:
456                 value = value.to(unit)
457                 # the above already makes a copy (with float dtype)
458                 copy = False
459 
460             if type(value) is not cls and not (subok and isinstance(value, cls)):
461                 value = value.view(cls)
462 
463             if float_default and value.dtype.kind in "iu":
464                 dtype = float
465 
466             return np.array(
467                 value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin
468             )
469 
470         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.
471         # To ensure array remains fast, we short-circuit it.
472         value_unit = None
473         if not isinstance(value, np.ndarray):
474             if isinstance(value, str):
475                 # The first part of the regex string matches any integer/float;
476                 # the second parts adds possible trailing .+-, which will break
477                 # the float function below and ensure things like 1.2.3deg
478                 # will not work.
479                 pattern = (
480                     r"\s*[+-]?"
481                     r"((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|"
482                     r"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))"
483                     r"([eE][+-]?\d+)?"
484                     r"[.+-]?"
485                 )
486 
487                 v = re.match(pattern, value)
488                 unit_string = None
489                 try:
490                     value = float(v.group())
491 
492                 except Exception:
493                     raise TypeError(
494                         f'Cannot parse "{value}" as a {cls.__name__}. It does not '
495                         "start with a number."
496                     )
497 
498                 unit_string = v.string[v.end() :].strip()
499                 if unit_string:
500                     value_unit = Unit(unit_string)
501                     if unit is None:
502                         unit = value_unit  # signal no conversion needed below.
503 
504             elif isiterable(value) and len(value) > 0:
505                 # Iterables like lists and tuples.
506                 if all(isinstance(v, Quantity) for v in value):
507                     # If a list/tuple containing only quantities, convert all
508                     # to the same unit.
509                     if unit is None:
510                         unit = value[0].unit
511                     value = [q.to_value(unit) for q in value]
512                     value_unit = unit  # signal below that conversion has been done
513                 elif (
514                     dtype is None
515                     and not hasattr(value, "dtype")
516                     and isinstance(unit, StructuredUnit)
517                 ):
518                     # Special case for list/tuple of values and a structured unit:
519                     # ``np.array(value, dtype=None)`` would treat tuples as lower
520                     # levels of the array, rather than as elements of a structured
521                     # array, so we use the structure of the unit to help infer the
522                     # structured dtype of the value.
523                     dtype = unit._recursively_get_dtype(value)
524 
525         using_default_unit = False
526         if value_unit is None:
527             # If the value has a `unit` attribute and if not None
528             # (for Columns with uninitialized unit), treat it like a quantity.
529             value_unit = getattr(value, "unit", None)
530             if value_unit is None:
531                 # Default to dimensionless for no (initialized) unit attribute.
532                 if unit is None:
533                     using_default_unit = True
534                     unit = cls._default_unit
535                 value_unit = unit  # signal below that no conversion is needed
536             else:
537                 try:
538                     value_unit = Unit(value_unit)
539                 except Exception as exc:
540                     raise TypeError(
541                         f"The unit attribute {value.unit!r} of the input could "
542                         "not be parsed as an astropy Unit."
543                     ) from exc
544 
545                 if unit is None:
546                     unit = value_unit
547                 elif unit is not value_unit:
548                     copy = False  # copy will be made in conversion at end
549 
550         value = np.array(
551             value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin
552         )
553 
554         # For no-user-input unit, make sure the constructed unit matches the
555         # structure of the data.
556         if using_default_unit and value.dtype.names is not None:
557             unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)
558 
559         # check that array contains numbers or long int objects
560         if value.dtype.kind in "OSU" and not (
561             value.dtype.kind == "O" and isinstance(value.item(0), numbers.Number)
562         ):
563             raise TypeError("The value must be a valid Python or Numpy numeric type.")
564 
565         # by default, cast any integer, boolean, etc., to float
566         if float_default and value.dtype.kind in "iuO":
567             value = value.astype(float)
568 
569         # if we allow subclasses, allow a class from the unit.
570         if subok:
571             qcls = getattr(unit, "_quantity_class", cls)
572             if issubclass(qcls, cls):
573                 cls = qcls
574 
575         value = value.view(cls)
576         value._set_unit(value_unit)
577         if unit is value_unit:
578             return value
579         else:
580             # here we had non-Quantity input that had a "unit" attribute
581             # with a unit different from the desired one.  So, convert.
582             return value.to(unit)
583 
584     def __array_finalize__(self, obj):
585         # Check whether super().__array_finalize should be called
586         # (sadly, ndarray.__array_finalize__ is None; we cannot be sure
587         # what is above us).
588         super_array_finalize = super().__array_finalize__
589         if super_array_finalize is not None:
590             super_array_finalize(obj)
591 
592         # If we're a new object or viewing an ndarray, nothing has to be done.
593         if obj is None or obj.__class__ is np.ndarray:
594             return
595 
596         # If our unit is not set and obj has a valid one, use it.
597         if self._unit is None:
598             unit = getattr(obj, "_unit", None)
599             if unit is not None:
600                 self._set_unit(unit)
601 
602         # Copy info if the original had `info` defined.  Because of the way the
603         # DataInfo works, `'info' in obj.__dict__` is False until the
604         # `info` attribute is accessed or set.
605         if "info" in obj.__dict__:
606             self.info = obj.info
607 
608     def __array_wrap__(self, obj, context=None):
609         if context is None:
610             # Methods like .squeeze() created a new `ndarray` and then call
611             # __array_wrap__ to turn the array into self's subclass.
612             return self._new_view(obj)
613 
614         raise NotImplementedError(
615             "__array_wrap__ should not be used with a context any more since all "
616             "use should go through array_function. Please raise an issue on "
617             "https://github.com/astropy/astropy"
618         )
619 
620     def __array_ufunc__(self, function, method, *inputs, **kwargs):
621         """Wrap numpy ufuncs, taking care of units.
622 
623         Parameters
624         ----------
625         function : callable
626             ufunc to wrap.
627         method : str
628             Ufunc method: ``__call__``, ``at``, ``reduce``, etc.
629         inputs : tuple
630             Input arrays.
631         kwargs : keyword arguments
632             As passed on, with ``out`` containing possible quantity output.
633 
634         Returns
635         -------
636         result : `~astropy.units.Quantity` or `NotImplemented`
637             Results of the ufunc, with the unit set properly.
638         """
639         # Determine required conversion functions -- to bring the unit of the
640         # input to that expected (e.g., radian for np.sin), or to get
641         # consistent units between two inputs (e.g., in np.add) --
642         # and the unit of the result (or tuple of units for nout > 1).
643         try:
644             converters, unit = converters_and_unit(function, method, *inputs)
645 
646             out = kwargs.get("out", None)
647             # Avoid loop back by turning any Quantity output into array views.
648             if out is not None:
649                 # If pre-allocated output is used, check it is suitable.
650                 # This also returns array view, to ensure we don't loop back.
651                 if function.nout == 1:
652                     out = out[0]
653                 out_array = check_output(out, unit, inputs, function=function)
654                 # Ensure output argument remains a tuple.
655                 kwargs["out"] = (out_array,) if function.nout == 1 else out_array
656 
657             if method == "reduce" and "initial" in kwargs and unit is not None:
658                 # Special-case for initial argument for reductions like
659                 # np.add.reduce.  This should be converted to the output unit as
660                 # well, which is typically the same as the input unit (but can
661                 # in principle be different: unitless for np.equal, radian
662                 # for np.arctan2, though those are not necessarily useful!)
663                 kwargs["initial"] = self._to_own_unit(
664                     kwargs["initial"], check_precision=False, unit=unit
665                 )
666 
667             # Same for inputs, but here also convert if necessary.
668             arrays = []
669             for input_, converter in zip(inputs, converters):
670                 input_ = getattr(input_, "value", input_)
671                 arrays.append(converter(input_) if converter else input_)
672 
673             # Call our superclass's __array_ufunc__
674             result = super().__array_ufunc__(function, method, *arrays, **kwargs)
675             # If unit is None, a plain array is expected (e.g., comparisons), which
676             # means we're done.
677             # We're also done if the result was None (for method 'at') or
678             # NotImplemented, which can happen if other inputs/outputs override
679             # __array_ufunc__; hopefully, they can then deal with us.
680             if unit is None or result is None or result is NotImplemented:
681                 return result
682 
683             return self._result_as_quantity(result, unit, out)
684 
685         except (TypeError, ValueError) as e:
686             out_normalized = kwargs.get("out", tuple())
687             inputs_and_outputs = inputs + out_normalized
688             ignored_ufunc = (
689                 None,
690                 np.ndarray.__array_ufunc__,
691                 type(self).__array_ufunc__,
692             )
693             if not all(
694                 getattr(type(io), "__array_ufunc__", None) in ignored_ufunc
695                 for io in inputs_and_outputs
696             ):
697                 return NotImplemented
698             else:
699                 raise e
700 
701     def _result_as_quantity(self, result, unit, out):
702         """Turn result into a quantity with the given unit.
703 
704         If no output is given, it will take a view of the array as a quantity,
705         and set the unit.  If output is given, those should be quantity views
706         of the result arrays, and the function will just set the unit.
707 
708         Parameters
709         ----------
710         result : ndarray or tuple thereof
711             Array(s) which need to be turned into quantity.
712         unit : `~astropy.units.Unit`
713             Unit for the quantities to be returned (or `None` if the result
714             should not be a quantity).  Should be tuple if result is a tuple.
715         out : `~astropy.units.Quantity` or None
716             Possible output quantity. Should be `None` or a tuple if result
717             is a tuple.
718 
719         Returns
720         -------
721         out : `~astropy.units.Quantity`
722            With units set.
723         """
724         if isinstance(result, (tuple, list)):
725             if out is None:
726                 out = (None,) * len(result)
727             return result.__class__(
728                 self._result_as_quantity(result_, unit_, out_)
729                 for (result_, unit_, out_) in zip(result, unit, out)
730             )
731 
732         if out is None:
733             # View the result array as a Quantity with the proper unit.
734             return (
735                 result if unit is None else self._new_view(result, unit, finalize=False)
736             )
737 
738         elif isinstance(out, Quantity):
739             # For given Quantity output, just set the unit. We know the unit
740             # is not None and the output is of the correct Quantity subclass,
741             # as it was passed through check_output.
742             # (We cannot do this unconditionally, though, since it is possible
743             # for out to be ndarray and the unit to be dimensionless.)
744             out._set_unit(unit)
745 
746         return out
747 
748     def __quantity_subclass__(self, unit):
749         """
750         Overridden by subclasses to change what kind of view is
751         created based on the output unit of an operation.
752 
753         Parameters
754         ----------
755         unit : UnitBase
756             The unit for which the appropriate class should be returned
757 
758         Returns
759         -------
760         tuple :
761             - `~astropy.units.Quantity` subclass
762             - bool: True if subclasses of the given class are ok
763         """
764         return Quantity, True
765 
766     def _new_view(self, obj=None, unit=None, finalize=True):
767         """Create a Quantity view of some array-like input, and set the unit.
768 
769         By default, return a view of ``obj`` of the same class as ``self`` and
770         with the same unit.  Subclasses can override the type of class for a
771         given unit using ``__quantity_subclass__``, and can ensure properties
772         other than the unit are copied using ``__array_finalize__``.
773 
774         If the given unit defines a ``_quantity_class`` of which ``self``
775         is not an instance, a view using this class is taken.
776 
777         Parameters
778         ----------
779         obj : ndarray or scalar, optional
780             The array to create a view of.  If obj is a numpy or python scalar,
781             it will be converted to an array scalar.  By default, ``self``
782             is converted.
783 
784         unit : unit-like, optional
785             The unit of the resulting object.  It is used to select a
786             subclass, and explicitly assigned to the view if given.
787             If not given, the subclass and unit will be that of ``self``.
788 
789         finalize : bool, optional
790             Whether to call ``__array_finalize__`` to transfer properties from
791             ``self`` to the new view of ``obj`` (e.g., ``info`` for all
792             subclasses, or ``_wrap_angle`` for `~astropy.coordinates.Latitude`).
793             Default: `True`, as appropriate for, e.g., unit conversions or slicing,
794             where the nature of the object does not change.
795 
796         Returns
797         -------
798         view : `~astropy.units.Quantity` subclass
799 
800         """
801         # Determine the unit and quantity subclass that we need for the view.
802         if unit is None:
803             unit = self.unit
804             quantity_subclass = self.__class__
805         elif unit is self.unit and self.__class__ is Quantity:
806             # The second part is because we should not presume what other
807             # classes want to do for the same unit.  E.g., Constant will
808             # always want to fall back to Quantity, and relies on going
809             # through `__quantity_subclass__`.
810             quantity_subclass = Quantity
811         else:
812             unit = Unit(unit)
813             quantity_subclass = getattr(unit, "_quantity_class", Quantity)
814             if isinstance(self, quantity_subclass):
815                 quantity_subclass, subok = self.__quantity_subclass__(unit)
816                 if subok:
817                     quantity_subclass = self.__class__
818 
819         # We only want to propagate information from ``self`` to our new view,
820         # so obj should be a regular array.  By using ``np.array``, we also
821         # convert python and numpy scalars, which cannot be viewed as arrays
822         # and thus not as Quantity either, to zero-dimensional arrays.
823         # (These are turned back into scalar in `.value`)
824         # Note that for an ndarray input, the np.array call takes only double
825         # ``obj.__class is np.ndarray``. So, not worth special-casing.
826         if obj is None:
827             obj = self.view(np.ndarray)
828         else:
829             obj = np.array(obj, copy=False, subok=True)
830 
831         # Take the view, set the unit, and update possible other properties
832         # such as ``info``, ``wrap_angle`` in `Longitude`, etc.
833         view = obj.view(quantity_subclass)
834         view._set_unit(unit)
835         if finalize:
836             view.__array_finalize__(self)
837         return view
838 
839     def _set_unit(self, unit):
840         """Set the unit.
841 
842         This is used anywhere the unit is set or modified, i.e., in the
843         initializer, in ``__imul__`` and ``__itruediv__`` for in-place
844         multiplication and division by another unit, as well as in
845         ``__array_finalize__`` for wrapping up views.  For Quantity, it just
846         sets the unit, but subclasses can override it to check that, e.g.,
847         a unit is consistent.
848         """
849         if not isinstance(unit, UnitBase):
850             if isinstance(self._unit, StructuredUnit) or isinstance(
851                 unit, StructuredUnit
852             ):
853                 unit = StructuredUnit(unit, self.dtype)
854             else:
855                 # Trying to go through a string ensures that, e.g., Magnitudes with
856                 # dimensionless physical unit become Quantity with units of mag.
857                 unit = Unit(str(unit), parse_strict="silent")
858                 if not isinstance(unit, (UnitBase, StructuredUnit)):
859                     raise UnitTypeError(
860                         f"{self.__class__.__name__} instances require normal units, "
861                         f"not {unit.__class__} instances."
862                     )
863 
864         self._unit = unit
865 
866     def __deepcopy__(self, memo):
867         # If we don't define this, ``copy.deepcopy(quantity)`` will
868         # return a bare Numpy array.
869         return self.copy()
870 
871     def __reduce__(self):
872         # patch to pickle Quantity objects (ndarray subclasses), see
873         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
874 
875         object_state = list(super().__reduce__())
876         object_state[2] = (object_state[2], self.__dict__)
877         return tuple(object_state)
878 
879     def __setstate__(self, state):
880         # patch to unpickle Quantity objects (ndarray subclasses), see
881         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
882 
883         nd_state, own_state = state
884         super().__setstate__(nd_state)
885         self.__dict__.update(own_state)
886 
887     info = QuantityInfo()
888 
889     def _to_value(self, unit, equivalencies=[]):
890         """Helper method for to and to_value."""
891         if equivalencies == []:
892             equivalencies = self._equivalencies
893         if not self.dtype.names or isinstance(self.unit, StructuredUnit):
894             # Standard path, let unit to do work.
895             return self.unit.to(
896                 unit, self.view(np.ndarray), equivalencies=equivalencies
897             )
898 
899         else:
900             # The .to() method of a simple unit cannot convert a structured
901             # dtype, so we work around it, by recursing.
902             # TODO: deprecate this?
903             # Convert simple to Structured on initialization?
904             result = np.empty_like(self.view(np.ndarray))
905             for name in self.dtype.names:
906                 result[name] = self[name]._to_value(unit, equivalencies)
907             return result
908 
909     def to(self, unit, equivalencies=[], copy=True):
910         """
911         Return a new `~astropy.units.Quantity` object with the specified unit.
912 
913         Parameters
914         ----------
915         unit : unit-like
916             An object that represents the unit to convert to. Must be
917             an `~astropy.units.UnitBase` object or a string parseable
918             by the `~astropy.units` package.
919 
920         equivalencies : list of tuple
921             A list of equivalence pairs to try if the units are not
922             directly convertible.  See :ref:`astropy:unit_equivalencies`.
923             If not provided or ``[]``, class default equivalencies will be used
924             (none for `~astropy.units.Quantity`, but may be set for subclasses)
925             If `None`, no equivalencies will be applied at all, not even any
926             set globally or within a context.
927 
928         copy : bool, optional
929             If `True` (default), then the value is copied.  Otherwise, a copy
930             will only be made if necessary.
931 
932         See Also
933         --------
934         to_value : get the numerical value in a given unit.
935         """
936         # We don't use `to_value` below since we always want to make a copy
937         # and don't want to slow down this method (esp. the scalar case).
938         unit = Unit(unit)
939         if copy:
940             # Avoid using to_value to ensure that we make a copy. We also
941             # don't want to slow down this method (esp. the scalar case).
942             value = self._to_value(unit, equivalencies)
943         else:
944             # to_value only copies if necessary
945             value = self.to_value(unit, equivalencies)
946         return self._new_view(value, unit)
947 
948     def to_value(self, unit=None, equivalencies=[]):
949         """
950         The numerical value, possibly in a different unit.
951 
952         Parameters
953         ----------
954         unit : unit-like, optional
955             The unit in which the value should be given. If not given or `None`,
956             use the current unit.
957 
958         equivalencies : list of tuple, optional
959             A list of equivalence pairs to try if the units are not directly
960             convertible (see :ref:`astropy:unit_equivalencies`). If not provided
961             or ``[]``, class default equivalencies will be used (none for
962             `~astropy.units.Quantity`, but may be set for subclasses).
963             If `None`, no equivalencies will be applied at all, not even any
964             set globally or within a context.
965 
966         Returns
967         -------
968         value : ndarray or scalar
969             The value in the units specified. For arrays, this will be a view
970             of the data if no unit conversion was necessary.
971 
972         See Also
973         --------
974         to : Get a new instance in a different unit.
975         """
976         if unit is None or unit is self.unit:
977             value = self.view(np.ndarray)
978         elif not self.dtype.names:
979             # For non-structured, we attempt a short-cut, where we just get
980             # the scale.  If that is 1, we do not have to do anything.
981             unit = Unit(unit)
982             # We want a view if the unit does not change.  One could check
983             # with "==", but that calculates the scale that we need anyway.
984             # TODO: would be better for `unit.to` to have an in-place flag.
985             try:
986                 scale = self.unit._to(unit)
987             except Exception:
988                 # Short-cut failed; try default (maybe equivalencies help).
989                 value = self._to_value(unit, equivalencies)
990             else:
991                 value = self.view(np.ndarray)
992                 if not is_effectively_unity(scale):
993                     # not in-place!
994                     value = value * scale
995         else:
996             # For structured arrays, we go the default route.
997             value = self._to_value(unit, equivalencies)
998 
999         # Index with empty tuple to decay array scalars in to numpy scalars.
1000         return value if value.shape else value[()]
1001 
1002     value = property(
1003         to_value,
1004         doc="""The numerical value of this instance.
1005 
1006     See also
1007     --------
1008     to_value : Get the numerical value in a given unit.
1009     """,
1010     )
1011 
1012     @property
1013     def unit(self):
1014         """
1015         A `~astropy.units.UnitBase` object representing the unit of this
1016         quantity.
1017         """
1018         return self._unit
1019 
1020     @property
1021     def equivalencies(self):
1022         """
1023         A list of equivalencies that will be applied by default during
1024         unit conversions.
1025         """
1026         return self._equivalencies
1027 
1028     def _recursively_apply(self, func):
1029         """Apply function recursively to every field.
1030 
1031         Returns a copy with the result.
1032         """
1033         result = np.empty_like(self)
1034         result_value = result.view(np.ndarray)
1035         result_unit = ()
1036         for name in self.dtype.names:
1037             part = func(self[name])
1038             result_value[name] = part.value
1039             result_unit += (part.unit,)
1040 
1041         result._set_unit(result_unit)
1042         return result
1043 
1044     @property
1045     def si(self):
1046         """
1047         Returns a copy of the current `Quantity` instance with SI units. The
1048         value of the resulting object will be scaled.
1049         """
1050         if self.dtype.names:
1051             return self._recursively_apply(operator.attrgetter("si"))
1052         si_unit = self.unit.si
1053         return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)
1054 
1055     @property
1056     def cgs(self):
1057         """
1058         Returns a copy of the current `Quantity` instance with CGS units. The
1059         value of the resulting object will be scaled.
1060         """
1061         if self.dtype.names:
1062             return self._recursively_apply(operator.attrgetter("cgs"))
1063         cgs_unit = self.unit.cgs
1064         return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)
1065 
1066     @property
1067     def isscalar(self):
1068         """
1069         True if the `value` of this quantity is a scalar, or False if it
1070         is an array-like object.
1071 
1072         .. note::
1073             This is subtly different from `numpy.isscalar` in that
1074             `numpy.isscalar` returns False for a zero-dimensional array
1075             (e.g. ``np.array(1)``), while this is True for quantities,
1076             since quantities cannot represent true numpy scalars.
1077         """
1078         return not self.shape
1079 
1080     # This flag controls whether convenience conversion members, such
1081     # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is
1082     # not turned on on Quantity itself, but is on some subclasses of
1083     # Quantity, such as `astropy.coordinates.Angle`.
1084     _include_easy_conversion_members = False
1085 
1086     def __dir__(self):
1087         """
1088         Quantities are able to directly convert to other units that
1089         have the same physical type.  This function is implemented in
1090         order to make autocompletion still work correctly in IPython.
1091         """
1092         if not self._include_easy_conversion_members:
1093             return super().__dir__()
1094 
1095         dir_values = set(super().__dir__())
1096         equivalencies = Unit._normalize_equivalencies(self.equivalencies)
1097         for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):
1098             dir_values.update(equivalent.names)
1099         return sorted(dir_values)
1100 
1101     def __getattr__(self, attr):
1102         """
1103         Quantities are able to directly convert to other units that
1104         have the same physical type.
1105         """
1106         if not self._include_easy_conversion_members:
1107             raise AttributeError(
1108                 f"'{self.__class__.__name__}' object has no '{attr}' member"
1109             )
1110 
1111         def get_virtual_unit_attribute():
1112             registry = get_current_unit_registry().registry
1113             to_unit = registry.get(attr, None)
1114             if to_unit is None:
1115                 return None
1116 
1117             try:
1118                 return self.unit.to(
1119                     to_unit, self.value, equivalencies=self.equivalencies
1120                 )
1121             except UnitsError:
1122                 return None
1123 
1124         value = get_virtual_unit_attribute()
1125 
1126         if value is None:
1127             raise AttributeError(
1128                 f"{self.__class__.__name__} instance has no attribute '{attr}'"
1129             )
1130         else:
1131             return value
1132 
1133     # Equality needs to be handled explicitly as ndarray.__eq__ gives
1134     # DeprecationWarnings on any error, which is distracting, and does not
1135     # deal well with structured arrays (nor does the ufunc).
1136     def __eq__(self, other):
1137         try:
1138             other_value = self._to_own_unit(other)
1139         except UnitsError:
1140             return False
1141         except Exception:
1142             return NotImplemented
1143         return self.value.__eq__(other_value)
1144 
1145     def __ne__(self, other):
1146         try:
1147             other_value = self._to_own_unit(other)
1148         except UnitsError:
1149             return True
1150         except Exception:
1151             return NotImplemented
1152         return self.value.__ne__(other_value)
1153 
1154     # Unit conversion operator (<<).
1155     def __lshift__(self, other):
1156         try:
1157             other = Unit(other, parse_strict="silent")
1158         except UnitTypeError:
1159             return NotImplemented
1160 
1161         return self.__class__(self, other, copy=False, subok=True)
1162 
1163     def __ilshift__(self, other):
1164         try:
1165             other = Unit(other, parse_strict="silent")
1166         except UnitTypeError:
1167             return NotImplemented  # try other.__rlshift__(self)
1168 
1169         try:
1170             factor = self.unit._to(other)
1171         except UnitConversionError:  # incompatible, or requires an Equivalency
1172             return NotImplemented
1173         except AttributeError:  # StructuredUnit does not have `_to`
1174             # In principle, in-place might be possible.
1175             return NotImplemented
1176 
1177         view = self.view(np.ndarray)
1178         try:
1179             view *= factor  # operates on view
1180         except TypeError:
1181             # The error is `numpy.core._exceptions._UFuncOutputCastingError`,
1182             # which inherits from `TypeError`.
1183             return NotImplemented
1184 
1185         self._set_unit(other)
1186         return self
1187 
1188     def __rlshift__(self, other):
1189         if not self.isscalar:
1190             return NotImplemented
1191         return Unit(self).__rlshift__(other)
1192 
1193     # Give warning for other >> self, since probably other << self was meant.
1194     def __rrshift__(self, other):
1195         warnings.warn(
1196             ">> is not implemented. Did you mean to convert "
1197             "something to this quantity as a unit using '<<'?",
1198             AstropyWarning,
1199         )
1200         return NotImplemented
1201 
1202     # Also define __rshift__ and __irshift__ so we override default ndarray
1203     # behaviour, but instead of emitting a warning here, let it be done by
1204     # other (which likely is a unit if this was a mistake).
1205     def __rshift__(self, other):
1206         return NotImplemented
1207 
1208     def __irshift__(self, other):
1209         return NotImplemented
1210 
1211     # Arithmetic operations
1212     def __mul__(self, other):
1213         """Multiplication between `Quantity` objects and other objects."""
1214         if isinstance(other, (UnitBase, str)):
1215             try:
1216                 return self._new_view(
1217                     self.value.copy(), other * self.unit, finalize=False
1218                 )
1219             except UnitsError:  # let other try to deal with it
1220                 return NotImplemented
1221 
1222         return super().__mul__(other)
1223 
1224     def __imul__(self, other):
1225         """In-place multiplication between `Quantity` objects and others."""
1226         if isinstance(other, (UnitBase, str)):
1227             self._set_unit(other * self.unit)
1228             return self
1229 
1230         return super().__imul__(other)
1231 
1232     def __rmul__(self, other):
1233         """
1234         Right Multiplication between `Quantity` objects and other objects.
1235         """
1236         return self.__mul__(other)
1237 
1238     def __truediv__(self, other):
1239         """Division between `Quantity` objects and other objects."""
1240         if isinstance(other, (UnitBase, str)):
1241             try:
1242                 return self._new_view(
1243                     self.value.copy(), self.unit / other, finalize=False
1244                 )
1245             except UnitsError:  # let other try to deal with it
1246                 return NotImplemented
1247 
1248         return super().__truediv__(other)
1249 
1250     def __itruediv__(self, other):
1251         """Inplace division between `Quantity` objects and other objects."""
1252         if isinstance(other, (UnitBase, str)):
1253             self._set_unit(self.unit / other)
1254             return self
1255 
1256         return super().__itruediv__(other)
1257 
1258     def __rtruediv__(self, other):
1259         """Right Division between `Quantity` objects and other objects."""
1260         if isinstance(other, (UnitBase, str)):
1261             return self._new_view(1.0 / self.value, other / self.unit, finalize=False)
1262 
1263         return super().__rtruediv__(other)
1264 
1265     def __pow__(self, other):
1266         if isinstance(other, Fraction):
1267             # Avoid getting object arrays by raising the value to a Fraction.
1268             return self._new_view(
1269                 self.value ** float(other), self.unit**other, finalize=False
1270             )
1271 
1272         return super().__pow__(other)
1273 
1274     # other overrides of special functions
1275     def __hash__(self):
1276         return hash(self.value) ^ hash(self.unit)
1277 
1278     def __iter__(self):
1279         if self.isscalar:
1280             raise TypeError(
1281                 f"'{self.__class__.__name__}' object with a scalar value is not"
1282                 " iterable"
1283             )
1284 
1285         # Otherwise return a generator
1286         def quantity_iter():
1287             for val in self.value:
1288                 yield self._new_view(val)
1289 
1290         return quantity_iter()
1291 
1292     def __getitem__(self, key):
1293         if isinstance(key, str) and isinstance(self.unit, StructuredUnit):
1294             return self._new_view(
1295                 self.view(np.ndarray)[key], self.unit[key], finalize=False
1296             )
1297 
1298         try:
1299             out = super().__getitem__(key)
1300         except IndexError:
1301             # We want zero-dimensional Quantity objects to behave like scalars,
1302             # so they should raise a TypeError rather than an IndexError.
1303             if self.isscalar:
1304                 raise TypeError(
1305                     f"'{self.__class__.__name__}' object with a scalar value "
1306                     "does not support indexing"
1307                 )
1308             else:
1309                 raise
1310         # For single elements, ndarray.__getitem__ returns scalars; these
1311         # need a new view as a Quantity.
1312         if not isinstance(out, np.ndarray):
1313             out = self._new_view(out)
1314         return out
1315 
1316     def __setitem__(self, i, value):
1317         if isinstance(i, str):
1318             # Indexing will cause a different unit, so by doing this in
1319             # two steps we effectively try with the right unit.
1320             self[i][...] = value
1321             return
1322 
1323         # update indices in info if the info property has been accessed
1324         # (in which case 'info' in self.__dict__ is True; this is guaranteed
1325         # to be the case if we're part of a table).
1326         if not self.isscalar and "info" in self.__dict__:
1327             self.info.adjust_indices(i, value, len(self))
1328         self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))
1329 
1330     # __contains__ is OK
1331 
1332     def __bool__(self):
1333         """This method raises ValueError, since truthiness of quantities is ambiguous,
1334         especially for logarithmic units and temperatures. Use explicit comparisons.
1335         """
1336         raise ValueError(
1337             f"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units"
1338             " and temperatures. Use explicit comparisons."
1339         )
1340 
1341     def __len__(self):
1342         if self.isscalar:
1343             raise TypeError(
1344                 f"'{self.__class__.__name__}' object with a scalar value has no len()"
1345             )
1346         else:
1347             return len(self.value)
1348 
1349     # Numerical types
1350     def __float__(self):
1351         try:
1352             return float(self.to_value(dimensionless_unscaled))
1353         except (UnitsError, TypeError):
1354             raise TypeError(
1355                 "only dimensionless scalar quantities can be "
1356                 "converted to Python scalars"
1357             )
1358 
1359     def __int__(self):
1360         try:
1361             return int(self.to_value(dimensionless_unscaled))
1362         except (UnitsError, TypeError):
1363             raise TypeError(
1364                 "only dimensionless scalar quantities can be "
1365                 "converted to Python scalars"
1366             )
1367 
1368     def __index__(self):
1369         # for indices, we do not want to mess around with scaling at all,
1370         # so unlike for float, int, we insist here on unscaled dimensionless
1371         try:
1372             assert self.unit.is_unity()
1373             return self.value.__index__()
1374         except Exception:
1375             raise TypeError(
1376                 "only integer dimensionless scalar quantities "
1377                 "can be converted to a Python index"
1378             )
1379 
1380     # TODO: we may want to add a hook for dimensionless quantities?
1381     @property
1382     def _unitstr(self):
1383         if self.unit is None:
1384             unitstr = _UNIT_NOT_INITIALISED
1385         else:
1386             unitstr = str(self.unit)
1387 
1388         if unitstr:
1389             unitstr = " " + unitstr
1390 
1391         return unitstr
1392 
1393     def to_string(self, unit=None, precision=None, format=None, subfmt=None):
1394         """
1395         Generate a string representation of the quantity and its unit.
1396 
1397         The behavior of this function can be altered via the
1398         `numpy.set_printoptions` function and its various keywords.  The
1399         exception to this is the ``threshold`` keyword, which is controlled via
1400         the ``[units.quantity]`` configuration item ``latex_array_threshold``.
1401         This is treated separately because the numpy default of 1000 is too big
1402         for most browsers to handle.
1403 
1404         Parameters
1405         ----------
1406         unit : unit-like, optional
1407             Specifies the unit.  If not provided,
1408             the unit used to initialize the quantity will be used.
1409 
1410         precision : number, optional
1411             The level of decimal precision. If `None`, or not provided,
1412             it will be determined from NumPy print options.
1413 
1414         format : str, optional
1415             The format of the result. If not provided, an unadorned
1416             string is returned. Supported values are:
1417 
1418             - 'latex': Return a LaTeX-formatted string
1419 
1420             - 'latex_inline': Return a LaTeX-formatted string that uses
1421               negative exponents instead of fractions
1422 
1423         subfmt : str, optional
1424             Subformat of the result. For the moment, only used for
1425             ``format='latex'`` and ``format='latex_inline'``. Supported
1426             values are:
1427 
1428             - 'inline': Use ``$ ... $`` as delimiters.
1429 
1430             - 'display': Use ``$\\displaystyle ... $`` as delimiters.
1431 
1432         Returns
1433         -------
1434         str
1435             A string with the contents of this Quantity
1436         """
1437         if unit is not None and unit != self.unit:
1438             return self.to(unit).to_string(
1439                 unit=None, precision=precision, format=format, subfmt=subfmt
1440             )
1441 
1442         formats = {
1443             None: None,
1444             "latex": {
1445                 None: ("$", "$"),
1446                 "inline": ("$", "$"),
1447                 "display": (r"$\displaystyle ", r"$"),
1448             },
1449         }
1450         formats["latex_inline"] = formats["latex"]
1451 
1452         if format not in formats:
1453             raise ValueError(f"Unknown format '{format}'")
1454         elif format is None:
1455             if precision is None:
1456                 # Use default formatting settings
1457                 return f"{self.value}{self._unitstr:s}"
1458             else:
1459                 # np.array2string properly formats arrays as well as scalars
1460                 return (
1461                     np.array2string(self.value, precision=precision, floatmode="fixed")
1462                     + self._unitstr
1463                 )
1464 
1465         # else, for the moment we assume format="latex" or "latex_inline".
1466 
1467         # Set the precision if set, otherwise use numpy default
1468         pops = np.get_printoptions()
1469         format_spec = f".{precision if precision is not None else pops['precision']}g"
1470 
1471         def float_formatter(value):
1472             return Latex.format_exponential_notation(value, format_spec=format_spec)
1473 
1474         def complex_formatter(value):
1475             return "({}{}i)".format(
1476                 Latex.format_exponential_notation(value.real, format_spec=format_spec),
1477                 Latex.format_exponential_notation(
1478                     value.imag, format_spec="+" + format_spec
1479                 ),
1480             )
1481 
1482         # The view is needed for the scalar case - self.value might be float.
1483         latex_value = np.array2string(
1484             self.view(np.ndarray),
1485             threshold=(
1486                 conf.latex_array_threshold
1487                 if conf.latex_array_threshold > -1
1488                 else pops["threshold"]
1489             ),
1490             formatter={
1491                 "float_kind": float_formatter,
1492                 "complex_kind": complex_formatter,
1493             },
1494             max_line_width=np.inf,
1495             separator=",~",
1496         )
1497 
1498         latex_value = latex_value.replace("...", r"\dots")
1499 
1500         # Format unit
1501         # [1:-1] strips the '$' on either side needed for math mode
1502         if self.unit is None:
1503             latex_unit = _UNIT_NOT_INITIALISED
1504         elif format == "latex":
1505             latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode
1506         elif format == "latex_inline":
1507             latex_unit = self.unit.to_string(format="latex_inline")[1:-1]
1508 
1509         delimiter_left, delimiter_right = formats[format][subfmt]
1510 
1511         return rf"{delimiter_left}{latex_value} \; {latex_unit}{delimiter_right}"
1512 
1513     def __str__(self):
1514         return self.to_string()
1515 
1516     def __repr__(self):
1517         prefixstr = "<" + self.__class__.__name__ + " "
1518         arrstr = np.array2string(
1519             self.view(np.ndarray), separator=", ", prefix=prefixstr
1520         )
1521         return f"{prefixstr}{arrstr}{self._unitstr:s}>"
1522 
1523     def _repr_latex_(self):
1524         """
1525         Generate a latex representation of the quantity and its unit.
1526 
1527         Returns
1528         -------
1529         lstr
1530             A LaTeX string with the contents of this Quantity
1531         """
1532         # NOTE: This should change to display format in a future release
1533         return self.to_string(format="latex", subfmt="inline")
1534 
1535     def __format__(self, format_spec):
1536         try:
1537             return self.to_string(format=format_spec)
1538         except ValueError:
1539             # We might have a unit format not implemented in `to_string()`.
1540             if format_spec in Base.registry:
1541                 if self.unit is dimensionless_unscaled:
1542                     return f"{self.value}"
1543                 else:
1544                     return f"{self.value} {format(self.unit, format_spec)}"
1545             # Can the value be formatted on its own?
1546             try:
1547                 return f"{format(self.value, format_spec)}{self._unitstr:s}"
1548             except ValueError:
1549                 # Format the whole thing as a single string.
1550                 return format(f"{self.value}{self._unitstr:s}", format_spec)
1551 
1552     def decompose(self, bases=[]):
1553         """
1554         Generates a new `Quantity` with the units
1555         decomposed. Decomposed units have only irreducible units in
1556         them (see `astropy.units.UnitBase.decompose`).
1557 
1558         Parameters
1559         ----------
1560         bases : sequence of `~astropy.units.UnitBase`, optional
1561             The bases to decompose into.  When not provided,
1562             decomposes down to any irreducible units.  When provided,
1563             the decomposed result will only contain the given units.
1564             This will raises a `~astropy.units.UnitsError` if it's not possible
1565             to do so.
1566 
1567         Returns
1568         -------
1569         newq : `~astropy.units.Quantity`
1570             A new object equal to this quantity with units decomposed.
1571         """
1572         return self._decompose(False, bases=bases)
1573 
1574     def _decompose(self, allowscaledunits=False, bases=[]):
1575         """
1576         Generates a new `Quantity` with the units decomposed. Decomposed
1577         units have only irreducible units in them (see
1578         `astropy.units.UnitBase.decompose`).
1579 
1580         Parameters
1581         ----------
1582         allowscaledunits : bool
1583             If True, the resulting `Quantity` may have a scale factor
1584             associated with it.  If False, any scaling in the unit will
1585             be subsumed into the value of the resulting `Quantity`
1586 
1587         bases : sequence of UnitBase, optional
1588             The bases to decompose into.  When not provided,
1589             decomposes down to any irreducible units.  When provided,
1590             the decomposed result will only contain the given units.
1591             This will raises a `~astropy.units.UnitsError` if it's not possible
1592             to do so.
1593 
1594         Returns
1595         -------
1596         newq : `~astropy.units.Quantity`
1597             A new object equal to this quantity with units decomposed.
1598 
1599         """
1600         new_unit = self.unit.decompose(bases=bases)
1601 
1602         # Be careful here because self.value usually is a view of self;
1603         # be sure that the original value is not being modified.
1604         if not allowscaledunits and hasattr(new_unit, "scale"):
1605             new_value = self.value * new_unit.scale
1606             new_unit = new_unit / new_unit.scale
1607             return self._new_view(new_value, new_unit)
1608         else:
1609             return self._new_view(self.copy(), new_unit)
1610 
1611     # These functions need to be overridden to take into account the units
1612     # Array conversion
1613     # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion
1614 
1615     def item(self, *args):
1616         """Copy an element of an array to a scalar Quantity and return it.
1617 
1618         Like :meth:`~numpy.ndarray.item` except that it always
1619         returns a `Quantity`, not a Python scalar.
1620 
1621         """
1622         return self._new_view(super().item(*args))
1623 
1624     def tolist(self):
1625         raise NotImplementedError(
1626             "cannot make a list of Quantities. Get list of values with"
1627             " q.value.tolist()."
1628         )
1629 
1630     def _to_own_unit(self, value, check_precision=True, *, unit=None):
1631         """Convert value to one's own unit (or that given).
1632 
1633         Here, non-quantities are treated as dimensionless, and care is taken
1634         for values of 0, infinity or nan, which are allowed to have any unit.
1635 
1636         Parameters
1637         ----------
1638         value : anything convertible to `~astropy.units.Quantity`
1639             The value to be converted to the requested unit.
1640         check_precision : bool
1641             Whether to forbid conversion of float to integer if that changes
1642             the input number.  Default: `True`.
1643         unit : `~astropy.units.Unit` or None
1644             The unit to convert to.  By default, the unit of ``self``.
1645 
1646         Returns
1647         -------
1648         value : number or `~numpy.ndarray`
1649             In the requested units.
1650 
1651         """
1652         if unit is None:
1653             unit = self.unit
1654         try:
1655             _value = value.to_value(unit)
1656         except AttributeError:
1657             # We're not a Quantity.
1658             # First remove two special cases (with a fast test):
1659             # 1) Maybe masked printing? MaskedArray with quantities does not
1660             # work very well, but no reason to break even repr and str.
1661             # 2) np.ma.masked? useful if we're a MaskedQuantity.
1662             if value is np.ma.masked or (
1663                 value is np.ma.masked_print_option and self.dtype.kind == "O"
1664             ):
1665                 return value
1666             # Now, let's try a more general conversion.
1667             # Plain arrays will be converted to dimensionless in the process,
1668             # but anything with a unit attribute will use that.
1669             try:
1670                 as_quantity = Quantity(value)
1671                 _value = as_quantity.to_value(unit)
1672             except UnitsError:
1673                 # last chance: if this was not something with a unit
1674                 # and is all 0, inf, or nan, we treat it as arbitrary unit.
1675                 if not hasattr(value, "unit") and can_have_arbitrary_unit(
1676                     as_quantity.value
1677                 ):
1678                     _value = as_quantity.value
1679                 else:
1680                     raise
1681 
1682         if self.dtype.kind == "i" and check_precision:
1683             # If, e.g., we are casting float to int, we want to fail if
1684             # precision is lost, but let things pass if it works.
1685             _value = np.array(_value, copy=False, subok=True)
1686             if not np.can_cast(_value.dtype, self.dtype):
1687                 self_dtype_array = np.array(_value, self.dtype, subok=True)
1688                 if not np.all((self_dtype_array == _value) | np.isnan(_value)):
1689                     raise TypeError(
1690                         "cannot convert value type to array type without precision loss"
1691                     )
1692 
1693         # Setting names to ensure things like equality work (note that
1694         # above will have failed already if units did not match).
1695         if self.dtype.names:
1696             _value.dtype.names = self.dtype.names
1697         return _value
1698 
1699     def itemset(self, *args):
1700         if len(args) == 0:
1701             raise ValueError("itemset must have at least one argument")
1702 
1703         self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))
1704 
1705     def tostring(self, order="C"):
1706         """Not implemented, use ``.value.tostring()`` instead."""
1707         raise NotImplementedError(
1708             "cannot write Quantities to string.  Write array with"
1709             " q.value.tostring(...)."
1710         )
1711 
1712     def tobytes(self, order="C"):
1713         """Not implemented, use ``.value.tobytes()`` instead."""
1714         raise NotImplementedError(
1715             "cannot write Quantities to bytes.  Write array with q.value.tobytes(...)."
1716         )
1717 
1718     def tofile(self, fid, sep="", format="%s"):
1719         """Not implemented, use ``.value.tofile()`` instead."""
1720         raise NotImplementedError(
1721             "cannot write Quantities to file.  Write array with q.value.tofile(...)"
1722         )
1723 
1724     def dump(self, file):
1725         """Not implemented, use ``.value.dump()`` instead."""
1726         raise NotImplementedError(
1727             "cannot dump Quantities to file.  Write array with q.value.dump()"
1728         )
1729 
1730     def dumps(self):
1731         """Not implemented, use ``.value.dumps()`` instead."""
1732         raise NotImplementedError(
1733             "cannot dump Quantities to string.  Write array with q.value.dumps()"
1734         )
1735 
1736     # astype, byteswap, copy, view, getfield, setflags OK as is
1737 
1738     def fill(self, value):
1739         self.view(np.ndarray).fill(self._to_own_unit(value))
1740 
1741     # Shape manipulation: resize cannot be done (does not own data), but
1742     # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only
1743     # the flat iterator needs to be overwritten, otherwise single items are
1744     # returned as numbers.
1745     @property
1746     def flat(self):
1747         """A 1-D iterator over the Quantity array.
1748 
1749         This returns a ``QuantityIterator`` instance, which behaves the same
1750         as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,
1751         and is similar to, but not a subclass of, Python's built-in iterator
1752         object.
1753         """
1754         return QuantityIterator(self)
1755 
1756     @flat.setter
1757     def flat(self, value):
1758         y = self.ravel()
1759         y[:] = value
1760 
1761     # Item selection and manipulation
1762     # repeat, sort, compress, diagonal OK
1763     def take(self, indices, axis=None, out=None, mode="raise"):
1764         out = super().take(indices, axis=axis, out=out, mode=mode)
1765         # For single elements, ndarray.take returns scalars; these
1766         # need a new view as a Quantity.
1767         if type(out) is not type(self):
1768             out = self._new_view(out)
1769         return out
1770 
1771     def put(self, indices, values, mode="raise"):
1772         self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)
1773 
1774     def choose(self, choices, out=None, mode="raise"):
1775         raise NotImplementedError(
1776             "cannot choose based on quantity.  Choose using array with"
1777             " q.value.choose(...)"
1778         )
1779 
1780     # ensure we do not return indices as quantities
1781     def argsort(self, axis=-1, kind="quicksort", order=None):
1782         return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)
1783 
1784     def searchsorted(self, v, *args, **kwargs):
1785         return np.searchsorted(
1786             np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs
1787         )  # avoid numpy 1.6 problem
1788 
1789     if NUMPY_LT_1_22:
1790 
1791         def argmax(self, axis=None, out=None):
1792             return self.view(np.ndarray).argmax(axis, out=out)
1793 
1794         def argmin(self, axis=None, out=None):
1795             return self.view(np.ndarray).argmin(axis, out=out)
1796 
1797     else:
1798 
1799         def argmax(self, axis=None, out=None, *, keepdims=False):
1800             return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)
1801 
1802         def argmin(self, axis=None, out=None, *, keepdims=False):
1803             return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)
1804 
1805     def __array_function__(self, function, types, args, kwargs):
1806         """Wrap numpy functions, taking care of units.
1807 
1808         Parameters
1809         ----------
1810         function : callable
1811             Numpy function to wrap
1812         types : iterable of classes
1813             Classes that provide an ``__array_function__`` override. Can
1814             in principle be used to interact with other classes. Below,
1815             mostly passed on to `~numpy.ndarray`, which can only interact
1816             with subclasses.
1817         args : tuple
1818             Positional arguments provided in the function call.
1819         kwargs : dict
1820             Keyword arguments provided in the function call.
1821 
1822         Returns
1823         -------
1824         result: `~astropy.units.Quantity`, `~numpy.ndarray`
1825             As appropriate for the function.  If the function is not
1826             supported, `NotImplemented` is returned, which will lead to
1827             a `TypeError` unless another argument overrode the function.
1828 
1829         Raises
1830         ------
1831         ~astropy.units.UnitsError
1832             If operands have incompatible units.
1833         """
1834         # A function should be in one of the following sets or dicts:
1835         # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation
1836         #    supports Quantity; we pass on to ndarray.__array_function__.
1837         # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable
1838         #    after converting quantities to arrays with suitable units,
1839         #    and possibly setting units on the result.
1840         # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but
1841         #    requires a Quantity-specific implementation.
1842         # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.
1843         # For now, since we may not yet have complete coverage, if a
1844         # function is in none of the above, we simply call the numpy
1845         # implementation.
1846         if function in SUBCLASS_SAFE_FUNCTIONS:
1847             return super().__array_function__(function, types, args, kwargs)
1848 
1849         elif function in FUNCTION_HELPERS:
1850             function_helper = FUNCTION_HELPERS[function]
1851             try:
1852                 args, kwargs, unit, out = function_helper(*args, **kwargs)
1853             except NotImplementedError:
1854                 return self._not_implemented_or_raise(function, types)
1855 
1856             result = super().__array_function__(function, types, args, kwargs)
1857             # Fall through to return section
1858 
1859         elif function in DISPATCHED_FUNCTIONS:
1860             dispatched_function = DISPATCHED_FUNCTIONS[function]
1861             try:
1862                 result, unit, out = dispatched_function(*args, **kwargs)
1863             except NotImplementedError:
1864                 return self._not_implemented_or_raise(function, types)
1865 
1866             # Fall through to return section
1867 
1868         elif function in UNSUPPORTED_FUNCTIONS:
1869             return NotImplemented
1870 
1871         else:
1872             warnings.warn(
1873                 f"function '{function.__name__}' is not known to astropy's Quantity."
1874                 " Will run it anyway, hoping it will treat ndarray subclasses"
1875                 " correctly. Please raise an issue at"
1876                 " https://github.com/astropy/astropy/issues.",
1877                 AstropyWarning,
1878             )
1879             return super().__array_function__(function, types, args, kwargs)
1880 
1881         # If unit is None, a plain array is expected (e.g., boolean), which
1882         # means we're done.
1883         # We're also done if the result was NotImplemented, which can happen
1884         # if other inputs/outputs override __array_function__;
1885         # hopefully, they can then deal with us.
1886         if unit is None or result is NotImplemented:
1887             return result
1888 
1889         return self._result_as_quantity(result, unit, out=out)
1890 
1891     def _not_implemented_or_raise(self, function, types):
1892         # Our function helper or dispatcher found that the function does not
1893         # work with Quantity.  In principle, there may be another class that
1894         # knows what to do with us, for which we should return NotImplemented.
1895         # But if there is ndarray (or a non-Quantity subclass of it) around,
1896         # it quite likely coerces, so we should just break.
1897         if any(
1898             issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types
1899         ):
1900             raise TypeError(
1901                 f"the Quantity implementation cannot handle {function} "
1902                 "with the given arguments."
1903             ) from None
1904         else:
1905             return NotImplemented
1906 
1907     # Calculation -- override ndarray methods to take into account units.
1908     # We use the corresponding numpy functions to evaluate the results, since
1909     # the methods do not always allow calling with keyword arguments.
1910     # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives
1911     # TypeError: 'a_max' is an invalid keyword argument for this function.
1912     def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):
1913         """Wrap a numpy function that processes self, returning a Quantity.
1914 
1915         Parameters
1916         ----------
1917         function : callable
1918             Numpy function to wrap.
1919         args : positional arguments
1920             Any positional arguments to the function beyond the first argument
1921             (which will be set to ``self``).
1922         kwargs : keyword arguments
1923             Keyword arguments to the function.
1924 
1925         If present, the following arguments are treated specially:
1926 
1927         unit : `~astropy.units.Unit`
1928             Unit of the output result.  If not given, the unit of ``self``.
1929         out : `~astropy.units.Quantity`
1930             A Quantity instance in which to store the output.
1931 
1932         Notes
1933         -----
1934         Output should always be assigned via a keyword argument, otherwise
1935         no proper account of the unit is taken.
1936 
1937         Returns
1938         -------
1939         out : `~astropy.units.Quantity`
1940             Result of the function call, with the unit set properly.
1941         """
1942         if unit is None:
1943             unit = self.unit
1944         # Ensure we don't loop back by turning any Quantity into array views.
1945         args = (self.value,) + tuple(
1946             (arg.value if isinstance(arg, Quantity) else arg) for arg in args
1947         )
1948         if out is not None:
1949             # If pre-allocated output is used, check it is suitable.
1950             # This also returns array view, to ensure we don't loop back.
1951             arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))
1952             kwargs["out"] = check_output(out, unit, arrays, function=function)
1953         # Apply the function and turn it back into a Quantity.
1954         result = function(*args, **kwargs)
1955         return self._result_as_quantity(result, unit, out)
1956 
1957     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
1958         return self._wrap_function(np.trace, offset, axis1, axis2, dtype, out=out)
1959 
1960     def var(
1961         self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True
1962     ):
1963         return self._wrap_function(
1964             np.var,
1965             axis,
1966             dtype,
1967             out=out,
1968             ddof=ddof,
1969             keepdims=keepdims,
1970             where=where,
1971             unit=self.unit**2,
1972         )
1973 
1974     def std(
1975         self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True
1976     ):
1977         return self._wrap_function(
1978             np.std, axis, dtype, out=out, ddof=ddof, keepdims=keepdims, where=where
1979         )
1980 
1981     def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
1982         return self._wrap_function(
1983             np.mean, axis, dtype, out=out, keepdims=keepdims, where=where
1984         )
1985 
1986     def round(self, decimals=0, out=None):
1987         return self._wrap_function(np.round, decimals, out=out)
1988 
1989     def dot(self, b, out=None):
1990         result_unit = self.unit * getattr(b, "unit", dimensionless_unscaled)
1991         return self._wrap_function(np.dot, b, out=out, unit=result_unit)
1992 
1993     # Calculation: override methods that do not make sense.
1994 
1995     def all(self, axis=None, out=None):
1996         raise TypeError(
1997             "cannot evaluate truth value of quantities. "
1998             "Evaluate array with q.value.all(...)"
1999         )
2000 
2001     def any(self, axis=None, out=None):
2002         raise TypeError(
2003             "cannot evaluate truth value of quantities. "
2004             "Evaluate array with q.value.any(...)"
2005         )
2006 
2007     # Calculation: numpy functions that can be overridden with methods.
2008 
2009     def diff(self, n=1, axis=-1):
2010         return self._wrap_function(np.diff, n, axis)
2011 
2012     def ediff1d(self, to_end=None, to_begin=None):
2013         return self._wrap_function(np.ediff1d, to_end, to_begin)
2014 
2015     if NUMPY_LT_1_22:
2016 
2017         @deprecated("5.3", alternative="np.nansum", obj_type="method")
2018         def nansum(self, axis=None, out=None, keepdims=False):
2019             return self._wrap_function(np.nansum, axis, out=out, keepdims=keepdims)
2020 
2021     else:
2022 
2023         @deprecated("5.3", alternative="np.nansum", obj_type="method")
2024         def nansum(
2025             self, axis=None, out=None, keepdims=False, *, initial=None, where=True
2026         ):
2027             if initial is not None:
2028                 initial = self._to_own_unit(initial)
2029             return self._wrap_function(
2030                 np.nansum,
2031                 axis,
2032                 out=out,
2033                 keepdims=keepdims,
2034                 initial=initial,
2035                 where=where,
2036             )
2037 
2038     def insert(self, obj, values, axis=None):
2039         """
2040         Insert values along the given axis before the given indices and return
2041         a new `~astropy.units.Quantity` object.
2042 
2043         This is a thin wrapper around the `numpy.insert` function.
2044 
2045         Parameters
2046         ----------
2047         obj : int, slice or sequence of int
2048             Object that defines the index or indices before which ``values`` is
2049             inserted.
2050         values : array-like
2051             Values to insert.  If the type of ``values`` is different
2052             from that of quantity, ``values`` is converted to the matching type.
2053             ``values`` should be shaped so that it can be broadcast appropriately
2054             The unit of ``values`` must be consistent with this quantity.
2055         axis : int, optional
2056             Axis along which to insert ``values``.  If ``axis`` is None then
2057             the quantity array is flattened before insertion.
2058 
2059         Returns
2060         -------
2061         out : `~astropy.units.Quantity`
2062             A copy of quantity with ``values`` inserted.  Note that the
2063             insertion does not occur in-place: a new quantity array is returned.
2064 
2065         Examples
2066         --------
2067         >>> import astropy.units as u
2068         >>> q = [1, 2] * u.m
2069         >>> q.insert(0, 50 * u.cm)
2070         <Quantity [ 0.5,  1.,  2.] m>
2071 
2072         >>> q = [[1, 2], [3, 4]] * u.m
2073         >>> q.insert(1, [10, 20] * u.m, axis=0)
2074         <Quantity [[  1.,  2.],
2075                    [ 10., 20.],
2076                    [  3.,  4.]] m>
2077 
2078         >>> q.insert(1, 10 * u.m, axis=1)
2079         <Quantity [[  1., 10.,  2.],
2080                    [  3., 10.,  4.]] m>
2081 
2082         """
2083         out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)
2084         return self._new_view(out_array)
2085 
2086 
2087 class SpecificTypeQuantity(Quantity):
2088     """Superclass for Quantities of specific physical type.
2089 
2090     Subclasses of these work just like :class:`~astropy.units.Quantity`, except
2091     that they are for specific physical types (and may have methods that are
2092     only appropriate for that type).  Astropy examples are
2093     :class:`~astropy.coordinates.Angle` and
2094     :class:`~astropy.coordinates.Distance`
2095 
2096     At a minimum, subclasses should set ``_equivalent_unit`` to the unit
2097     associated with the physical type.
2098     """
2099 
2100     # The unit for the specific physical type.  Instances can only be created
2101     # with units that are equivalent to this.
2102     _equivalent_unit = None
2103 
2104     # The default unit used for views.  Even with `None`, views of arrays
2105     # without units are possible, but will have an uninitialized unit.
2106     _unit = None
2107 
2108     # Default unit for initialization through the constructor.
2109     _default_unit = None
2110 
2111     # ensure that we get precedence over our superclass.
2112     __array_priority__ = Quantity.__array_priority__ + 10
2113 
2114     def __quantity_subclass__(self, unit):
2115         if unit.is_equivalent(self._equivalent_unit):
2116             return type(self), True
2117         else:
2118             return super().__quantity_subclass__(unit)[0], False
2119 
2120     def _set_unit(self, unit):
2121         if unit is None or not unit.is_equivalent(self._equivalent_unit):
2122             raise UnitTypeError(
2123                 "{} instances require units equivalent to '{}'".format(
2124                     type(self).__name__, self._equivalent_unit
2125                 )
2126                 + (
2127                     ", but no unit was given."
2128                     if unit is None
2129                     else f", so cannot set it to '{unit}'."
2130                 )
2131             )
2132 
2133         super()._set_unit(unit)
2134 
2135 
2136 def isclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs):
2137     """
2138     Return a boolean array where two arrays are element-wise equal
2139     within a tolerance.
2140 
2141     Parameters
2142     ----------
2143     a, b : array-like or `~astropy.units.Quantity`
2144         Input values or arrays to compare
2145     rtol : array-like or `~astropy.units.Quantity`
2146         The relative tolerance for the comparison, which defaults to
2147         ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,
2148         then it must be dimensionless.
2149     atol : number or `~astropy.units.Quantity`
2150         The absolute tolerance for the comparison.  The units (or lack
2151         thereof) of ``a``, ``b``, and ``atol`` must be consistent with
2152         each other.  If `None`, ``atol`` defaults to zero in the
2153         appropriate units.
2154     equal_nan : `bool`
2155         Whether to compare NaNs as equal. If `True`, NaNs in ``a`` will
2156         be considered equal to NaNs in ``b``.
2157 
2158     Notes
2159     -----
2160     This is a :class:`~astropy.units.Quantity`-aware version of
2161     :func:`numpy.isclose`. However, this differs from the `numpy` function in
2162     that the default for the absolute tolerance here is zero instead of
2163     ``atol=1e-8`` in `numpy`, as there is no natural way to set a default
2164     *absolute* tolerance given two inputs that may have differently scaled
2165     units.
2166 
2167     Raises
2168     ------
2169     `~astropy.units.UnitsError`
2170         If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,
2171         or if ``rtol`` is not dimensionless.
2172 
2173     See Also
2174     --------
2175     allclose
2176     """
2177     unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)
2178     return np.isclose(*unquantified_args, equal_nan=equal_nan, **kwargs)
2179 
2180 
2181 def allclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs) -> bool:
2182     """
2183     Whether two arrays are element-wise equal within a tolerance.
2184 
2185     Parameters
2186     ----------
2187     a, b : array-like or `~astropy.units.Quantity`
2188         Input values or arrays to compare
2189     rtol : array-like or `~astropy.units.Quantity`
2190         The relative tolerance for the comparison, which defaults to
2191         ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,
2192         then it must be dimensionless.
2193     atol : number or `~astropy.units.Quantity`
2194         The absolute tolerance for the comparison.  The units (or lack
2195         thereof) of ``a``, ``b``, and ``atol`` must be consistent with
2196         each other.  If `None`, ``atol`` defaults to zero in the
2197         appropriate units.
2198     equal_nan : `bool`
2199         Whether to compare NaNs as equal. If `True`, NaNs in ``a`` will
2200         be considered equal to NaNs in ``b``.
2201 
2202     Notes
2203     -----
2204     This is a :class:`~astropy.units.Quantity`-aware version of
2205     :func:`numpy.allclose`. However, this differs from the `numpy` function in
2206     that the default for the absolute tolerance here is zero instead of
2207     ``atol=1e-8`` in `numpy`, as there is no natural way to set a default
2208     *absolute* tolerance given two inputs that may have differently scaled
2209     units.
2210 
2211     Raises
2212     ------
2213     `~astropy.units.UnitsError`
2214         If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,
2215         or if ``rtol`` is not dimensionless.
2216 
2217     See Also
2218     --------
2219     isclose
2220     """
2221     unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)
2222     return np.allclose(*unquantified_args, equal_nan=equal_nan, **kwargs)
2223 
2224 
2225 def _unquantify_allclose_arguments(actual, desired, rtol, atol):
2226     actual = Quantity(actual, subok=True, copy=False)
2227 
2228     desired = Quantity(desired, subok=True, copy=False)
2229     try:
2230         desired = desired.to(actual.unit)
2231     except UnitsError:
2232         raise UnitsError(
2233             f"Units for 'desired' ({desired.unit}) and 'actual' "
2234             f"({actual.unit}) are not convertible"
2235         )
2236 
2237     if atol is None:
2238         # By default, we assume an absolute tolerance of zero in the
2239         # appropriate units.  The default value of None for atol is
2240         # needed because the units of atol must be consistent with the
2241         # units for a and b.
2242         atol = Quantity(0)
2243     else:
2244         atol = Quantity(atol, subok=True, copy=False)
2245         try:
2246             atol = atol.to(actual.unit)
2247         except UnitsError:
2248             raise UnitsError(
2249                 f"Units for 'atol' ({atol.unit}) and 'actual' "
2250                 f"({actual.unit}) are not convertible"
2251             )
2252 
2253     rtol = Quantity(rtol, subok=True, copy=False)
2254     try:
2255         rtol = rtol.to(dimensionless_unscaled)
2256     except Exception:
2257         raise UnitsError("'rtol' should be dimensionless")
2258 
2259     return actual.value, desired.value, rtol.value, atol.value

</code><intended_behavior>The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format.</intended_behavior>]
2025-10-17 22:18:51.701 | INFO     | Search completed. Bug locations: [<file>astropy/units/format/console.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Handles the "Console" unit format.
5 """
6 
7 
8 from . import base, core, utils
9 
10 
11 class Console(base.Base):
12     """
13     Output-only format for to display pretty formatting at the
14     console.
15 
16     For example::
17 
18       >>> import astropy.units as u
19       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP
20       2.1798721*10^-18m^2 kg s^-2
21       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP
22                        m^2 kg
23       2.1798721*10^-18 ------
24                         s^2
25     """
26 
27     _times = "*"
28     _line = "-"
29 
30     @classmethod
31     def _get_unit_name(cls, unit):
32         return unit.get_format_name("console")
33 
34     @classmethod
35     def _format_superscript(cls, number):
36         return f"^{number}"
37 
38     @classmethod
39     def _format_unit_list(cls, units):
40         out = []
41         for base_, power in units:
42             if power == 1:
43                 out.append(cls._get_unit_name(base_))
44             else:
45                 out.append(
46                     cls._get_unit_name(base_)
47                     + cls._format_superscript(utils.format_power(power))
48                 )
49         return " ".join(out)
50 
51     @classmethod
52     def format_exponential_notation(cls, val):
53         m, ex = utils.split_mantissa_exponent(val)
54 
55         parts = []
56         if m:
57             parts.append(m)
58 
59         if ex:
60             parts.append(f"10{cls._format_superscript(ex)}")
61 
62         return cls._times.join(parts)
63 
64     @classmethod
65     def to_string(cls, unit, inline=True):
66         if isinstance(unit, core.CompositeUnit):
67             if unit.scale == 1:
68                 s = ""
69             else:
70                 s = cls.format_exponential_notation(unit.scale)
71 
72             if len(unit.bases):
73                 if inline:
74                     nominator = zip(unit.bases, unit.powers)
75                     denominator = []
76                 else:
77                     nominator, denominator = utils.get_grouped_by_powers(
78                         unit.bases, unit.powers
79                     )
80                 if len(denominator):
81                     if len(nominator):
82                         nominator = cls._format_unit_list(nominator)
83                     else:
84                         nominator = "1"
85                     denominator = cls._format_unit_list(denominator)
86                     fraclength = max(len(nominator), len(denominator))
87                     f = f"{{0:^{len(s)}s}} {{1:^{fraclength}s}}"
88 
89                     lines = [
90                         f.format("", nominator),
91                         f.format(s, cls._line * fraclength),
92                         f.format("", denominator),
93                     ]
94 
95                     s = "\n".join(lines)
96                 else:
97                     nominator = cls._format_unit_list(nominator)
98                     s += nominator
99         elif isinstance(unit, core.NamedUnit):
100             s = cls._get_unit_name(unit)
101 
102         return s

</code><intended_behavior>The method responsible for formatting units in console format should ensure that it does not prepend a space to the unit string unless necessary for proper formatting. This behavior should be consistent, regardless of whether a unit scale factor is present or not. Adjustments might be needed to the logic that inserts spaces to only do so when part of the unit representation requires it, not as a default behavior for all unit strings.</intended_behavior>, <file>astropy/units/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Core units classes and functions.
5 """
6 
7 
8 import inspect
9 import operator
10 import textwrap
11 import warnings
12 
13 import numpy as np
14 
15 from astropy.utils.decorators import lazyproperty
16 from astropy.utils.exceptions import AstropyWarning
17 from astropy.utils.misc import isiterable
18 
19 from . import format as unit_format
20 from .utils import (
21     is_effectively_unity,
22     resolve_fractions,
23     sanitize_scale,
24     validate_power,
25 )
26 
27 __all__ = [
28     "UnitsError",
29     "UnitsWarning",
30     "UnitConversionError",
31     "UnitTypeError",
32     "UnitBase",
33     "NamedUnit",
34     "IrreducibleUnit",
35     "Unit",
36     "CompositeUnit",
37     "PrefixUnit",
38     "UnrecognizedUnit",
39     "def_unit",
40     "get_current_unit_registry",
41     "set_enabled_units",
42     "add_enabled_units",
43     "set_enabled_equivalencies",
44     "add_enabled_equivalencies",
45     "set_enabled_aliases",
46     "add_enabled_aliases",
47     "dimensionless_unscaled",
48     "one",
49 ]
50 
51 UNITY = 1.0
52 
53 
54 def _flatten_units_collection(items):
55     """
56     Given a list of sequences, modules or dictionaries of units, or
57     single units, return a flat set of all the units found.
58     """
59     if not isinstance(items, list):
60         items = [items]
61 
62     result = set()
63     for item in items:
64         if isinstance(item, UnitBase):
65             result.add(item)
66         else:
67             if isinstance(item, dict):
68                 units = item.values()
69             elif inspect.ismodule(item):
70                 units = vars(item).values()
71             elif isiterable(item):
72                 units = item
73             else:
74                 continue
75 
76             for unit in units:
77                 if isinstance(unit, UnitBase):
78                     result.add(unit)
79 
80     return result
81 
82 
83 def _normalize_equivalencies(equivalencies):
84     """Normalizes equivalencies ensuring each is a 4-tuple.
85 
86     The resulting tuple is of the form::
87 
88         (from_unit, to_unit, forward_func, backward_func)
89 
90     Parameters
91     ----------
92     equivalencies : list of equivalency pairs
93 
94     Raises
95     ------
96     ValueError if an equivalency cannot be interpreted
97     """
98     if equivalencies is None:
99         return []
100 
101     normalized = []
102 
103     for i, equiv in enumerate(equivalencies):
104         if len(equiv) == 2:
105             funit, tunit = equiv
106             a = b = lambda x: x
107         elif len(equiv) == 3:
108             funit, tunit, a = equiv
109             b = a
110         elif len(equiv) == 4:
111             funit, tunit, a, b = equiv
112         else:
113             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
114         if not (
115             funit is Unit(funit)
116             and (tunit is None or tunit is Unit(tunit))
117             and callable(a)
118             and callable(b)
119         ):
120             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
121         normalized.append((funit, tunit, a, b))
122 
123     return normalized
124 
125 
126 class _UnitRegistry:
127     """
128     Manages a registry of the enabled units.
129     """
130 
131     def __init__(self, init=[], equivalencies=[], aliases={}):
132         if isinstance(init, _UnitRegistry):
133             # If passed another registry we don't need to rebuild everything.
134             # but because these are mutable types we don't want to create
135             # conflicts so everything needs to be copied.
136             self._equivalencies = init._equivalencies.copy()
137             self._aliases = init._aliases.copy()
138             self._all_units = init._all_units.copy()
139             self._registry = init._registry.copy()
140             self._non_prefix_units = init._non_prefix_units.copy()
141             # The physical type is a dictionary containing sets as values.
142             # All of these must be copied otherwise we could alter the old
143             # registry.
144             self._by_physical_type = {
145                 k: v.copy() for k, v in init._by_physical_type.items()
146             }
147 
148         else:
149             self._reset_units()
150             self._reset_equivalencies()
151             self._reset_aliases()
152             self.add_enabled_units(init)
153             self.add_enabled_equivalencies(equivalencies)
154             self.add_enabled_aliases(aliases)
155 
156     def _reset_units(self):
157         self._all_units = set()
158         self._non_prefix_units = set()
159         self._registry = {}
160         self._by_physical_type = {}
161 
162     def _reset_equivalencies(self):
163         self._equivalencies = set()
164 
165     def _reset_aliases(self):
166         self._aliases = {}
167 
168     @property
169     def registry(self):
170         return self._registry
171 
172     @property
173     def all_units(self):
174         return self._all_units
175 
176     @property
177     def non_prefix_units(self):
178         return self._non_prefix_units
179 
180     def set_enabled_units(self, units):
181         """
182         Sets the units enabled in the unit registry.
183 
184         These units are searched when using
185         `UnitBase.find_equivalent_units`, for example.
186 
187         Parameters
188         ----------
189         units : list of sequence, dict, or module
190             This is a list of things in which units may be found
191             (sequences, dicts or modules), or units themselves.  The
192             entire set will be "enabled" for searching through by
193             methods like `UnitBase.find_equivalent_units` and
194             `UnitBase.compose`.
195         """
196         self._reset_units()
197         return self.add_enabled_units(units)
198 
199     def add_enabled_units(self, units):
200         """
201         Adds to the set of units enabled in the unit registry.
202 
203         These units are searched when using
204         `UnitBase.find_equivalent_units`, for example.
205 
206         Parameters
207         ----------
208         units : list of sequence, dict, or module
209             This is a list of things in which units may be found
210             (sequences, dicts or modules), or units themselves.  The
211             entire set will be added to the "enabled" set for
212             searching through by methods like
213             `UnitBase.find_equivalent_units` and `UnitBase.compose`.
214         """
215         units = _flatten_units_collection(units)
216 
217         for unit in units:
218             # Loop through all of the names first, to ensure all of them
219             # are new, then add them all as a single "transaction" below.
220             for st in unit._names:
221                 if st in self._registry and unit != self._registry[st]:
222                     raise ValueError(
223                         f"Object with name {st!r} already exists in namespace. "
224                         "Filter the set of units to avoid name clashes before "
225                         "enabling them."
226                     )
227 
228             for st in unit._names:
229                 self._registry[st] = unit
230 
231             self._all_units.add(unit)
232             if not isinstance(unit, PrefixUnit):
233                 self._non_prefix_units.add(unit)
234 
235             hash = unit._get_physical_type_id()
236             self._by_physical_type.setdefault(hash, set()).add(unit)
237 
238     def get_units_with_physical_type(self, unit):
239         """
240         Get all units in the registry with the same physical type as
241         the given unit.
242 
243         Parameters
244         ----------
245         unit : UnitBase instance
246         """
247         return self._by_physical_type.get(unit._get_physical_type_id(), set())
248 
249     @property
250     def equivalencies(self):
251         return list(self._equivalencies)
252 
253     def set_enabled_equivalencies(self, equivalencies):
254         """
255         Sets the equivalencies enabled in the unit registry.
256 
257         These equivalencies are used if no explicit equivalencies are given,
258         both in unit conversion and in finding equivalent units.
259 
260         This is meant in particular for allowing angles to be dimensionless.
261         Use with care.
262 
263         Parameters
264         ----------
265         equivalencies : list of tuple
266             List of equivalent pairs, e.g., as returned by
267             `~astropy.units.equivalencies.dimensionless_angles`.
268         """
269         self._reset_equivalencies()
270         return self.add_enabled_equivalencies(equivalencies)
271 
272     def add_enabled_equivalencies(self, equivalencies):
273         """
274         Adds to the set of equivalencies enabled in the unit registry.
275 
276         These equivalencies are used if no explicit equivalencies are given,
277         both in unit conversion and in finding equivalent units.
278 
279         This is meant in particular for allowing angles to be dimensionless.
280         Use with care.
281 
282         Parameters
283         ----------
284         equivalencies : list of tuple
285             List of equivalent pairs, e.g., as returned by
286             `~astropy.units.equivalencies.dimensionless_angles`.
287         """
288         # pre-normalize list to help catch mistakes
289         equivalencies = _normalize_equivalencies(equivalencies)
290         self._equivalencies |= set(equivalencies)
291 
292     @property
293     def aliases(self):
294         return self._aliases
295 
296     def set_enabled_aliases(self, aliases):
297         """
298         Set aliases for units.
299 
300         Parameters
301         ----------
302         aliases : dict of str, Unit
303             The aliases to set. The keys must be the string aliases, and values
304             must be the `astropy.units.Unit` that the alias will be mapped to.
305 
306         Raises
307         ------
308         ValueError
309             If the alias already defines a different unit.
310 
311         """
312         self._reset_aliases()
313         self.add_enabled_aliases(aliases)
314 
315     def add_enabled_aliases(self, aliases):
316         """
317         Add aliases for units.
318 
319         Parameters
320         ----------
321         aliases : dict of str, Unit
322             The aliases to add. The keys must be the string aliases, and values
323             must be the `astropy.units.Unit` that the alias will be mapped to.
324 
325         Raises
326         ------
327         ValueError
328             If the alias already defines a different unit.
329 
330         """
331         for alias, unit in aliases.items():
332             if alias in self._registry and unit != self._registry[alias]:
333                 raise ValueError(
334                     f"{alias} already means {self._registry[alias]}, so "
335                     f"cannot be used as an alias for {unit}."
336                 )
337             if alias in self._aliases and unit != self._aliases[alias]:
338                 raise ValueError(
339                     f"{alias} already is an alias for {self._aliases[alias]}, so "
340                     f"cannot be used as an alias for {unit}."
341                 )
342 
343         for alias, unit in aliases.items():
344             if alias not in self._registry and alias not in self._aliases:
345                 self._aliases[alias] = unit
346 
347 
348 class _UnitContext:
349     def __init__(self, init=[], equivalencies=[]):
350         _unit_registries.append(_UnitRegistry(init=init, equivalencies=equivalencies))
351 
352     def __enter__(self):
353         pass
354 
355     def __exit__(self, type, value, tb):
356         _unit_registries.pop()
357 
358 
359 _unit_registries = [_UnitRegistry()]
360 
361 
362 def get_current_unit_registry():
363     return _unit_registries[-1]
364 
365 
366 def set_enabled_units(units):
367     """
368     Sets the units enabled in the unit registry.
369 
370     These units are searched when using
371     `UnitBase.find_equivalent_units`, for example.
372 
373     This may be used either permanently, or as a context manager using
374     the ``with`` statement (see example below).
375 
376     Parameters
377     ----------
378     units : list of sequence, dict, or module
379         This is a list of things in which units may be found
380         (sequences, dicts or modules), or units themselves.  The
381         entire set will be "enabled" for searching through by methods
382         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.
383 
384     Examples
385     --------
386     >>> from astropy import units as u
387     >>> with u.set_enabled_units([u.pc]):
388     ...     u.m.find_equivalent_units()
389     ...
390       Primary name | Unit definition | Aliases
391     [
392       pc           | 3.08568e+16 m   | parsec  ,
393     ]
394     >>> u.m.find_equivalent_units()
395       Primary name | Unit definition | Aliases
396     [
397       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
398       Angstrom     | 1e-10 m         | AA, angstrom                     ,
399       cm           | 0.01 m          | centimeter                       ,
400       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
401       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
402       lsec         | 2.99792e+08 m   | lightsecond                      ,
403       lyr          | 9.46073e+15 m   | lightyear                        ,
404       m            | irreducible     | meter                            ,
405       micron       | 1e-06 m         |                                  ,
406       pc           | 3.08568e+16 m   | parsec                           ,
407       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
408     ]
409     """
410     # get a context with a new registry, using equivalencies of the current one
411     context = _UnitContext(equivalencies=get_current_unit_registry().equivalencies)
412     # in this new current registry, enable the units requested
413     get_current_unit_registry().set_enabled_units(units)
414     return context
415 
416 
417 def add_enabled_units(units):
418     """
419     Adds to the set of units enabled in the unit registry.
420 
421     These units are searched when using
422     `UnitBase.find_equivalent_units`, for example.
423 
424     This may be used either permanently, or as a context manager using
425     the ``with`` statement (see example below).
426 
427     Parameters
428     ----------
429     units : list of sequence, dict, or module
430         This is a list of things in which units may be found
431         (sequences, dicts or modules), or units themselves.  The
432         entire set will be added to the "enabled" set for searching
433         through by methods like `UnitBase.find_equivalent_units` and
434         `UnitBase.compose`.
435 
436     Examples
437     --------
438     >>> from astropy import units as u
439     >>> from astropy.units import imperial
440     >>> with u.add_enabled_units(imperial):
441     ...     u.m.find_equivalent_units()
442     ...
443       Primary name | Unit definition | Aliases
444     [
445       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
446       Angstrom     | 1e-10 m         | AA, angstrom                     ,
447       cm           | 0.01 m          | centimeter                       ,
448       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
449       ft           | 0.3048 m        | foot                             ,
450       fur          | 201.168 m       | furlong                          ,
451       inch         | 0.0254 m        |                                  ,
452       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
453       lsec         | 2.99792e+08 m   | lightsecond                      ,
454       lyr          | 9.46073e+15 m   | lightyear                        ,
455       m            | irreducible     | meter                            ,
456       mi           | 1609.34 m       | mile                             ,
457       micron       | 1e-06 m         |                                  ,
458       mil          | 2.54e-05 m      | thou                             ,
459       nmi          | 1852 m          | nauticalmile, NM                 ,
460       pc           | 3.08568e+16 m   | parsec                           ,
461       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
462       yd           | 0.9144 m        | yard                             ,
463     ]
464     """
465     # get a context with a new registry, which is a copy of the current one
466     context = _UnitContext(get_current_unit_registry())
467     # in this new current registry, enable the further units requested
468     get_current_unit_registry().add_enabled_units(units)
469     return context
470 
471 
472 def set_enabled_equivalencies(equivalencies):
473     """
474     Sets the equivalencies enabled in the unit registry.
475 
476     These equivalencies are used if no explicit equivalencies are given,
477     both in unit conversion and in finding equivalent units.
478 
479     This is meant in particular for allowing angles to be dimensionless.
480     Use with care.
481 
482     Parameters
483     ----------
484     equivalencies : list of tuple
485         list of equivalent pairs, e.g., as returned by
486         `~astropy.units.equivalencies.dimensionless_angles`.
487 
488     Examples
489     --------
490     Exponentiation normally requires dimensionless quantities.  To avoid
491     problems with complex phases::
492 
493         >>> from astropy import units as u
494         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):
495         ...     phase = 0.5 * u.cycle
496         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP
497         <Quantity -1.+1.2246468e-16j>
498     """
499     # get a context with a new registry, using all units of the current one
500     context = _UnitContext(get_current_unit_registry())
501     # in this new current registry, enable the equivalencies requested
502     get_current_unit_registry().set_enabled_equivalencies(equivalencies)
503     return context
504 
505 
506 def add_enabled_equivalencies(equivalencies):
507     """
508     Adds to the equivalencies enabled in the unit registry.
509 
510     These equivalencies are used if no explicit equivalencies are given,
511     both in unit conversion and in finding equivalent units.
512 
513     This is meant in particular for allowing angles to be dimensionless.
514     Since no equivalencies are enabled by default, generally it is recommended
515     to use `set_enabled_equivalencies`.
516 
517     Parameters
518     ----------
519     equivalencies : list of tuple
520         list of equivalent pairs, e.g., as returned by
521         `~astropy.units.equivalencies.dimensionless_angles`.
522     """
523     # get a context with a new registry, which is a copy of the current one
524     context = _UnitContext(get_current_unit_registry())
525     # in this new current registry, enable the further equivalencies requested
526     get_current_unit_registry().add_enabled_equivalencies(equivalencies)
527     return context
528 
529 
530 def set_enabled_aliases(aliases):
531     """
532     Set aliases for units.
533 
534     This is useful for handling alternate spellings for units, or
535     misspelled units in files one is trying to read.
536 
537     Parameters
538     ----------
539     aliases : dict of str, Unit
540         The aliases to set. The keys must be the string aliases, and values
541         must be the `astropy.units.Unit` that the alias will be mapped to.
542 
543     Raises
544     ------
545     ValueError
546         If the alias already defines a different unit.
547 
548     Examples
549     --------
550     To temporarily allow for a misspelled 'Angstroem' unit::
551 
552         >>> from astropy import units as u
553         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):
554         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
555         True
556 
557     """
558     # get a context with a new registry, which is a copy of the current one
559     context = _UnitContext(get_current_unit_registry())
560     # in this new current registry, enable the further equivalencies requested
561     get_current_unit_registry().set_enabled_aliases(aliases)
562     return context
563 
564 
565 def add_enabled_aliases(aliases):
566     """
567     Add aliases for units.
568 
569     This is useful for handling alternate spellings for units, or
570     misspelled units in files one is trying to read.
571 
572     Since no aliases are enabled by default, generally it is recommended
573     to use `set_enabled_aliases`.
574 
575     Parameters
576     ----------
577     aliases : dict of str, Unit
578         The aliases to add. The keys must be the string aliases, and values
579         must be the `astropy.units.Unit` that the alias will be mapped to.
580 
581     Raises
582     ------
583     ValueError
584         If the alias already defines a different unit.
585 
586     Examples
587     --------
588     To temporarily allow for a misspelled 'Angstroem' unit::
589 
590         >>> from astropy import units as u
591         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):
592         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
593         True
594 
595     """
596     # get a context with a new registry, which is a copy of the current one
597     context = _UnitContext(get_current_unit_registry())
598     # in this new current registry, enable the further equivalencies requested
599     get_current_unit_registry().add_enabled_aliases(aliases)
600     return context
601 
602 
603 class UnitsError(Exception):
604     """
605     The base class for unit-specific exceptions.
606     """
607 
608 
609 class UnitScaleError(UnitsError, ValueError):
610     """
611     Used to catch the errors involving scaled units,
612     which are not recognized by FITS format.
613     """
614 
615     pass
616 
617 
618 class UnitConversionError(UnitsError, ValueError):
619     """
620     Used specifically for errors related to converting between units or
621     interpreting units in terms of other units.
622     """
623 
624 
625 class UnitTypeError(UnitsError, TypeError):
626     """
627     Used specifically for errors in setting to units not allowed by a class.
628 
629     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`
630     instances were set to a non-angular unit.
631     """
632 
633 
634 class UnitsWarning(AstropyWarning):
635     """
636     The base class for unit-specific warnings.
637     """
638 
639 
640 class UnitBase:
641     """
642     Abstract base class for units.
643 
644     Most of the arithmetic operations on units are defined in this
645     base class.
646 
647     Should not be instantiated by users directly.
648     """
649 
650     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy
651     # arrays to avoid element-wise multiplication.
652     __array_priority__ = 1000
653 
654     _hash = None
655     _type_id = None
656 
657     def __deepcopy__(self, memo):
658         # This may look odd, but the units conversion will be very
659         # broken after deep-copying if we don't guarantee that a given
660         # physical unit corresponds to only one instance
661         return self
662 
663     def _repr_latex_(self):
664         """
665         Generate latex representation of unit name.  This is used by
666         the IPython notebook to print a unit with a nice layout.
667 
668         Returns
669         -------
670         Latex string
671         """
672         return unit_format.Latex.to_string(self)
673 
674     def __bytes__(self):
675         """Return string representation for unit."""
676         return unit_format.Generic.to_string(self).encode("unicode_escape")
677 
678     def __str__(self):
679         """Return string representation for unit."""
680         return unit_format.Generic.to_string(self)
681 
682     def __repr__(self):
683         string = unit_format.Generic.to_string(self)
684 
685         return f'Unit("{string}")'
686 
687     def _get_physical_type_id(self):
688         """
689         Returns an identifier that uniquely identifies the physical
690         type of this unit.  It is comprised of the bases and powers of
691         this unit, without the scale.  Since it is hashable, it is
692         useful as a dictionary key.
693         """
694         if self._type_id is None:
695             unit = self.decompose()
696             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))
697 
698         return self._type_id
699 
700     @property
701     def names(self):
702         """
703         Returns all of the names associated with this unit.
704         """
705         raise AttributeError(
706             "Can not get names from unnamed units. Perhaps you meant to_string()?"
707         )
708 
709     @property
710     def name(self):
711         """
712         Returns the canonical (short) name associated with this unit.
713         """
714         raise AttributeError(
715             "Can not get names from unnamed units. Perhaps you meant to_string()?"
716         )
717 
718     @property
719     def aliases(self):
720         """
721         Returns the alias (long) names for this unit.
722         """
723         raise AttributeError(
724             "Can not get aliases from unnamed units. Perhaps you meant to_string()?"
725         )
726 
727     @property
728     def scale(self):
729         """
730         Return the scale of the unit.
731         """
732         return 1.0
733 
734     @property
735     def bases(self):
736         """
737         Return the bases of the unit.
738         """
739         return [self]
740 
741     @property
742     def powers(self):
743         """
744         Return the powers of the unit.
745         """
746         return [1]
747 
748     def to_string(self, format=unit_format.Generic, **kwargs):
749         """Output the unit in the given format as a string.
750 
751         Parameters
752         ----------
753         format : `astropy.units.format.Base` instance or str
754             The name of a format or a formatter object.  If not
755             provided, defaults to the generic format.
756 
757         **kwargs :
758             Further options forwarded to the formatter. Currently
759             recognized is **inline** (:class:`bool`) for the
760             ``"latex"``, ``"console"``, and``"unicode"`` formats.
761 
762         """
763         f = unit_format.get_format(format)
764         return f.to_string(self, **kwargs)
765 
766     def __format__(self, format_spec):
767         """Try to format units using a formatter."""
768         try:
769             return self.to_string(format=format_spec)
770         except ValueError:
771             return format(str(self), format_spec)
772 
773     @staticmethod
774     def _normalize_equivalencies(equivalencies):
775         """Normalizes equivalencies, ensuring each is a 4-tuple.
776 
777         The resulting tuple is of the form::
778 
779             (from_unit, to_unit, forward_func, backward_func)
780 
781         Parameters
782         ----------
783         equivalencies : list of equivalency pairs, or None
784 
785         Returns
786         -------
787         A normalized list, including possible global defaults set by, e.g.,
788         `set_enabled_equivalencies`, except when `equivalencies`=`None`,
789         in which case the returned list is always empty.
790 
791         Raises
792         ------
793         ValueError if an equivalency cannot be interpreted
794         """
795         normalized = _normalize_equivalencies(equivalencies)
796         if equivalencies is not None:
797             normalized += get_current_unit_registry().equivalencies
798 
799         return normalized
800 
801     def __pow__(self, p):
802         p = validate_power(p)
803         return CompositeUnit(1, [self], [p], _error_check=False)
804 
805     def __truediv__(self, m):
806         if isinstance(m, (bytes, str)):
807             m = Unit(m)
808 
809         if isinstance(m, UnitBase):
810             if m.is_unity():
811                 return self
812             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)
813 
814         try:
815             # Cannot handle this as Unit, re-try as Quantity
816             from .quantity import Quantity
817 
818             return Quantity(1, self) / m
819         except TypeError:
820             return NotImplemented
821 
822     def __rtruediv__(self, m):
823         if isinstance(m, (bytes, str)):
824             return Unit(m) / self
825 
826         try:
827             # Cannot handle this as Unit.  Here, m cannot be a Quantity,
828             # so we make it into one, fasttracking when it does not have a
829             # unit, for the common case of <array> / <unit>.
830             from .quantity import Quantity
831 
832             if hasattr(m, "unit"):
833                 result = Quantity(m)
834                 result /= self
835                 return result
836             else:
837                 return Quantity(m, self ** (-1))
838         except TypeError:
839             return NotImplemented
840 
841     def __mul__(self, m):
842         if isinstance(m, (bytes, str)):
843             m = Unit(m)
844 
845         if isinstance(m, UnitBase):
846             if m.is_unity():
847                 return self
848             elif self.is_unity():
849                 return m
850             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)
851 
852         # Cannot handle this as Unit, re-try as Quantity.
853         try:
854             from .quantity import Quantity
855 
856             return Quantity(1, unit=self) * m
857         except TypeError:
858             return NotImplemented
859 
860     def __rmul__(self, m):
861         if isinstance(m, (bytes, str)):
862             return Unit(m) * self
863 
864         # Cannot handle this as Unit.  Here, m cannot be a Quantity,
865         # so we make it into one, fasttracking when it does not have a unit
866         # for the common case of <array> * <unit>.
867         try:
868             from .quantity import Quantity
869 
870             if hasattr(m, "unit"):
871                 result = Quantity(m)
872                 result *= self
873                 return result
874             else:
875                 return Quantity(m, unit=self)
876         except TypeError:
877             return NotImplemented
878 
879     def __rlshift__(self, m):
880         try:
881             from .quantity import Quantity
882 
883             return Quantity(m, self, copy=False, subok=True)
884         except Exception:
885             return NotImplemented
886 
887     def __rrshift__(self, m):
888         warnings.warn(
889             ">> is not implemented. Did you mean to convert "
890             f"to a Quantity with unit {m} using '<<'?",
891             AstropyWarning,
892         )
893         return NotImplemented
894 
895     def __hash__(self):
896         if self._hash is None:
897             parts = (
898                 [str(self.scale)]
899                 + [x.name for x in self.bases]
900                 + [str(x) for x in self.powers]
901             )
902             self._hash = hash(tuple(parts))
903         return self._hash
904 
905     def __getstate__(self):
906         # If we get pickled, we should *not* store the memoized members since
907         # hashes of strings vary between sessions.
908         state = self.__dict__.copy()
909         state.pop("_hash", None)
910         state.pop("_type_id", None)
911         return state
912 
913     def __eq__(self, other):
914         if self is other:
915             return True
916 
917         try:
918             other = Unit(other, parse_strict="silent")
919         except (ValueError, UnitsError, TypeError):
920             return NotImplemented
921 
922         # Other is unit-like, but the test below requires it is a UnitBase
923         # instance; if it is not, give up (so that other can try).
924         if not isinstance(other, UnitBase):
925             return NotImplemented
926 
927         try:
928             return is_effectively_unity(self._to(other))
929         except UnitsError:
930             return False
931 
932     def __ne__(self, other):
933         return not (self == other)
934 
935     def __le__(self, other):
936         scale = self._to(Unit(other))
937         return scale <= 1.0 or is_effectively_unity(scale)
938 
939     def __ge__(self, other):
940         scale = self._to(Unit(other))
941         return scale >= 1.0 or is_effectively_unity(scale)
942 
943     def __lt__(self, other):
944         return not (self >= other)
945 
946     def __gt__(self, other):
947         return not (self <= other)
948 
949     def __neg__(self):
950         return self * -1.0
951 
952     def is_equivalent(self, other, equivalencies=[]):
953         """
954         Returns `True` if this unit is equivalent to ``other``.
955 
956         Parameters
957         ----------
958         other : `~astropy.units.Unit`, str, or tuple
959             The unit to convert to. If a tuple of units is specified, this
960             method returns true if the unit matches any of those in the tuple.
961 
962         equivalencies : list of tuple
963             A list of equivalence pairs to try if the units are not
964             directly convertible.  See :ref:`astropy:unit_equivalencies`.
965             This list is in addition to possible global defaults set by, e.g.,
966             `set_enabled_equivalencies`.
967             Use `None` to turn off all equivalencies.
968 
969         Returns
970         -------
971         bool
972         """
973         equivalencies = self._normalize_equivalencies(equivalencies)
974 
975         if isinstance(other, tuple):
976             return any(self.is_equivalent(u, equivalencies) for u in other)
977 
978         other = Unit(other, parse_strict="silent")
979 
980         return self._is_equivalent(other, equivalencies)
981 
982     def _is_equivalent(self, other, equivalencies=[]):
983         """Returns `True` if this unit is equivalent to `other`.
984         See `is_equivalent`, except that a proper Unit object should be
985         given (i.e., no string) and that the equivalency list should be
986         normalized using `_normalize_equivalencies`.
987         """
988         if isinstance(other, UnrecognizedUnit):
989             return False
990 
991         if self._get_physical_type_id() == other._get_physical_type_id():
992             return True
993         elif len(equivalencies):
994             unit = self.decompose()
995             other = other.decompose()
996             for a, b, forward, backward in equivalencies:
997                 if b is None:
998                     # after canceling, is what's left convertible
999                     # to dimensionless (according to the equivalency)?
1000                     try:
1001                         (other / unit).decompose([a])
1002                         return True
1003                     except Exception:
1004                         pass
1005                 elif (a._is_equivalent(unit) and b._is_equivalent(other)) or (
1006                     b._is_equivalent(unit) and a._is_equivalent(other)
1007                 ):
1008                     return True
1009 
1010         return False
1011 
1012     def _apply_equivalencies(self, unit, other, equivalencies):
1013         """
1014         Internal function (used from `_get_converter`) to apply
1015         equivalence pairs.
1016         """
1017 
1018         def make_converter(scale1, func, scale2):
1019             def convert(v):
1020                 return func(_condition_arg(v) / scale1) * scale2
1021 
1022             return convert
1023 
1024         for funit, tunit, a, b in equivalencies:
1025             if tunit is None:
1026                 ratio = other.decompose() / unit.decompose()
1027                 try:
1028                     ratio_in_funit = ratio.decompose([funit])
1029                     return make_converter(ratio_in_funit.scale, a, 1.0)
1030                 except UnitsError:
1031                     pass
1032             else:
1033                 try:
1034                     scale1 = funit._to(unit)
1035                     scale2 = tunit._to(other)
1036                     return make_converter(scale1, a, scale2)
1037                 except UnitsError:
1038                     pass
1039                 try:
1040                     scale1 = tunit._to(unit)
1041                     scale2 = funit._to(other)
1042                     return make_converter(scale1, b, scale2)
1043                 except UnitsError:
1044                     pass
1045 
1046         def get_err_str(unit):
1047             unit_str = unit.to_string("unscaled")
1048             physical_type = unit.physical_type
1049             if physical_type != "unknown":
1050                 unit_str = f"'{unit_str}' ({physical_type})"
1051             else:
1052                 unit_str = f"'{unit_str}'"
1053             return unit_str
1054 
1055         unit_str = get_err_str(unit)
1056         other_str = get_err_str(other)
1057 
1058         raise UnitConversionError(f"{unit_str} and {other_str} are not convertible")
1059 
1060     def _get_converter(self, other, equivalencies=[]):
1061         """Get a converter for values in ``self`` to ``other``.
1062 
1063         If no conversion is necessary, returns ``unit_scale_converter``
1064         (which is used as a check in quantity helpers).
1065 
1066         """
1067         # First see if it is just a scaling.
1068         try:
1069             scale = self._to(other)
1070         except UnitsError:
1071             pass
1072         else:
1073             if scale == 1.0:
1074                 return unit_scale_converter
1075             else:
1076                 return lambda val: scale * _condition_arg(val)
1077 
1078         # if that doesn't work, maybe we can do it with equivalencies?
1079         try:
1080             return self._apply_equivalencies(
1081                 self, other, self._normalize_equivalencies(equivalencies)
1082             )
1083         except UnitsError as exc:
1084             # Last hope: maybe other knows how to do it?
1085             # We assume the equivalencies have the unit itself as first item.
1086             # TODO: maybe better for other to have a `_back_converter` method?
1087             if hasattr(other, "equivalencies"):
1088                 for funit, tunit, a, b in other.equivalencies:
1089                     if other is funit:
1090                         try:
1091                             converter = self._get_converter(tunit, equivalencies)
1092                         except Exception:
1093                             pass
1094                         else:
1095                             return lambda v: b(converter(v))
1096 
1097             raise exc
1098 
1099     def _to(self, other):
1100         """
1101         Returns the scale to the specified unit.
1102 
1103         See `to`, except that a Unit object should be given (i.e., no
1104         string), and that all defaults are used, i.e., no
1105         equivalencies and value=1.
1106         """
1107         # There are many cases where we just want to ensure a Quantity is
1108         # of a particular unit, without checking whether it's already in
1109         # a particular unit.  If we're being asked to convert from a unit
1110         # to itself, we can short-circuit all of this.
1111         if self is other:
1112             return 1.0
1113 
1114         # Don't presume decomposition is possible; e.g.,
1115         # conversion to function units is through equivalencies.
1116         if isinstance(other, UnitBase):
1117             self_decomposed = self.decompose()
1118             other_decomposed = other.decompose()
1119 
1120             # Check quickly whether equivalent.  This is faster than
1121             # `is_equivalent`, because it doesn't generate the entire
1122             # physical type list of both units.  In other words it "fails
1123             # fast".
1124             if self_decomposed.powers == other_decomposed.powers and all(
1125                 self_base is other_base
1126                 for (self_base, other_base) in zip(
1127                     self_decomposed.bases, other_decomposed.bases
1128                 )
1129             ):
1130                 return self_decomposed.scale / other_decomposed.scale
1131 
1132         raise UnitConversionError(f"'{self!r}' is not a scaled version of '{other!r}'")
1133 
1134     def to(self, other, value=UNITY, equivalencies=[]):
1135         """
1136         Return the converted values in the specified unit.
1137 
1138         Parameters
1139         ----------
1140         other : unit-like
1141             The unit to convert to.
1142 
1143         value : int, float, or scalar array-like, optional
1144             Value(s) in the current unit to be converted to the
1145             specified unit.  If not provided, defaults to 1.0
1146 
1147         equivalencies : list of tuple
1148             A list of equivalence pairs to try if the units are not
1149             directly convertible.  See :ref:`astropy:unit_equivalencies`.
1150             This list is in addition to possible global defaults set by, e.g.,
1151             `set_enabled_equivalencies`.
1152             Use `None` to turn off all equivalencies.
1153 
1154         Returns
1155         -------
1156         values : scalar or array
1157             Converted value(s). Input value sequences are returned as
1158             numpy arrays.
1159 
1160         Raises
1161         ------
1162         UnitsError
1163             If units are inconsistent
1164         """
1165         if other is self and value is UNITY:
1166             return UNITY
1167         else:
1168             return self._get_converter(Unit(other), equivalencies)(value)
1169 
1170     def in_units(self, other, value=1.0, equivalencies=[]):
1171         """
1172         Alias for `to` for backward compatibility with pynbody.
1173         """
1174         return self.to(other, value=value, equivalencies=equivalencies)
1175 
1176     def decompose(self, bases=set()):
1177         """
1178         Return a unit object composed of only irreducible units.
1179 
1180         Parameters
1181         ----------
1182         bases : sequence of UnitBase, optional
1183             The bases to decompose into.  When not provided,
1184             decomposes down to any irreducible units.  When provided,
1185             the decomposed result will only contain the given units.
1186             This will raises a `UnitsError` if it's not possible
1187             to do so.
1188 
1189         Returns
1190         -------
1191         unit : `~astropy.units.CompositeUnit`
1192             New object containing only irreducible unit objects.
1193         """
1194         raise NotImplementedError()
1195 
1196     def _compose(
1197         self, equivalencies=[], namespace=[], max_depth=2, depth=0, cached_results=None
1198     ):
1199         def is_final_result(unit):
1200             # Returns True if this result contains only the expected
1201             # units
1202             return all(base in namespace for base in unit.bases)
1203 
1204         unit = self.decompose()
1205         key = hash(unit)
1206 
1207         cached = cached_results.get(key)
1208         if cached is not None:
1209             if isinstance(cached, Exception):
1210                 raise cached
1211             return cached
1212 
1213         # Prevent too many levels of recursion
1214         # And special case for dimensionless unit
1215         if depth >= max_depth:
1216             cached_results[key] = [unit]
1217             return [unit]
1218 
1219         # Make a list including all of the equivalent units
1220         units = [unit]
1221         for funit, tunit, a, b in equivalencies:
1222             if tunit is not None:
1223                 if self._is_equivalent(funit):
1224                     scale = funit.decompose().scale / unit.scale
1225                     units.append(Unit(a(1.0 / scale) * tunit).decompose())
1226                 elif self._is_equivalent(tunit):
1227                     scale = tunit.decompose().scale / unit.scale
1228                     units.append(Unit(b(1.0 / scale) * funit).decompose())
1229             else:
1230                 if self._is_equivalent(funit):
1231                     units.append(Unit(unit.scale))
1232 
1233         # Store partial results
1234         partial_results = []
1235         # Store final results that reduce to a single unit or pair of
1236         # units
1237         if len(unit.bases) == 0:
1238             final_results = [{unit}, set()]
1239         else:
1240             final_results = [set(), set()]
1241 
1242         for tunit in namespace:
1243             tunit_decomposed = tunit.decompose()
1244             for u in units:
1245                 # If the unit is a base unit, look for an exact match
1246                 # to one of the bases of the target unit.  If found,
1247                 # factor by the same power as the target unit's base.
1248                 # This allows us to factor out fractional powers
1249                 # without needing to do an exhaustive search.
1250                 if len(tunit_decomposed.bases) == 1:
1251                     for base, power in zip(u.bases, u.powers):
1252                         if tunit_decomposed._is_equivalent(base):
1253                             tunit = tunit**power
1254                             tunit_decomposed = tunit_decomposed**power
1255                             break
1256 
1257                 composed = (u / tunit_decomposed).decompose()
1258                 factored = composed * tunit
1259                 len_bases = len(composed.bases)
1260                 if is_final_result(factored) and len_bases <= 1:
1261                     final_results[len_bases].add(factored)
1262                 else:
1263                     partial_results.append((len_bases, composed, tunit))
1264 
1265         # Do we have any minimal results?
1266         for final_result in final_results:
1267             if len(final_result):
1268                 results = final_results[0].union(final_results[1])
1269                 cached_results[key] = results
1270                 return results
1271 
1272         partial_results.sort(key=operator.itemgetter(0))
1273 
1274         # ...we have to recurse and try to further compose
1275         results = []
1276         for len_bases, composed, tunit in partial_results:
1277             try:
1278                 composed_list = composed._compose(
1279                     equivalencies=equivalencies,
1280                     namespace=namespace,
1281                     max_depth=max_depth,
1282                     depth=depth + 1,
1283                     cached_results=cached_results,
1284                 )
1285             except UnitsError:
1286                 composed_list = []
1287             for subcomposed in composed_list:
1288                 results.append((len(subcomposed.bases), subcomposed, tunit))
1289 
1290         if len(results):
1291             results.sort(key=operator.itemgetter(0))
1292 
1293             min_length = results[0][0]
1294             subresults = set()
1295             for len_bases, composed, tunit in results:
1296                 if len_bases > min_length:
1297                     break
1298                 else:
1299                     factored = composed * tunit
1300                     if is_final_result(factored):
1301                         subresults.add(factored)
1302 
1303             if len(subresults):
1304                 cached_results[key] = subresults
1305                 return subresults
1306 
1307         if not is_final_result(self):
1308             result = UnitsError(
1309                 f"Cannot represent unit {self} in terms of the given units"
1310             )
1311             cached_results[key] = result
1312             raise result
1313 
1314         cached_results[key] = [self]
1315         return [self]
1316 
1317     def compose(
1318         self, equivalencies=[], units=None, max_depth=2, include_prefix_units=None
1319     ):
1320         """
1321         Return the simplest possible composite unit(s) that represent
1322         the given unit.  Since there may be multiple equally simple
1323         compositions of the unit, a list of units is always returned.
1324 
1325         Parameters
1326         ----------
1327         equivalencies : list of tuple
1328             A list of equivalence pairs to also list.  See
1329             :ref:`astropy:unit_equivalencies`.
1330             This list is in addition to possible global defaults set by, e.g.,
1331             `set_enabled_equivalencies`.
1332             Use `None` to turn off all equivalencies.
1333 
1334         units : set of `~astropy.units.Unit`, optional
1335             If not provided, any known units may be used to compose
1336             into.  Otherwise, ``units`` is a dict, module or sequence
1337             containing the units to compose into.
1338 
1339         max_depth : int, optional
1340             The maximum recursion depth to use when composing into
1341             composite units.
1342 
1343         include_prefix_units : bool, optional
1344             When `True`, include prefixed units in the result.
1345             Default is `True` if a sequence is passed in to ``units``,
1346             `False` otherwise.
1347 
1348         Returns
1349         -------
1350         units : list of `CompositeUnit`
1351             A list of candidate compositions.  These will all be
1352             equally simple, but it may not be possible to
1353             automatically determine which of the candidates are
1354             better.
1355         """
1356         # if units parameter is specified and is a sequence (list|tuple),
1357         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]
1358         if include_prefix_units is None:
1359             include_prefix_units = isinstance(units, (list, tuple))
1360 
1361         # Pre-normalize the equivalencies list
1362         equivalencies = self._normalize_equivalencies(equivalencies)
1363 
1364         # The namespace of units to compose into should be filtered to
1365         # only include units with bases in common with self, otherwise
1366         # they can't possibly provide useful results.  Having too many
1367         # destination units greatly increases the search space.
1368 
1369         def has_bases_in_common(a, b):
1370             if len(a.bases) == 0 and len(b.bases) == 0:
1371                 return True
1372             for ab in a.bases:
1373                 for bb in b.bases:
1374                     if ab == bb:
1375                         return True
1376             return False
1377 
1378         def has_bases_in_common_with_equiv(unit, other):
1379             if has_bases_in_common(unit, other):
1380                 return True
1381             for funit, tunit, a, b in equivalencies:
1382                 if tunit is not None:
1383                     if unit._is_equivalent(funit):
1384                         if has_bases_in_common(tunit.decompose(), other):
1385                             return True
1386                     elif unit._is_equivalent(tunit):
1387                         if has_bases_in_common(funit.decompose(), other):
1388                             return True
1389                 else:
1390                     if unit._is_equivalent(funit):
1391                         if has_bases_in_common(dimensionless_unscaled, other):
1392                             return True
1393             return False
1394 
1395         def filter_units(units):
1396             filtered_namespace = set()
1397             for tunit in units:
1398                 if (
1399                     isinstance(tunit, UnitBase)
1400                     and (include_prefix_units or not isinstance(tunit, PrefixUnit))
1401                     and has_bases_in_common_with_equiv(decomposed, tunit.decompose())
1402                 ):
1403                     filtered_namespace.add(tunit)
1404             return filtered_namespace
1405 
1406         decomposed = self.decompose()
1407 
1408         if units is None:
1409             units = filter_units(self._get_units_with_same_physical_type(equivalencies))
1410             if len(units) == 0:
1411                 units = get_current_unit_registry().non_prefix_units
1412         elif isinstance(units, dict):
1413             units = set(filter_units(units.values()))
1414         elif inspect.ismodule(units):
1415             units = filter_units(vars(units).values())
1416         else:
1417             units = filter_units(_flatten_units_collection(units))
1418 
1419         def sort_results(results):
1420             if not len(results):
1421                 return []
1422 
1423             # Sort the results so the simplest ones appear first.
1424             # Simplest is defined as "the minimum sum of absolute
1425             # powers" (i.e. the fewest bases), and preference should
1426             # be given to results where the sum of powers is positive
1427             # and the scale is exactly equal to 1.0
1428             results = list(results)
1429             results.sort(key=lambda x: np.abs(x.scale))
1430             results.sort(key=lambda x: np.sum(np.abs(x.powers)))
1431             results.sort(key=lambda x: np.sum(x.powers) < 0.0)
1432             results.sort(key=lambda x: not is_effectively_unity(x.scale))
1433 
1434             last_result = results[0]
1435             filtered = [last_result]
1436             for result in results[1:]:
1437                 if str(result) != str(last_result):
1438                     filtered.append(result)
1439                 last_result = result
1440 
1441             return filtered
1442 
1443         return sort_results(
1444             self._compose(
1445                 equivalencies=equivalencies,
1446                 namespace=units,
1447                 max_depth=max_depth,
1448                 depth=0,
1449                 cached_results={},
1450             )
1451         )
1452 
1453     def to_system(self, system):
1454         """
1455         Converts this unit into ones belonging to the given system.
1456         Since more than one result may be possible, a list is always
1457         returned.
1458 
1459         Parameters
1460         ----------
1461         system : module
1462             The module that defines the unit system.  Commonly used
1463             ones include `astropy.units.si` and `astropy.units.cgs`.
1464 
1465             To use your own module it must contain unit objects and a
1466             sequence member named ``bases`` containing the base units of
1467             the system.
1468 
1469         Returns
1470         -------
1471         units : list of `CompositeUnit`
1472             The list is ranked so that units containing only the base
1473             units of that system will appear first.
1474         """
1475         bases = set(system.bases)
1476 
1477         def score(compose):
1478             # In case that compose._bases has no elements we return
1479             # 'np.inf' as 'score value'.  It does not really matter which
1480             # number we would return. This case occurs for instance for
1481             # dimensionless quantities:
1482             compose_bases = compose.bases
1483             if len(compose_bases) == 0:
1484                 return np.inf
1485             else:
1486                 sum = 0
1487                 for base in compose_bases:
1488                     if base in bases:
1489                         sum += 1
1490 
1491                 return sum / float(len(compose_bases))
1492 
1493         x = self.decompose(bases=bases)
1494         composed = x.compose(units=system)
1495         composed = sorted(composed, key=score, reverse=True)
1496         return composed
1497 
1498     @lazyproperty
1499     def si(self):
1500         """
1501         Returns a copy of the current `Unit` instance in SI units.
1502         """
1503         from . import si
1504 
1505         return self.to_system(si)[0]
1506 
1507     @lazyproperty
1508     def cgs(self):
1509         """
1510         Returns a copy of the current `Unit` instance with CGS units.
1511         """
1512         from . import cgs
1513 
1514         return self.to_system(cgs)[0]
1515 
1516     @property
1517     def physical_type(self):
1518         """
1519         Physical type(s) dimensionally compatible with the unit.
1520 
1521         Returns
1522         -------
1523         `~astropy.units.physical.PhysicalType`
1524             A representation of the physical type(s) of a unit.
1525 
1526         Examples
1527         --------
1528         >>> from astropy import units as u
1529         >>> u.m.physical_type
1530         PhysicalType('length')
1531         >>> (u.m ** 2 / u.s).physical_type
1532         PhysicalType({'diffusivity', 'kinematic viscosity'})
1533 
1534         Physical types can be compared to other physical types
1535         (recommended in packages) or to strings.
1536 
1537         >>> area = (u.m ** 2).physical_type
1538         >>> area == u.m.physical_type ** 2
1539         True
1540         >>> area == "area"
1541         True
1542 
1543         `~astropy.units.physical.PhysicalType` objects can be used for
1544         dimensional analysis.
1545 
1546         >>> number_density = u.m.physical_type ** -3
1547         >>> velocity = (u.m / u.s).physical_type
1548         >>> number_density * velocity
1549         PhysicalType('particle flux')
1550         """
1551         from . import physical
1552 
1553         return physical.get_physical_type(self)
1554 
1555     def _get_units_with_same_physical_type(self, equivalencies=[]):
1556         """
1557         Return a list of registered units with the same physical type
1558         as this unit.
1559 
1560         This function is used by Quantity to add its built-in
1561         conversions to equivalent units.
1562 
1563         This is a private method, since end users should be encouraged
1564         to use the more powerful `compose` and `find_equivalent_units`
1565         methods (which use this under the hood).
1566 
1567         Parameters
1568         ----------
1569         equivalencies : list of tuple
1570             A list of equivalence pairs to also pull options from.
1571             See :ref:`astropy:unit_equivalencies`.  It must already be
1572             normalized using `_normalize_equivalencies`.
1573         """
1574         unit_registry = get_current_unit_registry()
1575         units = set(unit_registry.get_units_with_physical_type(self))
1576         for funit, tunit, a, b in equivalencies:
1577             if tunit is not None:
1578                 if self.is_equivalent(funit) and tunit not in units:
1579                     units.update(unit_registry.get_units_with_physical_type(tunit))
1580                 if self._is_equivalent(tunit) and funit not in units:
1581                     units.update(unit_registry.get_units_with_physical_type(funit))
1582             else:
1583                 if self.is_equivalent(funit):
1584                     units.add(dimensionless_unscaled)
1585         return units
1586 
1587     class EquivalentUnitsList(list):
1588         """
1589         A class to handle pretty-printing the result of
1590         `find_equivalent_units`.
1591         """
1592 
1593         HEADING_NAMES = ("Primary name", "Unit definition", "Aliases")
1594         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant
1595         NO_EQUIV_UNITS_MSG = "There are no equivalent units"
1596 
1597         def __repr__(self):
1598             if len(self) == 0:
1599                 return self.NO_EQUIV_UNITS_MSG
1600             else:
1601                 lines = self._process_equivalent_units(self)
1602                 lines.insert(0, self.HEADING_NAMES)
1603                 widths = [0] * self.ROW_LEN
1604                 for line in lines:
1605                     for i, col in enumerate(line):
1606                         widths[i] = max(widths[i], len(col))
1607 
1608                 f = "  {{0:<{}s}} | {{1:<{}s}} | {{2:<{}s}}".format(*widths)
1609                 lines = [f.format(*line) for line in lines]
1610                 lines = lines[0:1] + ["["] + [f"{x} ," for x in lines[1:]] + ["]"]
1611                 return "\n".join(lines)
1612 
1613         def _repr_html_(self):
1614             """
1615             Outputs a HTML table representation within Jupyter notebooks.
1616             """
1617             if len(self) == 0:
1618                 return f"<p>{self.NO_EQUIV_UNITS_MSG}</p>"
1619             else:
1620                 # HTML tags to use to compose the table in HTML
1621                 blank_table = '<table style="width:50%">{}</table>'
1622                 blank_row_container = "<tr>{}</tr>"
1623                 heading_row_content = "<th>{}</th>" * self.ROW_LEN
1624                 data_row_content = "<td>{}</td>" * self.ROW_LEN
1625 
1626                 # The HTML will be rendered & the table is simple, so don't
1627                 # bother to include newlines & indentation for the HTML code.
1628                 heading_row = blank_row_container.format(
1629                     heading_row_content.format(*self.HEADING_NAMES)
1630                 )
1631                 data_rows = self._process_equivalent_units(self)
1632                 all_rows = heading_row
1633                 for row in data_rows:
1634                     html_row = blank_row_container.format(data_row_content.format(*row))
1635                     all_rows += html_row
1636                 return blank_table.format(all_rows)
1637 
1638         @staticmethod
1639         def _process_equivalent_units(equiv_units_data):
1640             """
1641             Extract attributes, and sort, the equivalent units pre-formatting.
1642             """
1643             processed_equiv_units = []
1644             for u in equiv_units_data:
1645                 irred = u.decompose().to_string()
1646                 if irred == u.name:
1647                     irred = "irreducible"
1648                 processed_equiv_units.append((u.name, irred, ", ".join(u.aliases)))
1649             processed_equiv_units.sort()
1650             return processed_equiv_units
1651 
1652     def find_equivalent_units(
1653         self, equivalencies=[], units=None, include_prefix_units=False
1654     ):
1655         """
1656         Return a list of all the units that are the same type as ``self``.
1657 
1658         Parameters
1659         ----------
1660         equivalencies : list of tuple
1661             A list of equivalence pairs to also list.  See
1662             :ref:`astropy:unit_equivalencies`.
1663             Any list given, including an empty one, supersedes global defaults
1664             that may be in effect (as set by `set_enabled_equivalencies`)
1665 
1666         units : set of `~astropy.units.Unit`, optional
1667             If not provided, all defined units will be searched for
1668             equivalencies.  Otherwise, may be a dict, module or
1669             sequence containing the units to search for equivalencies.
1670 
1671         include_prefix_units : bool, optional
1672             When `True`, include prefixed units in the result.
1673             Default is `False`.
1674 
1675         Returns
1676         -------
1677         units : list of `UnitBase`
1678             A list of unit objects that match ``u``.  A subclass of
1679             `list` (``EquivalentUnitsList``) is returned that
1680             pretty-prints the list of units when output.
1681         """
1682         results = self.compose(
1683             equivalencies=equivalencies,
1684             units=units,
1685             max_depth=1,
1686             include_prefix_units=include_prefix_units,
1687         )
1688         results = {x.bases[0] for x in results if len(x.bases) == 1}
1689         return self.EquivalentUnitsList(results)
1690 
1691     def is_unity(self):
1692         """
1693         Returns `True` if the unit is unscaled and dimensionless.
1694         """
1695         return False
1696 
1697 
1698 class NamedUnit(UnitBase):
1699     """
1700     The base class of units that have a name.
1701 
1702     Parameters
1703     ----------
1704     st : str, list of str, 2-tuple
1705         The name of the unit.  If a list of strings, the first element
1706         is the canonical (short) name, and the rest of the elements
1707         are aliases.  If a tuple of lists, the first element is a list
1708         of short names, and the second element is a list of long
1709         names; all but the first short name are considered "aliases".
1710         Each name *should* be a valid Python identifier to make it
1711         easy to access, but this is not required.
1712 
1713     namespace : dict, optional
1714         When provided, inject the unit, and all of its aliases, in the
1715         given namespace dictionary.  If a unit by the same name is
1716         already in the namespace, a ValueError is raised.
1717 
1718     doc : str, optional
1719         A docstring describing the unit.
1720 
1721     format : dict, optional
1722         A mapping to format-specific representations of this unit.
1723         For example, for the ``Ohm`` unit, it might be nice to have it
1724         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
1725         case, `format` argument should be set to::
1726 
1727             {'latex': r'\\Omega'}
1728 
1729     Raises
1730     ------
1731     ValueError
1732         If any of the given unit names are already in the registry.
1733 
1734     ValueError
1735         If any of the given unit names are not valid Python tokens.
1736     """
1737 
1738     def __init__(self, st, doc=None, format=None, namespace=None):
1739         UnitBase.__init__(self)
1740 
1741         if isinstance(st, (bytes, str)):
1742             self._names = [st]
1743             self._short_names = [st]
1744             self._long_names = []
1745         elif isinstance(st, tuple):
1746             if not len(st) == 2:
1747                 raise ValueError("st must be string, list or 2-tuple")
1748             self._names = st[0] + [n for n in st[1] if n not in st[0]]
1749             if not len(self._names):
1750                 raise ValueError("must provide at least one name")
1751             self._short_names = st[0][:]
1752             self._long_names = st[1][:]
1753         else:
1754             if len(st) == 0:
1755                 raise ValueError("st list must have at least one entry")
1756             self._names = st[:]
1757             self._short_names = [st[0]]
1758             self._long_names = st[1:]
1759 
1760         if format is None:
1761             format = {}
1762         self._format = format
1763 
1764         if doc is None:
1765             doc = self._generate_doc()
1766         else:
1767             doc = textwrap.dedent(doc)
1768             doc = textwrap.fill(doc)
1769 
1770         self.__doc__ = doc
1771 
1772         self._inject(namespace)
1773 
1774     def _generate_doc(self):
1775         """
1776         Generate a docstring for the unit if the user didn't supply
1777         one.  This is only used from the constructor and may be
1778         overridden in subclasses.
1779         """
1780         names = self.names
1781         if len(self.names) > 1:
1782             return f"{names[1]} ({names[0]})"
1783         else:
1784             return names[0]
1785 
1786     def get_format_name(self, format):
1787         """
1788         Get a name for this unit that is specific to a particular
1789         format.
1790 
1791         Uses the dictionary passed into the `format` kwarg in the
1792         constructor.
1793 
1794         Parameters
1795         ----------
1796         format : str
1797             The name of the format
1798 
1799         Returns
1800         -------
1801         name : str
1802             The name of the unit for the given format.
1803         """
1804         return self._format.get(format, self.name)
1805 
1806     @property
1807     def names(self):
1808         """
1809         Returns all of the names associated with this unit.
1810         """
1811         return self._names
1812 
1813     @property
1814     def name(self):
1815         """
1816         Returns the canonical (short) name associated with this unit.
1817         """
1818         return self._names[0]
1819 
1820     @property
1821     def aliases(self):
1822         """
1823         Returns the alias (long) names for this unit.
1824         """
1825         return self._names[1:]
1826 
1827     @property
1828     def short_names(self):
1829         """
1830         Returns all of the short names associated with this unit.
1831         """
1832         return self._short_names
1833 
1834     @property
1835     def long_names(self):
1836         """
1837         Returns all of the long names associated with this unit.
1838         """
1839         return self._long_names
1840 
1841     def _inject(self, namespace=None):
1842         """
1843         Injects the unit, and all of its aliases, in the given
1844         namespace dictionary.
1845         """
1846         if namespace is None:
1847             return
1848 
1849         # Loop through all of the names first, to ensure all of them
1850         # are new, then add them all as a single "transaction" below.
1851         for name in self._names:
1852             if name in namespace and self != namespace[name]:
1853                 raise ValueError(
1854                     f"Object with name {name!r} already exists in "
1855                     f"given namespace ({namespace[name]!r})."
1856                 )
1857 
1858         for name in self._names:
1859             namespace[name] = self
1860 
1861 
1862 def _recreate_irreducible_unit(cls, names, registered):
1863     """
1864     This is used to reconstruct units when passed around by
1865     multiprocessing.
1866     """
1867     registry = get_current_unit_registry().registry
1868     if names[0] in registry:
1869         # If in local registry return that object.
1870         return registry[names[0]]
1871     else:
1872         # otherwise, recreate the unit.
1873         unit = cls(names)
1874         if registered:
1875             # If not in local registry but registered in origin registry,
1876             # enable unit in local registry.
1877             get_current_unit_registry().add_enabled_units([unit])
1878 
1879         return unit
1880 
1881 
1882 class IrreducibleUnit(NamedUnit):
1883     """
1884     Irreducible units are the units that all other units are defined
1885     in terms of.
1886 
1887     Examples are meters, seconds, kilograms, amperes, etc.  There is
1888     only once instance of such a unit per type.
1889     """
1890 
1891     def __reduce__(self):
1892         # When IrreducibleUnit objects are passed to other processes
1893         # over multiprocessing, they need to be recreated to be the
1894         # ones already in the subprocesses' namespace, not new
1895         # objects, or they will be considered "unconvertible".
1896         # Therefore, we have a custom pickler/unpickler that
1897         # understands how to recreate the Unit on the other side.
1898         registry = get_current_unit_registry().registry
1899         return (
1900             _recreate_irreducible_unit,
1901             (self.__class__, list(self.names), self.name in registry),
1902             self.__getstate__(),
1903         )
1904 
1905     @property
1906     def represents(self):
1907         """The unit that this named unit represents.
1908 
1909         For an irreducible unit, that is always itself.
1910         """
1911         return self
1912 
1913     def decompose(self, bases=set()):
1914         if len(bases) and self not in bases:
1915             for base in bases:
1916                 try:
1917                     scale = self._to(base)
1918                 except UnitsError:
1919                     pass
1920                 else:
1921                     if is_effectively_unity(scale):
1922                         return base
1923                     else:
1924                         return CompositeUnit(scale, [base], [1], _error_check=False)
1925 
1926             raise UnitConversionError(
1927                 f"Unit {self} can not be decomposed into the requested bases"
1928             )
1929 
1930         return self
1931 
1932 
1933 class UnrecognizedUnit(IrreducibleUnit):
1934     """
1935     A unit that did not parse correctly.  This allows for
1936     round-tripping it as a string, but no unit operations actually work
1937     on it.
1938 
1939     Parameters
1940     ----------
1941     st : str
1942         The name of the unit.
1943     """
1944 
1945     # For UnrecognizedUnits, we want to use "standard" Python
1946     # pickling, not the special case that is used for
1947     # IrreducibleUnits.
1948     __reduce__ = object.__reduce__
1949 
1950     def __repr__(self):
1951         return f"UnrecognizedUnit({str(self)})"
1952 
1953     def __bytes__(self):
1954         return self.name.encode("ascii", "replace")
1955 
1956     def __str__(self):
1957         return self.name
1958 
1959     def to_string(self, format=None):
1960         return self.name
1961 
1962     def _unrecognized_operator(self, *args, **kwargs):
1963         raise ValueError(
1964             f"The unit {self.name!r} is unrecognized, so all arithmetic operations "
1965             "with it are invalid."
1966         )
1967 
1968     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = _unrecognized_operator
1969     __lt__ = __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator
1970 
1971     def __eq__(self, other):
1972         try:
1973             other = Unit(other, parse_strict="silent")
1974         except (ValueError, UnitsError, TypeError):
1975             return NotImplemented
1976 
1977         return isinstance(other, type(self)) and self.name == other.name
1978 
1979     def __ne__(self, other):
1980         return not (self == other)
1981 
1982     def is_equivalent(self, other, equivalencies=None):
1983         self._normalize_equivalencies(equivalencies)
1984         return self == other
1985 
1986     def _get_converter(self, other, equivalencies=None):
1987         self._normalize_equivalencies(equivalencies)
1988         raise ValueError(
1989             f"The unit {self.name!r} is unrecognized.  It can not be converted "
1990             "to other units."
1991         )
1992 
1993     def get_format_name(self, format):
1994         return self.name
1995 
1996     def is_unity(self):
1997         return False
1998 
1999 
2000 class _UnitMetaClass(type):
2001     """
2002     This metaclass exists because the Unit constructor should
2003     sometimes return instances that already exist.  This "overrides"
2004     the constructor before the new instance is actually created, so we
2005     can return an existing one.
2006     """
2007 
2008     def __call__(
2009         self,
2010         s="",
2011         represents=None,
2012         format=None,
2013         namespace=None,
2014         doc=None,
2015         parse_strict="raise",
2016     ):
2017         # Short-circuit if we're already a unit
2018         if hasattr(s, "_get_physical_type_id"):
2019             return s
2020 
2021         # turn possible Quantity input for s or represents into a Unit
2022         from .quantity import Quantity
2023 
2024         if isinstance(represents, Quantity):
2025             if is_effectively_unity(represents.value):
2026                 represents = represents.unit
2027             else:
2028                 represents = CompositeUnit(
2029                     represents.value * represents.unit.scale,
2030                     bases=represents.unit.bases,
2031                     powers=represents.unit.powers,
2032                     _error_check=False,
2033                 )
2034 
2035         if isinstance(s, Quantity):
2036             if is_effectively_unity(s.value):
2037                 s = s.unit
2038             else:
2039                 s = CompositeUnit(
2040                     s.value * s.unit.scale,
2041                     bases=s.unit.bases,
2042                     powers=s.unit.powers,
2043                     _error_check=False,
2044                 )
2045 
2046         # now decide what we really need to do; define derived Unit?
2047         if isinstance(represents, UnitBase):
2048             # This has the effect of calling the real __new__ and
2049             # __init__ on the Unit class.
2050             return super().__call__(
2051                 s, represents, format=format, namespace=namespace, doc=doc
2052             )
2053 
2054         # or interpret a Quantity (now became unit), string or number?
2055         if isinstance(s, UnitBase):
2056             return s
2057 
2058         elif isinstance(s, (bytes, str)):
2059             if len(s.strip()) == 0:
2060                 # Return the NULL unit
2061                 return dimensionless_unscaled
2062 
2063             if format is None:
2064                 format = unit_format.Generic
2065 
2066             f = unit_format.get_format(format)
2067             if isinstance(s, bytes):
2068                 s = s.decode("ascii")
2069 
2070             try:
2071                 return f.parse(s)
2072             except NotImplementedError:
2073                 raise
2074             except Exception as e:
2075                 if parse_strict == "silent":
2076                     pass
2077                 else:
2078                     # Deliberately not issubclass here. Subclasses
2079                     # should use their name.
2080                     if f is not unit_format.Generic:
2081                         format_clause = f.name + " "
2082                     else:
2083                         format_clause = ""
2084                     msg = (
2085                         f"'{s}' did not parse as {format_clause}unit: {str(e)} "
2086                         "If this is meant to be a custom unit, "
2087                         "define it with 'u.def_unit'. To have it "
2088                         "recognized inside a file reader or other code, "
2089                         "enable it with 'u.add_enabled_units'. "
2090                         "For details, see "
2091                         "https://docs.astropy.org/en/latest/units/combining_and_defining.html"
2092                     )
2093                     if parse_strict == "raise":
2094                         raise ValueError(msg)
2095                     elif parse_strict == "warn":
2096                         warnings.warn(msg, UnitsWarning)
2097                     else:
2098                         raise ValueError(
2099                             "'parse_strict' must be 'warn', 'raise' or 'silent'"
2100                         )
2101                 return UnrecognizedUnit(s)
2102 
2103         elif isinstance(s, (int, float, np.floating, np.integer)):
2104             return CompositeUnit(s, [], [], _error_check=False)
2105 
2106         elif isinstance(s, tuple):
2107             from .structured import StructuredUnit
2108 
2109             return StructuredUnit(s)
2110 
2111         elif s is None:
2112             raise TypeError("None is not a valid Unit")
2113 
2114         else:
2115             raise TypeError(f"{s} can not be converted to a Unit")
2116 
2117 
2118 class Unit(NamedUnit, metaclass=_UnitMetaClass):
2119     """
2120     The main unit class.
2121 
2122     There are a number of different ways to construct a Unit, but
2123     always returns a `UnitBase` instance.  If the arguments refer to
2124     an already-existing unit, that existing unit instance is returned,
2125     rather than a new one.
2126 
2127     - From a string::
2128 
2129         Unit(s, format=None, parse_strict='silent')
2130 
2131       Construct from a string representing a (possibly compound) unit.
2132 
2133       The optional `format` keyword argument specifies the format the
2134       string is in, by default ``"generic"``.  For a description of
2135       the available formats, see `astropy.units.format`.
2136 
2137       The optional ``parse_strict`` keyword controls what happens when an
2138       unrecognized unit string is passed in.  It may be one of the following:
2139 
2140          - ``'raise'``: (default) raise a ValueError exception.
2141 
2142          - ``'warn'``: emit a Warning, and return an
2143            `UnrecognizedUnit` instance.
2144 
2145          - ``'silent'``: return an `UnrecognizedUnit` instance.
2146 
2147     - From a number::
2148 
2149         Unit(number)
2150 
2151       Creates a dimensionless unit.
2152 
2153     - From a `UnitBase` instance::
2154 
2155         Unit(unit)
2156 
2157       Returns the given unit unchanged.
2158 
2159     - From no arguments::
2160 
2161         Unit()
2162 
2163       Returns the dimensionless unit.
2164 
2165     - The last form, which creates a new `Unit` is described in detail
2166       below.
2167 
2168     See also: https://docs.astropy.org/en/stable/units/
2169 
2170     Parameters
2171     ----------
2172     st : str or list of str
2173         The name of the unit.  If a list, the first element is the
2174         canonical (short) name, and the rest of the elements are
2175         aliases.
2176 
2177     represents : UnitBase instance
2178         The unit that this named unit represents.
2179 
2180     doc : str, optional
2181         A docstring describing the unit.
2182 
2183     format : dict, optional
2184         A mapping to format-specific representations of this unit.
2185         For example, for the ``Ohm`` unit, it might be nice to have it
2186         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
2187         case, `format` argument should be set to::
2188 
2189             {'latex': r'\\Omega'}
2190 
2191     namespace : dict, optional
2192         When provided, inject the unit (and all of its aliases) into
2193         the given namespace.
2194 
2195     Raises
2196     ------
2197     ValueError
2198         If any of the given unit names are already in the registry.
2199 
2200     ValueError
2201         If any of the given unit names are not valid Python tokens.
2202     """
2203 
2204     def __init__(self, st, represents=None, doc=None, format=None, namespace=None):
2205         represents = Unit(represents)
2206         self._represents = represents
2207 
2208         NamedUnit.__init__(self, st, namespace=namespace, doc=doc, format=format)
2209 
2210     @property
2211     def represents(self):
2212         """The unit that this named unit represents."""
2213         return self._represents
2214 
2215     def decompose(self, bases=set()):
2216         return self._represents.decompose(bases=bases)
2217 
2218     def is_unity(self):
2219         return self._represents.is_unity()
2220 
2221     def __hash__(self):
2222         if self._hash is None:
2223             self._hash = hash((self.name, self._represents))
2224         return self._hash
2225 
2226     @classmethod
2227     def _from_physical_type_id(cls, physical_type_id):
2228         # get string bases and powers from the ID tuple
2229         bases = [cls(base) for base, _ in physical_type_id]
2230         powers = [power for _, power in physical_type_id]
2231 
2232         if len(physical_type_id) == 1 and powers[0] == 1:
2233             unit = bases[0]
2234         else:
2235             unit = CompositeUnit(1, bases, powers, _error_check=False)
2236 
2237         return unit
2238 
2239 
2240 class PrefixUnit(Unit):
2241     """
2242     A unit that is simply a SI-prefixed version of another unit.
2243 
2244     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.
2245 
2246     The constructor is the same as for `Unit`.
2247     """
2248 
2249 
2250 class CompositeUnit(UnitBase):
2251     """
2252     Create a composite unit using expressions of previously defined
2253     units.
2254 
2255     Direct use of this class is not recommended. Instead use the
2256     factory function `Unit` and arithmetic operators to compose
2257     units.
2258 
2259     Parameters
2260     ----------
2261     scale : number
2262         A scaling factor for the unit.
2263 
2264     bases : sequence of `UnitBase`
2265         A sequence of units this unit is composed of.
2266 
2267     powers : sequence of numbers
2268         A sequence of powers (in parallel with ``bases``) for each
2269         of the base units.
2270     """
2271 
2272     _decomposed_cache = None
2273 
2274     def __init__(
2275         self,
2276         scale,
2277         bases,
2278         powers,
2279         decompose=False,
2280         decompose_bases=set(),
2281         _error_check=True,
2282     ):
2283         # There are many cases internal to astropy.units where we
2284         # already know that all the bases are Unit objects, and the
2285         # powers have been validated.  In those cases, we can skip the
2286         # error checking for performance reasons.  When the private
2287         # kwarg `_error_check` is False, the error checking is turned
2288         # off.
2289         if _error_check:
2290             for base in bases:
2291                 if not isinstance(base, UnitBase):
2292                     raise TypeError("bases must be sequence of UnitBase instances")
2293             powers = [validate_power(p) for p in powers]
2294 
2295         if not decompose and len(bases) == 1 and powers[0] >= 0:
2296             # Short-cut; with one unit there's nothing to expand and gather,
2297             # as that has happened already when creating the unit.  But do only
2298             # positive powers, since for negative powers we need to re-sort.
2299             unit = bases[0]
2300             power = powers[0]
2301             if power == 1:
2302                 scale *= unit.scale
2303                 self._bases = unit.bases
2304                 self._powers = unit.powers
2305             elif power == 0:
2306                 self._bases = []
2307                 self._powers = []
2308             else:
2309                 scale *= unit.scale**power
2310                 self._bases = unit.bases
2311                 self._powers = [
2312                     operator.mul(*resolve_fractions(p, power)) for p in unit.powers
2313                 ]
2314 
2315             self._scale = sanitize_scale(scale)
2316         else:
2317             # Regular case: use inputs as preliminary scale, bases, and powers,
2318             # then "expand and gather" identical bases, sanitize the scale, &c.
2319             self._scale = scale
2320             self._bases = bases
2321             self._powers = powers
2322             self._expand_and_gather(decompose=decompose, bases=decompose_bases)
2323 
2324     def __repr__(self):
2325         if len(self._bases):
2326             return super().__repr__()
2327         else:
2328             if self._scale != 1.0:
2329                 return f"Unit(dimensionless with a scale of {self._scale})"
2330             else:
2331                 return "Unit(dimensionless)"
2332 
2333     @property
2334     def scale(self):
2335         """
2336         Return the scale of the composite unit.
2337         """
2338         return self._scale
2339 
2340     @property
2341     def bases(self):
2342         """
2343         Return the bases of the composite unit.
2344         """
2345         return self._bases
2346 
2347     @property
2348     def powers(self):
2349         """
2350         Return the powers of the composite unit.
2351         """
2352         return self._powers
2353 
2354     def _expand_and_gather(self, decompose=False, bases=set()):
2355         def add_unit(unit, power, scale):
2356             if bases and unit not in bases:
2357                 for base in bases:
2358                     try:
2359                         scale *= unit._to(base) ** power
2360                     except UnitsError:
2361                         pass
2362                     else:
2363                         unit = base
2364                         break
2365 
2366             if unit in new_parts:
2367                 a, b = resolve_fractions(new_parts[unit], power)
2368                 new_parts[unit] = a + b
2369             else:
2370                 new_parts[unit] = power
2371             return scale
2372 
2373         new_parts = {}
2374         scale = self._scale
2375 
2376         for b, p in zip(self._bases, self._powers):
2377             if decompose and b not in bases:
2378                 b = b.decompose(bases=bases)
2379 
2380             if isinstance(b, CompositeUnit):
2381                 scale *= b._scale**p
2382                 for b_sub, p_sub in zip(b._bases, b._powers):
2383                     a, b = resolve_fractions(p_sub, p)
2384                     scale = add_unit(b_sub, a * b, scale)
2385             else:
2386                 scale = add_unit(b, p, scale)
2387 
2388         new_parts = [x for x in new_parts.items() if x[1] != 0]
2389         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], "name", "")))
2390 
2391         self._bases = [x[0] for x in new_parts]
2392         self._powers = [x[1] for x in new_parts]
2393         self._scale = sanitize_scale(scale)
2394 
2395     def __copy__(self):
2396         """
2397         For compatibility with python copy module.
2398         """
2399         return CompositeUnit(self._scale, self._bases[:], self._powers[:])
2400 
2401     def decompose(self, bases=set()):
2402         if len(bases) == 0 and self._decomposed_cache is not None:
2403             return self._decomposed_cache
2404 
2405         for base in self.bases:
2406             if not isinstance(base, IrreducibleUnit) or (
2407                 len(bases) and base not in bases
2408             ):
2409                 break
2410         else:
2411             if len(bases) == 0:
2412                 self._decomposed_cache = self
2413             return self
2414 
2415         x = CompositeUnit(
2416             self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases
2417         )
2418         if len(bases) == 0:
2419             self._decomposed_cache = x
2420         return x
2421 
2422     def is_unity(self):
2423         unit = self.decompose()
2424         return len(unit.bases) == 0 and unit.scale == 1.0
2425 
2426 
2427 si_prefixes = [
2428     (["Q"], ["quetta"], 1e30),
2429     (["R"], ["ronna"], 1e27),
2430     (["Y"], ["yotta"], 1e24),
2431     (["Z"], ["zetta"], 1e21),
2432     (["E"], ["exa"], 1e18),
2433     (["P"], ["peta"], 1e15),
2434     (["T"], ["tera"], 1e12),
2435     (["G"], ["giga"], 1e9),
2436     (["M"], ["mega"], 1e6),
2437     (["k"], ["kilo"], 1e3),
2438     (["h"], ["hecto"], 1e2),
2439     (["da"], ["deka", "deca"], 1e1),
2440     (["d"], ["deci"], 1e-1),
2441     (["c"], ["centi"], 1e-2),
2442     (["m"], ["milli"], 1e-3),
2443     (["u"], ["micro"], 1e-6),
2444     (["n"], ["nano"], 1e-9),
2445     (["p"], ["pico"], 1e-12),
2446     (["f"], ["femto"], 1e-15),
2447     (["a"], ["atto"], 1e-18),
2448     (["z"], ["zepto"], 1e-21),
2449     (["y"], ["yocto"], 1e-24),
2450     (["r"], ["ronto"], 1e-27),
2451     (["q"], ["quecto"], 1e-30),
2452 ]
2453 
2454 
2455 binary_prefixes = [
2456     (["Ki"], ["kibi"], 2**10),
2457     (["Mi"], ["mebi"], 2**20),
2458     (["Gi"], ["gibi"], 2**30),
2459     (["Ti"], ["tebi"], 2**40),
2460     (["Pi"], ["pebi"], 2**50),
2461     (["Ei"], ["exbi"], 2**60),
2462 ]
2463 
2464 
2465 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):
2466     """
2467     Set up all of the standard metric prefixes for a unit.  This
2468     function should not be used directly, but instead use the
2469     `prefixes` kwarg on `def_unit`.
2470 
2471     Parameters
2472     ----------
2473     excludes : list of str, optional
2474         Any prefixes to exclude from creation to avoid namespace
2475         collisions.
2476 
2477     namespace : dict, optional
2478         When provided, inject the unit (and all of its aliases) into
2479         the given namespace dictionary.
2480 
2481     prefixes : list, optional
2482         When provided, it is a list of prefix definitions of the form:
2483 
2484             (short_names, long_tables, factor)
2485     """
2486     if prefixes is True:
2487         prefixes = si_prefixes
2488     elif prefixes is False:
2489         prefixes = []
2490 
2491     for short, full, factor in prefixes:
2492         names = []
2493         format = {}
2494         for prefix in short:
2495             if prefix in excludes:
2496                 continue
2497 
2498             for alias in u.short_names:
2499                 names.append(prefix + alias)
2500 
2501                 # This is a hack to use Greek mu as a prefix
2502                 # for some formatters.
2503                 if prefix == "u":
2504                     format["latex"] = r"\mu " + u.get_format_name("latex")
2505                     format["unicode"] = "\N{MICRO SIGN}" + u.get_format_name("unicode")
2506 
2507                 for key, val in u._format.items():
2508                     format.setdefault(key, prefix + val)
2509 
2510         for prefix in full:
2511             if prefix in excludes:
2512                 continue
2513 
2514             for alias in u.long_names:
2515                 names.append(prefix + alias)
2516 
2517         if len(names):
2518             PrefixUnit(
2519                 names,
2520                 CompositeUnit(factor, [u], [1], _error_check=False),
2521                 namespace=namespace,
2522                 format=format,
2523             )
2524 
2525 
2526 def def_unit(
2527     s,
2528     represents=None,
2529     doc=None,
2530     format=None,
2531     prefixes=False,
2532     exclude_prefixes=[],
2533     namespace=None,
2534 ):
2535     """
2536     Factory function for defining new units.
2537 
2538     Parameters
2539     ----------
2540     s : str or list of str
2541         The name of the unit.  If a list, the first element is the
2542         canonical (short) name, and the rest of the elements are
2543         aliases.
2544 
2545     represents : UnitBase instance, optional
2546         The unit that this named unit represents.  If not provided,
2547         a new `IrreducibleUnit` is created.
2548 
2549     doc : str, optional
2550         A docstring describing the unit.
2551 
2552     format : dict, optional
2553         A mapping to format-specific representations of this unit.
2554         For example, for the ``Ohm`` unit, it might be nice to
2555         have it displayed as ``\\Omega`` by the ``latex``
2556         formatter.  In that case, `format` argument should be set
2557         to::
2558 
2559             {'latex': r'\\Omega'}
2560 
2561     prefixes : bool or list, optional
2562         When `True`, generate all of the SI prefixed versions of the
2563         unit as well.  For example, for a given unit ``m``, will
2564         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of
2565         prefix definitions of the form:
2566 
2567             (short_names, long_tables, factor)
2568 
2569         Default is `False`.  This function always returns the base
2570         unit object, even if multiple scaled versions of the unit were
2571         created.
2572 
2573     exclude_prefixes : list of str, optional
2574         If any of the SI prefixes need to be excluded, they may be
2575         listed here.  For example, ``Pa`` can be interpreted either as
2576         "petaannum" or "Pascal".  Therefore, when defining the
2577         prefixes for ``a``, ``exclude_prefixes`` should be set to
2578         ``["P"]``.
2579 
2580     namespace : dict, optional
2581         When provided, inject the unit (and all of its aliases and
2582         prefixes), into the given namespace dictionary.
2583 
2584     Returns
2585     -------
2586     unit : `~astropy.units.UnitBase`
2587         The newly-defined unit, or a matching unit that was already
2588         defined.
2589     """
2590     if represents is not None:
2591         result = Unit(s, represents, namespace=namespace, doc=doc, format=format)
2592     else:
2593         result = IrreducibleUnit(s, namespace=namespace, doc=doc, format=format)
2594 
2595     if prefixes:
2596         _add_prefixes(
2597             result, excludes=exclude_prefixes, namespace=namespace, prefixes=prefixes
2598         )
2599     return result
2600 
2601 
2602 def _condition_arg(value):
2603     """
2604     Validate value is acceptable for conversion purposes.
2605 
2606     Will convert into an array if not a scalar, and can be converted
2607     into an array
2608 
2609     Parameters
2610     ----------
2611     value : int or float value, or sequence of such values
2612 
2613     Returns
2614     -------
2615     Scalar value or numpy array
2616 
2617     Raises
2618     ------
2619     ValueError
2620         If value is not as expected
2621     """
2622     if isinstance(value, (np.ndarray, float, int, complex, np.void)):
2623         return value
2624 
2625     avalue = np.array(value)
2626     if avalue.dtype.kind not in ["i", "f", "c"]:
2627         raise ValueError(
2628             "Value not scalar compatible or convertible to "
2629             "an int, float, or complex array"
2630         )
2631     return avalue
2632 
2633 
2634 def unit_scale_converter(val):
2635     """Function that just multiplies the value by unity.
2636 
2637     This is a separate function so it can be recognized and
2638     discarded in unit conversion.
2639     """
2640     return 1.0 * _condition_arg(val)
2641 
2642 
2643 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)
2644 # Abbreviation of the above, see #1980
2645 one = dimensionless_unscaled
2646 
2647 # Maintain error in old location for backward compatibility
2648 # TODO: Is this still needed? Should there be a deprecation warning?
2649 unit_format.fits.UnitScaleError = UnitScaleError

</code><intended_behavior>The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format.</intended_behavior>, <file>astropy/units/quantity.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 """
3 This module defines the `Quantity` object, which represents a number with some
4 associated units. `Quantity` objects support operations like ordinary numbers,
5 but will deal with unit conversions internally.
6 """
7 
8 # STDLIB
9 import numbers
10 import operator
11 import re
12 import warnings
13 from fractions import Fraction
14 
15 # THIRD PARTY
16 import numpy as np
17 
18 # LOCAL
19 from astropy import config as _config
20 from astropy.utils.compat import NUMPY_LT_1_22
21 from astropy.utils.data_info import ParentDtypeInfo
22 from astropy.utils.decorators import deprecated
23 from astropy.utils.exceptions import AstropyWarning
24 from astropy.utils.misc import isiterable
25 
26 from .core import (
27     Unit,
28     UnitBase,
29     UnitConversionError,
30     UnitsError,
31     UnitTypeError,
32     dimensionless_unscaled,
33     get_current_unit_registry,
34 )
35 from .format import Base, Latex
36 from .quantity_helper import can_have_arbitrary_unit, check_output, converters_and_unit
37 from .quantity_helper.function_helpers import (
38     DISPATCHED_FUNCTIONS,
39     FUNCTION_HELPERS,
40     SUBCLASS_SAFE_FUNCTIONS,
41     UNSUPPORTED_FUNCTIONS,
42 )
43 from .structured import StructuredUnit, _structured_unit_like_dtype
44 from .utils import is_effectively_unity
45 
46 __all__ = [
47     "Quantity",
48     "SpecificTypeQuantity",
49     "QuantityInfoBase",
50     "QuantityInfo",
51     "allclose",
52     "isclose",
53 ]
54 
55 
56 # We don't want to run doctests in the docstrings we inherit from Numpy
57 __doctest_skip__ = ["Quantity.*"]
58 
59 _UNIT_NOT_INITIALISED = "(Unit not initialised)"
60 _UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}
61 
62 
63 class Conf(_config.ConfigNamespace):
64     """
65     Configuration parameters for Quantity.
66     """
67 
68     latex_array_threshold = _config.ConfigItem(
69         100,
70         "The maximum size an array Quantity can be before its LaTeX "
71         'representation for IPython gets "summarized" (meaning only the first '
72         'and last few elements are shown with "..." between). Setting this to a '
73         "negative number means that the value will instead be whatever numpy "
74         "gets from get_printoptions.",
75     )
76 
77 
78 conf = Conf()
79 
80 
81 class QuantityIterator:
82     """
83     Flat iterator object to iterate over Quantities.
84 
85     A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity
86     ``q``.  It allows iterating over the array as if it were a 1-D array,
87     either in a for-loop or by calling its `next` method.
88 
89     Iteration is done in C-contiguous style, with the last index varying the
90     fastest. The iterator can also be indexed using basic slicing or
91     advanced indexing.
92 
93     See Also
94     --------
95     Quantity.flatten : Returns a flattened copy of an array.
96 
97     Notes
98     -----
99     `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It
100     is not exported by the `~astropy.units` module.  Instead of
101     instantiating a `QuantityIterator` directly, use `Quantity.flat`.
102     """
103 
104     def __init__(self, q):
105         self._quantity = q
106         self._dataiter = q.view(np.ndarray).flat
107 
108     def __iter__(self):
109         return self
110 
111     def __getitem__(self, indx):
112         out = self._dataiter.__getitem__(indx)
113         # For single elements, ndarray.flat.__getitem__ returns scalars; these
114         # need a new view as a Quantity.
115         if isinstance(out, type(self._quantity)):
116             return out
117         else:
118             return self._quantity._new_view(out)
119 
120     def __setitem__(self, index, value):
121         self._dataiter[index] = self._quantity._to_own_unit(value)
122 
123     def __next__(self):
124         """
125         Return the next value, or raise StopIteration.
126         """
127         out = next(self._dataiter)
128         # ndarray.flat._dataiter returns scalars, so need a view as a Quantity.
129         return self._quantity._new_view(out)
130 
131     next = __next__
132 
133     def __len__(self):
134         return len(self._dataiter)
135 
136     #### properties and methods to match `numpy.ndarray.flatiter` ####
137 
138     @property
139     def base(self):
140         """A reference to the array that is iterated over."""
141         return self._quantity
142 
143     @property
144     def coords(self):
145         """An N-dimensional tuple of current coordinates."""
146         return self._dataiter.coords
147 
148     @property
149     def index(self):
150         """Current flat index into the array."""
151         return self._dataiter.index
152 
153     def copy(self):
154         """Get a copy of the iterator as a 1-D array."""
155         return self._quantity.flatten()
156 
157 
158 class QuantityInfoBase(ParentDtypeInfo):
159     # This is on a base class rather than QuantityInfo directly, so that
160     # it can be used for EarthLocationInfo yet make clear that that class
161     # should not be considered a typical Quantity subclass by Table.
162     attrs_from_parent = {"dtype", "unit"}  # dtype and unit taken from parent
163     _supports_indexing = True
164 
165     @staticmethod
166     def default_format(val):
167         return f"{val.value}"
168 
169     @staticmethod
170     def possible_string_format_functions(format_):
171         """Iterate through possible string-derived format functions.
172 
173         A string can either be a format specifier for the format built-in,
174         a new-style format string, or an old-style format string.
175 
176         This method is overridden in order to suppress printing the unit
177         in each row since it is already at the top in the column header.
178         """
179         yield lambda format_, val: format(val.value, format_)
180         yield lambda format_, val: format_.format(val.value)
181         yield lambda format_, val: format_ % val.value
182 
183 
184 class QuantityInfo(QuantityInfoBase):
185     """
186     Container for meta information like name, description, format.  This is
187     required when the object is used as a mixin column within a table, but can
188     be used as a general way to store meta information.
189     """
190 
191     _represent_as_dict_attrs = ("value", "unit")
192     _construct_from_dict_args = ["value"]
193     _represent_as_dict_primary_data = "value"
194 
195     def new_like(self, cols, length, metadata_conflicts="warn", name=None):
196         """
197         Return a new Quantity instance which is consistent with the
198         input ``cols`` and has ``length`` rows.
199 
200         This is intended for creating an empty column object whose elements can
201         be set in-place for table operations like join or vstack.
202 
203         Parameters
204         ----------
205         cols : list
206             List of input columns
207         length : int
208             Length of the output column object
209         metadata_conflicts : str ('warn'|'error'|'silent')
210             How to handle metadata conflicts
211         name : str
212             Output column name
213 
214         Returns
215         -------
216         col : `~astropy.units.Quantity` (or subclass)
217             Empty instance of this class consistent with ``cols``
218 
219         """
220         # Get merged info attributes like shape, dtype, format, description, etc.
221         attrs = self.merge_cols_attributes(
222             cols, metadata_conflicts, name, ("meta", "format", "description")
223         )
224 
225         # Make an empty quantity using the unit of the last one.
226         shape = (length,) + attrs.pop("shape")
227         dtype = attrs.pop("dtype")
228         # Use zeros so we do not get problems for Quantity subclasses such
229         # as Longitude and Latitude, which cannot take arbitrary values.
230         data = np.zeros(shape=shape, dtype=dtype)
231         # Get arguments needed to reconstruct class
232         map = {
233             key: (data if key == "value" else getattr(cols[-1], key))
234             for key in self._represent_as_dict_attrs
235         }
236         map["copy"] = False
237         out = self._construct_from_dict(map)
238 
239         # Set remaining info attributes
240         for attr, value in attrs.items():
241             setattr(out.info, attr, value)
242 
243         return out
244 
245     def get_sortable_arrays(self):
246         """
247         Return a list of arrays which can be lexically sorted to represent
248         the order of the parent column.
249 
250         For Quantity this is just the quantity itself.
251 
252 
253         Returns
254         -------
255         arrays : list of ndarray
256         """
257         return [self._parent]
258 
259 
260 class Quantity(np.ndarray):
261     """A `~astropy.units.Quantity` represents a number with some associated unit.
262 
263     See also: https://docs.astropy.org/en/stable/units/quantity.html
264 
265     Parameters
266     ----------
267     value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str
268         The numerical value of this quantity in the units given by unit.  If a
269         `Quantity` or sequence of them (or any other valid object with a
270         ``unit`` attribute), creates a new `Quantity` object, converting to
271         `unit` units as needed.  If a string, it is converted to a number or
272         `Quantity`, depending on whether a unit is present.
273 
274     unit : unit-like
275         An object that represents the unit associated with the input value.
276         Must be an `~astropy.units.UnitBase` object or a string parseable by
277         the :mod:`~astropy.units` package.
278 
279     dtype : ~numpy.dtype, optional
280         The dtype of the resulting Numpy array or scalar that will
281         hold the value.  If not provided, it is determined from the input,
282         except that any integer and (non-Quantity) object inputs are converted
283         to float by default.
284         If `None`, the normal `numpy.dtype` introspection is used, e.g.
285         preventing upcasting of integers.
286 
287     copy : bool, optional
288         If `True` (default), then the value is copied.  Otherwise, a copy will
289         only be made if ``__array__`` returns a copy, if value is a nested
290         sequence, or if a copy is needed to satisfy an explicitly given
291         ``dtype``.  (The `False` option is intended mostly for internal use,
292         to speed up initialization where a copy is known to have been made.
293         Use with care.)
294 
295     order : {'C', 'F', 'A'}, optional
296         Specify the order of the array.  As in `~numpy.array`.  This parameter
297         is ignored if the input is a `Quantity` and ``copy=False``.
298 
299     subok : bool, optional
300         If `False` (default), the returned array will be forced to be a
301         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,
302         or a subclass appropriate for the unit will be used (such as
303         `~astropy.units.Dex` for ``u.dex(u.AA)``).
304 
305     ndmin : int, optional
306         Specifies the minimum number of dimensions that the resulting array
307         should have.  Ones will be prepended to the shape as needed to meet
308         this requirement.  This parameter is ignored if the input is a
309         `Quantity` and ``copy=False``.
310 
311     Raises
312     ------
313     TypeError
314         If the value provided is not a Python numeric type.
315     TypeError
316         If the unit provided is not either a :class:`~astropy.units.Unit`
317         object or a parseable string unit.
318 
319     Notes
320     -----
321     Quantities can also be created by multiplying a number or array with a
322     :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/
323 
324     Unless the ``dtype`` argument is explicitly specified, integer
325     or (non-Quantity) object inputs are converted to `float` by default.
326     """
327 
328     # Need to set a class-level default for _equivalencies, or
329     # Constants can not initialize properly
330     _equivalencies = []
331 
332     # Default unit for initialization; can be overridden by subclasses,
333     # possibly to `None` to indicate there is no default unit.
334     _default_unit = dimensionless_unscaled
335 
336     # Ensures views have an undefined unit.
337     _unit = None
338 
339     __array_priority__ = 10000
340 
341     def __class_getitem__(cls, unit_shape_dtype):
342         """Quantity Type Hints.
343 
344         Unit-aware type hints are ``Annotated`` objects that encode the class,
345         the unit, and possibly shape and dtype information, depending on the
346         python and :mod:`numpy` versions.
347 
348         Schematically, ``Annotated[cls[shape, dtype], unit]``
349 
350         As a classmethod, the type is the class, ie ``Quantity``
351         produces an ``Annotated[Quantity, ...]`` while a subclass
352         like :class:`~astropy.coordinates.Angle` returns
353         ``Annotated[Angle, ...]``.
354 
355         Parameters
356         ----------
357         unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple
358             Unit specification, can be the physical type (ie str or class).
359             If tuple, then the first element is the unit specification
360             and all other elements are for `numpy.ndarray` type annotations.
361             Whether they are included depends on the python and :mod:`numpy`
362             versions.
363 
364         Returns
365         -------
366         `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`
367             Return type in this preference order:
368             * if python v3.9+ : `typing.Annotated`
369             * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`
370             * `astropy.units.Unit` or `astropy.units.PhysicalType`
371 
372         Raises
373         ------
374         TypeError
375             If the unit/physical_type annotation is not Unit-like or
376             PhysicalType-like.
377 
378         Examples
379         --------
380         Create a unit-aware Quantity type annotation
381 
382             >>> Quantity[Unit("s")]
383             Annotated[Quantity, Unit("s")]
384 
385         See Also
386         --------
387         `~astropy.units.quantity_input`
388             Use annotations for unit checks on function arguments and results.
389 
390         Notes
391         -----
392         With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also
393         static-type compatible.
394         """
395         # LOCAL
396         from ._typing import HAS_ANNOTATED, Annotated
397 
398         # process whether [unit] or [unit, shape, ptype]
399         if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype
400             target = unit_shape_dtype[0]
401             shape_dtype = unit_shape_dtype[1:]
402         else:  # just unit
403             target = unit_shape_dtype
404             shape_dtype = ()
405 
406         # Allowed unit/physical types. Errors if neither.
407         try:
408             unit = Unit(target)
409         except (TypeError, ValueError):
410             from astropy.units.physical import get_physical_type
411 
412             try:
413                 unit = get_physical_type(target)
414             except (TypeError, ValueError, KeyError):  # KeyError for Enum
415                 raise TypeError(
416                     "unit annotation is not a Unit or PhysicalType"
417                 ) from None
418 
419         # Allow to sort of work for python 3.8- / no typing_extensions
420         # instead of bailing out, return the unit for `quantity_input`
421         if not HAS_ANNOTATED:
422             warnings.warn(
423                 "Quantity annotations are valid static type annotations only"
424                 " if Python is v3.9+ or `typing_extensions` is installed."
425             )
426             return unit
427 
428         # Quantity does not (yet) properly extend the NumPy generics types,
429         # introduced in numpy v1.22+, instead just including the unit info as
430         # metadata using Annotated.
431         # TODO: ensure we do interact with NDArray.__class_getitem__.
432         return Annotated.__class_getitem__((cls, unit))
433 
434     def __new__(
435         cls,
436         value,
437         unit=None,
438         dtype=np.inexact,
439         copy=True,
440         order=None,
441         subok=False,
442         ndmin=0,
443     ):
444         if unit is not None:
445             # convert unit first, to avoid multiple string->unit conversions
446             unit = Unit(unit)
447 
448         # inexact -> upcast to float dtype
449         float_default = dtype is np.inexact
450         if float_default:
451             dtype = None
452 
453         # optimize speed for Quantity with no dtype given, copy=False
454         if isinstance(value, Quantity):
455             if unit is not None and unit is not value.unit:
456                 value = value.to(unit)
457                 # the above already makes a copy (with float dtype)
458                 copy = False
459 
460             if type(value) is not cls and not (subok and isinstance(value, cls)):
461                 value = value.view(cls)
462 
463             if float_default and value.dtype.kind in "iu":
464                 dtype = float
465 
466             return np.array(
467                 value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin
468             )
469 
470         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.
471         # To ensure array remains fast, we short-circuit it.
472         value_unit = None
473         if not isinstance(value, np.ndarray):
474             if isinstance(value, str):
475                 # The first part of the regex string matches any integer/float;
476                 # the second parts adds possible trailing .+-, which will break
477                 # the float function below and ensure things like 1.2.3deg
478                 # will not work.
479                 pattern = (
480                     r"\s*[+-]?"
481                     r"((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|"
482                     r"([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))"
483                     r"([eE][+-]?\d+)?"
484                     r"[.+-]?"
485                 )
486 
487                 v = re.match(pattern, value)
488                 unit_string = None
489                 try:
490                     value = float(v.group())
491 
492                 except Exception:
493                     raise TypeError(
494                         f'Cannot parse "{value}" as a {cls.__name__}. It does not '
495                         "start with a number."
496                     )
497 
498                 unit_string = v.string[v.end() :].strip()
499                 if unit_string:
500                     value_unit = Unit(unit_string)
501                     if unit is None:
502                         unit = value_unit  # signal no conversion needed below.
503 
504             elif isiterable(value) and len(value) > 0:
505                 # Iterables like lists and tuples.
506                 if all(isinstance(v, Quantity) for v in value):
507                     # If a list/tuple containing only quantities, convert all
508                     # to the same unit.
509                     if unit is None:
510                         unit = value[0].unit
511                     value = [q.to_value(unit) for q in value]
512                     value_unit = unit  # signal below that conversion has been done
513                 elif (
514                     dtype is None
515                     and not hasattr(value, "dtype")
516                     and isinstance(unit, StructuredUnit)
517                 ):
518                     # Special case for list/tuple of values and a structured unit:
519                     # ``np.array(value, dtype=None)`` would treat tuples as lower
520                     # levels of the array, rather than as elements of a structured
521                     # array, so we use the structure of the unit to help infer the
522                     # structured dtype of the value.
523                     dtype = unit._recursively_get_dtype(value)
524 
525         using_default_unit = False
526         if value_unit is None:
527             # If the value has a `unit` attribute and if not None
528             # (for Columns with uninitialized unit), treat it like a quantity.
529             value_unit = getattr(value, "unit", None)
530             if value_unit is None:
531                 # Default to dimensionless for no (initialized) unit attribute.
532                 if unit is None:
533                     using_default_unit = True
534                     unit = cls._default_unit
535                 value_unit = unit  # signal below that no conversion is needed
536             else:
537                 try:
538                     value_unit = Unit(value_unit)
539                 except Exception as exc:
540                     raise TypeError(
541                         f"The unit attribute {value.unit!r} of the input could "
542                         "not be parsed as an astropy Unit."
543                     ) from exc
544 
545                 if unit is None:
546                     unit = value_unit
547                 elif unit is not value_unit:
548                     copy = False  # copy will be made in conversion at end
549 
550         value = np.array(
551             value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin
552         )
553 
554         # For no-user-input unit, make sure the constructed unit matches the
555         # structure of the data.
556         if using_default_unit and value.dtype.names is not None:
557             unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)
558 
559         # check that array contains numbers or long int objects
560         if value.dtype.kind in "OSU" and not (
561             value.dtype.kind == "O" and isinstance(value.item(0), numbers.Number)
562         ):
563             raise TypeError("The value must be a valid Python or Numpy numeric type.")
564 
565         # by default, cast any integer, boolean, etc., to float
566         if float_default and value.dtype.kind in "iuO":
567             value = value.astype(float)
568 
569         # if we allow subclasses, allow a class from the unit.
570         if subok:
571             qcls = getattr(unit, "_quantity_class", cls)
572             if issubclass(qcls, cls):
573                 cls = qcls
574 
575         value = value.view(cls)
576         value._set_unit(value_unit)
577         if unit is value_unit:
578             return value
579         else:
580             # here we had non-Quantity input that had a "unit" attribute
581             # with a unit different from the desired one.  So, convert.
582             return value.to(unit)
583 
584     def __array_finalize__(self, obj):
585         # Check whether super().__array_finalize should be called
586         # (sadly, ndarray.__array_finalize__ is None; we cannot be sure
587         # what is above us).
588         super_array_finalize = super().__array_finalize__
589         if super_array_finalize is not None:
590             super_array_finalize(obj)
591 
592         # If we're a new object or viewing an ndarray, nothing has to be done.
593         if obj is None or obj.__class__ is np.ndarray:
594             return
595 
596         # If our unit is not set and obj has a valid one, use it.
597         if self._unit is None:
598             unit = getattr(obj, "_unit", None)
599             if unit is not None:
600                 self._set_unit(unit)
601 
602         # Copy info if the original had `info` defined.  Because of the way the
603         # DataInfo works, `'info' in obj.__dict__` is False until the
604         # `info` attribute is accessed or set.
605         if "info" in obj.__dict__:
606             self.info = obj.info
607 
608     def __array_wrap__(self, obj, context=None):
609         if context is None:
610             # Methods like .squeeze() created a new `ndarray` and then call
611             # __array_wrap__ to turn the array into self's subclass.
612             return self._new_view(obj)
613 
614         raise NotImplementedError(
615             "__array_wrap__ should not be used with a context any more since all "
616             "use should go through array_function. Please raise an issue on "
617             "https://github.com/astropy/astropy"
618         )
619 
620     def __array_ufunc__(self, function, method, *inputs, **kwargs):
621         """Wrap numpy ufuncs, taking care of units.
622 
623         Parameters
624         ----------
625         function : callable
626             ufunc to wrap.
627         method : str
628             Ufunc method: ``__call__``, ``at``, ``reduce``, etc.
629         inputs : tuple
630             Input arrays.
631         kwargs : keyword arguments
632             As passed on, with ``out`` containing possible quantity output.
633 
634         Returns
635         -------
636         result : `~astropy.units.Quantity` or `NotImplemented`
637             Results of the ufunc, with the unit set properly.
638         """
639         # Determine required conversion functions -- to bring the unit of the
640         # input to that expected (e.g., radian for np.sin), or to get
641         # consistent units between two inputs (e.g., in np.add) --
642         # and the unit of the result (or tuple of units for nout > 1).
643         try:
644             converters, unit = converters_and_unit(function, method, *inputs)
645 
646             out = kwargs.get("out", None)
647             # Avoid loop back by turning any Quantity output into array views.
648             if out is not None:
649                 # If pre-allocated output is used, check it is suitable.
650                 # This also returns array view, to ensure we don't loop back.
651                 if function.nout == 1:
652                     out = out[0]
653                 out_array = check_output(out, unit, inputs, function=function)
654                 # Ensure output argument remains a tuple.
655                 kwargs["out"] = (out_array,) if function.nout == 1 else out_array
656 
657             if method == "reduce" and "initial" in kwargs and unit is not None:
658                 # Special-case for initial argument for reductions like
659                 # np.add.reduce.  This should be converted to the output unit as
660                 # well, which is typically the same as the input unit (but can
661                 # in principle be different: unitless for np.equal, radian
662                 # for np.arctan2, though those are not necessarily useful!)
663                 kwargs["initial"] = self._to_own_unit(
664                     kwargs["initial"], check_precision=False, unit=unit
665                 )
666 
667             # Same for inputs, but here also convert if necessary.
668             arrays = []
669             for input_, converter in zip(inputs, converters):
670                 input_ = getattr(input_, "value", input_)
671                 arrays.append(converter(input_) if converter else input_)
672 
673             # Call our superclass's __array_ufunc__
674             result = super().__array_ufunc__(function, method, *arrays, **kwargs)
675             # If unit is None, a plain array is expected (e.g., comparisons), which
676             # means we're done.
677             # We're also done if the result was None (for method 'at') or
678             # NotImplemented, which can happen if other inputs/outputs override
679             # __array_ufunc__; hopefully, they can then deal with us.
680             if unit is None or result is None or result is NotImplemented:
681                 return result
682 
683             return self._result_as_quantity(result, unit, out)
684 
685         except (TypeError, ValueError) as e:
686             out_normalized = kwargs.get("out", tuple())
687             inputs_and_outputs = inputs + out_normalized
688             ignored_ufunc = (
689                 None,
690                 np.ndarray.__array_ufunc__,
691                 type(self).__array_ufunc__,
692             )
693             if not all(
694                 getattr(type(io), "__array_ufunc__", None) in ignored_ufunc
695                 for io in inputs_and_outputs
696             ):
697                 return NotImplemented
698             else:
699                 raise e
700 
701     def _result_as_quantity(self, result, unit, out):
702         """Turn result into a quantity with the given unit.
703 
704         If no output is given, it will take a view of the array as a quantity,
705         and set the unit.  If output is given, those should be quantity views
706         of the result arrays, and the function will just set the unit.
707 
708         Parameters
709         ----------
710         result : ndarray or tuple thereof
711             Array(s) which need to be turned into quantity.
712         unit : `~astropy.units.Unit`
713             Unit for the quantities to be returned (or `None` if the result
714             should not be a quantity).  Should be tuple if result is a tuple.
715         out : `~astropy.units.Quantity` or None
716             Possible output quantity. Should be `None` or a tuple if result
717             is a tuple.
718 
719         Returns
720         -------
721         out : `~astropy.units.Quantity`
722            With units set.
723         """
724         if isinstance(result, (tuple, list)):
725             if out is None:
726                 out = (None,) * len(result)
727             return result.__class__(
728                 self._result_as_quantity(result_, unit_, out_)
729                 for (result_, unit_, out_) in zip(result, unit, out)
730             )
731 
732         if out is None:
733             # View the result array as a Quantity with the proper unit.
734             return (
735                 result if unit is None else self._new_view(result, unit, finalize=False)
736             )
737 
738         elif isinstance(out, Quantity):
739             # For given Quantity output, just set the unit. We know the unit
740             # is not None and the output is of the correct Quantity subclass,
741             # as it was passed through check_output.
742             # (We cannot do this unconditionally, though, since it is possible
743             # for out to be ndarray and the unit to be dimensionless.)
744             out._set_unit(unit)
745 
746         return out
747 
748     def __quantity_subclass__(self, unit):
749         """
750         Overridden by subclasses to change what kind of view is
751         created based on the output unit of an operation.
752 
753         Parameters
754         ----------
755         unit : UnitBase
756             The unit for which the appropriate class should be returned
757 
758         Returns
759         -------
760         tuple :
761             - `~astropy.units.Quantity` subclass
762             - bool: True if subclasses of the given class are ok
763         """
764         return Quantity, True
765 
766     def _new_view(self, obj=None, unit=None, finalize=True):
767         """Create a Quantity view of some array-like input, and set the unit.
768 
769         By default, return a view of ``obj`` of the same class as ``self`` and
770         with the same unit.  Subclasses can override the type of class for a
771         given unit using ``__quantity_subclass__``, and can ensure properties
772         other than the unit are copied using ``__array_finalize__``.
773 
774         If the given unit defines a ``_quantity_class`` of which ``self``
775         is not an instance, a view using this class is taken.
776 
777         Parameters
778         ----------
779         obj : ndarray or scalar, optional
780             The array to create a view of.  If obj is a numpy or python scalar,
781             it will be converted to an array scalar.  By default, ``self``
782             is converted.
783 
784         unit : unit-like, optional
785             The unit of the resulting object.  It is used to select a
786             subclass, and explicitly assigned to the view if given.
787             If not given, the subclass and unit will be that of ``self``.
788 
789         finalize : bool, optional
790             Whether to call ``__array_finalize__`` to transfer properties from
791             ``self`` to the new view of ``obj`` (e.g., ``info`` for all
792             subclasses, or ``_wrap_angle`` for `~astropy.coordinates.Latitude`).
793             Default: `True`, as appropriate for, e.g., unit conversions or slicing,
794             where the nature of the object does not change.
795 
796         Returns
797         -------
798         view : `~astropy.units.Quantity` subclass
799 
800         """
801         # Determine the unit and quantity subclass that we need for the view.
802         if unit is None:
803             unit = self.unit
804             quantity_subclass = self.__class__
805         elif unit is self.unit and self.__class__ is Quantity:
806             # The second part is because we should not presume what other
807             # classes want to do for the same unit.  E.g., Constant will
808             # always want to fall back to Quantity, and relies on going
809             # through `__quantity_subclass__`.
810             quantity_subclass = Quantity
811         else:
812             unit = Unit(unit)
813             quantity_subclass = getattr(unit, "_quantity_class", Quantity)
814             if isinstance(self, quantity_subclass):
815                 quantity_subclass, subok = self.__quantity_subclass__(unit)
816                 if subok:
817                     quantity_subclass = self.__class__
818 
819         # We only want to propagate information from ``self`` to our new view,
820         # so obj should be a regular array.  By using ``np.array``, we also
821         # convert python and numpy scalars, which cannot be viewed as arrays
822         # and thus not as Quantity either, to zero-dimensional arrays.
823         # (These are turned back into scalar in `.value`)
824         # Note that for an ndarray input, the np.array call takes only double
825         # ``obj.__class is np.ndarray``. So, not worth special-casing.
826         if obj is None:
827             obj = self.view(np.ndarray)
828         else:
829             obj = np.array(obj, copy=False, subok=True)
830 
831         # Take the view, set the unit, and update possible other properties
832         # such as ``info``, ``wrap_angle`` in `Longitude`, etc.
833         view = obj.view(quantity_subclass)
834         view._set_unit(unit)
835         if finalize:
836             view.__array_finalize__(self)
837         return view
838 
839     def _set_unit(self, unit):
840         """Set the unit.
841 
842         This is used anywhere the unit is set or modified, i.e., in the
843         initializer, in ``__imul__`` and ``__itruediv__`` for in-place
844         multiplication and division by another unit, as well as in
845         ``__array_finalize__`` for wrapping up views.  For Quantity, it just
846         sets the unit, but subclasses can override it to check that, e.g.,
847         a unit is consistent.
848         """
849         if not isinstance(unit, UnitBase):
850             if isinstance(self._unit, StructuredUnit) or isinstance(
851                 unit, StructuredUnit
852             ):
853                 unit = StructuredUnit(unit, self.dtype)
854             else:
855                 # Trying to go through a string ensures that, e.g., Magnitudes with
856                 # dimensionless physical unit become Quantity with units of mag.
857                 unit = Unit(str(unit), parse_strict="silent")
858                 if not isinstance(unit, (UnitBase, StructuredUnit)):
859                     raise UnitTypeError(
860                         f"{self.__class__.__name__} instances require normal units, "
861                         f"not {unit.__class__} instances."
862                     )
863 
864         self._unit = unit
865 
866     def __deepcopy__(self, memo):
867         # If we don't define this, ``copy.deepcopy(quantity)`` will
868         # return a bare Numpy array.
869         return self.copy()
870 
871     def __reduce__(self):
872         # patch to pickle Quantity objects (ndarray subclasses), see
873         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
874 
875         object_state = list(super().__reduce__())
876         object_state[2] = (object_state[2], self.__dict__)
877         return tuple(object_state)
878 
879     def __setstate__(self, state):
880         # patch to unpickle Quantity objects (ndarray subclasses), see
881         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
882 
883         nd_state, own_state = state
884         super().__setstate__(nd_state)
885         self.__dict__.update(own_state)
886 
887     info = QuantityInfo()
888 
889     def _to_value(self, unit, equivalencies=[]):
890         """Helper method for to and to_value."""
891         if equivalencies == []:
892             equivalencies = self._equivalencies
893         if not self.dtype.names or isinstance(self.unit, StructuredUnit):
894             # Standard path, let unit to do work.
895             return self.unit.to(
896                 unit, self.view(np.ndarray), equivalencies=equivalencies
897             )
898 
899         else:
900             # The .to() method of a simple unit cannot convert a structured
901             # dtype, so we work around it, by recursing.
902             # TODO: deprecate this?
903             # Convert simple to Structured on initialization?
904             result = np.empty_like(self.view(np.ndarray))
905             for name in self.dtype.names:
906                 result[name] = self[name]._to_value(unit, equivalencies)
907             return result
908 
909     def to(self, unit, equivalencies=[], copy=True):
910         """
911         Return a new `~astropy.units.Quantity` object with the specified unit.
912 
913         Parameters
914         ----------
915         unit : unit-like
916             An object that represents the unit to convert to. Must be
917             an `~astropy.units.UnitBase` object or a string parseable
918             by the `~astropy.units` package.
919 
920         equivalencies : list of tuple
921             A list of equivalence pairs to try if the units are not
922             directly convertible.  See :ref:`astropy:unit_equivalencies`.
923             If not provided or ``[]``, class default equivalencies will be used
924             (none for `~astropy.units.Quantity`, but may be set for subclasses)
925             If `None`, no equivalencies will be applied at all, not even any
926             set globally or within a context.
927 
928         copy : bool, optional
929             If `True` (default), then the value is copied.  Otherwise, a copy
930             will only be made if necessary.
931 
932         See Also
933         --------
934         to_value : get the numerical value in a given unit.
935         """
936         # We don't use `to_value` below since we always want to make a copy
937         # and don't want to slow down this method (esp. the scalar case).
938         unit = Unit(unit)
939         if copy:
940             # Avoid using to_value to ensure that we make a copy. We also
941             # don't want to slow down this method (esp. the scalar case).
942             value = self._to_value(unit, equivalencies)
943         else:
944             # to_value only copies if necessary
945             value = self.to_value(unit, equivalencies)
946         return self._new_view(value, unit)
947 
948     def to_value(self, unit=None, equivalencies=[]):
949         """
950         The numerical value, possibly in a different unit.
951 
952         Parameters
953         ----------
954         unit : unit-like, optional
955             The unit in which the value should be given. If not given or `None`,
956             use the current unit.
957 
958         equivalencies : list of tuple, optional
959             A list of equivalence pairs to try if the units are not directly
960             convertible (see :ref:`astropy:unit_equivalencies`). If not provided
961             or ``[]``, class default equivalencies will be used (none for
962             `~astropy.units.Quantity`, but may be set for subclasses).
963             If `None`, no equivalencies will be applied at all, not even any
964             set globally or within a context.
965 
966         Returns
967         -------
968         value : ndarray or scalar
969             The value in the units specified. For arrays, this will be a view
970             of the data if no unit conversion was necessary.
971 
972         See Also
973         --------
974         to : Get a new instance in a different unit.
975         """
976         if unit is None or unit is self.unit:
977             value = self.view(np.ndarray)
978         elif not self.dtype.names:
979             # For non-structured, we attempt a short-cut, where we just get
980             # the scale.  If that is 1, we do not have to do anything.
981             unit = Unit(unit)
982             # We want a view if the unit does not change.  One could check
983             # with "==", but that calculates the scale that we need anyway.
984             # TODO: would be better for `unit.to` to have an in-place flag.
985             try:
986                 scale = self.unit._to(unit)
987             except Exception:
988                 # Short-cut failed; try default (maybe equivalencies help).
989                 value = self._to_value(unit, equivalencies)
990             else:
991                 value = self.view(np.ndarray)
992                 if not is_effectively_unity(scale):
993                     # not in-place!
994                     value = value * scale
995         else:
996             # For structured arrays, we go the default route.
997             value = self._to_value(unit, equivalencies)
998 
999         # Index with empty tuple to decay array scalars in to numpy scalars.
1000         return value if value.shape else value[()]
1001 
1002     value = property(
1003         to_value,
1004         doc="""The numerical value of this instance.
1005 
1006     See also
1007     --------
1008     to_value : Get the numerical value in a given unit.
1009     """,
1010     )
1011 
1012     @property
1013     def unit(self):
1014         """
1015         A `~astropy.units.UnitBase` object representing the unit of this
1016         quantity.
1017         """
1018         return self._unit
1019 
1020     @property
1021     def equivalencies(self):
1022         """
1023         A list of equivalencies that will be applied by default during
1024         unit conversions.
1025         """
1026         return self._equivalencies
1027 
1028     def _recursively_apply(self, func):
1029         """Apply function recursively to every field.
1030 
1031         Returns a copy with the result.
1032         """
1033         result = np.empty_like(self)
1034         result_value = result.view(np.ndarray)
1035         result_unit = ()
1036         for name in self.dtype.names:
1037             part = func(self[name])
1038             result_value[name] = part.value
1039             result_unit += (part.unit,)
1040 
1041         result._set_unit(result_unit)
1042         return result
1043 
1044     @property
1045     def si(self):
1046         """
1047         Returns a copy of the current `Quantity` instance with SI units. The
1048         value of the resulting object will be scaled.
1049         """
1050         if self.dtype.names:
1051             return self._recursively_apply(operator.attrgetter("si"))
1052         si_unit = self.unit.si
1053         return self._new_view(self.value * si_unit.scale, si_unit / si_unit.scale)
1054 
1055     @property
1056     def cgs(self):
1057         """
1058         Returns a copy of the current `Quantity` instance with CGS units. The
1059         value of the resulting object will be scaled.
1060         """
1061         if self.dtype.names:
1062             return self._recursively_apply(operator.attrgetter("cgs"))
1063         cgs_unit = self.unit.cgs
1064         return self._new_view(self.value * cgs_unit.scale, cgs_unit / cgs_unit.scale)
1065 
1066     @property
1067     def isscalar(self):
1068         """
1069         True if the `value` of this quantity is a scalar, or False if it
1070         is an array-like object.
1071 
1072         .. note::
1073             This is subtly different from `numpy.isscalar` in that
1074             `numpy.isscalar` returns False for a zero-dimensional array
1075             (e.g. ``np.array(1)``), while this is True for quantities,
1076             since quantities cannot represent true numpy scalars.
1077         """
1078         return not self.shape
1079 
1080     # This flag controls whether convenience conversion members, such
1081     # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is
1082     # not turned on on Quantity itself, but is on some subclasses of
1083     # Quantity, such as `astropy.coordinates.Angle`.
1084     _include_easy_conversion_members = False
1085 
1086     def __dir__(self):
1087         """
1088         Quantities are able to directly convert to other units that
1089         have the same physical type.  This function is implemented in
1090         order to make autocompletion still work correctly in IPython.
1091         """
1092         if not self._include_easy_conversion_members:
1093             return super().__dir__()
1094 
1095         dir_values = set(super().__dir__())
1096         equivalencies = Unit._normalize_equivalencies(self.equivalencies)
1097         for equivalent in self.unit._get_units_with_same_physical_type(equivalencies):
1098             dir_values.update(equivalent.names)
1099         return sorted(dir_values)
1100 
1101     def __getattr__(self, attr):
1102         """
1103         Quantities are able to directly convert to other units that
1104         have the same physical type.
1105         """
1106         if not self._include_easy_conversion_members:
1107             raise AttributeError(
1108                 f"'{self.__class__.__name__}' object has no '{attr}' member"
1109             )
1110 
1111         def get_virtual_unit_attribute():
1112             registry = get_current_unit_registry().registry
1113             to_unit = registry.get(attr, None)
1114             if to_unit is None:
1115                 return None
1116 
1117             try:
1118                 return self.unit.to(
1119                     to_unit, self.value, equivalencies=self.equivalencies
1120                 )
1121             except UnitsError:
1122                 return None
1123 
1124         value = get_virtual_unit_attribute()
1125 
1126         if value is None:
1127             raise AttributeError(
1128                 f"{self.__class__.__name__} instance has no attribute '{attr}'"
1129             )
1130         else:
1131             return value
1132 
1133     # Equality needs to be handled explicitly as ndarray.__eq__ gives
1134     # DeprecationWarnings on any error, which is distracting, and does not
1135     # deal well with structured arrays (nor does the ufunc).
1136     def __eq__(self, other):
1137         try:
1138             other_value = self._to_own_unit(other)
1139         except UnitsError:
1140             return False
1141         except Exception:
1142             return NotImplemented
1143         return self.value.__eq__(other_value)
1144 
1145     def __ne__(self, other):
1146         try:
1147             other_value = self._to_own_unit(other)
1148         except UnitsError:
1149             return True
1150         except Exception:
1151             return NotImplemented
1152         return self.value.__ne__(other_value)
1153 
1154     # Unit conversion operator (<<).
1155     def __lshift__(self, other):
1156         try:
1157             other = Unit(other, parse_strict="silent")
1158         except UnitTypeError:
1159             return NotImplemented
1160 
1161         return self.__class__(self, other, copy=False, subok=True)
1162 
1163     def __ilshift__(self, other):
1164         try:
1165             other = Unit(other, parse_strict="silent")
1166         except UnitTypeError:
1167             return NotImplemented  # try other.__rlshift__(self)
1168 
1169         try:
1170             factor = self.unit._to(other)
1171         except UnitConversionError:  # incompatible, or requires an Equivalency
1172             return NotImplemented
1173         except AttributeError:  # StructuredUnit does not have `_to`
1174             # In principle, in-place might be possible.
1175             return NotImplemented
1176 
1177         view = self.view(np.ndarray)
1178         try:
1179             view *= factor  # operates on view
1180         except TypeError:
1181             # The error is `numpy.core._exceptions._UFuncOutputCastingError`,
1182             # which inherits from `TypeError`.
1183             return NotImplemented
1184 
1185         self._set_unit(other)
1186         return self
1187 
1188     def __rlshift__(self, other):
1189         if not self.isscalar:
1190             return NotImplemented
1191         return Unit(self).__rlshift__(other)
1192 
1193     # Give warning for other >> self, since probably other << self was meant.
1194     def __rrshift__(self, other):
1195         warnings.warn(
1196             ">> is not implemented. Did you mean to convert "
1197             "something to this quantity as a unit using '<<'?",
1198             AstropyWarning,
1199         )
1200         return NotImplemented
1201 
1202     # Also define __rshift__ and __irshift__ so we override default ndarray
1203     # behaviour, but instead of emitting a warning here, let it be done by
1204     # other (which likely is a unit if this was a mistake).
1205     def __rshift__(self, other):
1206         return NotImplemented
1207 
1208     def __irshift__(self, other):
1209         return NotImplemented
1210 
1211     # Arithmetic operations
1212     def __mul__(self, other):
1213         """Multiplication between `Quantity` objects and other objects."""
1214         if isinstance(other, (UnitBase, str)):
1215             try:
1216                 return self._new_view(
1217                     self.value.copy(), other * self.unit, finalize=False
1218                 )
1219             except UnitsError:  # let other try to deal with it
1220                 return NotImplemented
1221 
1222         return super().__mul__(other)
1223 
1224     def __imul__(self, other):
1225         """In-place multiplication between `Quantity` objects and others."""
1226         if isinstance(other, (UnitBase, str)):
1227             self._set_unit(other * self.unit)
1228             return self
1229 
1230         return super().__imul__(other)
1231 
1232     def __rmul__(self, other):
1233         """
1234         Right Multiplication between `Quantity` objects and other objects.
1235         """
1236         return self.__mul__(other)
1237 
1238     def __truediv__(self, other):
1239         """Division between `Quantity` objects and other objects."""
1240         if isinstance(other, (UnitBase, str)):
1241             try:
1242                 return self._new_view(
1243                     self.value.copy(), self.unit / other, finalize=False
1244                 )
1245             except UnitsError:  # let other try to deal with it
1246                 return NotImplemented
1247 
1248         return super().__truediv__(other)
1249 
1250     def __itruediv__(self, other):
1251         """Inplace division between `Quantity` objects and other objects."""
1252         if isinstance(other, (UnitBase, str)):
1253             self._set_unit(self.unit / other)
1254             return self
1255 
1256         return super().__itruediv__(other)
1257 
1258     def __rtruediv__(self, other):
1259         """Right Division between `Quantity` objects and other objects."""
1260         if isinstance(other, (UnitBase, str)):
1261             return self._new_view(1.0 / self.value, other / self.unit, finalize=False)
1262 
1263         return super().__rtruediv__(other)
1264 
1265     def __pow__(self, other):
1266         if isinstance(other, Fraction):
1267             # Avoid getting object arrays by raising the value to a Fraction.
1268             return self._new_view(
1269                 self.value ** float(other), self.unit**other, finalize=False
1270             )
1271 
1272         return super().__pow__(other)
1273 
1274     # other overrides of special functions
1275     def __hash__(self):
1276         return hash(self.value) ^ hash(self.unit)
1277 
1278     def __iter__(self):
1279         if self.isscalar:
1280             raise TypeError(
1281                 f"'{self.__class__.__name__}' object with a scalar value is not"
1282                 " iterable"
1283             )
1284 
1285         # Otherwise return a generator
1286         def quantity_iter():
1287             for val in self.value:
1288                 yield self._new_view(val)
1289 
1290         return quantity_iter()
1291 
1292     def __getitem__(self, key):
1293         if isinstance(key, str) and isinstance(self.unit, StructuredUnit):
1294             return self._new_view(
1295                 self.view(np.ndarray)[key], self.unit[key], finalize=False
1296             )
1297 
1298         try:
1299             out = super().__getitem__(key)
1300         except IndexError:
1301             # We want zero-dimensional Quantity objects to behave like scalars,
1302             # so they should raise a TypeError rather than an IndexError.
1303             if self.isscalar:
1304                 raise TypeError(
1305                     f"'{self.__class__.__name__}' object with a scalar value "
1306                     "does not support indexing"
1307                 )
1308             else:
1309                 raise
1310         # For single elements, ndarray.__getitem__ returns scalars; these
1311         # need a new view as a Quantity.
1312         if not isinstance(out, np.ndarray):
1313             out = self._new_view(out)
1314         return out
1315 
1316     def __setitem__(self, i, value):
1317         if isinstance(i, str):
1318             # Indexing will cause a different unit, so by doing this in
1319             # two steps we effectively try with the right unit.
1320             self[i][...] = value
1321             return
1322 
1323         # update indices in info if the info property has been accessed
1324         # (in which case 'info' in self.__dict__ is True; this is guaranteed
1325         # to be the case if we're part of a table).
1326         if not self.isscalar and "info" in self.__dict__:
1327             self.info.adjust_indices(i, value, len(self))
1328         self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))
1329 
1330     # __contains__ is OK
1331 
1332     def __bool__(self):
1333         """This method raises ValueError, since truthiness of quantities is ambiguous,
1334         especially for logarithmic units and temperatures. Use explicit comparisons.
1335         """
1336         raise ValueError(
1337             f"{type(self).__name__} truthiness is ambiguous, especially for logarithmic units"
1338             " and temperatures. Use explicit comparisons."
1339         )
1340 
1341     def __len__(self):
1342         if self.isscalar:
1343             raise TypeError(
1344                 f"'{self.__class__.__name__}' object with a scalar value has no len()"
1345             )
1346         else:
1347             return len(self.value)
1348 
1349     # Numerical types
1350     def __float__(self):
1351         try:
1352             return float(self.to_value(dimensionless_unscaled))
1353         except (UnitsError, TypeError):
1354             raise TypeError(
1355                 "only dimensionless scalar quantities can be "
1356                 "converted to Python scalars"
1357             )
1358 
1359     def __int__(self):
1360         try:
1361             return int(self.to_value(dimensionless_unscaled))
1362         except (UnitsError, TypeError):
1363             raise TypeError(
1364                 "only dimensionless scalar quantities can be "
1365                 "converted to Python scalars"
1366             )
1367 
1368     def __index__(self):
1369         # for indices, we do not want to mess around with scaling at all,
1370         # so unlike for float, int, we insist here on unscaled dimensionless
1371         try:
1372             assert self.unit.is_unity()
1373             return self.value.__index__()
1374         except Exception:
1375             raise TypeError(
1376                 "only integer dimensionless scalar quantities "
1377                 "can be converted to a Python index"
1378             )
1379 
1380     # TODO: we may want to add a hook for dimensionless quantities?
1381     @property
1382     def _unitstr(self):
1383         if self.unit is None:
1384             unitstr = _UNIT_NOT_INITIALISED
1385         else:
1386             unitstr = str(self.unit)
1387 
1388         if unitstr:
1389             unitstr = " " + unitstr
1390 
1391         return unitstr
1392 
1393     def to_string(self, unit=None, precision=None, format=None, subfmt=None):
1394         """
1395         Generate a string representation of the quantity and its unit.
1396 
1397         The behavior of this function can be altered via the
1398         `numpy.set_printoptions` function and its various keywords.  The
1399         exception to this is the ``threshold`` keyword, which is controlled via
1400         the ``[units.quantity]`` configuration item ``latex_array_threshold``.
1401         This is treated separately because the numpy default of 1000 is too big
1402         for most browsers to handle.
1403 
1404         Parameters
1405         ----------
1406         unit : unit-like, optional
1407             Specifies the unit.  If not provided,
1408             the unit used to initialize the quantity will be used.
1409 
1410         precision : number, optional
1411             The level of decimal precision. If `None`, or not provided,
1412             it will be determined from NumPy print options.
1413 
1414         format : str, optional
1415             The format of the result. If not provided, an unadorned
1416             string is returned. Supported values are:
1417 
1418             - 'latex': Return a LaTeX-formatted string
1419 
1420             - 'latex_inline': Return a LaTeX-formatted string that uses
1421               negative exponents instead of fractions
1422 
1423         subfmt : str, optional
1424             Subformat of the result. For the moment, only used for
1425             ``format='latex'`` and ``format='latex_inline'``. Supported
1426             values are:
1427 
1428             - 'inline': Use ``$ ... $`` as delimiters.
1429 
1430             - 'display': Use ``$\\displaystyle ... $`` as delimiters.
1431 
1432         Returns
1433         -------
1434         str
1435             A string with the contents of this Quantity
1436         """
1437         if unit is not None and unit != self.unit:
1438             return self.to(unit).to_string(
1439                 unit=None, precision=precision, format=format, subfmt=subfmt
1440             )
1441 
1442         formats = {
1443             None: None,
1444             "latex": {
1445                 None: ("$", "$"),
1446                 "inline": ("$", "$"),
1447                 "display": (r"$\displaystyle ", r"$"),
1448             },
1449         }
1450         formats["latex_inline"] = formats["latex"]
1451 
1452         if format not in formats:
1453             raise ValueError(f"Unknown format '{format}'")
1454         elif format is None:
1455             if precision is None:
1456                 # Use default formatting settings
1457                 return f"{self.value}{self._unitstr:s}"
1458             else:
1459                 # np.array2string properly formats arrays as well as scalars
1460                 return (
1461                     np.array2string(self.value, precision=precision, floatmode="fixed")
1462                     + self._unitstr
1463                 )
1464 
1465         # else, for the moment we assume format="latex" or "latex_inline".
1466 
1467         # Set the precision if set, otherwise use numpy default
1468         pops = np.get_printoptions()
1469         format_spec = f".{precision if precision is not None else pops['precision']}g"
1470 
1471         def float_formatter(value):
1472             return Latex.format_exponential_notation(value, format_spec=format_spec)
1473 
1474         def complex_formatter(value):
1475             return "({}{}i)".format(
1476                 Latex.format_exponential_notation(value.real, format_spec=format_spec),
1477                 Latex.format_exponential_notation(
1478                     value.imag, format_spec="+" + format_spec
1479                 ),
1480             )
1481 
1482         # The view is needed for the scalar case - self.value might be float.
1483         latex_value = np.array2string(
1484             self.view(np.ndarray),
1485             threshold=(
1486                 conf.latex_array_threshold
1487                 if conf.latex_array_threshold > -1
1488                 else pops["threshold"]
1489             ),
1490             formatter={
1491                 "float_kind": float_formatter,
1492                 "complex_kind": complex_formatter,
1493             },
1494             max_line_width=np.inf,
1495             separator=",~",
1496         )
1497 
1498         latex_value = latex_value.replace("...", r"\dots")
1499 
1500         # Format unit
1501         # [1:-1] strips the '$' on either side needed for math mode
1502         if self.unit is None:
1503             latex_unit = _UNIT_NOT_INITIALISED
1504         elif format == "latex":
1505             latex_unit = self.unit._repr_latex_()[1:-1]  # note this is unicode
1506         elif format == "latex_inline":
1507             latex_unit = self.unit.to_string(format="latex_inline")[1:-1]
1508 
1509         delimiter_left, delimiter_right = formats[format][subfmt]
1510 
1511         return rf"{delimiter_left}{latex_value} \; {latex_unit}{delimiter_right}"
1512 
1513     def __str__(self):
1514         return self.to_string()
1515 
1516     def __repr__(self):
1517         prefixstr = "<" + self.__class__.__name__ + " "
1518         arrstr = np.array2string(
1519             self.view(np.ndarray), separator=", ", prefix=prefixstr
1520         )
1521         return f"{prefixstr}{arrstr}{self._unitstr:s}>"
1522 
1523     def _repr_latex_(self):
1524         """
1525         Generate a latex representation of the quantity and its unit.
1526 
1527         Returns
1528         -------
1529         lstr
1530             A LaTeX string with the contents of this Quantity
1531         """
1532         # NOTE: This should change to display format in a future release
1533         return self.to_string(format="latex", subfmt="inline")
1534 
1535     def __format__(self, format_spec):
1536         try:
1537             return self.to_string(format=format_spec)
1538         except ValueError:
1539             # We might have a unit format not implemented in `to_string()`.
1540             if format_spec in Base.registry:
1541                 if self.unit is dimensionless_unscaled:
1542                     return f"{self.value}"
1543                 else:
1544                     return f"{self.value} {format(self.unit, format_spec)}"
1545             # Can the value be formatted on its own?
1546             try:
1547                 return f"{format(self.value, format_spec)}{self._unitstr:s}"
1548             except ValueError:
1549                 # Format the whole thing as a single string.
1550                 return format(f"{self.value}{self._unitstr:s}", format_spec)
1551 
1552     def decompose(self, bases=[]):
1553         """
1554         Generates a new `Quantity` with the units
1555         decomposed. Decomposed units have only irreducible units in
1556         them (see `astropy.units.UnitBase.decompose`).
1557 
1558         Parameters
1559         ----------
1560         bases : sequence of `~astropy.units.UnitBase`, optional
1561             The bases to decompose into.  When not provided,
1562             decomposes down to any irreducible units.  When provided,
1563             the decomposed result will only contain the given units.
1564             This will raises a `~astropy.units.UnitsError` if it's not possible
1565             to do so.
1566 
1567         Returns
1568         -------
1569         newq : `~astropy.units.Quantity`
1570             A new object equal to this quantity with units decomposed.
1571         """
1572         return self._decompose(False, bases=bases)
1573 
1574     def _decompose(self, allowscaledunits=False, bases=[]):
1575         """
1576         Generates a new `Quantity` with the units decomposed. Decomposed
1577         units have only irreducible units in them (see
1578         `astropy.units.UnitBase.decompose`).
1579 
1580         Parameters
1581         ----------
1582         allowscaledunits : bool
1583             If True, the resulting `Quantity` may have a scale factor
1584             associated with it.  If False, any scaling in the unit will
1585             be subsumed into the value of the resulting `Quantity`
1586 
1587         bases : sequence of UnitBase, optional
1588             The bases to decompose into.  When not provided,
1589             decomposes down to any irreducible units.  When provided,
1590             the decomposed result will only contain the given units.
1591             This will raises a `~astropy.units.UnitsError` if it's not possible
1592             to do so.
1593 
1594         Returns
1595         -------
1596         newq : `~astropy.units.Quantity`
1597             A new object equal to this quantity with units decomposed.
1598 
1599         """
1600         new_unit = self.unit.decompose(bases=bases)
1601 
1602         # Be careful here because self.value usually is a view of self;
1603         # be sure that the original value is not being modified.
1604         if not allowscaledunits and hasattr(new_unit, "scale"):
1605             new_value = self.value * new_unit.scale
1606             new_unit = new_unit / new_unit.scale
1607             return self._new_view(new_value, new_unit)
1608         else:
1609             return self._new_view(self.copy(), new_unit)
1610 
1611     # These functions need to be overridden to take into account the units
1612     # Array conversion
1613     # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion
1614 
1615     def item(self, *args):
1616         """Copy an element of an array to a scalar Quantity and return it.
1617 
1618         Like :meth:`~numpy.ndarray.item` except that it always
1619         returns a `Quantity`, not a Python scalar.
1620 
1621         """
1622         return self._new_view(super().item(*args))
1623 
1624     def tolist(self):
1625         raise NotImplementedError(
1626             "cannot make a list of Quantities. Get list of values with"
1627             " q.value.tolist()."
1628         )
1629 
1630     def _to_own_unit(self, value, check_precision=True, *, unit=None):
1631         """Convert value to one's own unit (or that given).
1632 
1633         Here, non-quantities are treated as dimensionless, and care is taken
1634         for values of 0, infinity or nan, which are allowed to have any unit.
1635 
1636         Parameters
1637         ----------
1638         value : anything convertible to `~astropy.units.Quantity`
1639             The value to be converted to the requested unit.
1640         check_precision : bool
1641             Whether to forbid conversion of float to integer if that changes
1642             the input number.  Default: `True`.
1643         unit : `~astropy.units.Unit` or None
1644             The unit to convert to.  By default, the unit of ``self``.
1645 
1646         Returns
1647         -------
1648         value : number or `~numpy.ndarray`
1649             In the requested units.
1650 
1651         """
1652         if unit is None:
1653             unit = self.unit
1654         try:
1655             _value = value.to_value(unit)
1656         except AttributeError:
1657             # We're not a Quantity.
1658             # First remove two special cases (with a fast test):
1659             # 1) Maybe masked printing? MaskedArray with quantities does not
1660             # work very well, but no reason to break even repr and str.
1661             # 2) np.ma.masked? useful if we're a MaskedQuantity.
1662             if value is np.ma.masked or (
1663                 value is np.ma.masked_print_option and self.dtype.kind == "O"
1664             ):
1665                 return value
1666             # Now, let's try a more general conversion.
1667             # Plain arrays will be converted to dimensionless in the process,
1668             # but anything with a unit attribute will use that.
1669             try:
1670                 as_quantity = Quantity(value)
1671                 _value = as_quantity.to_value(unit)
1672             except UnitsError:
1673                 # last chance: if this was not something with a unit
1674                 # and is all 0, inf, or nan, we treat it as arbitrary unit.
1675                 if not hasattr(value, "unit") and can_have_arbitrary_unit(
1676                     as_quantity.value
1677                 ):
1678                     _value = as_quantity.value
1679                 else:
1680                     raise
1681 
1682         if self.dtype.kind == "i" and check_precision:
1683             # If, e.g., we are casting float to int, we want to fail if
1684             # precision is lost, but let things pass if it works.
1685             _value = np.array(_value, copy=False, subok=True)
1686             if not np.can_cast(_value.dtype, self.dtype):
1687                 self_dtype_array = np.array(_value, self.dtype, subok=True)
1688                 if not np.all((self_dtype_array == _value) | np.isnan(_value)):
1689                     raise TypeError(
1690                         "cannot convert value type to array type without precision loss"
1691                     )
1692 
1693         # Setting names to ensure things like equality work (note that
1694         # above will have failed already if units did not match).
1695         if self.dtype.names:
1696             _value.dtype.names = self.dtype.names
1697         return _value
1698 
1699     def itemset(self, *args):
1700         if len(args) == 0:
1701             raise ValueError("itemset must have at least one argument")
1702 
1703         self.view(np.ndarray).itemset(*(args[:-1] + (self._to_own_unit(args[-1]),)))
1704 
1705     def tostring(self, order="C"):
1706         """Not implemented, use ``.value.tostring()`` instead."""
1707         raise NotImplementedError(
1708             "cannot write Quantities to string.  Write array with"
1709             " q.value.tostring(...)."
1710         )
1711 
1712     def tobytes(self, order="C"):
1713         """Not implemented, use ``.value.tobytes()`` instead."""
1714         raise NotImplementedError(
1715             "cannot write Quantities to bytes.  Write array with q.value.tobytes(...)."
1716         )
1717 
1718     def tofile(self, fid, sep="", format="%s"):
1719         """Not implemented, use ``.value.tofile()`` instead."""
1720         raise NotImplementedError(
1721             "cannot write Quantities to file.  Write array with q.value.tofile(...)"
1722         )
1723 
1724     def dump(self, file):
1725         """Not implemented, use ``.value.dump()`` instead."""
1726         raise NotImplementedError(
1727             "cannot dump Quantities to file.  Write array with q.value.dump()"
1728         )
1729 
1730     def dumps(self):
1731         """Not implemented, use ``.value.dumps()`` instead."""
1732         raise NotImplementedError(
1733             "cannot dump Quantities to string.  Write array with q.value.dumps()"
1734         )
1735 
1736     # astype, byteswap, copy, view, getfield, setflags OK as is
1737 
1738     def fill(self, value):
1739         self.view(np.ndarray).fill(self._to_own_unit(value))
1740 
1741     # Shape manipulation: resize cannot be done (does not own data), but
1742     # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only
1743     # the flat iterator needs to be overwritten, otherwise single items are
1744     # returned as numbers.
1745     @property
1746     def flat(self):
1747         """A 1-D iterator over the Quantity array.
1748 
1749         This returns a ``QuantityIterator`` instance, which behaves the same
1750         as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,
1751         and is similar to, but not a subclass of, Python's built-in iterator
1752         object.
1753         """
1754         return QuantityIterator(self)
1755 
1756     @flat.setter
1757     def flat(self, value):
1758         y = self.ravel()
1759         y[:] = value
1760 
1761     # Item selection and manipulation
1762     # repeat, sort, compress, diagonal OK
1763     def take(self, indices, axis=None, out=None, mode="raise"):
1764         out = super().take(indices, axis=axis, out=out, mode=mode)
1765         # For single elements, ndarray.take returns scalars; these
1766         # need a new view as a Quantity.
1767         if type(out) is not type(self):
1768             out = self._new_view(out)
1769         return out
1770 
1771     def put(self, indices, values, mode="raise"):
1772         self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)
1773 
1774     def choose(self, choices, out=None, mode="raise"):
1775         raise NotImplementedError(
1776             "cannot choose based on quantity.  Choose using array with"
1777             " q.value.choose(...)"
1778         )
1779 
1780     # ensure we do not return indices as quantities
1781     def argsort(self, axis=-1, kind="quicksort", order=None):
1782         return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)
1783 
1784     def searchsorted(self, v, *args, **kwargs):
1785         return np.searchsorted(
1786             np.array(self), self._to_own_unit(v, check_precision=False), *args, **kwargs
1787         )  # avoid numpy 1.6 problem
1788 
1789     if NUMPY_LT_1_22:
1790 
1791         def argmax(self, axis=None, out=None):
1792             return self.view(np.ndarray).argmax(axis, out=out)
1793 
1794         def argmin(self, axis=None, out=None):
1795             return self.view(np.ndarray).argmin(axis, out=out)
1796 
1797     else:
1798 
1799         def argmax(self, axis=None, out=None, *, keepdims=False):
1800             return self.view(np.ndarray).argmax(axis=axis, out=out, keepdims=keepdims)
1801 
1802         def argmin(self, axis=None, out=None, *, keepdims=False):
1803             return self.view(np.ndarray).argmin(axis=axis, out=out, keepdims=keepdims)
1804 
1805     def __array_function__(self, function, types, args, kwargs):
1806         """Wrap numpy functions, taking care of units.
1807 
1808         Parameters
1809         ----------
1810         function : callable
1811             Numpy function to wrap
1812         types : iterable of classes
1813             Classes that provide an ``__array_function__`` override. Can
1814             in principle be used to interact with other classes. Below,
1815             mostly passed on to `~numpy.ndarray`, which can only interact
1816             with subclasses.
1817         args : tuple
1818             Positional arguments provided in the function call.
1819         kwargs : dict
1820             Keyword arguments provided in the function call.
1821 
1822         Returns
1823         -------
1824         result: `~astropy.units.Quantity`, `~numpy.ndarray`
1825             As appropriate for the function.  If the function is not
1826             supported, `NotImplemented` is returned, which will lead to
1827             a `TypeError` unless another argument overrode the function.
1828 
1829         Raises
1830         ------
1831         ~astropy.units.UnitsError
1832             If operands have incompatible units.
1833         """
1834         # A function should be in one of the following sets or dicts:
1835         # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation
1836         #    supports Quantity; we pass on to ndarray.__array_function__.
1837         # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable
1838         #    after converting quantities to arrays with suitable units,
1839         #    and possibly setting units on the result.
1840         # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but
1841         #    requires a Quantity-specific implementation.
1842         # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.
1843         # For now, since we may not yet have complete coverage, if a
1844         # function is in none of the above, we simply call the numpy
1845         # implementation.
1846         if function in SUBCLASS_SAFE_FUNCTIONS:
1847             return super().__array_function__(function, types, args, kwargs)
1848 
1849         elif function in FUNCTION_HELPERS:
1850             function_helper = FUNCTION_HELPERS[function]
1851             try:
1852                 args, kwargs, unit, out = function_helper(*args, **kwargs)
1853             except NotImplementedError:
1854                 return self._not_implemented_or_raise(function, types)
1855 
1856             result = super().__array_function__(function, types, args, kwargs)
1857             # Fall through to return section
1858 
1859         elif function in DISPATCHED_FUNCTIONS:
1860             dispatched_function = DISPATCHED_FUNCTIONS[function]
1861             try:
1862                 result, unit, out = dispatched_function(*args, **kwargs)
1863             except NotImplementedError:
1864                 return self._not_implemented_or_raise(function, types)
1865 
1866             # Fall through to return section
1867 
1868         elif function in UNSUPPORTED_FUNCTIONS:
1869             return NotImplemented
1870 
1871         else:
1872             warnings.warn(
1873                 f"function '{function.__name__}' is not known to astropy's Quantity."
1874                 " Will run it anyway, hoping it will treat ndarray subclasses"
1875                 " correctly. Please raise an issue at"
1876                 " https://github.com/astropy/astropy/issues.",
1877                 AstropyWarning,
1878             )
1879             return super().__array_function__(function, types, args, kwargs)
1880 
1881         # If unit is None, a plain array is expected (e.g., boolean), which
1882         # means we're done.
1883         # We're also done if the result was NotImplemented, which can happen
1884         # if other inputs/outputs override __array_function__;
1885         # hopefully, they can then deal with us.
1886         if unit is None or result is NotImplemented:
1887             return result
1888 
1889         return self._result_as_quantity(result, unit, out=out)
1890 
1891     def _not_implemented_or_raise(self, function, types):
1892         # Our function helper or dispatcher found that the function does not
1893         # work with Quantity.  In principle, there may be another class that
1894         # knows what to do with us, for which we should return NotImplemented.
1895         # But if there is ndarray (or a non-Quantity subclass of it) around,
1896         # it quite likely coerces, so we should just break.
1897         if any(
1898             issubclass(t, np.ndarray) and not issubclass(t, Quantity) for t in types
1899         ):
1900             raise TypeError(
1901                 f"the Quantity implementation cannot handle {function} "
1902                 "with the given arguments."
1903             ) from None
1904         else:
1905             return NotImplemented
1906 
1907     # Calculation -- override ndarray methods to take into account units.
1908     # We use the corresponding numpy functions to evaluate the results, since
1909     # the methods do not always allow calling with keyword arguments.
1910     # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives
1911     # TypeError: 'a_max' is an invalid keyword argument for this function.
1912     def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):
1913         """Wrap a numpy function that processes self, returning a Quantity.
1914 
1915         Parameters
1916         ----------
1917         function : callable
1918             Numpy function to wrap.
1919         args : positional arguments
1920             Any positional arguments to the function beyond the first argument
1921             (which will be set to ``self``).
1922         kwargs : keyword arguments
1923             Keyword arguments to the function.
1924 
1925         If present, the following arguments are treated specially:
1926 
1927         unit : `~astropy.units.Unit`
1928             Unit of the output result.  If not given, the unit of ``self``.
1929         out : `~astropy.units.Quantity`
1930             A Quantity instance in which to store the output.
1931 
1932         Notes
1933         -----
1934         Output should always be assigned via a keyword argument, otherwise
1935         no proper account of the unit is taken.
1936 
1937         Returns
1938         -------
1939         out : `~astropy.units.Quantity`
1940             Result of the function call, with the unit set properly.
1941         """
1942         if unit is None:
1943             unit = self.unit
1944         # Ensure we don't loop back by turning any Quantity into array views.
1945         args = (self.value,) + tuple(
1946             (arg.value if isinstance(arg, Quantity) else arg) for arg in args
1947         )
1948         if out is not None:
1949             # If pre-allocated output is used, check it is suitable.
1950             # This also returns array view, to ensure we don't loop back.
1951             arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))
1952             kwargs["out"] = check_output(out, unit, arrays, function=function)
1953         # Apply the function and turn it back into a Quantity.
1954         result = function(*args, **kwargs)
1955         return self._result_as_quantity(result, unit, out)
1956 
1957     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
1958         return self._wrap_function(np.trace, offset, axis1, axis2, dtype, out=out)
1959 
1960     def var(
1961         self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True
1962     ):
1963         return self._wrap_function(
1964             np.var,
1965             axis,
1966             dtype,
1967             out=out,
1968             ddof=ddof,
1969             keepdims=keepdims,
1970             where=where,
1971             unit=self.unit**2,
1972         )
1973 
1974     def std(
1975         self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True
1976     ):
1977         return self._wrap_function(
1978             np.std, axis, dtype, out=out, ddof=ddof, keepdims=keepdims, where=where
1979         )
1980 
1981     def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
1982         return self._wrap_function(
1983             np.mean, axis, dtype, out=out, keepdims=keepdims, where=where
1984         )
1985 
1986     def round(self, decimals=0, out=None):
1987         return self._wrap_function(np.round, decimals, out=out)
1988 
1989     def dot(self, b, out=None):
1990         result_unit = self.unit * getattr(b, "unit", dimensionless_unscaled)
1991         return self._wrap_function(np.dot, b, out=out, unit=result_unit)
1992 
1993     # Calculation: override methods that do not make sense.
1994 
1995     def all(self, axis=None, out=None):
1996         raise TypeError(
1997             "cannot evaluate truth value of quantities. "
1998             "Evaluate array with q.value.all(...)"
1999         )
2000 
2001     def any(self, axis=None, out=None):
2002         raise TypeError(
2003             "cannot evaluate truth value of quantities. "
2004             "Evaluate array with q.value.any(...)"
2005         )
2006 
2007     # Calculation: numpy functions that can be overridden with methods.
2008 
2009     def diff(self, n=1, axis=-1):
2010         return self._wrap_function(np.diff, n, axis)
2011 
2012     def ediff1d(self, to_end=None, to_begin=None):
2013         return self._wrap_function(np.ediff1d, to_end, to_begin)
2014 
2015     if NUMPY_LT_1_22:
2016 
2017         @deprecated("5.3", alternative="np.nansum", obj_type="method")
2018         def nansum(self, axis=None, out=None, keepdims=False):
2019             return self._wrap_function(np.nansum, axis, out=out, keepdims=keepdims)
2020 
2021     else:
2022 
2023         @deprecated("5.3", alternative="np.nansum", obj_type="method")
2024         def nansum(
2025             self, axis=None, out=None, keepdims=False, *, initial=None, where=True
2026         ):
2027             if initial is not None:
2028                 initial = self._to_own_unit(initial)
2029             return self._wrap_function(
2030                 np.nansum,
2031                 axis,
2032                 out=out,
2033                 keepdims=keepdims,
2034                 initial=initial,
2035                 where=where,
2036             )
2037 
2038     def insert(self, obj, values, axis=None):
2039         """
2040         Insert values along the given axis before the given indices and return
2041         a new `~astropy.units.Quantity` object.
2042 
2043         This is a thin wrapper around the `numpy.insert` function.
2044 
2045         Parameters
2046         ----------
2047         obj : int, slice or sequence of int
2048             Object that defines the index or indices before which ``values`` is
2049             inserted.
2050         values : array-like
2051             Values to insert.  If the type of ``values`` is different
2052             from that of quantity, ``values`` is converted to the matching type.
2053             ``values`` should be shaped so that it can be broadcast appropriately
2054             The unit of ``values`` must be consistent with this quantity.
2055         axis : int, optional
2056             Axis along which to insert ``values``.  If ``axis`` is None then
2057             the quantity array is flattened before insertion.
2058 
2059         Returns
2060         -------
2061         out : `~astropy.units.Quantity`
2062             A copy of quantity with ``values`` inserted.  Note that the
2063             insertion does not occur in-place: a new quantity array is returned.
2064 
2065         Examples
2066         --------
2067         >>> import astropy.units as u
2068         >>> q = [1, 2] * u.m
2069         >>> q.insert(0, 50 * u.cm)
2070         <Quantity [ 0.5,  1.,  2.] m>
2071 
2072         >>> q = [[1, 2], [3, 4]] * u.m
2073         >>> q.insert(1, [10, 20] * u.m, axis=0)
2074         <Quantity [[  1.,  2.],
2075                    [ 10., 20.],
2076                    [  3.,  4.]] m>
2077 
2078         >>> q.insert(1, 10 * u.m, axis=1)
2079         <Quantity [[  1., 10.,  2.],
2080                    [  3., 10.,  4.]] m>
2081 
2082         """
2083         out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)
2084         return self._new_view(out_array)
2085 
2086 
2087 class SpecificTypeQuantity(Quantity):
2088     """Superclass for Quantities of specific physical type.
2089 
2090     Subclasses of these work just like :class:`~astropy.units.Quantity`, except
2091     that they are for specific physical types (and may have methods that are
2092     only appropriate for that type).  Astropy examples are
2093     :class:`~astropy.coordinates.Angle` and
2094     :class:`~astropy.coordinates.Distance`
2095 
2096     At a minimum, subclasses should set ``_equivalent_unit`` to the unit
2097     associated with the physical type.
2098     """
2099 
2100     # The unit for the specific physical type.  Instances can only be created
2101     # with units that are equivalent to this.
2102     _equivalent_unit = None
2103 
2104     # The default unit used for views.  Even with `None`, views of arrays
2105     # without units are possible, but will have an uninitialized unit.
2106     _unit = None
2107 
2108     # Default unit for initialization through the constructor.
2109     _default_unit = None
2110 
2111     # ensure that we get precedence over our superclass.
2112     __array_priority__ = Quantity.__array_priority__ + 10
2113 
2114     def __quantity_subclass__(self, unit):
2115         if unit.is_equivalent(self._equivalent_unit):
2116             return type(self), True
2117         else:
2118             return super().__quantity_subclass__(unit)[0], False
2119 
2120     def _set_unit(self, unit):
2121         if unit is None or not unit.is_equivalent(self._equivalent_unit):
2122             raise UnitTypeError(
2123                 "{} instances require units equivalent to '{}'".format(
2124                     type(self).__name__, self._equivalent_unit
2125                 )
2126                 + (
2127                     ", but no unit was given."
2128                     if unit is None
2129                     else f", so cannot set it to '{unit}'."
2130                 )
2131             )
2132 
2133         super()._set_unit(unit)
2134 
2135 
2136 def isclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs):
2137     """
2138     Return a boolean array where two arrays are element-wise equal
2139     within a tolerance.
2140 
2141     Parameters
2142     ----------
2143     a, b : array-like or `~astropy.units.Quantity`
2144         Input values or arrays to compare
2145     rtol : array-like or `~astropy.units.Quantity`
2146         The relative tolerance for the comparison, which defaults to
2147         ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,
2148         then it must be dimensionless.
2149     atol : number or `~astropy.units.Quantity`
2150         The absolute tolerance for the comparison.  The units (or lack
2151         thereof) of ``a``, ``b``, and ``atol`` must be consistent with
2152         each other.  If `None`, ``atol`` defaults to zero in the
2153         appropriate units.
2154     equal_nan : `bool`
2155         Whether to compare NaNs as equal. If `True`, NaNs in ``a`` will
2156         be considered equal to NaNs in ``b``.
2157 
2158     Notes
2159     -----
2160     This is a :class:`~astropy.units.Quantity`-aware version of
2161     :func:`numpy.isclose`. However, this differs from the `numpy` function in
2162     that the default for the absolute tolerance here is zero instead of
2163     ``atol=1e-8`` in `numpy`, as there is no natural way to set a default
2164     *absolute* tolerance given two inputs that may have differently scaled
2165     units.
2166 
2167     Raises
2168     ------
2169     `~astropy.units.UnitsError`
2170         If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,
2171         or if ``rtol`` is not dimensionless.
2172 
2173     See Also
2174     --------
2175     allclose
2176     """
2177     unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)
2178     return np.isclose(*unquantified_args, equal_nan=equal_nan, **kwargs)
2179 
2180 
2181 def allclose(a, b, rtol=1.0e-5, atol=None, equal_nan=False, **kwargs) -> bool:
2182     """
2183     Whether two arrays are element-wise equal within a tolerance.
2184 
2185     Parameters
2186     ----------
2187     a, b : array-like or `~astropy.units.Quantity`
2188         Input values or arrays to compare
2189     rtol : array-like or `~astropy.units.Quantity`
2190         The relative tolerance for the comparison, which defaults to
2191         ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,
2192         then it must be dimensionless.
2193     atol : number or `~astropy.units.Quantity`
2194         The absolute tolerance for the comparison.  The units (or lack
2195         thereof) of ``a``, ``b``, and ``atol`` must be consistent with
2196         each other.  If `None`, ``atol`` defaults to zero in the
2197         appropriate units.
2198     equal_nan : `bool`
2199         Whether to compare NaNs as equal. If `True`, NaNs in ``a`` will
2200         be considered equal to NaNs in ``b``.
2201 
2202     Notes
2203     -----
2204     This is a :class:`~astropy.units.Quantity`-aware version of
2205     :func:`numpy.allclose`. However, this differs from the `numpy` function in
2206     that the default for the absolute tolerance here is zero instead of
2207     ``atol=1e-8`` in `numpy`, as there is no natural way to set a default
2208     *absolute* tolerance given two inputs that may have differently scaled
2209     units.
2210 
2211     Raises
2212     ------
2213     `~astropy.units.UnitsError`
2214         If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,
2215         or if ``rtol`` is not dimensionless.
2216 
2217     See Also
2218     --------
2219     isclose
2220     """
2221     unquantified_args = _unquantify_allclose_arguments(a, b, rtol, atol)
2222     return np.allclose(*unquantified_args, equal_nan=equal_nan, **kwargs)
2223 
2224 
2225 def _unquantify_allclose_arguments(actual, desired, rtol, atol):
2226     actual = Quantity(actual, subok=True, copy=False)
2227 
2228     desired = Quantity(desired, subok=True, copy=False)
2229     try:
2230         desired = desired.to(actual.unit)
2231     except UnitsError:
2232         raise UnitsError(
2233             f"Units for 'desired' ({desired.unit}) and 'actual' "
2234             f"({actual.unit}) are not convertible"
2235         )
2236 
2237     if atol is None:
2238         # By default, we assume an absolute tolerance of zero in the
2239         # appropriate units.  The default value of None for atol is
2240         # needed because the units of atol must be consistent with the
2241         # units for a and b.
2242         atol = Quantity(0)
2243     else:
2244         atol = Quantity(atol, subok=True, copy=False)
2245         try:
2246             atol = atol.to(actual.unit)
2247         except UnitsError:
2248             raise UnitsError(
2249                 f"Units for 'atol' ({atol.unit}) and 'actual' "
2250                 f"({actual.unit}) are not convertible"
2251             )
2252 
2253     rtol = Quantity(rtol, subok=True, copy=False)
2254     try:
2255         rtol = rtol.to(dimensionless_unscaled)
2256     except Exception:
2257         raise UnitsError("'rtol' should be dimensionless")
2258 
2259     return actual.value, desired.value, rtol.value, atol.value

</code><intended_behavior>The implementation should carefully handle how decomposed units are formatted as strings, ensuring no unintended spaces are introduced in the process. This might involve checking the decompose implementation for where it interacts with string formatting and ensuring consistency in representation, especially in unicode format.</intended_behavior>]
2025-10-17 22:18:51.702 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 22:18:51.702 | INFO     | Search-only: skipping patch selection
2025-10-17 22:18:51.861 | INFO     | Task astropy__astropy-14413 completed successfully.
2025-10-17 22:18:51.862 | INFO     | No patch generated. You can try running ACR again.
