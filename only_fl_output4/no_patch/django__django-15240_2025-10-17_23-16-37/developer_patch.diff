diff --git a/django/core/management/commands/migrate.py b/django/core/management/commands/migrate.py
--- a/django/core/management/commands/migrate.py
+++ b/django/core/management/commands/migrate.py
@@ -67,6 +67,10 @@ def add_arguments(self, parser):
             '--check', action='store_true', dest='check_unapplied',
             help='Exits with a non-zero status if unapplied migrations exist.',
         )
+        parser.add_argument(
+            '--prune', action='store_true', dest='prune',
+            help='Delete nonexistent migrations from the django_migrations table.',
+        )
 
     @no_translations
     def handle(self, *args, **options):
@@ -156,6 +160,52 @@ def handle(self, *args, **options):
         else:
             targets = executor.loader.graph.leaf_nodes()
 
+        if options['prune']:
+            if not options['app_label']:
+                raise CommandError(
+                    'Migrations can be pruned only when an app is specified.'
+                )
+            if self.verbosity > 0:
+                self.stdout.write('Pruning migrations:', self.style.MIGRATE_HEADING)
+            to_prune = set(executor.loader.applied_migrations) - set(executor.loader.disk_migrations)
+            squashed_migrations_with_deleted_replaced_migrations = [
+                migration_key
+                for migration_key, migration_obj in executor.loader.replacements.items()
+                if any(replaced in to_prune for replaced in migration_obj.replaces)
+            ]
+            if squashed_migrations_with_deleted_replaced_migrations:
+                self.stdout.write(self.style.NOTICE(
+                    "  Cannot use --prune because the following squashed "
+                    "migrations have their 'replaces' attributes and may not "
+                    "be recorded as applied:"
+                ))
+                for migration in squashed_migrations_with_deleted_replaced_migrations:
+                    app, name = migration
+                    self.stdout.write(f'    {app}.{name}')
+                self.stdout.write(self.style.NOTICE(
+                    "  Re-run 'manage.py migrate' if they are not marked as "
+                    "applied, and remove 'replaces' attributes in their "
+                    "Migration classes."
+                ))
+            else:
+                to_prune = sorted(
+                    migration
+                    for migration in to_prune
+                    if migration[0] == app_label
+                )
+                if to_prune:
+                    for migration in to_prune:
+                        app, name = migration
+                        if self.verbosity > 0:
+                            self.stdout.write(self.style.MIGRATE_LABEL(
+                                f'  Pruning {app}.{name}'
+                            ), ending='')
+                        executor.recorder.record_unapplied(app, name)
+                        if self.verbosity > 0:
+                            self.stdout.write(self.style.SUCCESS(' OK'))
+                elif self.verbosity > 0:
+                    self.stdout.write('  No migrations to prune.')
+
         plan = executor.migration_plan(targets)
         exit_dry = plan and options['check_unapplied']
 
@@ -174,6 +224,8 @@ def handle(self, *args, **options):
             return
         if exit_dry:
             sys.exit(1)
+        if options['prune']:
+            return
 
         # At this point, ignore run_syncdb if there aren't any apps to sync.
         run_syncdb = options['run_syncdb'] and executor.loader.unmigrated_apps
