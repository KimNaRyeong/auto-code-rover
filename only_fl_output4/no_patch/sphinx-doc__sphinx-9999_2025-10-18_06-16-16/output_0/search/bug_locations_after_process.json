[
    {
        "rel_file_path": "sphinx/writers/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/writers/latex.py",
        "start": 1,
        "end": 2052,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.writers.latex\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Custom docutils writer for LaTeX.\n6 \n7     Much of this code is adapted from Dave Kuhlman's \"docpy\" writer from his\n8     docutils sandbox.\n9 \n10     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n11     :license: BSD, see LICENSE for details.\n12 \"\"\"\n13 \n14 import re\n15 import warnings\n16 from collections import defaultdict\n17 from os import path\n18 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast\n19 \n20 from docutils import nodes, writers\n21 from docutils.nodes import Element, Node, Text\n22 \n23 from sphinx import addnodes, highlighting\n24 from sphinx.deprecation import RemovedInSphinx70Warning\n25 from sphinx.domains import IndexEntry\n26 from sphinx.domains.std import StandardDomain\n27 from sphinx.errors import SphinxError\n28 from sphinx.locale import _, __, admonitionlabels\n29 from sphinx.util import logging, split_into, texescape\n30 from sphinx.util.docutils import SphinxTranslator\n31 from sphinx.util.nodes import clean_astext, get_prev_node\n32 from sphinx.util.template import LaTeXRenderer\n33 from sphinx.util.texescape import tex_replace_map\n34 \n35 try:\n36     from docutils.utils.roman import toRoman\n37 except ImportError:\n38     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman\n39     from roman import toRoman  # type: ignore\n40 \n41 if TYPE_CHECKING:\n42     from sphinx.builders.latex import LaTeXBuilder\n43     from sphinx.builders.latex.theming import Theme\n44 \n45 \n46 logger = logging.getLogger(__name__)\n47 \n48 MAX_CITATION_LABEL_LENGTH = 8\n49 LATEXSECTIONNAMES = [\"part\", \"chapter\", \"section\", \"subsection\",\n50                      \"subsubsection\", \"paragraph\", \"subparagraph\"]\n51 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\\arabic',\n52                                    {\n53                                        'arabic': r'\\arabic',\n54                                        'loweralpha': r'\\alph',\n55                                        'upperalpha': r'\\Alph',\n56                                        'lowerroman': r'\\roman',\n57                                        'upperroman': r'\\Roman',\n58                                    })\n59 \n60 CR = '\\n'\n61 BLANKLINE = '\\n\\n'\n62 EXTRA_RE = re.compile(r'^(.*\\S)\\s+\\(([^()]*)\\)\\s*$')\n63 \n64 \n65 class collected_footnote(nodes.footnote):\n66     \"\"\"Footnotes that are collected are assigned this class.\"\"\"\n67 \n68 \n69 class UnsupportedError(SphinxError):\n70     category = 'Markup is unsupported in LaTeX'\n71 \n72 \n73 class LaTeXWriter(writers.Writer):\n74 \n75     supported = ('sphinxlatex',)\n76 \n77     settings_spec = ('LaTeX writer options', '', (\n78         ('Document name', ['--docname'], {'default': ''}),\n79         ('Document class', ['--docclass'], {'default': 'manual'}),\n80         ('Author', ['--author'], {'default': ''}),\n81     ))\n82     settings_defaults: Dict = {}\n83 \n84     output = None\n85 \n86     def __init__(self, builder: \"LaTeXBuilder\") -> None:\n87         super().__init__()\n88         self.builder = builder\n89         self.theme: Theme = None\n90 \n91     def translate(self) -> None:\n92         visitor = self.builder.create_translator(self.document, self.builder, self.theme)\n93         self.document.walkabout(visitor)\n94         self.output = cast(LaTeXTranslator, visitor).astext()\n95 \n96 \n97 # Helper classes\n98 \n99 class Table:\n100     \"\"\"A table data\"\"\"\n101 \n102     def __init__(self, node: Element) -> None:\n103         self.header: List[str] = []\n104         self.body: List[str] = []\n105         self.align = node.get('align', 'default')\n106         self.classes: List[str] = node.get('classes', [])\n107         self.colcount = 0\n108         self.colspec: str = None\n109         self.colwidths: List[int] = []\n110         self.has_problematic = False\n111         self.has_oldproblematic = False\n112         self.has_verbatim = False\n113         self.caption: List[str] = None\n114         self.stubs: List[int] = []\n115 \n116         # current position\n117         self.col = 0\n118         self.row = 0\n119 \n120         # A dict mapping a table location to a cell_id (cell = rectangular area)\n121         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)\n122         self.cell_id = 0  # last assigned cell_id\n123 \n124     def is_longtable(self) -> bool:\n125         \"\"\"True if and only if table uses longtable environment.\"\"\"\n126         return self.row > 30 or 'longtable' in self.classes\n127 \n128     def get_table_type(self) -> str:\n129         \"\"\"Returns the LaTeX environment name for the table.\n130 \n131         The class currently supports:\n132 \n133         * longtable\n134         * tabular\n135         * tabulary\n136         \"\"\"\n137         if self.is_longtable():\n138             return 'longtable'\n139         elif self.has_verbatim:\n140             return 'tabular'\n141         elif self.colspec:\n142             return 'tabulary'\n143         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):\n144             return 'tabular'\n145         else:\n146             return 'tabulary'\n147 \n148     def get_colspec(self) -> str:\n149         \"\"\"Returns a column spec of table.\n150 \n151         This is what LaTeX calls the 'preamble argument' of the used table environment.\n152 \n153         .. note:: the ``\\\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.\n154         \"\"\"\n155         if self.colspec:\n156             return self.colspec\n157         elif self.colwidths and 'colwidths-given' in self.classes:\n158             total = sum(self.colwidths)\n159             colspecs = [r'\\X{%d}{%d}' % (width, total) for width in self.colwidths]\n160             return '{|%s|}' % '|'.join(colspecs) + CR\n161         elif self.has_problematic:\n162             return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n163         elif self.get_table_type() == 'tabulary':\n164             # sphinx.sty sets T to be J by default.\n165             return '{|' + ('T|' * self.colcount) + '}' + CR\n166         elif self.has_oldproblematic:\n167             return r'{|*{%d}{\\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR\n168         else:\n169             return '{|' + ('l|' * self.colcount) + '}' + CR\n170 \n171     def add_cell(self, height: int, width: int) -> None:\n172         \"\"\"Adds a new cell to a table.\n173 \n174         It will be located at current position: (``self.row``, ``self.col``).\n175         \"\"\"\n176         self.cell_id += 1\n177         for col in range(width):\n178             for row in range(height):\n179                 assert self.cells[(self.row + row, self.col + col)] == 0\n180                 self.cells[(self.row + row, self.col + col)] = self.cell_id\n181 \n182     def cell(self, row: int = None, col: int = None) -> \"TableCell\":\n183         \"\"\"Returns a cell object (i.e. rectangular area) containing given position.\n184 \n185         If no option arguments: ``row`` or ``col`` are given, the current position;\n186         ``self.row`` and ``self.col`` are used to get a cell object by default.\n187         \"\"\"\n188         try:\n189             if row is None:\n190                 row = self.row\n191             if col is None:\n192                 col = self.col\n193             return TableCell(self, row, col)\n194         except IndexError:\n195             return None\n196 \n197 \n198 class TableCell:\n199     \"\"\"Data of a cell in a table.\"\"\"\n200 \n201     def __init__(self, table: Table, row: int, col: int) -> None:\n202         if table.cells[(row, col)] == 0:\n203             raise IndexError\n204 \n205         self.table = table\n206         self.cell_id = table.cells[(row, col)]\n207         self.row = row\n208         self.col = col\n209 \n210         # adjust position for multirow/multicol cell\n211         while table.cells[(self.row - 1, self.col)] == self.cell_id:\n212             self.row -= 1\n213         while table.cells[(self.row, self.col - 1)] == self.cell_id:\n214             self.col -= 1\n215 \n216     @property\n217     def width(self) -> int:\n218         \"\"\"Returns the cell width.\"\"\"\n219         width = 0\n220         while self.table.cells[(self.row, self.col + width)] == self.cell_id:\n221             width += 1\n222         return width\n223 \n224     @property\n225     def height(self) -> int:\n226         \"\"\"Returns the cell height.\"\"\"\n227         height = 0\n228         while self.table.cells[(self.row + height, self.col)] == self.cell_id:\n229             height += 1\n230         return height\n231 \n232 \n233 def escape_abbr(text: str) -> str:\n234     \"\"\"Adjust spacing after abbreviations.\"\"\"\n235     return re.sub(r'\\.(?=\\s|$)', r'.\\@', text)\n236 \n237 \n238 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:\n239     \"\"\"Convert `width_str` with rst length to LaTeX length.\"\"\"\n240     match = re.match(r'^(\\d*\\.?\\d*)\\s*(\\S*)$', width_str)\n241     if not match:\n242         raise ValueError\n243     res = width_str\n244     amount, unit = match.groups()[:2]\n245     if scale == 100:\n246         float(amount)  # validate amount is float\n247         if unit in ('', \"px\"):\n248             res = r\"%s\\sphinxpxdimen\" % amount\n249         elif unit == 'pt':\n250             res = '%sbp' % amount  # convert to 'bp'\n251         elif unit == \"%\":\n252             res = r\"%.3f\\linewidth\" % (float(amount) / 100.0)\n253     else:\n254         amount_float = float(amount) * scale / 100.0\n255         if unit in ('', \"px\"):\n256             res = r\"%.5f\\sphinxpxdimen\" % amount_float\n257         elif unit == 'pt':\n258             res = '%.5fbp' % amount_float\n259         elif unit == \"%\":\n260             res = r\"%.5f\\linewidth\" % (amount_float / 100.0)\n261         else:\n262             res = \"%.5f%s\" % (amount_float, unit)\n263     return res\n264 \n265 \n266 class LaTeXTranslator(SphinxTranslator):\n267     builder: \"LaTeXBuilder\" = None\n268 \n269     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls\n270     # default is originally 3. For book/report, 2 is already LaTeX default.\n271     ignore_missing_images = False\n272 \n273     def __init__(self, document: nodes.document, builder: \"LaTeXBuilder\",\n274                  theme: \"Theme\") -> None:\n275         super().__init__(document, builder)\n276         self.body: List[str] = []\n277         self.theme = theme\n278 \n279         # flags\n280         self.in_title = 0\n281         self.in_production_list = 0\n282         self.in_footnote = 0\n283         self.in_caption = 0\n284         self.in_term = 0\n285         self.needs_linetrimming = 0\n286         self.in_minipage = 0\n287         self.no_latex_floats = 0\n288         self.first_document = 1\n289         self.this_is_the_title = 1\n290         self.literal_whitespace = 0\n291         self.in_parsed_literal = 0\n292         self.compact_list = 0\n293         self.first_param = 0\n294 \n295         sphinxpkgoptions = []\n296 \n297         # sort out some elements\n298         self.elements = self.builder.context.copy()\n299 \n300         # initial section names\n301         self.sectionnames = LATEXSECTIONNAMES[:]\n302         if self.theme.toplevel_sectioning == 'section':\n303             self.sectionnames.remove('chapter')\n304 \n305         # determine top section level\n306         self.top_sectionlevel = 1\n307         if self.config.latex_toplevel_sectioning:\n308             try:\n309                 self.top_sectionlevel = \\\n310                     self.sectionnames.index(self.config.latex_toplevel_sectioning)\n311             except ValueError:\n312                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %\n313                                (self.config.latex_toplevel_sectioning, self.theme.docclass))\n314 \n315         if self.config.numfig:\n316             self.numfig_secnum_depth = self.config.numfig_secnum_depth\n317             if self.numfig_secnum_depth > 0:  # default is 1\n318                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in\n319                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...\n320                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n321                    self.top_sectionlevel > 0:\n322                     self.numfig_secnum_depth += self.top_sectionlevel\n323                 else:\n324                     self.numfig_secnum_depth += self.top_sectionlevel - 1\n325                 # this (minus one) will serve as minimum to LaTeX's secnumdepth\n326                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,\n327                                                len(LATEXSECTIONNAMES) - 1)\n328                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty\n329                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)\n330             else:\n331                 sphinxpkgoptions.append('nonumfigreset')\n332 \n333         if self.config.numfig and self.config.math_numfig:\n334             sphinxpkgoptions.append('mathnumfig')\n335 \n336         if (self.config.language not in {None, 'en', 'ja'} and\n337                 'fncychap' not in self.config.latex_elements):\n338             # use Sonny style if any language specified (except English)\n339             self.elements['fncychap'] = (r'\\usepackage[Sonny]{fncychap}' + CR +\n340                                          r'\\ChNameVar{\\Large\\normalfont\\sffamily}' + CR +\n341                                          r'\\ChTitleVar{\\Large\\normalfont\\sffamily}')\n342 \n343         self.babel = self.builder.babel\n344         if self.config.language and not self.babel.is_supported_language():\n345             # emit warning if specified language is invalid\n346             # (only emitting, nothing changed to processing)\n347             logger.warning(__('no Babel option known for language %r'),\n348                            self.config.language)\n349 \n350         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto\n351         if self.document.get('tocdepth'):\n352             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel\n353             #   tocdepth = -1: show only parts\n354             #   tocdepth =  0: show parts and chapters\n355             #   tocdepth =  1: show parts, chapters and sections\n356             #   tocdepth =  2: show parts, chapters, sections and subsections\n357             #   ...\n358             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2\n359             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \\\n360                self.top_sectionlevel > 0:\n361                 tocdepth += 1  # because top_sectionlevel is shifted by -1\n362             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph\n363                 logger.warning(__('too large :maxdepth:, ignored.'))\n364                 tocdepth = len(LATEXSECTIONNAMES) - 2\n365 \n366             self.elements['tocdepth'] = r'\\setcounter{tocdepth}{%d}' % tocdepth\n367             minsecnumdepth = max(minsecnumdepth, tocdepth)\n368 \n369         if self.config.numfig and (self.config.numfig_secnum_depth > 0):\n370             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)\n371 \n372         if minsecnumdepth > self.secnumdepth:\n373             self.elements['secnumdepth'] = r'\\setcounter{secnumdepth}{%d}' %\\\n374                                            minsecnumdepth\n375 \n376         contentsname = document.get('contentsname')\n377         if contentsname:\n378             self.elements['contentsname'] = self.babel_renewcommand(r'\\contentsname',\n379                                                                     contentsname)\n380 \n381         if self.elements['maxlistdepth']:\n382             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])\n383         if sphinxpkgoptions:\n384             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)\n385         if self.elements['sphinxsetup']:\n386             self.elements['sphinxsetup'] = (r'\\sphinxsetup{%s}' % self.elements['sphinxsetup'])\n387         if self.elements['extraclassoptions']:\n388             self.elements['classoptions'] += ',' + \\\n389                                              self.elements['extraclassoptions']\n390 \n391         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,\n392                                                        latex_engine=self.config.latex_engine)\n393         self.context: List[Any] = []\n394         self.descstack: List[str] = []\n395         self.tables: List[Table] = []\n396         self.next_table_colspec: str = None\n397         self.bodystack: List[List[str]] = []\n398         self.footnote_restricted: Element = None\n399         self.pending_footnotes: List[nodes.footnote_reference] = []\n400         self.curfilestack: List[str] = []\n401         self.handled_abbrs: Set[str] = set()\n402 \n403     def pushbody(self, newbody: List[str]) -> None:\n404         self.bodystack.append(self.body)\n405         self.body = newbody\n406 \n407     def popbody(self) -> List[str]:\n408         body = self.body\n409         self.body = self.bodystack.pop()\n410         return body\n411 \n412     def astext(self) -> str:\n413         self.elements.update({\n414             'body': ''.join(self.body),\n415             'indices': self.generate_indices()\n416         })\n417         return self.render('latex.tex_t', self.elements)\n418 \n419     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:\n420         if withdoc:\n421             id = self.curfilestack[-1] + ':' + id\n422         return (r'\\phantomsection' if anchor else '') + r'\\label{%s}' % self.idescape(id)\n423 \n424     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:\n425         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])\n426         if anchor:\n427             return r'\\phantomsection' + labels\n428         else:\n429             return labels\n430 \n431     def hyperlink(self, id: str) -> str:\n432         return r'{\\hyperref[%s]{' % self.idescape(id)\n433 \n434     def hyperpageref(self, id: str) -> str:\n435         return r'\\autopageref*{%s}' % self.idescape(id)\n436 \n437     def escape(self, s: str) -> str:\n438         return texescape.escape(s, self.config.latex_engine)\n439 \n440     def idescape(self, id: str) -> str:\n441         return r'\\detokenize{%s}' % str(id).translate(tex_replace_map).\\\n442             encode('ascii', 'backslashreplace').decode('ascii').\\\n443             replace('\\\\', '_')\n444 \n445     def babel_renewcommand(self, command: str, definition: str) -> str:\n446         if self.elements['multilingual']:\n447             prefix = r'\\addto\\captions%s{' % self.babel.get_language()\n448             suffix = '}'\n449         else:  # babel is disabled (mainly for Japanese environment)\n450             prefix = ''\n451             suffix = ''\n452 \n453         return r'%s\\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR\n454 \n455     def generate_indices(self) -> str:\n456         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:\n457             ret.append(r'\\begin{sphinxtheindex}' + CR)\n458             ret.append(r'\\let\\bigletter\\sphinxstyleindexlettergroup' + CR)\n459             for i, (letter, entries) in enumerate(content):\n460                 if i > 0:\n461                     ret.append(r'\\indexspace' + CR)\n462                 ret.append(r'\\bigletter{%s}' % self.escape(letter) + CR)\n463                 for entry in entries:\n464                     if not entry[3]:\n465                         continue\n466                     ret.append(r'\\item\\relax\\sphinxstyleindexentry{%s}' %\n467                                self.encode(entry[0]))\n468                     if entry[4]:\n469                         # add \"extra\" info\n470                         ret.append(r'\\sphinxstyleindexextra{%s}' % self.encode(entry[4]))\n471                     ret.append(r'\\sphinxstyleindexpageref{%s:%s}' %\n472                                (entry[2], self.idescape(entry[3])) + CR)\n473             ret.append(r'\\end{sphinxtheindex}' + CR)\n474 \n475         ret = []\n476         # latex_domain_indices can be False/True or a list of index names\n477         indices_config = self.config.latex_domain_indices\n478         if indices_config:\n479             for domain in self.builder.env.domains.values():\n480                 for indexcls in domain.indices:\n481                     indexname = '%s-%s' % (domain.name, indexcls.name)\n482                     if isinstance(indices_config, list):\n483                         if indexname not in indices_config:\n484                             continue\n485                     content, collapsed = indexcls(domain).generate(\n486                         self.builder.docnames)\n487                     if not content:\n488                         continue\n489                     ret.append(r'\\renewcommand{\\indexname}{%s}' % indexcls.localname + CR)\n490                     generate(content, collapsed)\n491 \n492         return ''.join(ret)\n493 \n494     def render(self, template_name: str, variables: Dict) -> str:\n495         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)\n496         for template_dir in self.config.templates_path:\n497             template = path.join(self.builder.confdir, template_dir,\n498                                  template_name)\n499             if path.exists(template):\n500                 return renderer.render(template, variables)\n501 \n502         return renderer.render(template_name, variables)\n503 \n504     @property\n505     def table(self) -> Table:\n506         \"\"\"Get current table.\"\"\"\n507         if self.tables:\n508             return self.tables[-1]\n509         else:\n510             return None\n511 \n512     def visit_document(self, node: Element) -> None:\n513         self.curfilestack.append(node.get('docname', ''))\n514         if self.first_document == 1:\n515             # the first document is all the regular content ...\n516             self.first_document = 0\n517         elif self.first_document == 0:\n518             # ... and all others are the appendices\n519             self.body.append(CR + r'\\appendix' + CR)\n520             self.first_document = -1\n521         if 'docname' in node:\n522             self.body.append(self.hypertarget(':doc'))\n523         # \"- 1\" because the level is increased before the title is visited\n524         self.sectionlevel = self.top_sectionlevel - 1\n525 \n526     def depart_document(self, node: Element) -> None:\n527         pass\n528 \n529     def visit_start_of_file(self, node: Element) -> None:\n530         self.curfilestack.append(node['docname'])\n531 \n532     def depart_start_of_file(self, node: Element) -> None:\n533         self.curfilestack.pop()\n534 \n535     def visit_section(self, node: Element) -> None:\n536         if not self.this_is_the_title:\n537             self.sectionlevel += 1\n538         self.body.append(BLANKLINE)\n539 \n540     def depart_section(self, node: Element) -> None:\n541         self.sectionlevel = max(self.sectionlevel - 1,\n542                                 self.top_sectionlevel - 1)\n543 \n544     def visit_problematic(self, node: Element) -> None:\n545         self.body.append(r'{\\color{red}\\bfseries{}')\n546 \n547     def depart_problematic(self, node: Element) -> None:\n548         self.body.append('}')\n549 \n550     def visit_topic(self, node: Element) -> None:\n551         self.in_minipage = 1\n552         self.body.append(CR + r'\\begin{sphinxShadowBox}' + CR)\n553 \n554     def depart_topic(self, node: Element) -> None:\n555         self.in_minipage = 0\n556         self.body.append(r'\\end{sphinxShadowBox}' + CR)\n557     visit_sidebar = visit_topic\n558     depart_sidebar = depart_topic\n559 \n560     def visit_glossary(self, node: Element) -> None:\n561         pass\n562 \n563     def depart_glossary(self, node: Element) -> None:\n564         pass\n565 \n566     def visit_productionlist(self, node: Element) -> None:\n567         self.body.append(BLANKLINE)\n568         self.body.append(r'\\begin{productionlist}' + CR)\n569         self.in_production_list = 1\n570 \n571     def depart_productionlist(self, node: Element) -> None:\n572         self.body.append(r'\\end{productionlist}' + BLANKLINE)\n573         self.in_production_list = 0\n574 \n575     def visit_production(self, node: Element) -> None:\n576         if node['tokenname']:\n577             tn = node['tokenname']\n578             self.body.append(self.hypertarget('grammar-token-' + tn))\n579             self.body.append(r'\\production{%s}{' % self.encode(tn))\n580         else:\n581             self.body.append(r'\\productioncont{')\n582 \n583     def depart_production(self, node: Element) -> None:\n584         self.body.append('}' + CR)\n585 \n586     def visit_transition(self, node: Element) -> None:\n587         self.body.append(self.elements['transition'])\n588 \n589     def depart_transition(self, node: Element) -> None:\n590         pass\n591 \n592     def visit_title(self, node: Element) -> None:\n593         parent = node.parent\n594         if isinstance(parent, addnodes.seealso):\n595             # the environment already handles this\n596             raise nodes.SkipNode\n597         elif isinstance(parent, nodes.section):\n598             if self.this_is_the_title:\n599                 if len(node.children) != 1 and not isinstance(node.children[0],\n600                                                               nodes.Text):\n601                     logger.warning(__('document title is not a single Text node'),\n602                                    location=node)\n603                 if not self.elements['title']:\n604                     # text needs to be escaped since it is inserted into\n605                     # the output literally\n606                     self.elements['title'] = self.escape(node.astext())\n607                 self.this_is_the_title = 0\n608                 raise nodes.SkipNode\n609             else:\n610                 short = ''\n611                 if list(node.traverse(nodes.image)):\n612                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))\n613 \n614                 try:\n615                     self.body.append(r'\\%s%s{' % (self.sectionnames[self.sectionlevel], short))\n616                 except IndexError:\n617                     # just use \"subparagraph\", it's not numbered anyway\n618                     self.body.append(r'\\%s%s{' % (self.sectionnames[-1], short))\n619                 self.context.append('}' + CR + self.hypertarget_to(node.parent))\n620         elif isinstance(parent, nodes.topic):\n621             self.body.append(r'\\sphinxstyletopictitle{')\n622             self.context.append('}' + CR)\n623         elif isinstance(parent, nodes.sidebar):\n624             self.body.append(r'\\sphinxstylesidebartitle{')\n625             self.context.append('}' + CR)\n626         elif isinstance(parent, nodes.Admonition):\n627             self.body.append('{')\n628             self.context.append('}' + CR)\n629         elif isinstance(parent, nodes.table):\n630             # Redirect body output until title is finished.\n631             self.pushbody([])\n632         else:\n633             logger.warning(__('encountered title node not in section, topic, table, '\n634                               'admonition or sidebar'),\n635                            location=node)\n636             self.body.append(r'\\sphinxstyleothertitle{')\n637             self.context.append('}' + CR)\n638         self.in_title = 1\n639 \n640     def depart_title(self, node: Element) -> None:\n641         self.in_title = 0\n642         if isinstance(node.parent, nodes.table):\n643             self.table.caption = self.popbody()\n644         else:\n645             self.body.append(self.context.pop())\n646 \n647     def visit_subtitle(self, node: Element) -> None:\n648         if isinstance(node.parent, nodes.sidebar):\n649             self.body.append(r'\\sphinxstylesidebarsubtitle{')\n650             self.context.append('}' + CR)\n651         else:\n652             self.context.append('')\n653 \n654     def depart_subtitle(self, node: Element) -> None:\n655         self.body.append(self.context.pop())\n656 \n657     #############################################################\n658     # Domain-specific object descriptions\n659     #############################################################\n660 \n661     # Top-level nodes for descriptions\n662     ##################################\n663 \n664     def visit_desc(self, node: Element) -> None:\n665         if self.config.latex_show_urls == 'footnote':\n666             self.body.append(BLANKLINE)\n667             self.body.append(r'\\begin{savenotes}\\begin{fulllineitems}' + CR)\n668         else:\n669             self.body.append(BLANKLINE)\n670             self.body.append(r'\\begin{fulllineitems}' + CR)\n671         if self.table:\n672             self.table.has_problematic = True\n673 \n674     def depart_desc(self, node: Element) -> None:\n675         if self.config.latex_show_urls == 'footnote':\n676             self.body.append(CR + r'\\end{fulllineitems}\\end{savenotes}' + BLANKLINE)\n677         else:\n678             self.body.append(CR + r'\\end{fulllineitems}' + BLANKLINE)\n679 \n680     def _visit_signature_line(self, node: Element) -> None:\n681         for child in node:\n682             if isinstance(child, addnodes.desc_parameterlist):\n683                 self.body.append(r'\\pysiglinewithargsret{')\n684                 break\n685         else:\n686             self.body.append(r'\\pysigline{')\n687 \n688     def _depart_signature_line(self, node: Element) -> None:\n689         self.body.append('}')\n690 \n691     def visit_desc_signature(self, node: Element) -> None:\n692         if node.parent['objtype'] != 'describe' and node['ids']:\n693             hyper = self.hypertarget(node['ids'][0])\n694         else:\n695             hyper = ''\n696         self.body.append(hyper)\n697         if not node.get('is_multiline'):\n698             self._visit_signature_line(node)\n699         else:\n700             self.body.append('%' + CR)\n701             self.body.append(r'\\pysigstartmultiline' + CR)\n702 \n703     def depart_desc_signature(self, node: Element) -> None:\n704         if not node.get('is_multiline'):\n705             self._depart_signature_line(node)\n706         else:\n707             self.body.append('%' + CR)\n708             self.body.append(r'\\pysigstopmultiline')\n709 \n710     def visit_desc_signature_line(self, node: Element) -> None:\n711         self._visit_signature_line(node)\n712 \n713     def depart_desc_signature_line(self, node: Element) -> None:\n714         self._depart_signature_line(node)\n715 \n716     def visit_desc_content(self, node: Element) -> None:\n717         pass\n718 \n719     def depart_desc_content(self, node: Element) -> None:\n720         pass\n721 \n722     def visit_desc_inline(self, node: Element) -> None:\n723         self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n724 \n725     def depart_desc_inline(self, node: Element) -> None:\n726         self.body.append('}}')\n727 \n728     # Nodes for high-level structure in signatures\n729     ##############################################\n730 \n731     def visit_desc_name(self, node: Element) -> None:\n732         self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n733         self.literal_whitespace += 1\n734 \n735     def depart_desc_name(self, node: Element) -> None:\n736         self.body.append('}}')\n737         self.literal_whitespace -= 1\n738 \n739     def visit_desc_addname(self, node: Element) -> None:\n740         self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n741         self.literal_whitespace += 1\n742 \n743     def depart_desc_addname(self, node: Element) -> None:\n744         self.body.append('}}')\n745         self.literal_whitespace -= 1\n746 \n747     def visit_desc_type(self, node: Element) -> None:\n748         pass\n749 \n750     def depart_desc_type(self, node: Element) -> None:\n751         pass\n752 \n753     def visit_desc_returns(self, node: Element) -> None:\n754         self.body.append(r'{ $\\rightarrow$ ')\n755 \n756     def depart_desc_returns(self, node: Element) -> None:\n757         self.body.append(r'}')\n758 \n759     def visit_desc_parameterlist(self, node: Element) -> None:\n760         # close name, open parameterlist\n761         self.body.append('}{')\n762         self.first_param = 1\n763 \n764     def depart_desc_parameterlist(self, node: Element) -> None:\n765         # close parameterlist, open return annotation\n766         self.body.append('}{')\n767 \n768     def visit_desc_parameter(self, node: Element) -> None:\n769         if not self.first_param:\n770             self.body.append(', ')\n771         else:\n772             self.first_param = 0\n773         if not node.hasattr('noemph'):\n774             self.body.append(r'\\emph{')\n775 \n776     def depart_desc_parameter(self, node: Element) -> None:\n777         if not node.hasattr('noemph'):\n778             self.body.append('}')\n779 \n780     def visit_desc_optional(self, node: Element) -> None:\n781         self.body.append(r'\\sphinxoptional{')\n782 \n783     def depart_desc_optional(self, node: Element) -> None:\n784         self.body.append('}')\n785 \n786     def visit_desc_annotation(self, node: Element) -> None:\n787         self.body.append(r'\\sphinxbfcode{\\sphinxupquote{')\n788 \n789     def depart_desc_annotation(self, node: Element) -> None:\n790         self.body.append('}}')\n791 \n792     ##############################################\n793 \n794     def visit_seealso(self, node: Element) -> None:\n795         self.body.append(BLANKLINE)\n796         self.body.append(r'\\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)\n797         self.body.append(r'\\nopagebreak' + BLANKLINE)\n798 \n799     def depart_seealso(self, node: Element) -> None:\n800         self.body.append(BLANKLINE)\n801 \n802     def visit_rubric(self, node: Element) -> None:\n803         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):\n804             raise nodes.SkipNode\n805         self.body.append(r'\\subsubsection*{')\n806         self.context.append('}' + CR)\n807         self.in_title = 1\n808 \n809     def depart_rubric(self, node: Element) -> None:\n810         self.in_title = 0\n811         self.body.append(self.context.pop())\n812 \n813     def visit_footnote(self, node: Element) -> None:\n814         self.in_footnote += 1\n815         label = cast(nodes.label, node[0])\n816         if 'auto' not in node:\n817             self.body.append(r'\\sphinxstepexplicit ')\n818         if self.in_parsed_literal:\n819             self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n820         else:\n821             self.body.append('%' + CR)\n822             self.body.append(r'\\begin{footnote}[%s]' % label.astext())\n823         if 'auto' not in node:\n824             self.body.append(r'\\phantomsection'\n825                              r'\\label{\\thesphinxscope.%s}%%' % label.astext() + CR)\n826         self.body.append(r'\\sphinxAtStartFootnote' + CR)\n827 \n828     def depart_footnote(self, node: Element) -> None:\n829         if self.in_parsed_literal:\n830             self.body.append(r'\\end{footnote}')\n831         else:\n832             self.body.append('%' + CR)\n833             self.body.append(r'\\end{footnote}')\n834         self.in_footnote -= 1\n835 \n836     def visit_label(self, node: Element) -> None:\n837         raise nodes.SkipNode\n838 \n839     def visit_tabular_col_spec(self, node: Element) -> None:\n840         self.next_table_colspec = node['spec']\n841         raise nodes.SkipNode\n842 \n843     def visit_table(self, node: Element) -> None:\n844         if len(self.tables) == 1:\n845             if self.table.get_table_type() == 'longtable':\n846                 raise UnsupportedError(\n847                     '%s:%s: longtable does not support nesting a table.' %\n848                     (self.curfilestack[-1], node.line or ''))\n849             else:\n850                 # change type of parent table to tabular\n851                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ\n852                 self.table.has_problematic = True\n853         elif len(self.tables) > 2:\n854             raise UnsupportedError(\n855                 '%s:%s: deeply nested tables are not implemented.' %\n856                 (self.curfilestack[-1], node.line or ''))\n857 \n858         self.tables.append(Table(node))\n859         if self.next_table_colspec:\n860             self.table.colspec = '{%s}' % self.next_table_colspec + CR\n861             if 'colwidths-given' in node.get('classes', []):\n862                 logger.info(__('both tabularcolumns and :widths: option are given. '\n863                                ':widths: is ignored.'), location=node)\n864         self.next_table_colspec = None\n865 \n866     def depart_table(self, node: Element) -> None:\n867         labels = self.hypertarget_to(node)\n868         table_type = self.table.get_table_type()\n869         table = self.render(table_type + '.tex_t',\n870                             dict(table=self.table, labels=labels))\n871         self.body.append(BLANKLINE)\n872         self.body.append(table)\n873         self.body.append(CR)\n874 \n875         self.tables.pop()\n876 \n877     def visit_colspec(self, node: Element) -> None:\n878         self.table.colcount += 1\n879         if 'colwidth' in node:\n880             self.table.colwidths.append(node['colwidth'])\n881         if 'stub' in node:\n882             self.table.stubs.append(self.table.colcount - 1)\n883 \n884     def depart_colspec(self, node: Element) -> None:\n885         pass\n886 \n887     def visit_tgroup(self, node: Element) -> None:\n888         pass\n889 \n890     def depart_tgroup(self, node: Element) -> None:\n891         pass\n892 \n893     def visit_thead(self, node: Element) -> None:\n894         # Redirect head output until header is finished.\n895         self.pushbody(self.table.header)\n896 \n897     def depart_thead(self, node: Element) -> None:\n898         self.popbody()\n899 \n900     def visit_tbody(self, node: Element) -> None:\n901         # Redirect body output until table is finished.\n902         self.pushbody(self.table.body)\n903 \n904     def depart_tbody(self, node: Element) -> None:\n905         self.popbody()\n906 \n907     def visit_row(self, node: Element) -> None:\n908         self.table.col = 0\n909 \n910         # fill columns if the row starts with the bottom of multirow cell\n911         while True:\n912             cell = self.table.cell(self.table.row, self.table.col)\n913             if cell is None:  # not a bottom of multirow cell\n914                 break\n915             else:  # a bottom of multirow cell\n916                 self.table.col += cell.width\n917                 if cell.col:\n918                     self.body.append('&')\n919                 if cell.width == 1:\n920                     # insert suitable strut for equalizing row heights in given multirow\n921                     self.body.append(r'\\sphinxtablestrut{%d}' % cell.cell_id)\n922                 else:  # use \\multicolumn for wide multirow cell\n923                     self.body.append(r'\\multicolumn{%d}{|l|}{\\sphinxtablestrut{%d}}' %\n924                                      (cell.width, cell.cell_id))\n925 \n926     def depart_row(self, node: Element) -> None:\n927         self.body.append(r'\\\\' + CR)\n928         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]\n929         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]\n930         if all(underlined):\n931             self.body.append(r'\\hline')\n932         else:\n933             i = 0\n934             underlined.extend([False])  # sentinel\n935             while i < len(underlined):\n936                 if underlined[i] is True:\n937                     j = underlined[i:].index(False)\n938                     self.body.append(r'\\cline{%d-%d}' % (i + 1, i + j))\n939                     i += j\n940                 i += 1\n941         self.table.row += 1\n942 \n943     def visit_entry(self, node: Element) -> None:\n944         if self.table.col > 0:\n945             self.body.append('&')\n946         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)\n947         cell = self.table.cell()\n948         context = ''\n949         if cell.width > 1:\n950             if self.config.latex_use_latex_multicolumn:\n951                 if self.table.col == 0:\n952                     self.body.append(r'\\multicolumn{%d}{|l|}{%%' % cell.width + CR)\n953                 else:\n954                     self.body.append(r'\\multicolumn{%d}{l|}{%%' % cell.width + CR)\n955                 context = '}%' + CR\n956             else:\n957                 self.body.append(r'\\sphinxstartmulticolumn{%d}%%' % cell.width + CR)\n958                 context = r'\\sphinxstopmulticolumn' + CR\n959         if cell.height > 1:\n960             # \\sphinxmultirow 2nd arg \"cell_id\" will serve as id for LaTeX macros as well\n961             self.body.append(r'\\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)\n962             context = '}%' + CR + context\n963         if cell.width > 1 or cell.height > 1:\n964             self.body.append(r'\\begin{varwidth}[t]{\\sphinxcolwidth{%d}{%d}}'\n965                              % (cell.width, self.table.colcount) + CR)\n966             context = (r'\\par' + CR + r'\\vskip-\\baselineskip'\n967                        r'\\vbox{\\hbox{\\strut}}\\end{varwidth}%' + CR + context)\n968             self.needs_linetrimming = 1\n969         if len(list(node.traverse(nodes.paragraph))) >= 2:\n970             self.table.has_oldproblematic = True\n971         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):\n972             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':\n973                 pass\n974             else:\n975                 self.body.append(r'\\sphinxstyletheadfamily ')\n976         if self.needs_linetrimming:\n977             self.pushbody([])\n978         self.context.append(context)\n979 \n980     def depart_entry(self, node: Element) -> None:\n981         if self.needs_linetrimming:\n982             self.needs_linetrimming = 0\n983             body = self.popbody()\n984 \n985             # Remove empty lines from top of merged cell\n986             while body and body[0] == CR:\n987                 body.pop(0)\n988             self.body.extend(body)\n989 \n990         self.body.append(self.context.pop())\n991 \n992         cell = self.table.cell()\n993         self.table.col += cell.width\n994 \n995         # fill columns if next ones are a bottom of wide-multirow cell\n996         while True:\n997             nextcell = self.table.cell()\n998             if nextcell is None:  # not a bottom of multirow cell\n999                 break\n1000             else:  # a bottom part of multirow cell\n1001                 self.table.col += nextcell.width\n1002                 self.body.append('&')\n1003                 if nextcell.width == 1:\n1004                     # insert suitable strut for equalizing row heights in multirow\n1005                     # they also serve to clear colour panels which would hide the text\n1006                     self.body.append(r'\\sphinxtablestrut{%d}' % nextcell.cell_id)\n1007                 else:\n1008                     # use \\multicolumn for wide multirow cell\n1009                     self.body.append(r'\\multicolumn{%d}{l|}{\\sphinxtablestrut{%d}}' %\n1010                                      (nextcell.width, nextcell.cell_id))\n1011 \n1012     def visit_acks(self, node: Element) -> None:\n1013         # this is a list in the source, but should be rendered as a\n1014         # comma-separated list here\n1015         bullet_list = cast(nodes.bullet_list, node[0])\n1016         list_items = cast(Iterable[nodes.list_item], bullet_list)\n1017         self.body.append(BLANKLINE)\n1018         self.body.append(', '.join(n.astext() for n in list_items) + '.')\n1019         self.body.append(BLANKLINE)\n1020         raise nodes.SkipNode\n1021 \n1022     def visit_bullet_list(self, node: Element) -> None:\n1023         if not self.compact_list:\n1024             self.body.append(r'\\begin{itemize}' + CR)\n1025         if self.table:\n1026             self.table.has_problematic = True\n1027 \n1028     def depart_bullet_list(self, node: Element) -> None:\n1029         if not self.compact_list:\n1030             self.body.append(r'\\end{itemize}' + CR)\n1031 \n1032     def visit_enumerated_list(self, node: Element) -> None:\n1033         def get_enumtype(node: Element) -> str:\n1034             enumtype = node.get('enumtype', 'arabic')\n1035             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):\n1036                 # fallback to arabic if alphabet counter overflows\n1037                 enumtype = 'arabic'\n1038 \n1039             return enumtype\n1040 \n1041         def get_nested_level(node: Element) -> int:\n1042             if node is None:\n1043                 return 0\n1044             elif isinstance(node, nodes.enumerated_list):\n1045                 return get_nested_level(node.parent) + 1\n1046             else:\n1047                 return get_nested_level(node.parent)\n1048 \n1049         enum = \"enum%s\" % toRoman(get_nested_level(node)).lower()\n1050         enumnext = \"enum%s\" % toRoman(get_nested_level(node) + 1).lower()\n1051         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))\n1052         prefix = node.get('prefix', '')\n1053         suffix = node.get('suffix', '.')\n1054 \n1055         self.body.append(r'\\begin{enumerate}' + CR)\n1056         self.body.append(r'\\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %\n1057                          (style, enum, enumnext, prefix, suffix) + CR)\n1058         if 'start' in node:\n1059             self.body.append(r'\\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)\n1060         if self.table:\n1061             self.table.has_problematic = True\n1062 \n1063     def depart_enumerated_list(self, node: Element) -> None:\n1064         self.body.append(r'\\end{enumerate}' + CR)\n1065 \n1066     def visit_list_item(self, node: Element) -> None:\n1067         # Append \"{}\" in case the next character is \"[\", which would break\n1068         # LaTeX's list environment (no numbering and the \"[\" is not printed).\n1069         self.body.append(r'\\item {} ')\n1070 \n1071     def depart_list_item(self, node: Element) -> None:\n1072         self.body.append(CR)\n1073 \n1074     def visit_definition_list(self, node: Element) -> None:\n1075         self.body.append(r'\\begin{description}' + CR)\n1076         if self.table:\n1077             self.table.has_problematic = True\n1078 \n1079     def depart_definition_list(self, node: Element) -> None:\n1080         self.body.append(r'\\end{description}' + CR)\n1081 \n1082     def visit_definition_list_item(self, node: Element) -> None:\n1083         pass\n1084 \n1085     def depart_definition_list_item(self, node: Element) -> None:\n1086         pass\n1087 \n1088     def visit_term(self, node: Element) -> None:\n1089         self.in_term += 1\n1090         ctx = ''\n1091         if node.get('ids'):\n1092             ctx = r'\\phantomsection'\n1093             for node_id in node['ids']:\n1094                 ctx += self.hypertarget(node_id, anchor=False)\n1095         ctx += r'}] \\leavevmode'\n1096         self.body.append(r'\\item[{')\n1097         self.context.append(ctx)\n1098 \n1099     def depart_term(self, node: Element) -> None:\n1100         self.body.append(self.context.pop())\n1101         self.in_term -= 1\n1102 \n1103     def visit_classifier(self, node: Element) -> None:\n1104         self.body.append('{[}')\n1105 \n1106     def depart_classifier(self, node: Element) -> None:\n1107         self.body.append('{]}')\n1108 \n1109     def visit_definition(self, node: Element) -> None:\n1110         pass\n1111 \n1112     def depart_definition(self, node: Element) -> None:\n1113         self.body.append(CR)\n1114 \n1115     def visit_field_list(self, node: Element) -> None:\n1116         self.body.append(r'\\begin{quote}\\begin{description}' + CR)\n1117         if self.table:\n1118             self.table.has_problematic = True\n1119 \n1120     def depart_field_list(self, node: Element) -> None:\n1121         self.body.append(r'\\end{description}\\end{quote}' + CR)\n1122 \n1123     def visit_field(self, node: Element) -> None:\n1124         pass\n1125 \n1126     def depart_field(self, node: Element) -> None:\n1127         pass\n1128 \n1129     visit_field_name = visit_term\n1130     depart_field_name = depart_term\n1131 \n1132     visit_field_body = visit_definition\n1133     depart_field_body = depart_definition\n1134 \n1135     def visit_paragraph(self, node: Element) -> None:\n1136         index = node.parent.index(node)\n1137         if (index > 0 and isinstance(node.parent, nodes.compound) and\n1138                 not isinstance(node.parent[index - 1], nodes.paragraph) and\n1139                 not isinstance(node.parent[index - 1], nodes.compound)):\n1140             # insert blank line, if the paragraph follows a non-paragraph node in a compound\n1141             self.body.append(r'\\noindent' + CR)\n1142         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):\n1143             # don't insert blank line, if the paragraph is second child of a footnote\n1144             # (first one is label node)\n1145             pass\n1146         else:\n1147             # the \\sphinxAtStartPar is to allow hyphenation of first word of\n1148             # a paragraph in narrow contexts such as in a table cell\n1149             # added as two items (cf. line trimming in depart_entry())\n1150             self.body.extend([CR, r'\\sphinxAtStartPar' + CR])\n1151 \n1152     def depart_paragraph(self, node: Element) -> None:\n1153         self.body.append(CR)\n1154 \n1155     def visit_centered(self, node: Element) -> None:\n1156         self.body.append(CR + r'\\begin{center}')\n1157         if self.table:\n1158             self.table.has_problematic = True\n1159 \n1160     def depart_centered(self, node: Element) -> None:\n1161         self.body.append(CR + r'\\end{center}')\n1162 \n1163     def visit_hlist(self, node: Element) -> None:\n1164         self.compact_list += 1\n1165         ncolumns = node['ncolumns']\n1166         if self.compact_list > 1:\n1167             self.body.append(r'\\setlength{\\multicolsep}{0pt}' + CR)\n1168         self.body.append(r'\\begin{multicols}{' + ncolumns + r'}\\raggedright' + CR)\n1169         self.body.append(r'\\begin{itemize}\\setlength{\\itemsep}{0pt}'\n1170                          r'\\setlength{\\parskip}{0pt}' + CR)\n1171         if self.table:\n1172             self.table.has_problematic = True\n1173 \n1174     def depart_hlist(self, node: Element) -> None:\n1175         self.compact_list -= 1\n1176         self.body.append(r'\\end{itemize}\\raggedcolumns\\end{multicols}' + CR)\n1177 \n1178     def visit_hlistcol(self, node: Element) -> None:\n1179         pass\n1180 \n1181     def depart_hlistcol(self, node: Element) -> None:\n1182         # \\columnbreak would guarantee same columns as in html output.  But\n1183         # some testing with long items showed that columns may be too uneven.\n1184         # And in case only of short items, the automatic column breaks should\n1185         # match the ones pre-computed by the hlist() directive.\n1186         # self.body.append(r'\\columnbreak\\n')\n1187         pass\n1188 \n1189     def latex_image_length(self, width_str: str, scale: int = 100) -> str:\n1190         try:\n1191             return rstdim_to_latexdim(width_str, scale)\n1192         except ValueError:\n1193             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)\n1194             return None\n1195 \n1196     def is_inline(self, node: Element) -> bool:\n1197         \"\"\"Check whether a node represents an inline element.\"\"\"\n1198         return isinstance(node.parent, nodes.TextElement)\n1199 \n1200     def visit_image(self, node: Element) -> None:\n1201         pre: List[str] = []  # in reverse order\n1202         post: List[str] = []\n1203         include_graphics_options = []\n1204         has_hyperlink = isinstance(node.parent, nodes.reference)\n1205         if has_hyperlink:\n1206             is_inline = self.is_inline(node.parent)\n1207         else:\n1208             is_inline = self.is_inline(node)\n1209         if 'width' in node:\n1210             if 'scale' in node:\n1211                 w = self.latex_image_length(node['width'], node['scale'])\n1212             else:\n1213                 w = self.latex_image_length(node['width'])\n1214             if w:\n1215                 include_graphics_options.append('width=%s' % w)\n1216         if 'height' in node:\n1217             if 'scale' in node:\n1218                 h = self.latex_image_length(node['height'], node['scale'])\n1219             else:\n1220                 h = self.latex_image_length(node['height'])\n1221             if h:\n1222                 include_graphics_options.append('height=%s' % h)\n1223         if 'scale' in node:\n1224             if not include_graphics_options:\n1225                 # if no \"width\" nor \"height\", \\sphinxincludegraphics will fit\n1226                 # to the available text width if oversized after rescaling.\n1227                 include_graphics_options.append('scale=%s'\n1228                                                 % (float(node['scale']) / 100.0))\n1229         if 'align' in node:\n1230             align_prepost = {\n1231                 # By default latex aligns the top of an image.\n1232                 (1, 'top'): ('', ''),\n1233                 (1, 'middle'): (r'\\raisebox{-0.5\\height}{', '}'),\n1234                 (1, 'bottom'): (r'\\raisebox{-\\height}{', '}'),\n1235                 (0, 'center'): (r'{\\hspace*{\\fill}', r'\\hspace*{\\fill}}'),\n1236                 # These 2 don't exactly do the right thing.  The image should\n1237                 # be floated alongside the paragraph.  See\n1238                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG\n1239                 (0, 'left'): ('{', r'\\hspace*{\\fill}}'),\n1240                 (0, 'right'): (r'{\\hspace*{\\fill}', '}'),\n1241             }\n1242             try:\n1243                 pre.append(align_prepost[is_inline, node['align']][0])\n1244                 post.append(align_prepost[is_inline, node['align']][1])\n1245             except KeyError:\n1246                 pass\n1247         if self.in_parsed_literal:\n1248             pre.append(r'{\\sphinxunactivateextrasandspace ')\n1249             post.append('}')\n1250         if not is_inline and not has_hyperlink:\n1251             pre.append(CR + r'\\noindent')\n1252             post.append(CR)\n1253         pre.reverse()\n1254         if node['uri'] in self.builder.images:\n1255             uri = self.builder.images[node['uri']]\n1256         else:\n1257             # missing image!\n1258             if self.ignore_missing_images:\n1259                 return\n1260             uri = node['uri']\n1261         if uri.find('://') != -1:\n1262             # ignore remote images\n1263             return\n1264         self.body.extend(pre)\n1265         options = ''\n1266         if include_graphics_options:\n1267             options = '[%s]' % ','.join(include_graphics_options)\n1268         base, ext = path.splitext(uri)\n1269         if self.in_title and base:\n1270             # Lowercase tokens forcely because some fncychap themes capitalize\n1271             # the options of \\sphinxincludegraphics unexpectedly (ex. WIDTH=...).\n1272             self.body.append(r'\\lowercase{\\sphinxincludegraphics%s}{{%s}%s}' %\n1273                              (options, base, ext))\n1274         else:\n1275             self.body.append(r'\\sphinxincludegraphics%s{{%s}%s}' %\n1276                              (options, base, ext))\n1277         self.body.extend(post)\n1278 \n1279     def depart_image(self, node: Element) -> None:\n1280         pass\n1281 \n1282     def visit_figure(self, node: Element) -> None:\n1283         align = self.elements['figure_align']\n1284         if self.no_latex_floats:\n1285             align = \"H\"\n1286         if self.table:\n1287             # TODO: support align option\n1288             if 'width' in node:\n1289                 length = self.latex_image_length(node['width'])\n1290                 if length:\n1291                     self.body.append(r'\\begin{sphinxfigure-in-table}[%s]' % length + CR)\n1292                     self.body.append(r'\\centering' + CR)\n1293             else:\n1294                 self.body.append(r'\\begin{sphinxfigure-in-table}' + CR)\n1295                 self.body.append(r'\\centering' + CR)\n1296             if any(isinstance(child, nodes.caption) for child in node):\n1297                 self.body.append(r'\\capstart')\n1298             self.context.append(r'\\end{sphinxfigure-in-table}\\relax' + CR)\n1299         elif node.get('align', '') in ('left', 'right'):\n1300             length = None\n1301             if 'width' in node:\n1302                 length = self.latex_image_length(node['width'])\n1303             elif isinstance(node[0], nodes.image) and 'width' in node[0]:\n1304                 length = self.latex_image_length(node[0]['width'])\n1305             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop\n1306                                             # https://github.com/sphinx-doc/sphinx/issues/7059\n1307             self.body.append(r'\\begin{wrapfigure}{%s}{%s}' %\n1308                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)\n1309             self.body.append(r'\\centering')\n1310             self.context.append(r'\\end{wrapfigure}' + CR)\n1311         elif self.in_minipage:\n1312             self.body.append(CR + r'\\begin{center}')\n1313             self.context.append(r'\\end{center}' + CR)\n1314         else:\n1315             self.body.append(CR + r'\\begin{figure}[%s]' % align + CR)\n1316             self.body.append(r'\\centering' + CR)\n1317             if any(isinstance(child, nodes.caption) for child in node):\n1318                 self.body.append(r'\\capstart' + CR)\n1319             self.context.append(r'\\end{figure}' + CR)\n1320 \n1321     def depart_figure(self, node: Element) -> None:\n1322         self.body.append(self.context.pop())\n1323 \n1324     def visit_caption(self, node: Element) -> None:\n1325         self.in_caption += 1\n1326         if isinstance(node.parent, captioned_literal_block):\n1327             self.body.append(r'\\sphinxSetupCaptionForVerbatim{')\n1328         elif self.in_minipage and isinstance(node.parent, nodes.figure):\n1329             self.body.append(r'\\captionof{figure}{')\n1330         elif self.table and node.parent.tagname == 'figure':\n1331             self.body.append(r'\\sphinxfigcaption{')\n1332         else:\n1333             self.body.append(r'\\caption{')\n1334 \n1335     def depart_caption(self, node: Element) -> None:\n1336         self.body.append('}')\n1337         if isinstance(node.parent, nodes.figure):\n1338             labels = self.hypertarget_to(node.parent)\n1339             self.body.append(labels)\n1340         self.in_caption -= 1\n1341 \n1342     def visit_legend(self, node: Element) -> None:\n1343         self.body.append(CR + r'\\begin{sphinxlegend}')\n1344 \n1345     def depart_legend(self, node: Element) -> None:\n1346         self.body.append(r'\\end{sphinxlegend}' + CR)\n1347 \n1348     def visit_admonition(self, node: Element) -> None:\n1349         self.body.append(CR + r'\\begin{sphinxadmonition}{note}')\n1350         self.no_latex_floats += 1\n1351 \n1352     def depart_admonition(self, node: Element) -> None:\n1353         self.body.append(r'\\end{sphinxadmonition}' + CR)\n1354         self.no_latex_floats -= 1\n1355 \n1356     def _visit_named_admonition(self, node: Element) -> None:\n1357         label = admonitionlabels[node.tagname]\n1358         self.body.append(CR + r'\\begin{sphinxadmonition}{%s}{%s:}' %\n1359                          (node.tagname, label))\n1360         self.no_latex_floats += 1\n1361 \n1362     def _depart_named_admonition(self, node: Element) -> None:\n1363         self.body.append(r'\\end{sphinxadmonition}' + CR)\n1364         self.no_latex_floats -= 1\n1365 \n1366     visit_attention = _visit_named_admonition\n1367     depart_attention = _depart_named_admonition\n1368     visit_caution = _visit_named_admonition\n1369     depart_caution = _depart_named_admonition\n1370     visit_danger = _visit_named_admonition\n1371     depart_danger = _depart_named_admonition\n1372     visit_error = _visit_named_admonition\n1373     depart_error = _depart_named_admonition\n1374     visit_hint = _visit_named_admonition\n1375     depart_hint = _depart_named_admonition\n1376     visit_important = _visit_named_admonition\n1377     depart_important = _depart_named_admonition\n1378     visit_note = _visit_named_admonition\n1379     depart_note = _depart_named_admonition\n1380     visit_tip = _visit_named_admonition\n1381     depart_tip = _depart_named_admonition\n1382     visit_warning = _visit_named_admonition\n1383     depart_warning = _depart_named_admonition\n1384 \n1385     def visit_versionmodified(self, node: Element) -> None:\n1386         pass\n1387 \n1388     def depart_versionmodified(self, node: Element) -> None:\n1389         pass\n1390 \n1391     def visit_target(self, node: Element) -> None:\n1392         def add_target(id: str) -> None:\n1393             # indexing uses standard LaTeX index markup, so the targets\n1394             # will be generated differently\n1395             if id.startswith('index-'):\n1396                 return\n1397 \n1398             # equations also need no extra blank line nor hypertarget\n1399             # TODO: fix this dependency on mathbase extension internals\n1400             if id.startswith('equation-'):\n1401                 return\n1402 \n1403             # insert blank line, if the target follows a paragraph node\n1404             index = node.parent.index(node)\n1405             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):\n1406                 self.body.append(CR)\n1407 \n1408             # do not generate \\phantomsection in \\section{}\n1409             anchor = not self.in_title\n1410             self.body.append(self.hypertarget(id, anchor=anchor))\n1411 \n1412         # skip if visitor for next node supports hyperlink\n1413         next_node: Node = node\n1414         while isinstance(next_node, nodes.target):\n1415             next_node = next_node.next_node(ascend=True)\n1416 \n1417         domain = cast(StandardDomain, self.builder.env.get_domain('std'))\n1418         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):\n1419             return\n1420         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):\n1421             return\n1422 \n1423         if 'refuri' in node:\n1424             return\n1425         if 'anonymous' in node:\n1426             return\n1427         if node.get('refid'):\n1428             prev_node = get_prev_node(node)\n1429             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:\n1430                 # a target for a hyperlink reference having alias\n1431                 pass\n1432             else:\n1433                 add_target(node['refid'])\n1434         for id in node['ids']:\n1435             add_target(id)\n1436 \n1437     def depart_target(self, node: Element) -> None:\n1438         pass\n1439 \n1440     def visit_attribution(self, node: Element) -> None:\n1441         self.body.append(CR + r'\\begin{flushright}' + CR)\n1442         self.body.append('---')\n1443 \n1444     def depart_attribution(self, node: Element) -> None:\n1445         self.body.append(CR + r'\\end{flushright}' + CR)\n1446 \n1447     def visit_index(self, node: Element) -> None:\n1448         def escape(value: str) -> str:\n1449             value = self.encode(value)\n1450             value = value.replace(r'\\{', r'\\sphinxleftcurlybrace{}')\n1451             value = value.replace(r'\\}', r'\\sphinxrightcurlybrace{}')\n1452             value = value.replace('\"', '\"\"')\n1453             value = value.replace('@', '\"@')\n1454             value = value.replace('!', '\"!')\n1455             value = value.replace('|', r'\\textbar{}')\n1456             return value\n1457 \n1458         def style(string: str) -> str:\n1459             match = EXTRA_RE.match(string)\n1460             if match:\n1461                 return match.expand(r'\\\\spxentry{\\1}\\\\spxextra{\\2}')\n1462             else:\n1463                 return r'\\spxentry{%s}' % string\n1464 \n1465         if not node.get('inline', True):\n1466             self.body.append(CR)\n1467         entries = node['entries']\n1468         for type, string, tid, ismain, key_ in entries:\n1469             m = ''\n1470             if ismain:\n1471                 m = '|spxpagem'\n1472             try:\n1473                 if type == 'single':\n1474                     try:\n1475                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]\n1476                         P1, P2 = style(p1), style(p2)\n1477                         self.body.append(r'\\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))\n1478                     except ValueError:\n1479                         p = escape(split_into(1, 'single', string)[0])\n1480                         P = style(p)\n1481                         self.body.append(r'\\index{%s@%s%s}' % (p, P, m))\n1482                 elif type == 'pair':\n1483                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]\n1484                     P1, P2 = style(p1), style(p2)\n1485                     self.body.append(r'\\index{%s@%s!%s@%s%s}\\index{%s@%s!%s@%s%s}' %\n1486                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))\n1487                 elif type == 'triple':\n1488                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]\n1489                     P1, P2, P3 = style(p1), style(p2), style(p3)\n1490                     self.body.append(\n1491                         r'\\index{%s@%s!%s %s@%s %s%s}'\n1492                         r'\\index{%s@%s!%s, %s@%s, %s%s}'\n1493                         r'\\index{%s@%s!%s %s@%s %s%s}' %\n1494                         (p1, P1, p2, p3, P2, P3, m,\n1495                          p2, P2, p3, p1, P3, P1, m,\n1496                          p3, P3, p1, p2, P1, P2, m))\n1497                 elif type == 'see':\n1498                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]\n1499                     P1 = style(p1)\n1500                     self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n1501                 elif type == 'seealso':\n1502                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]\n1503                     P1 = style(p1)\n1504                     self.body.append(r'\\index{%s@%s|see{%s}}' % (p1, P1, p2))\n1505                 else:\n1506                     logger.warning(__('unknown index entry type %s found'), type)\n1507             except ValueError as err:\n1508                 logger.warning(str(err))\n1509         if not node.get('inline', True):\n1510             self.body.append(r'\\ignorespaces ')\n1511         raise nodes.SkipNode\n1512 \n1513     def visit_raw(self, node: Element) -> None:\n1514         if not self.is_inline(node):\n1515             self.body.append(CR)\n1516         if 'latex' in node.get('format', '').split():\n1517             self.body.append(node.astext())\n1518         if not self.is_inline(node):\n1519             self.body.append(CR)\n1520         raise nodes.SkipNode\n1521 \n1522     def visit_reference(self, node: Element) -> None:\n1523         if not self.in_title:\n1524             for id in node.get('ids'):\n1525                 anchor = not self.in_caption\n1526                 self.body += self.hypertarget(id, anchor=anchor)\n1527         if not self.is_inline(node):\n1528             self.body.append(CR)\n1529         uri = node.get('refuri', '')\n1530         if not uri and node.get('refid'):\n1531             uri = '%' + self.curfilestack[-1] + '#' + node['refid']\n1532         if self.in_title or not uri:\n1533             self.context.append('')\n1534         elif uri.startswith('#'):\n1535             # references to labels in the same document\n1536             id = self.curfilestack[-1] + ':' + uri[1:]\n1537             self.body.append(self.hyperlink(id))\n1538             self.body.append(r'\\emph{')\n1539             if self.config.latex_show_pagerefs and not \\\n1540                     self.in_production_list:\n1541                 self.context.append('}}} (%s)' % self.hyperpageref(id))\n1542             else:\n1543                 self.context.append('}}}')\n1544         elif uri.startswith('%'):\n1545             # references to documents or labels inside documents\n1546             hashindex = uri.find('#')\n1547             if hashindex == -1:\n1548                 # reference to the document\n1549                 id = uri[1:] + '::doc'\n1550             else:\n1551                 # reference to a label\n1552                 id = uri[1:].replace('#', ':')\n1553             self.body.append(self.hyperlink(id))\n1554             if (len(node) and\n1555                     isinstance(node[0], nodes.Element) and\n1556                     'std-term' in node[0].get('classes', [])):\n1557                 # don't add a pageref for glossary terms\n1558                 self.context.append('}}}')\n1559                 # mark up as termreference\n1560                 self.body.append(r'\\sphinxtermref{')\n1561             else:\n1562                 self.body.append(r'\\sphinxcrossref{')\n1563                 if self.config.latex_show_pagerefs and not self.in_production_list:\n1564                     self.context.append('}}} (%s)' % self.hyperpageref(id))\n1565                 else:\n1566                     self.context.append('}}}')\n1567         else:\n1568             if len(node) == 1 and uri == node[0]:\n1569                 if node.get('nolinkurl'):\n1570                     self.body.append(r'\\sphinxnolinkurl{%s}' % self.encode_uri(uri))\n1571                 else:\n1572                     self.body.append(r'\\sphinxurl{%s}' % self.encode_uri(uri))\n1573                 raise nodes.SkipNode\n1574             else:\n1575                 self.body.append(r'\\sphinxhref{%s}{' % self.encode_uri(uri))\n1576                 self.context.append('}')\n1577 \n1578     def depart_reference(self, node: Element) -> None:\n1579         self.body.append(self.context.pop())\n1580         if not self.is_inline(node):\n1581             self.body.append(CR)\n1582 \n1583     def visit_number_reference(self, node: Element) -> None:\n1584         if node.get('refid'):\n1585             id = self.curfilestack[-1] + ':' + node['refid']\n1586         else:\n1587             id = node.get('refuri', '')[1:].replace('#', ':')\n1588 \n1589         title = self.escape(node.get('title', '%s')).replace(r'\\%s', '%s')\n1590         if r'\\{name\\}' in title or r'\\{number\\}' in title:\n1591             # new style format (cf. \"Fig.%{number}\")\n1592             title = title.replace(r'\\{name\\}', '{name}').replace(r'\\{number\\}', '{number}')\n1593             text = escape_abbr(title).format(name=r'\\nameref{%s}' % self.idescape(id),\n1594                                              number=r'\\ref{%s}' % self.idescape(id))\n1595         else:\n1596             # old style format (cf. \"Fig.%{number}\")\n1597             text = escape_abbr(title) % (r'\\ref{%s}' % self.idescape(id))\n1598         hyperref = r'\\hyperref[%s]{%s}' % (self.idescape(id), text)\n1599         self.body.append(hyperref)\n1600 \n1601         raise nodes.SkipNode\n1602 \n1603     def visit_download_reference(self, node: Element) -> None:\n1604         pass\n1605 \n1606     def depart_download_reference(self, node: Element) -> None:\n1607         pass\n1608 \n1609     def visit_pending_xref(self, node: Element) -> None:\n1610         pass\n1611 \n1612     def depart_pending_xref(self, node: Element) -> None:\n1613         pass\n1614 \n1615     def visit_emphasis(self, node: Element) -> None:\n1616         self.body.append(r'\\sphinxstyleemphasis{')\n1617 \n1618     def depart_emphasis(self, node: Element) -> None:\n1619         self.body.append('}')\n1620 \n1621     def visit_literal_emphasis(self, node: Element) -> None:\n1622         self.body.append(r'\\sphinxstyleliteralemphasis{\\sphinxupquote{')\n1623 \n1624     def depart_literal_emphasis(self, node: Element) -> None:\n1625         self.body.append('}}')\n1626 \n1627     def visit_strong(self, node: Element) -> None:\n1628         self.body.append(r'\\sphinxstylestrong{')\n1629 \n1630     def depart_strong(self, node: Element) -> None:\n1631         self.body.append('}')\n1632 \n1633     def visit_literal_strong(self, node: Element) -> None:\n1634         self.body.append(r'\\sphinxstyleliteralstrong{\\sphinxupquote{')\n1635 \n1636     def depart_literal_strong(self, node: Element) -> None:\n1637         self.body.append('}}')\n1638 \n1639     def visit_abbreviation(self, node: Element) -> None:\n1640         abbr = node.astext()\n1641         self.body.append(r'\\sphinxstyleabbreviation{')\n1642         # spell out the explanation once\n1643         if node.hasattr('explanation') and abbr not in self.handled_abbrs:\n1644             self.context.append('} (%s)' % self.encode(node['explanation']))\n1645             self.handled_abbrs.add(abbr)\n1646         else:\n1647             self.context.append('}')\n1648 \n1649     def depart_abbreviation(self, node: Element) -> None:\n1650         self.body.append(self.context.pop())\n1651 \n1652     def visit_manpage(self, node: Element) -> None:\n1653         return self.visit_literal_emphasis(node)\n1654 \n1655     def depart_manpage(self, node: Element) -> None:\n1656         return self.depart_literal_emphasis(node)\n1657 \n1658     def visit_title_reference(self, node: Element) -> None:\n1659         self.body.append(r'\\sphinxtitleref{')\n1660 \n1661     def depart_title_reference(self, node: Element) -> None:\n1662         self.body.append('}')\n1663 \n1664     def visit_thebibliography(self, node: Element) -> None:\n1665         citations = cast(Iterable[nodes.citation], node)\n1666         labels = (cast(nodes.label, citation[0]) for citation in citations)\n1667         longest_label = max((label.astext() for label in labels), key=len)\n1668         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:\n1669             # adjust max width of citation labels not to break the layout\n1670             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]\n1671 \n1672         self.body.append(CR + r'\\begin{sphinxthebibliography}{%s}' %\n1673                          self.encode(longest_label) + CR)\n1674 \n1675     def depart_thebibliography(self, node: Element) -> None:\n1676         self.body.append(r'\\end{sphinxthebibliography}' + CR)\n1677 \n1678     def visit_citation(self, node: Element) -> None:\n1679         label = cast(nodes.label, node[0])\n1680         self.body.append(r'\\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),\n1681                                                    node['docname'], node['ids'][0]))\n1682 \n1683     def depart_citation(self, node: Element) -> None:\n1684         pass\n1685 \n1686     def visit_citation_reference(self, node: Element) -> None:\n1687         if self.in_title:\n1688             pass\n1689         else:\n1690             self.body.append(r'\\sphinxcite{%s:%s}' % (node['docname'], node['refname']))\n1691             raise nodes.SkipNode\n1692 \n1693     def depart_citation_reference(self, node: Element) -> None:\n1694         pass\n1695 \n1696     def visit_literal(self, node: Element) -> None:\n1697         if self.in_title:\n1698             self.body.append(r'\\sphinxstyleliteralintitle{\\sphinxupquote{')\n1699         elif 'kbd' in node['classes']:\n1700             self.body.append(r'\\sphinxkeyboard{\\sphinxupquote{')\n1701         else:\n1702             self.body.append(r'\\sphinxcode{\\sphinxupquote{')\n1703 \n1704     def depart_literal(self, node: Element) -> None:\n1705         self.body.append('}}')\n1706 \n1707     def visit_footnote_reference(self, node: Element) -> None:\n1708         raise nodes.SkipNode\n1709 \n1710     def visit_footnotemark(self, node: Element) -> None:\n1711         self.body.append(r'\\sphinxfootnotemark[')\n1712 \n1713     def depart_footnotemark(self, node: Element) -> None:\n1714         self.body.append(']')\n1715 \n1716     def visit_footnotetext(self, node: Element) -> None:\n1717         label = cast(nodes.label, node[0])\n1718         self.body.append('%' + CR)\n1719         self.body.append(r'\\begin{footnotetext}[%s]'\n1720                          r'\\phantomsection\\label{\\thesphinxscope.%s}%%'\n1721                          % (label.astext(), label.astext()) + CR)\n1722         self.body.append(r'\\sphinxAtStartFootnote' + CR)\n1723 \n1724     def depart_footnotetext(self, node: Element) -> None:\n1725         # the \\ignorespaces in particular for after table header use\n1726         self.body.append('%' + CR)\n1727         self.body.append(r'\\end{footnotetext}\\ignorespaces ')\n1728 \n1729     def visit_captioned_literal_block(self, node: Element) -> None:\n1730         pass\n1731 \n1732     def depart_captioned_literal_block(self, node: Element) -> None:\n1733         pass\n1734 \n1735     def visit_literal_block(self, node: Element) -> None:\n1736         if node.rawsource != node.astext():\n1737             # most probably a parsed-literal block -- don't highlight\n1738             self.in_parsed_literal += 1\n1739             self.body.append(r'\\begin{sphinxalltt}' + CR)\n1740         else:\n1741             labels = self.hypertarget_to(node)\n1742             if isinstance(node.parent, captioned_literal_block):\n1743                 labels += self.hypertarget_to(node.parent)\n1744             if labels and not self.in_footnote:\n1745                 self.body.append(CR + r'\\def\\sphinxLiteralBlockLabel{' + labels + '}')\n1746 \n1747             lang = node.get('language', 'default')\n1748             linenos = node.get('linenos', False)\n1749             highlight_args = node.get('highlight_args', {})\n1750             highlight_args['force'] = node.get('force', False)\n1751             opts = self.config.highlight_options.get(lang, {})\n1752 \n1753             hlcode = self.highlighter.highlight_block(\n1754                 node.rawsource, lang, opts=opts, linenos=linenos,\n1755                 location=node, **highlight_args\n1756             )\n1757             if self.in_footnote:\n1758                 self.body.append(CR + r'\\sphinxSetupCodeBlockInFootnote')\n1759                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n1760                                         r'\\begin{sphinxVerbatim}')\n1761             # if in table raise verbatim flag to avoid \"tabulary\" environment\n1762             # and opt for sphinxVerbatimintable to handle caption & long lines\n1763             elif self.table:\n1764                 self.table.has_problematic = True\n1765                 self.table.has_verbatim = True\n1766                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n1767                                         r'\\begin{sphinxVerbatimintable}')\n1768             else:\n1769                 hlcode = hlcode.replace(r'\\begin{Verbatim}',\n1770                                         r'\\begin{sphinxVerbatim}')\n1771             # get consistent trailer\n1772             hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}\n1773             if self.table and not self.in_footnote:\n1774                 hlcode += r'\\end{sphinxVerbatimintable}'\n1775             else:\n1776                 hlcode += r'\\end{sphinxVerbatim}'\n1777 \n1778             hllines = str(highlight_args.get('hl_lines', []))[1:-1]\n1779             if hllines:\n1780                 self.body.append(CR + r'\\fvset{hllines={, %s,}}%%' % hllines)\n1781             self.body.append(CR + hlcode + CR)\n1782             if hllines:\n1783                 self.body.append(r'\\sphinxresetverbatimhllines' + CR)\n1784             raise nodes.SkipNode\n1785 \n1786     def depart_literal_block(self, node: Element) -> None:\n1787         self.body.append(CR + r'\\end{sphinxalltt}' + CR)\n1788         self.in_parsed_literal -= 1\n1789     visit_doctest_block = visit_literal_block\n1790     depart_doctest_block = depart_literal_block\n1791 \n1792     def visit_line(self, node: Element) -> None:\n1793         self.body.append(r'\\item[] ')\n1794 \n1795     def depart_line(self, node: Element) -> None:\n1796         self.body.append(CR)\n1797 \n1798     def visit_line_block(self, node: Element) -> None:\n1799         if isinstance(node.parent, nodes.line_block):\n1800             self.body.append(r'\\item[]' + CR)\n1801             self.body.append(r'\\begin{DUlineblock}{\\DUlineblockindent}' + CR)\n1802         else:\n1803             self.body.append(CR + r'\\begin{DUlineblock}{0em}' + CR)\n1804         if self.table:\n1805             self.table.has_problematic = True\n1806 \n1807     def depart_line_block(self, node: Element) -> None:\n1808         self.body.append(r'\\end{DUlineblock}' + CR)\n1809 \n1810     def visit_block_quote(self, node: Element) -> None:\n1811         # If the block quote contains a single object and that object\n1812         # is a list, then generate a list not a block quote.\n1813         # This lets us indent lists.\n1814         done = 0\n1815         if len(node.children) == 1:\n1816             child = node.children[0]\n1817             if isinstance(child, nodes.bullet_list) or \\\n1818                     isinstance(child, nodes.enumerated_list):\n1819                 done = 1\n1820         if not done:\n1821             self.body.append(r'\\begin{quote}' + CR)\n1822             if self.table:\n1823                 self.table.has_problematic = True\n1824 \n1825     def depart_block_quote(self, node: Element) -> None:\n1826         done = 0\n1827         if len(node.children) == 1:\n1828             child = node.children[0]\n1829             if isinstance(child, nodes.bullet_list) or \\\n1830                     isinstance(child, nodes.enumerated_list):\n1831                 done = 1\n1832         if not done:\n1833             self.body.append(r'\\end{quote}' + CR)\n1834 \n1835     # option node handling copied from docutils' latex writer\n1836 \n1837     def visit_option(self, node: Element) -> None:\n1838         if self.context[-1]:\n1839             # this is not the first option\n1840             self.body.append(', ')\n1841 \n1842     def depart_option(self, node: Element) -> None:\n1843         # flag that the first option is done.\n1844         self.context[-1] += 1\n1845 \n1846     def visit_option_argument(self, node: Element) -> None:\n1847         \"\"\"The delimiter between an option and its argument.\"\"\"\n1848         self.body.append(node.get('delimiter', ' '))\n1849 \n1850     def depart_option_argument(self, node: Element) -> None:\n1851         pass\n1852 \n1853     def visit_option_group(self, node: Element) -> None:\n1854         self.body.append(r'\\item [')\n1855         # flag for first option\n1856         self.context.append(0)\n1857 \n1858     def depart_option_group(self, node: Element) -> None:\n1859         self.context.pop()  # the flag\n1860         self.body.append('] ')\n1861 \n1862     def visit_option_list(self, node: Element) -> None:\n1863         self.body.append(r'\\begin{optionlist}{3cm}' + CR)\n1864         if self.table:\n1865             self.table.has_problematic = True\n1866 \n1867     def depart_option_list(self, node: Element) -> None:\n1868         self.body.append(r'\\end{optionlist}' + CR)\n1869 \n1870     def visit_option_list_item(self, node: Element) -> None:\n1871         pass\n1872 \n1873     def depart_option_list_item(self, node: Element) -> None:\n1874         pass\n1875 \n1876     def visit_option_string(self, node: Element) -> None:\n1877         ostring = node.astext()\n1878         self.body.append(self.encode(ostring))\n1879         raise nodes.SkipNode\n1880 \n1881     def visit_description(self, node: Element) -> None:\n1882         self.body.append(' ')\n1883 \n1884     def depart_description(self, node: Element) -> None:\n1885         pass\n1886 \n1887     def visit_superscript(self, node: Element) -> None:\n1888         self.body.append(r'$^{\\text{')\n1889 \n1890     def depart_superscript(self, node: Element) -> None:\n1891         self.body.append('}}$')\n1892 \n1893     def visit_subscript(self, node: Element) -> None:\n1894         self.body.append(r'$_{\\text{')\n1895 \n1896     def depart_subscript(self, node: Element) -> None:\n1897         self.body.append('}}$')\n1898 \n1899     def visit_inline(self, node: Element) -> None:\n1900         classes = node.get('classes', [])\n1901         if classes in [['menuselection']]:\n1902             self.body.append(r'\\sphinxmenuselection{')\n1903             self.context.append('}')\n1904         elif classes in [['guilabel']]:\n1905             self.body.append(r'\\sphinxguilabel{')\n1906             self.context.append('}')\n1907         elif classes in [['accelerator']]:\n1908             self.body.append(r'\\sphinxaccelerator{')\n1909             self.context.append('}')\n1910         elif classes and not self.in_title:\n1911             self.body.append(r'\\DUrole{%s}{' % ','.join(classes))\n1912             self.context.append('}')\n1913         else:\n1914             self.context.append('')\n1915 \n1916     def depart_inline(self, node: Element) -> None:\n1917         self.body.append(self.context.pop())\n1918 \n1919     def visit_generated(self, node: Element) -> None:\n1920         pass\n1921 \n1922     def depart_generated(self, node: Element) -> None:\n1923         pass\n1924 \n1925     def visit_compound(self, node: Element) -> None:\n1926         pass\n1927 \n1928     def depart_compound(self, node: Element) -> None:\n1929         pass\n1930 \n1931     def visit_container(self, node: Element) -> None:\n1932         classes = node.get('classes', [])\n1933         for c in classes:\n1934             self.body.append('\\n\\\\begin{sphinxuseclass}{%s}' % c)\n1935 \n1936     def depart_container(self, node: Element) -> None:\n1937         classes = node.get('classes', [])\n1938         for c in classes:\n1939             self.body.append('\\n\\\\end{sphinxuseclass}')\n1940 \n1941     def visit_decoration(self, node: Element) -> None:\n1942         pass\n1943 \n1944     def depart_decoration(self, node: Element) -> None:\n1945         pass\n1946 \n1947     # docutils-generated elements that we don't support\n1948 \n1949     def visit_header(self, node: Element) -> None:\n1950         raise nodes.SkipNode\n1951 \n1952     def visit_footer(self, node: Element) -> None:\n1953         raise nodes.SkipNode\n1954 \n1955     def visit_docinfo(self, node: Element) -> None:\n1956         raise nodes.SkipNode\n1957 \n1958     # text handling\n1959 \n1960     def encode(self, text: str) -> str:\n1961         text = self.escape(text)\n1962         if self.literal_whitespace:\n1963             # Insert a blank before the newline, to avoid\n1964             # ! LaTeX Error: There's no line here to end.\n1965             text = text.replace(CR, r'~\\\\' + CR).replace(' ', '~')\n1966         return text\n1967 \n1968     def encode_uri(self, text: str) -> str:\n1969         # TODO: it is probably wrong that this uses texescape.escape()\n1970         #       this must be checked against hyperref package exact dealings\n1971         #       mainly, %, #, {, } and \\ need escaping via a \\ escape\n1972         # in \\href, the tilde is allowed and must be represented literally\n1973         return self.encode(text).replace(r'\\textasciitilde{}', '~').\\\n1974             replace(r'\\sphinxhyphen{}', '-').\\\n1975             replace(r'\\textquotesingle{}', \"'\")\n1976 \n1977     def visit_Text(self, node: Text) -> None:\n1978         text = self.encode(node.astext())\n1979         self.body.append(text)\n1980 \n1981     def depart_Text(self, node: Text) -> None:\n1982         pass\n1983 \n1984     def visit_comment(self, node: Element) -> None:\n1985         raise nodes.SkipNode\n1986 \n1987     def visit_meta(self, node: Element) -> None:\n1988         # only valid for HTML\n1989         raise nodes.SkipNode\n1990 \n1991     def visit_system_message(self, node: Element) -> None:\n1992         pass\n1993 \n1994     def depart_system_message(self, node: Element) -> None:\n1995         self.body.append(CR)\n1996 \n1997     def visit_math(self, node: Element) -> None:\n1998         if self.in_title:\n1999             self.body.append(r'\\protect\\(%s\\protect\\)' % node.astext())\n2000         else:\n2001             self.body.append(r'\\(%s\\)' % node.astext())\n2002         raise nodes.SkipNode\n2003 \n2004     def visit_math_block(self, node: Element) -> None:\n2005         if node.get('label'):\n2006             label = \"equation:%s:%s\" % (node['docname'], node['label'])\n2007         else:\n2008             label = None\n2009 \n2010         if node.get('nowrap'):\n2011             if label:\n2012                 self.body.append(r'\\label{%s}' % label)\n2013             self.body.append(node.astext())\n2014         else:\n2015             from sphinx.util.math import wrap_displaymath\n2016             self.body.append(wrap_displaymath(node.astext(), label,\n2017                                               self.config.math_number_all))\n2018         raise nodes.SkipNode\n2019 \n2020     def visit_math_reference(self, node: Element) -> None:\n2021         label = \"equation:%s:%s\" % (node['docname'], node['target'])\n2022         eqref_format = self.config.math_eqref_format\n2023         if eqref_format:\n2024             try:\n2025                 ref = r'\\ref{%s}' % label\n2026                 self.body.append(eqref_format.format(number=ref))\n2027             except KeyError as exc:\n2028                 logger.warning(__('Invalid math_eqref_format: %r'), exc,\n2029                                location=node)\n2030                 self.body.append(r'\\eqref{%s}' % label)\n2031         else:\n2032             self.body.append(r'\\eqref{%s}' % label)\n2033 \n2034     def depart_math_reference(self, node: Element) -> None:\n2035         pass\n2036 \n2037     def unknown_visit(self, node: Node) -> None:\n2038         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)\n2039 \n2040     @property\n2041     def docclasses(self) -> Tuple[str, str]:\n2042         \"\"\"Prepends prefix to sphinx document classes\"\"\"\n2043         warnings.warn('LaTeXWriter.docclasses() is deprecated.',\n2044                       RemovedInSphinx70Warning, stacklevel=2)\n2045         return ('howto', 'manual')\n2046 \n2047 \n2048 # FIXME: Workaround to avoid circular import\n2049 # refs: https://github.com/sphinx-doc/sphinx/issues/5433\n2050 from sphinx.builders.latex.nodes import ( # NOQA isort:skip\n2051     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,\n2052 )\n",
        "intended_behavior": "This file should include a method or modify an existing method to ensure that glossary terms and similarly formatted items are separated by appropriate LaTeX commands to enforce a newline where expected. The intended behavior is to preserve glossary term separations in such a way that when converted to LaTeX, the output mimics the separation seen in HTML and other formats, without introducing undue vertical whitespace for grouped terms. This could involve checking for glossary term definitions and applying a LaTeX newline command (\\ or \\par) at the correct places while preserving existing functionality for handling other elements within .rst files. The code should ensure no unintended side effects on the rest of the LaTeX document's formatting."
    },
    {
        "rel_file_path": "sphinx/domains/std.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/domains/std.py",
        "start": 1,
        "end": 1132,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.domains.std\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     The standard domain.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import unicodedata\n13 from copy import copy\n14 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterable, Iterator, List, Optional,\n15                     Tuple, Type, Union, cast)\n16 \n17 from docutils import nodes\n18 from docutils.nodes import Element, Node, system_message\n19 from docutils.parsers.rst import Directive, directives\n20 from docutils.statemachine import StringList\n21 \n22 from sphinx import addnodes\n23 from sphinx.addnodes import desc_signature, pending_xref\n24 from sphinx.directives import ObjectDescription\n25 from sphinx.domains import Domain, ObjType\n26 from sphinx.locale import _, __\n27 from sphinx.roles import XRefRole\n28 from sphinx.util import docname_join, logging, ws_re\n29 from sphinx.util.docutils import SphinxDirective\n30 from sphinx.util.nodes import clean_astext, make_id, make_refnode\n31 from sphinx.util.typing import OptionSpec, RoleFunction\n32 \n33 if TYPE_CHECKING:\n34     from sphinx.application import Sphinx\n35     from sphinx.builders import Builder\n36     from sphinx.environment import BuildEnvironment\n37 \n38 logger = logging.getLogger(__name__)\n39 \n40 \n41 # RE for option descriptions\n42 option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n43 # RE for grammar tokens\n44 token_re = re.compile(r'`((~?\\w*:)?\\w+)`', re.U)\n45 \n46 \n47 class GenericObject(ObjectDescription[str]):\n48     \"\"\"\n49     A generic x-ref directive registered with Sphinx.add_object_type().\n50     \"\"\"\n51     indextemplate: str = ''\n52     parse_node: Callable[[\"GenericObject\", \"BuildEnvironment\", str, desc_signature], str] = None  # NOQA\n53 \n54     def handle_signature(self, sig: str, signode: desc_signature) -> str:\n55         if self.parse_node:\n56             name = self.parse_node(self.env, sig, signode)\n57         else:\n58             signode.clear()\n59             signode += addnodes.desc_name(sig, sig)\n60             # normalize whitespace like XRefRole does\n61             name = ws_re.sub(' ', sig)\n62         return name\n63 \n64     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:\n65         node_id = make_id(self.env, self.state.document, self.objtype, name)\n66         signode['ids'].append(node_id)\n67 \n68         # Assign old styled node_id not to break old hyperlinks (if possible)\n69         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n70         old_node_id = self.make_old_id(name)\n71         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:\n72             signode['ids'].append(old_node_id)\n73 \n74         self.state.document.note_explicit_target(signode)\n75 \n76         if self.indextemplate:\n77             colon = self.indextemplate.find(':')\n78             if colon != -1:\n79                 indextype = self.indextemplate[:colon].strip()\n80                 indexentry = self.indextemplate[colon + 1:].strip() % (name,)\n81             else:\n82                 indextype = 'single'\n83                 indexentry = self.indextemplate % (name,)\n84             self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))\n85 \n86         std = cast(StandardDomain, self.env.get_domain('std'))\n87         std.note_object(self.objtype, name, node_id, location=signode)\n88 \n89     def make_old_id(self, name: str) -> str:\n90         \"\"\"Generate old styled node_id for generic objects.\n91 \n92         .. note:: Old Styled node_id was used until Sphinx-3.0.\n93                   This will be removed in Sphinx-5.0.\n94         \"\"\"\n95         return self.objtype + '-' + name\n96 \n97 \n98 class EnvVar(GenericObject):\n99     indextemplate = _('environment variable; %s')\n100 \n101 \n102 class EnvVarXRefRole(XRefRole):\n103     \"\"\"\n104     Cross-referencing role for environment variables (adds an index entry).\n105     \"\"\"\n106 \n107     def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n108                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n109         if not is_ref:\n110             return [node], []\n111         varname = node['reftarget']\n112         tgtid = 'index-%s' % env.new_serialno('index')\n113         indexnode = addnodes.index()\n114         indexnode['entries'] = [\n115             ('single', varname, tgtid, '', None),\n116             ('single', _('environment variable; %s') % varname, tgtid, '', None)\n117         ]\n118         targetnode = nodes.target('', '', ids=[tgtid])\n119         document.note_explicit_target(targetnode)\n120         return [indexnode, targetnode, node], []\n121 \n122 \n123 class Target(SphinxDirective):\n124     \"\"\"\n125     Generic target for user-defined cross-reference types.\n126     \"\"\"\n127     indextemplate = ''\n128 \n129     has_content = False\n130     required_arguments = 1\n131     optional_arguments = 0\n132     final_argument_whitespace = True\n133     option_spec: OptionSpec = {}\n134 \n135     def run(self) -> List[Node]:\n136         # normalize whitespace in fullname like XRefRole does\n137         fullname = ws_re.sub(' ', self.arguments[0].strip())\n138         node_id = make_id(self.env, self.state.document, self.name, fullname)\n139         node = nodes.target('', '', ids=[node_id])\n140         self.set_source_info(node)\n141 \n142         # Assign old styled node_id not to break old hyperlinks (if possible)\n143         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n144         old_node_id = self.make_old_id(fullname)\n145         if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:\n146             node['ids'].append(old_node_id)\n147 \n148         self.state.document.note_explicit_target(node)\n149         ret: List[Node] = [node]\n150         if self.indextemplate:\n151             indexentry = self.indextemplate % (fullname,)\n152             indextype = 'single'\n153             colon = indexentry.find(':')\n154             if colon != -1:\n155                 indextype = indexentry[:colon].strip()\n156                 indexentry = indexentry[colon + 1:].strip()\n157             inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])\n158             ret.insert(0, inode)\n159         name = self.name\n160         if ':' in self.name:\n161             _, name = self.name.split(':', 1)\n162 \n163         std = cast(StandardDomain, self.env.get_domain('std'))\n164         std.note_object(name, fullname, node_id, location=node)\n165 \n166         return ret\n167 \n168     def make_old_id(self, name: str) -> str:\n169         \"\"\"Generate old styled node_id for targets.\n170 \n171         .. note:: Old Styled node_id was used until Sphinx-3.0.\n172                   This will be removed in Sphinx-5.0.\n173         \"\"\"\n174         return self.name + '-' + name\n175 \n176 \n177 class Cmdoption(ObjectDescription[str]):\n178     \"\"\"\n179     Description of a command-line option (.. option).\n180     \"\"\"\n181 \n182     def handle_signature(self, sig: str, signode: desc_signature) -> str:\n183         \"\"\"Transform an option description into RST nodes.\"\"\"\n184         count = 0\n185         firstname = ''\n186         for potential_option in sig.split(', '):\n187             potential_option = potential_option.strip()\n188             m = option_desc_re.match(potential_option)\n189             if not m:\n190                 logger.warning(__('Malformed option description %r, should '\n191                                   'look like \"opt\", \"-opt args\", \"--opt args\", '\n192                                   '\"/opt args\" or \"+opt args\"'), potential_option,\n193                                location=signode)\n194                 continue\n195             optname, args = m.groups()\n196             if optname.endswith('[') and args.endswith(']'):\n197                 # optional value surrounded by brackets (ex. foo[=bar])\n198                 optname = optname[:-1]\n199                 args = '[' + args\n200 \n201             if count:\n202                 signode += addnodes.desc_addname(', ', ', ')\n203             signode += addnodes.desc_name(optname, optname)\n204             signode += addnodes.desc_addname(args, args)\n205             if not count:\n206                 firstname = optname\n207                 signode['allnames'] = [optname]\n208             else:\n209                 signode['allnames'].append(optname)\n210             count += 1\n211         if not firstname:\n212             raise ValueError\n213         return firstname\n214 \n215     def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:\n216         currprogram = self.env.ref_context.get('std:program')\n217         for optname in signode.get('allnames', []):\n218             prefixes = ['cmdoption']\n219             if currprogram:\n220                 prefixes.append(currprogram)\n221             if not optname.startswith(('-', '/')):\n222                 prefixes.append('arg')\n223             prefix = '-'.join(prefixes)\n224             node_id = make_id(self.env, self.state.document, prefix, optname)\n225             signode['ids'].append(node_id)\n226 \n227             old_node_id = self.make_old_id(prefix, optname)\n228             if old_node_id not in self.state.document.ids and \\\n229                old_node_id not in signode['ids']:\n230                 signode['ids'].append(old_node_id)\n231 \n232         self.state.document.note_explicit_target(signode)\n233 \n234         domain = cast(StandardDomain, self.env.get_domain('std'))\n235         for optname in signode.get('allnames', []):\n236             domain.add_program_option(currprogram, optname,\n237                                       self.env.docname, signode['ids'][0])\n238 \n239         # create an index entry\n240         if currprogram:\n241             descr = _('%s command line option') % currprogram\n242         else:\n243             descr = _('command line option')\n244         for option in sig.split(', '):\n245             entry = '; '.join([descr, option])\n246             self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))\n247 \n248     def make_old_id(self, prefix: str, optname: str) -> str:\n249         \"\"\"Generate old styled node_id for cmdoption.\n250 \n251         .. note:: Old Styled node_id was used until Sphinx-3.0.\n252                   This will be removed in Sphinx-5.0.\n253         \"\"\"\n254         return nodes.make_id(prefix + '-' + optname)\n255 \n256 \n257 class Program(SphinxDirective):\n258     \"\"\"\n259     Directive to name the program for which options are documented.\n260     \"\"\"\n261 \n262     has_content = False\n263     required_arguments = 1\n264     optional_arguments = 0\n265     final_argument_whitespace = True\n266     option_spec: OptionSpec = {}\n267 \n268     def run(self) -> List[Node]:\n269         program = ws_re.sub('-', self.arguments[0].strip())\n270         if program == 'None':\n271             self.env.ref_context.pop('std:program', None)\n272         else:\n273             self.env.ref_context['std:program'] = program\n274         return []\n275 \n276 \n277 class OptionXRefRole(XRefRole):\n278     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n279                      title: str, target: str) -> Tuple[str, str]:\n280         refnode['std:program'] = env.ref_context.get('std:program')\n281         return title, target\n282 \n283 \n284 def split_term_classifiers(line: str) -> List[Optional[str]]:\n285     # split line into a term and classifiers. if no classifier, None is used..\n286     parts: List[Optional[str]] = re.split(' +: +', line) + [None]\n287     return parts\n288 \n289 \n290 def make_glossary_term(env: \"BuildEnvironment\", textnodes: Iterable[Node], index_key: str,\n291                        source: str, lineno: int, node_id: str, document: nodes.document\n292                        ) -> nodes.term:\n293     # get a text-only representation of the term and register it\n294     # as a cross-reference target\n295     term = nodes.term('', '', *textnodes)\n296     term.source = source\n297     term.line = lineno\n298     termtext = term.astext()\n299 \n300     if node_id:\n301         # node_id is given from outside (mainly i18n module), use it forcedly\n302         term['ids'].append(node_id)\n303     else:\n304         node_id = make_id(env, document, 'term', termtext)\n305         term['ids'].append(node_id)\n306         document.note_explicit_target(term)\n307 \n308     std = cast(StandardDomain, env.get_domain('std'))\n309     std._note_term(termtext, node_id, location=term)\n310 \n311     # add an index entry too\n312     indexnode = addnodes.index()\n313     indexnode['entries'] = [('single', termtext, node_id, 'main', index_key)]\n314     indexnode.source, indexnode.line = term.source, term.line\n315     term.append(indexnode)\n316 \n317     return term\n318 \n319 \n320 class Glossary(SphinxDirective):\n321     \"\"\"\n322     Directive to create a glossary with cross-reference targets for :term:\n323     roles.\n324     \"\"\"\n325 \n326     has_content = True\n327     required_arguments = 0\n328     optional_arguments = 0\n329     final_argument_whitespace = False\n330     option_spec: OptionSpec = {\n331         'sorted': directives.flag,\n332     }\n333 \n334     def run(self) -> List[Node]:\n335         node = addnodes.glossary()\n336         node.document = self.state.document\n337 \n338         # This directive implements a custom format of the reST definition list\n339         # that allows multiple lines of terms before the definition.  This is\n340         # easy to parse since we know that the contents of the glossary *must\n341         # be* a definition list.\n342 \n343         # first, collect single entries\n344         entries: List[Tuple[List[Tuple[str, str, int]], StringList]] = []\n345         in_definition = True\n346         in_comment = False\n347         was_empty = True\n348         messages: List[Node] = []\n349         for line, (source, lineno) in zip(self.content, self.content.items):\n350             # empty line -> add to last definition\n351             if not line:\n352                 if in_definition and entries:\n353                     entries[-1][1].append('', source, lineno)\n354                 was_empty = True\n355                 continue\n356             # unindented line -> a term\n357             if line and not line[0].isspace():\n358                 # enable comments\n359                 if line.startswith('.. '):\n360                     in_comment = True\n361                     continue\n362                 else:\n363                     in_comment = False\n364 \n365                 # first term of definition\n366                 if in_definition:\n367                     if not was_empty:\n368                         messages.append(self.state.reporter.warning(\n369                             _('glossary term must be preceded by empty line'),\n370                             source=source, line=lineno))\n371                     entries.append(([(line, source, lineno)], StringList()))\n372                     in_definition = False\n373                 # second term and following\n374                 else:\n375                     if was_empty:\n376                         messages.append(self.state.reporter.warning(\n377                             _('glossary terms must not be separated by empty lines'),\n378                             source=source, line=lineno))\n379                     if entries:\n380                         entries[-1][0].append((line, source, lineno))\n381                     else:\n382                         messages.append(self.state.reporter.warning(\n383                             _('glossary seems to be misformatted, check indentation'),\n384                             source=source, line=lineno))\n385             elif in_comment:\n386                 pass\n387             else:\n388                 if not in_definition:\n389                     # first line of definition, determines indentation\n390                     in_definition = True\n391                     indent_len = len(line) - len(line.lstrip())\n392                 if entries:\n393                     entries[-1][1].append(line[indent_len:], source, lineno)\n394                 else:\n395                     messages.append(self.state.reporter.warning(\n396                         _('glossary seems to be misformatted, check indentation'),\n397                         source=source, line=lineno))\n398             was_empty = False\n399 \n400         # now, parse all the entries into a big definition list\n401         items = []\n402         for terms, definition in entries:\n403             termtexts: List[str] = []\n404             termnodes: List[Node] = []\n405             system_messages: List[Node] = []\n406             for line, source, lineno in terms:\n407                 parts = split_term_classifiers(line)\n408                 # parse the term with inline markup\n409                 # classifiers (parts[1:]) will not be shown on doctree\n410                 textnodes, sysmsg = self.state.inline_text(parts[0], lineno)\n411 \n412                 # use first classifier as a index key\n413                 term = make_glossary_term(self.env, textnodes, parts[1], source, lineno,\n414                                           node_id=None, document=self.state.document)\n415                 term.rawsource = line\n416                 system_messages.extend(sysmsg)\n417                 termtexts.append(term.astext())\n418                 termnodes.append(term)\n419 \n420             termnodes.extend(system_messages)\n421 \n422             defnode = nodes.definition()\n423             if definition:\n424                 self.state.nested_parse(definition, definition.items[0][1],\n425                                         defnode)\n426             termnodes.append(defnode)\n427             items.append((termtexts,\n428                           nodes.definition_list_item('', *termnodes)))\n429 \n430         if 'sorted' in self.options:\n431             items.sort(key=lambda x:\n432                        unicodedata.normalize('NFD', x[0][0].lower()))\n433 \n434         dlist = nodes.definition_list()\n435         dlist['classes'].append('glossary')\n436         dlist.extend(item[1] for item in items)\n437         node += dlist\n438         return messages + [node]\n439 \n440 \n441 def token_xrefs(text: str, productionGroup: str = '') -> List[Node]:\n442     if len(productionGroup) != 0:\n443         productionGroup += ':'\n444     retnodes: List[Node] = []\n445     pos = 0\n446     for m in token_re.finditer(text):\n447         if m.start() > pos:\n448             txt = text[pos:m.start()]\n449             retnodes.append(nodes.Text(txt, txt))\n450         token = m.group(1)\n451         if ':' in token:\n452             if token[0] == '~':\n453                 _, title = token.split(':')\n454                 target = token[1:]\n455             elif token[0] == ':':\n456                 title = token[1:]\n457                 target = title\n458             else:\n459                 title = token\n460                 target = token\n461         else:\n462             title = token\n463             target = productionGroup + token\n464         refnode = pending_xref(title, reftype='token', refdomain='std',\n465                                reftarget=target)\n466         refnode += nodes.literal(token, title, classes=['xref'])\n467         retnodes.append(refnode)\n468         pos = m.end()\n469     if pos < len(text):\n470         retnodes.append(nodes.Text(text[pos:], text[pos:]))\n471     return retnodes\n472 \n473 \n474 class ProductionList(SphinxDirective):\n475     \"\"\"\n476     Directive to list grammar productions.\n477     \"\"\"\n478 \n479     has_content = False\n480     required_arguments = 1\n481     optional_arguments = 0\n482     final_argument_whitespace = True\n483     option_spec: OptionSpec = {}\n484 \n485     def run(self) -> List[Node]:\n486         domain = cast(StandardDomain, self.env.get_domain('std'))\n487         node: Element = addnodes.productionlist()\n488         self.set_source_info(node)\n489         # The backslash handling is from ObjectDescription.get_signatures\n490         nl_escape_re = re.compile(r'\\\\\\n')\n491         lines = nl_escape_re.sub('', self.arguments[0]).split('\\n')\n492 \n493         productionGroup = \"\"\n494         i = 0\n495         for rule in lines:\n496             if i == 0 and ':' not in rule:\n497                 productionGroup = rule.strip()\n498                 continue\n499             i += 1\n500             try:\n501                 name, tokens = rule.split(':', 1)\n502             except ValueError:\n503                 break\n504             subnode = addnodes.production(rule)\n505             name = name.strip()\n506             subnode['tokenname'] = name\n507             if subnode['tokenname']:\n508                 prefix = 'grammar-token-%s' % productionGroup\n509                 node_id = make_id(self.env, self.state.document, prefix, name)\n510                 subnode['ids'].append(node_id)\n511 \n512                 # Assign old styled node_id not to break old hyperlinks (if possible)\n513                 # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n514                 old_node_id = self.make_old_id(name)\n515                 if (old_node_id not in self.state.document.ids and\n516                         old_node_id not in subnode['ids']):\n517                     subnode['ids'].append(old_node_id)\n518 \n519                 self.state.document.note_implicit_target(subnode, subnode)\n520 \n521                 if len(productionGroup) != 0:\n522                     objName = \"%s:%s\" % (productionGroup, name)\n523                 else:\n524                     objName = name\n525                 domain.note_object('token', objName, node_id, location=node)\n526             subnode.extend(token_xrefs(tokens, productionGroup))\n527             node.append(subnode)\n528         return [node]\n529 \n530     def make_old_id(self, token: str) -> str:\n531         \"\"\"Generate old styled node_id for tokens.\n532 \n533         .. note:: Old Styled node_id was used until Sphinx-3.0.\n534                   This will be removed in Sphinx-5.0.\n535         \"\"\"\n536         return nodes.make_id('grammar-token-' + token)\n537 \n538 \n539 class TokenXRefRole(XRefRole):\n540     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n541                      title: str, target: str) -> Tuple[str, str]:\n542         target = target.lstrip('~')  # a title-specific thing\n543         if not self.has_explicit_title and title[0] == '~':\n544             if ':' in title:\n545                 _, title = title.split(':')\n546             else:\n547                 title = title[1:]\n548         return title, target\n549 \n550 \n551 class StandardDomain(Domain):\n552     \"\"\"\n553     Domain for all objects that don't fit into another domain or are added\n554     via the application interface.\n555     \"\"\"\n556 \n557     name = 'std'\n558     label = 'Default'\n559 \n560     object_types: Dict[str, ObjType] = {\n561         'term': ObjType(_('glossary term'), 'term', searchprio=-1),\n562         'token': ObjType(_('grammar token'), 'token', searchprio=-1),\n563         'label': ObjType(_('reference label'), 'ref', 'keyword',\n564                          searchprio=-1),\n565         'envvar': ObjType(_('environment variable'), 'envvar'),\n566         'cmdoption': ObjType(_('program option'), 'option'),\n567         'doc': ObjType(_('document'), 'doc', searchprio=-1)\n568     }\n569 \n570     directives: Dict[str, Type[Directive]] = {\n571         'program': Program,\n572         'cmdoption': Cmdoption,  # old name for backwards compatibility\n573         'option': Cmdoption,\n574         'envvar': EnvVar,\n575         'glossary': Glossary,\n576         'productionlist': ProductionList,\n577     }\n578     roles: Dict[str, Union[RoleFunction, XRefRole]] = {\n579         'option':  OptionXRefRole(warn_dangling=True),\n580         'envvar':  EnvVarXRefRole(),\n581         # links to tokens in grammar productions\n582         'token':   TokenXRefRole(),\n583         # links to terms in glossary\n584         'term':    XRefRole(innernodeclass=nodes.inline,\n585                             warn_dangling=True),\n586         # links to headings or arbitrary labels\n587         'ref':     XRefRole(lowercase=True, innernodeclass=nodes.inline,\n588                             warn_dangling=True),\n589         # links to labels of numbered figures, tables and code-blocks\n590         'numref':  XRefRole(lowercase=True,\n591                             warn_dangling=True),\n592         # links to labels, without a different title\n593         'keyword': XRefRole(warn_dangling=True),\n594         # links to documents\n595         'doc':     XRefRole(warn_dangling=True, innernodeclass=nodes.inline),\n596     }\n597 \n598     initial_data = {\n599         'progoptions': {},      # (program, name) -> docname, labelid\n600         'objects': {},          # (type, name) -> docname, labelid\n601         'labels': {             # labelname -> docname, labelid, sectionname\n602             'genindex': ('genindex', '', _('Index')),\n603             'modindex': ('py-modindex', '', _('Module Index')),\n604             'search':   ('search', '', _('Search Page')),\n605         },\n606         'anonlabels': {         # labelname -> docname, labelid\n607             'genindex': ('genindex', ''),\n608             'modindex': ('py-modindex', ''),\n609             'search':   ('search', ''),\n610         },\n611     }\n612 \n613     dangling_warnings = {\n614         'term': 'term not in glossary: %(target)s',\n615         'numref':  'undefined label: %(target)s',\n616         'keyword': 'unknown keyword: %(target)s',\n617         'doc': 'unknown document: %(target)s',\n618         'option': 'unknown option: %(target)s',\n619     }\n620 \n621     # node_class -> (figtype, title_getter)\n622     enumerable_nodes: Dict[Type[Node], Tuple[str, Optional[Callable]]] = {\n623         nodes.figure: ('figure', None),\n624         nodes.table: ('table', None),\n625         nodes.container: ('code-block', None),\n626     }\n627 \n628     def __init__(self, env: \"BuildEnvironment\") -> None:\n629         super().__init__(env)\n630 \n631         # set up enumerable nodes\n632         self.enumerable_nodes = copy(self.enumerable_nodes)  # create a copy for this instance\n633         for node, settings in env.app.registry.enumerable_nodes.items():\n634             self.enumerable_nodes[node] = settings\n635 \n636     def note_hyperlink_target(self, name: str, docname: str, node_id: str,\n637                               title: str = '') -> None:\n638         \"\"\"Add a hyperlink target for cross reference.\n639 \n640         .. warning::\n641 \n642            This is only for internal use.  Please don't use this from your extension.\n643            ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to\n644            add a hyperlink target to the document.\n645 \n646            This only adds a hyperlink target to the StandardDomain.  And this does not add a\n647            node_id to node.  Therefore, it is very fragile to calling this without\n648            understanding hyperlink target framework in both docutils and Sphinx.\n649 \n650         .. versionadded:: 3.0\n651         \"\"\"\n652         if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):\n653             logger.warning(__('duplicate label %s, other instance in %s'),\n654                            name, self.env.doc2path(self.anonlabels[name][0]))\n655 \n656         self.anonlabels[name] = (docname, node_id)\n657         if title:\n658             self.labels[name] = (docname, node_id, title)\n659 \n660     @property\n661     def objects(self) -> Dict[Tuple[str, str], Tuple[str, str]]:\n662         return self.data.setdefault('objects', {})  # (objtype, name) -> docname, labelid\n663 \n664     def note_object(self, objtype: str, name: str, labelid: str, location: Any = None\n665                     ) -> None:\n666         \"\"\"Note a generic object for cross reference.\n667 \n668         .. versionadded:: 3.0\n669         \"\"\"\n670         if (objtype, name) in self.objects:\n671             docname = self.objects[objtype, name][0]\n672             logger.warning(__('duplicate %s description of %s, other instance in %s'),\n673                            objtype, name, docname, location=location)\n674         self.objects[objtype, name] = (self.env.docname, labelid)\n675 \n676     @property\n677     def _terms(self) -> Dict[str, Tuple[str, str]]:\n678         \"\"\".. note:: Will be removed soon. internal use only.\"\"\"\n679         return self.data.setdefault('terms', {})  # (name) -> docname, labelid\n680 \n681     def _note_term(self, term: str, labelid: str, location: Any = None) -> None:\n682         \"\"\"Note a term for cross reference.\n683 \n684         .. note:: Will be removed soon. internal use only.\n685         \"\"\"\n686         self.note_object('term', term, labelid, location)\n687 \n688         self._terms[term.lower()] = (self.env.docname, labelid)\n689 \n690     @property\n691     def progoptions(self) -> Dict[Tuple[str, str], Tuple[str, str]]:\n692         return self.data.setdefault('progoptions', {})  # (program, name) -> docname, labelid\n693 \n694     @property\n695     def labels(self) -> Dict[str, Tuple[str, str, str]]:\n696         return self.data.setdefault('labels', {})  # labelname -> docname, labelid, sectionname\n697 \n698     @property\n699     def anonlabels(self) -> Dict[str, Tuple[str, str]]:\n700         return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid\n701 \n702     def clear_doc(self, docname: str) -> None:\n703         key: Any = None\n704         for key, (fn, _l) in list(self.progoptions.items()):\n705             if fn == docname:\n706                 del self.progoptions[key]\n707         for key, (fn, _l) in list(self.objects.items()):\n708             if fn == docname:\n709                 del self.objects[key]\n710         for key, (fn, _l) in list(self._terms.items()):\n711             if fn == docname:\n712                 del self._terms[key]\n713         for key, (fn, _l, _l) in list(self.labels.items()):\n714             if fn == docname:\n715                 del self.labels[key]\n716         for key, (fn, _l) in list(self.anonlabels.items()):\n717             if fn == docname:\n718                 del self.anonlabels[key]\n719 \n720     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n721         # XXX duplicates?\n722         for key, data in otherdata['progoptions'].items():\n723             if data[0] in docnames:\n724                 self.progoptions[key] = data\n725         for key, data in otherdata['objects'].items():\n726             if data[0] in docnames:\n727                 self.objects[key] = data\n728         for key, data in otherdata['terms'].items():\n729             if data[0] in docnames:\n730                 self._terms[key] = data\n731         for key, data in otherdata['labels'].items():\n732             if data[0] in docnames:\n733                 self.labels[key] = data\n734         for key, data in otherdata['anonlabels'].items():\n735             if data[0] in docnames:\n736                 self.anonlabels[key] = data\n737 \n738     def process_doc(self, env: \"BuildEnvironment\", docname: str, document: nodes.document) -> None:  # NOQA\n739         for name, explicit in document.nametypes.items():\n740             if not explicit:\n741                 continue\n742             labelid = document.nameids[name]\n743             if labelid is None:\n744                 continue\n745             node = document.ids[labelid]\n746             if isinstance(node, nodes.target) and 'refid' in node:\n747                 # indirect hyperlink targets\n748                 node = document.ids.get(node['refid'])\n749                 labelid = node['names'][0]\n750             if (node.tagname == 'footnote' or\n751                     'refuri' in node or\n752                     node.tagname.startswith('desc_')):\n753                 # ignore footnote labels, labels automatically generated from a\n754                 # link and object descriptions\n755                 continue\n756             if name in self.labels:\n757                 logger.warning(__('duplicate label %s, other instance in %s'),\n758                                name, env.doc2path(self.labels[name][0]),\n759                                location=node)\n760             self.anonlabels[name] = docname, labelid\n761             if node.tagname == 'section':\n762                 title = cast(nodes.title, node[0])\n763                 sectname = clean_astext(title)\n764             elif node.tagname == 'rubric':\n765                 sectname = clean_astext(node)\n766             elif node.tagname == 'target' and len(node) > 0:\n767                 # inline target (ex: blah _`blah` blah)\n768                 sectname = clean_astext(node)\n769             elif self.is_enumerable_node(node):\n770                 sectname = self.get_numfig_title(node)\n771             else:\n772                 toctree = next(iter(node.traverse(addnodes.toctree)), None)\n773                 if toctree and toctree.get('caption'):\n774                     sectname = toctree.get('caption')\n775                 else:\n776                     # anonymous-only labels\n777                     continue\n778             if sectname:\n779                 self.labels[name] = docname, labelid, sectname\n780 \n781     def add_program_option(self, program: str, name: str, docname: str, labelid: str) -> None:\n782         self.progoptions[program, name] = (docname, labelid)\n783 \n784     def build_reference_node(self, fromdocname: str, builder: \"Builder\", docname: str,\n785                              labelid: str, sectname: str, rolename: str, **options: Any\n786                              ) -> Element:\n787         nodeclass = options.pop('nodeclass', nodes.reference)\n788         newnode = nodeclass('', '', internal=True, **options)\n789         innernode = nodes.inline(sectname, sectname)\n790         if innernode.get('classes') is not None:\n791             innernode['classes'].append('std')\n792             innernode['classes'].append('std-' + rolename)\n793         if docname == fromdocname:\n794             newnode['refid'] = labelid\n795         else:\n796             # set more info in contnode; in case the\n797             # get_relative_uri call raises NoUri,\n798             # the builder will then have to resolve these\n799             contnode = pending_xref('')\n800             contnode['refdocname'] = docname\n801             contnode['refsectname'] = sectname\n802             newnode['refuri'] = builder.get_relative_uri(\n803                 fromdocname, docname)\n804             if labelid:\n805                 newnode['refuri'] += '#' + labelid\n806         newnode.append(innernode)\n807         return newnode\n808 \n809     def resolve_xref(self, env: \"BuildEnvironment\", fromdocname: str, builder: \"Builder\",\n810                      typ: str, target: str, node: pending_xref, contnode: Element\n811                      ) -> Optional[Element]:\n812         if typ == 'ref':\n813             resolver = self._resolve_ref_xref\n814         elif typ == 'numref':\n815             resolver = self._resolve_numref_xref\n816         elif typ == 'keyword':\n817             resolver = self._resolve_keyword_xref\n818         elif typ == 'doc':\n819             resolver = self._resolve_doc_xref\n820         elif typ == 'option':\n821             resolver = self._resolve_option_xref\n822         elif typ == 'term':\n823             resolver = self._resolve_term_xref\n824         else:\n825             resolver = self._resolve_obj_xref\n826 \n827         return resolver(env, fromdocname, builder, typ, target, node, contnode)\n828 \n829     def _resolve_ref_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n830                           builder: \"Builder\", typ: str, target: str, node: pending_xref,\n831                           contnode: Element) -> Optional[Element]:\n832         if node['refexplicit']:\n833             # reference to anonymous label; the reference uses\n834             # the supplied link caption\n835             docname, labelid = self.anonlabels.get(target, ('', ''))\n836             sectname = node.astext()\n837         else:\n838             # reference to named label; the final node will\n839             # contain the section name after the label\n840             docname, labelid, sectname = self.labels.get(target, ('', '', ''))\n841         if not docname:\n842             return None\n843 \n844         return self.build_reference_node(fromdocname, builder,\n845                                          docname, labelid, sectname, 'ref')\n846 \n847     def _resolve_numref_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n848                              builder: \"Builder\", typ: str, target: str,\n849                              node: pending_xref, contnode: Element) -> Optional[Element]:\n850         if target in self.labels:\n851             docname, labelid, figname = self.labels.get(target, ('', '', ''))\n852         else:\n853             docname, labelid = self.anonlabels.get(target, ('', ''))\n854             figname = None\n855 \n856         if not docname:\n857             return None\n858 \n859         target_node = env.get_doctree(docname).ids.get(labelid)\n860         figtype = self.get_enumerable_node_type(target_node)\n861         if figtype is None:\n862             return None\n863 \n864         if figtype != 'section' and env.config.numfig is False:\n865             logger.warning(__('numfig is disabled. :numref: is ignored.'), location=node)\n866             return contnode\n867 \n868         try:\n869             fignumber = self.get_fignumber(env, builder, figtype, docname, target_node)\n870             if fignumber is None:\n871                 return contnode\n872         except ValueError:\n873             logger.warning(__(\"Failed to create a cross reference. Any number is not \"\n874                               \"assigned: %s\"),\n875                            labelid, location=node)\n876             return contnode\n877 \n878         try:\n879             if node['refexplicit']:\n880                 title = contnode.astext()\n881             else:\n882                 title = env.config.numfig_format.get(figtype, '')\n883 \n884             if figname is None and '{name}' in title:\n885                 logger.warning(__('the link has no caption: %s'), title, location=node)\n886                 return contnode\n887             else:\n888                 fignum = '.'.join(map(str, fignumber))\n889                 if '{name}' in title or 'number' in title:\n890                     # new style format (cf. \"Fig.{number}\")\n891                     if figname:\n892                         newtitle = title.format(name=figname, number=fignum)\n893                     else:\n894                         newtitle = title.format(number=fignum)\n895                 else:\n896                     # old style format (cf. \"Fig.%s\")\n897                     newtitle = title % fignum\n898         except KeyError as exc:\n899             logger.warning(__('invalid numfig_format: %s (%r)'), title, exc, location=node)\n900             return contnode\n901         except TypeError:\n902             logger.warning(__('invalid numfig_format: %s'), title, location=node)\n903             return contnode\n904 \n905         return self.build_reference_node(fromdocname, builder,\n906                                          docname, labelid, newtitle, 'numref',\n907                                          nodeclass=addnodes.number_reference,\n908                                          title=title)\n909 \n910     def _resolve_keyword_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n911                               builder: \"Builder\", typ: str, target: str,\n912                               node: pending_xref, contnode: Element) -> Optional[Element]:\n913         # keywords are oddballs: they are referenced by named labels\n914         docname, labelid, _ = self.labels.get(target, ('', '', ''))\n915         if not docname:\n916             return None\n917         return make_refnode(builder, fromdocname, docname,\n918                             labelid, contnode)\n919 \n920     def _resolve_doc_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n921                           builder: \"Builder\", typ: str, target: str,\n922                           node: pending_xref, contnode: Element) -> Optional[Element]:\n923         # directly reference to document by source name; can be absolute or relative\n924         refdoc = node.get('refdoc', fromdocname)\n925         docname = docname_join(refdoc, node['reftarget'])\n926         if docname not in env.all_docs:\n927             return None\n928         else:\n929             if node['refexplicit']:\n930                 # reference with explicit title\n931                 caption = node.astext()\n932             else:\n933                 caption = clean_astext(env.titles[docname])\n934             innernode = nodes.inline(caption, caption, classes=['doc'])\n935             return make_refnode(builder, fromdocname, docname, None, innernode)\n936 \n937     def _resolve_option_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n938                              builder: \"Builder\", typ: str, target: str,\n939                              node: pending_xref, contnode: Element) -> Optional[Element]:\n940         progname = node.get('std:program')\n941         target = target.strip()\n942         docname, labelid = self.progoptions.get((progname, target), ('', ''))\n943         if not docname:\n944             commands = []\n945             while ws_re.search(target):\n946                 subcommand, target = ws_re.split(target, 1)\n947                 commands.append(subcommand)\n948                 progname = \"-\".join(commands)\n949 \n950                 docname, labelid = self.progoptions.get((progname, target), ('', ''))\n951                 if docname:\n952                     break\n953             else:\n954                 return None\n955 \n956         return make_refnode(builder, fromdocname, docname,\n957                             labelid, contnode)\n958 \n959     def _resolve_term_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n960                            builder: \"Builder\", typ: str, target: str,\n961                            node: pending_xref, contnode: Element) -> Element:\n962         result = self._resolve_obj_xref(env, fromdocname, builder, typ,\n963                                         target, node, contnode)\n964         if result:\n965             return result\n966         else:\n967             # fallback to case insentive match\n968             if target.lower() in self._terms:\n969                 docname, labelid = self._terms[target.lower()]\n970                 return make_refnode(builder, fromdocname, docname, labelid, contnode)\n971             else:\n972                 return None\n973 \n974     def _resolve_obj_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n975                           builder: \"Builder\", typ: str, target: str,\n976                           node: pending_xref, contnode: Element) -> Optional[Element]:\n977         objtypes = self.objtypes_for_role(typ) or []\n978         for objtype in objtypes:\n979             if (objtype, target) in self.objects:\n980                 docname, labelid = self.objects[objtype, target]\n981                 break\n982         else:\n983             docname, labelid = '', ''\n984         if not docname:\n985             return None\n986         return make_refnode(builder, fromdocname, docname,\n987                             labelid, contnode)\n988 \n989     def resolve_any_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n990                          builder: \"Builder\", target: str, node: pending_xref,\n991                          contnode: Element) -> List[Tuple[str, Element]]:\n992         results: List[Tuple[str, Element]] = []\n993         ltarget = target.lower()  # :ref: lowercases its target automatically\n994         for role in ('ref', 'option'):  # do not try \"keyword\"\n995             res = self.resolve_xref(env, fromdocname, builder, role,\n996                                     ltarget if role == 'ref' else target,\n997                                     node, contnode)\n998             if res:\n999                 results.append(('std:' + role, res))\n1000         # all others\n1001         for objtype in self.object_types:\n1002             key = (objtype, target)\n1003             if objtype == 'term':\n1004                 key = (objtype, ltarget)\n1005             if key in self.objects:\n1006                 docname, labelid = self.objects[key]\n1007                 results.append(('std:' + self.role_for_objtype(objtype),\n1008                                 make_refnode(builder, fromdocname, docname,\n1009                                              labelid, contnode)))\n1010         return results\n1011 \n1012     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:\n1013         # handle the special 'doc' reference here\n1014         for doc in self.env.all_docs:\n1015             yield (doc, clean_astext(self.env.titles[doc]), 'doc', doc, '', -1)\n1016         for (prog, option), info in self.progoptions.items():\n1017             if prog:\n1018                 fullname = \".\".join([prog, option])\n1019                 yield (fullname, fullname, 'cmdoption', info[0], info[1], 1)\n1020             else:\n1021                 yield (option, option, 'cmdoption', info[0], info[1], 1)\n1022         for (type, name), info in self.objects.items():\n1023             yield (name, name, type, info[0], info[1],\n1024                    self.object_types[type].attrs['searchprio'])\n1025         for name, (docname, labelid, sectionname) in self.labels.items():\n1026             yield (name, sectionname, 'label', docname, labelid, -1)\n1027         # add anonymous-only labels as well\n1028         non_anon_labels = set(self.labels)\n1029         for name, (docname, labelid) in self.anonlabels.items():\n1030             if name not in non_anon_labels:\n1031                 yield (name, name, 'label', docname, labelid, -1)\n1032 \n1033     def get_type_name(self, type: ObjType, primary: bool = False) -> str:\n1034         # never prepend \"Default\"\n1035         return type.lname\n1036 \n1037     def is_enumerable_node(self, node: Node) -> bool:\n1038         return node.__class__ in self.enumerable_nodes\n1039 \n1040     def get_numfig_title(self, node: Node) -> Optional[str]:\n1041         \"\"\"Get the title of enumerable nodes to refer them using its title\"\"\"\n1042         if self.is_enumerable_node(node):\n1043             elem = cast(Element, node)\n1044             _, title_getter = self.enumerable_nodes.get(elem.__class__, (None, None))\n1045             if title_getter:\n1046                 return title_getter(elem)\n1047             else:\n1048                 for subnode in elem:\n1049                     if isinstance(subnode, (nodes.caption, nodes.title)):\n1050                         return clean_astext(subnode)\n1051 \n1052         return None\n1053 \n1054     def get_enumerable_node_type(self, node: Node) -> Optional[str]:\n1055         \"\"\"Get type of enumerable nodes.\"\"\"\n1056         def has_child(node: Element, cls: Type) -> bool:\n1057             return any(isinstance(child, cls) for child in node)\n1058 \n1059         if isinstance(node, nodes.section):\n1060             return 'section'\n1061         elif (isinstance(node, nodes.container) and\n1062               'literal_block' in node and\n1063               has_child(node, nodes.literal_block)):\n1064             # given node is a code-block having caption\n1065             return 'code-block'\n1066         else:\n1067             figtype, _ = self.enumerable_nodes.get(node.__class__, (None, None))\n1068             return figtype\n1069 \n1070     def get_fignumber(self, env: \"BuildEnvironment\", builder: \"Builder\",\n1071                       figtype: str, docname: str, target_node: Element) -> Tuple[int, ...]:\n1072         if figtype == 'section':\n1073             if builder.name == 'latex':\n1074                 return tuple()\n1075             elif docname not in env.toc_secnumbers:\n1076                 raise ValueError  # no number assigned\n1077             else:\n1078                 anchorname = '#' + target_node['ids'][0]\n1079                 if anchorname not in env.toc_secnumbers[docname]:\n1080                     # try first heading which has no anchor\n1081                     return env.toc_secnumbers[docname].get('')\n1082                 else:\n1083                     return env.toc_secnumbers[docname].get(anchorname)\n1084         else:\n1085             try:\n1086                 figure_id = target_node['ids'][0]\n1087                 return env.toc_fignumbers[docname][figtype][figure_id]\n1088             except (KeyError, IndexError) as exc:\n1089                 # target_node is found, but fignumber is not assigned.\n1090                 # Maybe it is defined in orphaned document.\n1091                 raise ValueError from exc\n1092 \n1093     def get_full_qualified_name(self, node: Element) -> Optional[str]:\n1094         if node.get('reftype') == 'option':\n1095             progname = node.get('std:program')\n1096             command = ws_re.split(node.get('reftarget'))\n1097             if progname:\n1098                 command.insert(0, progname)\n1099             option = command.pop()\n1100             if command:\n1101                 return '.'.join(['-'.join(command), option])\n1102             else:\n1103                 return None\n1104         else:\n1105             return None\n1106 \n1107 \n1108 def warn_missing_reference(app: \"Sphinx\", domain: Domain, node: pending_xref\n1109                            ) -> Optional[bool]:\n1110     if (domain and domain.name != 'std') or node['reftype'] != 'ref':\n1111         return None\n1112     else:\n1113         target = node['reftarget']\n1114         if target not in domain.anonlabels:  # type: ignore\n1115             msg = __('undefined label: %s')\n1116         else:\n1117             msg = __('Failed to create a cross reference. A title or caption not found: %s')\n1118 \n1119         logger.warning(msg % target, location=node, type='ref', subtype=node['reftype'])\n1120         return True\n1121 \n1122 \n1123 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n1124     app.add_domain(StandardDomain)\n1125     app.connect('warn-missing-reference', warn_missing_reference)\n1126 \n1127     return {\n1128         'version': 'builtin',\n1129         'env_version': 2,\n1130         'parallel_read_safe': True,\n1131         'parallel_write_safe': True,\n1132     }\n",
        "intended_behavior": "This file likely handles the logical structuring or interpretation of standard domain elements, including glossaries. The intended behavior here is to ensure that data structure passed from this processing step to the LaTeX writer (sphinx/writers/latex.py) is correctly formatted or tagged in a way that facilitates the appropriate LaTeX separation of glossary terms. If issues stem from how glossary terms are aggregated or passed along, adjusting this to support clearer separation in LaTeX output is necessary. This might not require adding new methods but rather adjusting existing logic to ensure that groupings of glossary terms are maintained or appropriately flagged for the LaTeX output stage."
    }
]