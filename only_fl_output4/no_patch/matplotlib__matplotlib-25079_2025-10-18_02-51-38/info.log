2025-10-18 02:51:38.486 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 02:51:41.589 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1120, output_tokens=12, cost=0.011560
2025-10-18 02:51:51.635 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1300, output_tokens=490, cost=0.027700
2025-10-18 02:51:54.177 | INFO     | registered non reproducing test 0
2025-10-18 02:52:08.757 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2069, output_tokens=698, cost=0.041630
2025-10-18 02:52:10.163 | INFO     | registered non reproducing test 1
2025-10-18 02:52:27.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2277, output_tokens=760, cost=0.045570
2025-10-18 02:52:28.965 | INFO     | registered non reproducing test 2
2025-10-18 02:52:28.965 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 02:52:28.968 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:52:41.027 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1399, output_tokens=454, cost=0.027610
2025-10-18 02:52:41.036 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:52:44.382 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=808, output_tokens=70, cost=0.010180
2025-10-18 02:52:44.384 | DEBUG    | Extracted a valid json.
2025-10-18 02:52:44.384 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LogNorm\")",
        "search_method_in_class(\"update_scalarmappable\", \"Collection\")",
        "search_class(\"Collection\")",
        "search_method(\"update_scalarmappable\")",
        "search_code(\"__call__\")"
    ],
    "bug_locations": []
}
2025-10-18 02:52:44.661 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 02:52:44.662 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 02:53:07.717 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4851, output_tokens=747, cost=0.070920
2025-10-18 02:53:07.724 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:53:09.334 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5814, output_tokens=34, cost=0.059160
2025-10-18 02:53:09.335 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:53:13.077 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=388, output_tokens=48, cost=0.005320
2025-10-18 02:53:13.085 | DEBUG    | Extracted a valid json.
2025-10-18 02:53:13.085 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method_in_file(\"__call__\", \"lib/matplotlib/colors.py\")", "search_code_in_file(\"LogNorm\", \"lib/matplotlib/colors.py\")"],
    "bug_locations": []
}
2025-10-18 02:53:13.219 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 02:53:13.220 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 02:53:29.153 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=11847, output_tokens=627, cost=0.137280
2025-10-18 02:53:29.165 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:53:43.310 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12690, output_tokens=545, cost=0.143250
2025-10-18 02:53:43.320 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:53:47.602 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=899, output_tokens=182, cost=0.014450
2025-10-18 02:53:47.603 | INFO     | Refactored invocation argument parsing failed on 'search_code("vmin" and "vmax" and "LogNorm")': malformed node or string on line 1: <ast.BoolOp object at 0x73f68b0e4710>
2025-10-18 02:53:47.604 | DEBUG    | Extracted a valid json.
2025-10-18 02:53:47.604 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file(\"LogNorm\", \"lib/matplotlib/colors.py\")",
        "search_method_in_class(\"__call__\", \"LogNorm\")",
        "search_code(\"vmin\" and \"vmax\" and \"LogNorm\")"
    ],
    "bug_locations": [
        {
            "file": "lib/matplotlib/colors.py",
            "class": "LogNorm",
            "method": "__call__",
            "intended_behavior": "The `__call__` method (or equivalent within `LogNorm`) should handle updates to `vmin` and `vmax` safely, ensuring they are positive and `vmin < vmax`. Should validate changes in interactive settings and adjust internal state accordingly. Validation checks specific to `LogNorm` requirements must be included with clear error messaging for invalid configurations."
        }
    ]
}
2025-10-18 02:53:47.609 | INFO     | Refactored invocation argument parsing failed on 'search_code("vmin" and "vmax" and "LogNorm")': malformed node or string on line 1: <ast.BoolOp object at 0x73f68b0e4710>
2025-10-18 02:53:47.644 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 02:53:47.645 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 02:54:05.441 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=13440, output_tokens=717, cost=0.155910
2025-10-18 02:54:05.455 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:54:21.882 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=14373, output_tokens=594, cost=0.161550
2025-10-18 02:54:21.892 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:54:25.922 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=948, output_tokens=179, cost=0.014850
2025-10-18 02:54:25.924 | DEBUG    | Extracted a valid json.
2025-10-18 02:54:25.924 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LogNorm\")",
        "search_method_in_class(\"__init__\", \"LogNorm\")",
        "search_code(\"vmin and vmax\")"
    ],
    "bug_locations": [
        {
            "file": "",
            "class": "matplotlib.colors",
            "method": "LogNorm",
            "intended_behavior": "Ensure that updating the normalization to LogNorm after initial plot creation and colorbar addition does not lead to errors, given valid vmin and vmax values."
        },
        {
            "file": "",
            "class": "matplotlib.colors",
            "method": "",
            "intended_behavior": "Implement or adjust validation logic within LogNorm or related utility functions to accurately assess vmin and vmax values' validity, especially in contexts where these parameters might be updated after initial setting."
        }
    ]
}
2025-10-18 02:54:25.978 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 02:54:25.979 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 02:54:46.171 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=15296, output_tokens=765, cost=0.175910
2025-10-18 02:54:46.183 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 02:55:02.613 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=16277, output_tokens=625, cost=0.181520
2025-10-18 02:55:02.625 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:55:07.563 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=979, output_tokens=223, cost=0.016480
2025-10-18 02:55:07.565 | DEBUG    | Extracted a valid json.
2025-10-18 02:55:07.565 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "lib/matplotlib/colors.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that any updates to `vmin` and `vmax` after the initial setting are validated and processed in a manner that acknowledges the constraints of logarithmic scaling (i.e., both must be positive, and `vmin` must be less than `vmax`). It would involve dynamically recalculating the normalized values and applying them without causing errors under valid configurations."
        },
        {
            "file": "lib/matplotlib/colorbar.py",
            "class": "",
            "method": "",
            "intended_behavior": "When `vmin` and `vmax` are modified, particularly in an interactive setting, the colorbar update mechanism should detect these changes and redraw the colorbar to reflect the new range according to the newly set normalization method. This process should handle logarithmic scaling gracefully, ensuring that the colorbar accurately represents the updated data range."
        }
    ]
}
2025-10-18 02:55:07.577 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A module for converting numbers or color arguments to *RGB* or *RGBA*.
3 
4 *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
5 range 0-1.
6 
7 This module includes functions and classes for color specification conversions,
8 and for mapping numbers to colors in a 1-D array of colors called a colormap.
9 
10 Mapping data onto colors using a colormap typically involves two steps: a data
11 array is first mapped onto the range 0-1 using a subclass of `Normalize`,
12 then this number is mapped to a color using a subclass of `Colormap`.  Two
13 subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
14 piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
15 makes a colormap from a list of colors.
16 
17 .. seealso::
18 
19   :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
20   make colormaps and
21 
22   :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
23 
24   :doc:`/tutorials/colors/colormapnorms` for more details about data
25   normalization
26 
27   More colormaps are available at palettable_.
28 
29 The module also provides functions for checking whether an object can be
30 interpreted as a color (`is_color_like`), for converting such an object
31 to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
32 "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
33 RGBA array (`to_rgba_array`).  Caching is used for efficiency.
34 
35 Colors that Matplotlib recognizes are listed at
36 :doc:`/tutorials/colors/colors`.
37 
38 .. _palettable: https://jiffyclub.github.io/palettable/
39 .. _xkcd color survey: https://xkcd.com/color/rgb/
40 """
41 
42 import base64
43 from collections.abc import Sized, Sequence, Mapping
44 import functools
45 import importlib
46 import inspect
47 import io
48 import itertools
49 from numbers import Number
50 import re
51 from PIL import Image
52 from PIL.PngImagePlugin import PngInfo
53 
54 import matplotlib as mpl
55 import numpy as np
56 from matplotlib import _api, _cm, cbook, scale
57 from ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS
58 
59 
60 class _ColorMapping(dict):
61     def __init__(self, mapping):
62         super().__init__(mapping)
63         self.cache = {}
64 
65     def __setitem__(self, key, value):
66         super().__setitem__(key, value)
67         self.cache.clear()
68 
69     def __delitem__(self, key):
70         super().__delitem__(key)
71         self.cache.clear()
72 
73 
74 _colors_full_map = {}
75 # Set by reverse priority order.
76 _colors_full_map.update(XKCD_COLORS)
77 _colors_full_map.update({k.replace('grey', 'gray'): v
78                          for k, v in XKCD_COLORS.items()
79                          if 'grey' in k})
80 _colors_full_map.update(CSS4_COLORS)
81 _colors_full_map.update(TABLEAU_COLORS)
82 _colors_full_map.update({k.replace('gray', 'grey'): v
83                          for k, v in TABLEAU_COLORS.items()
84                          if 'gray' in k})
85 _colors_full_map.update(BASE_COLORS)
86 _colors_full_map = _ColorMapping(_colors_full_map)
87 
88 _REPR_PNG_SIZE = (512, 64)
89 
90 
91 def get_named_colors_mapping():
92     """Return the global mapping of names to named colors."""
93     return _colors_full_map
94 
95 
96 class ColorSequenceRegistry(Mapping):
97     r"""
98     Container for sequences of colors that are known to Matplotlib by name.
99 
100     The universal registry instance is `matplotlib.color_sequences`. There
101     should be no need for users to instantiate `.ColorSequenceRegistry`
102     themselves.
103 
104     Read access uses a dict-like interface mapping names to lists of colors::
105 
106         import matplotlib as mpl
107         cmap = mpl.color_sequences['tab10']
108 
109     The returned lists are copies, so that their modification does not change
110     the global definition of the color sequence.
111 
112     Additional color sequences can be added via
113     `.ColorSequenceRegistry.register`::
114 
115         mpl.color_sequences.register('rgb', ['r', 'g', 'b'])
116     """
117 
118     _BUILTIN_COLOR_SEQUENCES = {
119         'tab10': _cm._tab10_data,
120         'tab20': _cm._tab20_data,
121         'tab20b': _cm._tab20b_data,
122         'tab20c': _cm._tab20c_data,
123         'Pastel1': _cm._Pastel1_data,
124         'Pastel2': _cm._Pastel2_data,
125         'Paired': _cm._Paired_data,
126         'Accent': _cm._Accent_data,
127         'Dark2': _cm._Dark2_data,
128         'Set1': _cm._Set1_data,
129         'Set2': _cm._Set1_data,
130         'Set3': _cm._Set1_data,
131     }
132 
133     def __init__(self):
134         self._color_sequences = {**self._BUILTIN_COLOR_SEQUENCES}
135 
136     def __getitem__(self, item):
137         try:
138             return list(self._color_sequences[item])
139         except KeyError:
140             raise KeyError(f"{item!r} is not a known color sequence name")
141 
142     def __iter__(self):
143         return iter(self._color_sequences)
144 
145     def __len__(self):
146         return len(self._color_sequences)
147 
148     def __str__(self):
149         return ('ColorSequenceRegistry; available colormaps:\n' +
150                 ', '.join(f"'{name}'" for name in self))
151 
152     def register(self, name, color_list):
153         """
154         Register a new color sequence.
155 
156         The color sequence registry stores a copy of the given *color_list*, so
157         that future changes to the original list do not affect the registered
158         color sequence. Think of this as the registry taking a snapshot
159         of *color_list* at registration.
160 
161         Parameters
162         ----------
163         name : str
164             The name for the color sequence.
165 
166         color_list : list of colors
167             An iterable returning valid Matplotlib colors when iterating over.
168             Note however that the returned color sequence will always be a
169             list regardless of the input type.
170 
171         """
172         if name in self._BUILTIN_COLOR_SEQUENCES:
173             raise ValueError(f"{name!r} is a reserved name for a builtin "
174                              "color sequence")
175 
176         color_list = list(color_list)  # force copy and coerce type to list
177         for color in color_list:
178             try:
179                 to_rgba(color)
180             except ValueError:
181                 raise ValueError(
182                     f"{color!r} is not a valid color specification")
183 
184         self._color_sequences[name] = color_list
185 
186     def unregister(self, name):
187         """
188         Remove a sequence from the registry.
189 
190         You cannot remove built-in color sequences.
191 
192         If the name is not registered, returns with no error.
193         """
194         if name in self._BUILTIN_COLOR_SEQUENCES:
195             raise ValueError(
196                 f"Cannot unregister builtin color sequence {name!r}")
197         self._color_sequences.pop(name, None)
198 
199 
200 _color_sequences = ColorSequenceRegistry()
201 
202 
203 def _sanitize_extrema(ex):
204     if ex is None:
205         return ex
206     try:
207         ret = ex.item()
208     except AttributeError:
209         ret = float(ex)
210     return ret
211 
212 
213 def _is_nth_color(c):
214     """Return whether *c* can be interpreted as an item in the color cycle."""
215     return isinstance(c, str) and re.match(r"\AC[0-9]+\Z", c)
216 
217 
218 def is_color_like(c):
219     """Return whether *c* can be interpreted as an RGB(A) color."""
220     # Special-case nth color syntax because it cannot be parsed during setup.
221     if _is_nth_color(c):
222         return True
223     try:
224         to_rgba(c)
225     except ValueError:
226         return False
227     else:
228         return True
229 
230 
231 def _has_alpha_channel(c):
232     """Return whether *c* is a color with an alpha channel."""
233     # 4-element sequences are interpreted as r, g, b, a
234     return not isinstance(c, str) and len(c) == 4
235 
236 
237 def _check_color_like(**kwargs):
238     """
239     For each *key, value* pair in *kwargs*, check that *value* is color-like.
240     """
241     for k, v in kwargs.items():
242         if not is_color_like(v):
243             raise ValueError(f"{v!r} is not a valid value for {k}")
244 
245 
246 def same_color(c1, c2):
247     """
248     Return whether the colors *c1* and *c2* are the same.
249 
250     *c1*, *c2* can be single colors or lists/arrays of colors.
251     """
252     c1 = to_rgba_array(c1)
253     c2 = to_rgba_array(c2)
254     n1 = max(c1.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem
255     n2 = max(c2.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem
256 
257     if n1 != n2:
258         raise ValueError('Different number of elements passed.')
259     # The following shape test is needed to correctly handle comparisons with
260     # 'none', which results in a shape (0, 4) array and thus cannot be tested
261     # via value comparison.
262     return c1.shape == c2.shape and (c1 == c2).all()
263 
264 
265 def to_rgba(c, alpha=None):
266     """
267     Convert *c* to an RGBA color.
268 
269     Parameters
270     ----------
271     c : Matplotlib color or ``np.ma.masked``
272 
273     alpha : float, optional
274         If *alpha* is given, force the alpha value of the returned RGBA tuple
275         to *alpha*.
276 
277         If None, the alpha value from *c* is used. If *c* does not have an
278         alpha channel, then alpha defaults to 1.
279 
280         *alpha* is ignored for the color value ``"none"`` (case-insensitive),
281         which always maps to ``(0, 0, 0, 0)``.
282 
283     Returns
284     -------
285     tuple
286         Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
287         alpha) can assume values between 0 and 1.
288     """
289     # Special-case nth color syntax because it should not be cached.
290     if _is_nth_color(c):
291         prop_cycler = mpl.rcParams['axes.prop_cycle']
292         colors = prop_cycler.by_key().get('color', ['k'])
293         c = colors[int(c[1:]) % len(colors)]
294     try:
295         rgba = _colors_full_map.cache[c, alpha]
296     except (KeyError, TypeError):  # Not in cache, or unhashable.
297         rgba = None
298     if rgba is None:  # Suppress exception chaining of cache lookup failure.
299         rgba = _to_rgba_no_colorcycle(c, alpha)
300         try:
301             _colors_full_map.cache[c, alpha] = rgba
302         except TypeError:
303             pass
304     return rgba
305 
306 
307 def _to_rgba_no_colorcycle(c, alpha=None):
308     """
309     Convert *c* to an RGBA color, with no support for color-cycle syntax.
310 
311     If *alpha* is given, force the alpha value of the returned RGBA tuple
312     to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha
313     information, or defaults to 1.
314 
315     *alpha* is ignored for the color value ``"none"`` (case-insensitive),
316     which always maps to ``(0, 0, 0, 0)``.
317     """
318     orig_c = c
319     if c is np.ma.masked:
320         return (0., 0., 0., 0.)
321     if isinstance(c, str):
322         if c.lower() == "none":
323             return (0., 0., 0., 0.)
324         # Named color.
325         try:
326             # This may turn c into a non-string, so we check again below.
327             c = _colors_full_map[c]
328         except KeyError:
329             if len(orig_c) != 1:
330                 try:
331                     c = _colors_full_map[c.lower()]
332                 except KeyError:
333                     pass
334     if isinstance(c, str):
335         # hex color in #rrggbb format.
336         match = re.match(r"\A#[a-fA-F0-9]{6}\Z", c)
337         if match:
338             return (tuple(int(n, 16) / 255
339                           for n in [c[1:3], c[3:5], c[5:7]])
340                     + (alpha if alpha is not None else 1.,))
341         # hex color in #rgb format, shorthand for #rrggbb.
342         match = re.match(r"\A#[a-fA-F0-9]{3}\Z", c)
343         if match:
344             return (tuple(int(n, 16) / 255
345                           for n in [c[1]*2, c[2]*2, c[3]*2])
346                     + (alpha if alpha is not None else 1.,))
347         # hex color with alpha in #rrggbbaa format.
348         match = re.match(r"\A#[a-fA-F0-9]{8}\Z", c)
349         if match:
350             color = [int(n, 16) / 255
351                      for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]
352             if alpha is not None:
353                 color[-1] = alpha
354             return tuple(color)
355         # hex color with alpha in #rgba format, shorthand for #rrggbbaa.
356         match = re.match(r"\A#[a-fA-F0-9]{4}\Z", c)
357         if match:
358             color = [int(n, 16) / 255
359                      for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]
360             if alpha is not None:
361                 color[-1] = alpha
362             return tuple(color)
363         # string gray.
364         try:
365             c = float(c)
366         except ValueError:
367             pass
368         else:
369             if not (0 <= c <= 1):
370                 raise ValueError(
371                     f"Invalid string grayscale value {orig_c!r}. "
372                     f"Value must be within 0-1 range")
373             return c, c, c, alpha if alpha is not None else 1.
374         raise ValueError(f"Invalid RGBA argument: {orig_c!r}")
375     # turn 2-D array into 1-D array
376     if isinstance(c, np.ndarray):
377         if c.ndim == 2 and c.shape[0] == 1:
378             c = c.reshape(-1)
379     # tuple color.
380     if not np.iterable(c):
381         raise ValueError(f"Invalid RGBA argument: {orig_c!r}")
382     if len(c) not in [3, 4]:
383         raise ValueError("RGBA sequence should have length 3 or 4")
384     if not all(isinstance(x, Number) for x in c):
385         # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and
386         # `np.array(...).astype(float)` would all convert "0.5" to 0.5.
387         raise ValueError(f"Invalid RGBA argument: {orig_c!r}")
388     # Return a tuple to prevent the cached value from being modified.
389     c = tuple(map(float, c))
390     if len(c) == 3 and alpha is None:
391         alpha = 1
392     if alpha is not None:
393         c = c[:3] + (alpha,)
394     if any(elem < 0 or elem > 1 for elem in c):
395         raise ValueError("RGBA values should be within 0-1 range")
396     return c
397 
398 
399 def to_rgba_array(c, alpha=None):
400     """
401     Convert *c* to a (n, 4) array of RGBA colors.
402 
403     Parameters
404     ----------
405     c : Matplotlib color or array of colors
406         If *c* is a masked array, an `~numpy.ndarray` is returned with a
407         (0, 0, 0, 0) row for each masked value or row in *c*.
408 
409     alpha : float or sequence of floats, optional
410         If *alpha* is given, force the alpha value of the returned RGBA tuple
411         to *alpha*.
412 
413         If None, the alpha value from *c* is used. If *c* does not have an
414         alpha channel, then alpha defaults to 1.
415 
416         *alpha* is ignored for the color value ``"none"`` (case-insensitive),
417         which always maps to ``(0, 0, 0, 0)``.
418 
419         If *alpha* is a sequence and *c* is a single color, *c* will be
420         repeated to match the length of *alpha*.
421 
422     Returns
423     -------
424     array
425         (n, 4) array of RGBA colors,  where each channel (red, green, blue,
426         alpha) can assume values between 0 and 1.
427     """
428     # Special-case inputs that are already arrays, for performance.  (If the
429     # array has the wrong kind or shape, raise the error during one-at-a-time
430     # conversion.)
431     if np.iterable(alpha):
432         alpha = np.asarray(alpha).ravel()
433     if (isinstance(c, np.ndarray) and c.dtype.kind in "if"
434             and c.ndim == 2 and c.shape[1] in [3, 4]):
435         mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None
436         c = np.ma.getdata(c)
437         if np.iterable(alpha):
438             if c.shape[0] == 1 and alpha.shape[0] > 1:
439                 c = np.tile(c, (alpha.shape[0], 1))
440             elif c.shape[0] != alpha.shape[0]:
441                 raise ValueError("The number of colors must match the number"
442                                  " of alpha values if there are more than one"
443                                  " of each.")
444         if c.shape[1] == 3:
445             result = np.column_stack([c, np.zeros(len(c))])
446             result[:, -1] = alpha if alpha is not None else 1.
447         elif c.shape[1] == 4:
448             result = c.copy()
449             if alpha is not None:
450                 result[:, -1] = alpha
451         if mask is not None:
452             result[mask] = 0
453         if np.any((result < 0) | (result > 1)):
454             raise ValueError("RGBA values should be within 0-1 range")
455         return result
456     # Handle single values.
457     # Note that this occurs *after* handling inputs that are already arrays, as
458     # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need
459     # to format the array in the ValueError message(!).
460     if cbook._str_lower_equal(c, "none"):
461         return np.zeros((0, 4), float)
462     try:
463         if np.iterable(alpha):
464             return np.array([to_rgba(c, a) for a in alpha], float)
465         else:
466             return np.array([to_rgba(c, alpha)], float)
467     except (ValueError, TypeError):
468         pass
469 
470     if isinstance(c, str):
471         raise ValueError(f"{c!r} is not a valid color value.")
472 
473     if len(c) == 0:
474         return np.zeros((0, 4), float)
475 
476     # Quick path if the whole sequence can be directly converted to a numpy
477     # array in one shot.
478     if isinstance(c, Sequence):
479         lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}
480         if lens == {3}:
481             rgba = np.column_stack([c, np.ones(len(c))])
482         elif lens == {4}:
483             rgba = np.array(c)
484         else:
485             rgba = np.array([to_rgba(cc) for cc in c])
486     else:
487         rgba = np.array([to_rgba(cc) for cc in c])
488 
489     if alpha is not None:
490         rgba[:, 3] = alpha
491     return rgba
492 
493 
494 def to_rgb(c):
495     """Convert *c* to an RGB color, silently dropping the alpha channel."""
496     return to_rgba(c)[:3]
497 
498 
499 def to_hex(c, keep_alpha=False):
500     """
501     Convert *c* to a hex color.
502 
503     Parameters
504     ----------
505     c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
506 
507     keep_alpha : bool, default: False
508       If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
509 
510     Returns
511     -------
512     str
513       ``#rrggbb`` or ``#rrggbbaa`` hex color string
514     """
515     c = to_rgba(c)
516     if not keep_alpha:
517         c = c[:3]
518     return "#" + "".join(format(round(val * 255), "02x") for val in c)
519 
520 
521 ### Backwards-compatible color-conversion API
522 
523 
524 cnames = CSS4_COLORS
525 hexColorPattern = re.compile(r"\A#[a-fA-F0-9]{6}\Z")
526 rgb2hex = to_hex
527 hex2color = to_rgb
528 
529 
530 class ColorConverter:
531     """
532     A class only kept for backwards compatibility.
533 
534     Its functionality is entirely provided by module-level functions.
535     """
536     colors = _colors_full_map
537     cache = _colors_full_map.cache
538     to_rgb = staticmethod(to_rgb)
539     to_rgba = staticmethod(to_rgba)
540     to_rgba_array = staticmethod(to_rgba_array)
541 
542 
543 colorConverter = ColorConverter()
544 
545 
546 ### End of backwards-compatible color-conversion API
547 
548 
549 def _create_lookup_table(N, data, gamma=1.0):
550     r"""
551     Create an *N* -element 1D lookup table.
552 
553     This assumes a mapping :math:`f : [0, 1] \rightarrow [0, 1]`. The returned
554     data is an array of N values :math:`y = f(x)` where x is sampled from
555     [0, 1].
556 
557     By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The
558     *gamma* correction factor :math:`\gamma` distorts this equidistant
559     sampling by :math:`x \rightarrow x^\gamma`.
560 
561     Parameters
562     ----------
563     N : int
564         The number of elements of the created lookup table; at least 1.
565 
566     data : (M, 3) array-like or callable
567         Defines the mapping :math:`f`.
568 
569         If a (M, 3) array-like, the rows define values (x, y0, y1).  The x
570         values must start with x=0, end with x=1, and all x values be in
571         increasing order.
572 
573         A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range
574         :math:`y^1_{i-1} \ldots y^0_i` by linear interpolation.
575 
576         For the simple case of a y-continuous mapping, y0 and y1 are identical.
577 
578         The two values of y are to allow for discontinuous mapping functions.
579         E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::
580 
581             [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]
582 
583         In the special case of ``N == 1``, by convention the returned value
584         is y0 for x == 1.
585 
586         If *data* is a callable, it must accept and return numpy arrays::
587 
588            data(x : ndarray) -> ndarray
589 
590         and map values between 0 - 1 to 0 - 1.
591 
592     gamma : float
593         Gamma correction factor for input distribution x of the mapping.
594 
595         See also https://en.wikipedia.org/wiki/Gamma_correction.
596 
597     Returns
598     -------
599     array
600         The lookup table where ``lut[x * (N-1)]`` gives the closest value
601         for values of x between 0 and 1.
602 
603     Notes
604     -----
605     This function is internally used for `.LinearSegmentedColormap`.
606     """
607 
608     if callable(data):
609         xind = np.linspace(0, 1, N) ** gamma
610         lut = np.clip(np.array(data(xind), dtype=float), 0, 1)
611         return lut
612 
613     try:
614         adata = np.array(data)
615     except Exception as err:
616         raise TypeError("data must be convertible to an array") from err
617     _api.check_shape((None, 3), data=adata)
618 
619     x = adata[:, 0]
620     y0 = adata[:, 1]
621     y1 = adata[:, 2]
622 
623     if x[0] != 0. or x[-1] != 1.0:
624         raise ValueError(
625             "data mapping points must start with x=0 and end with x=1")
626     if (np.diff(x) < 0).any():
627         raise ValueError("data mapping points must have x in increasing order")
628     # begin generation of lookup table
629     if N == 1:
630         # convention: use the y = f(x=1) value for a 1-element lookup table
631         lut = np.array(y0[-1])
632     else:
633         x = x * (N - 1)
634         xind = (N - 1) * np.linspace(0, 1, N) ** gamma
635         ind = np.searchsorted(x, xind)[1:-1]
636 
637         distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])
638         lut = np.concatenate([
639             [y1[0]],
640             distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],
641             [y0[-1]],
642         ])
643     # ensure that the lut is confined to values between 0 and 1 by clipping it
644     return np.clip(lut, 0.0, 1.0)
645 
646 
647 class Colormap:
648     """
649     Baseclass for all scalar to RGBA mappings.
650 
651     Typically, Colormap instances are used to convert data values (floats)
652     from the interval ``[0, 1]`` to the RGBA color that the respective
653     Colormap represents. For scaling of data into the ``[0, 1]`` interval see
654     `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
655     make heavy use of this ``data -> normalize -> map-to-color`` processing
656     chain.
657     """
658 
659     def __init__(self, name, N=256):
660         """
661         Parameters
662         ----------
663         name : str
664             The name of the colormap.
665         N : int
666             The number of RGB quantization levels.
667         """
668         self.name = name
669         self.N = int(N)  # ensure that N is always int
670         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.
671         self._rgba_under = None
672         self._rgba_over = None
673         self._i_under = self.N
674         self._i_over = self.N + 1
675         self._i_bad = self.N + 2
676         self._isinit = False
677         #: When this colormap exists on a scalar mappable and colorbar_extend
678         #: is not False, colorbar creation will pick up ``colorbar_extend`` as
679         #: the default value for the ``extend`` keyword in the
680         #: `matplotlib.colorbar.Colorbar` constructor.
681         self.colorbar_extend = False
682 
683     def __call__(self, X, alpha=None, bytes=False):
684         """
685         Parameters
686         ----------
687         X : float or int, `~numpy.ndarray` or scalar
688             The data value(s) to convert to RGBA.
689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to
690             return the RGBA values ``X*100`` percent along the Colormap line.
691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to
692             return RGBA values *indexed* from the Colormap with index ``X``.
693         alpha : float or array-like or None
694             Alpha must be a scalar between 0 and 1, a sequence of such
695             floats with shape matching X, or None.
696         bytes : bool
697             If False (default), the returned RGBA values will be floats in the
698             interval ``[0, 1]`` otherwise they will be uint8s in the interval
699             ``[0, 255]``.
700 
701         Returns
702         -------
703         Tuple of RGBA values if X is scalar, otherwise an array of
704         RGBA values with a shape of ``X.shape + (4, )``.
705         """
706         if not self._isinit:
707             self._init()
708 
709         xa = np.array(X, copy=True)
710         if not xa.dtype.isnative:
711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
712         if xa.dtype.kind == "f":
713             xa *= self.N
714             # xa == 1 (== N after multiplication) is not out of range.
715             xa[xa == self.N] = self.N - 1
716         # Pre-compute the masks before casting to int (which can truncate
717         # negative values to zero or wrap large floats to negative ints).
718         mask_under = xa < 0
719         mask_over = xa >= self.N
720         # If input was masked, get the bad mask from it; else mask out nans.
721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)
722         with np.errstate(invalid="ignore"):
723             # We need this cast for unsigned ints as well as floats
724             xa = xa.astype(int)
725         xa[mask_under] = self._i_under
726         xa[mask_over] = self._i_over
727         xa[mask_bad] = self._i_bad
728 
729         lut = self._lut
730         if bytes:
731             lut = (lut * 255).astype(np.uint8)
732 
733         rgba = lut.take(xa, axis=0, mode='clip')
734 
735         if alpha is not None:
736             alpha = np.clip(alpha, 0, 1)
737             if bytes:
738                 alpha *= 255  # Will be cast to uint8 upon assignment.
739             if alpha.shape not in [(), xa.shape]:
740                 raise ValueError(
741                     f"alpha is array-like but its shape {alpha.shape} does "
742                     f"not match that of X {xa.shape}")
743             rgba[..., -1] = alpha
744             # If the "bad" color is all zeros, then ignore alpha input.
745             if (lut[-1] == 0).all():
746                 rgba[mask_bad] = (0, 0, 0, 0)
747 
748         if not np.iterable(X):
749             rgba = tuple(rgba)
750         return rgba
751 
752     def __copy__(self):
753         cls = self.__class__
754         cmapobject = cls.__new__(cls)
755         cmapobject.__dict__.update(self.__dict__)
756         if self._isinit:
757             cmapobject._lut = np.copy(self._lut)
758         return cmapobject
759 
760     def __eq__(self, other):
761         if (not isinstance(other, Colormap) or self.name != other.name or
762                 self.colorbar_extend != other.colorbar_extend):
763             return False
764         # To compare lookup tables the Colormaps have to be initialized
765         if not self._isinit:
766             self._init()
767         if not other._isinit:
768             other._init()
769         return np.array_equal(self._lut, other._lut)
770 
771     def get_bad(self):
772         """Get the color for masked values."""
773         if not self._isinit:
774             self._init()
775         return np.array(self._lut[self._i_bad])
776 
777     def set_bad(self, color='k', alpha=None):
778         """Set the color for masked values."""
779         self._rgba_bad = to_rgba(color, alpha)
780         if self._isinit:
781             self._set_extremes()
782 
783     def get_under(self):
784         """Get the color for low out-of-range values."""
785         if not self._isinit:
786             self._init()
787         return np.array(self._lut[self._i_under])
788 
789     def set_under(self, color='k', alpha=None):
790         """Set the color for low out-of-range values."""
791         self._rgba_under = to_rgba(color, alpha)
792         if self._isinit:
793             self._set_extremes()
794 
795     def get_over(self):
796         """Get the color for high out-of-range values."""
797         if not self._isinit:
798             self._init()
799         return np.array(self._lut[self._i_over])
800 
801     def set_over(self, color='k', alpha=None):
802         """Set the color for high out-of-range values."""
803         self._rgba_over = to_rgba(color, alpha)
804         if self._isinit:
805             self._set_extremes()
806 
807     def set_extremes(self, *, bad=None, under=None, over=None):
808         """
809         Set the colors for masked (*bad*) values and, when ``norm.clip =
810         False``, low (*under*) and high (*over*) out-of-range values.
811         """
812         if bad is not None:
813             self.set_bad(bad)
814         if under is not None:
815             self.set_under(under)
816         if over is not None:
817             self.set_over(over)
818 
819     def with_extremes(self, *, bad=None, under=None, over=None):
820         """
821         Return a copy of the colormap, for which the colors for masked (*bad*)
822         values and, when ``norm.clip = False``, low (*under*) and high (*over*)
823         out-of-range values, have been set accordingly.
824         """
825         new_cm = self.copy()
826         new_cm.set_extremes(bad=bad, under=under, over=over)
827         return new_cm
828 
829     def _set_extremes(self):
830         if self._rgba_under:
831             self._lut[self._i_under] = self._rgba_under
832         else:
833             self._lut[self._i_under] = self._lut[0]
834         if self._rgba_over:
835             self._lut[self._i_over] = self._rgba_over
836         else:
837             self._lut[self._i_over] = self._lut[self.N - 1]
838         self._lut[self._i_bad] = self._rgba_bad
839 
840     def _init(self):
841         """Generate the lookup table, ``self._lut``."""
842         raise NotImplementedError("Abstract class only")
843 
844     def is_gray(self):
845         """Return whether the colormap is grayscale."""
846         if not self._isinit:
847             self._init()
848         return (np.all(self._lut[:, 0] == self._lut[:, 1]) and
849                 np.all(self._lut[:, 0] == self._lut[:, 2]))
850 
851     def resampled(self, lutsize):
852         """Return a new colormap with *lutsize* entries."""
853         if hasattr(self, '_resample'):
854             _api.warn_external(
855                 "The ability to resample a color map is now public API "
856                 f"However the class {type(self)} still only implements "
857                 "the previous private _resample method.  Please update "
858                 "your class."
859             )
860             return self._resample(lutsize)
861 
862         raise NotImplementedError()
863 
864     def reversed(self, name=None):
865         """
866         Return a reversed instance of the Colormap.
867 
868         .. note:: This function is not implemented for the base class.
869 
870         Parameters
871         ----------
872         name : str, optional
873             The name for the reversed colormap. If None, the
874             name is set to ``self.name + "_r"``.
875 
876         See Also
877         --------
878         LinearSegmentedColormap.reversed
879         ListedColormap.reversed
880         """
881         raise NotImplementedError()
882 
883     def _repr_png_(self):
884         """Generate a PNG representation of the Colormap."""
885         X = np.tile(np.linspace(0, 1, _REPR_PNG_SIZE[0]),
886                     (_REPR_PNG_SIZE[1], 1))
887         pixels = self(X, bytes=True)
888         png_bytes = io.BytesIO()
889         title = self.name + ' colormap'
890         author = f'Matplotlib v{mpl.__version__}, https://matplotlib.org'
891         pnginfo = PngInfo()
892         pnginfo.add_text('Title', title)
893         pnginfo.add_text('Description', title)
894         pnginfo.add_text('Author', author)
895         pnginfo.add_text('Software', author)
896         Image.fromarray(pixels).save(png_bytes, format='png', pnginfo=pnginfo)
897         return png_bytes.getvalue()
898 
899     def _repr_html_(self):
900         """Generate an HTML representation of the Colormap."""
901         png_bytes = self._repr_png_()
902         png_base64 = base64.b64encode(png_bytes).decode('ascii')
903         def color_block(color):
904             hex_color = to_hex(color, keep_alpha=True)
905             return (f'<div title="{hex_color}" '
906                     'style="display: inline-block; '
907                     'width: 1em; height: 1em; '
908                     'margin: 0; '
909                     'vertical-align: middle; '
910                     'border: 1px solid #555; '
911                     f'background-color: {hex_color};"></div>')
912 
913         return ('<div style="vertical-align: middle;">'
914                 f'<strong>{self.name}</strong> '
915                 '</div>'
916                 '<div class="cmap"><img '
917                 f'alt="{self.name} colormap" '
918                 f'title="{self.name}" '
919                 'style="border: 1px solid #555;" '
920                 f'src="data:image/png;base64,{png_base64}"></div>'
921                 '<div style="vertical-align: middle; '
922                 f'max-width: {_REPR_PNG_SIZE[0]+2}px; '
923                 'display: flex; justify-content: space-between;">'
924                 '<div style="float: left;">'
925                 f'{color_block(self.get_under())} under'
926                 '</div>'
927                 '<div style="margin: 0 auto; display: inline-block;">'
928                 f'bad {color_block(self.get_bad())}'
929                 '</div>'
930                 '<div style="float: right;">'
931                 f'over {color_block(self.get_over())}'
932                 '</div>')
933 
934     def copy(self):
935         """Return a copy of the colormap."""
936         return self.__copy__()
937 
938 
939 class LinearSegmentedColormap(Colormap):
940     """
941     Colormap objects based on lookup tables using linear segments.
942 
943     The lookup table is generated using linear interpolation for each
944     primary color, with the 0-1 domain divided into any number of
945     segments.
946     """
947 
948     def __init__(self, name, segmentdata, N=256, gamma=1.0):
949         """
950         Create colormap from linear mapping segments
951 
952         segmentdata argument is a dictionary with a red, green and blue
953         entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
954         forming rows in a table. Entries for alpha are optional.
955 
956         Example: suppose you want red to increase from 0 to 1 over
957         the bottom half, green to do the same over the middle half,
958         and blue over the top half.  Then you would use::
959 
960             cdict = {'red':   [(0.0,  0.0, 0.0),
961                                (0.5,  1.0, 1.0),
962                                (1.0,  1.0, 1.0)],
963 
964                      'green': [(0.0,  0.0, 0.0),
965                                (0.25, 0.0, 0.0),
966                                (0.75, 1.0, 1.0),
967                                (1.0,  1.0, 1.0)],
968 
969                      'blue':  [(0.0,  0.0, 0.0),
970                                (0.5,  0.0, 0.0),
971                                (1.0,  1.0, 1.0)]}
972 
973         Each row in the table for a given color is a sequence of
974         *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
975         monotonically from 0 to 1.  For any input value *z* falling
976         between *x[i]* and *x[i+1]*, the output value of a given color
977         will be linearly interpolated between *y1[i]* and *y0[i+1]*::
978 
979             row i:   x  y0  y1
980                            /
981                           /
982             row i+1: x  y0  y1
983 
984         Hence y0 in the first row and y1 in the last row are never used.
985 
986         See Also
987         --------
988         LinearSegmentedColormap.from_list
989             Static method; factory function for generating a smoothly-varying
990             LinearSegmentedColormap.
991         """
992         # True only if all colors in map are identical; needed for contouring.
993         self.monochrome = False
994         super().__init__(name, N)
995         self._segmentdata = segmentdata
996         self._gamma = gamma
997 
998     def _init(self):
999         self._lut = np.ones((self.N + 3, 4), float)
1000         self._lut[:-3, 0] = _create_lookup_table(
1001             self.N, self._segmentdata['red'], self._gamma)
1002         self._lut[:-3, 1] = _create_lookup_table(
1003             self.N, self._segmentdata['green'], self._gamma)
1004         self._lut[:-3, 2] = _create_lookup_table(
1005             self.N, self._segmentdata['blue'], self._gamma)
1006         if 'alpha' in self._segmentdata:
1007             self._lut[:-3, 3] = _create_lookup_table(
1008                 self.N, self._segmentdata['alpha'], 1)
1009         self._isinit = True
1010         self._set_extremes()
1011 
1012     def set_gamma(self, gamma):
1013         """Set a new gamma value and regenerate colormap."""
1014         self._gamma = gamma
1015         self._init()
1016 
1017     @staticmethod
1018     def from_list(name, colors, N=256, gamma=1.0):
1019         """
1020         Create a `LinearSegmentedColormap` from a list of colors.
1021 
1022         Parameters
1023         ----------
1024         name : str
1025             The name of the colormap.
1026         colors : array-like of colors or array-like of (value, color)
1027             If only colors are given, they are equidistantly mapped from the
1028             range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
1029             ``colors[-1]``.
1030             If (value, color) pairs are given, the mapping is from *value*
1031             to *color*. This can be used to divide the range unevenly.
1032         N : int
1033             The number of RGB quantization levels.
1034         gamma : float
1035         """
1036         if not np.iterable(colors):
1037             raise ValueError('colors must be iterable')
1038 
1039         if (isinstance(colors[0], Sized) and len(colors[0]) == 2
1040                 and not isinstance(colors[0], str)):
1041             # List of value, color pairs
1042             vals, colors = zip(*colors)
1043         else:
1044             vals = np.linspace(0, 1, len(colors))
1045 
1046         r, g, b, a = to_rgba_array(colors).T
1047         cdict = {
1048             "red": np.column_stack([vals, r, r]),
1049             "green": np.column_stack([vals, g, g]),
1050             "blue": np.column_stack([vals, b, b]),
1051             "alpha": np.column_stack([vals, a, a]),
1052         }
1053 
1054         return LinearSegmentedColormap(name, cdict, N, gamma)
1055 
1056     def resampled(self, lutsize):
1057         """Return a new colormap with *lutsize* entries."""
1058         new_cmap = LinearSegmentedColormap(self.name, self._segmentdata,
1059                                            lutsize)
1060         new_cmap._rgba_over = self._rgba_over
1061         new_cmap._rgba_under = self._rgba_under
1062         new_cmap._rgba_bad = self._rgba_bad
1063         return new_cmap
1064 
1065     # Helper ensuring picklability of the reversed cmap.
1066     @staticmethod
1067     def _reverser(func, x):
1068         return func(1 - x)
1069 
1070     def reversed(self, name=None):
1071         """
1072         Return a reversed instance of the Colormap.
1073 
1074         Parameters
1075         ----------
1076         name : str, optional
1077             The name for the reversed colormap. If None, the
1078             name is set to ``self.name + "_r"``.
1079 
1080         Returns
1081         -------
1082         LinearSegmentedColormap
1083             The reversed colormap.
1084         """
1085         if name is None:
1086             name = self.name + "_r"
1087 
1088         # Using a partial object keeps the cmap picklable.
1089         data_r = {key: (functools.partial(self._reverser, data)
1090                         if callable(data) else
1091                         [(1.0 - x, y1, y0) for x, y0, y1 in reversed(data)])
1092                   for key, data in self._segmentdata.items()}
1093 
1094         new_cmap = LinearSegmentedColormap(name, data_r, self.N, self._gamma)
1095         # Reverse the over/under values too
1096         new_cmap._rgba_over = self._rgba_under
1097         new_cmap._rgba_under = self._rgba_over
1098         new_cmap._rgba_bad = self._rgba_bad
1099         return new_cmap
1100 
1101 
1102 class ListedColormap(Colormap):
1103     """
1104     Colormap object generated from a list of colors.
1105 
1106     This may be most useful when indexing directly into a colormap,
1107     but it can also be used to generate special colormaps for ordinary
1108     mapping.
1109 
1110     Parameters
1111     ----------
1112     colors : list, array
1113         List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
1114         floating point array (*N* RGB or RGBA values).
1115     name : str, optional
1116         String to identify the colormap.
1117     N : int, optional
1118         Number of entries in the map. The default is *None*, in which case
1119         there is one colormap entry for each element in the list of colors.
1120         If ::
1121 
1122             N < len(colors)
1123 
1124         the list will be truncated at *N*. If ::
1125 
1126             N > len(colors)
1127 
1128         the list will be extended by repetition.
1129     """
1130     def __init__(self, colors, name='from_list', N=None):
1131         self.monochrome = False  # Are all colors identical? (for contour.py)
1132         if N is None:
1133             self.colors = colors
1134             N = len(colors)
1135         else:
1136             if isinstance(colors, str):
1137                 self.colors = [colors] * N
1138                 self.monochrome = True
1139             elif np.iterable(colors):
1140                 if len(colors) == 1:
1141                     self.monochrome = True
1142                 self.colors = list(
1143                     itertools.islice(itertools.cycle(colors), N))
1144             else:
1145                 try:
1146                     gray = float(colors)
1147                 except TypeError:
1148                     pass
1149                 else:
1150                     self.colors = [gray] * N
1151                 self.monochrome = True
1152         super().__init__(name, N)
1153 
1154     def _init(self):
1155         self._lut = np.zeros((self.N + 3, 4), float)
1156         self._lut[:-3] = to_rgba_array(self.colors)
1157         self._isinit = True
1158         self._set_extremes()
1159 
1160     def resampled(self, lutsize):
1161         """Return a new colormap with *lutsize* entries."""
1162         colors = self(np.linspace(0, 1, lutsize))
1163         new_cmap = ListedColormap(colors, name=self.name)
1164         # Keep the over/under values too
1165         new_cmap._rgba_over = self._rgba_over
1166         new_cmap._rgba_under = self._rgba_under
1167         new_cmap._rgba_bad = self._rgba_bad
1168         return new_cmap
1169 
1170     def reversed(self, name=None):
1171         """
1172         Return a reversed instance of the Colormap.
1173 
1174         Parameters
1175         ----------
1176         name : str, optional
1177             The name for the reversed colormap. If None, the
1178             name is set to ``self.name + "_r"``.
1179 
1180         Returns
1181         -------
1182         ListedColormap
1183             A reversed instance of the colormap.
1184         """
1185         if name is None:
1186             name = self.name + "_r"
1187 
1188         colors_r = list(reversed(self.colors))
1189         new_cmap = ListedColormap(colors_r, name=name, N=self.N)
1190         # Reverse the over/under values too
1191         new_cmap._rgba_over = self._rgba_under
1192         new_cmap._rgba_under = self._rgba_over
1193         new_cmap._rgba_bad = self._rgba_bad
1194         return new_cmap
1195 
1196 
1197 class Normalize:
1198     """
1199     A class which, when called, linearly normalizes data into the
1200     ``[0.0, 1.0]`` interval.
1201     """
1202 
1203     def __init__(self, vmin=None, vmax=None, clip=False):
1204         """
1205         Parameters
1206         ----------
1207         vmin, vmax : float or None
1208             If *vmin* and/or *vmax* is not given, they are initialized from the
1209             minimum and maximum value, respectively, of the first input
1210             processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
1211 
1212         clip : bool, default: False
1213             If ``True`` values falling outside the range ``[vmin, vmax]``,
1214             are mapped to 0 or 1, whichever is closer, and masked values are
1215             set to 1.  If ``False`` masked values remain masked.
1216 
1217             Clipping silently defeats the purpose of setting the over, under,
1218             and masked colors in a colormap, so it is likely to lead to
1219             surprises; therefore the default is ``clip=False``.
1220 
1221         Notes
1222         -----
1223         Returns 0 if ``vmin == vmax``.
1224         """
1225         self._vmin = _sanitize_extrema(vmin)
1226         self._vmax = _sanitize_extrema(vmax)
1227         self._clip = clip
1228         self._scale = None
1229         self.callbacks = cbook.CallbackRegistry(signals=["changed"])
1230 
1231     @property
1232     def vmin(self):
1233         return self._vmin
1234 
1235     @vmin.setter
1236     def vmin(self, value):
1237         value = _sanitize_extrema(value)
1238         if value != self._vmin:
1239             self._vmin = value
1240             self._changed()
1241 
1242     @property
1243     def vmax(self):
1244         return self._vmax
1245 
1246     @vmax.setter
1247     def vmax(self, value):
1248         value = _sanitize_extrema(value)
1249         if value != self._vmax:
1250             self._vmax = value
1251             self._changed()
1252 
1253     @property
1254     def clip(self):
1255         return self._clip
1256 
1257     @clip.setter
1258     def clip(self, value):
1259         if value != self._clip:
1260             self._clip = value
1261             self._changed()
1262 
1263     def _changed(self):
1264         """
1265         Call this whenever the norm is changed to notify all the
1266         callback listeners to the 'changed' signal.
1267         """
1268         self.callbacks.process('changed')
1269 
1270     @staticmethod
1271     def process_value(value):
1272         """
1273         Homogenize the input *value* for easy and efficient normalization.
1274 
1275         *value* can be a scalar or sequence.
1276 
1277         Returns
1278         -------
1279         result : masked array
1280             Masked array with the same shape as *value*.
1281         is_scalar : bool
1282             Whether *value* is a scalar.
1283 
1284         Notes
1285         -----
1286         Float dtypes are preserved; integer types with two bytes or smaller are
1287         converted to np.float32, and larger types are converted to np.float64.
1288         Preserving float32 when possible, and using in-place operations,
1289         greatly improves speed for large arrays.
1290         """
1291         is_scalar = not np.iterable(value)
1292         if is_scalar:
1293             value = [value]
1294         dtype = np.min_scalar_type(value)
1295         if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:
1296             # bool_/int8/int16 -> float32; int32/int64 -> float64
1297             dtype = np.promote_types(dtype, np.float32)
1298         # ensure data passed in as an ndarray subclass are interpreted as
1299         # an ndarray. See issue #6622.
1300         mask = np.ma.getmask(value)
1301         data = np.asarray(value)
1302         result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)
1303         return result, is_scalar
1304 
1305     def __call__(self, value, clip=None):
1306         """
1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the
1308         ``[0.0, 1.0]`` interval and return it.
1309 
1310         Parameters
1311         ----------
1312         value
1313             Data to normalize.
1314         clip : bool
1315             If ``None``, defaults to ``self.clip`` (which defaults to
1316             ``False``).
1317 
1318         Notes
1319         -----
1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are
1321         initialized using ``self.autoscale_None(value)``.
1322         """
1323         if clip is None:
1324             clip = self.clip
1325 
1326         result, is_scalar = self.process_value(value)
1327 
1328         if self.vmin is None or self.vmax is None:
1329             self.autoscale_None(result)
1330         # Convert at least to float, without losing precision.
1331         (vmin,), _ = self.process_value(self.vmin)
1332         (vmax,), _ = self.process_value(self.vmax)
1333         if vmin == vmax:
1334             result.fill(0)  # Or should it be all masked?  Or 0.5?
1335         elif vmin > vmax:
1336             raise ValueError("minvalue must be less than or equal to maxvalue")
1337         else:
1338             if clip:
1339                 mask = np.ma.getmask(result)
1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1341                                      mask=mask)
1342             # ma division is very slow; we can take a shortcut
1343             resdat = result.data
1344             resdat -= vmin
1345             resdat /= (vmax - vmin)
1346             result = np.ma.array(resdat, mask=result.mask, copy=False)
1347         if is_scalar:
1348             result = result[0]
1349         return result
1350 
1351     def inverse(self, value):
1352         if not self.scaled():
1353             raise ValueError("Not invertible until both vmin and vmax are set")
1354         (vmin,), _ = self.process_value(self.vmin)
1355         (vmax,), _ = self.process_value(self.vmax)
1356 
1357         if np.iterable(value):
1358             val = np.ma.asarray(value)
1359             return vmin + val * (vmax - vmin)
1360         else:
1361             return vmin + value * (vmax - vmin)
1362 
1363     def autoscale(self, A):
1364         """Set *vmin*, *vmax* to min, max of *A*."""
1365         self.vmin = self.vmax = None
1366         self.autoscale_None(A)
1367 
1368     def autoscale_None(self, A):
1369         """If vmin or vmax are not set, use the min/max of *A* to set them."""
1370         A = np.asanyarray(A)
1371         if self.vmin is None and A.size:
1372             self.vmin = A.min()
1373         if self.vmax is None and A.size:
1374             self.vmax = A.max()
1375 
1376     def scaled(self):
1377         """Return whether vmin and vmax are set."""
1378         return self.vmin is not None and self.vmax is not None
1379 
1380 
1381 class TwoSlopeNorm(Normalize):
1382     def __init__(self, vcenter, vmin=None, vmax=None):
1383         """
1384         Normalize data with a set center.
1385 
1386         Useful when mapping data with an unequal rates of change around a
1387         conceptual center, e.g., data that range from -2 to 4, with 0 as
1388         the midpoint.
1389 
1390         Parameters
1391         ----------
1392         vcenter : float
1393             The data value that defines ``0.5`` in the normalization.
1394         vmin : float, optional
1395             The data value that defines ``0.0`` in the normalization.
1396             Defaults to the min value of the dataset.
1397         vmax : float, optional
1398             The data value that defines ``1.0`` in the normalization.
1399             Defaults to the max value of the dataset.
1400 
1401         Examples
1402         --------
1403         This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
1404         between is linearly interpolated::
1405 
1406             >>> import matplotlib.colors as mcolors
1407             >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
1408                                               vcenter=0., vmax=10000)
1409             >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
1410             >>> offset(data)
1411             array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
1412         """
1413 
1414         super().__init__(vmin=vmin, vmax=vmax)
1415         self._vcenter = vcenter
1416         if vcenter is not None and vmax is not None and vcenter >= vmax:
1417             raise ValueError('vmin, vcenter, and vmax must be in '
1418                              'ascending order')
1419         if vcenter is not None and vmin is not None and vcenter <= vmin:
1420             raise ValueError('vmin, vcenter, and vmax must be in '
1421                              'ascending order')
1422 
1423     @property
1424     def vcenter(self):
1425         return self._vcenter
1426 
1427     @vcenter.setter
1428     def vcenter(self, value):
1429         if value != self._vcenter:
1430             self._vcenter = value
1431             self._changed()
1432 
1433     def autoscale_None(self, A):
1434         """
1435         Get vmin and vmax.
1436 
1437         If vcenter isn't in the range [vmin, vmax], either vmin or vmax
1438         is expanded so that vcenter lies in the middle of the modified range
1439         [vmin, vmax].
1440         """
1441         super().autoscale_None(A)
1442         if self.vmin >= self.vcenter:
1443             self.vmin = self.vcenter - (self.vmax - self.vcenter)
1444         if self.vmax <= self.vcenter:
1445             self.vmax = self.vcenter + (self.vcenter - self.vmin)
1446 
1447     def __call__(self, value, clip=None):
1448         """
1449         Map value to the interval [0, 1]. The clip argument is unused.
1450         """
1451         result, is_scalar = self.process_value(value)
1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None
1453 
1454         if not self.vmin <= self.vcenter <= self.vmax:
1455             raise ValueError("vmin, vcenter, vmax must increase monotonically")
1456         # note that we must extrapolate for tick locators:
1457         result = np.ma.masked_array(
1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],
1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),
1460             mask=np.ma.getmask(result))
1461         if is_scalar:
1462             result = np.atleast_1d(result)[0]
1463         return result
1464 
1465     def inverse(self, value):
1466         if not self.scaled():
1467             raise ValueError("Not invertible until both vmin and vmax are set")
1468         (vmin,), _ = self.process_value(self.vmin)
1469         (vmax,), _ = self.process_value(self.vmax)
1470         (vcenter,), _ = self.process_value(self.vcenter)
1471         result = np.interp(value, [0, 0.5, 1], [vmin, vcenter, vmax],
1472                            left=-np.inf, right=np.inf)
1473         return result
1474 
1475 
1476 class CenteredNorm(Normalize):
1477     def __init__(self, vcenter=0, halfrange=None, clip=False):
1478         """
1479         Normalize symmetrical data around a center (0 by default).
1480 
1481         Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
1482         around the center.
1483 
1484         Useful when mapping symmetrical data around a conceptual center
1485         e.g., data that range from -2 to 4, with 0 as the midpoint, and
1486         with equal rates of change around that midpoint.
1487 
1488         Parameters
1489         ----------
1490         vcenter : float, default: 0
1491             The data value that defines ``0.5`` in the normalization.
1492         halfrange : float, optional
1493             The range of data values that defines a range of ``0.5`` in the
1494             normalization, so that *vcenter* - *halfrange* is ``0.0`` and
1495             *vcenter* + *halfrange* is ``1.0`` in the normalization.
1496             Defaults to the largest absolute difference to *vcenter* for
1497             the values in the dataset.
1498 
1499         Examples
1500         --------
1501         This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
1502         (assuming equal rates of change above and below 0.0):
1503 
1504             >>> import matplotlib.colors as mcolors
1505             >>> norm = mcolors.CenteredNorm(halfrange=4.0)
1506             >>> data = [-2., 0., 4.]
1507             >>> norm(data)
1508             array([0.25, 0.5 , 1.  ])
1509         """
1510         super().__init__(vmin=None, vmax=None, clip=clip)
1511         self._vcenter = vcenter
1512         # calling the halfrange setter to set vmin and vmax
1513         self.halfrange = halfrange
1514 
1515     def autoscale(self, A):
1516         """
1517         Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
1518         """
1519         A = np.asanyarray(A)
1520         self.halfrange = max(self._vcenter-A.min(),
1521                              A.max()-self._vcenter)
1522 
1523     def autoscale_None(self, A):
1524         """Set *vmin* and *vmax*."""
1525         A = np.asanyarray(A)
1526         if self.halfrange is None and A.size:
1527             self.autoscale(A)
1528 
1529     @property
1530     def vmin(self):
1531         return self._vmin
1532 
1533     @vmin.setter
1534     def vmin(self, value):
1535         value = _sanitize_extrema(value)
1536         if value != self._vmin:
1537             self._vmin = value
1538             self._vmax = 2*self.vcenter - value
1539             self._changed()
1540 
1541     @property
1542     def vmax(self):
1543         return self._vmax
1544 
1545     @vmax.setter
1546     def vmax(self, value):
1547         value = _sanitize_extrema(value)
1548         if value != self._vmax:
1549             self._vmax = value
1550             self._vmin = 2*self.vcenter - value
1551             self._changed()
1552 
1553     @property
1554     def vcenter(self):
1555         return self._vcenter
1556 
1557     @vcenter.setter
1558     def vcenter(self, vcenter):
1559         if vcenter != self._vcenter:
1560             self._vcenter = vcenter
1561             # Trigger an update of the vmin/vmax values through the setter
1562             self.halfrange = self.halfrange
1563             self._changed()
1564 
1565     @property
1566     def halfrange(self):
1567         if self.vmin is None or self.vmax is None:
1568             return None
1569         return (self.vmax - self.vmin) / 2
1570 
1571     @halfrange.setter
1572     def halfrange(self, halfrange):
1573         if halfrange is None:
1574             self.vmin = None
1575             self.vmax = None
1576         else:
1577             self.vmin = self.vcenter - abs(halfrange)
1578             self.vmax = self.vcenter + abs(halfrange)
1579 
1580 
1581 def make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):
1582     """
1583     Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
1584     subclass.
1585 
1586     After ::
1587 
1588         @make_norm_from_scale(scale_cls)
1589         class norm_cls(Normalize):
1590             ...
1591 
1592     *norm_cls* is filled with methods so that normalization computations are
1593     forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
1594     for the colorbar of a mappable normalized with *norm_cls*).
1595 
1596     If *init* is not passed, then the constructor signature of *norm_cls*
1597     will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
1598     parameters will be forwarded to the base class (``Normalize.__init__``),
1599     and a *scale_cls* object will be initialized with no arguments (other than
1600     a dummy axis).
1601 
1602     If the *scale_cls* constructor takes additional parameters, then *init*
1603     should be passed to `make_norm_from_scale`.  It is a callable which is
1604     *only* used for its signature.  First, this signature will become the
1605     signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
1606     parameters passed to it using this signature, extract the bound *vmin*,
1607     *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
1608     forward the remaining bound values (including any defaults defined by the
1609     signature) to the *scale_cls* constructor.
1610     """
1611 
1612     if base_norm_cls is None:
1613         return functools.partial(make_norm_from_scale, scale_cls, init=init)
1614 
1615     if isinstance(scale_cls, functools.partial):
1616         scale_args = scale_cls.args
1617         scale_kwargs_items = tuple(scale_cls.keywords.items())
1618         scale_cls = scale_cls.func
1619     else:
1620         scale_args = scale_kwargs_items = ()
1621 
1622     if init is None:
1623         def init(vmin=None, vmax=None, clip=False): pass
1624 
1625     return _make_norm_from_scale(
1626         scale_cls, scale_args, scale_kwargs_items,
1627         base_norm_cls, inspect.signature(init))
1628 
1629 
1630 @functools.cache
1631 def _make_norm_from_scale(
1632     scale_cls, scale_args, scale_kwargs_items,
1633     base_norm_cls, bound_init_signature,
1634 ):
1635     """
1636     Helper for `make_norm_from_scale`.
1637 
1638     This function is split out to enable caching (in particular so that
1639     different unpickles reuse the same class).  In order to do so,
1640 
1641     - ``functools.partial`` *scale_cls* is expanded into ``func, args, kwargs``
1642       to allow memoizing returned norms (partial instances always compare
1643       unequal, but we can check identity based on ``func, args, kwargs``;
1644     - *init* is replaced by *init_signature*, as signatures are picklable,
1645       unlike to arbitrary lambdas.
1646     """
1647 
1648     class Norm(base_norm_cls):
1649         def __reduce__(self):
1650             cls = type(self)
1651             # If the class is toplevel-accessible, it is possible to directly
1652             # pickle it "by name".  This is required to support norm classes
1653             # defined at a module's toplevel, as the inner base_norm_cls is
1654             # otherwise unpicklable (as it gets shadowed by the generated norm
1655             # class).  If either import or attribute access fails, fall back to
1656             # the general path.
1657             try:
1658                 if cls is getattr(importlib.import_module(cls.__module__),
1659                                   cls.__qualname__):
1660                     return (_create_empty_object_of_class, (cls,), vars(self))
1661             except (ImportError, AttributeError):
1662                 pass
1663             return (_picklable_norm_constructor,
1664                     (scale_cls, scale_args, scale_kwargs_items,
1665                      base_norm_cls, bound_init_signature),
1666                     vars(self))
1667 
1668         def __init__(self, *args, **kwargs):
1669             ba = bound_init_signature.bind(*args, **kwargs)
1670             ba.apply_defaults()
1671             super().__init__(
1672                 **{k: ba.arguments.pop(k) for k in ["vmin", "vmax", "clip"]})
1673             self._scale = functools.partial(
1674                 scale_cls, *scale_args, **dict(scale_kwargs_items))(
1675                     axis=None, **ba.arguments)
1676             self._trf = self._scale.get_transform()
1677 
1678         __init__.__signature__ = bound_init_signature.replace(parameters=[
1679             inspect.Parameter("self", inspect.Parameter.POSITIONAL_OR_KEYWORD),
1680             *bound_init_signature.parameters.values()])
1681 
1682         def __call__(self, value, clip=None):
1683             value, is_scalar = self.process_value(value)
1684             if self.vmin is None or self.vmax is None:
1685                 self.autoscale_None(value)
1686             if self.vmin > self.vmax:
1687                 raise ValueError("vmin must be less or equal to vmax")
1688             if self.vmin == self.vmax:
1689                 return np.full_like(value, 0)
1690             if clip is None:
1691                 clip = self.clip
1692             if clip:
1693                 value = np.clip(value, self.vmin, self.vmax)
1694             t_value = self._trf.transform(value).reshape(np.shape(value))
1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1696             if not np.isfinite([t_vmin, t_vmax]).all():
1697                 raise ValueError("Invalid vmin or vmax")
1698             t_value -= t_vmin
1699             t_value /= (t_vmax - t_vmin)
1700             t_value = np.ma.masked_invalid(t_value, copy=False)
1701             return t_value[0] if is_scalar else t_value
1702 
1703         def inverse(self, value):
1704             if not self.scaled():
1705                 raise ValueError("Not invertible until scaled")
1706             if self.vmin > self.vmax:
1707                 raise ValueError("vmin must be less or equal to vmax")
1708             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1709             if not np.isfinite([t_vmin, t_vmax]).all():
1710                 raise ValueError("Invalid vmin or vmax")
1711             value, is_scalar = self.process_value(value)
1712             rescaled = value * (t_vmax - t_vmin)
1713             rescaled += t_vmin
1714             value = (self._trf
1715                      .inverted()
1716                      .transform(rescaled)
1717                      .reshape(np.shape(value)))
1718             return value[0] if is_scalar else value
1719 
1720         def autoscale_None(self, A):
1721             # i.e. A[np.isfinite(...)], but also for non-array A's
1722             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)
1723             if in_trf_domain.size == 0:
1724                 in_trf_domain = np.ma.masked
1725             return super().autoscale_None(in_trf_domain)
1726 
1727     if base_norm_cls is Normalize:
1728         Norm.__name__ = f"{scale_cls.__name__}Norm"
1729         Norm.__qualname__ = f"{scale_cls.__qualname__}Norm"
1730     else:
1731         Norm.__name__ = base_norm_cls.__name__
1732         Norm.__qualname__ = base_norm_cls.__qualname__
1733     Norm.__module__ = base_norm_cls.__module__
1734     Norm.__doc__ = base_norm_cls.__doc__
1735 
1736     return Norm
1737 
1738 
1739 def _create_empty_object_of_class(cls):
1740     return cls.__new__(cls)
1741 
1742 
1743 def _picklable_norm_constructor(*args):
1744     return _create_empty_object_of_class(_make_norm_from_scale(*args))
1745 
1746 
1747 @make_norm_from_scale(
1748     scale.FuncScale,
1749     init=lambda functions, vmin=None, vmax=None, clip=False: None)
1750 class FuncNorm(Normalize):
1751     """
1752     Arbitrary normalization using functions for the forward and inverse.
1753 
1754     Parameters
1755     ----------
1756     functions : (callable, callable)
1757         two-tuple of the forward and inverse functions for the normalization.
1758         The forward function must be monotonic.
1759 
1760         Both functions must have the signature ::
1761 
1762            def forward(values: array-like) -> array-like
1763 
1764     vmin, vmax : float or None
1765         If *vmin* and/or *vmax* is not given, they are initialized from the
1766         minimum and maximum value, respectively, of the first input
1767         processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
1768 
1769     clip : bool, default: False
1770         If ``True`` values falling outside the range ``[vmin, vmax]``,
1771         are mapped to 0 or 1, whichever is closer, and masked values are
1772         set to 1.  If ``False`` masked values remain masked.
1773 
1774         Clipping silently defeats the purpose of setting the over, under,
1775         and masked colors in a colormap, so it is likely to lead to
1776         surprises; therefore the default is ``clip=False``.
1777     """
1778 
1779 
1780 LogNorm = make_norm_from_scale(
1781     functools.partial(scale.LogScale, nonpositive="mask"))(Normalize)
1782 LogNorm.__name__ = LogNorm.__qualname__ = "LogNorm"
1783 LogNorm.__doc__ = "Normalize a given value to the 0-1 range on a log scale."
1784 
1785 
1786 @make_norm_from_scale(
1787     scale.SymmetricalLogScale,
1788     init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,
1789                 base=10: None)
1790 class SymLogNorm(Normalize):
1791     """
1792     The symmetrical logarithmic scale is logarithmic in both the
1793     positive and negative directions from the origin.
1794 
1795     Since the values close to zero tend toward infinity, there is a
1796     need to have a range around zero that is linear.  The parameter
1797     *linthresh* allows the user to specify the size of this range
1798     (-*linthresh*, *linthresh*).
1799 
1800     Parameters
1801     ----------
1802     linthresh : float
1803         The range within which the plot is linear (to avoid having the plot
1804         go to infinity around zero).
1805     linscale : float, default: 1
1806         This allows the linear range (-*linthresh* to *linthresh*) to be
1807         stretched relative to the logarithmic range. Its value is the
1808         number of decades to use for each half of the linear range. For
1809         example, when *linscale* == 1.0 (the default), the space used for
1810         the positive and negative halves of the linear range will be equal
1811         to one decade in the logarithmic range.
1812     base : float, default: 10
1813     """
1814 
1815     @property
1816     def linthresh(self):
1817         return self._scale.linthresh
1818 
1819     @linthresh.setter
1820     def linthresh(self, value):
1821         self._scale.linthresh = value
1822 
1823 
1824 @make_norm_from_scale(
1825     scale.AsinhScale,
1826     init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None)
1827 class AsinhNorm(Normalize):
1828     """
1829     The inverse hyperbolic sine scale is approximately linear near
1830     the origin, but becomes logarithmic for larger positive
1831     or negative values. Unlike the `SymLogNorm`, the transition between
1832     these linear and logarithmic regions is smooth, which may reduce
1833     the risk of visual artifacts.
1834 
1835     .. note::
1836 
1837        This API is provisional and may be revised in the future
1838        based on early user feedback.
1839 
1840     Parameters
1841     ----------
1842     linear_width : float, default: 1
1843         The effective width of the linear region, beyond which
1844         the transformation becomes asymptotically logarithmic
1845     """
1846 
1847     @property
1848     def linear_width(self):
1849         return self._scale.linear_width
1850 
1851     @linear_width.setter
1852     def linear_width(self, value):
1853         self._scale.linear_width = value
1854 
1855 
1856 class PowerNorm(Normalize):
1857     """
1858     Linearly map a given value to the 0-1 range and then apply
1859     a power-law normalization over that range.
1860     """
1861     def __init__(self, gamma, vmin=None, vmax=None, clip=False):
1862         super().__init__(vmin, vmax, clip)
1863         self.gamma = gamma
1864 
1865     def __call__(self, value, clip=None):
1866         if clip is None:
1867             clip = self.clip
1868 
1869         result, is_scalar = self.process_value(value)
1870 
1871         self.autoscale_None(result)
1872         gamma = self.gamma
1873         vmin, vmax = self.vmin, self.vmax
1874         if vmin > vmax:
1875             raise ValueError("minvalue must be less than or equal to maxvalue")
1876         elif vmin == vmax:
1877             result.fill(0)
1878         else:
1879             if clip:
1880                 mask = np.ma.getmask(result)
1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1882                                      mask=mask)
1883             resdat = result.data
1884             resdat -= vmin
1885             resdat[resdat < 0] = 0
1886             np.power(resdat, gamma, resdat)
1887             resdat /= (vmax - vmin) ** gamma
1888 
1889             result = np.ma.array(resdat, mask=result.mask, copy=False)
1890         if is_scalar:
1891             result = result[0]
1892         return result
1893 
1894     def inverse(self, value):
1895         if not self.scaled():
1896             raise ValueError("Not invertible until scaled")
1897         gamma = self.gamma
1898         vmin, vmax = self.vmin, self.vmax
1899 
1900         if np.iterable(value):
1901             val = np.ma.asarray(value)
1902             return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin
1903         else:
1904             return pow(value, 1. / gamma) * (vmax - vmin) + vmin
1905 
1906 
1907 class BoundaryNorm(Normalize):
1908     """
1909     Generate a colormap index based on discrete intervals.
1910 
1911     Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
1912     instead of to the interval 0-1.
1913     """
1914 
1915     # Mapping to the 0-1 interval could have been done via piece-wise linear
1916     # interpolation, but using integers seems simpler, and reduces the number
1917     # of conversions back and forth between int and float.
1918 
1919     def __init__(self, boundaries, ncolors, clip=False, *, extend='neither'):
1920         """
1921         Parameters
1922         ----------
1923         boundaries : array-like
1924             Monotonically increasing sequence of at least 2 bin edges:  data
1925             falling in the n-th bin will be mapped to the n-th color.
1926 
1927         ncolors : int
1928             Number of colors in the colormap to be used.
1929 
1930         clip : bool, optional
1931             If clip is ``True``, out of range values are mapped to 0 if they
1932             are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
1933             are above ``boundaries[-1]``.
1934 
1935             If clip is ``False``, out of range values are mapped to -1 if
1936             they are below ``boundaries[0]`` or mapped to *ncolors* if they are
1937             above ``boundaries[-1]``. These are then converted to valid indices
1938             by `Colormap.__call__`.
1939 
1940         extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
1941             Extend the number of bins to include one or both of the
1942             regions beyond the boundaries.  For example, if ``extend``
1943             is 'min', then the color to which the region between the first
1944             pair of boundaries is mapped will be distinct from the first
1945             color in the colormap, and by default a
1946             `~matplotlib.colorbar.Colorbar` will be drawn with
1947             the triangle extension on the left or lower end.
1948 
1949         Notes
1950         -----
1951         If there are fewer bins (including extensions) than colors, then the
1952         color index is chosen by linearly interpolating the ``[0, nbins - 1]``
1953         range onto the ``[0, ncolors - 1]`` range, effectively skipping some
1954         colors in the middle of the colormap.
1955         """
1956         if clip and extend != 'neither':
1957             raise ValueError("'clip=True' is not compatible with 'extend'")
1958         super().__init__(vmin=boundaries[0], vmax=boundaries[-1], clip=clip)
1959         self.boundaries = np.asarray(boundaries)
1960         self.N = len(self.boundaries)
1961         if self.N < 2:
1962             raise ValueError("You must provide at least 2 boundaries "
1963                              f"(1 region) but you passed in {boundaries!r}")
1964         self.Ncmap = ncolors
1965         self.extend = extend
1966 
1967         self._scale = None  # don't use the default scale.
1968 
1969         self._n_regions = self.N - 1  # number of colors needed
1970         self._offset = 0
1971         if extend in ('min', 'both'):
1972             self._n_regions += 1
1973             self._offset = 1
1974         if extend in ('max', 'both'):
1975             self._n_regions += 1
1976         if self._n_regions > self.Ncmap:
1977             raise ValueError(f"There are {self._n_regions} color bins "
1978                              "including extensions, but ncolors = "
1979                              f"{ncolors}; ncolors must equal or exceed the "
1980                              "number of bins")
1981 
1982     def __call__(self, value, clip=None):
1983         """
1984         This method behaves similarly to `.Normalize.__call__`, except that it
1985         returns integers or arrays of int16.
1986         """
1987         if clip is None:
1988             clip = self.clip
1989 
1990         xx, is_scalar = self.process_value(value)
1991         mask = np.ma.getmaskarray(xx)
1992         # Fill masked values a value above the upper boundary
1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))
1994         if clip:
1995             np.clip(xx, self.vmin, self.vmax, out=xx)
1996             max_col = self.Ncmap - 1
1997         else:
1998             max_col = self.Ncmap
1999         # this gives us the bins in the lookup table in the range
2000         # [0, _n_regions - 1]  (the offset is set in the init)
2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset
2002         # if we have more colors than regions, stretch the region
2003         # index computed above to full range of the color bins.  This
2004         # will make use of the full range (but skip some of the colors
2005         # in the middle) such that the first region is mapped to the
2006         # first color and the last region is mapped to the last color.
2007         if self.Ncmap > self._n_regions:
2008             if self._n_regions == 1:
2009                 # special case the 1 region case, pick the middle color
2010                 iret[iret == 0] = (self.Ncmap - 1) // 2
2011             else:
2012                 # otherwise linearly remap the values from the region index
2013                 # to the color index spaces
2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret
2015         # cast to 16bit integers in all cases
2016         iret = iret.astype(np.int16)
2017         iret[xx < self.vmin] = -1
2018         iret[xx >= self.vmax] = max_col
2019         ret = np.ma.array(iret, mask=mask)
2020         if is_scalar:
2021             ret = int(ret[0])  # assume python scalar
2022         return ret
2023 
2024     def inverse(self, value):
2025         """
2026         Raises
2027         ------
2028         ValueError
2029             BoundaryNorm is not invertible, so calling this method will always
2030             raise an error
2031         """
2032         raise ValueError("BoundaryNorm is not invertible")
2033 
2034 
2035 class NoNorm(Normalize):
2036     """
2037     Dummy replacement for `Normalize`, for the case where we want to use
2038     indices directly in a `~matplotlib.cm.ScalarMappable`.
2039     """
2040     def __call__(self, value, clip=None):
2041         return value
2042 
2043     def inverse(self, value):
2044         return value
2045 
2046 
2047 def rgb_to_hsv(arr):
2048     """
2049     Convert float RGB values (in the range [0, 1]), in a numpy array to HSV
2050     values.
2051 
2052     Parameters
2053     ----------
2054     arr : (..., 3) array-like
2055        All values must be in the range [0, 1]
2056 
2057     Returns
2058     -------
2059     (..., 3) `~numpy.ndarray`
2060        Colors converted to HSV values in range [0, 1]
2061     """
2062     arr = np.asarray(arr)
2063 
2064     # check length of the last dimension, should be _some_ sort of rgb
2065     if arr.shape[-1] != 3:
2066         raise ValueError("Last dimension of input array must be 3; "
2067                          f"shape {arr.shape} was found.")
2068 
2069     in_shape = arr.shape
2070     arr = np.array(
2071         arr, copy=False,
2072         dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.
2073         ndmin=2,  # In case input was 1D.
2074     )
2075     out = np.zeros_like(arr)
2076     arr_max = arr.max(-1)
2077     ipos = arr_max > 0
2078     delta = arr.ptp(-1)
2079     s = np.zeros_like(delta)
2080     s[ipos] = delta[ipos] / arr_max[ipos]
2081     ipos = delta > 0
2082     # red is max
2083     idx = (arr[..., 0] == arr_max) & ipos
2084     out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]
2085     # green is max
2086     idx = (arr[..., 1] == arr_max) & ipos
2087     out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]
2088     # blue is max
2089     idx = (arr[..., 2] == arr_max) & ipos
2090     out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]
2091 
2092     out[..., 0] = (out[..., 0] / 6.0) % 1.0
2093     out[..., 1] = s
2094     out[..., 2] = arr_max
2095 
2096     return out.reshape(in_shape)
2097 
2098 
2099 def hsv_to_rgb(hsv):
2100     """
2101     Convert HSV values to RGB.
2102 
2103     Parameters
2104     ----------
2105     hsv : (..., 3) array-like
2106        All values assumed to be in range [0, 1]
2107 
2108     Returns
2109     -------
2110     (..., 3) `~numpy.ndarray`
2111        Colors converted to RGB values in range [0, 1]
2112     """
2113     hsv = np.asarray(hsv)
2114 
2115     # check length of the last dimension, should be _some_ sort of rgb
2116     if hsv.shape[-1] != 3:
2117         raise ValueError("Last dimension of input array must be 3; "
2118                          f"shape {hsv.shape} was found.")
2119 
2120     in_shape = hsv.shape
2121     hsv = np.array(
2122         hsv, copy=False,
2123         dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.
2124         ndmin=2,  # In case input was 1D.
2125     )
2126 
2127     h = hsv[..., 0]
2128     s = hsv[..., 1]
2129     v = hsv[..., 2]
2130 
2131     r = np.empty_like(h)
2132     g = np.empty_like(h)
2133     b = np.empty_like(h)
2134 
2135     i = (h * 6.0).astype(int)
2136     f = (h * 6.0) - i
2137     p = v * (1.0 - s)
2138     q = v * (1.0 - s * f)
2139     t = v * (1.0 - s * (1.0 - f))
2140 
2141     idx = i % 6 == 0
2142     r[idx] = v[idx]
2143     g[idx] = t[idx]
2144     b[idx] = p[idx]
2145 
2146     idx = i == 1
2147     r[idx] = q[idx]
2148     g[idx] = v[idx]
2149     b[idx] = p[idx]
2150 
2151     idx = i == 2
2152     r[idx] = p[idx]
2153     g[idx] = v[idx]
2154     b[idx] = t[idx]
2155 
2156     idx = i == 3
2157     r[idx] = p[idx]
2158     g[idx] = q[idx]
2159     b[idx] = v[idx]
2160 
2161     idx = i == 4
2162     r[idx] = t[idx]
2163     g[idx] = p[idx]
2164     b[idx] = v[idx]
2165 
2166     idx = i == 5
2167     r[idx] = v[idx]
2168     g[idx] = p[idx]
2169     b[idx] = q[idx]
2170 
2171     idx = s == 0
2172     r[idx] = v[idx]
2173     g[idx] = v[idx]
2174     b[idx] = v[idx]
2175 
2176     rgb = np.stack([r, g, b], axis=-1)
2177 
2178     return rgb.reshape(in_shape)
2179 
2180 
2181 def _vector_magnitude(arr):
2182     # things that don't work here:
2183     #  * np.linalg.norm: drops mask from ma.array
2184     #  * np.sum: drops mask from ma.array unless entire vector is masked
2185     sum_sq = 0
2186     for i in range(arr.shape[-1]):
2187         sum_sq += arr[..., i, np.newaxis] ** 2
2188     return np.sqrt(sum_sq)
2189 
2190 
2191 class LightSource:
2192     """
2193     Create a light source coming from the specified azimuth and elevation.
2194     Angles are in degrees, with the azimuth measured
2195     clockwise from north and elevation up from the zero plane of the surface.
2196 
2197     `shade` is used to produce "shaded" RGB values for a data array.
2198     `shade_rgb` can be used to combine an RGB image with an elevation map.
2199     `hillshade` produces an illumination map of a surface.
2200     """
2201 
2202     def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,
2203                  hsv_min_sat=1, hsv_max_sat=0):
2204         """
2205         Specify the azimuth (measured clockwise from south) and altitude
2206         (measured up from the plane of the surface) of the light source
2207         in degrees.
2208 
2209         Parameters
2210         ----------
2211         azdeg : float, default: 315 degrees (from the northwest)
2212             The azimuth (0-360, degrees clockwise from North) of the light
2213             source.
2214         altdeg : float, default: 45 degrees
2215             The altitude (0-90, degrees up from horizontal) of the light
2216             source.
2217 
2218         Notes
2219         -----
2220         For backwards compatibility, the parameters *hsv_min_val*,
2221         *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
2222         initialization as well.  However, these parameters will only be used if
2223         "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
2224         See the documentation for `blend_hsv` for more details.
2225         """
2226         self.azdeg = azdeg
2227         self.altdeg = altdeg
2228         self.hsv_min_val = hsv_min_val
2229         self.hsv_max_val = hsv_max_val
2230         self.hsv_min_sat = hsv_min_sat
2231         self.hsv_max_sat = hsv_max_sat
2232 
2233     @property
2234     def direction(self):
2235         """The unit vector direction towards the light source."""
2236         # Azimuth is in degrees clockwise from North. Convert to radians
2237         # counterclockwise from East (mathematical notation).
2238         az = np.radians(90 - self.azdeg)
2239         alt = np.radians(self.altdeg)
2240         return np.array([
2241             np.cos(az) * np.cos(alt),
2242             np.sin(az) * np.cos(alt),
2243             np.sin(alt)
2244         ])
2245 
2246     def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):
2247         """
2248         Calculate the illumination intensity for a surface using the defined
2249         azimuth and elevation for the light source.
2250 
2251         This computes the normal vectors for the surface, and then passes them
2252         on to `shade_normals`
2253 
2254         Parameters
2255         ----------
2256         elevation : 2D array-like
2257             The height values used to generate an illumination map
2258         vert_exag : number, optional
2259             The amount to exaggerate the elevation values by when calculating
2260             illumination. This can be used either to correct for differences in
2261             units between the x-y coordinate system and the elevation
2262             coordinate system (e.g. decimal degrees vs. meters) or to
2263             exaggerate or de-emphasize topographic effects.
2264         dx : number, optional
2265             The x-spacing (columns) of the input *elevation* grid.
2266         dy : number, optional
2267             The y-spacing (rows) of the input *elevation* grid.
2268         fraction : number, optional
2269             Increases or decreases the contrast of the hillshade.  Values
2270             greater than one will cause intermediate values to move closer to
2271             full illumination or shadow (and clipping any values that move
2272             beyond 0 or 1). Note that this is not visually or mathematically
2273             the same as vertical exaggeration.
2274 
2275         Returns
2276         -------
2277         `~numpy.ndarray`
2278             A 2D array of illumination values between 0-1, where 0 is
2279             completely in shadow and 1 is completely illuminated.
2280         """
2281 
2282         # Because most image and raster GIS data has the first row in the array
2283         # as the "top" of the image, dy is implicitly negative.  This is
2284         # consistent to what `imshow` assumes, as well.
2285         dy = -dy
2286 
2287         # compute the normal vectors from the partial derivatives
2288         e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)
2289 
2290         # .view is to keep subclasses
2291         normal = np.empty(elevation.shape + (3,)).view(type(elevation))
2292         normal[..., 0] = -e_dx
2293         normal[..., 1] = -e_dy
2294         normal[..., 2] = 1
2295         normal /= _vector_magnitude(normal)
2296 
2297         return self.shade_normals(normal, fraction)
2298 
2299     def shade_normals(self, normals, fraction=1.):
2300         """
2301         Calculate the illumination intensity for the normal vectors of a
2302         surface using the defined azimuth and elevation for the light source.
2303 
2304         Imagine an artificial sun placed at infinity in some azimuth and
2305         elevation position illuminating our surface. The parts of the surface
2306         that slope toward the sun should brighten while those sides facing away
2307         should become darker.
2308 
2309         Parameters
2310         ----------
2311         fraction : number, optional
2312             Increases or decreases the contrast of the hillshade.  Values
2313             greater than one will cause intermediate values to move closer to
2314             full illumination or shadow (and clipping any values that move
2315             beyond 0 or 1). Note that this is not visually or mathematically
2316             the same as vertical exaggeration.
2317 
2318         Returns
2319         -------
2320         `~numpy.ndarray`
2321             A 2D array of illumination values between 0-1, where 0 is
2322             completely in shadow and 1 is completely illuminated.
2323         """
2324 
2325         intensity = normals.dot(self.direction)
2326 
2327         # Apply contrast stretch
2328         imin, imax = intensity.min(), intensity.max()
2329         intensity *= fraction
2330 
2331         # Rescale to 0-1, keeping range before contrast stretch
2332         # If constant slope, keep relative scaling (i.e. flat should be 0.5,
2333         # fully occluded 0, etc.)
2334         if (imax - imin) > 1e-6:
2335             # Strictly speaking, this is incorrect. Negative values should be
2336             # clipped to 0 because they're fully occluded. However, rescaling
2337             # in this manner is consistent with the previous implementation and
2338             # visually appears better than a "hard" clip.
2339             intensity -= imin
2340             intensity /= (imax - imin)
2341         intensity = np.clip(intensity, 0, 1)
2342 
2343         return intensity
2344 
2345     def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,
2346               vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):
2347         """
2348         Combine colormapped data values with an illumination intensity map
2349         (a.k.a.  "hillshade") of the values.
2350 
2351         Parameters
2352         ----------
2353         data : 2D array-like
2354             The height values used to generate a shaded map.
2355         cmap : `~matplotlib.colors.Colormap`
2356             The colormap used to color the *data* array. Note that this must be
2357             a `~matplotlib.colors.Colormap` instance.  For example, rather than
2358             passing in ``cmap='gist_earth'``, use
2359             ``cmap=plt.get_cmap('gist_earth')`` instead.
2360         norm : `~matplotlib.colors.Normalize` instance, optional
2361             The normalization used to scale values before colormapping. If
2362             None, the input will be linearly scaled between its min and max.
2363         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
2364             The type of blending used to combine the colormapped data
2365             values with the illumination intensity.  Default is
2366             "overlay".  Note that for most topographic surfaces,
2367             "overlay" or "soft" appear more visually realistic. If a
2368             user-defined function is supplied, it is expected to
2369             combine an MxNx3 RGB array of floats (ranging 0 to 1) with
2370             an MxNx1 hillshade array (also 0 to 1).  (Call signature
2371             ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
2372             to this function will be passed on to the *blend_mode*
2373             function.
2374         vmin : float or None, optional
2375             The minimum value used in colormapping *data*. If *None* the
2376             minimum value in *data* is used. If *norm* is specified, then this
2377             argument will be ignored.
2378         vmax : float or None, optional
2379             The maximum value used in colormapping *data*. If *None* the
2380             maximum value in *data* is used. If *norm* is specified, then this
2381             argument will be ignored.
2382         vert_exag : number, optional
2383             The amount to exaggerate the elevation values by when calculating
2384             illumination. This can be used either to correct for differences in
2385             units between the x-y coordinate system and the elevation
2386             coordinate system (e.g. decimal degrees vs. meters) or to
2387             exaggerate or de-emphasize topography.
2388         dx : number, optional
2389             The x-spacing (columns) of the input *elevation* grid.
2390         dy : number, optional
2391             The y-spacing (rows) of the input *elevation* grid.
2392         fraction : number, optional
2393             Increases or decreases the contrast of the hillshade.  Values
2394             greater than one will cause intermediate values to move closer to
2395             full illumination or shadow (and clipping any values that move
2396             beyond 0 or 1). Note that this is not visually or mathematically
2397             the same as vertical exaggeration.
2398         Additional kwargs are passed on to the *blend_mode* function.
2399 
2400         Returns
2401         -------
2402         `~numpy.ndarray`
2403             An MxNx4 array of floats ranging between 0-1.
2404         """
2405         if vmin is None:
2406             vmin = data.min()
2407         if vmax is None:
2408             vmax = data.max()
2409         if norm is None:
2410             norm = Normalize(vmin=vmin, vmax=vmax)
2411 
2412         rgb0 = cmap(norm(data))
2413         rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,
2414                               vert_exag=vert_exag, dx=dx, dy=dy,
2415                               fraction=fraction, **kwargs)
2416         # Don't overwrite the alpha channel, if present.
2417         rgb0[..., :3] = rgb1[..., :3]
2418         return rgb0
2419 
2420     def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',
2421                   vert_exag=1, dx=1, dy=1, **kwargs):
2422         """
2423         Use this light source to adjust the colors of the *rgb* input array to
2424         give the impression of a shaded relief map with the given *elevation*.
2425 
2426         Parameters
2427         ----------
2428         rgb : array-like
2429             An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
2430         elevation : array-like
2431             An (M, N) array of the height values used to generate a shaded map.
2432         fraction : number
2433             Increases or decreases the contrast of the hillshade.  Values
2434             greater than one will cause intermediate values to move closer to
2435             full illumination or shadow (and clipping any values that move
2436             beyond 0 or 1). Note that this is not visually or mathematically
2437             the same as vertical exaggeration.
2438         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
2439             The type of blending used to combine the colormapped data values
2440             with the illumination intensity.  For backwards compatibility, this
2441             defaults to "hsv". Note that for most topographic surfaces,
2442             "overlay" or "soft" appear more visually realistic. If a
2443             user-defined function is supplied, it is expected to combine an
2444             MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
2445             array (also 0 to 1).  (Call signature
2446             ``func(rgb, illum, **kwargs)``)
2447             Additional kwargs supplied to this function will be passed on to
2448             the *blend_mode* function.
2449         vert_exag : number, optional
2450             The amount to exaggerate the elevation values by when calculating
2451             illumination. This can be used either to correct for differences in
2452             units between the x-y coordinate system and the elevation
2453             coordinate system (e.g. decimal degrees vs. meters) or to
2454             exaggerate or de-emphasize topography.
2455         dx : number, optional
2456             The x-spacing (columns) of the input *elevation* grid.
2457         dy : number, optional
2458             The y-spacing (rows) of the input *elevation* grid.
2459         Additional kwargs are passed on to the *blend_mode* function.
2460 
2461         Returns
2462         -------
2463         `~numpy.ndarray`
2464             An (m, n, 3) array of floats ranging between 0-1.
2465         """
2466         # Calculate the "hillshade" intensity.
2467         intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)
2468         intensity = intensity[..., np.newaxis]
2469 
2470         # Blend the hillshade and rgb data using the specified mode
2471         lookup = {
2472                 'hsv': self.blend_hsv,
2473                 'soft': self.blend_soft_light,
2474                 'overlay': self.blend_overlay,
2475                 }
2476         if blend_mode in lookup:
2477             blend = lookup[blend_mode](rgb, intensity, **kwargs)
2478         else:
2479             try:
2480                 blend = blend_mode(rgb, intensity, **kwargs)
2481             except TypeError as err:
2482                 raise ValueError('"blend_mode" must be callable or one of '
2483                                  f'{lookup.keys}') from err
2484 
2485         # Only apply result where hillshade intensity isn't masked
2486         if np.ma.is_masked(intensity):
2487             mask = intensity.mask[..., 0]
2488             for i in range(3):
2489                 blend[..., i][mask] = rgb[..., i][mask]
2490 
2491         return blend
2492 
2493     def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,
2494                   hsv_min_val=None, hsv_min_sat=None):
2495         """
2496         Take the input data array, convert to HSV values in the given colormap,
2497         then adjust those color values to give the impression of a shaded
2498         relief map with a specified light source.  RGBA values are returned,
2499         which can then be used to plot the shaded image with imshow.
2500 
2501         The color of the resulting image will be darkened by moving the (s, v)
2502         values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the
2503         shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
2504         hsv_max_val) in regions that are illuminated.  The default extremes are
2505         chose so that completely shaded points are nearly black (s = 1, v = 0)
2506         and completely illuminated points are nearly white (s = 0, v = 1).
2507 
2508         Parameters
2509         ----------
2510         rgb : `~numpy.ndarray`
2511             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
2512         intensity : `~numpy.ndarray`
2513             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
2514         hsv_max_sat : number, default: 1
2515             The maximum saturation value that the *intensity* map can shift the
2516             output image to.
2517         hsv_min_sat : number, optional
2518             The minimum saturation value that the *intensity* map can shift the
2519             output image to. Defaults to 0.
2520         hsv_max_val : number, optional
2521             The maximum value ("v" in "hsv") that the *intensity* map can shift
2522             the output image to. Defaults to 1.
2523         hsv_min_val : number, optional
2524             The minimum value ("v" in "hsv") that the *intensity* map can shift
2525             the output image to. Defaults to 0.
2526 
2527         Returns
2528         -------
2529         `~numpy.ndarray`
2530             An MxNx3 RGB array representing the combined images.
2531         """
2532         # Backward compatibility...
2533         if hsv_max_sat is None:
2534             hsv_max_sat = self.hsv_max_sat
2535         if hsv_max_val is None:
2536             hsv_max_val = self.hsv_max_val
2537         if hsv_min_sat is None:
2538             hsv_min_sat = self.hsv_min_sat
2539         if hsv_min_val is None:
2540             hsv_min_val = self.hsv_min_val
2541 
2542         # Expects a 2D intensity array scaled between -1 to 1...
2543         intensity = intensity[..., 0]
2544         intensity = 2 * intensity - 1
2545 
2546         # Convert to rgb, then rgb to hsv
2547         hsv = rgb_to_hsv(rgb[:, :, 0:3])
2548         hue, sat, val = np.moveaxis(hsv, -1, 0)
2549 
2550         # Modify hsv values (in place) to simulate illumination.
2551         # putmask(A, mask, B) <=> A[mask] = B[mask]
2552         np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),
2553                    (1 - intensity) * sat + intensity * hsv_max_sat)
2554         np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),
2555                    (1 + intensity) * sat - intensity * hsv_min_sat)
2556         np.putmask(val, intensity > 0,
2557                    (1 - intensity) * val + intensity * hsv_max_val)
2558         np.putmask(val, intensity < 0,
2559                    (1 + intensity) * val - intensity * hsv_min_val)
2560         np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])
2561 
2562         # Convert modified hsv back to rgb.
2563         return hsv_to_rgb(hsv)
2564 
2565     def blend_soft_light(self, rgb, intensity):
2566         """
2567         Combine an RGB image with an intensity map using "soft light" blending,
2568         using the "pegtop" formula.
2569 
2570         Parameters
2571         ----------
2572         rgb : `~numpy.ndarray`
2573             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
2574         intensity : `~numpy.ndarray`
2575             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
2576 
2577         Returns
2578         -------
2579         `~numpy.ndarray`
2580             An MxNx3 RGB array representing the combined images.
2581         """
2582         return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2
2583 
2584     def blend_overlay(self, rgb, intensity):
2585         """
2586         Combine an RGB image with an intensity map using "overlay" blending.
2587 
2588         Parameters
2589         ----------
2590         rgb : `~numpy.ndarray`
2591             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
2592         intensity : `~numpy.ndarray`
2593             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
2594 
2595         Returns
2596         -------
2597         ndarray
2598             An MxNx3 RGB array representing the combined images.
2599         """
2600         low = 2 * intensity * rgb
2601         high = 1 - 2 * (1 - intensity) * (1 - rgb)
2602         return np.where(rgb <= 0.5, low, high)
2603 
2604 
2605 def from_levels_and_colors(levels, colors, extend='neither'):
2606     """
2607     A helper routine to generate a cmap and a norm instance which
2608     behave similar to contourf's levels and colors arguments.
2609 
2610     Parameters
2611     ----------
2612     levels : sequence of numbers
2613         The quantization levels used to construct the `BoundaryNorm`.
2614         Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
2615     colors : sequence of colors
2616         The fill color to use for each level. If *extend* is "neither" there
2617         must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
2618         one extra color, and for an *extend* of "both" add two colors.
2619     extend : {'neither', 'min', 'max', 'both'}, optional
2620         The behaviour when a value falls out of range of the given levels.
2621         See `~.Axes.contourf` for details.
2622 
2623     Returns
2624     -------
2625     cmap : `~matplotlib.colors.Normalize`
2626     norm : `~matplotlib.colors.Colormap`
2627     """
2628     slice_map = {
2629         'both': slice(1, -1),
2630         'min': slice(1, None),
2631         'max': slice(0, -1),
2632         'neither': slice(0, None),
2633     }
2634     _api.check_in_list(slice_map, extend=extend)
2635     color_slice = slice_map[extend]
2636 
2637     n_data_colors = len(levels) - 1
2638     n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)
2639     if len(colors) != n_expected:
2640         raise ValueError(
2641             f'With extend == {extend!r} and {len(levels)} levels, '
2642             f'expected {n_expected} colors, but got {len(colors)}')
2643 
2644     cmap = ListedColormap(colors[color_slice], N=n_data_colors)
2645 
2646     if extend in ['min', 'both']:
2647         cmap.set_under(colors[0])
2648     else:
2649         cmap.set_under('none')
2650 
2651     if extend in ['max', 'both']:
2652         cmap.set_over(colors[-1])
2653     else:
2654         cmap.set_over('none')
2655 
2656     cmap.colorbar_extend = extend
2657 
2658     norm = BoundaryNorm(levels, ncolors=n_data_colors)
2659     return cmap, norm

</code><intended_behavior>Ensure that any updates to `vmin` and `vmax` after the initial setting are validated and processed in a manner that acknowledges the constraints of logarithmic scaling (i.e., both must be positive, and `vmin` must be less than `vmax`). It would involve dynamically recalculating the normalized values and applying them without causing errors under valid configurations.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Colorbars are a visualization of the mapping from scalar values to colors.
3 In Matplotlib they are drawn into a dedicated `~.axes.Axes`.
4 
5 .. note::
6    Colorbars are typically created through `.Figure.colorbar` or its pyplot
7    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with
8    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for
9    non-`.GridSpec`-positioned axes).
10 
11    End-users most likely won't need to directly use this module's API.
12 """
13 
14 import logging
15 
16 import numpy as np
17 
18 import matplotlib as mpl
19 from matplotlib import _api, cbook, collections, cm, colors, contour, ticker
20 import matplotlib.artist as martist
21 import matplotlib.patches as mpatches
22 import matplotlib.path as mpath
23 import matplotlib.spines as mspines
24 import matplotlib.transforms as mtransforms
25 from matplotlib import _docstring
26 
27 _log = logging.getLogger(__name__)
28 
29 _docstring.interpd.update(
30     _make_axes_kw_doc="""
31 location : None or {'left', 'right', 'top', 'bottom'}
32     The location, relative to the parent axes, where the colorbar axes
33     is created.  It also determines the *orientation* of the colorbar
34     (colorbars on the left and right are vertical, colorbars at the top
35     and bottom are horizontal).  If None, the location will come from the
36     *orientation* if it is set (vertical colorbars on the right, horizontal
37     ones at the bottom), or default to 'right' if *orientation* is unset.
38 
39 orientation : None or {'vertical', 'horizontal'}
40     The orientation of the colorbar.  It is preferable to set the *location*
41     of the colorbar, as that also determines the *orientation*; passing
42     incompatible values for *location* and *orientation* raises an exception.
43 
44 fraction : float, default: 0.15
45     Fraction of original axes to use for colorbar.
46 
47 shrink : float, default: 1.0
48     Fraction by which to multiply the size of the colorbar.
49 
50 aspect : float, default: 20
51     Ratio of long to short dimensions.
52 
53 pad : float, default: 0.05 if vertical, 0.15 if horizontal
54     Fraction of original axes between colorbar and new image axes.
55 
56 anchor : (float, float), optional
57     The anchor point of the colorbar axes.
58     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.
59 
60 panchor : (float, float), or *False*, optional
61     The anchor point of the colorbar parent axes. If *False*, the parent
62     axes' anchor will be unchanged.
63     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.""",
64     _colormap_kw_doc="""
65 extend : {'neither', 'both', 'min', 'max'}
66     Make pointed end(s) for out-of-range values (unless 'neither').  These are
67     set for a given colormap using the colormap set_under and set_over methods.
68 
69 extendfrac : {*None*, 'auto', length, lengths}
70     If set to *None*, both the minimum and maximum triangular colorbar
71     extensions will have a length of 5% of the interior colorbar length (this
72     is the default setting).
73 
74     If set to 'auto', makes the triangular colorbar extensions the same lengths
75     as the interior boxes (when *spacing* is set to 'uniform') or the same
76     lengths as the respective adjacent interior boxes (when *spacing* is set to
77     'proportional').
78 
79     If a scalar, indicates the length of both the minimum and maximum
80     triangular colorbar extensions as a fraction of the interior colorbar
81     length.  A two-element sequence of fractions may also be given, indicating
82     the lengths of the minimum and maximum colorbar extensions respectively as
83     a fraction of the interior colorbar length.
84 
85 extendrect : bool
86     If *False* the minimum and maximum colorbar extensions will be triangular
87     (the default).  If *True* the extensions will be rectangular.
88 
89 spacing : {'uniform', 'proportional'}
90     For discrete colorbars (`.BoundaryNorm` or contours), 'uniform' gives each
91     color the same space; 'proportional' makes the space proportional to the
92     data interval.
93 
94 ticks : None or list of ticks or Locator
95     If None, ticks are determined automatically from the input.
96 
97 format : None or str or Formatter
98     If None, `~.ticker.ScalarFormatter` is used.
99     Format strings, e.g., ``"%4.2e"`` or ``"{x:.2e}"``, are supported.
100     An alternative `~.ticker.Formatter` may be given instead.
101 
102 drawedges : bool
103     Whether to draw lines at color boundaries.
104 
105 label : str
106     The label on the colorbar's long axis.
107 
108 boundaries, values : None or a sequence
109     If unset, the colormap will be displayed on a 0-1 scale.
110     If sequences, *values* must have a length 1 less than *boundaries*.  For
111     each region delimited by adjacent entries in *boundaries*, the color mapped
112     to the corresponding value in values will be used.
113     Normally only useful for indexed colors (i.e. ``norm=NoNorm()``) or other
114     unusual circumstances.""")
115 
116 
117 def _set_ticks_on_axis_warn(*args, **kwargs):
118     # a top level function which gets put in at the axes'
119     # set_xticks and set_yticks by Colorbar.__init__.
120     _api.warn_external("Use the colorbar set_ticks() method instead.")
121 
122 
123 class _ColorbarSpine(mspines.Spine):
124     def __init__(self, axes):
125         self._ax = axes
126         super().__init__(axes, 'colorbar', mpath.Path(np.empty((0, 2))))
127         mpatches.Patch.set_transform(self, axes.transAxes)
128 
129     def get_window_extent(self, renderer=None):
130         # This Spine has no Axis associated with it, and doesn't need to adjust
131         # its location, so we can directly get the window extent from the
132         # super-super-class.
133         return mpatches.Patch.get_window_extent(self, renderer=renderer)
134 
135     def set_xy(self, xy):
136         self._path = mpath.Path(xy, closed=True)
137         self._xy = xy
138         self.stale = True
139 
140     def draw(self, renderer):
141         ret = mpatches.Patch.draw(self, renderer)
142         self.stale = False
143         return ret
144 
145 
146 class _ColorbarAxesLocator:
147     """
148     Shrink the axes if there are triangular or rectangular extends.
149     """
150     def __init__(self, cbar):
151         self._cbar = cbar
152         self._orig_locator = cbar.ax._axes_locator
153 
154     def __call__(self, ax, renderer):
155         if self._orig_locator is not None:
156             pos = self._orig_locator(ax, renderer)
157         else:
158             pos = ax.get_position(original=True)
159         if self._cbar.extend == 'neither':
160             return pos
161 
162         y, extendlen = self._cbar._proportional_y()
163         if not self._cbar._extend_lower():
164             extendlen[0] = 0
165         if not self._cbar._extend_upper():
166             extendlen[1] = 0
167         len = sum(extendlen) + 1
168         shrink = 1 / len
169         offset = extendlen[0] / len
170         # we need to reset the aspect ratio of the axes to account
171         # of the extends...
172         if hasattr(ax, '_colorbar_info'):
173             aspect = ax._colorbar_info['aspect']
174         else:
175             aspect = False
176         # now shrink and/or offset to take into account the
177         # extend tri/rectangles.
178         if self._cbar.orientation == 'vertical':
179             if aspect:
180                 self._cbar.ax.set_box_aspect(aspect*shrink)
181             pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)
182         else:
183             if aspect:
184                 self._cbar.ax.set_box_aspect(1/(aspect * shrink))
185             pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)
186         return pos
187 
188     def get_subplotspec(self):
189         # make tight_layout happy..
190         return (
191             self._cbar.ax.get_subplotspec()
192             or getattr(self._orig_locator, "get_subplotspec", lambda: None)())
193 
194 
195 @_docstring.interpd
196 class Colorbar:
197     r"""
198     Draw a colorbar in an existing axes.
199 
200     Typically, colorbars are created using `.Figure.colorbar` or
201     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
202     `.AxesImage` generated via `~.axes.Axes.imshow`).
203 
204     In order to draw a colorbar not associated with other elements in the
205     figure, e.g. when showing a colormap by itself, one can create an empty
206     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
207     to `Colorbar`.
208 
209     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
210 
211     Attributes
212     ----------
213     ax : `~matplotlib.axes.Axes`
214         The `~.axes.Axes` instance in which the colorbar is drawn.
215     lines : list
216         A list of `.LineCollection` (empty if no lines were drawn).
217     dividers : `.LineCollection`
218         A LineCollection (empty if *drawedges* is ``False``).
219 
220     Parameters
221     ----------
222     ax : `~matplotlib.axes.Axes`
223         The `~.axes.Axes` instance in which the colorbar is drawn.
224 
225     mappable : `.ScalarMappable`
226         The mappable whose colormap and norm will be used.
227 
228         To show the under- and over- value colors, the mappable's norm should
229         be specified as ::
230 
231             norm = colors.Normalize(clip=False)
232 
233         To show the colors versus index instead of on a 0-1 scale, use::
234 
235             norm=colors.NoNorm()
236 
237     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
238         The colormap to use.  This parameter is ignored, unless *mappable* is
239         None.
240 
241     norm : `~matplotlib.colors.Normalize`
242         The normalization to use.  This parameter is ignored, unless *mappable*
243         is None.
244 
245     alpha : float
246         The colorbar transparency between 0 (transparent) and 1 (opaque).
247 
248     orientation : None or {'vertical', 'horizontal'}
249         If None, use the value determined by *location*. If both
250         *orientation* and *location* are None then defaults to 'vertical'.
251 
252     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
253         The location of the colorbar ticks. The *ticklocation* must match
254         *orientation*. For example, a horizontal colorbar can only have ticks
255         at the top or the bottom. If 'auto', the ticks will be the same as
256         *location*, so a colorbar to the left will have ticks to the left. If
257         *location* is None, the ticks will be at the bottom for a horizontal
258         colorbar and at the right for a vertical.
259 
260     drawedges : bool
261         Whether to draw lines at color boundaries.
262 
263     filled : bool
264 
265     %(_colormap_kw_doc)s
266 
267     location : None or {'left', 'right', 'top', 'bottom'}
268         Set the *orientation* and *ticklocation* of the colorbar using a
269         single argument. Colorbars on the left and right are vertical,
270         colorbars at the top and bottom are horizontal. The *ticklocation* is
271         the same as *location*, so if *location* is 'top', the ticks are on
272         the top. *orientation* and/or *ticklocation* can be provided as well
273         and overrides the value set by *location*, but there will be an error
274         for incompatible combinations.
275 
276         .. versionadded:: 3.7
277     """
278 
279     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
280 
281     @_api.delete_parameter("3.6", "filled")
282     def __init__(self, ax, mappable=None, *, cmap=None,
283                  norm=None,
284                  alpha=None,
285                  values=None,
286                  boundaries=None,
287                  orientation=None,
288                  ticklocation='auto',
289                  extend=None,
290                  spacing='uniform',  # uniform or proportional
291                  ticks=None,
292                  format=None,
293                  drawedges=False,
294                  filled=True,
295                  extendfrac=None,
296                  extendrect=False,
297                  label='',
298                  location=None,
299                  ):
300 
301         if mappable is None:
302             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
303 
304         # Ensure the given mappable's norm has appropriate vmin and vmax
305         # set even if mappable.draw has not yet been called.
306         if mappable.get_array() is not None:
307             mappable.autoscale_None()
308 
309         self.mappable = mappable
310         cmap = mappable.cmap
311         norm = mappable.norm
312 
313         if isinstance(mappable, contour.ContourSet):
314             cs = mappable
315             alpha = cs.get_alpha()
316             boundaries = cs._levels
317             values = cs.cvalues
318             extend = cs.extend
319             filled = cs.filled
320             if ticks is None:
321                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
322         elif isinstance(mappable, martist.Artist):
323             alpha = mappable.get_alpha()
324 
325         mappable.colorbar = self
326         mappable.colorbar_cid = mappable.callbacks.connect(
327             'changed', self.update_normal)
328 
329         location_orientation = _get_orientation_from_location(location)
330 
331         _api.check_in_list(
332             [None, 'vertical', 'horizontal'], orientation=orientation)
333         _api.check_in_list(
334             ['auto', 'left', 'right', 'top', 'bottom'],
335             ticklocation=ticklocation)
336         _api.check_in_list(
337             ['uniform', 'proportional'], spacing=spacing)
338 
339         if location_orientation is not None and orientation is not None:
340             if location_orientation != orientation:
341                 raise TypeError(
342                     "location and orientation are mutually exclusive")
343         else:
344             orientation = orientation or location_orientation or "vertical"
345 
346         self.ax = ax
347         self.ax._axes_locator = _ColorbarAxesLocator(self)
348 
349         if extend is None:
350             if (not isinstance(mappable, contour.ContourSet)
351                     and getattr(cmap, 'colorbar_extend', False) is not False):
352                 extend = cmap.colorbar_extend
353             elif hasattr(norm, 'extend'):
354                 extend = norm.extend
355             else:
356                 extend = 'neither'
357         self.alpha = None
358         # Call set_alpha to handle array-like alphas properly
359         self.set_alpha(alpha)
360         self.cmap = cmap
361         self.norm = norm
362         self.values = values
363         self.boundaries = boundaries
364         self.extend = extend
365         self._inside = _api.check_getitem(
366             {'neither': slice(0, None), 'both': slice(1, -1),
367              'min': slice(1, None), 'max': slice(0, -1)},
368             extend=extend)
369         self.spacing = spacing
370         self.orientation = orientation
371         self.drawedges = drawedges
372         self._filled = filled
373         self.extendfrac = extendfrac
374         self.extendrect = extendrect
375         self._extend_patches = []
376         self.solids = None
377         self.solids_patches = []
378         self.lines = []
379 
380         for spine in self.ax.spines.values():
381             spine.set_visible(False)
382         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
383 
384         self.dividers = collections.LineCollection(
385             [],
386             colors=[mpl.rcParams['axes.edgecolor']],
387             linewidths=[0.5 * mpl.rcParams['axes.linewidth']],
388             clip_on=False)
389         self.ax.add_collection(self.dividers)
390 
391         self._locator = None
392         self._minorlocator = None
393         self._formatter = None
394         self._minorformatter = None
395 
396         if ticklocation == 'auto':
397             ticklocation = _get_ticklocation_from_orientation(
398                 orientation) if location is None else location
399         self.ticklocation = ticklocation
400 
401         self.set_label(label)
402         self._reset_locator_formatter_scale()
403 
404         if np.iterable(ticks):
405             self._locator = ticker.FixedLocator(ticks, nbins=len(ticks))
406         else:
407             self._locator = ticks
408 
409         if isinstance(format, str):
410             # Check format between FormatStrFormatter and StrMethodFormatter
411             try:
412                 self._formatter = ticker.FormatStrFormatter(format)
413                 _ = self._formatter(0)
414             except TypeError:
415                 self._formatter = ticker.StrMethodFormatter(format)
416         else:
417             self._formatter = format  # Assume it is a Formatter or None
418         self._draw_all()
419 
420         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
421             self.add_lines(mappable)
422 
423         # Link the Axes and Colorbar for interactive use
424         self.ax._colorbar = self
425         # Don't navigate on any of these types of mappables
426         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
427                 isinstance(self.mappable, contour.ContourSet)):
428             self.ax.set_navigate(False)
429 
430         # These are the functions that set up interactivity on this colorbar
431         self._interactive_funcs = ["_get_view", "_set_view",
432                                    "_set_view_from_bbox", "drag_pan"]
433         for x in self._interactive_funcs:
434             setattr(self.ax, x, getattr(self, x))
435         # Set the cla function to the cbar's method to override it
436         self.ax.cla = self._cbar_cla
437         # Callbacks for the extend calculations to handle inverting the axis
438         self._extend_cid1 = self.ax.callbacks.connect(
439             "xlim_changed", self._do_extends)
440         self._extend_cid2 = self.ax.callbacks.connect(
441             "ylim_changed", self._do_extends)
442 
443     @property
444     def locator(self):
445         """Major tick `.Locator` for the colorbar."""
446         return self._long_axis().get_major_locator()
447 
448     @locator.setter
449     def locator(self, loc):
450         self._long_axis().set_major_locator(loc)
451         self._locator = loc
452 
453     @property
454     def minorlocator(self):
455         """Minor tick `.Locator` for the colorbar."""
456         return self._long_axis().get_minor_locator()
457 
458     @minorlocator.setter
459     def minorlocator(self, loc):
460         self._long_axis().set_minor_locator(loc)
461         self._minorlocator = loc
462 
463     @property
464     def formatter(self):
465         """Major tick label `.Formatter` for the colorbar."""
466         return self._long_axis().get_major_formatter()
467 
468     @formatter.setter
469     def formatter(self, fmt):
470         self._long_axis().set_major_formatter(fmt)
471         self._formatter = fmt
472 
473     @property
474     def minorformatter(self):
475         """Minor tick `.Formatter` for the colorbar."""
476         return self._long_axis().get_minor_formatter()
477 
478     @minorformatter.setter
479     def minorformatter(self, fmt):
480         self._long_axis().set_minor_formatter(fmt)
481         self._minorformatter = fmt
482 
483     def _cbar_cla(self):
484         """Function to clear the interactive colorbar state."""
485         for x in self._interactive_funcs:
486             delattr(self.ax, x)
487         # We now restore the old cla() back and can call it directly
488         del self.ax.cla
489         self.ax.cla()
490 
491     filled = _api.deprecate_privatize_attribute("3.6")
492 
493     def update_normal(self, mappable):
494         """
495         Update solid patches, lines, etc.
496 
497         This is meant to be called when the norm of the image or contour plot
498         to which this colorbar belongs changes.
499 
500         If the norm on the mappable is different than before, this resets the
501         locator and formatter for the axis, so if these have been customized,
502         they will need to be customized again.  However, if the norm only
503         changes values of *vmin*, *vmax* or *cmap* then the old formatter
504         and locator will be preserved.
505         """
506         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
507         self.mappable = mappable
508         self.set_alpha(mappable.get_alpha())
509         self.cmap = mappable.cmap
510         if mappable.norm != self.norm:
511             self.norm = mappable.norm
512             self._reset_locator_formatter_scale()
513 
514         self._draw_all()
515         if isinstance(self.mappable, contour.ContourSet):
516             CS = self.mappable
517             if not CS.filled:
518                 self.add_lines(CS)
519         self.stale = True
520 
521     @_api.deprecated("3.6", alternative="fig.draw_without_rendering()")
522     def draw_all(self):
523         """
524         Calculate any free parameters based on the current cmap and norm,
525         and do all the drawing.
526         """
527         self._draw_all()
528 
529     def _draw_all(self):
530         """
531         Calculate any free parameters based on the current cmap and norm,
532         and do all the drawing.
533         """
534         if self.orientation == 'vertical':
535             if mpl.rcParams['ytick.minor.visible']:
536                 self.minorticks_on()
537         else:
538             if mpl.rcParams['xtick.minor.visible']:
539                 self.minorticks_on()
540         self._long_axis().set(label_position=self.ticklocation,
541                               ticks_position=self.ticklocation)
542         self._short_axis().set_ticks([])
543         self._short_axis().set_ticks([], minor=True)
544 
545         # Set self._boundaries and self._values, including extensions.
546         # self._boundaries are the edges of each square of color, and
547         # self._values are the value to map into the norm to get the
548         # color:
549         self._process_values()
550         # Set self.vmin and self.vmax to first and last boundary, excluding
551         # extensions:
552         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
553         # Compute the X/Y mesh.
554         X, Y = self._mesh()
555         # draw the extend triangles, and shrink the inner axes to accommodate.
556         # also adds the outline path to self.outline spine:
557         self._do_extends()
558         lower, upper = self.vmin, self.vmax
559         if self._long_axis().get_inverted():
560             # If the axis is inverted, we need to swap the vmin/vmax
561             lower, upper = upper, lower
562         if self.orientation == 'vertical':
563             self.ax.set_xlim(0, 1)
564             self.ax.set_ylim(lower, upper)
565         else:
566             self.ax.set_ylim(0, 1)
567             self.ax.set_xlim(lower, upper)
568 
569         # set up the tick locators and formatters.  A bit complicated because
570         # boundary norms + uniform spacing requires a manual locator.
571         self.update_ticks()
572 
573         if self._filled:
574             ind = np.arange(len(self._values))
575             if self._extend_lower():
576                 ind = ind[1:]
577             if self._extend_upper():
578                 ind = ind[:-1]
579             self._add_solids(X, Y, self._values[ind, np.newaxis])
580 
581     def _add_solids(self, X, Y, C):
582         """Draw the colors; optionally add separators."""
583         # Cleanup previously set artists.
584         if self.solids is not None:
585             self.solids.remove()
586         for solid in self.solids_patches:
587             solid.remove()
588         # Add new artist(s), based on mappable type.  Use individual patches if
589         # hatching is needed, pcolormesh otherwise.
590         mappable = getattr(self, 'mappable', None)
591         if (isinstance(mappable, contour.ContourSet)
592                 and any(hatch is not None for hatch in mappable.hatches)):
593             self._add_solids_patches(X, Y, C, mappable)
594         else:
595             self.solids = self.ax.pcolormesh(
596                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
597                 edgecolors='none', shading='flat')
598             if not self.drawedges:
599                 if len(self._y) >= self.n_rasterize:
600                     self.solids.set_rasterized(True)
601         self._update_dividers()
602 
603     def _update_dividers(self):
604         if not self.drawedges:
605             self.dividers.set_segments([])
606             return
607         # Place all *internal* dividers.
608         if self.orientation == 'vertical':
609             lims = self.ax.get_ylim()
610             bounds = (lims[0] < self._y) & (self._y < lims[1])
611         else:
612             lims = self.ax.get_xlim()
613             bounds = (lims[0] < self._y) & (self._y < lims[1])
614         y = self._y[bounds]
615         # And then add outer dividers if extensions are on.
616         if self._extend_lower():
617             y = np.insert(y, 0, lims[0])
618         if self._extend_upper():
619             y = np.append(y, lims[1])
620         X, Y = np.meshgrid([0, 1], y)
621         if self.orientation == 'vertical':
622             segments = np.dstack([X, Y])
623         else:
624             segments = np.dstack([Y, X])
625         self.dividers.set_segments(segments)
626 
627     def _add_solids_patches(self, X, Y, C, mappable):
628         hatches = mappable.hatches * (len(C) + 1)  # Have enough hatches.
629         if self._extend_lower():
630             # remove first hatch that goes into the extend patch
631             hatches = hatches[1:]
632         patches = []
633         for i in range(len(X) - 1):
634             xy = np.array([[X[i, 0], Y[i, 1]],
635                            [X[i, 1], Y[i, 0]],
636                            [X[i + 1, 1], Y[i + 1, 0]],
637                            [X[i + 1, 0], Y[i + 1, 1]]])
638             patch = mpatches.PathPatch(mpath.Path(xy),
639                                        facecolor=self.cmap(self.norm(C[i][0])),
640                                        hatch=hatches[i], linewidth=0,
641                                        antialiased=False, alpha=self.alpha)
642             self.ax.add_patch(patch)
643             patches.append(patch)
644         self.solids_patches = patches
645 
646     def _do_extends(self, ax=None):
647         """
648         Add the extend tri/rectangles on the outside of the axes.
649 
650         ax is unused, but required due to the callbacks on xlim/ylim changed
651         """
652         # Clean up any previous extend patches
653         for patch in self._extend_patches:
654             patch.remove()
655         self._extend_patches = []
656         # extend lengths are fraction of the *inner* part of colorbar,
657         # not the total colorbar:
658         _, extendlen = self._proportional_y()
659         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
660         top = 1 + (extendlen[1] if self._extend_upper() else 0)
661 
662         # xyout is the outline of the colorbar including the extend patches:
663         if not self.extendrect:
664             # triangle:
665             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
666                               [1, 1], [0.5, top], [0, 1], [0, 0]])
667         else:
668             # rectangle:
669             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
670                               [1, 1], [1, top], [0, top], [0, 1],
671                               [0, 0]])
672 
673         if self.orientation == 'horizontal':
674             xyout = xyout[:, ::-1]
675 
676         # xyout is the path for the spine:
677         self.outline.set_xy(xyout)
678         if not self._filled:
679             return
680 
681         # Make extend triangles or rectangles filled patches.  These are
682         # defined in the outer parent axes' coordinates:
683         mappable = getattr(self, 'mappable', None)
684         if (isinstance(mappable, contour.ContourSet)
685                 and any(hatch is not None for hatch in mappable.hatches)):
686             hatches = mappable.hatches * (len(self._y) + 1)
687         else:
688             hatches = [None] * (len(self._y) + 1)
689 
690         if self._extend_lower():
691             if not self.extendrect:
692                 # triangle
693                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
694             else:
695                 # rectangle
696                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
697             if self.orientation == 'horizontal':
698                 xy = xy[:, ::-1]
699             # add the patch
700             val = -1 if self._long_axis().get_inverted() else 0
701             color = self.cmap(self.norm(self._values[val]))
702             patch = mpatches.PathPatch(
703                 mpath.Path(xy), facecolor=color, alpha=self.alpha,
704                 linewidth=0, antialiased=False,
705                 transform=self.ax.transAxes,
706                 hatch=hatches[0], clip_on=False,
707                 # Place it right behind the standard patches, which is
708                 # needed if we updated the extends
709                 zorder=np.nextafter(self.ax.patch.zorder, -np.inf))
710             self.ax.add_patch(patch)
711             self._extend_patches.append(patch)
712             # remove first hatch that goes into the extend patch
713             hatches = hatches[1:]
714         if self._extend_upper():
715             if not self.extendrect:
716                 # triangle
717                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
718             else:
719                 # rectangle
720                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
721             if self.orientation == 'horizontal':
722                 xy = xy[:, ::-1]
723             # add the patch
724             val = 0 if self._long_axis().get_inverted() else -1
725             color = self.cmap(self.norm(self._values[val]))
726             hatch_idx = len(self._y) - 1
727             patch = mpatches.PathPatch(
728                 mpath.Path(xy), facecolor=color, alpha=self.alpha,
729                 linewidth=0, antialiased=False,
730                 transform=self.ax.transAxes, hatch=hatches[hatch_idx],
731                 clip_on=False,
732                 # Place it right behind the standard patches, which is
733                 # needed if we updated the extends
734                 zorder=np.nextafter(self.ax.patch.zorder, -np.inf))
735             self.ax.add_patch(patch)
736             self._extend_patches.append(patch)
737 
738         self._update_dividers()
739 
740     def add_lines(self, *args, **kwargs):
741         """
742         Draw lines on the colorbar.
743 
744         The lines are appended to the list :attr:`lines`.
745 
746         Parameters
747         ----------
748         levels : array-like
749             The positions of the lines.
750         colors : color or list of colors
751             Either a single color applying to all lines or one color value for
752             each line.
753         linewidths : float or array-like
754             Either a single linewidth applying to all lines or one linewidth
755             for each line.
756         erase : bool, default: True
757             Whether to remove any previously added lines.
758 
759         Notes
760         -----
761         Alternatively, this method can also be called with the signature
762         ``colorbar.add_lines(contour_set, erase=True)``, in which case
763         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
764         """
765         params = _api.select_matching_signature(
766             [lambda self, CS, erase=True: locals(),
767              lambda self, levels, colors, linewidths, erase=True: locals()],
768             self, *args, **kwargs)
769         if "CS" in params:
770             self, CS, erase = params.values()
771             if not isinstance(CS, contour.ContourSet) or CS.filled:
772                 raise ValueError("If a single artist is passed to add_lines, "
773                                  "it must be a ContourSet of lines")
774             # TODO: Make colorbar lines auto-follow changes in contour lines.
775             return self.add_lines(
776                 CS.levels,
777                 [c[0] for c in CS.tcolors],
778                 [t[0] for t in CS.tlinewidths],
779                 erase=erase)
780         else:
781             self, levels, colors, linewidths, erase = params.values()
782 
783         y = self._locate(levels)
784         rtol = (self._y[-1] - self._y[0]) * 1e-10
785         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
786         y = y[igood]
787         if np.iterable(colors):
788             colors = np.asarray(colors)[igood]
789         if np.iterable(linewidths):
790             linewidths = np.asarray(linewidths)[igood]
791         X, Y = np.meshgrid([0, 1], y)
792         if self.orientation == 'vertical':
793             xy = np.stack([X, Y], axis=-1)
794         else:
795             xy = np.stack([Y, X], axis=-1)
796         col = collections.LineCollection(xy, linewidths=linewidths,
797                                          colors=colors)
798 
799         if erase and self.lines:
800             for lc in self.lines:
801                 lc.remove()
802             self.lines = []
803         self.lines.append(col)
804 
805         # make a clip path that is just a linewidth bigger than the axes...
806         fac = np.max(linewidths) / 72
807         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
808         inches = self.ax.get_figure().dpi_scale_trans
809         # do in inches:
810         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
811         xy[[0, 1, 4], 1] -= fac
812         xy[[2, 3], 1] += fac
813         # back to axes units...
814         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
815         col.set_clip_path(mpath.Path(xy, closed=True),
816                           self.ax.transAxes)
817         self.ax.add_collection(col)
818         self.stale = True
819 
820     def update_ticks(self):
821         """
822         Set up the ticks and ticklabels. This should not be needed by users.
823         """
824         # Get the locator and formatter; defaults to self._locator if not None.
825         self._get_ticker_locator_formatter()
826         self._long_axis().set_major_locator(self._locator)
827         self._long_axis().set_minor_locator(self._minorlocator)
828         self._long_axis().set_major_formatter(self._formatter)
829 
830     def _get_ticker_locator_formatter(self):
831         """
832         Return the ``locator`` and ``formatter`` of the colorbar.
833 
834         If they have not been defined (i.e. are *None*), the formatter and
835         locator are retrieved from the axis, or from the value of the
836         boundaries for a boundary norm.
837 
838         Called by update_ticks...
839         """
840         locator = self._locator
841         formatter = self._formatter
842         minorlocator = self._minorlocator
843         if isinstance(self.norm, colors.BoundaryNorm):
844             b = self.norm.boundaries
845             if locator is None:
846                 locator = ticker.FixedLocator(b, nbins=10)
847             if minorlocator is None:
848                 minorlocator = ticker.FixedLocator(b)
849         elif isinstance(self.norm, colors.NoNorm):
850             if locator is None:
851                 # put ticks on integers between the boundaries of NoNorm
852                 nv = len(self._values)
853                 base = 1 + int(nv / 10)
854                 locator = ticker.IndexLocator(base=base, offset=.5)
855         elif self.boundaries is not None:
856             b = self._boundaries[self._inside]
857             if locator is None:
858                 locator = ticker.FixedLocator(b, nbins=10)
859         else:  # most cases:
860             if locator is None:
861                 # we haven't set the locator explicitly, so use the default
862                 # for this axis:
863                 locator = self._long_axis().get_major_locator()
864             if minorlocator is None:
865                 minorlocator = self._long_axis().get_minor_locator()
866 
867         if minorlocator is None:
868             minorlocator = ticker.NullLocator()
869 
870         if formatter is None:
871             formatter = self._long_axis().get_major_formatter()
872 
873         self._locator = locator
874         self._formatter = formatter
875         self._minorlocator = minorlocator
876         _log.debug('locator: %r', locator)
877 
878     def set_ticks(self, ticks, *, labels=None, minor=False, **kwargs):
879         """
880         Set tick locations.
881 
882         Parameters
883         ----------
884         ticks : list of floats
885             List of tick locations.
886         labels : list of str, optional
887             List of tick labels. If not set, the labels show the data value.
888         minor : bool, default: False
889             If ``False``, set the major ticks; if ``True``, the minor ticks.
890         **kwargs
891             `.Text` properties for the labels. These take effect only if you
892             pass *labels*. In other cases, please use `~.Axes.tick_params`.
893         """
894         if np.iterable(ticks):
895             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
896                                         **kwargs)
897             self._locator = self._long_axis().get_major_locator()
898         else:
899             self._locator = ticks
900             self._long_axis().set_major_locator(self._locator)
901         self.stale = True
902 
903     def get_ticks(self, minor=False):
904         """
905         Return the ticks as a list of locations.
906 
907         Parameters
908         ----------
909         minor : boolean, default: False
910             if True return the minor ticks.
911         """
912         if minor:
913             return self._long_axis().get_minorticklocs()
914         else:
915             return self._long_axis().get_majorticklocs()
916 
917     def set_ticklabels(self, ticklabels, *, minor=False, **kwargs):
918         """
919         [*Discouraged*] Set tick labels.
920 
921         .. admonition:: Discouraged
922 
923             The use of this method is discouraged, because of the dependency
924             on tick positions. In most cases, you'll want to use
925             ``set_ticks(positions, labels=labels)`` instead.
926 
927             If you are using this method, you should always fix the tick
928             positions before, e.g. by using `.Colorbar.set_ticks` or by
929             explicitly setting a `~.ticker.FixedLocator` on the long axis
930             of the colorbar. Otherwise, ticks are free to move and the
931             labels may end up in unexpected positions.
932 
933         Parameters
934         ----------
935         ticklabels : sequence of str or of `.Text`
936             Texts for labeling each tick location in the sequence set by
937             `.Colorbar.set_ticks`; the number of labels must match the number
938             of locations.
939 
940         update_ticks : bool, default: True
941             This keyword argument is ignored and will be removed.
942             Deprecated
943 
944          minor : bool
945             If True, set minor ticks instead of major ticks.
946 
947         **kwargs
948             `.Text` properties for the labels.
949         """
950         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
951 
952     def minorticks_on(self):
953         """
954         Turn on colorbar minor ticks.
955         """
956         self.ax.minorticks_on()
957         self._short_axis().set_minor_locator(ticker.NullLocator())
958 
959     def minorticks_off(self):
960         """Turn the minor ticks of the colorbar off."""
961         self._minorlocator = ticker.NullLocator()
962         self._long_axis().set_minor_locator(self._minorlocator)
963 
964     def set_label(self, label, *, loc=None, **kwargs):
965         """
966         Add a label to the long axis of the colorbar.
967 
968         Parameters
969         ----------
970         label : str
971             The label text.
972         loc : str, optional
973             The location of the label.
974 
975             - For horizontal orientation one of {'left', 'center', 'right'}
976             - For vertical orientation one of {'bottom', 'center', 'top'}
977 
978             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
979             depending on the orientation.
980         **kwargs
981             Keyword arguments are passed to `~.Axes.set_xlabel` /
982             `~.Axes.set_ylabel`.
983             Supported keywords are *labelpad* and `.Text` properties.
984         """
985         if self.orientation == "vertical":
986             self.ax.set_ylabel(label, loc=loc, **kwargs)
987         else:
988             self.ax.set_xlabel(label, loc=loc, **kwargs)
989         self.stale = True
990 
991     def set_alpha(self, alpha):
992         """
993         Set the transparency between 0 (transparent) and 1 (opaque).
994 
995         If an array is provided, *alpha* will be set to None to use the
996         transparency values associated with the colormap.
997         """
998         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
999 
1000     def _set_scale(self, scale, **kwargs):
1001         """
1002         Set the colorbar long axis scale.
1003 
1004         Parameters
1005         ----------
1006         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
1007             The axis scale type to apply.
1008 
1009         **kwargs
1010             Different keyword arguments are accepted, depending on the scale.
1011             See the respective class keyword arguments:
1012 
1013             - `matplotlib.scale.LinearScale`
1014             - `matplotlib.scale.LogScale`
1015             - `matplotlib.scale.SymmetricalLogScale`
1016             - `matplotlib.scale.LogitScale`
1017             - `matplotlib.scale.FuncScale`
1018 
1019         Notes
1020         -----
1021         By default, Matplotlib supports the above-mentioned scales.
1022         Additionally, custom scales may be registered using
1023         `matplotlib.scale.register_scale`. These scales can then also
1024         be used here.
1025         """
1026         self._long_axis()._set_axes_scale(scale, **kwargs)
1027 
1028     def remove(self):
1029         """
1030         Remove this colorbar from the figure.
1031 
1032         If the colorbar was created with ``use_gridspec=True`` the previous
1033         gridspec is restored.
1034         """
1035         if hasattr(self.ax, '_colorbar_info'):
1036             parents = self.ax._colorbar_info['parents']
1037             for a in parents:
1038                 if self.ax in a._colorbars:
1039                     a._colorbars.remove(self.ax)
1040 
1041         self.ax.remove()
1042 
1043         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1044         self.mappable.colorbar = None
1045         self.mappable.colorbar_cid = None
1046         # Remove the extension callbacks
1047         self.ax.callbacks.disconnect(self._extend_cid1)
1048         self.ax.callbacks.disconnect(self._extend_cid2)
1049 
1050         try:
1051             ax = self.mappable.axes
1052         except AttributeError:
1053             return
1054         try:
1055             gs = ax.get_subplotspec().get_gridspec()
1056             subplotspec = gs.get_topmost_subplotspec()
1057         except AttributeError:
1058             # use_gridspec was False
1059             pos = ax.get_position(original=True)
1060             ax._set_position(pos)
1061         else:
1062             # use_gridspec was True
1063             ax.set_subplotspec(subplotspec)
1064 
1065     def _process_values(self):
1066         """
1067         Set `_boundaries` and `_values` based on the self.boundaries and
1068         self.values if not None, or based on the size of the colormap and
1069         the vmin/vmax of the norm.
1070         """
1071         if self.values is not None:
1072             # set self._boundaries from the values...
1073             self._values = np.array(self.values)
1074             if self.boundaries is None:
1075                 # bracket values by 1/2 dv:
1076                 b = np.zeros(len(self.values) + 1)
1077                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1078                 b[0] = 2.0 * b[1] - b[2]
1079                 b[-1] = 2.0 * b[-2] - b[-3]
1080                 self._boundaries = b
1081                 return
1082             self._boundaries = np.array(self.boundaries)
1083             return
1084 
1085         # otherwise values are set from the boundaries
1086         if isinstance(self.norm, colors.BoundaryNorm):
1087             b = self.norm.boundaries
1088         elif isinstance(self.norm, colors.NoNorm):
1089             # NoNorm has N blocks, so N+1 boundaries, centered on integers:
1090             b = np.arange(self.cmap.N + 1) - .5
1091         elif self.boundaries is not None:
1092             b = self.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if (not isinstance(self.norm, colors.BoundaryNorm) and
1110                 (self.boundaries is None)):
1111             b = self.norm.inverse(b)
1112 
1113         self._boundaries = np.asarray(b, dtype=float)
1114         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1115         if isinstance(self.norm, colors.NoNorm):
1116             self._values = (self._values + 0.00001).astype(np.int16)
1117 
1118     def _mesh(self):
1119         """
1120         Return the coordinate arrays for the colorbar pcolormesh/patches.
1121 
1122         These are scaled between vmin and vmax, and already handle colorbar
1123         orientation.
1124         """
1125         y, _ = self._proportional_y()
1126         # Use the vmin and vmax of the colorbar, which may not be the same
1127         # as the norm. There are situations where the colormap has a
1128         # narrower range than the colorbar and we want to accommodate the
1129         # extra contours.
1130         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm))
1131                 or self.boundaries is not None):
1132             # not using a norm.
1133             y = y * (self.vmax - self.vmin) + self.vmin
1134         else:
1135             # Update the norm values in a context manager as it is only
1136             # a temporary change and we don't want to propagate any signals
1137             # attached to the norm (callbacks.blocked).
1138             with self.norm.callbacks.blocked(), \
1139                     cbook._setattr_cm(self.norm,
1140                                       vmin=self.vmin,
1141                                       vmax=self.vmax):
1142                 y = self.norm.inverse(y)
1143         self._y = y
1144         X, Y = np.meshgrid([0., 1.], y)
1145         if self.orientation == 'vertical':
1146             return (X, Y)
1147         else:
1148             return (Y, X)
1149 
1150     def _forward_boundaries(self, x):
1151         # map boundaries equally between 0 and 1...
1152         b = self._boundaries
1153         y = np.interp(x, b, np.linspace(0, 1, len(b)))
1154         # the following avoids ticks in the extends:
1155         eps = (b[-1] - b[0]) * 1e-6
1156         # map these _well_ out of bounds to keep any ticks out
1157         # of the extends region...
1158         y[x < b[0]-eps] = -1
1159         y[x > b[-1]+eps] = 2
1160         return y
1161 
1162     def _inverse_boundaries(self, x):
1163         # invert the above...
1164         b = self._boundaries
1165         return np.interp(x, np.linspace(0, 1, len(b)), b)
1166 
1167     def _reset_locator_formatter_scale(self):
1168         """
1169         Reset the locator et al to defaults.  Any user-hardcoded changes
1170         need to be re-entered if this gets called (either at init, or when
1171         the mappable normal gets changed: Colorbar.update_normal)
1172         """
1173         self._process_values()
1174         self._locator = None
1175         self._minorlocator = None
1176         self._formatter = None
1177         self._minorformatter = None
1178         if (isinstance(self.mappable, contour.ContourSet) and
1179                 isinstance(self.norm, colors.LogNorm)):
1180             # if contours have lognorm, give them a log scale...
1181             self._set_scale('log')
1182         elif (self.boundaries is not None or
1183                 isinstance(self.norm, colors.BoundaryNorm)):
1184             if self.spacing == 'uniform':
1185                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1186                 self._set_scale('function', functions=funcs)
1187             elif self.spacing == 'proportional':
1188                 self._set_scale('linear')
1189         elif getattr(self.norm, '_scale', None):
1190             # use the norm's scale (if it exists and is not None):
1191             self._set_scale(self.norm._scale)
1192         elif type(self.norm) is colors.Normalize:
1193             # plain Normalize:
1194             self._set_scale('linear')
1195         else:
1196             # norm._scale is None or not an attr: derive the scale from
1197             # the Norm:
1198             funcs = (self.norm, self.norm.inverse)
1199             self._set_scale('function', functions=funcs)
1200 
1201     def _locate(self, x):
1202         """
1203         Given a set of color data values, return their
1204         corresponding colorbar data coordinates.
1205         """
1206         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1207             b = self._boundaries
1208             xn = x
1209         else:
1210             # Do calculations using normalized coordinates so
1211             # as to make the interpolation more accurate.
1212             b = self.norm(self._boundaries, clip=False).filled()
1213             xn = self.norm(x, clip=False).filled()
1214 
1215         bunique = b[self._inside]
1216         yunique = self._y
1217 
1218         z = np.interp(xn, bunique, yunique)
1219         return z
1220 
1221     # trivial helpers
1222 
1223     def _uniform_y(self, N):
1224         """
1225         Return colorbar data coordinates for *N* uniformly
1226         spaced boundaries, plus extension lengths if required.
1227         """
1228         automin = automax = 1. / (N - 1.)
1229         extendlength = self._get_extension_lengths(self.extendfrac,
1230                                                    automin, automax,
1231                                                    default=0.05)
1232         y = np.linspace(0, 1, N)
1233         return y, extendlength
1234 
1235     def _proportional_y(self):
1236         """
1237         Return colorbar data coordinates for the boundaries of
1238         a proportional colorbar, plus extension lengths if required:
1239         """
1240         if (isinstance(self.norm, colors.BoundaryNorm) or
1241                 self.boundaries is not None):
1242             y = (self._boundaries - self._boundaries[self._inside][0])
1243             y = y / (self._boundaries[self._inside][-1] -
1244                      self._boundaries[self._inside][0])
1245             # need yscaled the same as the axes scale to get
1246             # the extend lengths.
1247             if self.spacing == 'uniform':
1248                 yscaled = self._forward_boundaries(self._boundaries)
1249             else:
1250                 yscaled = y
1251         else:
1252             y = self.norm(self._boundaries.copy())
1253             y = np.ma.filled(y, np.nan)
1254             # the norm and the scale should be the same...
1255             yscaled = y
1256         y = y[self._inside]
1257         yscaled = yscaled[self._inside]
1258         # normalize from 0..1:
1259         norm = colors.Normalize(y[0], y[-1])
1260         y = np.ma.filled(norm(y), np.nan)
1261         norm = colors.Normalize(yscaled[0], yscaled[-1])
1262         yscaled = np.ma.filled(norm(yscaled), np.nan)
1263         # make the lower and upper extend lengths proportional to the lengths
1264         # of the first and last boundary spacing (if extendfrac='auto'):
1265         automin = yscaled[1] - yscaled[0]
1266         automax = yscaled[-1] - yscaled[-2]
1267         extendlength = [0, 0]
1268         if self._extend_lower() or self._extend_upper():
1269             extendlength = self._get_extension_lengths(
1270                     self.extendfrac, automin, automax, default=0.05)
1271         return y, extendlength
1272 
1273     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1274         """
1275         Return the lengths of colorbar extensions.
1276 
1277         This is a helper method for _uniform_y and _proportional_y.
1278         """
1279         # Set the default value.
1280         extendlength = np.array([default, default])
1281         if isinstance(frac, str):
1282             _api.check_in_list(['auto'], extendfrac=frac.lower())
1283             # Use the provided values when 'auto' is required.
1284             extendlength[:] = [automin, automax]
1285         elif frac is not None:
1286             try:
1287                 # Try to set min and max extension fractions directly.
1288                 extendlength[:] = frac
1289                 # If frac is a sequence containing None then NaN may
1290                 # be encountered. This is an error.
1291                 if np.isnan(extendlength).any():
1292                     raise ValueError()
1293             except (TypeError, ValueError) as err:
1294                 # Raise an error on encountering an invalid value for frac.
1295                 raise ValueError('invalid value for extendfrac') from err
1296         return extendlength
1297 
1298     def _extend_lower(self):
1299         """Return whether the lower limit is open ended."""
1300         minmax = "max" if self._long_axis().get_inverted() else "min"
1301         return self.extend in ('both', minmax)
1302 
1303     def _extend_upper(self):
1304         """Return whether the upper limit is open ended."""
1305         minmax = "min" if self._long_axis().get_inverted() else "max"
1306         return self.extend in ('both', minmax)
1307 
1308     def _long_axis(self):
1309         """Return the long axis"""
1310         if self.orientation == 'vertical':
1311             return self.ax.yaxis
1312         return self.ax.xaxis
1313 
1314     def _short_axis(self):
1315         """Return the short axis"""
1316         if self.orientation == 'vertical':
1317             return self.ax.xaxis
1318         return self.ax.yaxis
1319 
1320     def _get_view(self):
1321         # docstring inherited
1322         # An interactive view for a colorbar is the norm's vmin/vmax
1323         return self.norm.vmin, self.norm.vmax
1324 
1325     def _set_view(self, view):
1326         # docstring inherited
1327         # An interactive view for a colorbar is the norm's vmin/vmax
1328         self.norm.vmin, self.norm.vmax = view
1329 
1330     def _set_view_from_bbox(self, bbox, direction='in',
1331                             mode=None, twinx=False, twiny=False):
1332         # docstring inherited
1333         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1334         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1335             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1336         if self.orientation == 'horizontal':
1337             self.norm.vmin, self.norm.vmax = new_xbound
1338         elif self.orientation == 'vertical':
1339             self.norm.vmin, self.norm.vmax = new_ybound
1340 
1341     def drag_pan(self, button, key, x, y):
1342         # docstring inherited
1343         points = self.ax._get_pan_points(button, key, x, y)
1344         if points is not None:
1345             if self.orientation == 'horizontal':
1346                 self.norm.vmin, self.norm.vmax = points[:, 0]
1347             elif self.orientation == 'vertical':
1348                 self.norm.vmin, self.norm.vmax = points[:, 1]
1349 
1350 
1351 ColorbarBase = Colorbar  # Backcompat API
1352 
1353 
1354 def _normalize_location_orientation(location, orientation):
1355     if location is None:
1356         location = _get_ticklocation_from_orientation(orientation)
1357     loc_settings = _api.check_getitem({
1358         "left":   {"location": "left", "anchor": (1.0, 0.5),
1359                    "panchor": (0.0, 0.5), "pad": 0.10},
1360         "right":  {"location": "right", "anchor": (0.0, 0.5),
1361                    "panchor": (1.0, 0.5), "pad": 0.05},
1362         "top":    {"location": "top", "anchor": (0.5, 0.0),
1363                    "panchor": (0.5, 1.0), "pad": 0.05},
1364         "bottom": {"location": "bottom", "anchor": (0.5, 1.0),
1365                    "panchor": (0.5, 0.0), "pad": 0.15},
1366     }, location=location)
1367     loc_settings["orientation"] = _get_orientation_from_location(location)
1368     if orientation is not None and orientation != loc_settings["orientation"]:
1369         # Allow the user to pass both if they are consistent.
1370         raise TypeError("location and orientation are mutually exclusive")
1371     return loc_settings
1372 
1373 
1374 def _get_orientation_from_location(location):
1375     return _api.check_getitem(
1376         {None: None, "left": "vertical", "right": "vertical",
1377          "top": "horizontal", "bottom": "horizontal"}, location=location)
1378 
1379 
1380 def _get_ticklocation_from_orientation(orientation):
1381     return _api.check_getitem(
1382         {None: "right", "vertical": "right", "horizontal": "bottom"},
1383         orientation=orientation)
1384 
1385 
1386 @_docstring.interpd
1387 def make_axes(parents, location=None, orientation=None, fraction=0.15,
1388               shrink=1.0, aspect=20, **kwargs):
1389     """
1390     Create an `~.axes.Axes` suitable for a colorbar.
1391 
1392     The axes is placed in the figure of the *parents* axes, by resizing and
1393     repositioning *parents*.
1394 
1395     Parameters
1396     ----------
1397     parents : `~.axes.Axes` or iterable or `numpy.ndarray` of `~.axes.Axes`
1398         The Axes to use as parents for placing the colorbar.
1399     %(_make_axes_kw_doc)s
1400 
1401     Returns
1402     -------
1403     cax : `~.axes.Axes`
1404         The child axes.
1405     kwargs : dict
1406         The reduced keyword dictionary to be passed when creating the colorbar
1407         instance.
1408     """
1409     loc_settings = _normalize_location_orientation(location, orientation)
1410     # put appropriate values into the kwargs dict for passing back to
1411     # the Colorbar class
1412     kwargs['orientation'] = loc_settings['orientation']
1413     location = kwargs['ticklocation'] = loc_settings['location']
1414 
1415     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1416     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1417     aspect0 = aspect
1418     # turn parents into a list if it is not already.  Note we cannot
1419     # use .flatten or .ravel as these copy the references rather than
1420     # reuse them, leading to a memory leak
1421     if isinstance(parents, np.ndarray):
1422         parents = list(parents.flat)
1423     elif np.iterable(parents):
1424         parents = list(parents)
1425     else:
1426         parents = [parents]
1427 
1428     fig = parents[0].get_figure()
1429 
1430     pad0 = 0.05 if fig.get_constrained_layout() else loc_settings['pad']
1431     pad = kwargs.pop('pad', pad0)
1432 
1433     if not all(fig is ax.get_figure() for ax in parents):
1434         raise ValueError('Unable to create a colorbar axes as not all '
1435                          'parents share the same figure.')
1436 
1437     # take a bounding box around all of the given axes
1438     parents_bbox = mtransforms.Bbox.union(
1439         [ax.get_position(original=True).frozen() for ax in parents])
1440 
1441     pb = parents_bbox
1442     if location in ('left', 'right'):
1443         if location == 'left':
1444             pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)
1445         else:
1446             pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)
1447         pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)
1448     else:
1449         if location == 'bottom':
1450             pbcb, _, pb1 = pb.splity(fraction, fraction + pad)
1451         else:
1452             pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)
1453         pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)
1454 
1455         # define the aspect ratio in terms of y's per x rather than x's per y
1456         aspect = 1.0 / aspect
1457 
1458     # define a transform which takes us from old axes coordinates to
1459     # new axes coordinates
1460     shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)
1461 
1462     # transform each of the axes in parents using the new transform
1463     for ax in parents:
1464         new_posn = shrinking_trans.transform(ax.get_position(original=True))
1465         new_posn = mtransforms.Bbox(new_posn)
1466         ax._set_position(new_posn)
1467         if panchor is not False:
1468             ax.set_anchor(panchor)
1469 
1470     cax = fig.add_axes(pbcb, label="<colorbar>")
1471     for a in parents:
1472         # tell the parent it has a colorbar
1473         a._colorbars += [cax]
1474     cax._colorbar_info = dict(
1475         parents=parents,
1476         location=location,
1477         shrink=shrink,
1478         anchor=anchor,
1479         panchor=panchor,
1480         fraction=fraction,
1481         aspect=aspect0,
1482         pad=pad)
1483     # and we need to set the aspect ratio by hand...
1484     cax.set_anchor(anchor)
1485     cax.set_box_aspect(aspect)
1486     cax.set_aspect('auto')
1487 
1488     return cax, kwargs
1489 
1490 
1491 @_docstring.interpd
1492 def make_axes_gridspec(parent, *, location=None, orientation=None,
1493                        fraction=0.15, shrink=1.0, aspect=20, **kwargs):
1494     """
1495     Create an `~.axes.Axes` suitable for a colorbar.
1496 
1497     The axes is placed in the figure of the *parent* axes, by resizing and
1498     repositioning *parent*.
1499 
1500     This function is similar to `.make_axes` and mostly compatible with it.
1501     Primary differences are
1502 
1503     - `.make_axes_gridspec` requires the *parent* to have a subplotspec.
1504     - `.make_axes` positions the axes in figure coordinates;
1505       `.make_axes_gridspec` positions it using a subplotspec.
1506     - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`
1507       replaces the parent gridspec with a new one.
1508 
1509     Parameters
1510     ----------
1511     parent : `~.axes.Axes`
1512         The Axes to use as parent for placing the colorbar.
1513     %(_make_axes_kw_doc)s
1514 
1515     Returns
1516     -------
1517     cax : `~.axes.Axes`
1518         The child axes.
1519     kwargs : dict
1520         The reduced keyword dictionary to be passed when creating the colorbar
1521         instance.
1522     """
1523 
1524     loc_settings = _normalize_location_orientation(location, orientation)
1525     kwargs['orientation'] = loc_settings['orientation']
1526     location = kwargs['ticklocation'] = loc_settings['location']
1527 
1528     aspect0 = aspect
1529     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1530     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1531     pad = kwargs.pop('pad', loc_settings["pad"])
1532     wh_space = 2 * pad / (1 - pad)
1533 
1534     if location in ('left', 'right'):
1535         # for shrinking
1536         height_ratios = [
1537                 (1-anchor[1])*(1-shrink), shrink, anchor[1]*(1-shrink)]
1538 
1539         if location == 'left':
1540             gs = parent.get_subplotspec().subgridspec(
1541                     1, 2, wspace=wh_space,
1542                     width_ratios=[fraction, 1-fraction-pad])
1543             ss_main = gs[1]
1544             ss_cb = gs[0].subgridspec(
1545                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1546         else:
1547             gs = parent.get_subplotspec().subgridspec(
1548                     1, 2, wspace=wh_space,
1549                     width_ratios=[1-fraction-pad, fraction])
1550             ss_main = gs[0]
1551             ss_cb = gs[1].subgridspec(
1552                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1553     else:
1554         # for shrinking
1555         width_ratios = [
1556                 anchor[0]*(1-shrink), shrink, (1-anchor[0])*(1-shrink)]
1557 
1558         if location == 'bottom':
1559             gs = parent.get_subplotspec().subgridspec(
1560                     2, 1, hspace=wh_space,
1561                     height_ratios=[1-fraction-pad, fraction])
1562             ss_main = gs[0]
1563             ss_cb = gs[1].subgridspec(
1564                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1565             aspect = 1 / aspect
1566         else:
1567             gs = parent.get_subplotspec().subgridspec(
1568                     2, 1, hspace=wh_space,
1569                     height_ratios=[fraction, 1-fraction-pad])
1570             ss_main = gs[1]
1571             ss_cb = gs[0].subgridspec(
1572                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1573             aspect = 1 / aspect
1574 
1575     parent.set_subplotspec(ss_main)
1576     if panchor is not False:
1577         parent.set_anchor(panchor)
1578 
1579     fig = parent.get_figure()
1580     cax = fig.add_subplot(ss_cb, label="<colorbar>")
1581     cax.set_anchor(anchor)
1582     cax.set_box_aspect(aspect)
1583     cax.set_aspect('auto')
1584     cax._colorbar_info = dict(
1585         location=location,
1586         parents=[parent],
1587         shrink=shrink,
1588         anchor=anchor,
1589         panchor=panchor,
1590         fraction=fraction,
1591         aspect=aspect0,
1592         pad=pad)
1593 
1594     return cax, kwargs

</code><intended_behavior>When `vmin` and `vmax` are modified, particularly in an interactive setting, the colorbar update mechanism should detect these changes and redraw the colorbar to reflect the new range according to the newly set normalization method. This process should handle logarithmic scaling gracefully, ensuring that the colorbar accurately represents the updated data range.</intended_behavior>]
2025-10-18 02:55:07.577 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A module for converting numbers or color arguments to *RGB* or *RGBA*.
3 
4 *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
5 range 0-1.
6 
7 This module includes functions and classes for color specification conversions,
8 and for mapping numbers to colors in a 1-D array of colors called a colormap.
9 
10 Mapping data onto colors using a colormap typically involves two steps: a data
11 array is first mapped onto the range 0-1 using a subclass of `Normalize`,
12 then this number is mapped to a color using a subclass of `Colormap`.  Two
13 subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
14 piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
15 makes a colormap from a list of colors.
16 
17 .. seealso::
18 
19   :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
20   make colormaps and
21 
22   :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
23 
24   :doc:`/tutorials/colors/colormapnorms` for more details about data
25   normalization
26 
27   More colormaps are available at palettable_.
28 
29 The module also provides functions for checking whether an object can be
30 interpreted as a color (`is_color_like`), for converting such an object
31 to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
32 "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
33 RGBA array (`to_rgba_array`).  Caching is used for efficiency.
34 
35 Colors that Matplotlib recognizes are listed at
36 :doc:`/tutorials/colors/colors`.
37 
38 .. _palettable: https://jiffyclub.github.io/palettable/
39 .. _xkcd color survey: https://xkcd.com/color/rgb/
40 """
41 
42 import base64
43 from collections.abc import Sized, Sequence, Mapping
44 import functools
45 import importlib
46 import inspect
47 import io
48 import itertools
49 from numbers import Number
50 import re
51 from PIL import Image
52 from PIL.PngImagePlugin import PngInfo
53 
54 import matplotlib as mpl
55 import numpy as np
56 from matplotlib import _api, _cm, cbook, scale
57 from ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS
58 
59 
60 class _ColorMapping(dict):
61     def __init__(self, mapping):
62         super().__init__(mapping)
63         self.cache = {}
64 
65     def __setitem__(self, key, value):
66         super().__setitem__(key, value)
67         self.cache.clear()
68 
69     def __delitem__(self, key):
70         super().__delitem__(key)
71         self.cache.clear()
72 
73 
74 _colors_full_map = {}
75 # Set by reverse priority order.
76 _colors_full_map.update(XKCD_COLORS)
77 _colors_full_map.update({k.replace('grey', 'gray'): v
78                          for k, v in XKCD_COLORS.items()
79                          if 'grey' in k})
80 _colors_full_map.update(CSS4_COLORS)
81 _colors_full_map.update(TABLEAU_COLORS)
82 _colors_full_map.update({k.replace('gray', 'grey'): v
83                          for k, v in TABLEAU_COLORS.items()
84                          if 'gray' in k})
85 _colors_full_map.update(BASE_COLORS)
86 _colors_full_map = _ColorMapping(_colors_full_map)
87 
88 _REPR_PNG_SIZE = (512, 64)
89 
90 
91 def get_named_colors_mapping():
92     """Return the global mapping of names to named colors."""
93     return _colors_full_map
94 
95 
96 class ColorSequenceRegistry(Mapping):
97     r"""
98     Container for sequences of colors that are known to Matplotlib by name.
99 
100     The universal registry instance is `matplotlib.color_sequences`. There
101     should be no need for users to instantiate `.ColorSequenceRegistry`
102     themselves.
103 
104     Read access uses a dict-like interface mapping names to lists of colors::
105 
106         import matplotlib as mpl
107         cmap = mpl.color_sequences['tab10']
108 
109     The returned lists are copies, so that their modification does not change
110     the global definition of the color sequence.
111 
112     Additional color sequences can be added via
113     `.ColorSequenceRegistry.register`::
114 
115         mpl.color_sequences.register('rgb', ['r', 'g', 'b'])
116     """
117 
118     _BUILTIN_COLOR_SEQUENCES = {
119         'tab10': _cm._tab10_data,
120         'tab20': _cm._tab20_data,
121         'tab20b': _cm._tab20b_data,
122         'tab20c': _cm._tab20c_data,
123         'Pastel1': _cm._Pastel1_data,
124         'Pastel2': _cm._Pastel2_data,
125         'Paired': _cm._Paired_data,
126         'Accent': _cm._Accent_data,
127         'Dark2': _cm._Dark2_data,
128         'Set1': _cm._Set1_data,
129         'Set2': _cm._Set1_data,
130         'Set3': _cm._Set1_data,
131     }
132 
133     def __init__(self):
134         self._color_sequences = {**self._BUILTIN_COLOR_SEQUENCES}
135 
136     def __getitem__(self, item):
137         try:
138             return list(self._color_sequences[item])
139         except KeyError:
140             raise KeyError(f"{item!r} is not a known color sequence name")
141 
142     def __iter__(self):
143         return iter(self._color_sequences)
144 
145     def __len__(self):
146         return len(self._color_sequences)
147 
148     def __str__(self):
149         return ('ColorSequenceRegistry; available colormaps:\n' +
150                 ', '.join(f"'{name}'" for name in self))
151 
152     def register(self, name, color_list):
153         """
154         Register a new color sequence.
155 
156         The color sequence registry stores a copy of the given *color_list*, so
157         that future changes to the original list do not affect the registered
158         color sequence. Think of this as the registry taking a snapshot
159         of *color_list* at registration.
160 
161         Parameters
162         ----------
163         name : str
164             The name for the color sequence.
165 
166         color_list : list of colors
167             An iterable returning valid Matplotlib colors when iterating over.
168             Note however that the returned color sequence will always be a
169             list regardless of the input type.
170 
171         """
172         if name in self._BUILTIN_COLOR_SEQUENCES:
173             raise ValueError(f"{name!r} is a reserved name for a builtin "
174                              "color sequence")
175 
176         color_list = list(color_list)  # force copy and coerce type to list
177         for color in color_list:
178             try:
179                 to_rgba(color)
180             except ValueError:
181                 raise ValueError(
182                     f"{color!r} is not a valid color specification")
183 
184         self._color_sequences[name] = color_list
185 
186     def unregister(self, name):
187         """
188         Remove a sequence from the registry.
189 
190         You cannot remove built-in color sequences.
191 
192         If the name is not registered, returns with no error.
193         """
194         if name in self._BUILTIN_COLOR_SEQUENCES:
195             raise ValueError(
196                 f"Cannot unregister builtin color sequence {name!r}")
197         self._color_sequences.pop(name, None)
198 
199 
200 _color_sequences = ColorSequenceRegistry()
201 
202 
203 def _sanitize_extrema(ex):
204     if ex is None:
205         return ex
206     try:
207         ret = ex.item()
208     except AttributeError:
209         ret = float(ex)
210     return ret
211 
212 
213 def _is_nth_color(c):
214     """Return whether *c* can be interpreted as an item in the color cycle."""
215     return isinstance(c, str) and re.match(r"\AC[0-9]+\Z", c)
216 
217 
218 def is_color_like(c):
219     """Return whether *c* can be interpreted as an RGB(A) color."""
220     # Special-case nth color syntax because it cannot be parsed during setup.
221     if _is_nth_color(c):
222         return True
223     try:
224         to_rgba(c)
225     except ValueError:
226         return False
227     else:
228         return True
229 
230 
231 def _has_alpha_channel(c):
232     """Return whether *c* is a color with an alpha channel."""
233     # 4-element sequences are interpreted as r, g, b, a
234     return not isinstance(c, str) and len(c) == 4
235 
236 
237 def _check_color_like(**kwargs):
238     """
239     For each *key, value* pair in *kwargs*, check that *value* is color-like.
240     """
241     for k, v in kwargs.items():
242         if not is_color_like(v):
243             raise ValueError(f"{v!r} is not a valid value for {k}")
244 
245 
246 def same_color(c1, c2):
247     """
248     Return whether the colors *c1* and *c2* are the same.
249 
250     *c1*, *c2* can be single colors or lists/arrays of colors.
251     """
252     c1 = to_rgba_array(c1)
253     c2 = to_rgba_array(c2)
254     n1 = max(c1.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem
255     n2 = max(c2.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem
256 
257     if n1 != n2:
258         raise ValueError('Different number of elements passed.')
259     # The following shape test is needed to correctly handle comparisons with
260     # 'none', which results in a shape (0, 4) array and thus cannot be tested
261     # via value comparison.
262     return c1.shape == c2.shape and (c1 == c2).all()
263 
264 
265 def to_rgba(c, alpha=None):
266     """
267     Convert *c* to an RGBA color.
268 
269     Parameters
270     ----------
271     c : Matplotlib color or ``np.ma.masked``
272 
273     alpha : float, optional
274         If *alpha* is given, force the alpha value of the returned RGBA tuple
275         to *alpha*.
276 
277         If None, the alpha value from *c* is used. If *c* does not have an
278         alpha channel, then alpha defaults to 1.
279 
280         *alpha* is ignored for the color value ``"none"`` (case-insensitive),
281         which always maps to ``(0, 0, 0, 0)``.
282 
283     Returns
284     -------
285     tuple
286         Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
287         alpha) can assume values between 0 and 1.
288     """
289     # Special-case nth color syntax because it should not be cached.
290     if _is_nth_color(c):
291         prop_cycler = mpl.rcParams['axes.prop_cycle']
292         colors = prop_cycler.by_key().get('color', ['k'])
293         c = colors[int(c[1:]) % len(colors)]
294     try:
295         rgba = _colors_full_map.cache[c, alpha]
296     except (KeyError, TypeError):  # Not in cache, or unhashable.
297         rgba = None
298     if rgba is None:  # Suppress exception chaining of cache lookup failure.
299         rgba = _to_rgba_no_colorcycle(c, alpha)
300         try:
301             _colors_full_map.cache[c, alpha] = rgba
302         except TypeError:
303             pass
304     return rgba
305 
306 
307 def _to_rgba_no_colorcycle(c, alpha=None):
308     """
309     Convert *c* to an RGBA color, with no support for color-cycle syntax.
310 
311     If *alpha* is given, force the alpha value of the returned RGBA tuple
312     to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha
313     information, or defaults to 1.
314 
315     *alpha* is ignored for the color value ``"none"`` (case-insensitive),
316     which always maps to ``(0, 0, 0, 0)``.
317     """
318     orig_c = c
319     if c is np.ma.masked:
320         return (0., 0., 0., 0.)
321     if isinstance(c, str):
322         if c.lower() == "none":
323             return (0., 0., 0., 0.)
324         # Named color.
325         try:
326             # This may turn c into a non-string, so we check again below.
327             c = _colors_full_map[c]
328         except KeyError:
329             if len(orig_c) != 1:
330                 try:
331                     c = _colors_full_map[c.lower()]
332                 except KeyError:
333                     pass
334     if isinstance(c, str):
335         # hex color in #rrggbb format.
336         match = re.match(r"\A#[a-fA-F0-9]{6}\Z", c)
337         if match:
338             return (tuple(int(n, 16) / 255
339                           for n in [c[1:3], c[3:5], c[5:7]])
340                     + (alpha if alpha is not None else 1.,))
341         # hex color in #rgb format, shorthand for #rrggbb.
342         match = re.match(r"\A#[a-fA-F0-9]{3}\Z", c)
343         if match:
344             return (tuple(int(n, 16) / 255
345                           for n in [c[1]*2, c[2]*2, c[3]*2])
346                     + (alpha if alpha is not None else 1.,))
347         # hex color with alpha in #rrggbbaa format.
348         match = re.match(r"\A#[a-fA-F0-9]{8}\Z", c)
349         if match:
350             color = [int(n, 16) / 255
351                      for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]
352             if alpha is not None:
353                 color[-1] = alpha
354             return tuple(color)
355         # hex color with alpha in #rgba format, shorthand for #rrggbbaa.
356         match = re.match(r"\A#[a-fA-F0-9]{4}\Z", c)
357         if match:
358             color = [int(n, 16) / 255
359                      for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]
360             if alpha is not None:
361                 color[-1] = alpha
362             return tuple(color)
363         # string gray.
364         try:
365             c = float(c)
366         except ValueError:
367             pass
368         else:
369             if not (0 <= c <= 1):
370                 raise ValueError(
371                     f"Invalid string grayscale value {orig_c!r}. "
372                     f"Value must be within 0-1 range")
373             return c, c, c, alpha if alpha is not None else 1.
374         raise ValueError(f"Invalid RGBA argument: {orig_c!r}")
375     # turn 2-D array into 1-D array
376     if isinstance(c, np.ndarray):
377         if c.ndim == 2 and c.shape[0] == 1:
378             c = c.reshape(-1)
379     # tuple color.
380     if not np.iterable(c):
381         raise ValueError(f"Invalid RGBA argument: {orig_c!r}")
382     if len(c) not in [3, 4]:
383         raise ValueError("RGBA sequence should have length 3 or 4")
384     if not all(isinstance(x, Number) for x in c):
385         # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and
386         # `np.array(...).astype(float)` would all convert "0.5" to 0.5.
387         raise ValueError(f"Invalid RGBA argument: {orig_c!r}")
388     # Return a tuple to prevent the cached value from being modified.
389     c = tuple(map(float, c))
390     if len(c) == 3 and alpha is None:
391         alpha = 1
392     if alpha is not None:
393         c = c[:3] + (alpha,)
394     if any(elem < 0 or elem > 1 for elem in c):
395         raise ValueError("RGBA values should be within 0-1 range")
396     return c
397 
398 
399 def to_rgba_array(c, alpha=None):
400     """
401     Convert *c* to a (n, 4) array of RGBA colors.
402 
403     Parameters
404     ----------
405     c : Matplotlib color or array of colors
406         If *c* is a masked array, an `~numpy.ndarray` is returned with a
407         (0, 0, 0, 0) row for each masked value or row in *c*.
408 
409     alpha : float or sequence of floats, optional
410         If *alpha* is given, force the alpha value of the returned RGBA tuple
411         to *alpha*.
412 
413         If None, the alpha value from *c* is used. If *c* does not have an
414         alpha channel, then alpha defaults to 1.
415 
416         *alpha* is ignored for the color value ``"none"`` (case-insensitive),
417         which always maps to ``(0, 0, 0, 0)``.
418 
419         If *alpha* is a sequence and *c* is a single color, *c* will be
420         repeated to match the length of *alpha*.
421 
422     Returns
423     -------
424     array
425         (n, 4) array of RGBA colors,  where each channel (red, green, blue,
426         alpha) can assume values between 0 and 1.
427     """
428     # Special-case inputs that are already arrays, for performance.  (If the
429     # array has the wrong kind or shape, raise the error during one-at-a-time
430     # conversion.)
431     if np.iterable(alpha):
432         alpha = np.asarray(alpha).ravel()
433     if (isinstance(c, np.ndarray) and c.dtype.kind in "if"
434             and c.ndim == 2 and c.shape[1] in [3, 4]):
435         mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None
436         c = np.ma.getdata(c)
437         if np.iterable(alpha):
438             if c.shape[0] == 1 and alpha.shape[0] > 1:
439                 c = np.tile(c, (alpha.shape[0], 1))
440             elif c.shape[0] != alpha.shape[0]:
441                 raise ValueError("The number of colors must match the number"
442                                  " of alpha values if there are more than one"
443                                  " of each.")
444         if c.shape[1] == 3:
445             result = np.column_stack([c, np.zeros(len(c))])
446             result[:, -1] = alpha if alpha is not None else 1.
447         elif c.shape[1] == 4:
448             result = c.copy()
449             if alpha is not None:
450                 result[:, -1] = alpha
451         if mask is not None:
452             result[mask] = 0
453         if np.any((result < 0) | (result > 1)):
454             raise ValueError("RGBA values should be within 0-1 range")
455         return result
456     # Handle single values.
457     # Note that this occurs *after* handling inputs that are already arrays, as
458     # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need
459     # to format the array in the ValueError message(!).
460     if cbook._str_lower_equal(c, "none"):
461         return np.zeros((0, 4), float)
462     try:
463         if np.iterable(alpha):
464             return np.array([to_rgba(c, a) for a in alpha], float)
465         else:
466             return np.array([to_rgba(c, alpha)], float)
467     except (ValueError, TypeError):
468         pass
469 
470     if isinstance(c, str):
471         raise ValueError(f"{c!r} is not a valid color value.")
472 
473     if len(c) == 0:
474         return np.zeros((0, 4), float)
475 
476     # Quick path if the whole sequence can be directly converted to a numpy
477     # array in one shot.
478     if isinstance(c, Sequence):
479         lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}
480         if lens == {3}:
481             rgba = np.column_stack([c, np.ones(len(c))])
482         elif lens == {4}:
483             rgba = np.array(c)
484         else:
485             rgba = np.array([to_rgba(cc) for cc in c])
486     else:
487         rgba = np.array([to_rgba(cc) for cc in c])
488 
489     if alpha is not None:
490         rgba[:, 3] = alpha
491     return rgba
492 
493 
494 def to_rgb(c):
495     """Convert *c* to an RGB color, silently dropping the alpha channel."""
496     return to_rgba(c)[:3]
497 
498 
499 def to_hex(c, keep_alpha=False):
500     """
501     Convert *c* to a hex color.
502 
503     Parameters
504     ----------
505     c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
506 
507     keep_alpha : bool, default: False
508       If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
509 
510     Returns
511     -------
512     str
513       ``#rrggbb`` or ``#rrggbbaa`` hex color string
514     """
515     c = to_rgba(c)
516     if not keep_alpha:
517         c = c[:3]
518     return "#" + "".join(format(round(val * 255), "02x") for val in c)
519 
520 
521 ### Backwards-compatible color-conversion API
522 
523 
524 cnames = CSS4_COLORS
525 hexColorPattern = re.compile(r"\A#[a-fA-F0-9]{6}\Z")
526 rgb2hex = to_hex
527 hex2color = to_rgb
528 
529 
530 class ColorConverter:
531     """
532     A class only kept for backwards compatibility.
533 
534     Its functionality is entirely provided by module-level functions.
535     """
536     colors = _colors_full_map
537     cache = _colors_full_map.cache
538     to_rgb = staticmethod(to_rgb)
539     to_rgba = staticmethod(to_rgba)
540     to_rgba_array = staticmethod(to_rgba_array)
541 
542 
543 colorConverter = ColorConverter()
544 
545 
546 ### End of backwards-compatible color-conversion API
547 
548 
549 def _create_lookup_table(N, data, gamma=1.0):
550     r"""
551     Create an *N* -element 1D lookup table.
552 
553     This assumes a mapping :math:`f : [0, 1] \rightarrow [0, 1]`. The returned
554     data is an array of N values :math:`y = f(x)` where x is sampled from
555     [0, 1].
556 
557     By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The
558     *gamma* correction factor :math:`\gamma` distorts this equidistant
559     sampling by :math:`x \rightarrow x^\gamma`.
560 
561     Parameters
562     ----------
563     N : int
564         The number of elements of the created lookup table; at least 1.
565 
566     data : (M, 3) array-like or callable
567         Defines the mapping :math:`f`.
568 
569         If a (M, 3) array-like, the rows define values (x, y0, y1).  The x
570         values must start with x=0, end with x=1, and all x values be in
571         increasing order.
572 
573         A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range
574         :math:`y^1_{i-1} \ldots y^0_i` by linear interpolation.
575 
576         For the simple case of a y-continuous mapping, y0 and y1 are identical.
577 
578         The two values of y are to allow for discontinuous mapping functions.
579         E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::
580 
581             [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]
582 
583         In the special case of ``N == 1``, by convention the returned value
584         is y0 for x == 1.
585 
586         If *data* is a callable, it must accept and return numpy arrays::
587 
588            data(x : ndarray) -> ndarray
589 
590         and map values between 0 - 1 to 0 - 1.
591 
592     gamma : float
593         Gamma correction factor for input distribution x of the mapping.
594 
595         See also https://en.wikipedia.org/wiki/Gamma_correction.
596 
597     Returns
598     -------
599     array
600         The lookup table where ``lut[x * (N-1)]`` gives the closest value
601         for values of x between 0 and 1.
602 
603     Notes
604     -----
605     This function is internally used for `.LinearSegmentedColormap`.
606     """
607 
608     if callable(data):
609         xind = np.linspace(0, 1, N) ** gamma
610         lut = np.clip(np.array(data(xind), dtype=float), 0, 1)
611         return lut
612 
613     try:
614         adata = np.array(data)
615     except Exception as err:
616         raise TypeError("data must be convertible to an array") from err
617     _api.check_shape((None, 3), data=adata)
618 
619     x = adata[:, 0]
620     y0 = adata[:, 1]
621     y1 = adata[:, 2]
622 
623     if x[0] != 0. or x[-1] != 1.0:
624         raise ValueError(
625             "data mapping points must start with x=0 and end with x=1")
626     if (np.diff(x) < 0).any():
627         raise ValueError("data mapping points must have x in increasing order")
628     # begin generation of lookup table
629     if N == 1:
630         # convention: use the y = f(x=1) value for a 1-element lookup table
631         lut = np.array(y0[-1])
632     else:
633         x = x * (N - 1)
634         xind = (N - 1) * np.linspace(0, 1, N) ** gamma
635         ind = np.searchsorted(x, xind)[1:-1]
636 
637         distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])
638         lut = np.concatenate([
639             [y1[0]],
640             distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],
641             [y0[-1]],
642         ])
643     # ensure that the lut is confined to values between 0 and 1 by clipping it
644     return np.clip(lut, 0.0, 1.0)
645 
646 
647 class Colormap:
648     """
649     Baseclass for all scalar to RGBA mappings.
650 
651     Typically, Colormap instances are used to convert data values (floats)
652     from the interval ``[0, 1]`` to the RGBA color that the respective
653     Colormap represents. For scaling of data into the ``[0, 1]`` interval see
654     `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
655     make heavy use of this ``data -> normalize -> map-to-color`` processing
656     chain.
657     """
658 
659     def __init__(self, name, N=256):
660         """
661         Parameters
662         ----------
663         name : str
664             The name of the colormap.
665         N : int
666             The number of RGB quantization levels.
667         """
668         self.name = name
669         self.N = int(N)  # ensure that N is always int
670         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.
671         self._rgba_under = None
672         self._rgba_over = None
673         self._i_under = self.N
674         self._i_over = self.N + 1
675         self._i_bad = self.N + 2
676         self._isinit = False
677         #: When this colormap exists on a scalar mappable and colorbar_extend
678         #: is not False, colorbar creation will pick up ``colorbar_extend`` as
679         #: the default value for the ``extend`` keyword in the
680         #: `matplotlib.colorbar.Colorbar` constructor.
681         self.colorbar_extend = False
682 
683     def __call__(self, X, alpha=None, bytes=False):
684         """
685         Parameters
686         ----------
687         X : float or int, `~numpy.ndarray` or scalar
688             The data value(s) to convert to RGBA.
689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to
690             return the RGBA values ``X*100`` percent along the Colormap line.
691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to
692             return RGBA values *indexed* from the Colormap with index ``X``.
693         alpha : float or array-like or None
694             Alpha must be a scalar between 0 and 1, a sequence of such
695             floats with shape matching X, or None.
696         bytes : bool
697             If False (default), the returned RGBA values will be floats in the
698             interval ``[0, 1]`` otherwise they will be uint8s in the interval
699             ``[0, 255]``.
700 
701         Returns
702         -------
703         Tuple of RGBA values if X is scalar, otherwise an array of
704         RGBA values with a shape of ``X.shape + (4, )``.
705         """
706         if not self._isinit:
707             self._init()
708 
709         xa = np.array(X, copy=True)
710         if not xa.dtype.isnative:
711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
712         if xa.dtype.kind == "f":
713             xa *= self.N
714             # xa == 1 (== N after multiplication) is not out of range.
715             xa[xa == self.N] = self.N - 1
716         # Pre-compute the masks before casting to int (which can truncate
717         # negative values to zero or wrap large floats to negative ints).
718         mask_under = xa < 0
719         mask_over = xa >= self.N
720         # If input was masked, get the bad mask from it; else mask out nans.
721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)
722         with np.errstate(invalid="ignore"):
723             # We need this cast for unsigned ints as well as floats
724             xa = xa.astype(int)
725         xa[mask_under] = self._i_under
726         xa[mask_over] = self._i_over
727         xa[mask_bad] = self._i_bad
728 
729         lut = self._lut
730         if bytes:
731             lut = (lut * 255).astype(np.uint8)
732 
733         rgba = lut.take(xa, axis=0, mode='clip')
734 
735         if alpha is not None:
736             alpha = np.clip(alpha, 0, 1)
737             if bytes:
738                 alpha *= 255  # Will be cast to uint8 upon assignment.
739             if alpha.shape not in [(), xa.shape]:
740                 raise ValueError(
741                     f"alpha is array-like but its shape {alpha.shape} does "
742                     f"not match that of X {xa.shape}")
743             rgba[..., -1] = alpha
744             # If the "bad" color is all zeros, then ignore alpha input.
745             if (lut[-1] == 0).all():
746                 rgba[mask_bad] = (0, 0, 0, 0)
747 
748         if not np.iterable(X):
749             rgba = tuple(rgba)
750         return rgba
751 
752     def __copy__(self):
753         cls = self.__class__
754         cmapobject = cls.__new__(cls)
755         cmapobject.__dict__.update(self.__dict__)
756         if self._isinit:
757             cmapobject._lut = np.copy(self._lut)
758         return cmapobject
759 
760     def __eq__(self, other):
761         if (not isinstance(other, Colormap) or self.name != other.name or
762                 self.colorbar_extend != other.colorbar_extend):
763             return False
764         # To compare lookup tables the Colormaps have to be initialized
765         if not self._isinit:
766             self._init()
767         if not other._isinit:
768             other._init()
769         return np.array_equal(self._lut, other._lut)
770 
771     def get_bad(self):
772         """Get the color for masked values."""
773         if not self._isinit:
774             self._init()
775         return np.array(self._lut[self._i_bad])
776 
777     def set_bad(self, color='k', alpha=None):
778         """Set the color for masked values."""
779         self._rgba_bad = to_rgba(color, alpha)
780         if self._isinit:
781             self._set_extremes()
782 
783     def get_under(self):
784         """Get the color for low out-of-range values."""
785         if not self._isinit:
786             self._init()
787         return np.array(self._lut[self._i_under])
788 
789     def set_under(self, color='k', alpha=None):
790         """Set the color for low out-of-range values."""
791         self._rgba_under = to_rgba(color, alpha)
792         if self._isinit:
793             self._set_extremes()
794 
795     def get_over(self):
796         """Get the color for high out-of-range values."""
797         if not self._isinit:
798             self._init()
799         return np.array(self._lut[self._i_over])
800 
801     def set_over(self, color='k', alpha=None):
802         """Set the color for high out-of-range values."""
803         self._rgba_over = to_rgba(color, alpha)
804         if self._isinit:
805             self._set_extremes()
806 
807     def set_extremes(self, *, bad=None, under=None, over=None):
808         """
809         Set the colors for masked (*bad*) values and, when ``norm.clip =
810         False``, low (*under*) and high (*over*) out-of-range values.
811         """
812         if bad is not None:
813             self.set_bad(bad)
814         if under is not None:
815             self.set_under(under)
816         if over is not None:
817             self.set_over(over)
818 
819     def with_extremes(self, *, bad=None, under=None, over=None):
820         """
821         Return a copy of the colormap, for which the colors for masked (*bad*)
822         values and, when ``norm.clip = False``, low (*under*) and high (*over*)
823         out-of-range values, have been set accordingly.
824         """
825         new_cm = self.copy()
826         new_cm.set_extremes(bad=bad, under=under, over=over)
827         return new_cm
828 
829     def _set_extremes(self):
830         if self._rgba_under:
831             self._lut[self._i_under] = self._rgba_under
832         else:
833             self._lut[self._i_under] = self._lut[0]
834         if self._rgba_over:
835             self._lut[self._i_over] = self._rgba_over
836         else:
837             self._lut[self._i_over] = self._lut[self.N - 1]
838         self._lut[self._i_bad] = self._rgba_bad
839 
840     def _init(self):
841         """Generate the lookup table, ``self._lut``."""
842         raise NotImplementedError("Abstract class only")
843 
844     def is_gray(self):
845         """Return whether the colormap is grayscale."""
846         if not self._isinit:
847             self._init()
848         return (np.all(self._lut[:, 0] == self._lut[:, 1]) and
849                 np.all(self._lut[:, 0] == self._lut[:, 2]))
850 
851     def resampled(self, lutsize):
852         """Return a new colormap with *lutsize* entries."""
853         if hasattr(self, '_resample'):
854             _api.warn_external(
855                 "The ability to resample a color map is now public API "
856                 f"However the class {type(self)} still only implements "
857                 "the previous private _resample method.  Please update "
858                 "your class."
859             )
860             return self._resample(lutsize)
861 
862         raise NotImplementedError()
863 
864     def reversed(self, name=None):
865         """
866         Return a reversed instance of the Colormap.
867 
868         .. note:: This function is not implemented for the base class.
869 
870         Parameters
871         ----------
872         name : str, optional
873             The name for the reversed colormap. If None, the
874             name is set to ``self.name + "_r"``.
875 
876         See Also
877         --------
878         LinearSegmentedColormap.reversed
879         ListedColormap.reversed
880         """
881         raise NotImplementedError()
882 
883     def _repr_png_(self):
884         """Generate a PNG representation of the Colormap."""
885         X = np.tile(np.linspace(0, 1, _REPR_PNG_SIZE[0]),
886                     (_REPR_PNG_SIZE[1], 1))
887         pixels = self(X, bytes=True)
888         png_bytes = io.BytesIO()
889         title = self.name + ' colormap'
890         author = f'Matplotlib v{mpl.__version__}, https://matplotlib.org'
891         pnginfo = PngInfo()
892         pnginfo.add_text('Title', title)
893         pnginfo.add_text('Description', title)
894         pnginfo.add_text('Author', author)
895         pnginfo.add_text('Software', author)
896         Image.fromarray(pixels).save(png_bytes, format='png', pnginfo=pnginfo)
897         return png_bytes.getvalue()
898 
899     def _repr_html_(self):
900         """Generate an HTML representation of the Colormap."""
901         png_bytes = self._repr_png_()
902         png_base64 = base64.b64encode(png_bytes).decode('ascii')
903         def color_block(color):
904             hex_color = to_hex(color, keep_alpha=True)
905             return (f'<div title="{hex_color}" '
906                     'style="display: inline-block; '
907                     'width: 1em; height: 1em; '
908                     'margin: 0; '
909                     'vertical-align: middle; '
910                     'border: 1px solid #555; '
911                     f'background-color: {hex_color};"></div>')
912 
913         return ('<div style="vertical-align: middle;">'
914                 f'<strong>{self.name}</strong> '
915                 '</div>'
916                 '<div class="cmap"><img '
917                 f'alt="{self.name} colormap" '
918                 f'title="{self.name}" '
919                 'style="border: 1px solid #555;" '
920                 f'src="data:image/png;base64,{png_base64}"></div>'
921                 '<div style="vertical-align: middle; '
922                 f'max-width: {_REPR_PNG_SIZE[0]+2}px; '
923                 'display: flex; justify-content: space-between;">'
924                 '<div style="float: left;">'
925                 f'{color_block(self.get_under())} under'
926                 '</div>'
927                 '<div style="margin: 0 auto; display: inline-block;">'
928                 f'bad {color_block(self.get_bad())}'
929                 '</div>'
930                 '<div style="float: right;">'
931                 f'over {color_block(self.get_over())}'
932                 '</div>')
933 
934     def copy(self):
935         """Return a copy of the colormap."""
936         return self.__copy__()
937 
938 
939 class LinearSegmentedColormap(Colormap):
940     """
941     Colormap objects based on lookup tables using linear segments.
942 
943     The lookup table is generated using linear interpolation for each
944     primary color, with the 0-1 domain divided into any number of
945     segments.
946     """
947 
948     def __init__(self, name, segmentdata, N=256, gamma=1.0):
949         """
950         Create colormap from linear mapping segments
951 
952         segmentdata argument is a dictionary with a red, green and blue
953         entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
954         forming rows in a table. Entries for alpha are optional.
955 
956         Example: suppose you want red to increase from 0 to 1 over
957         the bottom half, green to do the same over the middle half,
958         and blue over the top half.  Then you would use::
959 
960             cdict = {'red':   [(0.0,  0.0, 0.0),
961                                (0.5,  1.0, 1.0),
962                                (1.0,  1.0, 1.0)],
963 
964                      'green': [(0.0,  0.0, 0.0),
965                                (0.25, 0.0, 0.0),
966                                (0.75, 1.0, 1.0),
967                                (1.0,  1.0, 1.0)],
968 
969                      'blue':  [(0.0,  0.0, 0.0),
970                                (0.5,  0.0, 0.0),
971                                (1.0,  1.0, 1.0)]}
972 
973         Each row in the table for a given color is a sequence of
974         *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
975         monotonically from 0 to 1.  For any input value *z* falling
976         between *x[i]* and *x[i+1]*, the output value of a given color
977         will be linearly interpolated between *y1[i]* and *y0[i+1]*::
978 
979             row i:   x  y0  y1
980                            /
981                           /
982             row i+1: x  y0  y1
983 
984         Hence y0 in the first row and y1 in the last row are never used.
985 
986         See Also
987         --------
988         LinearSegmentedColormap.from_list
989             Static method; factory function for generating a smoothly-varying
990             LinearSegmentedColormap.
991         """
992         # True only if all colors in map are identical; needed for contouring.
993         self.monochrome = False
994         super().__init__(name, N)
995         self._segmentdata = segmentdata
996         self._gamma = gamma
997 
998     def _init(self):
999         self._lut = np.ones((self.N + 3, 4), float)
1000         self._lut[:-3, 0] = _create_lookup_table(
1001             self.N, self._segmentdata['red'], self._gamma)
1002         self._lut[:-3, 1] = _create_lookup_table(
1003             self.N, self._segmentdata['green'], self._gamma)
1004         self._lut[:-3, 2] = _create_lookup_table(
1005             self.N, self._segmentdata['blue'], self._gamma)
1006         if 'alpha' in self._segmentdata:
1007             self._lut[:-3, 3] = _create_lookup_table(
1008                 self.N, self._segmentdata['alpha'], 1)
1009         self._isinit = True
1010         self._set_extremes()
1011 
1012     def set_gamma(self, gamma):
1013         """Set a new gamma value and regenerate colormap."""
1014         self._gamma = gamma
1015         self._init()
1016 
1017     @staticmethod
1018     def from_list(name, colors, N=256, gamma=1.0):
1019         """
1020         Create a `LinearSegmentedColormap` from a list of colors.
1021 
1022         Parameters
1023         ----------
1024         name : str
1025             The name of the colormap.
1026         colors : array-like of colors or array-like of (value, color)
1027             If only colors are given, they are equidistantly mapped from the
1028             range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
1029             ``colors[-1]``.
1030             If (value, color) pairs are given, the mapping is from *value*
1031             to *color*. This can be used to divide the range unevenly.
1032         N : int
1033             The number of RGB quantization levels.
1034         gamma : float
1035         """
1036         if not np.iterable(colors):
1037             raise ValueError('colors must be iterable')
1038 
1039         if (isinstance(colors[0], Sized) and len(colors[0]) == 2
1040                 and not isinstance(colors[0], str)):
1041             # List of value, color pairs
1042             vals, colors = zip(*colors)
1043         else:
1044             vals = np.linspace(0, 1, len(colors))
1045 
1046         r, g, b, a = to_rgba_array(colors).T
1047         cdict = {
1048             "red": np.column_stack([vals, r, r]),
1049             "green": np.column_stack([vals, g, g]),
1050             "blue": np.column_stack([vals, b, b]),
1051             "alpha": np.column_stack([vals, a, a]),
1052         }
1053 
1054         return LinearSegmentedColormap(name, cdict, N, gamma)
1055 
1056     def resampled(self, lutsize):
1057         """Return a new colormap with *lutsize* entries."""
1058         new_cmap = LinearSegmentedColormap(self.name, self._segmentdata,
1059                                            lutsize)
1060         new_cmap._rgba_over = self._rgba_over
1061         new_cmap._rgba_under = self._rgba_under
1062         new_cmap._rgba_bad = self._rgba_bad
1063         return new_cmap
1064 
1065     # Helper ensuring picklability of the reversed cmap.
1066     @staticmethod
1067     def _reverser(func, x):
1068         return func(1 - x)
1069 
1070     def reversed(self, name=None):
1071         """
1072         Return a reversed instance of the Colormap.
1073 
1074         Parameters
1075         ----------
1076         name : str, optional
1077             The name for the reversed colormap. If None, the
1078             name is set to ``self.name + "_r"``.
1079 
1080         Returns
1081         -------
1082         LinearSegmentedColormap
1083             The reversed colormap.
1084         """
1085         if name is None:
1086             name = self.name + "_r"
1087 
1088         # Using a partial object keeps the cmap picklable.
1089         data_r = {key: (functools.partial(self._reverser, data)
1090                         if callable(data) else
1091                         [(1.0 - x, y1, y0) for x, y0, y1 in reversed(data)])
1092                   for key, data in self._segmentdata.items()}
1093 
1094         new_cmap = LinearSegmentedColormap(name, data_r, self.N, self._gamma)
1095         # Reverse the over/under values too
1096         new_cmap._rgba_over = self._rgba_under
1097         new_cmap._rgba_under = self._rgba_over
1098         new_cmap._rgba_bad = self._rgba_bad
1099         return new_cmap
1100 
1101 
1102 class ListedColormap(Colormap):
1103     """
1104     Colormap object generated from a list of colors.
1105 
1106     This may be most useful when indexing directly into a colormap,
1107     but it can also be used to generate special colormaps for ordinary
1108     mapping.
1109 
1110     Parameters
1111     ----------
1112     colors : list, array
1113         List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
1114         floating point array (*N* RGB or RGBA values).
1115     name : str, optional
1116         String to identify the colormap.
1117     N : int, optional
1118         Number of entries in the map. The default is *None*, in which case
1119         there is one colormap entry for each element in the list of colors.
1120         If ::
1121 
1122             N < len(colors)
1123 
1124         the list will be truncated at *N*. If ::
1125 
1126             N > len(colors)
1127 
1128         the list will be extended by repetition.
1129     """
1130     def __init__(self, colors, name='from_list', N=None):
1131         self.monochrome = False  # Are all colors identical? (for contour.py)
1132         if N is None:
1133             self.colors = colors
1134             N = len(colors)
1135         else:
1136             if isinstance(colors, str):
1137                 self.colors = [colors] * N
1138                 self.monochrome = True
1139             elif np.iterable(colors):
1140                 if len(colors) == 1:
1141                     self.monochrome = True
1142                 self.colors = list(
1143                     itertools.islice(itertools.cycle(colors), N))
1144             else:
1145                 try:
1146                     gray = float(colors)
1147                 except TypeError:
1148                     pass
1149                 else:
1150                     self.colors = [gray] * N
1151                 self.monochrome = True
1152         super().__init__(name, N)
1153 
1154     def _init(self):
1155         self._lut = np.zeros((self.N + 3, 4), float)
1156         self._lut[:-3] = to_rgba_array(self.colors)
1157         self._isinit = True
1158         self._set_extremes()
1159 
1160     def resampled(self, lutsize):
1161         """Return a new colormap with *lutsize* entries."""
1162         colors = self(np.linspace(0, 1, lutsize))
1163         new_cmap = ListedColormap(colors, name=self.name)
1164         # Keep the over/under values too
1165         new_cmap._rgba_over = self._rgba_over
1166         new_cmap._rgba_under = self._rgba_under
1167         new_cmap._rgba_bad = self._rgba_bad
1168         return new_cmap
1169 
1170     def reversed(self, name=None):
1171         """
1172         Return a reversed instance of the Colormap.
1173 
1174         Parameters
1175         ----------
1176         name : str, optional
1177             The name for the reversed colormap. If None, the
1178             name is set to ``self.name + "_r"``.
1179 
1180         Returns
1181         -------
1182         ListedColormap
1183             A reversed instance of the colormap.
1184         """
1185         if name is None:
1186             name = self.name + "_r"
1187 
1188         colors_r = list(reversed(self.colors))
1189         new_cmap = ListedColormap(colors_r, name=name, N=self.N)
1190         # Reverse the over/under values too
1191         new_cmap._rgba_over = self._rgba_under
1192         new_cmap._rgba_under = self._rgba_over
1193         new_cmap._rgba_bad = self._rgba_bad
1194         return new_cmap
1195 
1196 
1197 class Normalize:
1198     """
1199     A class which, when called, linearly normalizes data into the
1200     ``[0.0, 1.0]`` interval.
1201     """
1202 
1203     def __init__(self, vmin=None, vmax=None, clip=False):
1204         """
1205         Parameters
1206         ----------
1207         vmin, vmax : float or None
1208             If *vmin* and/or *vmax* is not given, they are initialized from the
1209             minimum and maximum value, respectively, of the first input
1210             processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
1211 
1212         clip : bool, default: False
1213             If ``True`` values falling outside the range ``[vmin, vmax]``,
1214             are mapped to 0 or 1, whichever is closer, and masked values are
1215             set to 1.  If ``False`` masked values remain masked.
1216 
1217             Clipping silently defeats the purpose of setting the over, under,
1218             and masked colors in a colormap, so it is likely to lead to
1219             surprises; therefore the default is ``clip=False``.
1220 
1221         Notes
1222         -----
1223         Returns 0 if ``vmin == vmax``.
1224         """
1225         self._vmin = _sanitize_extrema(vmin)
1226         self._vmax = _sanitize_extrema(vmax)
1227         self._clip = clip
1228         self._scale = None
1229         self.callbacks = cbook.CallbackRegistry(signals=["changed"])
1230 
1231     @property
1232     def vmin(self):
1233         return self._vmin
1234 
1235     @vmin.setter
1236     def vmin(self, value):
1237         value = _sanitize_extrema(value)
1238         if value != self._vmin:
1239             self._vmin = value
1240             self._changed()
1241 
1242     @property
1243     def vmax(self):
1244         return self._vmax
1245 
1246     @vmax.setter
1247     def vmax(self, value):
1248         value = _sanitize_extrema(value)
1249         if value != self._vmax:
1250             self._vmax = value
1251             self._changed()
1252 
1253     @property
1254     def clip(self):
1255         return self._clip
1256 
1257     @clip.setter
1258     def clip(self, value):
1259         if value != self._clip:
1260             self._clip = value
1261             self._changed()
1262 
1263     def _changed(self):
1264         """
1265         Call this whenever the norm is changed to notify all the
1266         callback listeners to the 'changed' signal.
1267         """
1268         self.callbacks.process('changed')
1269 
1270     @staticmethod
1271     def process_value(value):
1272         """
1273         Homogenize the input *value* for easy and efficient normalization.
1274 
1275         *value* can be a scalar or sequence.
1276 
1277         Returns
1278         -------
1279         result : masked array
1280             Masked array with the same shape as *value*.
1281         is_scalar : bool
1282             Whether *value* is a scalar.
1283 
1284         Notes
1285         -----
1286         Float dtypes are preserved; integer types with two bytes or smaller are
1287         converted to np.float32, and larger types are converted to np.float64.
1288         Preserving float32 when possible, and using in-place operations,
1289         greatly improves speed for large arrays.
1290         """
1291         is_scalar = not np.iterable(value)
1292         if is_scalar:
1293             value = [value]
1294         dtype = np.min_scalar_type(value)
1295         if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:
1296             # bool_/int8/int16 -> float32; int32/int64 -> float64
1297             dtype = np.promote_types(dtype, np.float32)
1298         # ensure data passed in as an ndarray subclass are interpreted as
1299         # an ndarray. See issue #6622.
1300         mask = np.ma.getmask(value)
1301         data = np.asarray(value)
1302         result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)
1303         return result, is_scalar
1304 
1305     def __call__(self, value, clip=None):
1306         """
1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the
1308         ``[0.0, 1.0]`` interval and return it.
1309 
1310         Parameters
1311         ----------
1312         value
1313             Data to normalize.
1314         clip : bool
1315             If ``None``, defaults to ``self.clip`` (which defaults to
1316             ``False``).
1317 
1318         Notes
1319         -----
1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are
1321         initialized using ``self.autoscale_None(value)``.
1322         """
1323         if clip is None:
1324             clip = self.clip
1325 
1326         result, is_scalar = self.process_value(value)
1327 
1328         if self.vmin is None or self.vmax is None:
1329             self.autoscale_None(result)
1330         # Convert at least to float, without losing precision.
1331         (vmin,), _ = self.process_value(self.vmin)
1332         (vmax,), _ = self.process_value(self.vmax)
1333         if vmin == vmax:
1334             result.fill(0)  # Or should it be all masked?  Or 0.5?
1335         elif vmin > vmax:
1336             raise ValueError("minvalue must be less than or equal to maxvalue")
1337         else:
1338             if clip:
1339                 mask = np.ma.getmask(result)
1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1341                                      mask=mask)
1342             # ma division is very slow; we can take a shortcut
1343             resdat = result.data
1344             resdat -= vmin
1345             resdat /= (vmax - vmin)
1346             result = np.ma.array(resdat, mask=result.mask, copy=False)
1347         if is_scalar:
1348             result = result[0]
1349         return result
1350 
1351     def inverse(self, value):
1352         if not self.scaled():
1353             raise ValueError("Not invertible until both vmin and vmax are set")
1354         (vmin,), _ = self.process_value(self.vmin)
1355         (vmax,), _ = self.process_value(self.vmax)
1356 
1357         if np.iterable(value):
1358             val = np.ma.asarray(value)
1359             return vmin + val * (vmax - vmin)
1360         else:
1361             return vmin + value * (vmax - vmin)
1362 
1363     def autoscale(self, A):
1364         """Set *vmin*, *vmax* to min, max of *A*."""
1365         self.vmin = self.vmax = None
1366         self.autoscale_None(A)
1367 
1368     def autoscale_None(self, A):
1369         """If vmin or vmax are not set, use the min/max of *A* to set them."""
1370         A = np.asanyarray(A)
1371         if self.vmin is None and A.size:
1372             self.vmin = A.min()
1373         if self.vmax is None and A.size:
1374             self.vmax = A.max()
1375 
1376     def scaled(self):
1377         """Return whether vmin and vmax are set."""
1378         return self.vmin is not None and self.vmax is not None
1379 
1380 
1381 class TwoSlopeNorm(Normalize):
1382     def __init__(self, vcenter, vmin=None, vmax=None):
1383         """
1384         Normalize data with a set center.
1385 
1386         Useful when mapping data with an unequal rates of change around a
1387         conceptual center, e.g., data that range from -2 to 4, with 0 as
1388         the midpoint.
1389 
1390         Parameters
1391         ----------
1392         vcenter : float
1393             The data value that defines ``0.5`` in the normalization.
1394         vmin : float, optional
1395             The data value that defines ``0.0`` in the normalization.
1396             Defaults to the min value of the dataset.
1397         vmax : float, optional
1398             The data value that defines ``1.0`` in the normalization.
1399             Defaults to the max value of the dataset.
1400 
1401         Examples
1402         --------
1403         This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
1404         between is linearly interpolated::
1405 
1406             >>> import matplotlib.colors as mcolors
1407             >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
1408                                               vcenter=0., vmax=10000)
1409             >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
1410             >>> offset(data)
1411             array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
1412         """
1413 
1414         super().__init__(vmin=vmin, vmax=vmax)
1415         self._vcenter = vcenter
1416         if vcenter is not None and vmax is not None and vcenter >= vmax:
1417             raise ValueError('vmin, vcenter, and vmax must be in '
1418                              'ascending order')
1419         if vcenter is not None and vmin is not None and vcenter <= vmin:
1420             raise ValueError('vmin, vcenter, and vmax must be in '
1421                              'ascending order')
1422 
1423     @property
1424     def vcenter(self):
1425         return self._vcenter
1426 
1427     @vcenter.setter
1428     def vcenter(self, value):
1429         if value != self._vcenter:
1430             self._vcenter = value
1431             self._changed()
1432 
1433     def autoscale_None(self, A):
1434         """
1435         Get vmin and vmax.
1436 
1437         If vcenter isn't in the range [vmin, vmax], either vmin or vmax
1438         is expanded so that vcenter lies in the middle of the modified range
1439         [vmin, vmax].
1440         """
1441         super().autoscale_None(A)
1442         if self.vmin >= self.vcenter:
1443             self.vmin = self.vcenter - (self.vmax - self.vcenter)
1444         if self.vmax <= self.vcenter:
1445             self.vmax = self.vcenter + (self.vcenter - self.vmin)
1446 
1447     def __call__(self, value, clip=None):
1448         """
1449         Map value to the interval [0, 1]. The clip argument is unused.
1450         """
1451         result, is_scalar = self.process_value(value)
1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None
1453 
1454         if not self.vmin <= self.vcenter <= self.vmax:
1455             raise ValueError("vmin, vcenter, vmax must increase monotonically")
1456         # note that we must extrapolate for tick locators:
1457         result = np.ma.masked_array(
1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],
1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),
1460             mask=np.ma.getmask(result))
1461         if is_scalar:
1462             result = np.atleast_1d(result)[0]
1463         return result
1464 
1465     def inverse(self, value):
1466         if not self.scaled():
1467             raise ValueError("Not invertible until both vmin and vmax are set")
1468         (vmin,), _ = self.process_value(self.vmin)
1469         (vmax,), _ = self.process_value(self.vmax)
1470         (vcenter,), _ = self.process_value(self.vcenter)
1471         result = np.interp(value, [0, 0.5, 1], [vmin, vcenter, vmax],
1472                            left=-np.inf, right=np.inf)
1473         return result
1474 
1475 
1476 class CenteredNorm(Normalize):
1477     def __init__(self, vcenter=0, halfrange=None, clip=False):
1478         """
1479         Normalize symmetrical data around a center (0 by default).
1480 
1481         Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
1482         around the center.
1483 
1484         Useful when mapping symmetrical data around a conceptual center
1485         e.g., data that range from -2 to 4, with 0 as the midpoint, and
1486         with equal rates of change around that midpoint.
1487 
1488         Parameters
1489         ----------
1490         vcenter : float, default: 0
1491             The data value that defines ``0.5`` in the normalization.
1492         halfrange : float, optional
1493             The range of data values that defines a range of ``0.5`` in the
1494             normalization, so that *vcenter* - *halfrange* is ``0.0`` and
1495             *vcenter* + *halfrange* is ``1.0`` in the normalization.
1496             Defaults to the largest absolute difference to *vcenter* for
1497             the values in the dataset.
1498 
1499         Examples
1500         --------
1501         This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
1502         (assuming equal rates of change above and below 0.0):
1503 
1504             >>> import matplotlib.colors as mcolors
1505             >>> norm = mcolors.CenteredNorm(halfrange=4.0)
1506             >>> data = [-2., 0., 4.]
1507             >>> norm(data)
1508             array([0.25, 0.5 , 1.  ])
1509         """
1510         super().__init__(vmin=None, vmax=None, clip=clip)
1511         self._vcenter = vcenter
1512         # calling the halfrange setter to set vmin and vmax
1513         self.halfrange = halfrange
1514 
1515     def autoscale(self, A):
1516         """
1517         Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
1518         """
1519         A = np.asanyarray(A)
1520         self.halfrange = max(self._vcenter-A.min(),
1521                              A.max()-self._vcenter)
1522 
1523     def autoscale_None(self, A):
1524         """Set *vmin* and *vmax*."""
1525         A = np.asanyarray(A)
1526         if self.halfrange is None and A.size:
1527             self.autoscale(A)
1528 
1529     @property
1530     def vmin(self):
1531         return self._vmin
1532 
1533     @vmin.setter
1534     def vmin(self, value):
1535         value = _sanitize_extrema(value)
1536         if value != self._vmin:
1537             self._vmin = value
1538             self._vmax = 2*self.vcenter - value
1539             self._changed()
1540 
1541     @property
1542     def vmax(self):
1543         return self._vmax
1544 
1545     @vmax.setter
1546     def vmax(self, value):
1547         value = _sanitize_extrema(value)
1548         if value != self._vmax:
1549             self._vmax = value
1550             self._vmin = 2*self.vcenter - value
1551             self._changed()
1552 
1553     @property
1554     def vcenter(self):
1555         return self._vcenter
1556 
1557     @vcenter.setter
1558     def vcenter(self, vcenter):
1559         if vcenter != self._vcenter:
1560             self._vcenter = vcenter
1561             # Trigger an update of the vmin/vmax values through the setter
1562             self.halfrange = self.halfrange
1563             self._changed()
1564 
1565     @property
1566     def halfrange(self):
1567         if self.vmin is None or self.vmax is None:
1568             return None
1569         return (self.vmax - self.vmin) / 2
1570 
1571     @halfrange.setter
1572     def halfrange(self, halfrange):
1573         if halfrange is None:
1574             self.vmin = None
1575             self.vmax = None
1576         else:
1577             self.vmin = self.vcenter - abs(halfrange)
1578             self.vmax = self.vcenter + abs(halfrange)
1579 
1580 
1581 def make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):
1582     """
1583     Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
1584     subclass.
1585 
1586     After ::
1587 
1588         @make_norm_from_scale(scale_cls)
1589         class norm_cls(Normalize):
1590             ...
1591 
1592     *norm_cls* is filled with methods so that normalization computations are
1593     forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
1594     for the colorbar of a mappable normalized with *norm_cls*).
1595 
1596     If *init* is not passed, then the constructor signature of *norm_cls*
1597     will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
1598     parameters will be forwarded to the base class (``Normalize.__init__``),
1599     and a *scale_cls* object will be initialized with no arguments (other than
1600     a dummy axis).
1601 
1602     If the *scale_cls* constructor takes additional parameters, then *init*
1603     should be passed to `make_norm_from_scale`.  It is a callable which is
1604     *only* used for its signature.  First, this signature will become the
1605     signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
1606     parameters passed to it using this signature, extract the bound *vmin*,
1607     *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
1608     forward the remaining bound values (including any defaults defined by the
1609     signature) to the *scale_cls* constructor.
1610     """
1611 
1612     if base_norm_cls is None:
1613         return functools.partial(make_norm_from_scale, scale_cls, init=init)
1614 
1615     if isinstance(scale_cls, functools.partial):
1616         scale_args = scale_cls.args
1617         scale_kwargs_items = tuple(scale_cls.keywords.items())
1618         scale_cls = scale_cls.func
1619     else:
1620         scale_args = scale_kwargs_items = ()
1621 
1622     if init is None:
1623         def init(vmin=None, vmax=None, clip=False): pass
1624 
1625     return _make_norm_from_scale(
1626         scale_cls, scale_args, scale_kwargs_items,
1627         base_norm_cls, inspect.signature(init))
1628 
1629 
1630 @functools.cache
1631 def _make_norm_from_scale(
1632     scale_cls, scale_args, scale_kwargs_items,
1633     base_norm_cls, bound_init_signature,
1634 ):
1635     """
1636     Helper for `make_norm_from_scale`.
1637 
1638     This function is split out to enable caching (in particular so that
1639     different unpickles reuse the same class).  In order to do so,
1640 
1641     - ``functools.partial`` *scale_cls* is expanded into ``func, args, kwargs``
1642       to allow memoizing returned norms (partial instances always compare
1643       unequal, but we can check identity based on ``func, args, kwargs``;
1644     - *init* is replaced by *init_signature*, as signatures are picklable,
1645       unlike to arbitrary lambdas.
1646     """
1647 
1648     class Norm(base_norm_cls):
1649         def __reduce__(self):
1650             cls = type(self)
1651             # If the class is toplevel-accessible, it is possible to directly
1652             # pickle it "by name".  This is required to support norm classes
1653             # defined at a module's toplevel, as the inner base_norm_cls is
1654             # otherwise unpicklable (as it gets shadowed by the generated norm
1655             # class).  If either import or attribute access fails, fall back to
1656             # the general path.
1657             try:
1658                 if cls is getattr(importlib.import_module(cls.__module__),
1659                                   cls.__qualname__):
1660                     return (_create_empty_object_of_class, (cls,), vars(self))
1661             except (ImportError, AttributeError):
1662                 pass
1663             return (_picklable_norm_constructor,
1664                     (scale_cls, scale_args, scale_kwargs_items,
1665                      base_norm_cls, bound_init_signature),
1666                     vars(self))
1667 
1668         def __init__(self, *args, **kwargs):
1669             ba = bound_init_signature.bind(*args, **kwargs)
1670             ba.apply_defaults()
1671             super().__init__(
1672                 **{k: ba.arguments.pop(k) for k in ["vmin", "vmax", "clip"]})
1673             self._scale = functools.partial(
1674                 scale_cls, *scale_args, **dict(scale_kwargs_items))(
1675                     axis=None, **ba.arguments)
1676             self._trf = self._scale.get_transform()
1677 
1678         __init__.__signature__ = bound_init_signature.replace(parameters=[
1679             inspect.Parameter("self", inspect.Parameter.POSITIONAL_OR_KEYWORD),
1680             *bound_init_signature.parameters.values()])
1681 
1682         def __call__(self, value, clip=None):
1683             value, is_scalar = self.process_value(value)
1684             if self.vmin is None or self.vmax is None:
1685                 self.autoscale_None(value)
1686             if self.vmin > self.vmax:
1687                 raise ValueError("vmin must be less or equal to vmax")
1688             if self.vmin == self.vmax:
1689                 return np.full_like(value, 0)
1690             if clip is None:
1691                 clip = self.clip
1692             if clip:
1693                 value = np.clip(value, self.vmin, self.vmax)
1694             t_value = self._trf.transform(value).reshape(np.shape(value))
1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1696             if not np.isfinite([t_vmin, t_vmax]).all():
1697                 raise ValueError("Invalid vmin or vmax")
1698             t_value -= t_vmin
1699             t_value /= (t_vmax - t_vmin)
1700             t_value = np.ma.masked_invalid(t_value, copy=False)
1701             return t_value[0] if is_scalar else t_value
1702 
1703         def inverse(self, value):
1704             if not self.scaled():
1705                 raise ValueError("Not invertible until scaled")
1706             if self.vmin > self.vmax:
1707                 raise ValueError("vmin must be less or equal to vmax")
1708             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1709             if not np.isfinite([t_vmin, t_vmax]).all():
1710                 raise ValueError("Invalid vmin or vmax")
1711             value, is_scalar = self.process_value(value)
1712             rescaled = value * (t_vmax - t_vmin)
1713             rescaled += t_vmin
1714             value = (self._trf
1715                      .inverted()
1716                      .transform(rescaled)
1717                      .reshape(np.shape(value)))
1718             return value[0] if is_scalar else value
1719 
1720         def autoscale_None(self, A):
1721             # i.e. A[np.isfinite(...)], but also for non-array A's
1722             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)
1723             if in_trf_domain.size == 0:
1724                 in_trf_domain = np.ma.masked
1725             return super().autoscale_None(in_trf_domain)
1726 
1727     if base_norm_cls is Normalize:
1728         Norm.__name__ = f"{scale_cls.__name__}Norm"
1729         Norm.__qualname__ = f"{scale_cls.__qualname__}Norm"
1730     else:
1731         Norm.__name__ = base_norm_cls.__name__
1732         Norm.__qualname__ = base_norm_cls.__qualname__
1733     Norm.__module__ = base_norm_cls.__module__
1734     Norm.__doc__ = base_norm_cls.__doc__
1735 
1736     return Norm
1737 
1738 
1739 def _create_empty_object_of_class(cls):
1740     return cls.__new__(cls)
1741 
1742 
1743 def _picklable_norm_constructor(*args):
1744     return _create_empty_object_of_class(_make_norm_from_scale(*args))
1745 
1746 
1747 @make_norm_from_scale(
1748     scale.FuncScale,
1749     init=lambda functions, vmin=None, vmax=None, clip=False: None)
1750 class FuncNorm(Normalize):
1751     """
1752     Arbitrary normalization using functions for the forward and inverse.
1753 
1754     Parameters
1755     ----------
1756     functions : (callable, callable)
1757         two-tuple of the forward and inverse functions for the normalization.
1758         The forward function must be monotonic.
1759 
1760         Both functions must have the signature ::
1761 
1762            def forward(values: array-like) -> array-like
1763 
1764     vmin, vmax : float or None
1765         If *vmin* and/or *vmax* is not given, they are initialized from the
1766         minimum and maximum value, respectively, of the first input
1767         processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
1768 
1769     clip : bool, default: False
1770         If ``True`` values falling outside the range ``[vmin, vmax]``,
1771         are mapped to 0 or 1, whichever is closer, and masked values are
1772         set to 1.  If ``False`` masked values remain masked.
1773 
1774         Clipping silently defeats the purpose of setting the over, under,
1775         and masked colors in a colormap, so it is likely to lead to
1776         surprises; therefore the default is ``clip=False``.
1777     """
1778 
1779 
1780 LogNorm = make_norm_from_scale(
1781     functools.partial(scale.LogScale, nonpositive="mask"))(Normalize)
1782 LogNorm.__name__ = LogNorm.__qualname__ = "LogNorm"
1783 LogNorm.__doc__ = "Normalize a given value to the 0-1 range on a log scale."
1784 
1785 
1786 @make_norm_from_scale(
1787     scale.SymmetricalLogScale,
1788     init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,
1789                 base=10: None)
1790 class SymLogNorm(Normalize):
1791     """
1792     The symmetrical logarithmic scale is logarithmic in both the
1793     positive and negative directions from the origin.
1794 
1795     Since the values close to zero tend toward infinity, there is a
1796     need to have a range around zero that is linear.  The parameter
1797     *linthresh* allows the user to specify the size of this range
1798     (-*linthresh*, *linthresh*).
1799 
1800     Parameters
1801     ----------
1802     linthresh : float
1803         The range within which the plot is linear (to avoid having the plot
1804         go to infinity around zero).
1805     linscale : float, default: 1
1806         This allows the linear range (-*linthresh* to *linthresh*) to be
1807         stretched relative to the logarithmic range. Its value is the
1808         number of decades to use for each half of the linear range. For
1809         example, when *linscale* == 1.0 (the default), the space used for
1810         the positive and negative halves of the linear range will be equal
1811         to one decade in the logarithmic range.
1812     base : float, default: 10
1813     """
1814 
1815     @property
1816     def linthresh(self):
1817         return self._scale.linthresh
1818 
1819     @linthresh.setter
1820     def linthresh(self, value):
1821         self._scale.linthresh = value
1822 
1823 
1824 @make_norm_from_scale(
1825     scale.AsinhScale,
1826     init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None)
1827 class AsinhNorm(Normalize):
1828     """
1829     The inverse hyperbolic sine scale is approximately linear near
1830     the origin, but becomes logarithmic for larger positive
1831     or negative values. Unlike the `SymLogNorm`, the transition between
1832     these linear and logarithmic regions is smooth, which may reduce
1833     the risk of visual artifacts.
1834 
1835     .. note::
1836 
1837        This API is provisional and may be revised in the future
1838        based on early user feedback.
1839 
1840     Parameters
1841     ----------
1842     linear_width : float, default: 1
1843         The effective width of the linear region, beyond which
1844         the transformation becomes asymptotically logarithmic
1845     """
1846 
1847     @property
1848     def linear_width(self):
1849         return self._scale.linear_width
1850 
1851     @linear_width.setter
1852     def linear_width(self, value):
1853         self._scale.linear_width = value
1854 
1855 
1856 class PowerNorm(Normalize):
1857     """
1858     Linearly map a given value to the 0-1 range and then apply
1859     a power-law normalization over that range.
1860     """
1861     def __init__(self, gamma, vmin=None, vmax=None, clip=False):
1862         super().__init__(vmin, vmax, clip)
1863         self.gamma = gamma
1864 
1865     def __call__(self, value, clip=None):
1866         if clip is None:
1867             clip = self.clip
1868 
1869         result, is_scalar = self.process_value(value)
1870 
1871         self.autoscale_None(result)
1872         gamma = self.gamma
1873         vmin, vmax = self.vmin, self.vmax
1874         if vmin > vmax:
1875             raise ValueError("minvalue must be less than or equal to maxvalue")
1876         elif vmin == vmax:
1877             result.fill(0)
1878         else:
1879             if clip:
1880                 mask = np.ma.getmask(result)
1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1882                                      mask=mask)
1883             resdat = result.data
1884             resdat -= vmin
1885             resdat[resdat < 0] = 0
1886             np.power(resdat, gamma, resdat)
1887             resdat /= (vmax - vmin) ** gamma
1888 
1889             result = np.ma.array(resdat, mask=result.mask, copy=False)
1890         if is_scalar:
1891             result = result[0]
1892         return result
1893 
1894     def inverse(self, value):
1895         if not self.scaled():
1896             raise ValueError("Not invertible until scaled")
1897         gamma = self.gamma
1898         vmin, vmax = self.vmin, self.vmax
1899 
1900         if np.iterable(value):
1901             val = np.ma.asarray(value)
1902             return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin
1903         else:
1904             return pow(value, 1. / gamma) * (vmax - vmin) + vmin
1905 
1906 
1907 class BoundaryNorm(Normalize):
1908     """
1909     Generate a colormap index based on discrete intervals.
1910 
1911     Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
1912     instead of to the interval 0-1.
1913     """
1914 
1915     # Mapping to the 0-1 interval could have been done via piece-wise linear
1916     # interpolation, but using integers seems simpler, and reduces the number
1917     # of conversions back and forth between int and float.
1918 
1919     def __init__(self, boundaries, ncolors, clip=False, *, extend='neither'):
1920         """
1921         Parameters
1922         ----------
1923         boundaries : array-like
1924             Monotonically increasing sequence of at least 2 bin edges:  data
1925             falling in the n-th bin will be mapped to the n-th color.
1926 
1927         ncolors : int
1928             Number of colors in the colormap to be used.
1929 
1930         clip : bool, optional
1931             If clip is ``True``, out of range values are mapped to 0 if they
1932             are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
1933             are above ``boundaries[-1]``.
1934 
1935             If clip is ``False``, out of range values are mapped to -1 if
1936             they are below ``boundaries[0]`` or mapped to *ncolors* if they are
1937             above ``boundaries[-1]``. These are then converted to valid indices
1938             by `Colormap.__call__`.
1939 
1940         extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
1941             Extend the number of bins to include one or both of the
1942             regions beyond the boundaries.  For example, if ``extend``
1943             is 'min', then the color to which the region between the first
1944             pair of boundaries is mapped will be distinct from the first
1945             color in the colormap, and by default a
1946             `~matplotlib.colorbar.Colorbar` will be drawn with
1947             the triangle extension on the left or lower end.
1948 
1949         Notes
1950         -----
1951         If there are fewer bins (including extensions) than colors, then the
1952         color index is chosen by linearly interpolating the ``[0, nbins - 1]``
1953         range onto the ``[0, ncolors - 1]`` range, effectively skipping some
1954         colors in the middle of the colormap.
1955         """
1956         if clip and extend != 'neither':
1957             raise ValueError("'clip=True' is not compatible with 'extend'")
1958         super().__init__(vmin=boundaries[0], vmax=boundaries[-1], clip=clip)
1959         self.boundaries = np.asarray(boundaries)
1960         self.N = len(self.boundaries)
1961         if self.N < 2:
1962             raise ValueError("You must provide at least 2 boundaries "
1963                              f"(1 region) but you passed in {boundaries!r}")
1964         self.Ncmap = ncolors
1965         self.extend = extend
1966 
1967         self._scale = None  # don't use the default scale.
1968 
1969         self._n_regions = self.N - 1  # number of colors needed
1970         self._offset = 0
1971         if extend in ('min', 'both'):
1972             self._n_regions += 1
1973             self._offset = 1
1974         if extend in ('max', 'both'):
1975             self._n_regions += 1
1976         if self._n_regions > self.Ncmap:
1977             raise ValueError(f"There are {self._n_regions} color bins "
1978                              "including extensions, but ncolors = "
1979                              f"{ncolors}; ncolors must equal or exceed the "
1980                              "number of bins")
1981 
1982     def __call__(self, value, clip=None):
1983         """
1984         This method behaves similarly to `.Normalize.__call__`, except that it
1985         returns integers or arrays of int16.
1986         """
1987         if clip is None:
1988             clip = self.clip
1989 
1990         xx, is_scalar = self.process_value(value)
1991         mask = np.ma.getmaskarray(xx)
1992         # Fill masked values a value above the upper boundary
1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))
1994         if clip:
1995             np.clip(xx, self.vmin, self.vmax, out=xx)
1996             max_col = self.Ncmap - 1
1997         else:
1998             max_col = self.Ncmap
1999         # this gives us the bins in the lookup table in the range
2000         # [0, _n_regions - 1]  (the offset is set in the init)
2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset
2002         # if we have more colors than regions, stretch the region
2003         # index computed above to full range of the color bins.  This
2004         # will make use of the full range (but skip some of the colors
2005         # in the middle) such that the first region is mapped to the
2006         # first color and the last region is mapped to the last color.
2007         if self.Ncmap > self._n_regions:
2008             if self._n_regions == 1:
2009                 # special case the 1 region case, pick the middle color
2010                 iret[iret == 0] = (self.Ncmap - 1) // 2
2011             else:
2012                 # otherwise linearly remap the values from the region index
2013                 # to the color index spaces
2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret
2015         # cast to 16bit integers in all cases
2016         iret = iret.astype(np.int16)
2017         iret[xx < self.vmin] = -1
2018         iret[xx >= self.vmax] = max_col
2019         ret = np.ma.array(iret, mask=mask)
2020         if is_scalar:
2021             ret = int(ret[0])  # assume python scalar
2022         return ret
2023 
2024     def inverse(self, value):
2025         """
2026         Raises
2027         ------
2028         ValueError
2029             BoundaryNorm is not invertible, so calling this method will always
2030             raise an error
2031         """
2032         raise ValueError("BoundaryNorm is not invertible")
2033 
2034 
2035 class NoNorm(Normalize):
2036     """
2037     Dummy replacement for `Normalize`, for the case where we want to use
2038     indices directly in a `~matplotlib.cm.ScalarMappable`.
2039     """
2040     def __call__(self, value, clip=None):
2041         return value
2042 
2043     def inverse(self, value):
2044         return value
2045 
2046 
2047 def rgb_to_hsv(arr):
2048     """
2049     Convert float RGB values (in the range [0, 1]), in a numpy array to HSV
2050     values.
2051 
2052     Parameters
2053     ----------
2054     arr : (..., 3) array-like
2055        All values must be in the range [0, 1]
2056 
2057     Returns
2058     -------
2059     (..., 3) `~numpy.ndarray`
2060        Colors converted to HSV values in range [0, 1]
2061     """
2062     arr = np.asarray(arr)
2063 
2064     # check length of the last dimension, should be _some_ sort of rgb
2065     if arr.shape[-1] != 3:
2066         raise ValueError("Last dimension of input array must be 3; "
2067                          f"shape {arr.shape} was found.")
2068 
2069     in_shape = arr.shape
2070     arr = np.array(
2071         arr, copy=False,
2072         dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.
2073         ndmin=2,  # In case input was 1D.
2074     )
2075     out = np.zeros_like(arr)
2076     arr_max = arr.max(-1)
2077     ipos = arr_max > 0
2078     delta = arr.ptp(-1)
2079     s = np.zeros_like(delta)
2080     s[ipos] = delta[ipos] / arr_max[ipos]
2081     ipos = delta > 0
2082     # red is max
2083     idx = (arr[..., 0] == arr_max) & ipos
2084     out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]
2085     # green is max
2086     idx = (arr[..., 1] == arr_max) & ipos
2087     out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]
2088     # blue is max
2089     idx = (arr[..., 2] == arr_max) & ipos
2090     out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]
2091 
2092     out[..., 0] = (out[..., 0] / 6.0) % 1.0
2093     out[..., 1] = s
2094     out[..., 2] = arr_max
2095 
2096     return out.reshape(in_shape)
2097 
2098 
2099 def hsv_to_rgb(hsv):
2100     """
2101     Convert HSV values to RGB.
2102 
2103     Parameters
2104     ----------
2105     hsv : (..., 3) array-like
2106        All values assumed to be in range [0, 1]
2107 
2108     Returns
2109     -------
2110     (..., 3) `~numpy.ndarray`
2111        Colors converted to RGB values in range [0, 1]
2112     """
2113     hsv = np.asarray(hsv)
2114 
2115     # check length of the last dimension, should be _some_ sort of rgb
2116     if hsv.shape[-1] != 3:
2117         raise ValueError("Last dimension of input array must be 3; "
2118                          f"shape {hsv.shape} was found.")
2119 
2120     in_shape = hsv.shape
2121     hsv = np.array(
2122         hsv, copy=False,
2123         dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.
2124         ndmin=2,  # In case input was 1D.
2125     )
2126 
2127     h = hsv[..., 0]
2128     s = hsv[..., 1]
2129     v = hsv[..., 2]
2130 
2131     r = np.empty_like(h)
2132     g = np.empty_like(h)
2133     b = np.empty_like(h)
2134 
2135     i = (h * 6.0).astype(int)
2136     f = (h * 6.0) - i
2137     p = v * (1.0 - s)
2138     q = v * (1.0 - s * f)
2139     t = v * (1.0 - s * (1.0 - f))
2140 
2141     idx = i % 6 == 0
2142     r[idx] = v[idx]
2143     g[idx] = t[idx]
2144     b[idx] = p[idx]
2145 
2146     idx = i == 1
2147     r[idx] = q[idx]
2148     g[idx] = v[idx]
2149     b[idx] = p[idx]
2150 
2151     idx = i == 2
2152     r[idx] = p[idx]
2153     g[idx] = v[idx]
2154     b[idx] = t[idx]
2155 
2156     idx = i == 3
2157     r[idx] = p[idx]
2158     g[idx] = q[idx]
2159     b[idx] = v[idx]
2160 
2161     idx = i == 4
2162     r[idx] = t[idx]
2163     g[idx] = p[idx]
2164     b[idx] = v[idx]
2165 
2166     idx = i == 5
2167     r[idx] = v[idx]
2168     g[idx] = p[idx]
2169     b[idx] = q[idx]
2170 
2171     idx = s == 0
2172     r[idx] = v[idx]
2173     g[idx] = v[idx]
2174     b[idx] = v[idx]
2175 
2176     rgb = np.stack([r, g, b], axis=-1)
2177 
2178     return rgb.reshape(in_shape)
2179 
2180 
2181 def _vector_magnitude(arr):
2182     # things that don't work here:
2183     #  * np.linalg.norm: drops mask from ma.array
2184     #  * np.sum: drops mask from ma.array unless entire vector is masked
2185     sum_sq = 0
2186     for i in range(arr.shape[-1]):
2187         sum_sq += arr[..., i, np.newaxis] ** 2
2188     return np.sqrt(sum_sq)
2189 
2190 
2191 class LightSource:
2192     """
2193     Create a light source coming from the specified azimuth and elevation.
2194     Angles are in degrees, with the azimuth measured
2195     clockwise from north and elevation up from the zero plane of the surface.
2196 
2197     `shade` is used to produce "shaded" RGB values for a data array.
2198     `shade_rgb` can be used to combine an RGB image with an elevation map.
2199     `hillshade` produces an illumination map of a surface.
2200     """
2201 
2202     def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,
2203                  hsv_min_sat=1, hsv_max_sat=0):
2204         """
2205         Specify the azimuth (measured clockwise from south) and altitude
2206         (measured up from the plane of the surface) of the light source
2207         in degrees.
2208 
2209         Parameters
2210         ----------
2211         azdeg : float, default: 315 degrees (from the northwest)
2212             The azimuth (0-360, degrees clockwise from North) of the light
2213             source.
2214         altdeg : float, default: 45 degrees
2215             The altitude (0-90, degrees up from horizontal) of the light
2216             source.
2217 
2218         Notes
2219         -----
2220         For backwards compatibility, the parameters *hsv_min_val*,
2221         *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
2222         initialization as well.  However, these parameters will only be used if
2223         "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
2224         See the documentation for `blend_hsv` for more details.
2225         """
2226         self.azdeg = azdeg
2227         self.altdeg = altdeg
2228         self.hsv_min_val = hsv_min_val
2229         self.hsv_max_val = hsv_max_val
2230         self.hsv_min_sat = hsv_min_sat
2231         self.hsv_max_sat = hsv_max_sat
2232 
2233     @property
2234     def direction(self):
2235         """The unit vector direction towards the light source."""
2236         # Azimuth is in degrees clockwise from North. Convert to radians
2237         # counterclockwise from East (mathematical notation).
2238         az = np.radians(90 - self.azdeg)
2239         alt = np.radians(self.altdeg)
2240         return np.array([
2241             np.cos(az) * np.cos(alt),
2242             np.sin(az) * np.cos(alt),
2243             np.sin(alt)
2244         ])
2245 
2246     def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):
2247         """
2248         Calculate the illumination intensity for a surface using the defined
2249         azimuth and elevation for the light source.
2250 
2251         This computes the normal vectors for the surface, and then passes them
2252         on to `shade_normals`
2253 
2254         Parameters
2255         ----------
2256         elevation : 2D array-like
2257             The height values used to generate an illumination map
2258         vert_exag : number, optional
2259             The amount to exaggerate the elevation values by when calculating
2260             illumination. This can be used either to correct for differences in
2261             units between the x-y coordinate system and the elevation
2262             coordinate system (e.g. decimal degrees vs. meters) or to
2263             exaggerate or de-emphasize topographic effects.
2264         dx : number, optional
2265             The x-spacing (columns) of the input *elevation* grid.
2266         dy : number, optional
2267             The y-spacing (rows) of the input *elevation* grid.
2268         fraction : number, optional
2269             Increases or decreases the contrast of the hillshade.  Values
2270             greater than one will cause intermediate values to move closer to
2271             full illumination or shadow (and clipping any values that move
2272             beyond 0 or 1). Note that this is not visually or mathematically
2273             the same as vertical exaggeration.
2274 
2275         Returns
2276         -------
2277         `~numpy.ndarray`
2278             A 2D array of illumination values between 0-1, where 0 is
2279             completely in shadow and 1 is completely illuminated.
2280         """
2281 
2282         # Because most image and raster GIS data has the first row in the array
2283         # as the "top" of the image, dy is implicitly negative.  This is
2284         # consistent to what `imshow` assumes, as well.
2285         dy = -dy
2286 
2287         # compute the normal vectors from the partial derivatives
2288         e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)
2289 
2290         # .view is to keep subclasses
2291         normal = np.empty(elevation.shape + (3,)).view(type(elevation))
2292         normal[..., 0] = -e_dx
2293         normal[..., 1] = -e_dy
2294         normal[..., 2] = 1
2295         normal /= _vector_magnitude(normal)
2296 
2297         return self.shade_normals(normal, fraction)
2298 
2299     def shade_normals(self, normals, fraction=1.):
2300         """
2301         Calculate the illumination intensity for the normal vectors of a
2302         surface using the defined azimuth and elevation for the light source.
2303 
2304         Imagine an artificial sun placed at infinity in some azimuth and
2305         elevation position illuminating our surface. The parts of the surface
2306         that slope toward the sun should brighten while those sides facing away
2307         should become darker.
2308 
2309         Parameters
2310         ----------
2311         fraction : number, optional
2312             Increases or decreases the contrast of the hillshade.  Values
2313             greater than one will cause intermediate values to move closer to
2314             full illumination or shadow (and clipping any values that move
2315             beyond 0 or 1). Note that this is not visually or mathematically
2316             the same as vertical exaggeration.
2317 
2318         Returns
2319         -------
2320         `~numpy.ndarray`
2321             A 2D array of illumination values between 0-1, where 0 is
2322             completely in shadow and 1 is completely illuminated.
2323         """
2324 
2325         intensity = normals.dot(self.direction)
2326 
2327         # Apply contrast stretch
2328         imin, imax = intensity.min(), intensity.max()
2329         intensity *= fraction
2330 
2331         # Rescale to 0-1, keeping range before contrast stretch
2332         # If constant slope, keep relative scaling (i.e. flat should be 0.5,
2333         # fully occluded 0, etc.)
2334         if (imax - imin) > 1e-6:
2335             # Strictly speaking, this is incorrect. Negative values should be
2336             # clipped to 0 because they're fully occluded. However, rescaling
2337             # in this manner is consistent with the previous implementation and
2338             # visually appears better than a "hard" clip.
2339             intensity -= imin
2340             intensity /= (imax - imin)
2341         intensity = np.clip(intensity, 0, 1)
2342 
2343         return intensity
2344 
2345     def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,
2346               vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):
2347         """
2348         Combine colormapped data values with an illumination intensity map
2349         (a.k.a.  "hillshade") of the values.
2350 
2351         Parameters
2352         ----------
2353         data : 2D array-like
2354             The height values used to generate a shaded map.
2355         cmap : `~matplotlib.colors.Colormap`
2356             The colormap used to color the *data* array. Note that this must be
2357             a `~matplotlib.colors.Colormap` instance.  For example, rather than
2358             passing in ``cmap='gist_earth'``, use
2359             ``cmap=plt.get_cmap('gist_earth')`` instead.
2360         norm : `~matplotlib.colors.Normalize` instance, optional
2361             The normalization used to scale values before colormapping. If
2362             None, the input will be linearly scaled between its min and max.
2363         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
2364             The type of blending used to combine the colormapped data
2365             values with the illumination intensity.  Default is
2366             "overlay".  Note that for most topographic surfaces,
2367             "overlay" or "soft" appear more visually realistic. If a
2368             user-defined function is supplied, it is expected to
2369             combine an MxNx3 RGB array of floats (ranging 0 to 1) with
2370             an MxNx1 hillshade array (also 0 to 1).  (Call signature
2371             ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
2372             to this function will be passed on to the *blend_mode*
2373             function.
2374         vmin : float or None, optional
2375             The minimum value used in colormapping *data*. If *None* the
2376             minimum value in *data* is used. If *norm* is specified, then this
2377             argument will be ignored.
2378         vmax : float or None, optional
2379             The maximum value used in colormapping *data*. If *None* the
2380             maximum value in *data* is used. If *norm* is specified, then this
2381             argument will be ignored.
2382         vert_exag : number, optional
2383             The amount to exaggerate the elevation values by when calculating
2384             illumination. This can be used either to correct for differences in
2385             units between the x-y coordinate system and the elevation
2386             coordinate system (e.g. decimal degrees vs. meters) or to
2387             exaggerate or de-emphasize topography.
2388         dx : number, optional
2389             The x-spacing (columns) of the input *elevation* grid.
2390         dy : number, optional
2391             The y-spacing (rows) of the input *elevation* grid.
2392         fraction : number, optional
2393             Increases or decreases the contrast of the hillshade.  Values
2394             greater than one will cause intermediate values to move closer to
2395             full illumination or shadow (and clipping any values that move
2396             beyond 0 or 1). Note that this is not visually or mathematically
2397             the same as vertical exaggeration.
2398         Additional kwargs are passed on to the *blend_mode* function.
2399 
2400         Returns
2401         -------
2402         `~numpy.ndarray`
2403             An MxNx4 array of floats ranging between 0-1.
2404         """
2405         if vmin is None:
2406             vmin = data.min()
2407         if vmax is None:
2408             vmax = data.max()
2409         if norm is None:
2410             norm = Normalize(vmin=vmin, vmax=vmax)
2411 
2412         rgb0 = cmap(norm(data))
2413         rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,
2414                               vert_exag=vert_exag, dx=dx, dy=dy,
2415                               fraction=fraction, **kwargs)
2416         # Don't overwrite the alpha channel, if present.
2417         rgb0[..., :3] = rgb1[..., :3]
2418         return rgb0
2419 
2420     def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',
2421                   vert_exag=1, dx=1, dy=1, **kwargs):
2422         """
2423         Use this light source to adjust the colors of the *rgb* input array to
2424         give the impression of a shaded relief map with the given *elevation*.
2425 
2426         Parameters
2427         ----------
2428         rgb : array-like
2429             An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
2430         elevation : array-like
2431             An (M, N) array of the height values used to generate a shaded map.
2432         fraction : number
2433             Increases or decreases the contrast of the hillshade.  Values
2434             greater than one will cause intermediate values to move closer to
2435             full illumination or shadow (and clipping any values that move
2436             beyond 0 or 1). Note that this is not visually or mathematically
2437             the same as vertical exaggeration.
2438         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
2439             The type of blending used to combine the colormapped data values
2440             with the illumination intensity.  For backwards compatibility, this
2441             defaults to "hsv". Note that for most topographic surfaces,
2442             "overlay" or "soft" appear more visually realistic. If a
2443             user-defined function is supplied, it is expected to combine an
2444             MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
2445             array (also 0 to 1).  (Call signature
2446             ``func(rgb, illum, **kwargs)``)
2447             Additional kwargs supplied to this function will be passed on to
2448             the *blend_mode* function.
2449         vert_exag : number, optional
2450             The amount to exaggerate the elevation values by when calculating
2451             illumination. This can be used either to correct for differences in
2452             units between the x-y coordinate system and the elevation
2453             coordinate system (e.g. decimal degrees vs. meters) or to
2454             exaggerate or de-emphasize topography.
2455         dx : number, optional
2456             The x-spacing (columns) of the input *elevation* grid.
2457         dy : number, optional
2458             The y-spacing (rows) of the input *elevation* grid.
2459         Additional kwargs are passed on to the *blend_mode* function.
2460 
2461         Returns
2462         -------
2463         `~numpy.ndarray`
2464             An (m, n, 3) array of floats ranging between 0-1.
2465         """
2466         # Calculate the "hillshade" intensity.
2467         intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)
2468         intensity = intensity[..., np.newaxis]
2469 
2470         # Blend the hillshade and rgb data using the specified mode
2471         lookup = {
2472                 'hsv': self.blend_hsv,
2473                 'soft': self.blend_soft_light,
2474                 'overlay': self.blend_overlay,
2475                 }
2476         if blend_mode in lookup:
2477             blend = lookup[blend_mode](rgb, intensity, **kwargs)
2478         else:
2479             try:
2480                 blend = blend_mode(rgb, intensity, **kwargs)
2481             except TypeError as err:
2482                 raise ValueError('"blend_mode" must be callable or one of '
2483                                  f'{lookup.keys}') from err
2484 
2485         # Only apply result where hillshade intensity isn't masked
2486         if np.ma.is_masked(intensity):
2487             mask = intensity.mask[..., 0]
2488             for i in range(3):
2489                 blend[..., i][mask] = rgb[..., i][mask]
2490 
2491         return blend
2492 
2493     def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,
2494                   hsv_min_val=None, hsv_min_sat=None):
2495         """
2496         Take the input data array, convert to HSV values in the given colormap,
2497         then adjust those color values to give the impression of a shaded
2498         relief map with a specified light source.  RGBA values are returned,
2499         which can then be used to plot the shaded image with imshow.
2500 
2501         The color of the resulting image will be darkened by moving the (s, v)
2502         values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the
2503         shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
2504         hsv_max_val) in regions that are illuminated.  The default extremes are
2505         chose so that completely shaded points are nearly black (s = 1, v = 0)
2506         and completely illuminated points are nearly white (s = 0, v = 1).
2507 
2508         Parameters
2509         ----------
2510         rgb : `~numpy.ndarray`
2511             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
2512         intensity : `~numpy.ndarray`
2513             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
2514         hsv_max_sat : number, default: 1
2515             The maximum saturation value that the *intensity* map can shift the
2516             output image to.
2517         hsv_min_sat : number, optional
2518             The minimum saturation value that the *intensity* map can shift the
2519             output image to. Defaults to 0.
2520         hsv_max_val : number, optional
2521             The maximum value ("v" in "hsv") that the *intensity* map can shift
2522             the output image to. Defaults to 1.
2523         hsv_min_val : number, optional
2524             The minimum value ("v" in "hsv") that the *intensity* map can shift
2525             the output image to. Defaults to 0.
2526 
2527         Returns
2528         -------
2529         `~numpy.ndarray`
2530             An MxNx3 RGB array representing the combined images.
2531         """
2532         # Backward compatibility...
2533         if hsv_max_sat is None:
2534             hsv_max_sat = self.hsv_max_sat
2535         if hsv_max_val is None:
2536             hsv_max_val = self.hsv_max_val
2537         if hsv_min_sat is None:
2538             hsv_min_sat = self.hsv_min_sat
2539         if hsv_min_val is None:
2540             hsv_min_val = self.hsv_min_val
2541 
2542         # Expects a 2D intensity array scaled between -1 to 1...
2543         intensity = intensity[..., 0]
2544         intensity = 2 * intensity - 1
2545 
2546         # Convert to rgb, then rgb to hsv
2547         hsv = rgb_to_hsv(rgb[:, :, 0:3])
2548         hue, sat, val = np.moveaxis(hsv, -1, 0)
2549 
2550         # Modify hsv values (in place) to simulate illumination.
2551         # putmask(A, mask, B) <=> A[mask] = B[mask]
2552         np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),
2553                    (1 - intensity) * sat + intensity * hsv_max_sat)
2554         np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),
2555                    (1 + intensity) * sat - intensity * hsv_min_sat)
2556         np.putmask(val, intensity > 0,
2557                    (1 - intensity) * val + intensity * hsv_max_val)
2558         np.putmask(val, intensity < 0,
2559                    (1 + intensity) * val - intensity * hsv_min_val)
2560         np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])
2561 
2562         # Convert modified hsv back to rgb.
2563         return hsv_to_rgb(hsv)
2564 
2565     def blend_soft_light(self, rgb, intensity):
2566         """
2567         Combine an RGB image with an intensity map using "soft light" blending,
2568         using the "pegtop" formula.
2569 
2570         Parameters
2571         ----------
2572         rgb : `~numpy.ndarray`
2573             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
2574         intensity : `~numpy.ndarray`
2575             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
2576 
2577         Returns
2578         -------
2579         `~numpy.ndarray`
2580             An MxNx3 RGB array representing the combined images.
2581         """
2582         return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2
2583 
2584     def blend_overlay(self, rgb, intensity):
2585         """
2586         Combine an RGB image with an intensity map using "overlay" blending.
2587 
2588         Parameters
2589         ----------
2590         rgb : `~numpy.ndarray`
2591             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
2592         intensity : `~numpy.ndarray`
2593             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
2594 
2595         Returns
2596         -------
2597         ndarray
2598             An MxNx3 RGB array representing the combined images.
2599         """
2600         low = 2 * intensity * rgb
2601         high = 1 - 2 * (1 - intensity) * (1 - rgb)
2602         return np.where(rgb <= 0.5, low, high)
2603 
2604 
2605 def from_levels_and_colors(levels, colors, extend='neither'):
2606     """
2607     A helper routine to generate a cmap and a norm instance which
2608     behave similar to contourf's levels and colors arguments.
2609 
2610     Parameters
2611     ----------
2612     levels : sequence of numbers
2613         The quantization levels used to construct the `BoundaryNorm`.
2614         Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
2615     colors : sequence of colors
2616         The fill color to use for each level. If *extend* is "neither" there
2617         must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
2618         one extra color, and for an *extend* of "both" add two colors.
2619     extend : {'neither', 'min', 'max', 'both'}, optional
2620         The behaviour when a value falls out of range of the given levels.
2621         See `~.Axes.contourf` for details.
2622 
2623     Returns
2624     -------
2625     cmap : `~matplotlib.colors.Normalize`
2626     norm : `~matplotlib.colors.Colormap`
2627     """
2628     slice_map = {
2629         'both': slice(1, -1),
2630         'min': slice(1, None),
2631         'max': slice(0, -1),
2632         'neither': slice(0, None),
2633     }
2634     _api.check_in_list(slice_map, extend=extend)
2635     color_slice = slice_map[extend]
2636 
2637     n_data_colors = len(levels) - 1
2638     n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)
2639     if len(colors) != n_expected:
2640         raise ValueError(
2641             f'With extend == {extend!r} and {len(levels)} levels, '
2642             f'expected {n_expected} colors, but got {len(colors)}')
2643 
2644     cmap = ListedColormap(colors[color_slice], N=n_data_colors)
2645 
2646     if extend in ['min', 'both']:
2647         cmap.set_under(colors[0])
2648     else:
2649         cmap.set_under('none')
2650 
2651     if extend in ['max', 'both']:
2652         cmap.set_over(colors[-1])
2653     else:
2654         cmap.set_over('none')
2655 
2656     cmap.colorbar_extend = extend
2657 
2658     norm = BoundaryNorm(levels, ncolors=n_data_colors)
2659     return cmap, norm

</code><intended_behavior>Ensure that any updates to `vmin` and `vmax` after the initial setting are validated and processed in a manner that acknowledges the constraints of logarithmic scaling (i.e., both must be positive, and `vmin` must be less than `vmax`). It would involve dynamically recalculating the normalized values and applying them without causing errors under valid configurations.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Colorbars are a visualization of the mapping from scalar values to colors.
3 In Matplotlib they are drawn into a dedicated `~.axes.Axes`.
4 
5 .. note::
6    Colorbars are typically created through `.Figure.colorbar` or its pyplot
7    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with
8    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for
9    non-`.GridSpec`-positioned axes).
10 
11    End-users most likely won't need to directly use this module's API.
12 """
13 
14 import logging
15 
16 import numpy as np
17 
18 import matplotlib as mpl
19 from matplotlib import _api, cbook, collections, cm, colors, contour, ticker
20 import matplotlib.artist as martist
21 import matplotlib.patches as mpatches
22 import matplotlib.path as mpath
23 import matplotlib.spines as mspines
24 import matplotlib.transforms as mtransforms
25 from matplotlib import _docstring
26 
27 _log = logging.getLogger(__name__)
28 
29 _docstring.interpd.update(
30     _make_axes_kw_doc="""
31 location : None or {'left', 'right', 'top', 'bottom'}
32     The location, relative to the parent axes, where the colorbar axes
33     is created.  It also determines the *orientation* of the colorbar
34     (colorbars on the left and right are vertical, colorbars at the top
35     and bottom are horizontal).  If None, the location will come from the
36     *orientation* if it is set (vertical colorbars on the right, horizontal
37     ones at the bottom), or default to 'right' if *orientation* is unset.
38 
39 orientation : None or {'vertical', 'horizontal'}
40     The orientation of the colorbar.  It is preferable to set the *location*
41     of the colorbar, as that also determines the *orientation*; passing
42     incompatible values for *location* and *orientation* raises an exception.
43 
44 fraction : float, default: 0.15
45     Fraction of original axes to use for colorbar.
46 
47 shrink : float, default: 1.0
48     Fraction by which to multiply the size of the colorbar.
49 
50 aspect : float, default: 20
51     Ratio of long to short dimensions.
52 
53 pad : float, default: 0.05 if vertical, 0.15 if horizontal
54     Fraction of original axes between colorbar and new image axes.
55 
56 anchor : (float, float), optional
57     The anchor point of the colorbar axes.
58     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.
59 
60 panchor : (float, float), or *False*, optional
61     The anchor point of the colorbar parent axes. If *False*, the parent
62     axes' anchor will be unchanged.
63     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.""",
64     _colormap_kw_doc="""
65 extend : {'neither', 'both', 'min', 'max'}
66     Make pointed end(s) for out-of-range values (unless 'neither').  These are
67     set for a given colormap using the colormap set_under and set_over methods.
68 
69 extendfrac : {*None*, 'auto', length, lengths}
70     If set to *None*, both the minimum and maximum triangular colorbar
71     extensions will have a length of 5% of the interior colorbar length (this
72     is the default setting).
73 
74     If set to 'auto', makes the triangular colorbar extensions the same lengths
75     as the interior boxes (when *spacing* is set to 'uniform') or the same
76     lengths as the respective adjacent interior boxes (when *spacing* is set to
77     'proportional').
78 
79     If a scalar, indicates the length of both the minimum and maximum
80     triangular colorbar extensions as a fraction of the interior colorbar
81     length.  A two-element sequence of fractions may also be given, indicating
82     the lengths of the minimum and maximum colorbar extensions respectively as
83     a fraction of the interior colorbar length.
84 
85 extendrect : bool
86     If *False* the minimum and maximum colorbar extensions will be triangular
87     (the default).  If *True* the extensions will be rectangular.
88 
89 spacing : {'uniform', 'proportional'}
90     For discrete colorbars (`.BoundaryNorm` or contours), 'uniform' gives each
91     color the same space; 'proportional' makes the space proportional to the
92     data interval.
93 
94 ticks : None or list of ticks or Locator
95     If None, ticks are determined automatically from the input.
96 
97 format : None or str or Formatter
98     If None, `~.ticker.ScalarFormatter` is used.
99     Format strings, e.g., ``"%4.2e"`` or ``"{x:.2e}"``, are supported.
100     An alternative `~.ticker.Formatter` may be given instead.
101 
102 drawedges : bool
103     Whether to draw lines at color boundaries.
104 
105 label : str
106     The label on the colorbar's long axis.
107 
108 boundaries, values : None or a sequence
109     If unset, the colormap will be displayed on a 0-1 scale.
110     If sequences, *values* must have a length 1 less than *boundaries*.  For
111     each region delimited by adjacent entries in *boundaries*, the color mapped
112     to the corresponding value in values will be used.
113     Normally only useful for indexed colors (i.e. ``norm=NoNorm()``) or other
114     unusual circumstances.""")
115 
116 
117 def _set_ticks_on_axis_warn(*args, **kwargs):
118     # a top level function which gets put in at the axes'
119     # set_xticks and set_yticks by Colorbar.__init__.
120     _api.warn_external("Use the colorbar set_ticks() method instead.")
121 
122 
123 class _ColorbarSpine(mspines.Spine):
124     def __init__(self, axes):
125         self._ax = axes
126         super().__init__(axes, 'colorbar', mpath.Path(np.empty((0, 2))))
127         mpatches.Patch.set_transform(self, axes.transAxes)
128 
129     def get_window_extent(self, renderer=None):
130         # This Spine has no Axis associated with it, and doesn't need to adjust
131         # its location, so we can directly get the window extent from the
132         # super-super-class.
133         return mpatches.Patch.get_window_extent(self, renderer=renderer)
134 
135     def set_xy(self, xy):
136         self._path = mpath.Path(xy, closed=True)
137         self._xy = xy
138         self.stale = True
139 
140     def draw(self, renderer):
141         ret = mpatches.Patch.draw(self, renderer)
142         self.stale = False
143         return ret
144 
145 
146 class _ColorbarAxesLocator:
147     """
148     Shrink the axes if there are triangular or rectangular extends.
149     """
150     def __init__(self, cbar):
151         self._cbar = cbar
152         self._orig_locator = cbar.ax._axes_locator
153 
154     def __call__(self, ax, renderer):
155         if self._orig_locator is not None:
156             pos = self._orig_locator(ax, renderer)
157         else:
158             pos = ax.get_position(original=True)
159         if self._cbar.extend == 'neither':
160             return pos
161 
162         y, extendlen = self._cbar._proportional_y()
163         if not self._cbar._extend_lower():
164             extendlen[0] = 0
165         if not self._cbar._extend_upper():
166             extendlen[1] = 0
167         len = sum(extendlen) + 1
168         shrink = 1 / len
169         offset = extendlen[0] / len
170         # we need to reset the aspect ratio of the axes to account
171         # of the extends...
172         if hasattr(ax, '_colorbar_info'):
173             aspect = ax._colorbar_info['aspect']
174         else:
175             aspect = False
176         # now shrink and/or offset to take into account the
177         # extend tri/rectangles.
178         if self._cbar.orientation == 'vertical':
179             if aspect:
180                 self._cbar.ax.set_box_aspect(aspect*shrink)
181             pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)
182         else:
183             if aspect:
184                 self._cbar.ax.set_box_aspect(1/(aspect * shrink))
185             pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)
186         return pos
187 
188     def get_subplotspec(self):
189         # make tight_layout happy..
190         return (
191             self._cbar.ax.get_subplotspec()
192             or getattr(self._orig_locator, "get_subplotspec", lambda: None)())
193 
194 
195 @_docstring.interpd
196 class Colorbar:
197     r"""
198     Draw a colorbar in an existing axes.
199 
200     Typically, colorbars are created using `.Figure.colorbar` or
201     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
202     `.AxesImage` generated via `~.axes.Axes.imshow`).
203 
204     In order to draw a colorbar not associated with other elements in the
205     figure, e.g. when showing a colormap by itself, one can create an empty
206     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
207     to `Colorbar`.
208 
209     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
210 
211     Attributes
212     ----------
213     ax : `~matplotlib.axes.Axes`
214         The `~.axes.Axes` instance in which the colorbar is drawn.
215     lines : list
216         A list of `.LineCollection` (empty if no lines were drawn).
217     dividers : `.LineCollection`
218         A LineCollection (empty if *drawedges* is ``False``).
219 
220     Parameters
221     ----------
222     ax : `~matplotlib.axes.Axes`
223         The `~.axes.Axes` instance in which the colorbar is drawn.
224 
225     mappable : `.ScalarMappable`
226         The mappable whose colormap and norm will be used.
227 
228         To show the under- and over- value colors, the mappable's norm should
229         be specified as ::
230 
231             norm = colors.Normalize(clip=False)
232 
233         To show the colors versus index instead of on a 0-1 scale, use::
234 
235             norm=colors.NoNorm()
236 
237     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
238         The colormap to use.  This parameter is ignored, unless *mappable* is
239         None.
240 
241     norm : `~matplotlib.colors.Normalize`
242         The normalization to use.  This parameter is ignored, unless *mappable*
243         is None.
244 
245     alpha : float
246         The colorbar transparency between 0 (transparent) and 1 (opaque).
247 
248     orientation : None or {'vertical', 'horizontal'}
249         If None, use the value determined by *location*. If both
250         *orientation* and *location* are None then defaults to 'vertical'.
251 
252     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
253         The location of the colorbar ticks. The *ticklocation* must match
254         *orientation*. For example, a horizontal colorbar can only have ticks
255         at the top or the bottom. If 'auto', the ticks will be the same as
256         *location*, so a colorbar to the left will have ticks to the left. If
257         *location* is None, the ticks will be at the bottom for a horizontal
258         colorbar and at the right for a vertical.
259 
260     drawedges : bool
261         Whether to draw lines at color boundaries.
262 
263     filled : bool
264 
265     %(_colormap_kw_doc)s
266 
267     location : None or {'left', 'right', 'top', 'bottom'}
268         Set the *orientation* and *ticklocation* of the colorbar using a
269         single argument. Colorbars on the left and right are vertical,
270         colorbars at the top and bottom are horizontal. The *ticklocation* is
271         the same as *location*, so if *location* is 'top', the ticks are on
272         the top. *orientation* and/or *ticklocation* can be provided as well
273         and overrides the value set by *location*, but there will be an error
274         for incompatible combinations.
275 
276         .. versionadded:: 3.7
277     """
278 
279     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
280 
281     @_api.delete_parameter("3.6", "filled")
282     def __init__(self, ax, mappable=None, *, cmap=None,
283                  norm=None,
284                  alpha=None,
285                  values=None,
286                  boundaries=None,
287                  orientation=None,
288                  ticklocation='auto',
289                  extend=None,
290                  spacing='uniform',  # uniform or proportional
291                  ticks=None,
292                  format=None,
293                  drawedges=False,
294                  filled=True,
295                  extendfrac=None,
296                  extendrect=False,
297                  label='',
298                  location=None,
299                  ):
300 
301         if mappable is None:
302             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
303 
304         # Ensure the given mappable's norm has appropriate vmin and vmax
305         # set even if mappable.draw has not yet been called.
306         if mappable.get_array() is not None:
307             mappable.autoscale_None()
308 
309         self.mappable = mappable
310         cmap = mappable.cmap
311         norm = mappable.norm
312 
313         if isinstance(mappable, contour.ContourSet):
314             cs = mappable
315             alpha = cs.get_alpha()
316             boundaries = cs._levels
317             values = cs.cvalues
318             extend = cs.extend
319             filled = cs.filled
320             if ticks is None:
321                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
322         elif isinstance(mappable, martist.Artist):
323             alpha = mappable.get_alpha()
324 
325         mappable.colorbar = self
326         mappable.colorbar_cid = mappable.callbacks.connect(
327             'changed', self.update_normal)
328 
329         location_orientation = _get_orientation_from_location(location)
330 
331         _api.check_in_list(
332             [None, 'vertical', 'horizontal'], orientation=orientation)
333         _api.check_in_list(
334             ['auto', 'left', 'right', 'top', 'bottom'],
335             ticklocation=ticklocation)
336         _api.check_in_list(
337             ['uniform', 'proportional'], spacing=spacing)
338 
339         if location_orientation is not None and orientation is not None:
340             if location_orientation != orientation:
341                 raise TypeError(
342                     "location and orientation are mutually exclusive")
343         else:
344             orientation = orientation or location_orientation or "vertical"
345 
346         self.ax = ax
347         self.ax._axes_locator = _ColorbarAxesLocator(self)
348 
349         if extend is None:
350             if (not isinstance(mappable, contour.ContourSet)
351                     and getattr(cmap, 'colorbar_extend', False) is not False):
352                 extend = cmap.colorbar_extend
353             elif hasattr(norm, 'extend'):
354                 extend = norm.extend
355             else:
356                 extend = 'neither'
357         self.alpha = None
358         # Call set_alpha to handle array-like alphas properly
359         self.set_alpha(alpha)
360         self.cmap = cmap
361         self.norm = norm
362         self.values = values
363         self.boundaries = boundaries
364         self.extend = extend
365         self._inside = _api.check_getitem(
366             {'neither': slice(0, None), 'both': slice(1, -1),
367              'min': slice(1, None), 'max': slice(0, -1)},
368             extend=extend)
369         self.spacing = spacing
370         self.orientation = orientation
371         self.drawedges = drawedges
372         self._filled = filled
373         self.extendfrac = extendfrac
374         self.extendrect = extendrect
375         self._extend_patches = []
376         self.solids = None
377         self.solids_patches = []
378         self.lines = []
379 
380         for spine in self.ax.spines.values():
381             spine.set_visible(False)
382         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
383 
384         self.dividers = collections.LineCollection(
385             [],
386             colors=[mpl.rcParams['axes.edgecolor']],
387             linewidths=[0.5 * mpl.rcParams['axes.linewidth']],
388             clip_on=False)
389         self.ax.add_collection(self.dividers)
390 
391         self._locator = None
392         self._minorlocator = None
393         self._formatter = None
394         self._minorformatter = None
395 
396         if ticklocation == 'auto':
397             ticklocation = _get_ticklocation_from_orientation(
398                 orientation) if location is None else location
399         self.ticklocation = ticklocation
400 
401         self.set_label(label)
402         self._reset_locator_formatter_scale()
403 
404         if np.iterable(ticks):
405             self._locator = ticker.FixedLocator(ticks, nbins=len(ticks))
406         else:
407             self._locator = ticks
408 
409         if isinstance(format, str):
410             # Check format between FormatStrFormatter and StrMethodFormatter
411             try:
412                 self._formatter = ticker.FormatStrFormatter(format)
413                 _ = self._formatter(0)
414             except TypeError:
415                 self._formatter = ticker.StrMethodFormatter(format)
416         else:
417             self._formatter = format  # Assume it is a Formatter or None
418         self._draw_all()
419 
420         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
421             self.add_lines(mappable)
422 
423         # Link the Axes and Colorbar for interactive use
424         self.ax._colorbar = self
425         # Don't navigate on any of these types of mappables
426         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
427                 isinstance(self.mappable, contour.ContourSet)):
428             self.ax.set_navigate(False)
429 
430         # These are the functions that set up interactivity on this colorbar
431         self._interactive_funcs = ["_get_view", "_set_view",
432                                    "_set_view_from_bbox", "drag_pan"]
433         for x in self._interactive_funcs:
434             setattr(self.ax, x, getattr(self, x))
435         # Set the cla function to the cbar's method to override it
436         self.ax.cla = self._cbar_cla
437         # Callbacks for the extend calculations to handle inverting the axis
438         self._extend_cid1 = self.ax.callbacks.connect(
439             "xlim_changed", self._do_extends)
440         self._extend_cid2 = self.ax.callbacks.connect(
441             "ylim_changed", self._do_extends)
442 
443     @property
444     def locator(self):
445         """Major tick `.Locator` for the colorbar."""
446         return self._long_axis().get_major_locator()
447 
448     @locator.setter
449     def locator(self, loc):
450         self._long_axis().set_major_locator(loc)
451         self._locator = loc
452 
453     @property
454     def minorlocator(self):
455         """Minor tick `.Locator` for the colorbar."""
456         return self._long_axis().get_minor_locator()
457 
458     @minorlocator.setter
459     def minorlocator(self, loc):
460         self._long_axis().set_minor_locator(loc)
461         self._minorlocator = loc
462 
463     @property
464     def formatter(self):
465         """Major tick label `.Formatter` for the colorbar."""
466         return self._long_axis().get_major_formatter()
467 
468     @formatter.setter
469     def formatter(self, fmt):
470         self._long_axis().set_major_formatter(fmt)
471         self._formatter = fmt
472 
473     @property
474     def minorformatter(self):
475         """Minor tick `.Formatter` for the colorbar."""
476         return self._long_axis().get_minor_formatter()
477 
478     @minorformatter.setter
479     def minorformatter(self, fmt):
480         self._long_axis().set_minor_formatter(fmt)
481         self._minorformatter = fmt
482 
483     def _cbar_cla(self):
484         """Function to clear the interactive colorbar state."""
485         for x in self._interactive_funcs:
486             delattr(self.ax, x)
487         # We now restore the old cla() back and can call it directly
488         del self.ax.cla
489         self.ax.cla()
490 
491     filled = _api.deprecate_privatize_attribute("3.6")
492 
493     def update_normal(self, mappable):
494         """
495         Update solid patches, lines, etc.
496 
497         This is meant to be called when the norm of the image or contour plot
498         to which this colorbar belongs changes.
499 
500         If the norm on the mappable is different than before, this resets the
501         locator and formatter for the axis, so if these have been customized,
502         they will need to be customized again.  However, if the norm only
503         changes values of *vmin*, *vmax* or *cmap* then the old formatter
504         and locator will be preserved.
505         """
506         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
507         self.mappable = mappable
508         self.set_alpha(mappable.get_alpha())
509         self.cmap = mappable.cmap
510         if mappable.norm != self.norm:
511             self.norm = mappable.norm
512             self._reset_locator_formatter_scale()
513 
514         self._draw_all()
515         if isinstance(self.mappable, contour.ContourSet):
516             CS = self.mappable
517             if not CS.filled:
518                 self.add_lines(CS)
519         self.stale = True
520 
521     @_api.deprecated("3.6", alternative="fig.draw_without_rendering()")
522     def draw_all(self):
523         """
524         Calculate any free parameters based on the current cmap and norm,
525         and do all the drawing.
526         """
527         self._draw_all()
528 
529     def _draw_all(self):
530         """
531         Calculate any free parameters based on the current cmap and norm,
532         and do all the drawing.
533         """
534         if self.orientation == 'vertical':
535             if mpl.rcParams['ytick.minor.visible']:
536                 self.minorticks_on()
537         else:
538             if mpl.rcParams['xtick.minor.visible']:
539                 self.minorticks_on()
540         self._long_axis().set(label_position=self.ticklocation,
541                               ticks_position=self.ticklocation)
542         self._short_axis().set_ticks([])
543         self._short_axis().set_ticks([], minor=True)
544 
545         # Set self._boundaries and self._values, including extensions.
546         # self._boundaries are the edges of each square of color, and
547         # self._values are the value to map into the norm to get the
548         # color:
549         self._process_values()
550         # Set self.vmin and self.vmax to first and last boundary, excluding
551         # extensions:
552         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
553         # Compute the X/Y mesh.
554         X, Y = self._mesh()
555         # draw the extend triangles, and shrink the inner axes to accommodate.
556         # also adds the outline path to self.outline spine:
557         self._do_extends()
558         lower, upper = self.vmin, self.vmax
559         if self._long_axis().get_inverted():
560             # If the axis is inverted, we need to swap the vmin/vmax
561             lower, upper = upper, lower
562         if self.orientation == 'vertical':
563             self.ax.set_xlim(0, 1)
564             self.ax.set_ylim(lower, upper)
565         else:
566             self.ax.set_ylim(0, 1)
567             self.ax.set_xlim(lower, upper)
568 
569         # set up the tick locators and formatters.  A bit complicated because
570         # boundary norms + uniform spacing requires a manual locator.
571         self.update_ticks()
572 
573         if self._filled:
574             ind = np.arange(len(self._values))
575             if self._extend_lower():
576                 ind = ind[1:]
577             if self._extend_upper():
578                 ind = ind[:-1]
579             self._add_solids(X, Y, self._values[ind, np.newaxis])
580 
581     def _add_solids(self, X, Y, C):
582         """Draw the colors; optionally add separators."""
583         # Cleanup previously set artists.
584         if self.solids is not None:
585             self.solids.remove()
586         for solid in self.solids_patches:
587             solid.remove()
588         # Add new artist(s), based on mappable type.  Use individual patches if
589         # hatching is needed, pcolormesh otherwise.
590         mappable = getattr(self, 'mappable', None)
591         if (isinstance(mappable, contour.ContourSet)
592                 and any(hatch is not None for hatch in mappable.hatches)):
593             self._add_solids_patches(X, Y, C, mappable)
594         else:
595             self.solids = self.ax.pcolormesh(
596                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
597                 edgecolors='none', shading='flat')
598             if not self.drawedges:
599                 if len(self._y) >= self.n_rasterize:
600                     self.solids.set_rasterized(True)
601         self._update_dividers()
602 
603     def _update_dividers(self):
604         if not self.drawedges:
605             self.dividers.set_segments([])
606             return
607         # Place all *internal* dividers.
608         if self.orientation == 'vertical':
609             lims = self.ax.get_ylim()
610             bounds = (lims[0] < self._y) & (self._y < lims[1])
611         else:
612             lims = self.ax.get_xlim()
613             bounds = (lims[0] < self._y) & (self._y < lims[1])
614         y = self._y[bounds]
615         # And then add outer dividers if extensions are on.
616         if self._extend_lower():
617             y = np.insert(y, 0, lims[0])
618         if self._extend_upper():
619             y = np.append(y, lims[1])
620         X, Y = np.meshgrid([0, 1], y)
621         if self.orientation == 'vertical':
622             segments = np.dstack([X, Y])
623         else:
624             segments = np.dstack([Y, X])
625         self.dividers.set_segments(segments)
626 
627     def _add_solids_patches(self, X, Y, C, mappable):
628         hatches = mappable.hatches * (len(C) + 1)  # Have enough hatches.
629         if self._extend_lower():
630             # remove first hatch that goes into the extend patch
631             hatches = hatches[1:]
632         patches = []
633         for i in range(len(X) - 1):
634             xy = np.array([[X[i, 0], Y[i, 1]],
635                            [X[i, 1], Y[i, 0]],
636                            [X[i + 1, 1], Y[i + 1, 0]],
637                            [X[i + 1, 0], Y[i + 1, 1]]])
638             patch = mpatches.PathPatch(mpath.Path(xy),
639                                        facecolor=self.cmap(self.norm(C[i][0])),
640                                        hatch=hatches[i], linewidth=0,
641                                        antialiased=False, alpha=self.alpha)
642             self.ax.add_patch(patch)
643             patches.append(patch)
644         self.solids_patches = patches
645 
646     def _do_extends(self, ax=None):
647         """
648         Add the extend tri/rectangles on the outside of the axes.
649 
650         ax is unused, but required due to the callbacks on xlim/ylim changed
651         """
652         # Clean up any previous extend patches
653         for patch in self._extend_patches:
654             patch.remove()
655         self._extend_patches = []
656         # extend lengths are fraction of the *inner* part of colorbar,
657         # not the total colorbar:
658         _, extendlen = self._proportional_y()
659         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
660         top = 1 + (extendlen[1] if self._extend_upper() else 0)
661 
662         # xyout is the outline of the colorbar including the extend patches:
663         if not self.extendrect:
664             # triangle:
665             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
666                               [1, 1], [0.5, top], [0, 1], [0, 0]])
667         else:
668             # rectangle:
669             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
670                               [1, 1], [1, top], [0, top], [0, 1],
671                               [0, 0]])
672 
673         if self.orientation == 'horizontal':
674             xyout = xyout[:, ::-1]
675 
676         # xyout is the path for the spine:
677         self.outline.set_xy(xyout)
678         if not self._filled:
679             return
680 
681         # Make extend triangles or rectangles filled patches.  These are
682         # defined in the outer parent axes' coordinates:
683         mappable = getattr(self, 'mappable', None)
684         if (isinstance(mappable, contour.ContourSet)
685                 and any(hatch is not None for hatch in mappable.hatches)):
686             hatches = mappable.hatches * (len(self._y) + 1)
687         else:
688             hatches = [None] * (len(self._y) + 1)
689 
690         if self._extend_lower():
691             if not self.extendrect:
692                 # triangle
693                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
694             else:
695                 # rectangle
696                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
697             if self.orientation == 'horizontal':
698                 xy = xy[:, ::-1]
699             # add the patch
700             val = -1 if self._long_axis().get_inverted() else 0
701             color = self.cmap(self.norm(self._values[val]))
702             patch = mpatches.PathPatch(
703                 mpath.Path(xy), facecolor=color, alpha=self.alpha,
704                 linewidth=0, antialiased=False,
705                 transform=self.ax.transAxes,
706                 hatch=hatches[0], clip_on=False,
707                 # Place it right behind the standard patches, which is
708                 # needed if we updated the extends
709                 zorder=np.nextafter(self.ax.patch.zorder, -np.inf))
710             self.ax.add_patch(patch)
711             self._extend_patches.append(patch)
712             # remove first hatch that goes into the extend patch
713             hatches = hatches[1:]
714         if self._extend_upper():
715             if not self.extendrect:
716                 # triangle
717                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
718             else:
719                 # rectangle
720                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
721             if self.orientation == 'horizontal':
722                 xy = xy[:, ::-1]
723             # add the patch
724             val = 0 if self._long_axis().get_inverted() else -1
725             color = self.cmap(self.norm(self._values[val]))
726             hatch_idx = len(self._y) - 1
727             patch = mpatches.PathPatch(
728                 mpath.Path(xy), facecolor=color, alpha=self.alpha,
729                 linewidth=0, antialiased=False,
730                 transform=self.ax.transAxes, hatch=hatches[hatch_idx],
731                 clip_on=False,
732                 # Place it right behind the standard patches, which is
733                 # needed if we updated the extends
734                 zorder=np.nextafter(self.ax.patch.zorder, -np.inf))
735             self.ax.add_patch(patch)
736             self._extend_patches.append(patch)
737 
738         self._update_dividers()
739 
740     def add_lines(self, *args, **kwargs):
741         """
742         Draw lines on the colorbar.
743 
744         The lines are appended to the list :attr:`lines`.
745 
746         Parameters
747         ----------
748         levels : array-like
749             The positions of the lines.
750         colors : color or list of colors
751             Either a single color applying to all lines or one color value for
752             each line.
753         linewidths : float or array-like
754             Either a single linewidth applying to all lines or one linewidth
755             for each line.
756         erase : bool, default: True
757             Whether to remove any previously added lines.
758 
759         Notes
760         -----
761         Alternatively, this method can also be called with the signature
762         ``colorbar.add_lines(contour_set, erase=True)``, in which case
763         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
764         """
765         params = _api.select_matching_signature(
766             [lambda self, CS, erase=True: locals(),
767              lambda self, levels, colors, linewidths, erase=True: locals()],
768             self, *args, **kwargs)
769         if "CS" in params:
770             self, CS, erase = params.values()
771             if not isinstance(CS, contour.ContourSet) or CS.filled:
772                 raise ValueError("If a single artist is passed to add_lines, "
773                                  "it must be a ContourSet of lines")
774             # TODO: Make colorbar lines auto-follow changes in contour lines.
775             return self.add_lines(
776                 CS.levels,
777                 [c[0] for c in CS.tcolors],
778                 [t[0] for t in CS.tlinewidths],
779                 erase=erase)
780         else:
781             self, levels, colors, linewidths, erase = params.values()
782 
783         y = self._locate(levels)
784         rtol = (self._y[-1] - self._y[0]) * 1e-10
785         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
786         y = y[igood]
787         if np.iterable(colors):
788             colors = np.asarray(colors)[igood]
789         if np.iterable(linewidths):
790             linewidths = np.asarray(linewidths)[igood]
791         X, Y = np.meshgrid([0, 1], y)
792         if self.orientation == 'vertical':
793             xy = np.stack([X, Y], axis=-1)
794         else:
795             xy = np.stack([Y, X], axis=-1)
796         col = collections.LineCollection(xy, linewidths=linewidths,
797                                          colors=colors)
798 
799         if erase and self.lines:
800             for lc in self.lines:
801                 lc.remove()
802             self.lines = []
803         self.lines.append(col)
804 
805         # make a clip path that is just a linewidth bigger than the axes...
806         fac = np.max(linewidths) / 72
807         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
808         inches = self.ax.get_figure().dpi_scale_trans
809         # do in inches:
810         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
811         xy[[0, 1, 4], 1] -= fac
812         xy[[2, 3], 1] += fac
813         # back to axes units...
814         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
815         col.set_clip_path(mpath.Path(xy, closed=True),
816                           self.ax.transAxes)
817         self.ax.add_collection(col)
818         self.stale = True
819 
820     def update_ticks(self):
821         """
822         Set up the ticks and ticklabels. This should not be needed by users.
823         """
824         # Get the locator and formatter; defaults to self._locator if not None.
825         self._get_ticker_locator_formatter()
826         self._long_axis().set_major_locator(self._locator)
827         self._long_axis().set_minor_locator(self._minorlocator)
828         self._long_axis().set_major_formatter(self._formatter)
829 
830     def _get_ticker_locator_formatter(self):
831         """
832         Return the ``locator`` and ``formatter`` of the colorbar.
833 
834         If they have not been defined (i.e. are *None*), the formatter and
835         locator are retrieved from the axis, or from the value of the
836         boundaries for a boundary norm.
837 
838         Called by update_ticks...
839         """
840         locator = self._locator
841         formatter = self._formatter
842         minorlocator = self._minorlocator
843         if isinstance(self.norm, colors.BoundaryNorm):
844             b = self.norm.boundaries
845             if locator is None:
846                 locator = ticker.FixedLocator(b, nbins=10)
847             if minorlocator is None:
848                 minorlocator = ticker.FixedLocator(b)
849         elif isinstance(self.norm, colors.NoNorm):
850             if locator is None:
851                 # put ticks on integers between the boundaries of NoNorm
852                 nv = len(self._values)
853                 base = 1 + int(nv / 10)
854                 locator = ticker.IndexLocator(base=base, offset=.5)
855         elif self.boundaries is not None:
856             b = self._boundaries[self._inside]
857             if locator is None:
858                 locator = ticker.FixedLocator(b, nbins=10)
859         else:  # most cases:
860             if locator is None:
861                 # we haven't set the locator explicitly, so use the default
862                 # for this axis:
863                 locator = self._long_axis().get_major_locator()
864             if minorlocator is None:
865                 minorlocator = self._long_axis().get_minor_locator()
866 
867         if minorlocator is None:
868             minorlocator = ticker.NullLocator()
869 
870         if formatter is None:
871             formatter = self._long_axis().get_major_formatter()
872 
873         self._locator = locator
874         self._formatter = formatter
875         self._minorlocator = minorlocator
876         _log.debug('locator: %r', locator)
877 
878     def set_ticks(self, ticks, *, labels=None, minor=False, **kwargs):
879         """
880         Set tick locations.
881 
882         Parameters
883         ----------
884         ticks : list of floats
885             List of tick locations.
886         labels : list of str, optional
887             List of tick labels. If not set, the labels show the data value.
888         minor : bool, default: False
889             If ``False``, set the major ticks; if ``True``, the minor ticks.
890         **kwargs
891             `.Text` properties for the labels. These take effect only if you
892             pass *labels*. In other cases, please use `~.Axes.tick_params`.
893         """
894         if np.iterable(ticks):
895             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
896                                         **kwargs)
897             self._locator = self._long_axis().get_major_locator()
898         else:
899             self._locator = ticks
900             self._long_axis().set_major_locator(self._locator)
901         self.stale = True
902 
903     def get_ticks(self, minor=False):
904         """
905         Return the ticks as a list of locations.
906 
907         Parameters
908         ----------
909         minor : boolean, default: False
910             if True return the minor ticks.
911         """
912         if minor:
913             return self._long_axis().get_minorticklocs()
914         else:
915             return self._long_axis().get_majorticklocs()
916 
917     def set_ticklabels(self, ticklabels, *, minor=False, **kwargs):
918         """
919         [*Discouraged*] Set tick labels.
920 
921         .. admonition:: Discouraged
922 
923             The use of this method is discouraged, because of the dependency
924             on tick positions. In most cases, you'll want to use
925             ``set_ticks(positions, labels=labels)`` instead.
926 
927             If you are using this method, you should always fix the tick
928             positions before, e.g. by using `.Colorbar.set_ticks` or by
929             explicitly setting a `~.ticker.FixedLocator` on the long axis
930             of the colorbar. Otherwise, ticks are free to move and the
931             labels may end up in unexpected positions.
932 
933         Parameters
934         ----------
935         ticklabels : sequence of str or of `.Text`
936             Texts for labeling each tick location in the sequence set by
937             `.Colorbar.set_ticks`; the number of labels must match the number
938             of locations.
939 
940         update_ticks : bool, default: True
941             This keyword argument is ignored and will be removed.
942             Deprecated
943 
944          minor : bool
945             If True, set minor ticks instead of major ticks.
946 
947         **kwargs
948             `.Text` properties for the labels.
949         """
950         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
951 
952     def minorticks_on(self):
953         """
954         Turn on colorbar minor ticks.
955         """
956         self.ax.minorticks_on()
957         self._short_axis().set_minor_locator(ticker.NullLocator())
958 
959     def minorticks_off(self):
960         """Turn the minor ticks of the colorbar off."""
961         self._minorlocator = ticker.NullLocator()
962         self._long_axis().set_minor_locator(self._minorlocator)
963 
964     def set_label(self, label, *, loc=None, **kwargs):
965         """
966         Add a label to the long axis of the colorbar.
967 
968         Parameters
969         ----------
970         label : str
971             The label text.
972         loc : str, optional
973             The location of the label.
974 
975             - For horizontal orientation one of {'left', 'center', 'right'}
976             - For vertical orientation one of {'bottom', 'center', 'top'}
977 
978             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
979             depending on the orientation.
980         **kwargs
981             Keyword arguments are passed to `~.Axes.set_xlabel` /
982             `~.Axes.set_ylabel`.
983             Supported keywords are *labelpad* and `.Text` properties.
984         """
985         if self.orientation == "vertical":
986             self.ax.set_ylabel(label, loc=loc, **kwargs)
987         else:
988             self.ax.set_xlabel(label, loc=loc, **kwargs)
989         self.stale = True
990 
991     def set_alpha(self, alpha):
992         """
993         Set the transparency between 0 (transparent) and 1 (opaque).
994 
995         If an array is provided, *alpha* will be set to None to use the
996         transparency values associated with the colormap.
997         """
998         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
999 
1000     def _set_scale(self, scale, **kwargs):
1001         """
1002         Set the colorbar long axis scale.
1003 
1004         Parameters
1005         ----------
1006         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
1007             The axis scale type to apply.
1008 
1009         **kwargs
1010             Different keyword arguments are accepted, depending on the scale.
1011             See the respective class keyword arguments:
1012 
1013             - `matplotlib.scale.LinearScale`
1014             - `matplotlib.scale.LogScale`
1015             - `matplotlib.scale.SymmetricalLogScale`
1016             - `matplotlib.scale.LogitScale`
1017             - `matplotlib.scale.FuncScale`
1018 
1019         Notes
1020         -----
1021         By default, Matplotlib supports the above-mentioned scales.
1022         Additionally, custom scales may be registered using
1023         `matplotlib.scale.register_scale`. These scales can then also
1024         be used here.
1025         """
1026         self._long_axis()._set_axes_scale(scale, **kwargs)
1027 
1028     def remove(self):
1029         """
1030         Remove this colorbar from the figure.
1031 
1032         If the colorbar was created with ``use_gridspec=True`` the previous
1033         gridspec is restored.
1034         """
1035         if hasattr(self.ax, '_colorbar_info'):
1036             parents = self.ax._colorbar_info['parents']
1037             for a in parents:
1038                 if self.ax in a._colorbars:
1039                     a._colorbars.remove(self.ax)
1040 
1041         self.ax.remove()
1042 
1043         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1044         self.mappable.colorbar = None
1045         self.mappable.colorbar_cid = None
1046         # Remove the extension callbacks
1047         self.ax.callbacks.disconnect(self._extend_cid1)
1048         self.ax.callbacks.disconnect(self._extend_cid2)
1049 
1050         try:
1051             ax = self.mappable.axes
1052         except AttributeError:
1053             return
1054         try:
1055             gs = ax.get_subplotspec().get_gridspec()
1056             subplotspec = gs.get_topmost_subplotspec()
1057         except AttributeError:
1058             # use_gridspec was False
1059             pos = ax.get_position(original=True)
1060             ax._set_position(pos)
1061         else:
1062             # use_gridspec was True
1063             ax.set_subplotspec(subplotspec)
1064 
1065     def _process_values(self):
1066         """
1067         Set `_boundaries` and `_values` based on the self.boundaries and
1068         self.values if not None, or based on the size of the colormap and
1069         the vmin/vmax of the norm.
1070         """
1071         if self.values is not None:
1072             # set self._boundaries from the values...
1073             self._values = np.array(self.values)
1074             if self.boundaries is None:
1075                 # bracket values by 1/2 dv:
1076                 b = np.zeros(len(self.values) + 1)
1077                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1078                 b[0] = 2.0 * b[1] - b[2]
1079                 b[-1] = 2.0 * b[-2] - b[-3]
1080                 self._boundaries = b
1081                 return
1082             self._boundaries = np.array(self.boundaries)
1083             return
1084 
1085         # otherwise values are set from the boundaries
1086         if isinstance(self.norm, colors.BoundaryNorm):
1087             b = self.norm.boundaries
1088         elif isinstance(self.norm, colors.NoNorm):
1089             # NoNorm has N blocks, so N+1 boundaries, centered on integers:
1090             b = np.arange(self.cmap.N + 1) - .5
1091         elif self.boundaries is not None:
1092             b = self.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if (not isinstance(self.norm, colors.BoundaryNorm) and
1110                 (self.boundaries is None)):
1111             b = self.norm.inverse(b)
1112 
1113         self._boundaries = np.asarray(b, dtype=float)
1114         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1115         if isinstance(self.norm, colors.NoNorm):
1116             self._values = (self._values + 0.00001).astype(np.int16)
1117 
1118     def _mesh(self):
1119         """
1120         Return the coordinate arrays for the colorbar pcolormesh/patches.
1121 
1122         These are scaled between vmin and vmax, and already handle colorbar
1123         orientation.
1124         """
1125         y, _ = self._proportional_y()
1126         # Use the vmin and vmax of the colorbar, which may not be the same
1127         # as the norm. There are situations where the colormap has a
1128         # narrower range than the colorbar and we want to accommodate the
1129         # extra contours.
1130         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm))
1131                 or self.boundaries is not None):
1132             # not using a norm.
1133             y = y * (self.vmax - self.vmin) + self.vmin
1134         else:
1135             # Update the norm values in a context manager as it is only
1136             # a temporary change and we don't want to propagate any signals
1137             # attached to the norm (callbacks.blocked).
1138             with self.norm.callbacks.blocked(), \
1139                     cbook._setattr_cm(self.norm,
1140                                       vmin=self.vmin,
1141                                       vmax=self.vmax):
1142                 y = self.norm.inverse(y)
1143         self._y = y
1144         X, Y = np.meshgrid([0., 1.], y)
1145         if self.orientation == 'vertical':
1146             return (X, Y)
1147         else:
1148             return (Y, X)
1149 
1150     def _forward_boundaries(self, x):
1151         # map boundaries equally between 0 and 1...
1152         b = self._boundaries
1153         y = np.interp(x, b, np.linspace(0, 1, len(b)))
1154         # the following avoids ticks in the extends:
1155         eps = (b[-1] - b[0]) * 1e-6
1156         # map these _well_ out of bounds to keep any ticks out
1157         # of the extends region...
1158         y[x < b[0]-eps] = -1
1159         y[x > b[-1]+eps] = 2
1160         return y
1161 
1162     def _inverse_boundaries(self, x):
1163         # invert the above...
1164         b = self._boundaries
1165         return np.interp(x, np.linspace(0, 1, len(b)), b)
1166 
1167     def _reset_locator_formatter_scale(self):
1168         """
1169         Reset the locator et al to defaults.  Any user-hardcoded changes
1170         need to be re-entered if this gets called (either at init, or when
1171         the mappable normal gets changed: Colorbar.update_normal)
1172         """
1173         self._process_values()
1174         self._locator = None
1175         self._minorlocator = None
1176         self._formatter = None
1177         self._minorformatter = None
1178         if (isinstance(self.mappable, contour.ContourSet) and
1179                 isinstance(self.norm, colors.LogNorm)):
1180             # if contours have lognorm, give them a log scale...
1181             self._set_scale('log')
1182         elif (self.boundaries is not None or
1183                 isinstance(self.norm, colors.BoundaryNorm)):
1184             if self.spacing == 'uniform':
1185                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1186                 self._set_scale('function', functions=funcs)
1187             elif self.spacing == 'proportional':
1188                 self._set_scale('linear')
1189         elif getattr(self.norm, '_scale', None):
1190             # use the norm's scale (if it exists and is not None):
1191             self._set_scale(self.norm._scale)
1192         elif type(self.norm) is colors.Normalize:
1193             # plain Normalize:
1194             self._set_scale('linear')
1195         else:
1196             # norm._scale is None or not an attr: derive the scale from
1197             # the Norm:
1198             funcs = (self.norm, self.norm.inverse)
1199             self._set_scale('function', functions=funcs)
1200 
1201     def _locate(self, x):
1202         """
1203         Given a set of color data values, return their
1204         corresponding colorbar data coordinates.
1205         """
1206         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1207             b = self._boundaries
1208             xn = x
1209         else:
1210             # Do calculations using normalized coordinates so
1211             # as to make the interpolation more accurate.
1212             b = self.norm(self._boundaries, clip=False).filled()
1213             xn = self.norm(x, clip=False).filled()
1214 
1215         bunique = b[self._inside]
1216         yunique = self._y
1217 
1218         z = np.interp(xn, bunique, yunique)
1219         return z
1220 
1221     # trivial helpers
1222 
1223     def _uniform_y(self, N):
1224         """
1225         Return colorbar data coordinates for *N* uniformly
1226         spaced boundaries, plus extension lengths if required.
1227         """
1228         automin = automax = 1. / (N - 1.)
1229         extendlength = self._get_extension_lengths(self.extendfrac,
1230                                                    automin, automax,
1231                                                    default=0.05)
1232         y = np.linspace(0, 1, N)
1233         return y, extendlength
1234 
1235     def _proportional_y(self):
1236         """
1237         Return colorbar data coordinates for the boundaries of
1238         a proportional colorbar, plus extension lengths if required:
1239         """
1240         if (isinstance(self.norm, colors.BoundaryNorm) or
1241                 self.boundaries is not None):
1242             y = (self._boundaries - self._boundaries[self._inside][0])
1243             y = y / (self._boundaries[self._inside][-1] -
1244                      self._boundaries[self._inside][0])
1245             # need yscaled the same as the axes scale to get
1246             # the extend lengths.
1247             if self.spacing == 'uniform':
1248                 yscaled = self._forward_boundaries(self._boundaries)
1249             else:
1250                 yscaled = y
1251         else:
1252             y = self.norm(self._boundaries.copy())
1253             y = np.ma.filled(y, np.nan)
1254             # the norm and the scale should be the same...
1255             yscaled = y
1256         y = y[self._inside]
1257         yscaled = yscaled[self._inside]
1258         # normalize from 0..1:
1259         norm = colors.Normalize(y[0], y[-1])
1260         y = np.ma.filled(norm(y), np.nan)
1261         norm = colors.Normalize(yscaled[0], yscaled[-1])
1262         yscaled = np.ma.filled(norm(yscaled), np.nan)
1263         # make the lower and upper extend lengths proportional to the lengths
1264         # of the first and last boundary spacing (if extendfrac='auto'):
1265         automin = yscaled[1] - yscaled[0]
1266         automax = yscaled[-1] - yscaled[-2]
1267         extendlength = [0, 0]
1268         if self._extend_lower() or self._extend_upper():
1269             extendlength = self._get_extension_lengths(
1270                     self.extendfrac, automin, automax, default=0.05)
1271         return y, extendlength
1272 
1273     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1274         """
1275         Return the lengths of colorbar extensions.
1276 
1277         This is a helper method for _uniform_y and _proportional_y.
1278         """
1279         # Set the default value.
1280         extendlength = np.array([default, default])
1281         if isinstance(frac, str):
1282             _api.check_in_list(['auto'], extendfrac=frac.lower())
1283             # Use the provided values when 'auto' is required.
1284             extendlength[:] = [automin, automax]
1285         elif frac is not None:
1286             try:
1287                 # Try to set min and max extension fractions directly.
1288                 extendlength[:] = frac
1289                 # If frac is a sequence containing None then NaN may
1290                 # be encountered. This is an error.
1291                 if np.isnan(extendlength).any():
1292                     raise ValueError()
1293             except (TypeError, ValueError) as err:
1294                 # Raise an error on encountering an invalid value for frac.
1295                 raise ValueError('invalid value for extendfrac') from err
1296         return extendlength
1297 
1298     def _extend_lower(self):
1299         """Return whether the lower limit is open ended."""
1300         minmax = "max" if self._long_axis().get_inverted() else "min"
1301         return self.extend in ('both', minmax)
1302 
1303     def _extend_upper(self):
1304         """Return whether the upper limit is open ended."""
1305         minmax = "min" if self._long_axis().get_inverted() else "max"
1306         return self.extend in ('both', minmax)
1307 
1308     def _long_axis(self):
1309         """Return the long axis"""
1310         if self.orientation == 'vertical':
1311             return self.ax.yaxis
1312         return self.ax.xaxis
1313 
1314     def _short_axis(self):
1315         """Return the short axis"""
1316         if self.orientation == 'vertical':
1317             return self.ax.xaxis
1318         return self.ax.yaxis
1319 
1320     def _get_view(self):
1321         # docstring inherited
1322         # An interactive view for a colorbar is the norm's vmin/vmax
1323         return self.norm.vmin, self.norm.vmax
1324 
1325     def _set_view(self, view):
1326         # docstring inherited
1327         # An interactive view for a colorbar is the norm's vmin/vmax
1328         self.norm.vmin, self.norm.vmax = view
1329 
1330     def _set_view_from_bbox(self, bbox, direction='in',
1331                             mode=None, twinx=False, twiny=False):
1332         # docstring inherited
1333         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1334         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1335             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1336         if self.orientation == 'horizontal':
1337             self.norm.vmin, self.norm.vmax = new_xbound
1338         elif self.orientation == 'vertical':
1339             self.norm.vmin, self.norm.vmax = new_ybound
1340 
1341     def drag_pan(self, button, key, x, y):
1342         # docstring inherited
1343         points = self.ax._get_pan_points(button, key, x, y)
1344         if points is not None:
1345             if self.orientation == 'horizontal':
1346                 self.norm.vmin, self.norm.vmax = points[:, 0]
1347             elif self.orientation == 'vertical':
1348                 self.norm.vmin, self.norm.vmax = points[:, 1]
1349 
1350 
1351 ColorbarBase = Colorbar  # Backcompat API
1352 
1353 
1354 def _normalize_location_orientation(location, orientation):
1355     if location is None:
1356         location = _get_ticklocation_from_orientation(orientation)
1357     loc_settings = _api.check_getitem({
1358         "left":   {"location": "left", "anchor": (1.0, 0.5),
1359                    "panchor": (0.0, 0.5), "pad": 0.10},
1360         "right":  {"location": "right", "anchor": (0.0, 0.5),
1361                    "panchor": (1.0, 0.5), "pad": 0.05},
1362         "top":    {"location": "top", "anchor": (0.5, 0.0),
1363                    "panchor": (0.5, 1.0), "pad": 0.05},
1364         "bottom": {"location": "bottom", "anchor": (0.5, 1.0),
1365                    "panchor": (0.5, 0.0), "pad": 0.15},
1366     }, location=location)
1367     loc_settings["orientation"] = _get_orientation_from_location(location)
1368     if orientation is not None and orientation != loc_settings["orientation"]:
1369         # Allow the user to pass both if they are consistent.
1370         raise TypeError("location and orientation are mutually exclusive")
1371     return loc_settings
1372 
1373 
1374 def _get_orientation_from_location(location):
1375     return _api.check_getitem(
1376         {None: None, "left": "vertical", "right": "vertical",
1377          "top": "horizontal", "bottom": "horizontal"}, location=location)
1378 
1379 
1380 def _get_ticklocation_from_orientation(orientation):
1381     return _api.check_getitem(
1382         {None: "right", "vertical": "right", "horizontal": "bottom"},
1383         orientation=orientation)
1384 
1385 
1386 @_docstring.interpd
1387 def make_axes(parents, location=None, orientation=None, fraction=0.15,
1388               shrink=1.0, aspect=20, **kwargs):
1389     """
1390     Create an `~.axes.Axes` suitable for a colorbar.
1391 
1392     The axes is placed in the figure of the *parents* axes, by resizing and
1393     repositioning *parents*.
1394 
1395     Parameters
1396     ----------
1397     parents : `~.axes.Axes` or iterable or `numpy.ndarray` of `~.axes.Axes`
1398         The Axes to use as parents for placing the colorbar.
1399     %(_make_axes_kw_doc)s
1400 
1401     Returns
1402     -------
1403     cax : `~.axes.Axes`
1404         The child axes.
1405     kwargs : dict
1406         The reduced keyword dictionary to be passed when creating the colorbar
1407         instance.
1408     """
1409     loc_settings = _normalize_location_orientation(location, orientation)
1410     # put appropriate values into the kwargs dict for passing back to
1411     # the Colorbar class
1412     kwargs['orientation'] = loc_settings['orientation']
1413     location = kwargs['ticklocation'] = loc_settings['location']
1414 
1415     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1416     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1417     aspect0 = aspect
1418     # turn parents into a list if it is not already.  Note we cannot
1419     # use .flatten or .ravel as these copy the references rather than
1420     # reuse them, leading to a memory leak
1421     if isinstance(parents, np.ndarray):
1422         parents = list(parents.flat)
1423     elif np.iterable(parents):
1424         parents = list(parents)
1425     else:
1426         parents = [parents]
1427 
1428     fig = parents[0].get_figure()
1429 
1430     pad0 = 0.05 if fig.get_constrained_layout() else loc_settings['pad']
1431     pad = kwargs.pop('pad', pad0)
1432 
1433     if not all(fig is ax.get_figure() for ax in parents):
1434         raise ValueError('Unable to create a colorbar axes as not all '
1435                          'parents share the same figure.')
1436 
1437     # take a bounding box around all of the given axes
1438     parents_bbox = mtransforms.Bbox.union(
1439         [ax.get_position(original=True).frozen() for ax in parents])
1440 
1441     pb = parents_bbox
1442     if location in ('left', 'right'):
1443         if location == 'left':
1444             pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)
1445         else:
1446             pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)
1447         pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)
1448     else:
1449         if location == 'bottom':
1450             pbcb, _, pb1 = pb.splity(fraction, fraction + pad)
1451         else:
1452             pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)
1453         pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)
1454 
1455         # define the aspect ratio in terms of y's per x rather than x's per y
1456         aspect = 1.0 / aspect
1457 
1458     # define a transform which takes us from old axes coordinates to
1459     # new axes coordinates
1460     shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)
1461 
1462     # transform each of the axes in parents using the new transform
1463     for ax in parents:
1464         new_posn = shrinking_trans.transform(ax.get_position(original=True))
1465         new_posn = mtransforms.Bbox(new_posn)
1466         ax._set_position(new_posn)
1467         if panchor is not False:
1468             ax.set_anchor(panchor)
1469 
1470     cax = fig.add_axes(pbcb, label="<colorbar>")
1471     for a in parents:
1472         # tell the parent it has a colorbar
1473         a._colorbars += [cax]
1474     cax._colorbar_info = dict(
1475         parents=parents,
1476         location=location,
1477         shrink=shrink,
1478         anchor=anchor,
1479         panchor=panchor,
1480         fraction=fraction,
1481         aspect=aspect0,
1482         pad=pad)
1483     # and we need to set the aspect ratio by hand...
1484     cax.set_anchor(anchor)
1485     cax.set_box_aspect(aspect)
1486     cax.set_aspect('auto')
1487 
1488     return cax, kwargs
1489 
1490 
1491 @_docstring.interpd
1492 def make_axes_gridspec(parent, *, location=None, orientation=None,
1493                        fraction=0.15, shrink=1.0, aspect=20, **kwargs):
1494     """
1495     Create an `~.axes.Axes` suitable for a colorbar.
1496 
1497     The axes is placed in the figure of the *parent* axes, by resizing and
1498     repositioning *parent*.
1499 
1500     This function is similar to `.make_axes` and mostly compatible with it.
1501     Primary differences are
1502 
1503     - `.make_axes_gridspec` requires the *parent* to have a subplotspec.
1504     - `.make_axes` positions the axes in figure coordinates;
1505       `.make_axes_gridspec` positions it using a subplotspec.
1506     - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`
1507       replaces the parent gridspec with a new one.
1508 
1509     Parameters
1510     ----------
1511     parent : `~.axes.Axes`
1512         The Axes to use as parent for placing the colorbar.
1513     %(_make_axes_kw_doc)s
1514 
1515     Returns
1516     -------
1517     cax : `~.axes.Axes`
1518         The child axes.
1519     kwargs : dict
1520         The reduced keyword dictionary to be passed when creating the colorbar
1521         instance.
1522     """
1523 
1524     loc_settings = _normalize_location_orientation(location, orientation)
1525     kwargs['orientation'] = loc_settings['orientation']
1526     location = kwargs['ticklocation'] = loc_settings['location']
1527 
1528     aspect0 = aspect
1529     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1530     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1531     pad = kwargs.pop('pad', loc_settings["pad"])
1532     wh_space = 2 * pad / (1 - pad)
1533 
1534     if location in ('left', 'right'):
1535         # for shrinking
1536         height_ratios = [
1537                 (1-anchor[1])*(1-shrink), shrink, anchor[1]*(1-shrink)]
1538 
1539         if location == 'left':
1540             gs = parent.get_subplotspec().subgridspec(
1541                     1, 2, wspace=wh_space,
1542                     width_ratios=[fraction, 1-fraction-pad])
1543             ss_main = gs[1]
1544             ss_cb = gs[0].subgridspec(
1545                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1546         else:
1547             gs = parent.get_subplotspec().subgridspec(
1548                     1, 2, wspace=wh_space,
1549                     width_ratios=[1-fraction-pad, fraction])
1550             ss_main = gs[0]
1551             ss_cb = gs[1].subgridspec(
1552                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1553     else:
1554         # for shrinking
1555         width_ratios = [
1556                 anchor[0]*(1-shrink), shrink, (1-anchor[0])*(1-shrink)]
1557 
1558         if location == 'bottom':
1559             gs = parent.get_subplotspec().subgridspec(
1560                     2, 1, hspace=wh_space,
1561                     height_ratios=[1-fraction-pad, fraction])
1562             ss_main = gs[0]
1563             ss_cb = gs[1].subgridspec(
1564                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1565             aspect = 1 / aspect
1566         else:
1567             gs = parent.get_subplotspec().subgridspec(
1568                     2, 1, hspace=wh_space,
1569                     height_ratios=[fraction, 1-fraction-pad])
1570             ss_main = gs[1]
1571             ss_cb = gs[0].subgridspec(
1572                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1573             aspect = 1 / aspect
1574 
1575     parent.set_subplotspec(ss_main)
1576     if panchor is not False:
1577         parent.set_anchor(panchor)
1578 
1579     fig = parent.get_figure()
1580     cax = fig.add_subplot(ss_cb, label="<colorbar>")
1581     cax.set_anchor(anchor)
1582     cax.set_box_aspect(aspect)
1583     cax.set_aspect('auto')
1584     cax._colorbar_info = dict(
1585         location=location,
1586         parents=[parent],
1587         shrink=shrink,
1588         anchor=anchor,
1589         panchor=panchor,
1590         fraction=fraction,
1591         aspect=aspect0,
1592         pad=pad)
1593 
1594     return cax, kwargs

</code><intended_behavior>When `vmin` and `vmax` are modified, particularly in an interactive setting, the colorbar update mechanism should detect these changes and redraw the colorbar to reflect the new range according to the newly set normalization method. This process should handle logarithmic scaling gracefully, ensuring that the colorbar accurately represents the updated data range.</intended_behavior>]
2025-10-18 02:55:07.578 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 02:55:07.578 | INFO     | Search-only: skipping patch selection
2025-10-18 02:55:07.742 | INFO     | Task matplotlib__matplotlib-25079 completed successfully.
2025-10-18 02:55:07.743 | INFO     | No patch generated. You can try running ACR again.
