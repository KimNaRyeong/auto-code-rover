[
    {
        "rel_file_path": "lib/matplotlib/colors.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.6/lib/matplotlib/colors.py",
        "start": 1,
        "end": 2659,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 A module for converting numbers or color arguments to *RGB* or *RGBA*.\n3 \n4 *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\n5 range 0-1.\n6 \n7 This module includes functions and classes for color specification conversions,\n8 and for mapping numbers to colors in a 1-D array of colors called a colormap.\n9 \n10 Mapping data onto colors using a colormap typically involves two steps: a data\n11 array is first mapped onto the range 0-1 using a subclass of `Normalize`,\n12 then this number is mapped to a color using a subclass of `Colormap`.  Two\n13 subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses\n14 piecewise-linear interpolation to define colormaps, and `ListedColormap`, which\n15 makes a colormap from a list of colors.\n16 \n17 .. seealso::\n18 \n19   :doc:`/tutorials/colors/colormap-manipulation` for examples of how to\n20   make colormaps and\n21 \n22   :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.\n23 \n24   :doc:`/tutorials/colors/colormapnorms` for more details about data\n25   normalization\n26 \n27   More colormaps are available at palettable_.\n28 \n29 The module also provides functions for checking whether an object can be\n30 interpreted as a color (`is_color_like`), for converting such an object\n31 to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the\n32 \"#rrggbb\" format (`to_hex`), and a sequence of colors to an (n, 4)\n33 RGBA array (`to_rgba_array`).  Caching is used for efficiency.\n34 \n35 Colors that Matplotlib recognizes are listed at\n36 :doc:`/tutorials/colors/colors`.\n37 \n38 .. _palettable: https://jiffyclub.github.io/palettable/\n39 .. _xkcd color survey: https://xkcd.com/color/rgb/\n40 \"\"\"\n41 \n42 import base64\n43 from collections.abc import Sized, Sequence, Mapping\n44 import functools\n45 import importlib\n46 import inspect\n47 import io\n48 import itertools\n49 from numbers import Number\n50 import re\n51 from PIL import Image\n52 from PIL.PngImagePlugin import PngInfo\n53 \n54 import matplotlib as mpl\n55 import numpy as np\n56 from matplotlib import _api, _cm, cbook, scale\n57 from ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS\n58 \n59 \n60 class _ColorMapping(dict):\n61     def __init__(self, mapping):\n62         super().__init__(mapping)\n63         self.cache = {}\n64 \n65     def __setitem__(self, key, value):\n66         super().__setitem__(key, value)\n67         self.cache.clear()\n68 \n69     def __delitem__(self, key):\n70         super().__delitem__(key)\n71         self.cache.clear()\n72 \n73 \n74 _colors_full_map = {}\n75 # Set by reverse priority order.\n76 _colors_full_map.update(XKCD_COLORS)\n77 _colors_full_map.update({k.replace('grey', 'gray'): v\n78                          for k, v in XKCD_COLORS.items()\n79                          if 'grey' in k})\n80 _colors_full_map.update(CSS4_COLORS)\n81 _colors_full_map.update(TABLEAU_COLORS)\n82 _colors_full_map.update({k.replace('gray', 'grey'): v\n83                          for k, v in TABLEAU_COLORS.items()\n84                          if 'gray' in k})\n85 _colors_full_map.update(BASE_COLORS)\n86 _colors_full_map = _ColorMapping(_colors_full_map)\n87 \n88 _REPR_PNG_SIZE = (512, 64)\n89 \n90 \n91 def get_named_colors_mapping():\n92     \"\"\"Return the global mapping of names to named colors.\"\"\"\n93     return _colors_full_map\n94 \n95 \n96 class ColorSequenceRegistry(Mapping):\n97     r\"\"\"\n98     Container for sequences of colors that are known to Matplotlib by name.\n99 \n100     The universal registry instance is `matplotlib.color_sequences`. There\n101     should be no need for users to instantiate `.ColorSequenceRegistry`\n102     themselves.\n103 \n104     Read access uses a dict-like interface mapping names to lists of colors::\n105 \n106         import matplotlib as mpl\n107         cmap = mpl.color_sequences['tab10']\n108 \n109     The returned lists are copies, so that their modification does not change\n110     the global definition of the color sequence.\n111 \n112     Additional color sequences can be added via\n113     `.ColorSequenceRegistry.register`::\n114 \n115         mpl.color_sequences.register('rgb', ['r', 'g', 'b'])\n116     \"\"\"\n117 \n118     _BUILTIN_COLOR_SEQUENCES = {\n119         'tab10': _cm._tab10_data,\n120         'tab20': _cm._tab20_data,\n121         'tab20b': _cm._tab20b_data,\n122         'tab20c': _cm._tab20c_data,\n123         'Pastel1': _cm._Pastel1_data,\n124         'Pastel2': _cm._Pastel2_data,\n125         'Paired': _cm._Paired_data,\n126         'Accent': _cm._Accent_data,\n127         'Dark2': _cm._Dark2_data,\n128         'Set1': _cm._Set1_data,\n129         'Set2': _cm._Set1_data,\n130         'Set3': _cm._Set1_data,\n131     }\n132 \n133     def __init__(self):\n134         self._color_sequences = {**self._BUILTIN_COLOR_SEQUENCES}\n135 \n136     def __getitem__(self, item):\n137         try:\n138             return list(self._color_sequences[item])\n139         except KeyError:\n140             raise KeyError(f\"{item!r} is not a known color sequence name\")\n141 \n142     def __iter__(self):\n143         return iter(self._color_sequences)\n144 \n145     def __len__(self):\n146         return len(self._color_sequences)\n147 \n148     def __str__(self):\n149         return ('ColorSequenceRegistry; available colormaps:\\n' +\n150                 ', '.join(f\"'{name}'\" for name in self))\n151 \n152     def register(self, name, color_list):\n153         \"\"\"\n154         Register a new color sequence.\n155 \n156         The color sequence registry stores a copy of the given *color_list*, so\n157         that future changes to the original list do not affect the registered\n158         color sequence. Think of this as the registry taking a snapshot\n159         of *color_list* at registration.\n160 \n161         Parameters\n162         ----------\n163         name : str\n164             The name for the color sequence.\n165 \n166         color_list : list of colors\n167             An iterable returning valid Matplotlib colors when iterating over.\n168             Note however that the returned color sequence will always be a\n169             list regardless of the input type.\n170 \n171         \"\"\"\n172         if name in self._BUILTIN_COLOR_SEQUENCES:\n173             raise ValueError(f\"{name!r} is a reserved name for a builtin \"\n174                              \"color sequence\")\n175 \n176         color_list = list(color_list)  # force copy and coerce type to list\n177         for color in color_list:\n178             try:\n179                 to_rgba(color)\n180             except ValueError:\n181                 raise ValueError(\n182                     f\"{color!r} is not a valid color specification\")\n183 \n184         self._color_sequences[name] = color_list\n185 \n186     def unregister(self, name):\n187         \"\"\"\n188         Remove a sequence from the registry.\n189 \n190         You cannot remove built-in color sequences.\n191 \n192         If the name is not registered, returns with no error.\n193         \"\"\"\n194         if name in self._BUILTIN_COLOR_SEQUENCES:\n195             raise ValueError(\n196                 f\"Cannot unregister builtin color sequence {name!r}\")\n197         self._color_sequences.pop(name, None)\n198 \n199 \n200 _color_sequences = ColorSequenceRegistry()\n201 \n202 \n203 def _sanitize_extrema(ex):\n204     if ex is None:\n205         return ex\n206     try:\n207         ret = ex.item()\n208     except AttributeError:\n209         ret = float(ex)\n210     return ret\n211 \n212 \n213 def _is_nth_color(c):\n214     \"\"\"Return whether *c* can be interpreted as an item in the color cycle.\"\"\"\n215     return isinstance(c, str) and re.match(r\"\\AC[0-9]+\\Z\", c)\n216 \n217 \n218 def is_color_like(c):\n219     \"\"\"Return whether *c* can be interpreted as an RGB(A) color.\"\"\"\n220     # Special-case nth color syntax because it cannot be parsed during setup.\n221     if _is_nth_color(c):\n222         return True\n223     try:\n224         to_rgba(c)\n225     except ValueError:\n226         return False\n227     else:\n228         return True\n229 \n230 \n231 def _has_alpha_channel(c):\n232     \"\"\"Return whether *c* is a color with an alpha channel.\"\"\"\n233     # 4-element sequences are interpreted as r, g, b, a\n234     return not isinstance(c, str) and len(c) == 4\n235 \n236 \n237 def _check_color_like(**kwargs):\n238     \"\"\"\n239     For each *key, value* pair in *kwargs*, check that *value* is color-like.\n240     \"\"\"\n241     for k, v in kwargs.items():\n242         if not is_color_like(v):\n243             raise ValueError(f\"{v!r} is not a valid value for {k}\")\n244 \n245 \n246 def same_color(c1, c2):\n247     \"\"\"\n248     Return whether the colors *c1* and *c2* are the same.\n249 \n250     *c1*, *c2* can be single colors or lists/arrays of colors.\n251     \"\"\"\n252     c1 = to_rgba_array(c1)\n253     c2 = to_rgba_array(c2)\n254     n1 = max(c1.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem\n255     n2 = max(c2.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem\n256 \n257     if n1 != n2:\n258         raise ValueError('Different number of elements passed.')\n259     # The following shape test is needed to correctly handle comparisons with\n260     # 'none', which results in a shape (0, 4) array and thus cannot be tested\n261     # via value comparison.\n262     return c1.shape == c2.shape and (c1 == c2).all()\n263 \n264 \n265 def to_rgba(c, alpha=None):\n266     \"\"\"\n267     Convert *c* to an RGBA color.\n268 \n269     Parameters\n270     ----------\n271     c : Matplotlib color or ``np.ma.masked``\n272 \n273     alpha : float, optional\n274         If *alpha* is given, force the alpha value of the returned RGBA tuple\n275         to *alpha*.\n276 \n277         If None, the alpha value from *c* is used. If *c* does not have an\n278         alpha channel, then alpha defaults to 1.\n279 \n280         *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n281         which always maps to ``(0, 0, 0, 0)``.\n282 \n283     Returns\n284     -------\n285     tuple\n286         Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,\n287         alpha) can assume values between 0 and 1.\n288     \"\"\"\n289     # Special-case nth color syntax because it should not be cached.\n290     if _is_nth_color(c):\n291         prop_cycler = mpl.rcParams['axes.prop_cycle']\n292         colors = prop_cycler.by_key().get('color', ['k'])\n293         c = colors[int(c[1:]) % len(colors)]\n294     try:\n295         rgba = _colors_full_map.cache[c, alpha]\n296     except (KeyError, TypeError):  # Not in cache, or unhashable.\n297         rgba = None\n298     if rgba is None:  # Suppress exception chaining of cache lookup failure.\n299         rgba = _to_rgba_no_colorcycle(c, alpha)\n300         try:\n301             _colors_full_map.cache[c, alpha] = rgba\n302         except TypeError:\n303             pass\n304     return rgba\n305 \n306 \n307 def _to_rgba_no_colorcycle(c, alpha=None):\n308     \"\"\"\n309     Convert *c* to an RGBA color, with no support for color-cycle syntax.\n310 \n311     If *alpha* is given, force the alpha value of the returned RGBA tuple\n312     to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha\n313     information, or defaults to 1.\n314 \n315     *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n316     which always maps to ``(0, 0, 0, 0)``.\n317     \"\"\"\n318     orig_c = c\n319     if c is np.ma.masked:\n320         return (0., 0., 0., 0.)\n321     if isinstance(c, str):\n322         if c.lower() == \"none\":\n323             return (0., 0., 0., 0.)\n324         # Named color.\n325         try:\n326             # This may turn c into a non-string, so we check again below.\n327             c = _colors_full_map[c]\n328         except KeyError:\n329             if len(orig_c) != 1:\n330                 try:\n331                     c = _colors_full_map[c.lower()]\n332                 except KeyError:\n333                     pass\n334     if isinstance(c, str):\n335         # hex color in #rrggbb format.\n336         match = re.match(r\"\\A#[a-fA-F0-9]{6}\\Z\", c)\n337         if match:\n338             return (tuple(int(n, 16) / 255\n339                           for n in [c[1:3], c[3:5], c[5:7]])\n340                     + (alpha if alpha is not None else 1.,))\n341         # hex color in #rgb format, shorthand for #rrggbb.\n342         match = re.match(r\"\\A#[a-fA-F0-9]{3}\\Z\", c)\n343         if match:\n344             return (tuple(int(n, 16) / 255\n345                           for n in [c[1]*2, c[2]*2, c[3]*2])\n346                     + (alpha if alpha is not None else 1.,))\n347         # hex color with alpha in #rrggbbaa format.\n348         match = re.match(r\"\\A#[a-fA-F0-9]{8}\\Z\", c)\n349         if match:\n350             color = [int(n, 16) / 255\n351                      for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n352             if alpha is not None:\n353                 color[-1] = alpha\n354             return tuple(color)\n355         # hex color with alpha in #rgba format, shorthand for #rrggbbaa.\n356         match = re.match(r\"\\A#[a-fA-F0-9]{4}\\Z\", c)\n357         if match:\n358             color = [int(n, 16) / 255\n359                      for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]\n360             if alpha is not None:\n361                 color[-1] = alpha\n362             return tuple(color)\n363         # string gray.\n364         try:\n365             c = float(c)\n366         except ValueError:\n367             pass\n368         else:\n369             if not (0 <= c <= 1):\n370                 raise ValueError(\n371                     f\"Invalid string grayscale value {orig_c!r}. \"\n372                     f\"Value must be within 0-1 range\")\n373             return c, c, c, alpha if alpha is not None else 1.\n374         raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n375     # turn 2-D array into 1-D array\n376     if isinstance(c, np.ndarray):\n377         if c.ndim == 2 and c.shape[0] == 1:\n378             c = c.reshape(-1)\n379     # tuple color.\n380     if not np.iterable(c):\n381         raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n382     if len(c) not in [3, 4]:\n383         raise ValueError(\"RGBA sequence should have length 3 or 4\")\n384     if not all(isinstance(x, Number) for x in c):\n385         # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and\n386         # `np.array(...).astype(float)` would all convert \"0.5\" to 0.5.\n387         raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n388     # Return a tuple to prevent the cached value from being modified.\n389     c = tuple(map(float, c))\n390     if len(c) == 3 and alpha is None:\n391         alpha = 1\n392     if alpha is not None:\n393         c = c[:3] + (alpha,)\n394     if any(elem < 0 or elem > 1 for elem in c):\n395         raise ValueError(\"RGBA values should be within 0-1 range\")\n396     return c\n397 \n398 \n399 def to_rgba_array(c, alpha=None):\n400     \"\"\"\n401     Convert *c* to a (n, 4) array of RGBA colors.\n402 \n403     Parameters\n404     ----------\n405     c : Matplotlib color or array of colors\n406         If *c* is a masked array, an `~numpy.ndarray` is returned with a\n407         (0, 0, 0, 0) row for each masked value or row in *c*.\n408 \n409     alpha : float or sequence of floats, optional\n410         If *alpha* is given, force the alpha value of the returned RGBA tuple\n411         to *alpha*.\n412 \n413         If None, the alpha value from *c* is used. If *c* does not have an\n414         alpha channel, then alpha defaults to 1.\n415 \n416         *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n417         which always maps to ``(0, 0, 0, 0)``.\n418 \n419         If *alpha* is a sequence and *c* is a single color, *c* will be\n420         repeated to match the length of *alpha*.\n421 \n422     Returns\n423     -------\n424     array\n425         (n, 4) array of RGBA colors,  where each channel (red, green, blue,\n426         alpha) can assume values between 0 and 1.\n427     \"\"\"\n428     # Special-case inputs that are already arrays, for performance.  (If the\n429     # array has the wrong kind or shape, raise the error during one-at-a-time\n430     # conversion.)\n431     if np.iterable(alpha):\n432         alpha = np.asarray(alpha).ravel()\n433     if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n434             and c.ndim == 2 and c.shape[1] in [3, 4]):\n435         mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n436         c = np.ma.getdata(c)\n437         if np.iterable(alpha):\n438             if c.shape[0] == 1 and alpha.shape[0] > 1:\n439                 c = np.tile(c, (alpha.shape[0], 1))\n440             elif c.shape[0] != alpha.shape[0]:\n441                 raise ValueError(\"The number of colors must match the number\"\n442                                  \" of alpha values if there are more than one\"\n443                                  \" of each.\")\n444         if c.shape[1] == 3:\n445             result = np.column_stack([c, np.zeros(len(c))])\n446             result[:, -1] = alpha if alpha is not None else 1.\n447         elif c.shape[1] == 4:\n448             result = c.copy()\n449             if alpha is not None:\n450                 result[:, -1] = alpha\n451         if mask is not None:\n452             result[mask] = 0\n453         if np.any((result < 0) | (result > 1)):\n454             raise ValueError(\"RGBA values should be within 0-1 range\")\n455         return result\n456     # Handle single values.\n457     # Note that this occurs *after* handling inputs that are already arrays, as\n458     # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n459     # to format the array in the ValueError message(!).\n460     if cbook._str_lower_equal(c, \"none\"):\n461         return np.zeros((0, 4), float)\n462     try:\n463         if np.iterable(alpha):\n464             return np.array([to_rgba(c, a) for a in alpha], float)\n465         else:\n466             return np.array([to_rgba(c, alpha)], float)\n467     except (ValueError, TypeError):\n468         pass\n469 \n470     if isinstance(c, str):\n471         raise ValueError(f\"{c!r} is not a valid color value.\")\n472 \n473     if len(c) == 0:\n474         return np.zeros((0, 4), float)\n475 \n476     # Quick path if the whole sequence can be directly converted to a numpy\n477     # array in one shot.\n478     if isinstance(c, Sequence):\n479         lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n480         if lens == {3}:\n481             rgba = np.column_stack([c, np.ones(len(c))])\n482         elif lens == {4}:\n483             rgba = np.array(c)\n484         else:\n485             rgba = np.array([to_rgba(cc) for cc in c])\n486     else:\n487         rgba = np.array([to_rgba(cc) for cc in c])\n488 \n489     if alpha is not None:\n490         rgba[:, 3] = alpha\n491     return rgba\n492 \n493 \n494 def to_rgb(c):\n495     \"\"\"Convert *c* to an RGB color, silently dropping the alpha channel.\"\"\"\n496     return to_rgba(c)[:3]\n497 \n498 \n499 def to_hex(c, keep_alpha=False):\n500     \"\"\"\n501     Convert *c* to a hex color.\n502 \n503     Parameters\n504     ----------\n505     c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`\n506 \n507     keep_alpha : bool, default: False\n508       If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.\n509 \n510     Returns\n511     -------\n512     str\n513       ``#rrggbb`` or ``#rrggbbaa`` hex color string\n514     \"\"\"\n515     c = to_rgba(c)\n516     if not keep_alpha:\n517         c = c[:3]\n518     return \"#\" + \"\".join(format(round(val * 255), \"02x\") for val in c)\n519 \n520 \n521 ### Backwards-compatible color-conversion API\n522 \n523 \n524 cnames = CSS4_COLORS\n525 hexColorPattern = re.compile(r\"\\A#[a-fA-F0-9]{6}\\Z\")\n526 rgb2hex = to_hex\n527 hex2color = to_rgb\n528 \n529 \n530 class ColorConverter:\n531     \"\"\"\n532     A class only kept for backwards compatibility.\n533 \n534     Its functionality is entirely provided by module-level functions.\n535     \"\"\"\n536     colors = _colors_full_map\n537     cache = _colors_full_map.cache\n538     to_rgb = staticmethod(to_rgb)\n539     to_rgba = staticmethod(to_rgba)\n540     to_rgba_array = staticmethod(to_rgba_array)\n541 \n542 \n543 colorConverter = ColorConverter()\n544 \n545 \n546 ### End of backwards-compatible color-conversion API\n547 \n548 \n549 def _create_lookup_table(N, data, gamma=1.0):\n550     r\"\"\"\n551     Create an *N* -element 1D lookup table.\n552 \n553     This assumes a mapping :math:`f : [0, 1] \\rightarrow [0, 1]`. The returned\n554     data is an array of N values :math:`y = f(x)` where x is sampled from\n555     [0, 1].\n556 \n557     By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The\n558     *gamma* correction factor :math:`\\gamma` distorts this equidistant\n559     sampling by :math:`x \\rightarrow x^\\gamma`.\n560 \n561     Parameters\n562     ----------\n563     N : int\n564         The number of elements of the created lookup table; at least 1.\n565 \n566     data : (M, 3) array-like or callable\n567         Defines the mapping :math:`f`.\n568 \n569         If a (M, 3) array-like, the rows define values (x, y0, y1).  The x\n570         values must start with x=0, end with x=1, and all x values be in\n571         increasing order.\n572 \n573         A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range\n574         :math:`y^1_{i-1} \\ldots y^0_i` by linear interpolation.\n575 \n576         For the simple case of a y-continuous mapping, y0 and y1 are identical.\n577 \n578         The two values of y are to allow for discontinuous mapping functions.\n579         E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::\n580 \n581             [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]\n582 \n583         In the special case of ``N == 1``, by convention the returned value\n584         is y0 for x == 1.\n585 \n586         If *data* is a callable, it must accept and return numpy arrays::\n587 \n588            data(x : ndarray) -> ndarray\n589 \n590         and map values between 0 - 1 to 0 - 1.\n591 \n592     gamma : float\n593         Gamma correction factor for input distribution x of the mapping.\n594 \n595         See also https://en.wikipedia.org/wiki/Gamma_correction.\n596 \n597     Returns\n598     -------\n599     array\n600         The lookup table where ``lut[x * (N-1)]`` gives the closest value\n601         for values of x between 0 and 1.\n602 \n603     Notes\n604     -----\n605     This function is internally used for `.LinearSegmentedColormap`.\n606     \"\"\"\n607 \n608     if callable(data):\n609         xind = np.linspace(0, 1, N) ** gamma\n610         lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n611         return lut\n612 \n613     try:\n614         adata = np.array(data)\n615     except Exception as err:\n616         raise TypeError(\"data must be convertible to an array\") from err\n617     _api.check_shape((None, 3), data=adata)\n618 \n619     x = adata[:, 0]\n620     y0 = adata[:, 1]\n621     y1 = adata[:, 2]\n622 \n623     if x[0] != 0. or x[-1] != 1.0:\n624         raise ValueError(\n625             \"data mapping points must start with x=0 and end with x=1\")\n626     if (np.diff(x) < 0).any():\n627         raise ValueError(\"data mapping points must have x in increasing order\")\n628     # begin generation of lookup table\n629     if N == 1:\n630         # convention: use the y = f(x=1) value for a 1-element lookup table\n631         lut = np.array(y0[-1])\n632     else:\n633         x = x * (N - 1)\n634         xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n635         ind = np.searchsorted(x, xind)[1:-1]\n636 \n637         distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n638         lut = np.concatenate([\n639             [y1[0]],\n640             distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],\n641             [y0[-1]],\n642         ])\n643     # ensure that the lut is confined to values between 0 and 1 by clipping it\n644     return np.clip(lut, 0.0, 1.0)\n645 \n646 \n647 class Colormap:\n648     \"\"\"\n649     Baseclass for all scalar to RGBA mappings.\n650 \n651     Typically, Colormap instances are used to convert data values (floats)\n652     from the interval ``[0, 1]`` to the RGBA color that the respective\n653     Colormap represents. For scaling of data into the ``[0, 1]`` interval see\n654     `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`\n655     make heavy use of this ``data -> normalize -> map-to-color`` processing\n656     chain.\n657     \"\"\"\n658 \n659     def __init__(self, name, N=256):\n660         \"\"\"\n661         Parameters\n662         ----------\n663         name : str\n664             The name of the colormap.\n665         N : int\n666             The number of RGB quantization levels.\n667         \"\"\"\n668         self.name = name\n669         self.N = int(N)  # ensure that N is always int\n670         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n671         self._rgba_under = None\n672         self._rgba_over = None\n673         self._i_under = self.N\n674         self._i_over = self.N + 1\n675         self._i_bad = self.N + 2\n676         self._isinit = False\n677         #: When this colormap exists on a scalar mappable and colorbar_extend\n678         #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n679         #: the default value for the ``extend`` keyword in the\n680         #: `matplotlib.colorbar.Colorbar` constructor.\n681         self.colorbar_extend = False\n682 \n683     def __call__(self, X, alpha=None, bytes=False):\n684         \"\"\"\n685         Parameters\n686         ----------\n687         X : float or int, `~numpy.ndarray` or scalar\n688             The data value(s) to convert to RGBA.\n689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to\n690             return the RGBA values ``X*100`` percent along the Colormap line.\n691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to\n692             return RGBA values *indexed* from the Colormap with index ``X``.\n693         alpha : float or array-like or None\n694             Alpha must be a scalar between 0 and 1, a sequence of such\n695             floats with shape matching X, or None.\n696         bytes : bool\n697             If False (default), the returned RGBA values will be floats in the\n698             interval ``[0, 1]`` otherwise they will be uint8s in the interval\n699             ``[0, 255]``.\n700 \n701         Returns\n702         -------\n703         Tuple of RGBA values if X is scalar, otherwise an array of\n704         RGBA values with a shape of ``X.shape + (4, )``.\n705         \"\"\"\n706         if not self._isinit:\n707             self._init()\n708 \n709         xa = np.array(X, copy=True)\n710         if not xa.dtype.isnative:\n711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n712         if xa.dtype.kind == \"f\":\n713             xa *= self.N\n714             # xa == 1 (== N after multiplication) is not out of range.\n715             xa[xa == self.N] = self.N - 1\n716         # Pre-compute the masks before casting to int (which can truncate\n717         # negative values to zero or wrap large floats to negative ints).\n718         mask_under = xa < 0\n719         mask_over = xa >= self.N\n720         # If input was masked, get the bad mask from it; else mask out nans.\n721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)\n722         with np.errstate(invalid=\"ignore\"):\n723             # We need this cast for unsigned ints as well as floats\n724             xa = xa.astype(int)\n725         xa[mask_under] = self._i_under\n726         xa[mask_over] = self._i_over\n727         xa[mask_bad] = self._i_bad\n728 \n729         lut = self._lut\n730         if bytes:\n731             lut = (lut * 255).astype(np.uint8)\n732 \n733         rgba = lut.take(xa, axis=0, mode='clip')\n734 \n735         if alpha is not None:\n736             alpha = np.clip(alpha, 0, 1)\n737             if bytes:\n738                 alpha *= 255  # Will be cast to uint8 upon assignment.\n739             if alpha.shape not in [(), xa.shape]:\n740                 raise ValueError(\n741                     f\"alpha is array-like but its shape {alpha.shape} does \"\n742                     f\"not match that of X {xa.shape}\")\n743             rgba[..., -1] = alpha\n744             # If the \"bad\" color is all zeros, then ignore alpha input.\n745             if (lut[-1] == 0).all():\n746                 rgba[mask_bad] = (0, 0, 0, 0)\n747 \n748         if not np.iterable(X):\n749             rgba = tuple(rgba)\n750         return rgba\n751 \n752     def __copy__(self):\n753         cls = self.__class__\n754         cmapobject = cls.__new__(cls)\n755         cmapobject.__dict__.update(self.__dict__)\n756         if self._isinit:\n757             cmapobject._lut = np.copy(self._lut)\n758         return cmapobject\n759 \n760     def __eq__(self, other):\n761         if (not isinstance(other, Colormap) or self.name != other.name or\n762                 self.colorbar_extend != other.colorbar_extend):\n763             return False\n764         # To compare lookup tables the Colormaps have to be initialized\n765         if not self._isinit:\n766             self._init()\n767         if not other._isinit:\n768             other._init()\n769         return np.array_equal(self._lut, other._lut)\n770 \n771     def get_bad(self):\n772         \"\"\"Get the color for masked values.\"\"\"\n773         if not self._isinit:\n774             self._init()\n775         return np.array(self._lut[self._i_bad])\n776 \n777     def set_bad(self, color='k', alpha=None):\n778         \"\"\"Set the color for masked values.\"\"\"\n779         self._rgba_bad = to_rgba(color, alpha)\n780         if self._isinit:\n781             self._set_extremes()\n782 \n783     def get_under(self):\n784         \"\"\"Get the color for low out-of-range values.\"\"\"\n785         if not self._isinit:\n786             self._init()\n787         return np.array(self._lut[self._i_under])\n788 \n789     def set_under(self, color='k', alpha=None):\n790         \"\"\"Set the color for low out-of-range values.\"\"\"\n791         self._rgba_under = to_rgba(color, alpha)\n792         if self._isinit:\n793             self._set_extremes()\n794 \n795     def get_over(self):\n796         \"\"\"Get the color for high out-of-range values.\"\"\"\n797         if not self._isinit:\n798             self._init()\n799         return np.array(self._lut[self._i_over])\n800 \n801     def set_over(self, color='k', alpha=None):\n802         \"\"\"Set the color for high out-of-range values.\"\"\"\n803         self._rgba_over = to_rgba(color, alpha)\n804         if self._isinit:\n805             self._set_extremes()\n806 \n807     def set_extremes(self, *, bad=None, under=None, over=None):\n808         \"\"\"\n809         Set the colors for masked (*bad*) values and, when ``norm.clip =\n810         False``, low (*under*) and high (*over*) out-of-range values.\n811         \"\"\"\n812         if bad is not None:\n813             self.set_bad(bad)\n814         if under is not None:\n815             self.set_under(under)\n816         if over is not None:\n817             self.set_over(over)\n818 \n819     def with_extremes(self, *, bad=None, under=None, over=None):\n820         \"\"\"\n821         Return a copy of the colormap, for which the colors for masked (*bad*)\n822         values and, when ``norm.clip = False``, low (*under*) and high (*over*)\n823         out-of-range values, have been set accordingly.\n824         \"\"\"\n825         new_cm = self.copy()\n826         new_cm.set_extremes(bad=bad, under=under, over=over)\n827         return new_cm\n828 \n829     def _set_extremes(self):\n830         if self._rgba_under:\n831             self._lut[self._i_under] = self._rgba_under\n832         else:\n833             self._lut[self._i_under] = self._lut[0]\n834         if self._rgba_over:\n835             self._lut[self._i_over] = self._rgba_over\n836         else:\n837             self._lut[self._i_over] = self._lut[self.N - 1]\n838         self._lut[self._i_bad] = self._rgba_bad\n839 \n840     def _init(self):\n841         \"\"\"Generate the lookup table, ``self._lut``.\"\"\"\n842         raise NotImplementedError(\"Abstract class only\")\n843 \n844     def is_gray(self):\n845         \"\"\"Return whether the colormap is grayscale.\"\"\"\n846         if not self._isinit:\n847             self._init()\n848         return (np.all(self._lut[:, 0] == self._lut[:, 1]) and\n849                 np.all(self._lut[:, 0] == self._lut[:, 2]))\n850 \n851     def resampled(self, lutsize):\n852         \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n853         if hasattr(self, '_resample'):\n854             _api.warn_external(\n855                 \"The ability to resample a color map is now public API \"\n856                 f\"However the class {type(self)} still only implements \"\n857                 \"the previous private _resample method.  Please update \"\n858                 \"your class.\"\n859             )\n860             return self._resample(lutsize)\n861 \n862         raise NotImplementedError()\n863 \n864     def reversed(self, name=None):\n865         \"\"\"\n866         Return a reversed instance of the Colormap.\n867 \n868         .. note:: This function is not implemented for the base class.\n869 \n870         Parameters\n871         ----------\n872         name : str, optional\n873             The name for the reversed colormap. If None, the\n874             name is set to ``self.name + \"_r\"``.\n875 \n876         See Also\n877         --------\n878         LinearSegmentedColormap.reversed\n879         ListedColormap.reversed\n880         \"\"\"\n881         raise NotImplementedError()\n882 \n883     def _repr_png_(self):\n884         \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n885         X = np.tile(np.linspace(0, 1, _REPR_PNG_SIZE[0]),\n886                     (_REPR_PNG_SIZE[1], 1))\n887         pixels = self(X, bytes=True)\n888         png_bytes = io.BytesIO()\n889         title = self.name + ' colormap'\n890         author = f'Matplotlib v{mpl.__version__}, https://matplotlib.org'\n891         pnginfo = PngInfo()\n892         pnginfo.add_text('Title', title)\n893         pnginfo.add_text('Description', title)\n894         pnginfo.add_text('Author', author)\n895         pnginfo.add_text('Software', author)\n896         Image.fromarray(pixels).save(png_bytes, format='png', pnginfo=pnginfo)\n897         return png_bytes.getvalue()\n898 \n899     def _repr_html_(self):\n900         \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n901         png_bytes = self._repr_png_()\n902         png_base64 = base64.b64encode(png_bytes).decode('ascii')\n903         def color_block(color):\n904             hex_color = to_hex(color, keep_alpha=True)\n905             return (f'<div title=\"{hex_color}\" '\n906                     'style=\"display: inline-block; '\n907                     'width: 1em; height: 1em; '\n908                     'margin: 0; '\n909                     'vertical-align: middle; '\n910                     'border: 1px solid #555; '\n911                     f'background-color: {hex_color};\"></div>')\n912 \n913         return ('<div style=\"vertical-align: middle;\">'\n914                 f'<strong>{self.name}</strong> '\n915                 '</div>'\n916                 '<div class=\"cmap\"><img '\n917                 f'alt=\"{self.name} colormap\" '\n918                 f'title=\"{self.name}\" '\n919                 'style=\"border: 1px solid #555;\" '\n920                 f'src=\"data:image/png;base64,{png_base64}\"></div>'\n921                 '<div style=\"vertical-align: middle; '\n922                 f'max-width: {_REPR_PNG_SIZE[0]+2}px; '\n923                 'display: flex; justify-content: space-between;\">'\n924                 '<div style=\"float: left;\">'\n925                 f'{color_block(self.get_under())} under'\n926                 '</div>'\n927                 '<div style=\"margin: 0 auto; display: inline-block;\">'\n928                 f'bad {color_block(self.get_bad())}'\n929                 '</div>'\n930                 '<div style=\"float: right;\">'\n931                 f'over {color_block(self.get_over())}'\n932                 '</div>')\n933 \n934     def copy(self):\n935         \"\"\"Return a copy of the colormap.\"\"\"\n936         return self.__copy__()\n937 \n938 \n939 class LinearSegmentedColormap(Colormap):\n940     \"\"\"\n941     Colormap objects based on lookup tables using linear segments.\n942 \n943     The lookup table is generated using linear interpolation for each\n944     primary color, with the 0-1 domain divided into any number of\n945     segments.\n946     \"\"\"\n947 \n948     def __init__(self, name, segmentdata, N=256, gamma=1.0):\n949         \"\"\"\n950         Create colormap from linear mapping segments\n951 \n952         segmentdata argument is a dictionary with a red, green and blue\n953         entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n954         forming rows in a table. Entries for alpha are optional.\n955 \n956         Example: suppose you want red to increase from 0 to 1 over\n957         the bottom half, green to do the same over the middle half,\n958         and blue over the top half.  Then you would use::\n959 \n960             cdict = {'red':   [(0.0,  0.0, 0.0),\n961                                (0.5,  1.0, 1.0),\n962                                (1.0,  1.0, 1.0)],\n963 \n964                      'green': [(0.0,  0.0, 0.0),\n965                                (0.25, 0.0, 0.0),\n966                                (0.75, 1.0, 1.0),\n967                                (1.0,  1.0, 1.0)],\n968 \n969                      'blue':  [(0.0,  0.0, 0.0),\n970                                (0.5,  0.0, 0.0),\n971                                (1.0,  1.0, 1.0)]}\n972 \n973         Each row in the table for a given color is a sequence of\n974         *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n975         monotonically from 0 to 1.  For any input value *z* falling\n976         between *x[i]* and *x[i+1]*, the output value of a given color\n977         will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n978 \n979             row i:   x  y0  y1\n980                            /\n981                           /\n982             row i+1: x  y0  y1\n983 \n984         Hence y0 in the first row and y1 in the last row are never used.\n985 \n986         See Also\n987         --------\n988         LinearSegmentedColormap.from_list\n989             Static method; factory function for generating a smoothly-varying\n990             LinearSegmentedColormap.\n991         \"\"\"\n992         # True only if all colors in map are identical; needed for contouring.\n993         self.monochrome = False\n994         super().__init__(name, N)\n995         self._segmentdata = segmentdata\n996         self._gamma = gamma\n997 \n998     def _init(self):\n999         self._lut = np.ones((self.N + 3, 4), float)\n1000         self._lut[:-3, 0] = _create_lookup_table(\n1001             self.N, self._segmentdata['red'], self._gamma)\n1002         self._lut[:-3, 1] = _create_lookup_table(\n1003             self.N, self._segmentdata['green'], self._gamma)\n1004         self._lut[:-3, 2] = _create_lookup_table(\n1005             self.N, self._segmentdata['blue'], self._gamma)\n1006         if 'alpha' in self._segmentdata:\n1007             self._lut[:-3, 3] = _create_lookup_table(\n1008                 self.N, self._segmentdata['alpha'], 1)\n1009         self._isinit = True\n1010         self._set_extremes()\n1011 \n1012     def set_gamma(self, gamma):\n1013         \"\"\"Set a new gamma value and regenerate colormap.\"\"\"\n1014         self._gamma = gamma\n1015         self._init()\n1016 \n1017     @staticmethod\n1018     def from_list(name, colors, N=256, gamma=1.0):\n1019         \"\"\"\n1020         Create a `LinearSegmentedColormap` from a list of colors.\n1021 \n1022         Parameters\n1023         ----------\n1024         name : str\n1025             The name of the colormap.\n1026         colors : array-like of colors or array-like of (value, color)\n1027             If only colors are given, they are equidistantly mapped from the\n1028             range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to\n1029             ``colors[-1]``.\n1030             If (value, color) pairs are given, the mapping is from *value*\n1031             to *color*. This can be used to divide the range unevenly.\n1032         N : int\n1033             The number of RGB quantization levels.\n1034         gamma : float\n1035         \"\"\"\n1036         if not np.iterable(colors):\n1037             raise ValueError('colors must be iterable')\n1038 \n1039         if (isinstance(colors[0], Sized) and len(colors[0]) == 2\n1040                 and not isinstance(colors[0], str)):\n1041             # List of value, color pairs\n1042             vals, colors = zip(*colors)\n1043         else:\n1044             vals = np.linspace(0, 1, len(colors))\n1045 \n1046         r, g, b, a = to_rgba_array(colors).T\n1047         cdict = {\n1048             \"red\": np.column_stack([vals, r, r]),\n1049             \"green\": np.column_stack([vals, g, g]),\n1050             \"blue\": np.column_stack([vals, b, b]),\n1051             \"alpha\": np.column_stack([vals, a, a]),\n1052         }\n1053 \n1054         return LinearSegmentedColormap(name, cdict, N, gamma)\n1055 \n1056     def resampled(self, lutsize):\n1057         \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n1058         new_cmap = LinearSegmentedColormap(self.name, self._segmentdata,\n1059                                            lutsize)\n1060         new_cmap._rgba_over = self._rgba_over\n1061         new_cmap._rgba_under = self._rgba_under\n1062         new_cmap._rgba_bad = self._rgba_bad\n1063         return new_cmap\n1064 \n1065     # Helper ensuring picklability of the reversed cmap.\n1066     @staticmethod\n1067     def _reverser(func, x):\n1068         return func(1 - x)\n1069 \n1070     def reversed(self, name=None):\n1071         \"\"\"\n1072         Return a reversed instance of the Colormap.\n1073 \n1074         Parameters\n1075         ----------\n1076         name : str, optional\n1077             The name for the reversed colormap. If None, the\n1078             name is set to ``self.name + \"_r\"``.\n1079 \n1080         Returns\n1081         -------\n1082         LinearSegmentedColormap\n1083             The reversed colormap.\n1084         \"\"\"\n1085         if name is None:\n1086             name = self.name + \"_r\"\n1087 \n1088         # Using a partial object keeps the cmap picklable.\n1089         data_r = {key: (functools.partial(self._reverser, data)\n1090                         if callable(data) else\n1091                         [(1.0 - x, y1, y0) for x, y0, y1 in reversed(data)])\n1092                   for key, data in self._segmentdata.items()}\n1093 \n1094         new_cmap = LinearSegmentedColormap(name, data_r, self.N, self._gamma)\n1095         # Reverse the over/under values too\n1096         new_cmap._rgba_over = self._rgba_under\n1097         new_cmap._rgba_under = self._rgba_over\n1098         new_cmap._rgba_bad = self._rgba_bad\n1099         return new_cmap\n1100 \n1101 \n1102 class ListedColormap(Colormap):\n1103     \"\"\"\n1104     Colormap object generated from a list of colors.\n1105 \n1106     This may be most useful when indexing directly into a colormap,\n1107     but it can also be used to generate special colormaps for ordinary\n1108     mapping.\n1109 \n1110     Parameters\n1111     ----------\n1112     colors : list, array\n1113         List of Matplotlib color specifications, or an equivalent Nx3 or Nx4\n1114         floating point array (*N* RGB or RGBA values).\n1115     name : str, optional\n1116         String to identify the colormap.\n1117     N : int, optional\n1118         Number of entries in the map. The default is *None*, in which case\n1119         there is one colormap entry for each element in the list of colors.\n1120         If ::\n1121 \n1122             N < len(colors)\n1123 \n1124         the list will be truncated at *N*. If ::\n1125 \n1126             N > len(colors)\n1127 \n1128         the list will be extended by repetition.\n1129     \"\"\"\n1130     def __init__(self, colors, name='from_list', N=None):\n1131         self.monochrome = False  # Are all colors identical? (for contour.py)\n1132         if N is None:\n1133             self.colors = colors\n1134             N = len(colors)\n1135         else:\n1136             if isinstance(colors, str):\n1137                 self.colors = [colors] * N\n1138                 self.monochrome = True\n1139             elif np.iterable(colors):\n1140                 if len(colors) == 1:\n1141                     self.monochrome = True\n1142                 self.colors = list(\n1143                     itertools.islice(itertools.cycle(colors), N))\n1144             else:\n1145                 try:\n1146                     gray = float(colors)\n1147                 except TypeError:\n1148                     pass\n1149                 else:\n1150                     self.colors = [gray] * N\n1151                 self.monochrome = True\n1152         super().__init__(name, N)\n1153 \n1154     def _init(self):\n1155         self._lut = np.zeros((self.N + 3, 4), float)\n1156         self._lut[:-3] = to_rgba_array(self.colors)\n1157         self._isinit = True\n1158         self._set_extremes()\n1159 \n1160     def resampled(self, lutsize):\n1161         \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n1162         colors = self(np.linspace(0, 1, lutsize))\n1163         new_cmap = ListedColormap(colors, name=self.name)\n1164         # Keep the over/under values too\n1165         new_cmap._rgba_over = self._rgba_over\n1166         new_cmap._rgba_under = self._rgba_under\n1167         new_cmap._rgba_bad = self._rgba_bad\n1168         return new_cmap\n1169 \n1170     def reversed(self, name=None):\n1171         \"\"\"\n1172         Return a reversed instance of the Colormap.\n1173 \n1174         Parameters\n1175         ----------\n1176         name : str, optional\n1177             The name for the reversed colormap. If None, the\n1178             name is set to ``self.name + \"_r\"``.\n1179 \n1180         Returns\n1181         -------\n1182         ListedColormap\n1183             A reversed instance of the colormap.\n1184         \"\"\"\n1185         if name is None:\n1186             name = self.name + \"_r\"\n1187 \n1188         colors_r = list(reversed(self.colors))\n1189         new_cmap = ListedColormap(colors_r, name=name, N=self.N)\n1190         # Reverse the over/under values too\n1191         new_cmap._rgba_over = self._rgba_under\n1192         new_cmap._rgba_under = self._rgba_over\n1193         new_cmap._rgba_bad = self._rgba_bad\n1194         return new_cmap\n1195 \n1196 \n1197 class Normalize:\n1198     \"\"\"\n1199     A class which, when called, linearly normalizes data into the\n1200     ``[0.0, 1.0]`` interval.\n1201     \"\"\"\n1202 \n1203     def __init__(self, vmin=None, vmax=None, clip=False):\n1204         \"\"\"\n1205         Parameters\n1206         ----------\n1207         vmin, vmax : float or None\n1208             If *vmin* and/or *vmax* is not given, they are initialized from the\n1209             minimum and maximum value, respectively, of the first input\n1210             processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n1211 \n1212         clip : bool, default: False\n1213             If ``True`` values falling outside the range ``[vmin, vmax]``,\n1214             are mapped to 0 or 1, whichever is closer, and masked values are\n1215             set to 1.  If ``False`` masked values remain masked.\n1216 \n1217             Clipping silently defeats the purpose of setting the over, under,\n1218             and masked colors in a colormap, so it is likely to lead to\n1219             surprises; therefore the default is ``clip=False``.\n1220 \n1221         Notes\n1222         -----\n1223         Returns 0 if ``vmin == vmax``.\n1224         \"\"\"\n1225         self._vmin = _sanitize_extrema(vmin)\n1226         self._vmax = _sanitize_extrema(vmax)\n1227         self._clip = clip\n1228         self._scale = None\n1229         self.callbacks = cbook.CallbackRegistry(signals=[\"changed\"])\n1230 \n1231     @property\n1232     def vmin(self):\n1233         return self._vmin\n1234 \n1235     @vmin.setter\n1236     def vmin(self, value):\n1237         value = _sanitize_extrema(value)\n1238         if value != self._vmin:\n1239             self._vmin = value\n1240             self._changed()\n1241 \n1242     @property\n1243     def vmax(self):\n1244         return self._vmax\n1245 \n1246     @vmax.setter\n1247     def vmax(self, value):\n1248         value = _sanitize_extrema(value)\n1249         if value != self._vmax:\n1250             self._vmax = value\n1251             self._changed()\n1252 \n1253     @property\n1254     def clip(self):\n1255         return self._clip\n1256 \n1257     @clip.setter\n1258     def clip(self, value):\n1259         if value != self._clip:\n1260             self._clip = value\n1261             self._changed()\n1262 \n1263     def _changed(self):\n1264         \"\"\"\n1265         Call this whenever the norm is changed to notify all the\n1266         callback listeners to the 'changed' signal.\n1267         \"\"\"\n1268         self.callbacks.process('changed')\n1269 \n1270     @staticmethod\n1271     def process_value(value):\n1272         \"\"\"\n1273         Homogenize the input *value* for easy and efficient normalization.\n1274 \n1275         *value* can be a scalar or sequence.\n1276 \n1277         Returns\n1278         -------\n1279         result : masked array\n1280             Masked array with the same shape as *value*.\n1281         is_scalar : bool\n1282             Whether *value* is a scalar.\n1283 \n1284         Notes\n1285         -----\n1286         Float dtypes are preserved; integer types with two bytes or smaller are\n1287         converted to np.float32, and larger types are converted to np.float64.\n1288         Preserving float32 when possible, and using in-place operations,\n1289         greatly improves speed for large arrays.\n1290         \"\"\"\n1291         is_scalar = not np.iterable(value)\n1292         if is_scalar:\n1293             value = [value]\n1294         dtype = np.min_scalar_type(value)\n1295         if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n1296             # bool_/int8/int16 -> float32; int32/int64 -> float64\n1297             dtype = np.promote_types(dtype, np.float32)\n1298         # ensure data passed in as an ndarray subclass are interpreted as\n1299         # an ndarray. See issue #6622.\n1300         mask = np.ma.getmask(value)\n1301         data = np.asarray(value)\n1302         result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n1303         return result, is_scalar\n1304 \n1305     def __call__(self, value, clip=None):\n1306         \"\"\"\n1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the\n1308         ``[0.0, 1.0]`` interval and return it.\n1309 \n1310         Parameters\n1311         ----------\n1312         value\n1313             Data to normalize.\n1314         clip : bool\n1315             If ``None``, defaults to ``self.clip`` (which defaults to\n1316             ``False``).\n1317 \n1318         Notes\n1319         -----\n1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are\n1321         initialized using ``self.autoscale_None(value)``.\n1322         \"\"\"\n1323         if clip is None:\n1324             clip = self.clip\n1325 \n1326         result, is_scalar = self.process_value(value)\n1327 \n1328         if self.vmin is None or self.vmax is None:\n1329             self.autoscale_None(result)\n1330         # Convert at least to float, without losing precision.\n1331         (vmin,), _ = self.process_value(self.vmin)\n1332         (vmax,), _ = self.process_value(self.vmax)\n1333         if vmin == vmax:\n1334             result.fill(0)  # Or should it be all masked?  Or 0.5?\n1335         elif vmin > vmax:\n1336             raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n1337         else:\n1338             if clip:\n1339                 mask = np.ma.getmask(result)\n1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n1341                                      mask=mask)\n1342             # ma division is very slow; we can take a shortcut\n1343             resdat = result.data\n1344             resdat -= vmin\n1345             resdat /= (vmax - vmin)\n1346             result = np.ma.array(resdat, mask=result.mask, copy=False)\n1347         if is_scalar:\n1348             result = result[0]\n1349         return result\n1350 \n1351     def inverse(self, value):\n1352         if not self.scaled():\n1353             raise ValueError(\"Not invertible until both vmin and vmax are set\")\n1354         (vmin,), _ = self.process_value(self.vmin)\n1355         (vmax,), _ = self.process_value(self.vmax)\n1356 \n1357         if np.iterable(value):\n1358             val = np.ma.asarray(value)\n1359             return vmin + val * (vmax - vmin)\n1360         else:\n1361             return vmin + value * (vmax - vmin)\n1362 \n1363     def autoscale(self, A):\n1364         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n1365         self.vmin = self.vmax = None\n1366         self.autoscale_None(A)\n1367 \n1368     def autoscale_None(self, A):\n1369         \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n1370         A = np.asanyarray(A)\n1371         if self.vmin is None and A.size:\n1372             self.vmin = A.min()\n1373         if self.vmax is None and A.size:\n1374             self.vmax = A.max()\n1375 \n1376     def scaled(self):\n1377         \"\"\"Return whether vmin and vmax are set.\"\"\"\n1378         return self.vmin is not None and self.vmax is not None\n1379 \n1380 \n1381 class TwoSlopeNorm(Normalize):\n1382     def __init__(self, vcenter, vmin=None, vmax=None):\n1383         \"\"\"\n1384         Normalize data with a set center.\n1385 \n1386         Useful when mapping data with an unequal rates of change around a\n1387         conceptual center, e.g., data that range from -2 to 4, with 0 as\n1388         the midpoint.\n1389 \n1390         Parameters\n1391         ----------\n1392         vcenter : float\n1393             The data value that defines ``0.5`` in the normalization.\n1394         vmin : float, optional\n1395             The data value that defines ``0.0`` in the normalization.\n1396             Defaults to the min value of the dataset.\n1397         vmax : float, optional\n1398             The data value that defines ``1.0`` in the normalization.\n1399             Defaults to the max value of the dataset.\n1400 \n1401         Examples\n1402         --------\n1403         This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data\n1404         between is linearly interpolated::\n1405 \n1406             >>> import matplotlib.colors as mcolors\n1407             >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,\n1408                                               vcenter=0., vmax=10000)\n1409             >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]\n1410             >>> offset(data)\n1411             array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])\n1412         \"\"\"\n1413 \n1414         super().__init__(vmin=vmin, vmax=vmax)\n1415         self._vcenter = vcenter\n1416         if vcenter is not None and vmax is not None and vcenter >= vmax:\n1417             raise ValueError('vmin, vcenter, and vmax must be in '\n1418                              'ascending order')\n1419         if vcenter is not None and vmin is not None and vcenter <= vmin:\n1420             raise ValueError('vmin, vcenter, and vmax must be in '\n1421                              'ascending order')\n1422 \n1423     @property\n1424     def vcenter(self):\n1425         return self._vcenter\n1426 \n1427     @vcenter.setter\n1428     def vcenter(self, value):\n1429         if value != self._vcenter:\n1430             self._vcenter = value\n1431             self._changed()\n1432 \n1433     def autoscale_None(self, A):\n1434         \"\"\"\n1435         Get vmin and vmax.\n1436 \n1437         If vcenter isn't in the range [vmin, vmax], either vmin or vmax\n1438         is expanded so that vcenter lies in the middle of the modified range\n1439         [vmin, vmax].\n1440         \"\"\"\n1441         super().autoscale_None(A)\n1442         if self.vmin >= self.vcenter:\n1443             self.vmin = self.vcenter - (self.vmax - self.vcenter)\n1444         if self.vmax <= self.vcenter:\n1445             self.vmax = self.vcenter + (self.vcenter - self.vmin)\n1446 \n1447     def __call__(self, value, clip=None):\n1448         \"\"\"\n1449         Map value to the interval [0, 1]. The clip argument is unused.\n1450         \"\"\"\n1451         result, is_scalar = self.process_value(value)\n1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None\n1453 \n1454         if not self.vmin <= self.vcenter <= self.vmax:\n1455             raise ValueError(\"vmin, vcenter, vmax must increase monotonically\")\n1456         # note that we must extrapolate for tick locators:\n1457         result = np.ma.masked_array(\n1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],\n1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),\n1460             mask=np.ma.getmask(result))\n1461         if is_scalar:\n1462             result = np.atleast_1d(result)[0]\n1463         return result\n1464 \n1465     def inverse(self, value):\n1466         if not self.scaled():\n1467             raise ValueError(\"Not invertible until both vmin and vmax are set\")\n1468         (vmin,), _ = self.process_value(self.vmin)\n1469         (vmax,), _ = self.process_value(self.vmax)\n1470         (vcenter,), _ = self.process_value(self.vcenter)\n1471         result = np.interp(value, [0, 0.5, 1], [vmin, vcenter, vmax],\n1472                            left=-np.inf, right=np.inf)\n1473         return result\n1474 \n1475 \n1476 class CenteredNorm(Normalize):\n1477     def __init__(self, vcenter=0, halfrange=None, clip=False):\n1478         \"\"\"\n1479         Normalize symmetrical data around a center (0 by default).\n1480 \n1481         Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change\n1482         around the center.\n1483 \n1484         Useful when mapping symmetrical data around a conceptual center\n1485         e.g., data that range from -2 to 4, with 0 as the midpoint, and\n1486         with equal rates of change around that midpoint.\n1487 \n1488         Parameters\n1489         ----------\n1490         vcenter : float, default: 0\n1491             The data value that defines ``0.5`` in the normalization.\n1492         halfrange : float, optional\n1493             The range of data values that defines a range of ``0.5`` in the\n1494             normalization, so that *vcenter* - *halfrange* is ``0.0`` and\n1495             *vcenter* + *halfrange* is ``1.0`` in the normalization.\n1496             Defaults to the largest absolute difference to *vcenter* for\n1497             the values in the dataset.\n1498 \n1499         Examples\n1500         --------\n1501         This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0\n1502         (assuming equal rates of change above and below 0.0):\n1503 \n1504             >>> import matplotlib.colors as mcolors\n1505             >>> norm = mcolors.CenteredNorm(halfrange=4.0)\n1506             >>> data = [-2., 0., 4.]\n1507             >>> norm(data)\n1508             array([0.25, 0.5 , 1.  ])\n1509         \"\"\"\n1510         super().__init__(vmin=None, vmax=None, clip=clip)\n1511         self._vcenter = vcenter\n1512         # calling the halfrange setter to set vmin and vmax\n1513         self.halfrange = halfrange\n1514 \n1515     def autoscale(self, A):\n1516         \"\"\"\n1517         Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.\n1518         \"\"\"\n1519         A = np.asanyarray(A)\n1520         self.halfrange = max(self._vcenter-A.min(),\n1521                              A.max()-self._vcenter)\n1522 \n1523     def autoscale_None(self, A):\n1524         \"\"\"Set *vmin* and *vmax*.\"\"\"\n1525         A = np.asanyarray(A)\n1526         if self.halfrange is None and A.size:\n1527             self.autoscale(A)\n1528 \n1529     @property\n1530     def vmin(self):\n1531         return self._vmin\n1532 \n1533     @vmin.setter\n1534     def vmin(self, value):\n1535         value = _sanitize_extrema(value)\n1536         if value != self._vmin:\n1537             self._vmin = value\n1538             self._vmax = 2*self.vcenter - value\n1539             self._changed()\n1540 \n1541     @property\n1542     def vmax(self):\n1543         return self._vmax\n1544 \n1545     @vmax.setter\n1546     def vmax(self, value):\n1547         value = _sanitize_extrema(value)\n1548         if value != self._vmax:\n1549             self._vmax = value\n1550             self._vmin = 2*self.vcenter - value\n1551             self._changed()\n1552 \n1553     @property\n1554     def vcenter(self):\n1555         return self._vcenter\n1556 \n1557     @vcenter.setter\n1558     def vcenter(self, vcenter):\n1559         if vcenter != self._vcenter:\n1560             self._vcenter = vcenter\n1561             # Trigger an update of the vmin/vmax values through the setter\n1562             self.halfrange = self.halfrange\n1563             self._changed()\n1564 \n1565     @property\n1566     def halfrange(self):\n1567         if self.vmin is None or self.vmax is None:\n1568             return None\n1569         return (self.vmax - self.vmin) / 2\n1570 \n1571     @halfrange.setter\n1572     def halfrange(self, halfrange):\n1573         if halfrange is None:\n1574             self.vmin = None\n1575             self.vmax = None\n1576         else:\n1577             self.vmin = self.vcenter - abs(halfrange)\n1578             self.vmax = self.vcenter + abs(halfrange)\n1579 \n1580 \n1581 def make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n1582     \"\"\"\n1583     Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`\n1584     subclass.\n1585 \n1586     After ::\n1587 \n1588         @make_norm_from_scale(scale_cls)\n1589         class norm_cls(Normalize):\n1590             ...\n1591 \n1592     *norm_cls* is filled with methods so that normalization computations are\n1593     forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used\n1594     for the colorbar of a mappable normalized with *norm_cls*).\n1595 \n1596     If *init* is not passed, then the constructor signature of *norm_cls*\n1597     will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three\n1598     parameters will be forwarded to the base class (``Normalize.__init__``),\n1599     and a *scale_cls* object will be initialized with no arguments (other than\n1600     a dummy axis).\n1601 \n1602     If the *scale_cls* constructor takes additional parameters, then *init*\n1603     should be passed to `make_norm_from_scale`.  It is a callable which is\n1604     *only* used for its signature.  First, this signature will become the\n1605     signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the\n1606     parameters passed to it using this signature, extract the bound *vmin*,\n1607     *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and\n1608     forward the remaining bound values (including any defaults defined by the\n1609     signature) to the *scale_cls* constructor.\n1610     \"\"\"\n1611 \n1612     if base_norm_cls is None:\n1613         return functools.partial(make_norm_from_scale, scale_cls, init=init)\n1614 \n1615     if isinstance(scale_cls, functools.partial):\n1616         scale_args = scale_cls.args\n1617         scale_kwargs_items = tuple(scale_cls.keywords.items())\n1618         scale_cls = scale_cls.func\n1619     else:\n1620         scale_args = scale_kwargs_items = ()\n1621 \n1622     if init is None:\n1623         def init(vmin=None, vmax=None, clip=False): pass\n1624 \n1625     return _make_norm_from_scale(\n1626         scale_cls, scale_args, scale_kwargs_items,\n1627         base_norm_cls, inspect.signature(init))\n1628 \n1629 \n1630 @functools.cache\n1631 def _make_norm_from_scale(\n1632     scale_cls, scale_args, scale_kwargs_items,\n1633     base_norm_cls, bound_init_signature,\n1634 ):\n1635     \"\"\"\n1636     Helper for `make_norm_from_scale`.\n1637 \n1638     This function is split out to enable caching (in particular so that\n1639     different unpickles reuse the same class).  In order to do so,\n1640 \n1641     - ``functools.partial`` *scale_cls* is expanded into ``func, args, kwargs``\n1642       to allow memoizing returned norms (partial instances always compare\n1643       unequal, but we can check identity based on ``func, args, kwargs``;\n1644     - *init* is replaced by *init_signature*, as signatures are picklable,\n1645       unlike to arbitrary lambdas.\n1646     \"\"\"\n1647 \n1648     class Norm(base_norm_cls):\n1649         def __reduce__(self):\n1650             cls = type(self)\n1651             # If the class is toplevel-accessible, it is possible to directly\n1652             # pickle it \"by name\".  This is required to support norm classes\n1653             # defined at a module's toplevel, as the inner base_norm_cls is\n1654             # otherwise unpicklable (as it gets shadowed by the generated norm\n1655             # class).  If either import or attribute access fails, fall back to\n1656             # the general path.\n1657             try:\n1658                 if cls is getattr(importlib.import_module(cls.__module__),\n1659                                   cls.__qualname__):\n1660                     return (_create_empty_object_of_class, (cls,), vars(self))\n1661             except (ImportError, AttributeError):\n1662                 pass\n1663             return (_picklable_norm_constructor,\n1664                     (scale_cls, scale_args, scale_kwargs_items,\n1665                      base_norm_cls, bound_init_signature),\n1666                     vars(self))\n1667 \n1668         def __init__(self, *args, **kwargs):\n1669             ba = bound_init_signature.bind(*args, **kwargs)\n1670             ba.apply_defaults()\n1671             super().__init__(\n1672                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n1673             self._scale = functools.partial(\n1674                 scale_cls, *scale_args, **dict(scale_kwargs_items))(\n1675                     axis=None, **ba.arguments)\n1676             self._trf = self._scale.get_transform()\n1677 \n1678         __init__.__signature__ = bound_init_signature.replace(parameters=[\n1679             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n1680             *bound_init_signature.parameters.values()])\n1681 \n1682         def __call__(self, value, clip=None):\n1683             value, is_scalar = self.process_value(value)\n1684             if self.vmin is None or self.vmax is None:\n1685                 self.autoscale_None(value)\n1686             if self.vmin > self.vmax:\n1687                 raise ValueError(\"vmin must be less or equal to vmax\")\n1688             if self.vmin == self.vmax:\n1689                 return np.full_like(value, 0)\n1690             if clip is None:\n1691                 clip = self.clip\n1692             if clip:\n1693                 value = np.clip(value, self.vmin, self.vmax)\n1694             t_value = self._trf.transform(value).reshape(np.shape(value))\n1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n1696             if not np.isfinite([t_vmin, t_vmax]).all():\n1697                 raise ValueError(\"Invalid vmin or vmax\")\n1698             t_value -= t_vmin\n1699             t_value /= (t_vmax - t_vmin)\n1700             t_value = np.ma.masked_invalid(t_value, copy=False)\n1701             return t_value[0] if is_scalar else t_value\n1702 \n1703         def inverse(self, value):\n1704             if not self.scaled():\n1705                 raise ValueError(\"Not invertible until scaled\")\n1706             if self.vmin > self.vmax:\n1707                 raise ValueError(\"vmin must be less or equal to vmax\")\n1708             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n1709             if not np.isfinite([t_vmin, t_vmax]).all():\n1710                 raise ValueError(\"Invalid vmin or vmax\")\n1711             value, is_scalar = self.process_value(value)\n1712             rescaled = value * (t_vmax - t_vmin)\n1713             rescaled += t_vmin\n1714             value = (self._trf\n1715                      .inverted()\n1716                      .transform(rescaled)\n1717                      .reshape(np.shape(value)))\n1718             return value[0] if is_scalar else value\n1719 \n1720         def autoscale_None(self, A):\n1721             # i.e. A[np.isfinite(...)], but also for non-array A's\n1722             in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n1723             if in_trf_domain.size == 0:\n1724                 in_trf_domain = np.ma.masked\n1725             return super().autoscale_None(in_trf_domain)\n1726 \n1727     if base_norm_cls is Normalize:\n1728         Norm.__name__ = f\"{scale_cls.__name__}Norm\"\n1729         Norm.__qualname__ = f\"{scale_cls.__qualname__}Norm\"\n1730     else:\n1731         Norm.__name__ = base_norm_cls.__name__\n1732         Norm.__qualname__ = base_norm_cls.__qualname__\n1733     Norm.__module__ = base_norm_cls.__module__\n1734     Norm.__doc__ = base_norm_cls.__doc__\n1735 \n1736     return Norm\n1737 \n1738 \n1739 def _create_empty_object_of_class(cls):\n1740     return cls.__new__(cls)\n1741 \n1742 \n1743 def _picklable_norm_constructor(*args):\n1744     return _create_empty_object_of_class(_make_norm_from_scale(*args))\n1745 \n1746 \n1747 @make_norm_from_scale(\n1748     scale.FuncScale,\n1749     init=lambda functions, vmin=None, vmax=None, clip=False: None)\n1750 class FuncNorm(Normalize):\n1751     \"\"\"\n1752     Arbitrary normalization using functions for the forward and inverse.\n1753 \n1754     Parameters\n1755     ----------\n1756     functions : (callable, callable)\n1757         two-tuple of the forward and inverse functions for the normalization.\n1758         The forward function must be monotonic.\n1759 \n1760         Both functions must have the signature ::\n1761 \n1762            def forward(values: array-like) -> array-like\n1763 \n1764     vmin, vmax : float or None\n1765         If *vmin* and/or *vmax* is not given, they are initialized from the\n1766         minimum and maximum value, respectively, of the first input\n1767         processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n1768 \n1769     clip : bool, default: False\n1770         If ``True`` values falling outside the range ``[vmin, vmax]``,\n1771         are mapped to 0 or 1, whichever is closer, and masked values are\n1772         set to 1.  If ``False`` masked values remain masked.\n1773 \n1774         Clipping silently defeats the purpose of setting the over, under,\n1775         and masked colors in a colormap, so it is likely to lead to\n1776         surprises; therefore the default is ``clip=False``.\n1777     \"\"\"\n1778 \n1779 \n1780 LogNorm = make_norm_from_scale(\n1781     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n1782 LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\n1783 LogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n1784 \n1785 \n1786 @make_norm_from_scale(\n1787     scale.SymmetricalLogScale,\n1788     init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,\n1789                 base=10: None)\n1790 class SymLogNorm(Normalize):\n1791     \"\"\"\n1792     The symmetrical logarithmic scale is logarithmic in both the\n1793     positive and negative directions from the origin.\n1794 \n1795     Since the values close to zero tend toward infinity, there is a\n1796     need to have a range around zero that is linear.  The parameter\n1797     *linthresh* allows the user to specify the size of this range\n1798     (-*linthresh*, *linthresh*).\n1799 \n1800     Parameters\n1801     ----------\n1802     linthresh : float\n1803         The range within which the plot is linear (to avoid having the plot\n1804         go to infinity around zero).\n1805     linscale : float, default: 1\n1806         This allows the linear range (-*linthresh* to *linthresh*) to be\n1807         stretched relative to the logarithmic range. Its value is the\n1808         number of decades to use for each half of the linear range. For\n1809         example, when *linscale* == 1.0 (the default), the space used for\n1810         the positive and negative halves of the linear range will be equal\n1811         to one decade in the logarithmic range.\n1812     base : float, default: 10\n1813     \"\"\"\n1814 \n1815     @property\n1816     def linthresh(self):\n1817         return self._scale.linthresh\n1818 \n1819     @linthresh.setter\n1820     def linthresh(self, value):\n1821         self._scale.linthresh = value\n1822 \n1823 \n1824 @make_norm_from_scale(\n1825     scale.AsinhScale,\n1826     init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None)\n1827 class AsinhNorm(Normalize):\n1828     \"\"\"\n1829     The inverse hyperbolic sine scale is approximately linear near\n1830     the origin, but becomes logarithmic for larger positive\n1831     or negative values. Unlike the `SymLogNorm`, the transition between\n1832     these linear and logarithmic regions is smooth, which may reduce\n1833     the risk of visual artifacts.\n1834 \n1835     .. note::\n1836 \n1837        This API is provisional and may be revised in the future\n1838        based on early user feedback.\n1839 \n1840     Parameters\n1841     ----------\n1842     linear_width : float, default: 1\n1843         The effective width of the linear region, beyond which\n1844         the transformation becomes asymptotically logarithmic\n1845     \"\"\"\n1846 \n1847     @property\n1848     def linear_width(self):\n1849         return self._scale.linear_width\n1850 \n1851     @linear_width.setter\n1852     def linear_width(self, value):\n1853         self._scale.linear_width = value\n1854 \n1855 \n1856 class PowerNorm(Normalize):\n1857     \"\"\"\n1858     Linearly map a given value to the 0-1 range and then apply\n1859     a power-law normalization over that range.\n1860     \"\"\"\n1861     def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n1862         super().__init__(vmin, vmax, clip)\n1863         self.gamma = gamma\n1864 \n1865     def __call__(self, value, clip=None):\n1866         if clip is None:\n1867             clip = self.clip\n1868 \n1869         result, is_scalar = self.process_value(value)\n1870 \n1871         self.autoscale_None(result)\n1872         gamma = self.gamma\n1873         vmin, vmax = self.vmin, self.vmax\n1874         if vmin > vmax:\n1875             raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n1876         elif vmin == vmax:\n1877             result.fill(0)\n1878         else:\n1879             if clip:\n1880                 mask = np.ma.getmask(result)\n1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n1882                                      mask=mask)\n1883             resdat = result.data\n1884             resdat -= vmin\n1885             resdat[resdat < 0] = 0\n1886             np.power(resdat, gamma, resdat)\n1887             resdat /= (vmax - vmin) ** gamma\n1888 \n1889             result = np.ma.array(resdat, mask=result.mask, copy=False)\n1890         if is_scalar:\n1891             result = result[0]\n1892         return result\n1893 \n1894     def inverse(self, value):\n1895         if not self.scaled():\n1896             raise ValueError(\"Not invertible until scaled\")\n1897         gamma = self.gamma\n1898         vmin, vmax = self.vmin, self.vmax\n1899 \n1900         if np.iterable(value):\n1901             val = np.ma.asarray(value)\n1902             return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin\n1903         else:\n1904             return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n1905 \n1906 \n1907 class BoundaryNorm(Normalize):\n1908     \"\"\"\n1909     Generate a colormap index based on discrete intervals.\n1910 \n1911     Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers\n1912     instead of to the interval 0-1.\n1913     \"\"\"\n1914 \n1915     # Mapping to the 0-1 interval could have been done via piece-wise linear\n1916     # interpolation, but using integers seems simpler, and reduces the number\n1917     # of conversions back and forth between int and float.\n1918 \n1919     def __init__(self, boundaries, ncolors, clip=False, *, extend='neither'):\n1920         \"\"\"\n1921         Parameters\n1922         ----------\n1923         boundaries : array-like\n1924             Monotonically increasing sequence of at least 2 bin edges:  data\n1925             falling in the n-th bin will be mapped to the n-th color.\n1926 \n1927         ncolors : int\n1928             Number of colors in the colormap to be used.\n1929 \n1930         clip : bool, optional\n1931             If clip is ``True``, out of range values are mapped to 0 if they\n1932             are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they\n1933             are above ``boundaries[-1]``.\n1934 \n1935             If clip is ``False``, out of range values are mapped to -1 if\n1936             they are below ``boundaries[0]`` or mapped to *ncolors* if they are\n1937             above ``boundaries[-1]``. These are then converted to valid indices\n1938             by `Colormap.__call__`.\n1939 \n1940         extend : {'neither', 'both', 'min', 'max'}, default: 'neither'\n1941             Extend the number of bins to include one or both of the\n1942             regions beyond the boundaries.  For example, if ``extend``\n1943             is 'min', then the color to which the region between the first\n1944             pair of boundaries is mapped will be distinct from the first\n1945             color in the colormap, and by default a\n1946             `~matplotlib.colorbar.Colorbar` will be drawn with\n1947             the triangle extension on the left or lower end.\n1948 \n1949         Notes\n1950         -----\n1951         If there are fewer bins (including extensions) than colors, then the\n1952         color index is chosen by linearly interpolating the ``[0, nbins - 1]``\n1953         range onto the ``[0, ncolors - 1]`` range, effectively skipping some\n1954         colors in the middle of the colormap.\n1955         \"\"\"\n1956         if clip and extend != 'neither':\n1957             raise ValueError(\"'clip=True' is not compatible with 'extend'\")\n1958         super().__init__(vmin=boundaries[0], vmax=boundaries[-1], clip=clip)\n1959         self.boundaries = np.asarray(boundaries)\n1960         self.N = len(self.boundaries)\n1961         if self.N < 2:\n1962             raise ValueError(\"You must provide at least 2 boundaries \"\n1963                              f\"(1 region) but you passed in {boundaries!r}\")\n1964         self.Ncmap = ncolors\n1965         self.extend = extend\n1966 \n1967         self._scale = None  # don't use the default scale.\n1968 \n1969         self._n_regions = self.N - 1  # number of colors needed\n1970         self._offset = 0\n1971         if extend in ('min', 'both'):\n1972             self._n_regions += 1\n1973             self._offset = 1\n1974         if extend in ('max', 'both'):\n1975             self._n_regions += 1\n1976         if self._n_regions > self.Ncmap:\n1977             raise ValueError(f\"There are {self._n_regions} color bins \"\n1978                              \"including extensions, but ncolors = \"\n1979                              f\"{ncolors}; ncolors must equal or exceed the \"\n1980                              \"number of bins\")\n1981 \n1982     def __call__(self, value, clip=None):\n1983         \"\"\"\n1984         This method behaves similarly to `.Normalize.__call__`, except that it\n1985         returns integers or arrays of int16.\n1986         \"\"\"\n1987         if clip is None:\n1988             clip = self.clip\n1989 \n1990         xx, is_scalar = self.process_value(value)\n1991         mask = np.ma.getmaskarray(xx)\n1992         # Fill masked values a value above the upper boundary\n1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))\n1994         if clip:\n1995             np.clip(xx, self.vmin, self.vmax, out=xx)\n1996             max_col = self.Ncmap - 1\n1997         else:\n1998             max_col = self.Ncmap\n1999         # this gives us the bins in the lookup table in the range\n2000         # [0, _n_regions - 1]  (the offset is set in the init)\n2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset\n2002         # if we have more colors than regions, stretch the region\n2003         # index computed above to full range of the color bins.  This\n2004         # will make use of the full range (but skip some of the colors\n2005         # in the middle) such that the first region is mapped to the\n2006         # first color and the last region is mapped to the last color.\n2007         if self.Ncmap > self._n_regions:\n2008             if self._n_regions == 1:\n2009                 # special case the 1 region case, pick the middle color\n2010                 iret[iret == 0] = (self.Ncmap - 1) // 2\n2011             else:\n2012                 # otherwise linearly remap the values from the region index\n2013                 # to the color index spaces\n2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret\n2015         # cast to 16bit integers in all cases\n2016         iret = iret.astype(np.int16)\n2017         iret[xx < self.vmin] = -1\n2018         iret[xx >= self.vmax] = max_col\n2019         ret = np.ma.array(iret, mask=mask)\n2020         if is_scalar:\n2021             ret = int(ret[0])  # assume python scalar\n2022         return ret\n2023 \n2024     def inverse(self, value):\n2025         \"\"\"\n2026         Raises\n2027         ------\n2028         ValueError\n2029             BoundaryNorm is not invertible, so calling this method will always\n2030             raise an error\n2031         \"\"\"\n2032         raise ValueError(\"BoundaryNorm is not invertible\")\n2033 \n2034 \n2035 class NoNorm(Normalize):\n2036     \"\"\"\n2037     Dummy replacement for `Normalize`, for the case where we want to use\n2038     indices directly in a `~matplotlib.cm.ScalarMappable`.\n2039     \"\"\"\n2040     def __call__(self, value, clip=None):\n2041         return value\n2042 \n2043     def inverse(self, value):\n2044         return value\n2045 \n2046 \n2047 def rgb_to_hsv(arr):\n2048     \"\"\"\n2049     Convert float RGB values (in the range [0, 1]), in a numpy array to HSV\n2050     values.\n2051 \n2052     Parameters\n2053     ----------\n2054     arr : (..., 3) array-like\n2055        All values must be in the range [0, 1]\n2056 \n2057     Returns\n2058     -------\n2059     (..., 3) `~numpy.ndarray`\n2060        Colors converted to HSV values in range [0, 1]\n2061     \"\"\"\n2062     arr = np.asarray(arr)\n2063 \n2064     # check length of the last dimension, should be _some_ sort of rgb\n2065     if arr.shape[-1] != 3:\n2066         raise ValueError(\"Last dimension of input array must be 3; \"\n2067                          f\"shape {arr.shape} was found.\")\n2068 \n2069     in_shape = arr.shape\n2070     arr = np.array(\n2071         arr, copy=False,\n2072         dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.\n2073         ndmin=2,  # In case input was 1D.\n2074     )\n2075     out = np.zeros_like(arr)\n2076     arr_max = arr.max(-1)\n2077     ipos = arr_max > 0\n2078     delta = arr.ptp(-1)\n2079     s = np.zeros_like(delta)\n2080     s[ipos] = delta[ipos] / arr_max[ipos]\n2081     ipos = delta > 0\n2082     # red is max\n2083     idx = (arr[..., 0] == arr_max) & ipos\n2084     out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n2085     # green is max\n2086     idx = (arr[..., 1] == arr_max) & ipos\n2087     out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n2088     # blue is max\n2089     idx = (arr[..., 2] == arr_max) & ipos\n2090     out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n2091 \n2092     out[..., 0] = (out[..., 0] / 6.0) % 1.0\n2093     out[..., 1] = s\n2094     out[..., 2] = arr_max\n2095 \n2096     return out.reshape(in_shape)\n2097 \n2098 \n2099 def hsv_to_rgb(hsv):\n2100     \"\"\"\n2101     Convert HSV values to RGB.\n2102 \n2103     Parameters\n2104     ----------\n2105     hsv : (..., 3) array-like\n2106        All values assumed to be in range [0, 1]\n2107 \n2108     Returns\n2109     -------\n2110     (..., 3) `~numpy.ndarray`\n2111        Colors converted to RGB values in range [0, 1]\n2112     \"\"\"\n2113     hsv = np.asarray(hsv)\n2114 \n2115     # check length of the last dimension, should be _some_ sort of rgb\n2116     if hsv.shape[-1] != 3:\n2117         raise ValueError(\"Last dimension of input array must be 3; \"\n2118                          f\"shape {hsv.shape} was found.\")\n2119 \n2120     in_shape = hsv.shape\n2121     hsv = np.array(\n2122         hsv, copy=False,\n2123         dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.\n2124         ndmin=2,  # In case input was 1D.\n2125     )\n2126 \n2127     h = hsv[..., 0]\n2128     s = hsv[..., 1]\n2129     v = hsv[..., 2]\n2130 \n2131     r = np.empty_like(h)\n2132     g = np.empty_like(h)\n2133     b = np.empty_like(h)\n2134 \n2135     i = (h * 6.0).astype(int)\n2136     f = (h * 6.0) - i\n2137     p = v * (1.0 - s)\n2138     q = v * (1.0 - s * f)\n2139     t = v * (1.0 - s * (1.0 - f))\n2140 \n2141     idx = i % 6 == 0\n2142     r[idx] = v[idx]\n2143     g[idx] = t[idx]\n2144     b[idx] = p[idx]\n2145 \n2146     idx = i == 1\n2147     r[idx] = q[idx]\n2148     g[idx] = v[idx]\n2149     b[idx] = p[idx]\n2150 \n2151     idx = i == 2\n2152     r[idx] = p[idx]\n2153     g[idx] = v[idx]\n2154     b[idx] = t[idx]\n2155 \n2156     idx = i == 3\n2157     r[idx] = p[idx]\n2158     g[idx] = q[idx]\n2159     b[idx] = v[idx]\n2160 \n2161     idx = i == 4\n2162     r[idx] = t[idx]\n2163     g[idx] = p[idx]\n2164     b[idx] = v[idx]\n2165 \n2166     idx = i == 5\n2167     r[idx] = v[idx]\n2168     g[idx] = p[idx]\n2169     b[idx] = q[idx]\n2170 \n2171     idx = s == 0\n2172     r[idx] = v[idx]\n2173     g[idx] = v[idx]\n2174     b[idx] = v[idx]\n2175 \n2176     rgb = np.stack([r, g, b], axis=-1)\n2177 \n2178     return rgb.reshape(in_shape)\n2179 \n2180 \n2181 def _vector_magnitude(arr):\n2182     # things that don't work here:\n2183     #  * np.linalg.norm: drops mask from ma.array\n2184     #  * np.sum: drops mask from ma.array unless entire vector is masked\n2185     sum_sq = 0\n2186     for i in range(arr.shape[-1]):\n2187         sum_sq += arr[..., i, np.newaxis] ** 2\n2188     return np.sqrt(sum_sq)\n2189 \n2190 \n2191 class LightSource:\n2192     \"\"\"\n2193     Create a light source coming from the specified azimuth and elevation.\n2194     Angles are in degrees, with the azimuth measured\n2195     clockwise from north and elevation up from the zero plane of the surface.\n2196 \n2197     `shade` is used to produce \"shaded\" RGB values for a data array.\n2198     `shade_rgb` can be used to combine an RGB image with an elevation map.\n2199     `hillshade` produces an illumination map of a surface.\n2200     \"\"\"\n2201 \n2202     def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n2203                  hsv_min_sat=1, hsv_max_sat=0):\n2204         \"\"\"\n2205         Specify the azimuth (measured clockwise from south) and altitude\n2206         (measured up from the plane of the surface) of the light source\n2207         in degrees.\n2208 \n2209         Parameters\n2210         ----------\n2211         azdeg : float, default: 315 degrees (from the northwest)\n2212             The azimuth (0-360, degrees clockwise from North) of the light\n2213             source.\n2214         altdeg : float, default: 45 degrees\n2215             The altitude (0-90, degrees up from horizontal) of the light\n2216             source.\n2217 \n2218         Notes\n2219         -----\n2220         For backwards compatibility, the parameters *hsv_min_val*,\n2221         *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n2222         initialization as well.  However, these parameters will only be used if\n2223         \"blend_mode='hsv'\" is passed into `shade` or `shade_rgb`.\n2224         See the documentation for `blend_hsv` for more details.\n2225         \"\"\"\n2226         self.azdeg = azdeg\n2227         self.altdeg = altdeg\n2228         self.hsv_min_val = hsv_min_val\n2229         self.hsv_max_val = hsv_max_val\n2230         self.hsv_min_sat = hsv_min_sat\n2231         self.hsv_max_sat = hsv_max_sat\n2232 \n2233     @property\n2234     def direction(self):\n2235         \"\"\"The unit vector direction towards the light source.\"\"\"\n2236         # Azimuth is in degrees clockwise from North. Convert to radians\n2237         # counterclockwise from East (mathematical notation).\n2238         az = np.radians(90 - self.azdeg)\n2239         alt = np.radians(self.altdeg)\n2240         return np.array([\n2241             np.cos(az) * np.cos(alt),\n2242             np.sin(az) * np.cos(alt),\n2243             np.sin(alt)\n2244         ])\n2245 \n2246     def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n2247         \"\"\"\n2248         Calculate the illumination intensity for a surface using the defined\n2249         azimuth and elevation for the light source.\n2250 \n2251         This computes the normal vectors for the surface, and then passes them\n2252         on to `shade_normals`\n2253 \n2254         Parameters\n2255         ----------\n2256         elevation : 2D array-like\n2257             The height values used to generate an illumination map\n2258         vert_exag : number, optional\n2259             The amount to exaggerate the elevation values by when calculating\n2260             illumination. This can be used either to correct for differences in\n2261             units between the x-y coordinate system and the elevation\n2262             coordinate system (e.g. decimal degrees vs. meters) or to\n2263             exaggerate or de-emphasize topographic effects.\n2264         dx : number, optional\n2265             The x-spacing (columns) of the input *elevation* grid.\n2266         dy : number, optional\n2267             The y-spacing (rows) of the input *elevation* grid.\n2268         fraction : number, optional\n2269             Increases or decreases the contrast of the hillshade.  Values\n2270             greater than one will cause intermediate values to move closer to\n2271             full illumination or shadow (and clipping any values that move\n2272             beyond 0 or 1). Note that this is not visually or mathematically\n2273             the same as vertical exaggeration.\n2274 \n2275         Returns\n2276         -------\n2277         `~numpy.ndarray`\n2278             A 2D array of illumination values between 0-1, where 0 is\n2279             completely in shadow and 1 is completely illuminated.\n2280         \"\"\"\n2281 \n2282         # Because most image and raster GIS data has the first row in the array\n2283         # as the \"top\" of the image, dy is implicitly negative.  This is\n2284         # consistent to what `imshow` assumes, as well.\n2285         dy = -dy\n2286 \n2287         # compute the normal vectors from the partial derivatives\n2288         e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n2289 \n2290         # .view is to keep subclasses\n2291         normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n2292         normal[..., 0] = -e_dx\n2293         normal[..., 1] = -e_dy\n2294         normal[..., 2] = 1\n2295         normal /= _vector_magnitude(normal)\n2296 \n2297         return self.shade_normals(normal, fraction)\n2298 \n2299     def shade_normals(self, normals, fraction=1.):\n2300         \"\"\"\n2301         Calculate the illumination intensity for the normal vectors of a\n2302         surface using the defined azimuth and elevation for the light source.\n2303 \n2304         Imagine an artificial sun placed at infinity in some azimuth and\n2305         elevation position illuminating our surface. The parts of the surface\n2306         that slope toward the sun should brighten while those sides facing away\n2307         should become darker.\n2308 \n2309         Parameters\n2310         ----------\n2311         fraction : number, optional\n2312             Increases or decreases the contrast of the hillshade.  Values\n2313             greater than one will cause intermediate values to move closer to\n2314             full illumination or shadow (and clipping any values that move\n2315             beyond 0 or 1). Note that this is not visually or mathematically\n2316             the same as vertical exaggeration.\n2317 \n2318         Returns\n2319         -------\n2320         `~numpy.ndarray`\n2321             A 2D array of illumination values between 0-1, where 0 is\n2322             completely in shadow and 1 is completely illuminated.\n2323         \"\"\"\n2324 \n2325         intensity = normals.dot(self.direction)\n2326 \n2327         # Apply contrast stretch\n2328         imin, imax = intensity.min(), intensity.max()\n2329         intensity *= fraction\n2330 \n2331         # Rescale to 0-1, keeping range before contrast stretch\n2332         # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n2333         # fully occluded 0, etc.)\n2334         if (imax - imin) > 1e-6:\n2335             # Strictly speaking, this is incorrect. Negative values should be\n2336             # clipped to 0 because they're fully occluded. However, rescaling\n2337             # in this manner is consistent with the previous implementation and\n2338             # visually appears better than a \"hard\" clip.\n2339             intensity -= imin\n2340             intensity /= (imax - imin)\n2341         intensity = np.clip(intensity, 0, 1)\n2342 \n2343         return intensity\n2344 \n2345     def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n2346               vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n2347         \"\"\"\n2348         Combine colormapped data values with an illumination intensity map\n2349         (a.k.a.  \"hillshade\") of the values.\n2350 \n2351         Parameters\n2352         ----------\n2353         data : 2D array-like\n2354             The height values used to generate a shaded map.\n2355         cmap : `~matplotlib.colors.Colormap`\n2356             The colormap used to color the *data* array. Note that this must be\n2357             a `~matplotlib.colors.Colormap` instance.  For example, rather than\n2358             passing in ``cmap='gist_earth'``, use\n2359             ``cmap=plt.get_cmap('gist_earth')`` instead.\n2360         norm : `~matplotlib.colors.Normalize` instance, optional\n2361             The normalization used to scale values before colormapping. If\n2362             None, the input will be linearly scaled between its min and max.\n2363         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n2364             The type of blending used to combine the colormapped data\n2365             values with the illumination intensity.  Default is\n2366             \"overlay\".  Note that for most topographic surfaces,\n2367             \"overlay\" or \"soft\" appear more visually realistic. If a\n2368             user-defined function is supplied, it is expected to\n2369             combine an MxNx3 RGB array of floats (ranging 0 to 1) with\n2370             an MxNx1 hillshade array (also 0 to 1).  (Call signature\n2371             ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n2372             to this function will be passed on to the *blend_mode*\n2373             function.\n2374         vmin : float or None, optional\n2375             The minimum value used in colormapping *data*. If *None* the\n2376             minimum value in *data* is used. If *norm* is specified, then this\n2377             argument will be ignored.\n2378         vmax : float or None, optional\n2379             The maximum value used in colormapping *data*. If *None* the\n2380             maximum value in *data* is used. If *norm* is specified, then this\n2381             argument will be ignored.\n2382         vert_exag : number, optional\n2383             The amount to exaggerate the elevation values by when calculating\n2384             illumination. This can be used either to correct for differences in\n2385             units between the x-y coordinate system and the elevation\n2386             coordinate system (e.g. decimal degrees vs. meters) or to\n2387             exaggerate or de-emphasize topography.\n2388         dx : number, optional\n2389             The x-spacing (columns) of the input *elevation* grid.\n2390         dy : number, optional\n2391             The y-spacing (rows) of the input *elevation* grid.\n2392         fraction : number, optional\n2393             Increases or decreases the contrast of the hillshade.  Values\n2394             greater than one will cause intermediate values to move closer to\n2395             full illumination or shadow (and clipping any values that move\n2396             beyond 0 or 1). Note that this is not visually or mathematically\n2397             the same as vertical exaggeration.\n2398         Additional kwargs are passed on to the *blend_mode* function.\n2399 \n2400         Returns\n2401         -------\n2402         `~numpy.ndarray`\n2403             An MxNx4 array of floats ranging between 0-1.\n2404         \"\"\"\n2405         if vmin is None:\n2406             vmin = data.min()\n2407         if vmax is None:\n2408             vmax = data.max()\n2409         if norm is None:\n2410             norm = Normalize(vmin=vmin, vmax=vmax)\n2411 \n2412         rgb0 = cmap(norm(data))\n2413         rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n2414                               vert_exag=vert_exag, dx=dx, dy=dy,\n2415                               fraction=fraction, **kwargs)\n2416         # Don't overwrite the alpha channel, if present.\n2417         rgb0[..., :3] = rgb1[..., :3]\n2418         return rgb0\n2419 \n2420     def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n2421                   vert_exag=1, dx=1, dy=1, **kwargs):\n2422         \"\"\"\n2423         Use this light source to adjust the colors of the *rgb* input array to\n2424         give the impression of a shaded relief map with the given *elevation*.\n2425 \n2426         Parameters\n2427         ----------\n2428         rgb : array-like\n2429             An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n2430         elevation : array-like\n2431             An (M, N) array of the height values used to generate a shaded map.\n2432         fraction : number\n2433             Increases or decreases the contrast of the hillshade.  Values\n2434             greater than one will cause intermediate values to move closer to\n2435             full illumination or shadow (and clipping any values that move\n2436             beyond 0 or 1). Note that this is not visually or mathematically\n2437             the same as vertical exaggeration.\n2438         blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n2439             The type of blending used to combine the colormapped data values\n2440             with the illumination intensity.  For backwards compatibility, this\n2441             defaults to \"hsv\". Note that for most topographic surfaces,\n2442             \"overlay\" or \"soft\" appear more visually realistic. If a\n2443             user-defined function is supplied, it is expected to combine an\n2444             MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n2445             array (also 0 to 1).  (Call signature\n2446             ``func(rgb, illum, **kwargs)``)\n2447             Additional kwargs supplied to this function will be passed on to\n2448             the *blend_mode* function.\n2449         vert_exag : number, optional\n2450             The amount to exaggerate the elevation values by when calculating\n2451             illumination. This can be used either to correct for differences in\n2452             units between the x-y coordinate system and the elevation\n2453             coordinate system (e.g. decimal degrees vs. meters) or to\n2454             exaggerate or de-emphasize topography.\n2455         dx : number, optional\n2456             The x-spacing (columns) of the input *elevation* grid.\n2457         dy : number, optional\n2458             The y-spacing (rows) of the input *elevation* grid.\n2459         Additional kwargs are passed on to the *blend_mode* function.\n2460 \n2461         Returns\n2462         -------\n2463         `~numpy.ndarray`\n2464             An (m, n, 3) array of floats ranging between 0-1.\n2465         \"\"\"\n2466         # Calculate the \"hillshade\" intensity.\n2467         intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n2468         intensity = intensity[..., np.newaxis]\n2469 \n2470         # Blend the hillshade and rgb data using the specified mode\n2471         lookup = {\n2472                 'hsv': self.blend_hsv,\n2473                 'soft': self.blend_soft_light,\n2474                 'overlay': self.blend_overlay,\n2475                 }\n2476         if blend_mode in lookup:\n2477             blend = lookup[blend_mode](rgb, intensity, **kwargs)\n2478         else:\n2479             try:\n2480                 blend = blend_mode(rgb, intensity, **kwargs)\n2481             except TypeError as err:\n2482                 raise ValueError('\"blend_mode\" must be callable or one of '\n2483                                  f'{lookup.keys}') from err\n2484 \n2485         # Only apply result where hillshade intensity isn't masked\n2486         if np.ma.is_masked(intensity):\n2487             mask = intensity.mask[..., 0]\n2488             for i in range(3):\n2489                 blend[..., i][mask] = rgb[..., i][mask]\n2490 \n2491         return blend\n2492 \n2493     def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n2494                   hsv_min_val=None, hsv_min_sat=None):\n2495         \"\"\"\n2496         Take the input data array, convert to HSV values in the given colormap,\n2497         then adjust those color values to give the impression of a shaded\n2498         relief map with a specified light source.  RGBA values are returned,\n2499         which can then be used to plot the shaded image with imshow.\n2500 \n2501         The color of the resulting image will be darkened by moving the (s, v)\n2502         values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the\n2503         shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n2504         hsv_max_val) in regions that are illuminated.  The default extremes are\n2505         chose so that completely shaded points are nearly black (s = 1, v = 0)\n2506         and completely illuminated points are nearly white (s = 0, v = 1).\n2507 \n2508         Parameters\n2509         ----------\n2510         rgb : `~numpy.ndarray`\n2511             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n2512         intensity : `~numpy.ndarray`\n2513             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n2514         hsv_max_sat : number, default: 1\n2515             The maximum saturation value that the *intensity* map can shift the\n2516             output image to.\n2517         hsv_min_sat : number, optional\n2518             The minimum saturation value that the *intensity* map can shift the\n2519             output image to. Defaults to 0.\n2520         hsv_max_val : number, optional\n2521             The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n2522             the output image to. Defaults to 1.\n2523         hsv_min_val : number, optional\n2524             The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n2525             the output image to. Defaults to 0.\n2526 \n2527         Returns\n2528         -------\n2529         `~numpy.ndarray`\n2530             An MxNx3 RGB array representing the combined images.\n2531         \"\"\"\n2532         # Backward compatibility...\n2533         if hsv_max_sat is None:\n2534             hsv_max_sat = self.hsv_max_sat\n2535         if hsv_max_val is None:\n2536             hsv_max_val = self.hsv_max_val\n2537         if hsv_min_sat is None:\n2538             hsv_min_sat = self.hsv_min_sat\n2539         if hsv_min_val is None:\n2540             hsv_min_val = self.hsv_min_val\n2541 \n2542         # Expects a 2D intensity array scaled between -1 to 1...\n2543         intensity = intensity[..., 0]\n2544         intensity = 2 * intensity - 1\n2545 \n2546         # Convert to rgb, then rgb to hsv\n2547         hsv = rgb_to_hsv(rgb[:, :, 0:3])\n2548         hue, sat, val = np.moveaxis(hsv, -1, 0)\n2549 \n2550         # Modify hsv values (in place) to simulate illumination.\n2551         # putmask(A, mask, B) <=> A[mask] = B[mask]\n2552         np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n2553                    (1 - intensity) * sat + intensity * hsv_max_sat)\n2554         np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n2555                    (1 + intensity) * sat - intensity * hsv_min_sat)\n2556         np.putmask(val, intensity > 0,\n2557                    (1 - intensity) * val + intensity * hsv_max_val)\n2558         np.putmask(val, intensity < 0,\n2559                    (1 + intensity) * val - intensity * hsv_min_val)\n2560         np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n2561 \n2562         # Convert modified hsv back to rgb.\n2563         return hsv_to_rgb(hsv)\n2564 \n2565     def blend_soft_light(self, rgb, intensity):\n2566         \"\"\"\n2567         Combine an RGB image with an intensity map using \"soft light\" blending,\n2568         using the \"pegtop\" formula.\n2569 \n2570         Parameters\n2571         ----------\n2572         rgb : `~numpy.ndarray`\n2573             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n2574         intensity : `~numpy.ndarray`\n2575             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n2576 \n2577         Returns\n2578         -------\n2579         `~numpy.ndarray`\n2580             An MxNx3 RGB array representing the combined images.\n2581         \"\"\"\n2582         return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n2583 \n2584     def blend_overlay(self, rgb, intensity):\n2585         \"\"\"\n2586         Combine an RGB image with an intensity map using \"overlay\" blending.\n2587 \n2588         Parameters\n2589         ----------\n2590         rgb : `~numpy.ndarray`\n2591             An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n2592         intensity : `~numpy.ndarray`\n2593             An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n2594 \n2595         Returns\n2596         -------\n2597         ndarray\n2598             An MxNx3 RGB array representing the combined images.\n2599         \"\"\"\n2600         low = 2 * intensity * rgb\n2601         high = 1 - 2 * (1 - intensity) * (1 - rgb)\n2602         return np.where(rgb <= 0.5, low, high)\n2603 \n2604 \n2605 def from_levels_and_colors(levels, colors, extend='neither'):\n2606     \"\"\"\n2607     A helper routine to generate a cmap and a norm instance which\n2608     behave similar to contourf's levels and colors arguments.\n2609 \n2610     Parameters\n2611     ----------\n2612     levels : sequence of numbers\n2613         The quantization levels used to construct the `BoundaryNorm`.\n2614         Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.\n2615     colors : sequence of colors\n2616         The fill color to use for each level. If *extend* is \"neither\" there\n2617         must be ``n_level - 1`` colors. For an *extend* of \"min\" or \"max\" add\n2618         one extra color, and for an *extend* of \"both\" add two colors.\n2619     extend : {'neither', 'min', 'max', 'both'}, optional\n2620         The behaviour when a value falls out of range of the given levels.\n2621         See `~.Axes.contourf` for details.\n2622 \n2623     Returns\n2624     -------\n2625     cmap : `~matplotlib.colors.Normalize`\n2626     norm : `~matplotlib.colors.Colormap`\n2627     \"\"\"\n2628     slice_map = {\n2629         'both': slice(1, -1),\n2630         'min': slice(1, None),\n2631         'max': slice(0, -1),\n2632         'neither': slice(0, None),\n2633     }\n2634     _api.check_in_list(slice_map, extend=extend)\n2635     color_slice = slice_map[extend]\n2636 \n2637     n_data_colors = len(levels) - 1\n2638     n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)\n2639     if len(colors) != n_expected:\n2640         raise ValueError(\n2641             f'With extend == {extend!r} and {len(levels)} levels, '\n2642             f'expected {n_expected} colors, but got {len(colors)}')\n2643 \n2644     cmap = ListedColormap(colors[color_slice], N=n_data_colors)\n2645 \n2646     if extend in ['min', 'both']:\n2647         cmap.set_under(colors[0])\n2648     else:\n2649         cmap.set_under('none')\n2650 \n2651     if extend in ['max', 'both']:\n2652         cmap.set_over(colors[-1])\n2653     else:\n2654         cmap.set_over('none')\n2655 \n2656     cmap.colorbar_extend = extend\n2657 \n2658     norm = BoundaryNorm(levels, ncolors=n_data_colors)\n2659     return cmap, norm\n",
        "intended_behavior": "Ensure that any updates to `vmin` and `vmax` after the initial setting are validated and processed in a manner that acknowledges the constraints of logarithmic scaling (i.e., both must be positive, and `vmin` must be less than `vmax`). It would involve dynamically recalculating the normalized values and applying them without causing errors under valid configurations."
    },
    {
        "rel_file_path": "lib/matplotlib/colorbar.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.6/lib/matplotlib/colorbar.py",
        "start": 1,
        "end": 1594,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Colorbars are a visualization of the mapping from scalar values to colors.\n3 In Matplotlib they are drawn into a dedicated `~.axes.Axes`.\n4 \n5 .. note::\n6    Colorbars are typically created through `.Figure.colorbar` or its pyplot\n7    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with\n8    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for\n9    non-`.GridSpec`-positioned axes).\n10 \n11    End-users most likely won't need to directly use this module's API.\n12 \"\"\"\n13 \n14 import logging\n15 \n16 import numpy as np\n17 \n18 import matplotlib as mpl\n19 from matplotlib import _api, cbook, collections, cm, colors, contour, ticker\n20 import matplotlib.artist as martist\n21 import matplotlib.patches as mpatches\n22 import matplotlib.path as mpath\n23 import matplotlib.spines as mspines\n24 import matplotlib.transforms as mtransforms\n25 from matplotlib import _docstring\n26 \n27 _log = logging.getLogger(__name__)\n28 \n29 _docstring.interpd.update(\n30     _make_axes_kw_doc=\"\"\"\n31 location : None or {'left', 'right', 'top', 'bottom'}\n32     The location, relative to the parent axes, where the colorbar axes\n33     is created.  It also determines the *orientation* of the colorbar\n34     (colorbars on the left and right are vertical, colorbars at the top\n35     and bottom are horizontal).  If None, the location will come from the\n36     *orientation* if it is set (vertical colorbars on the right, horizontal\n37     ones at the bottom), or default to 'right' if *orientation* is unset.\n38 \n39 orientation : None or {'vertical', 'horizontal'}\n40     The orientation of the colorbar.  It is preferable to set the *location*\n41     of the colorbar, as that also determines the *orientation*; passing\n42     incompatible values for *location* and *orientation* raises an exception.\n43 \n44 fraction : float, default: 0.15\n45     Fraction of original axes to use for colorbar.\n46 \n47 shrink : float, default: 1.0\n48     Fraction by which to multiply the size of the colorbar.\n49 \n50 aspect : float, default: 20\n51     Ratio of long to short dimensions.\n52 \n53 pad : float, default: 0.05 if vertical, 0.15 if horizontal\n54     Fraction of original axes between colorbar and new image axes.\n55 \n56 anchor : (float, float), optional\n57     The anchor point of the colorbar axes.\n58     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.\n59 \n60 panchor : (float, float), or *False*, optional\n61     The anchor point of the colorbar parent axes. If *False*, the parent\n62     axes' anchor will be unchanged.\n63     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.\"\"\",\n64     _colormap_kw_doc=\"\"\"\n65 extend : {'neither', 'both', 'min', 'max'}\n66     Make pointed end(s) for out-of-range values (unless 'neither').  These are\n67     set for a given colormap using the colormap set_under and set_over methods.\n68 \n69 extendfrac : {*None*, 'auto', length, lengths}\n70     If set to *None*, both the minimum and maximum triangular colorbar\n71     extensions will have a length of 5% of the interior colorbar length (this\n72     is the default setting).\n73 \n74     If set to 'auto', makes the triangular colorbar extensions the same lengths\n75     as the interior boxes (when *spacing* is set to 'uniform') or the same\n76     lengths as the respective adjacent interior boxes (when *spacing* is set to\n77     'proportional').\n78 \n79     If a scalar, indicates the length of both the minimum and maximum\n80     triangular colorbar extensions as a fraction of the interior colorbar\n81     length.  A two-element sequence of fractions may also be given, indicating\n82     the lengths of the minimum and maximum colorbar extensions respectively as\n83     a fraction of the interior colorbar length.\n84 \n85 extendrect : bool\n86     If *False* the minimum and maximum colorbar extensions will be triangular\n87     (the default).  If *True* the extensions will be rectangular.\n88 \n89 spacing : {'uniform', 'proportional'}\n90     For discrete colorbars (`.BoundaryNorm` or contours), 'uniform' gives each\n91     color the same space; 'proportional' makes the space proportional to the\n92     data interval.\n93 \n94 ticks : None or list of ticks or Locator\n95     If None, ticks are determined automatically from the input.\n96 \n97 format : None or str or Formatter\n98     If None, `~.ticker.ScalarFormatter` is used.\n99     Format strings, e.g., ``\"%4.2e\"`` or ``\"{x:.2e}\"``, are supported.\n100     An alternative `~.ticker.Formatter` may be given instead.\n101 \n102 drawedges : bool\n103     Whether to draw lines at color boundaries.\n104 \n105 label : str\n106     The label on the colorbar's long axis.\n107 \n108 boundaries, values : None or a sequence\n109     If unset, the colormap will be displayed on a 0-1 scale.\n110     If sequences, *values* must have a length 1 less than *boundaries*.  For\n111     each region delimited by adjacent entries in *boundaries*, the color mapped\n112     to the corresponding value in values will be used.\n113     Normally only useful for indexed colors (i.e. ``norm=NoNorm()``) or other\n114     unusual circumstances.\"\"\")\n115 \n116 \n117 def _set_ticks_on_axis_warn(*args, **kwargs):\n118     # a top level function which gets put in at the axes'\n119     # set_xticks and set_yticks by Colorbar.__init__.\n120     _api.warn_external(\"Use the colorbar set_ticks() method instead.\")\n121 \n122 \n123 class _ColorbarSpine(mspines.Spine):\n124     def __init__(self, axes):\n125         self._ax = axes\n126         super().__init__(axes, 'colorbar', mpath.Path(np.empty((0, 2))))\n127         mpatches.Patch.set_transform(self, axes.transAxes)\n128 \n129     def get_window_extent(self, renderer=None):\n130         # This Spine has no Axis associated with it, and doesn't need to adjust\n131         # its location, so we can directly get the window extent from the\n132         # super-super-class.\n133         return mpatches.Patch.get_window_extent(self, renderer=renderer)\n134 \n135     def set_xy(self, xy):\n136         self._path = mpath.Path(xy, closed=True)\n137         self._xy = xy\n138         self.stale = True\n139 \n140     def draw(self, renderer):\n141         ret = mpatches.Patch.draw(self, renderer)\n142         self.stale = False\n143         return ret\n144 \n145 \n146 class _ColorbarAxesLocator:\n147     \"\"\"\n148     Shrink the axes if there are triangular or rectangular extends.\n149     \"\"\"\n150     def __init__(self, cbar):\n151         self._cbar = cbar\n152         self._orig_locator = cbar.ax._axes_locator\n153 \n154     def __call__(self, ax, renderer):\n155         if self._orig_locator is not None:\n156             pos = self._orig_locator(ax, renderer)\n157         else:\n158             pos = ax.get_position(original=True)\n159         if self._cbar.extend == 'neither':\n160             return pos\n161 \n162         y, extendlen = self._cbar._proportional_y()\n163         if not self._cbar._extend_lower():\n164             extendlen[0] = 0\n165         if not self._cbar._extend_upper():\n166             extendlen[1] = 0\n167         len = sum(extendlen) + 1\n168         shrink = 1 / len\n169         offset = extendlen[0] / len\n170         # we need to reset the aspect ratio of the axes to account\n171         # of the extends...\n172         if hasattr(ax, '_colorbar_info'):\n173             aspect = ax._colorbar_info['aspect']\n174         else:\n175             aspect = False\n176         # now shrink and/or offset to take into account the\n177         # extend tri/rectangles.\n178         if self._cbar.orientation == 'vertical':\n179             if aspect:\n180                 self._cbar.ax.set_box_aspect(aspect*shrink)\n181             pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)\n182         else:\n183             if aspect:\n184                 self._cbar.ax.set_box_aspect(1/(aspect * shrink))\n185             pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)\n186         return pos\n187 \n188     def get_subplotspec(self):\n189         # make tight_layout happy..\n190         return (\n191             self._cbar.ax.get_subplotspec()\n192             or getattr(self._orig_locator, \"get_subplotspec\", lambda: None)())\n193 \n194 \n195 @_docstring.interpd\n196 class Colorbar:\n197     r\"\"\"\n198     Draw a colorbar in an existing axes.\n199 \n200     Typically, colorbars are created using `.Figure.colorbar` or\n201     `.pyplot.colorbar` and associated with `.ScalarMappable`\\s (such as an\n202     `.AxesImage` generated via `~.axes.Axes.imshow`).\n203 \n204     In order to draw a colorbar not associated with other elements in the\n205     figure, e.g. when showing a colormap by itself, one can create an empty\n206     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*\n207     to `Colorbar`.\n208 \n209     Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n210 \n211     Attributes\n212     ----------\n213     ax : `~matplotlib.axes.Axes`\n214         The `~.axes.Axes` instance in which the colorbar is drawn.\n215     lines : list\n216         A list of `.LineCollection` (empty if no lines were drawn).\n217     dividers : `.LineCollection`\n218         A LineCollection (empty if *drawedges* is ``False``).\n219 \n220     Parameters\n221     ----------\n222     ax : `~matplotlib.axes.Axes`\n223         The `~.axes.Axes` instance in which the colorbar is drawn.\n224 \n225     mappable : `.ScalarMappable`\n226         The mappable whose colormap and norm will be used.\n227 \n228         To show the under- and over- value colors, the mappable's norm should\n229         be specified as ::\n230 \n231             norm = colors.Normalize(clip=False)\n232 \n233         To show the colors versus index instead of on a 0-1 scale, use::\n234 \n235             norm=colors.NoNorm()\n236 \n237     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n238         The colormap to use.  This parameter is ignored, unless *mappable* is\n239         None.\n240 \n241     norm : `~matplotlib.colors.Normalize`\n242         The normalization to use.  This parameter is ignored, unless *mappable*\n243         is None.\n244 \n245     alpha : float\n246         The colorbar transparency between 0 (transparent) and 1 (opaque).\n247 \n248     orientation : None or {'vertical', 'horizontal'}\n249         If None, use the value determined by *location*. If both\n250         *orientation* and *location* are None then defaults to 'vertical'.\n251 \n252     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}\n253         The location of the colorbar ticks. The *ticklocation* must match\n254         *orientation*. For example, a horizontal colorbar can only have ticks\n255         at the top or the bottom. If 'auto', the ticks will be the same as\n256         *location*, so a colorbar to the left will have ticks to the left. If\n257         *location* is None, the ticks will be at the bottom for a horizontal\n258         colorbar and at the right for a vertical.\n259 \n260     drawedges : bool\n261         Whether to draw lines at color boundaries.\n262 \n263     filled : bool\n264 \n265     %(_colormap_kw_doc)s\n266 \n267     location : None or {'left', 'right', 'top', 'bottom'}\n268         Set the *orientation* and *ticklocation* of the colorbar using a\n269         single argument. Colorbars on the left and right are vertical,\n270         colorbars at the top and bottom are horizontal. The *ticklocation* is\n271         the same as *location*, so if *location* is 'top', the ticks are on\n272         the top. *orientation* and/or *ticklocation* can be provided as well\n273         and overrides the value set by *location*, but there will be an error\n274         for incompatible combinations.\n275 \n276         .. versionadded:: 3.7\n277     \"\"\"\n278 \n279     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n280 \n281     @_api.delete_parameter(\"3.6\", \"filled\")\n282     def __init__(self, ax, mappable=None, *, cmap=None,\n283                  norm=None,\n284                  alpha=None,\n285                  values=None,\n286                  boundaries=None,\n287                  orientation=None,\n288                  ticklocation='auto',\n289                  extend=None,\n290                  spacing='uniform',  # uniform or proportional\n291                  ticks=None,\n292                  format=None,\n293                  drawedges=False,\n294                  filled=True,\n295                  extendfrac=None,\n296                  extendrect=False,\n297                  label='',\n298                  location=None,\n299                  ):\n300 \n301         if mappable is None:\n302             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n303 \n304         # Ensure the given mappable's norm has appropriate vmin and vmax\n305         # set even if mappable.draw has not yet been called.\n306         if mappable.get_array() is not None:\n307             mappable.autoscale_None()\n308 \n309         self.mappable = mappable\n310         cmap = mappable.cmap\n311         norm = mappable.norm\n312 \n313         if isinstance(mappable, contour.ContourSet):\n314             cs = mappable\n315             alpha = cs.get_alpha()\n316             boundaries = cs._levels\n317             values = cs.cvalues\n318             extend = cs.extend\n319             filled = cs.filled\n320             if ticks is None:\n321                 ticks = ticker.FixedLocator(cs.levels, nbins=10)\n322         elif isinstance(mappable, martist.Artist):\n323             alpha = mappable.get_alpha()\n324 \n325         mappable.colorbar = self\n326         mappable.colorbar_cid = mappable.callbacks.connect(\n327             'changed', self.update_normal)\n328 \n329         location_orientation = _get_orientation_from_location(location)\n330 \n331         _api.check_in_list(\n332             [None, 'vertical', 'horizontal'], orientation=orientation)\n333         _api.check_in_list(\n334             ['auto', 'left', 'right', 'top', 'bottom'],\n335             ticklocation=ticklocation)\n336         _api.check_in_list(\n337             ['uniform', 'proportional'], spacing=spacing)\n338 \n339         if location_orientation is not None and orientation is not None:\n340             if location_orientation != orientation:\n341                 raise TypeError(\n342                     \"location and orientation are mutually exclusive\")\n343         else:\n344             orientation = orientation or location_orientation or \"vertical\"\n345 \n346         self.ax = ax\n347         self.ax._axes_locator = _ColorbarAxesLocator(self)\n348 \n349         if extend is None:\n350             if (not isinstance(mappable, contour.ContourSet)\n351                     and getattr(cmap, 'colorbar_extend', False) is not False):\n352                 extend = cmap.colorbar_extend\n353             elif hasattr(norm, 'extend'):\n354                 extend = norm.extend\n355             else:\n356                 extend = 'neither'\n357         self.alpha = None\n358         # Call set_alpha to handle array-like alphas properly\n359         self.set_alpha(alpha)\n360         self.cmap = cmap\n361         self.norm = norm\n362         self.values = values\n363         self.boundaries = boundaries\n364         self.extend = extend\n365         self._inside = _api.check_getitem(\n366             {'neither': slice(0, None), 'both': slice(1, -1),\n367              'min': slice(1, None), 'max': slice(0, -1)},\n368             extend=extend)\n369         self.spacing = spacing\n370         self.orientation = orientation\n371         self.drawedges = drawedges\n372         self._filled = filled\n373         self.extendfrac = extendfrac\n374         self.extendrect = extendrect\n375         self._extend_patches = []\n376         self.solids = None\n377         self.solids_patches = []\n378         self.lines = []\n379 \n380         for spine in self.ax.spines.values():\n381             spine.set_visible(False)\n382         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n383 \n384         self.dividers = collections.LineCollection(\n385             [],\n386             colors=[mpl.rcParams['axes.edgecolor']],\n387             linewidths=[0.5 * mpl.rcParams['axes.linewidth']],\n388             clip_on=False)\n389         self.ax.add_collection(self.dividers)\n390 \n391         self._locator = None\n392         self._minorlocator = None\n393         self._formatter = None\n394         self._minorformatter = None\n395 \n396         if ticklocation == 'auto':\n397             ticklocation = _get_ticklocation_from_orientation(\n398                 orientation) if location is None else location\n399         self.ticklocation = ticklocation\n400 \n401         self.set_label(label)\n402         self._reset_locator_formatter_scale()\n403 \n404         if np.iterable(ticks):\n405             self._locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n406         else:\n407             self._locator = ticks\n408 \n409         if isinstance(format, str):\n410             # Check format between FormatStrFormatter and StrMethodFormatter\n411             try:\n412                 self._formatter = ticker.FormatStrFormatter(format)\n413                 _ = self._formatter(0)\n414             except TypeError:\n415                 self._formatter = ticker.StrMethodFormatter(format)\n416         else:\n417             self._formatter = format  # Assume it is a Formatter or None\n418         self._draw_all()\n419 \n420         if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n421             self.add_lines(mappable)\n422 \n423         # Link the Axes and Colorbar for interactive use\n424         self.ax._colorbar = self\n425         # Don't navigate on any of these types of mappables\n426         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or\n427                 isinstance(self.mappable, contour.ContourSet)):\n428             self.ax.set_navigate(False)\n429 \n430         # These are the functions that set up interactivity on this colorbar\n431         self._interactive_funcs = [\"_get_view\", \"_set_view\",\n432                                    \"_set_view_from_bbox\", \"drag_pan\"]\n433         for x in self._interactive_funcs:\n434             setattr(self.ax, x, getattr(self, x))\n435         # Set the cla function to the cbar's method to override it\n436         self.ax.cla = self._cbar_cla\n437         # Callbacks for the extend calculations to handle inverting the axis\n438         self._extend_cid1 = self.ax.callbacks.connect(\n439             \"xlim_changed\", self._do_extends)\n440         self._extend_cid2 = self.ax.callbacks.connect(\n441             \"ylim_changed\", self._do_extends)\n442 \n443     @property\n444     def locator(self):\n445         \"\"\"Major tick `.Locator` for the colorbar.\"\"\"\n446         return self._long_axis().get_major_locator()\n447 \n448     @locator.setter\n449     def locator(self, loc):\n450         self._long_axis().set_major_locator(loc)\n451         self._locator = loc\n452 \n453     @property\n454     def minorlocator(self):\n455         \"\"\"Minor tick `.Locator` for the colorbar.\"\"\"\n456         return self._long_axis().get_minor_locator()\n457 \n458     @minorlocator.setter\n459     def minorlocator(self, loc):\n460         self._long_axis().set_minor_locator(loc)\n461         self._minorlocator = loc\n462 \n463     @property\n464     def formatter(self):\n465         \"\"\"Major tick label `.Formatter` for the colorbar.\"\"\"\n466         return self._long_axis().get_major_formatter()\n467 \n468     @formatter.setter\n469     def formatter(self, fmt):\n470         self._long_axis().set_major_formatter(fmt)\n471         self._formatter = fmt\n472 \n473     @property\n474     def minorformatter(self):\n475         \"\"\"Minor tick `.Formatter` for the colorbar.\"\"\"\n476         return self._long_axis().get_minor_formatter()\n477 \n478     @minorformatter.setter\n479     def minorformatter(self, fmt):\n480         self._long_axis().set_minor_formatter(fmt)\n481         self._minorformatter = fmt\n482 \n483     def _cbar_cla(self):\n484         \"\"\"Function to clear the interactive colorbar state.\"\"\"\n485         for x in self._interactive_funcs:\n486             delattr(self.ax, x)\n487         # We now restore the old cla() back and can call it directly\n488         del self.ax.cla\n489         self.ax.cla()\n490 \n491     filled = _api.deprecate_privatize_attribute(\"3.6\")\n492 \n493     def update_normal(self, mappable):\n494         \"\"\"\n495         Update solid patches, lines, etc.\n496 \n497         This is meant to be called when the norm of the image or contour plot\n498         to which this colorbar belongs changes.\n499 \n500         If the norm on the mappable is different than before, this resets the\n501         locator and formatter for the axis, so if these have been customized,\n502         they will need to be customized again.  However, if the norm only\n503         changes values of *vmin*, *vmax* or *cmap* then the old formatter\n504         and locator will be preserved.\n505         \"\"\"\n506         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n507         self.mappable = mappable\n508         self.set_alpha(mappable.get_alpha())\n509         self.cmap = mappable.cmap\n510         if mappable.norm != self.norm:\n511             self.norm = mappable.norm\n512             self._reset_locator_formatter_scale()\n513 \n514         self._draw_all()\n515         if isinstance(self.mappable, contour.ContourSet):\n516             CS = self.mappable\n517             if not CS.filled:\n518                 self.add_lines(CS)\n519         self.stale = True\n520 \n521     @_api.deprecated(\"3.6\", alternative=\"fig.draw_without_rendering()\")\n522     def draw_all(self):\n523         \"\"\"\n524         Calculate any free parameters based on the current cmap and norm,\n525         and do all the drawing.\n526         \"\"\"\n527         self._draw_all()\n528 \n529     def _draw_all(self):\n530         \"\"\"\n531         Calculate any free parameters based on the current cmap and norm,\n532         and do all the drawing.\n533         \"\"\"\n534         if self.orientation == 'vertical':\n535             if mpl.rcParams['ytick.minor.visible']:\n536                 self.minorticks_on()\n537         else:\n538             if mpl.rcParams['xtick.minor.visible']:\n539                 self.minorticks_on()\n540         self._long_axis().set(label_position=self.ticklocation,\n541                               ticks_position=self.ticklocation)\n542         self._short_axis().set_ticks([])\n543         self._short_axis().set_ticks([], minor=True)\n544 \n545         # Set self._boundaries and self._values, including extensions.\n546         # self._boundaries are the edges of each square of color, and\n547         # self._values are the value to map into the norm to get the\n548         # color:\n549         self._process_values()\n550         # Set self.vmin and self.vmax to first and last boundary, excluding\n551         # extensions:\n552         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]\n553         # Compute the X/Y mesh.\n554         X, Y = self._mesh()\n555         # draw the extend triangles, and shrink the inner axes to accommodate.\n556         # also adds the outline path to self.outline spine:\n557         self._do_extends()\n558         lower, upper = self.vmin, self.vmax\n559         if self._long_axis().get_inverted():\n560             # If the axis is inverted, we need to swap the vmin/vmax\n561             lower, upper = upper, lower\n562         if self.orientation == 'vertical':\n563             self.ax.set_xlim(0, 1)\n564             self.ax.set_ylim(lower, upper)\n565         else:\n566             self.ax.set_ylim(0, 1)\n567             self.ax.set_xlim(lower, upper)\n568 \n569         # set up the tick locators and formatters.  A bit complicated because\n570         # boundary norms + uniform spacing requires a manual locator.\n571         self.update_ticks()\n572 \n573         if self._filled:\n574             ind = np.arange(len(self._values))\n575             if self._extend_lower():\n576                 ind = ind[1:]\n577             if self._extend_upper():\n578                 ind = ind[:-1]\n579             self._add_solids(X, Y, self._values[ind, np.newaxis])\n580 \n581     def _add_solids(self, X, Y, C):\n582         \"\"\"Draw the colors; optionally add separators.\"\"\"\n583         # Cleanup previously set artists.\n584         if self.solids is not None:\n585             self.solids.remove()\n586         for solid in self.solids_patches:\n587             solid.remove()\n588         # Add new artist(s), based on mappable type.  Use individual patches if\n589         # hatching is needed, pcolormesh otherwise.\n590         mappable = getattr(self, 'mappable', None)\n591         if (isinstance(mappable, contour.ContourSet)\n592                 and any(hatch is not None for hatch in mappable.hatches)):\n593             self._add_solids_patches(X, Y, C, mappable)\n594         else:\n595             self.solids = self.ax.pcolormesh(\n596                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,\n597                 edgecolors='none', shading='flat')\n598             if not self.drawedges:\n599                 if len(self._y) >= self.n_rasterize:\n600                     self.solids.set_rasterized(True)\n601         self._update_dividers()\n602 \n603     def _update_dividers(self):\n604         if not self.drawedges:\n605             self.dividers.set_segments([])\n606             return\n607         # Place all *internal* dividers.\n608         if self.orientation == 'vertical':\n609             lims = self.ax.get_ylim()\n610             bounds = (lims[0] < self._y) & (self._y < lims[1])\n611         else:\n612             lims = self.ax.get_xlim()\n613             bounds = (lims[0] < self._y) & (self._y < lims[1])\n614         y = self._y[bounds]\n615         # And then add outer dividers if extensions are on.\n616         if self._extend_lower():\n617             y = np.insert(y, 0, lims[0])\n618         if self._extend_upper():\n619             y = np.append(y, lims[1])\n620         X, Y = np.meshgrid([0, 1], y)\n621         if self.orientation == 'vertical':\n622             segments = np.dstack([X, Y])\n623         else:\n624             segments = np.dstack([Y, X])\n625         self.dividers.set_segments(segments)\n626 \n627     def _add_solids_patches(self, X, Y, C, mappable):\n628         hatches = mappable.hatches * (len(C) + 1)  # Have enough hatches.\n629         if self._extend_lower():\n630             # remove first hatch that goes into the extend patch\n631             hatches = hatches[1:]\n632         patches = []\n633         for i in range(len(X) - 1):\n634             xy = np.array([[X[i, 0], Y[i, 1]],\n635                            [X[i, 1], Y[i, 0]],\n636                            [X[i + 1, 1], Y[i + 1, 0]],\n637                            [X[i + 1, 0], Y[i + 1, 1]]])\n638             patch = mpatches.PathPatch(mpath.Path(xy),\n639                                        facecolor=self.cmap(self.norm(C[i][0])),\n640                                        hatch=hatches[i], linewidth=0,\n641                                        antialiased=False, alpha=self.alpha)\n642             self.ax.add_patch(patch)\n643             patches.append(patch)\n644         self.solids_patches = patches\n645 \n646     def _do_extends(self, ax=None):\n647         \"\"\"\n648         Add the extend tri/rectangles on the outside of the axes.\n649 \n650         ax is unused, but required due to the callbacks on xlim/ylim changed\n651         \"\"\"\n652         # Clean up any previous extend patches\n653         for patch in self._extend_patches:\n654             patch.remove()\n655         self._extend_patches = []\n656         # extend lengths are fraction of the *inner* part of colorbar,\n657         # not the total colorbar:\n658         _, extendlen = self._proportional_y()\n659         bot = 0 - (extendlen[0] if self._extend_lower() else 0)\n660         top = 1 + (extendlen[1] if self._extend_upper() else 0)\n661 \n662         # xyout is the outline of the colorbar including the extend patches:\n663         if not self.extendrect:\n664             # triangle:\n665             xyout = np.array([[0, 0], [0.5, bot], [1, 0],\n666                               [1, 1], [0.5, top], [0, 1], [0, 0]])\n667         else:\n668             # rectangle:\n669             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],\n670                               [1, 1], [1, top], [0, top], [0, 1],\n671                               [0, 0]])\n672 \n673         if self.orientation == 'horizontal':\n674             xyout = xyout[:, ::-1]\n675 \n676         # xyout is the path for the spine:\n677         self.outline.set_xy(xyout)\n678         if not self._filled:\n679             return\n680 \n681         # Make extend triangles or rectangles filled patches.  These are\n682         # defined in the outer parent axes' coordinates:\n683         mappable = getattr(self, 'mappable', None)\n684         if (isinstance(mappable, contour.ContourSet)\n685                 and any(hatch is not None for hatch in mappable.hatches)):\n686             hatches = mappable.hatches * (len(self._y) + 1)\n687         else:\n688             hatches = [None] * (len(self._y) + 1)\n689 \n690         if self._extend_lower():\n691             if not self.extendrect:\n692                 # triangle\n693                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])\n694             else:\n695                 # rectangle\n696                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])\n697             if self.orientation == 'horizontal':\n698                 xy = xy[:, ::-1]\n699             # add the patch\n700             val = -1 if self._long_axis().get_inverted() else 0\n701             color = self.cmap(self.norm(self._values[val]))\n702             patch = mpatches.PathPatch(\n703                 mpath.Path(xy), facecolor=color, alpha=self.alpha,\n704                 linewidth=0, antialiased=False,\n705                 transform=self.ax.transAxes,\n706                 hatch=hatches[0], clip_on=False,\n707                 # Place it right behind the standard patches, which is\n708                 # needed if we updated the extends\n709                 zorder=np.nextafter(self.ax.patch.zorder, -np.inf))\n710             self.ax.add_patch(patch)\n711             self._extend_patches.append(patch)\n712             # remove first hatch that goes into the extend patch\n713             hatches = hatches[1:]\n714         if self._extend_upper():\n715             if not self.extendrect:\n716                 # triangle\n717                 xy = np.array([[0, 1], [0.5, top], [1, 1]])\n718             else:\n719                 # rectangle\n720                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])\n721             if self.orientation == 'horizontal':\n722                 xy = xy[:, ::-1]\n723             # add the patch\n724             val = 0 if self._long_axis().get_inverted() else -1\n725             color = self.cmap(self.norm(self._values[val]))\n726             hatch_idx = len(self._y) - 1\n727             patch = mpatches.PathPatch(\n728                 mpath.Path(xy), facecolor=color, alpha=self.alpha,\n729                 linewidth=0, antialiased=False,\n730                 transform=self.ax.transAxes, hatch=hatches[hatch_idx],\n731                 clip_on=False,\n732                 # Place it right behind the standard patches, which is\n733                 # needed if we updated the extends\n734                 zorder=np.nextafter(self.ax.patch.zorder, -np.inf))\n735             self.ax.add_patch(patch)\n736             self._extend_patches.append(patch)\n737 \n738         self._update_dividers()\n739 \n740     def add_lines(self, *args, **kwargs):\n741         \"\"\"\n742         Draw lines on the colorbar.\n743 \n744         The lines are appended to the list :attr:`lines`.\n745 \n746         Parameters\n747         ----------\n748         levels : array-like\n749             The positions of the lines.\n750         colors : color or list of colors\n751             Either a single color applying to all lines or one color value for\n752             each line.\n753         linewidths : float or array-like\n754             Either a single linewidth applying to all lines or one linewidth\n755             for each line.\n756         erase : bool, default: True\n757             Whether to remove any previously added lines.\n758 \n759         Notes\n760         -----\n761         Alternatively, this method can also be called with the signature\n762         ``colorbar.add_lines(contour_set, erase=True)``, in which case\n763         *levels*, *colors*, and *linewidths* are taken from *contour_set*.\n764         \"\"\"\n765         params = _api.select_matching_signature(\n766             [lambda self, CS, erase=True: locals(),\n767              lambda self, levels, colors, linewidths, erase=True: locals()],\n768             self, *args, **kwargs)\n769         if \"CS\" in params:\n770             self, CS, erase = params.values()\n771             if not isinstance(CS, contour.ContourSet) or CS.filled:\n772                 raise ValueError(\"If a single artist is passed to add_lines, \"\n773                                  \"it must be a ContourSet of lines\")\n774             # TODO: Make colorbar lines auto-follow changes in contour lines.\n775             return self.add_lines(\n776                 CS.levels,\n777                 [c[0] for c in CS.tcolors],\n778                 [t[0] for t in CS.tlinewidths],\n779                 erase=erase)\n780         else:\n781             self, levels, colors, linewidths, erase = params.values()\n782 \n783         y = self._locate(levels)\n784         rtol = (self._y[-1] - self._y[0]) * 1e-10\n785         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)\n786         y = y[igood]\n787         if np.iterable(colors):\n788             colors = np.asarray(colors)[igood]\n789         if np.iterable(linewidths):\n790             linewidths = np.asarray(linewidths)[igood]\n791         X, Y = np.meshgrid([0, 1], y)\n792         if self.orientation == 'vertical':\n793             xy = np.stack([X, Y], axis=-1)\n794         else:\n795             xy = np.stack([Y, X], axis=-1)\n796         col = collections.LineCollection(xy, linewidths=linewidths,\n797                                          colors=colors)\n798 \n799         if erase and self.lines:\n800             for lc in self.lines:\n801                 lc.remove()\n802             self.lines = []\n803         self.lines.append(col)\n804 \n805         # make a clip path that is just a linewidth bigger than the axes...\n806         fac = np.max(linewidths) / 72\n807         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])\n808         inches = self.ax.get_figure().dpi_scale_trans\n809         # do in inches:\n810         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))\n811         xy[[0, 1, 4], 1] -= fac\n812         xy[[2, 3], 1] += fac\n813         # back to axes units...\n814         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))\n815         col.set_clip_path(mpath.Path(xy, closed=True),\n816                           self.ax.transAxes)\n817         self.ax.add_collection(col)\n818         self.stale = True\n819 \n820     def update_ticks(self):\n821         \"\"\"\n822         Set up the ticks and ticklabels. This should not be needed by users.\n823         \"\"\"\n824         # Get the locator and formatter; defaults to self._locator if not None.\n825         self._get_ticker_locator_formatter()\n826         self._long_axis().set_major_locator(self._locator)\n827         self._long_axis().set_minor_locator(self._minorlocator)\n828         self._long_axis().set_major_formatter(self._formatter)\n829 \n830     def _get_ticker_locator_formatter(self):\n831         \"\"\"\n832         Return the ``locator`` and ``formatter`` of the colorbar.\n833 \n834         If they have not been defined (i.e. are *None*), the formatter and\n835         locator are retrieved from the axis, or from the value of the\n836         boundaries for a boundary norm.\n837 \n838         Called by update_ticks...\n839         \"\"\"\n840         locator = self._locator\n841         formatter = self._formatter\n842         minorlocator = self._minorlocator\n843         if isinstance(self.norm, colors.BoundaryNorm):\n844             b = self.norm.boundaries\n845             if locator is None:\n846                 locator = ticker.FixedLocator(b, nbins=10)\n847             if minorlocator is None:\n848                 minorlocator = ticker.FixedLocator(b)\n849         elif isinstance(self.norm, colors.NoNorm):\n850             if locator is None:\n851                 # put ticks on integers between the boundaries of NoNorm\n852                 nv = len(self._values)\n853                 base = 1 + int(nv / 10)\n854                 locator = ticker.IndexLocator(base=base, offset=.5)\n855         elif self.boundaries is not None:\n856             b = self._boundaries[self._inside]\n857             if locator is None:\n858                 locator = ticker.FixedLocator(b, nbins=10)\n859         else:  # most cases:\n860             if locator is None:\n861                 # we haven't set the locator explicitly, so use the default\n862                 # for this axis:\n863                 locator = self._long_axis().get_major_locator()\n864             if minorlocator is None:\n865                 minorlocator = self._long_axis().get_minor_locator()\n866 \n867         if minorlocator is None:\n868             minorlocator = ticker.NullLocator()\n869 \n870         if formatter is None:\n871             formatter = self._long_axis().get_major_formatter()\n872 \n873         self._locator = locator\n874         self._formatter = formatter\n875         self._minorlocator = minorlocator\n876         _log.debug('locator: %r', locator)\n877 \n878     def set_ticks(self, ticks, *, labels=None, minor=False, **kwargs):\n879         \"\"\"\n880         Set tick locations.\n881 \n882         Parameters\n883         ----------\n884         ticks : list of floats\n885             List of tick locations.\n886         labels : list of str, optional\n887             List of tick labels. If not set, the labels show the data value.\n888         minor : bool, default: False\n889             If ``False``, set the major ticks; if ``True``, the minor ticks.\n890         **kwargs\n891             `.Text` properties for the labels. These take effect only if you\n892             pass *labels*. In other cases, please use `~.Axes.tick_params`.\n893         \"\"\"\n894         if np.iterable(ticks):\n895             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,\n896                                         **kwargs)\n897             self._locator = self._long_axis().get_major_locator()\n898         else:\n899             self._locator = ticks\n900             self._long_axis().set_major_locator(self._locator)\n901         self.stale = True\n902 \n903     def get_ticks(self, minor=False):\n904         \"\"\"\n905         Return the ticks as a list of locations.\n906 \n907         Parameters\n908         ----------\n909         minor : boolean, default: False\n910             if True return the minor ticks.\n911         \"\"\"\n912         if minor:\n913             return self._long_axis().get_minorticklocs()\n914         else:\n915             return self._long_axis().get_majorticklocs()\n916 \n917     def set_ticklabels(self, ticklabels, *, minor=False, **kwargs):\n918         \"\"\"\n919         [*Discouraged*] Set tick labels.\n920 \n921         .. admonition:: Discouraged\n922 \n923             The use of this method is discouraged, because of the dependency\n924             on tick positions. In most cases, you'll want to use\n925             ``set_ticks(positions, labels=labels)`` instead.\n926 \n927             If you are using this method, you should always fix the tick\n928             positions before, e.g. by using `.Colorbar.set_ticks` or by\n929             explicitly setting a `~.ticker.FixedLocator` on the long axis\n930             of the colorbar. Otherwise, ticks are free to move and the\n931             labels may end up in unexpected positions.\n932 \n933         Parameters\n934         ----------\n935         ticklabels : sequence of str or of `.Text`\n936             Texts for labeling each tick location in the sequence set by\n937             `.Colorbar.set_ticks`; the number of labels must match the number\n938             of locations.\n939 \n940         update_ticks : bool, default: True\n941             This keyword argument is ignored and will be removed.\n942             Deprecated\n943 \n944          minor : bool\n945             If True, set minor ticks instead of major ticks.\n946 \n947         **kwargs\n948             `.Text` properties for the labels.\n949         \"\"\"\n950         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)\n951 \n952     def minorticks_on(self):\n953         \"\"\"\n954         Turn on colorbar minor ticks.\n955         \"\"\"\n956         self.ax.minorticks_on()\n957         self._short_axis().set_minor_locator(ticker.NullLocator())\n958 \n959     def minorticks_off(self):\n960         \"\"\"Turn the minor ticks of the colorbar off.\"\"\"\n961         self._minorlocator = ticker.NullLocator()\n962         self._long_axis().set_minor_locator(self._minorlocator)\n963 \n964     def set_label(self, label, *, loc=None, **kwargs):\n965         \"\"\"\n966         Add a label to the long axis of the colorbar.\n967 \n968         Parameters\n969         ----------\n970         label : str\n971             The label text.\n972         loc : str, optional\n973             The location of the label.\n974 \n975             - For horizontal orientation one of {'left', 'center', 'right'}\n976             - For vertical orientation one of {'bottom', 'center', 'top'}\n977 \n978             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`\n979             depending on the orientation.\n980         **kwargs\n981             Keyword arguments are passed to `~.Axes.set_xlabel` /\n982             `~.Axes.set_ylabel`.\n983             Supported keywords are *labelpad* and `.Text` properties.\n984         \"\"\"\n985         if self.orientation == \"vertical\":\n986             self.ax.set_ylabel(label, loc=loc, **kwargs)\n987         else:\n988             self.ax.set_xlabel(label, loc=loc, **kwargs)\n989         self.stale = True\n990 \n991     def set_alpha(self, alpha):\n992         \"\"\"\n993         Set the transparency between 0 (transparent) and 1 (opaque).\n994 \n995         If an array is provided, *alpha* will be set to None to use the\n996         transparency values associated with the colormap.\n997         \"\"\"\n998         self.alpha = None if isinstance(alpha, np.ndarray) else alpha\n999 \n1000     def _set_scale(self, scale, **kwargs):\n1001         \"\"\"\n1002         Set the colorbar long axis scale.\n1003 \n1004         Parameters\n1005         ----------\n1006         value : {\"linear\", \"log\", \"symlog\", \"logit\", ...} or `.ScaleBase`\n1007             The axis scale type to apply.\n1008 \n1009         **kwargs\n1010             Different keyword arguments are accepted, depending on the scale.\n1011             See the respective class keyword arguments:\n1012 \n1013             - `matplotlib.scale.LinearScale`\n1014             - `matplotlib.scale.LogScale`\n1015             - `matplotlib.scale.SymmetricalLogScale`\n1016             - `matplotlib.scale.LogitScale`\n1017             - `matplotlib.scale.FuncScale`\n1018 \n1019         Notes\n1020         -----\n1021         By default, Matplotlib supports the above-mentioned scales.\n1022         Additionally, custom scales may be registered using\n1023         `matplotlib.scale.register_scale`. These scales can then also\n1024         be used here.\n1025         \"\"\"\n1026         self._long_axis()._set_axes_scale(scale, **kwargs)\n1027 \n1028     def remove(self):\n1029         \"\"\"\n1030         Remove this colorbar from the figure.\n1031 \n1032         If the colorbar was created with ``use_gridspec=True`` the previous\n1033         gridspec is restored.\n1034         \"\"\"\n1035         if hasattr(self.ax, '_colorbar_info'):\n1036             parents = self.ax._colorbar_info['parents']\n1037             for a in parents:\n1038                 if self.ax in a._colorbars:\n1039                     a._colorbars.remove(self.ax)\n1040 \n1041         self.ax.remove()\n1042 \n1043         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)\n1044         self.mappable.colorbar = None\n1045         self.mappable.colorbar_cid = None\n1046         # Remove the extension callbacks\n1047         self.ax.callbacks.disconnect(self._extend_cid1)\n1048         self.ax.callbacks.disconnect(self._extend_cid2)\n1049 \n1050         try:\n1051             ax = self.mappable.axes\n1052         except AttributeError:\n1053             return\n1054         try:\n1055             gs = ax.get_subplotspec().get_gridspec()\n1056             subplotspec = gs.get_topmost_subplotspec()\n1057         except AttributeError:\n1058             # use_gridspec was False\n1059             pos = ax.get_position(original=True)\n1060             ax._set_position(pos)\n1061         else:\n1062             # use_gridspec was True\n1063             ax.set_subplotspec(subplotspec)\n1064 \n1065     def _process_values(self):\n1066         \"\"\"\n1067         Set `_boundaries` and `_values` based on the self.boundaries and\n1068         self.values if not None, or based on the size of the colormap and\n1069         the vmin/vmax of the norm.\n1070         \"\"\"\n1071         if self.values is not None:\n1072             # set self._boundaries from the values...\n1073             self._values = np.array(self.values)\n1074             if self.boundaries is None:\n1075                 # bracket values by 1/2 dv:\n1076                 b = np.zeros(len(self.values) + 1)\n1077                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n1078                 b[0] = 2.0 * b[1] - b[2]\n1079                 b[-1] = 2.0 * b[-2] - b[-3]\n1080                 self._boundaries = b\n1081                 return\n1082             self._boundaries = np.array(self.boundaries)\n1083             return\n1084 \n1085         # otherwise values are set from the boundaries\n1086         if isinstance(self.norm, colors.BoundaryNorm):\n1087             b = self.norm.boundaries\n1088         elif isinstance(self.norm, colors.NoNorm):\n1089             # NoNorm has N blocks, so N+1 boundaries, centered on integers:\n1090             b = np.arange(self.cmap.N + 1) - .5\n1091         elif self.boundaries is not None:\n1092             b = self.boundaries\n1093         else:\n1094             # otherwise make the boundaries from the size of the cmap:\n1095             N = self.cmap.N + 1\n1096             b, _ = self._uniform_y(N)\n1097         # add extra boundaries if needed:\n1098         if self._extend_lower():\n1099             b = np.hstack((b[0] - 1, b))\n1100         if self._extend_upper():\n1101             b = np.hstack((b, b[-1] + 1))\n1102 \n1103         # transform from 0-1 to vmin-vmax:\n1104         if not self.norm.scaled():\n1105             self.norm.vmin = 0\n1106             self.norm.vmax = 1\n1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n1108             self.norm.vmin, self.norm.vmax, expander=0.1)\n1109         if (not isinstance(self.norm, colors.BoundaryNorm) and\n1110                 (self.boundaries is None)):\n1111             b = self.norm.inverse(b)\n1112 \n1113         self._boundaries = np.asarray(b, dtype=float)\n1114         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n1115         if isinstance(self.norm, colors.NoNorm):\n1116             self._values = (self._values + 0.00001).astype(np.int16)\n1117 \n1118     def _mesh(self):\n1119         \"\"\"\n1120         Return the coordinate arrays for the colorbar pcolormesh/patches.\n1121 \n1122         These are scaled between vmin and vmax, and already handle colorbar\n1123         orientation.\n1124         \"\"\"\n1125         y, _ = self._proportional_y()\n1126         # Use the vmin and vmax of the colorbar, which may not be the same\n1127         # as the norm. There are situations where the colormap has a\n1128         # narrower range than the colorbar and we want to accommodate the\n1129         # extra contours.\n1130         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm))\n1131                 or self.boundaries is not None):\n1132             # not using a norm.\n1133             y = y * (self.vmax - self.vmin) + self.vmin\n1134         else:\n1135             # Update the norm values in a context manager as it is only\n1136             # a temporary change and we don't want to propagate any signals\n1137             # attached to the norm (callbacks.blocked).\n1138             with self.norm.callbacks.blocked(), \\\n1139                     cbook._setattr_cm(self.norm,\n1140                                       vmin=self.vmin,\n1141                                       vmax=self.vmax):\n1142                 y = self.norm.inverse(y)\n1143         self._y = y\n1144         X, Y = np.meshgrid([0., 1.], y)\n1145         if self.orientation == 'vertical':\n1146             return (X, Y)\n1147         else:\n1148             return (Y, X)\n1149 \n1150     def _forward_boundaries(self, x):\n1151         # map boundaries equally between 0 and 1...\n1152         b = self._boundaries\n1153         y = np.interp(x, b, np.linspace(0, 1, len(b)))\n1154         # the following avoids ticks in the extends:\n1155         eps = (b[-1] - b[0]) * 1e-6\n1156         # map these _well_ out of bounds to keep any ticks out\n1157         # of the extends region...\n1158         y[x < b[0]-eps] = -1\n1159         y[x > b[-1]+eps] = 2\n1160         return y\n1161 \n1162     def _inverse_boundaries(self, x):\n1163         # invert the above...\n1164         b = self._boundaries\n1165         return np.interp(x, np.linspace(0, 1, len(b)), b)\n1166 \n1167     def _reset_locator_formatter_scale(self):\n1168         \"\"\"\n1169         Reset the locator et al to defaults.  Any user-hardcoded changes\n1170         need to be re-entered if this gets called (either at init, or when\n1171         the mappable normal gets changed: Colorbar.update_normal)\n1172         \"\"\"\n1173         self._process_values()\n1174         self._locator = None\n1175         self._minorlocator = None\n1176         self._formatter = None\n1177         self._minorformatter = None\n1178         if (isinstance(self.mappable, contour.ContourSet) and\n1179                 isinstance(self.norm, colors.LogNorm)):\n1180             # if contours have lognorm, give them a log scale...\n1181             self._set_scale('log')\n1182         elif (self.boundaries is not None or\n1183                 isinstance(self.norm, colors.BoundaryNorm)):\n1184             if self.spacing == 'uniform':\n1185                 funcs = (self._forward_boundaries, self._inverse_boundaries)\n1186                 self._set_scale('function', functions=funcs)\n1187             elif self.spacing == 'proportional':\n1188                 self._set_scale('linear')\n1189         elif getattr(self.norm, '_scale', None):\n1190             # use the norm's scale (if it exists and is not None):\n1191             self._set_scale(self.norm._scale)\n1192         elif type(self.norm) is colors.Normalize:\n1193             # plain Normalize:\n1194             self._set_scale('linear')\n1195         else:\n1196             # norm._scale is None or not an attr: derive the scale from\n1197             # the Norm:\n1198             funcs = (self.norm, self.norm.inverse)\n1199             self._set_scale('function', functions=funcs)\n1200 \n1201     def _locate(self, x):\n1202         \"\"\"\n1203         Given a set of color data values, return their\n1204         corresponding colorbar data coordinates.\n1205         \"\"\"\n1206         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n1207             b = self._boundaries\n1208             xn = x\n1209         else:\n1210             # Do calculations using normalized coordinates so\n1211             # as to make the interpolation more accurate.\n1212             b = self.norm(self._boundaries, clip=False).filled()\n1213             xn = self.norm(x, clip=False).filled()\n1214 \n1215         bunique = b[self._inside]\n1216         yunique = self._y\n1217 \n1218         z = np.interp(xn, bunique, yunique)\n1219         return z\n1220 \n1221     # trivial helpers\n1222 \n1223     def _uniform_y(self, N):\n1224         \"\"\"\n1225         Return colorbar data coordinates for *N* uniformly\n1226         spaced boundaries, plus extension lengths if required.\n1227         \"\"\"\n1228         automin = automax = 1. / (N - 1.)\n1229         extendlength = self._get_extension_lengths(self.extendfrac,\n1230                                                    automin, automax,\n1231                                                    default=0.05)\n1232         y = np.linspace(0, 1, N)\n1233         return y, extendlength\n1234 \n1235     def _proportional_y(self):\n1236         \"\"\"\n1237         Return colorbar data coordinates for the boundaries of\n1238         a proportional colorbar, plus extension lengths if required:\n1239         \"\"\"\n1240         if (isinstance(self.norm, colors.BoundaryNorm) or\n1241                 self.boundaries is not None):\n1242             y = (self._boundaries - self._boundaries[self._inside][0])\n1243             y = y / (self._boundaries[self._inside][-1] -\n1244                      self._boundaries[self._inside][0])\n1245             # need yscaled the same as the axes scale to get\n1246             # the extend lengths.\n1247             if self.spacing == 'uniform':\n1248                 yscaled = self._forward_boundaries(self._boundaries)\n1249             else:\n1250                 yscaled = y\n1251         else:\n1252             y = self.norm(self._boundaries.copy())\n1253             y = np.ma.filled(y, np.nan)\n1254             # the norm and the scale should be the same...\n1255             yscaled = y\n1256         y = y[self._inside]\n1257         yscaled = yscaled[self._inside]\n1258         # normalize from 0..1:\n1259         norm = colors.Normalize(y[0], y[-1])\n1260         y = np.ma.filled(norm(y), np.nan)\n1261         norm = colors.Normalize(yscaled[0], yscaled[-1])\n1262         yscaled = np.ma.filled(norm(yscaled), np.nan)\n1263         # make the lower and upper extend lengths proportional to the lengths\n1264         # of the first and last boundary spacing (if extendfrac='auto'):\n1265         automin = yscaled[1] - yscaled[0]\n1266         automax = yscaled[-1] - yscaled[-2]\n1267         extendlength = [0, 0]\n1268         if self._extend_lower() or self._extend_upper():\n1269             extendlength = self._get_extension_lengths(\n1270                     self.extendfrac, automin, automax, default=0.05)\n1271         return y, extendlength\n1272 \n1273     def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n1274         \"\"\"\n1275         Return the lengths of colorbar extensions.\n1276 \n1277         This is a helper method for _uniform_y and _proportional_y.\n1278         \"\"\"\n1279         # Set the default value.\n1280         extendlength = np.array([default, default])\n1281         if isinstance(frac, str):\n1282             _api.check_in_list(['auto'], extendfrac=frac.lower())\n1283             # Use the provided values when 'auto' is required.\n1284             extendlength[:] = [automin, automax]\n1285         elif frac is not None:\n1286             try:\n1287                 # Try to set min and max extension fractions directly.\n1288                 extendlength[:] = frac\n1289                 # If frac is a sequence containing None then NaN may\n1290                 # be encountered. This is an error.\n1291                 if np.isnan(extendlength).any():\n1292                     raise ValueError()\n1293             except (TypeError, ValueError) as err:\n1294                 # Raise an error on encountering an invalid value for frac.\n1295                 raise ValueError('invalid value for extendfrac') from err\n1296         return extendlength\n1297 \n1298     def _extend_lower(self):\n1299         \"\"\"Return whether the lower limit is open ended.\"\"\"\n1300         minmax = \"max\" if self._long_axis().get_inverted() else \"min\"\n1301         return self.extend in ('both', minmax)\n1302 \n1303     def _extend_upper(self):\n1304         \"\"\"Return whether the upper limit is open ended.\"\"\"\n1305         minmax = \"min\" if self._long_axis().get_inverted() else \"max\"\n1306         return self.extend in ('both', minmax)\n1307 \n1308     def _long_axis(self):\n1309         \"\"\"Return the long axis\"\"\"\n1310         if self.orientation == 'vertical':\n1311             return self.ax.yaxis\n1312         return self.ax.xaxis\n1313 \n1314     def _short_axis(self):\n1315         \"\"\"Return the short axis\"\"\"\n1316         if self.orientation == 'vertical':\n1317             return self.ax.xaxis\n1318         return self.ax.yaxis\n1319 \n1320     def _get_view(self):\n1321         # docstring inherited\n1322         # An interactive view for a colorbar is the norm's vmin/vmax\n1323         return self.norm.vmin, self.norm.vmax\n1324 \n1325     def _set_view(self, view):\n1326         # docstring inherited\n1327         # An interactive view for a colorbar is the norm's vmin/vmax\n1328         self.norm.vmin, self.norm.vmax = view\n1329 \n1330     def _set_view_from_bbox(self, bbox, direction='in',\n1331                             mode=None, twinx=False, twiny=False):\n1332         # docstring inherited\n1333         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax\n1334         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(\n1335             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)\n1336         if self.orientation == 'horizontal':\n1337             self.norm.vmin, self.norm.vmax = new_xbound\n1338         elif self.orientation == 'vertical':\n1339             self.norm.vmin, self.norm.vmax = new_ybound\n1340 \n1341     def drag_pan(self, button, key, x, y):\n1342         # docstring inherited\n1343         points = self.ax._get_pan_points(button, key, x, y)\n1344         if points is not None:\n1345             if self.orientation == 'horizontal':\n1346                 self.norm.vmin, self.norm.vmax = points[:, 0]\n1347             elif self.orientation == 'vertical':\n1348                 self.norm.vmin, self.norm.vmax = points[:, 1]\n1349 \n1350 \n1351 ColorbarBase = Colorbar  # Backcompat API\n1352 \n1353 \n1354 def _normalize_location_orientation(location, orientation):\n1355     if location is None:\n1356         location = _get_ticklocation_from_orientation(orientation)\n1357     loc_settings = _api.check_getitem({\n1358         \"left\":   {\"location\": \"left\", \"anchor\": (1.0, 0.5),\n1359                    \"panchor\": (0.0, 0.5), \"pad\": 0.10},\n1360         \"right\":  {\"location\": \"right\", \"anchor\": (0.0, 0.5),\n1361                    \"panchor\": (1.0, 0.5), \"pad\": 0.05},\n1362         \"top\":    {\"location\": \"top\", \"anchor\": (0.5, 0.0),\n1363                    \"panchor\": (0.5, 1.0), \"pad\": 0.05},\n1364         \"bottom\": {\"location\": \"bottom\", \"anchor\": (0.5, 1.0),\n1365                    \"panchor\": (0.5, 0.0), \"pad\": 0.15},\n1366     }, location=location)\n1367     loc_settings[\"orientation\"] = _get_orientation_from_location(location)\n1368     if orientation is not None and orientation != loc_settings[\"orientation\"]:\n1369         # Allow the user to pass both if they are consistent.\n1370         raise TypeError(\"location and orientation are mutually exclusive\")\n1371     return loc_settings\n1372 \n1373 \n1374 def _get_orientation_from_location(location):\n1375     return _api.check_getitem(\n1376         {None: None, \"left\": \"vertical\", \"right\": \"vertical\",\n1377          \"top\": \"horizontal\", \"bottom\": \"horizontal\"}, location=location)\n1378 \n1379 \n1380 def _get_ticklocation_from_orientation(orientation):\n1381     return _api.check_getitem(\n1382         {None: \"right\", \"vertical\": \"right\", \"horizontal\": \"bottom\"},\n1383         orientation=orientation)\n1384 \n1385 \n1386 @_docstring.interpd\n1387 def make_axes(parents, location=None, orientation=None, fraction=0.15,\n1388               shrink=1.0, aspect=20, **kwargs):\n1389     \"\"\"\n1390     Create an `~.axes.Axes` suitable for a colorbar.\n1391 \n1392     The axes is placed in the figure of the *parents* axes, by resizing and\n1393     repositioning *parents*.\n1394 \n1395     Parameters\n1396     ----------\n1397     parents : `~.axes.Axes` or iterable or `numpy.ndarray` of `~.axes.Axes`\n1398         The Axes to use as parents for placing the colorbar.\n1399     %(_make_axes_kw_doc)s\n1400 \n1401     Returns\n1402     -------\n1403     cax : `~.axes.Axes`\n1404         The child axes.\n1405     kwargs : dict\n1406         The reduced keyword dictionary to be passed when creating the colorbar\n1407         instance.\n1408     \"\"\"\n1409     loc_settings = _normalize_location_orientation(location, orientation)\n1410     # put appropriate values into the kwargs dict for passing back to\n1411     # the Colorbar class\n1412     kwargs['orientation'] = loc_settings['orientation']\n1413     location = kwargs['ticklocation'] = loc_settings['location']\n1414 \n1415     anchor = kwargs.pop('anchor', loc_settings['anchor'])\n1416     panchor = kwargs.pop('panchor', loc_settings['panchor'])\n1417     aspect0 = aspect\n1418     # turn parents into a list if it is not already.  Note we cannot\n1419     # use .flatten or .ravel as these copy the references rather than\n1420     # reuse them, leading to a memory leak\n1421     if isinstance(parents, np.ndarray):\n1422         parents = list(parents.flat)\n1423     elif np.iterable(parents):\n1424         parents = list(parents)\n1425     else:\n1426         parents = [parents]\n1427 \n1428     fig = parents[0].get_figure()\n1429 \n1430     pad0 = 0.05 if fig.get_constrained_layout() else loc_settings['pad']\n1431     pad = kwargs.pop('pad', pad0)\n1432 \n1433     if not all(fig is ax.get_figure() for ax in parents):\n1434         raise ValueError('Unable to create a colorbar axes as not all '\n1435                          'parents share the same figure.')\n1436 \n1437     # take a bounding box around all of the given axes\n1438     parents_bbox = mtransforms.Bbox.union(\n1439         [ax.get_position(original=True).frozen() for ax in parents])\n1440 \n1441     pb = parents_bbox\n1442     if location in ('left', 'right'):\n1443         if location == 'left':\n1444             pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)\n1445         else:\n1446             pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)\n1447         pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)\n1448     else:\n1449         if location == 'bottom':\n1450             pbcb, _, pb1 = pb.splity(fraction, fraction + pad)\n1451         else:\n1452             pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)\n1453         pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)\n1454 \n1455         # define the aspect ratio in terms of y's per x rather than x's per y\n1456         aspect = 1.0 / aspect\n1457 \n1458     # define a transform which takes us from old axes coordinates to\n1459     # new axes coordinates\n1460     shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)\n1461 \n1462     # transform each of the axes in parents using the new transform\n1463     for ax in parents:\n1464         new_posn = shrinking_trans.transform(ax.get_position(original=True))\n1465         new_posn = mtransforms.Bbox(new_posn)\n1466         ax._set_position(new_posn)\n1467         if panchor is not False:\n1468             ax.set_anchor(panchor)\n1469 \n1470     cax = fig.add_axes(pbcb, label=\"<colorbar>\")\n1471     for a in parents:\n1472         # tell the parent it has a colorbar\n1473         a._colorbars += [cax]\n1474     cax._colorbar_info = dict(\n1475         parents=parents,\n1476         location=location,\n1477         shrink=shrink,\n1478         anchor=anchor,\n1479         panchor=panchor,\n1480         fraction=fraction,\n1481         aspect=aspect0,\n1482         pad=pad)\n1483     # and we need to set the aspect ratio by hand...\n1484     cax.set_anchor(anchor)\n1485     cax.set_box_aspect(aspect)\n1486     cax.set_aspect('auto')\n1487 \n1488     return cax, kwargs\n1489 \n1490 \n1491 @_docstring.interpd\n1492 def make_axes_gridspec(parent, *, location=None, orientation=None,\n1493                        fraction=0.15, shrink=1.0, aspect=20, **kwargs):\n1494     \"\"\"\n1495     Create an `~.axes.Axes` suitable for a colorbar.\n1496 \n1497     The axes is placed in the figure of the *parent* axes, by resizing and\n1498     repositioning *parent*.\n1499 \n1500     This function is similar to `.make_axes` and mostly compatible with it.\n1501     Primary differences are\n1502 \n1503     - `.make_axes_gridspec` requires the *parent* to have a subplotspec.\n1504     - `.make_axes` positions the axes in figure coordinates;\n1505       `.make_axes_gridspec` positions it using a subplotspec.\n1506     - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`\n1507       replaces the parent gridspec with a new one.\n1508 \n1509     Parameters\n1510     ----------\n1511     parent : `~.axes.Axes`\n1512         The Axes to use as parent for placing the colorbar.\n1513     %(_make_axes_kw_doc)s\n1514 \n1515     Returns\n1516     -------\n1517     cax : `~.axes.Axes`\n1518         The child axes.\n1519     kwargs : dict\n1520         The reduced keyword dictionary to be passed when creating the colorbar\n1521         instance.\n1522     \"\"\"\n1523 \n1524     loc_settings = _normalize_location_orientation(location, orientation)\n1525     kwargs['orientation'] = loc_settings['orientation']\n1526     location = kwargs['ticklocation'] = loc_settings['location']\n1527 \n1528     aspect0 = aspect\n1529     anchor = kwargs.pop('anchor', loc_settings['anchor'])\n1530     panchor = kwargs.pop('panchor', loc_settings['panchor'])\n1531     pad = kwargs.pop('pad', loc_settings[\"pad\"])\n1532     wh_space = 2 * pad / (1 - pad)\n1533 \n1534     if location in ('left', 'right'):\n1535         # for shrinking\n1536         height_ratios = [\n1537                 (1-anchor[1])*(1-shrink), shrink, anchor[1]*(1-shrink)]\n1538 \n1539         if location == 'left':\n1540             gs = parent.get_subplotspec().subgridspec(\n1541                     1, 2, wspace=wh_space,\n1542                     width_ratios=[fraction, 1-fraction-pad])\n1543             ss_main = gs[1]\n1544             ss_cb = gs[0].subgridspec(\n1545                     3, 1, hspace=0, height_ratios=height_ratios)[1]\n1546         else:\n1547             gs = parent.get_subplotspec().subgridspec(\n1548                     1, 2, wspace=wh_space,\n1549                     width_ratios=[1-fraction-pad, fraction])\n1550             ss_main = gs[0]\n1551             ss_cb = gs[1].subgridspec(\n1552                     3, 1, hspace=0, height_ratios=height_ratios)[1]\n1553     else:\n1554         # for shrinking\n1555         width_ratios = [\n1556                 anchor[0]*(1-shrink), shrink, (1-anchor[0])*(1-shrink)]\n1557 \n1558         if location == 'bottom':\n1559             gs = parent.get_subplotspec().subgridspec(\n1560                     2, 1, hspace=wh_space,\n1561                     height_ratios=[1-fraction-pad, fraction])\n1562             ss_main = gs[0]\n1563             ss_cb = gs[1].subgridspec(\n1564                     1, 3, wspace=0, width_ratios=width_ratios)[1]\n1565             aspect = 1 / aspect\n1566         else:\n1567             gs = parent.get_subplotspec().subgridspec(\n1568                     2, 1, hspace=wh_space,\n1569                     height_ratios=[fraction, 1-fraction-pad])\n1570             ss_main = gs[1]\n1571             ss_cb = gs[0].subgridspec(\n1572                     1, 3, wspace=0, width_ratios=width_ratios)[1]\n1573             aspect = 1 / aspect\n1574 \n1575     parent.set_subplotspec(ss_main)\n1576     if panchor is not False:\n1577         parent.set_anchor(panchor)\n1578 \n1579     fig = parent.get_figure()\n1580     cax = fig.add_subplot(ss_cb, label=\"<colorbar>\")\n1581     cax.set_anchor(anchor)\n1582     cax.set_box_aspect(aspect)\n1583     cax.set_aspect('auto')\n1584     cax._colorbar_info = dict(\n1585         location=location,\n1586         parents=[parent],\n1587         shrink=shrink,\n1588         anchor=anchor,\n1589         panchor=panchor,\n1590         fraction=fraction,\n1591         aspect=aspect0,\n1592         pad=pad)\n1593 \n1594     return cax, kwargs\n",
        "intended_behavior": "When `vmin` and `vmax` are modified, particularly in an interactive setting, the colorbar update mechanism should detect these changes and redraw the colorbar to reflect the new range according to the newly set normalization method. This process should handle logarithmic scaling gracefully, ensuring that the colorbar accurately represents the updated data range."
    }
]