[
    {
        "rel_file_path": "django/core/servers/basehttp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/core/servers/basehttp.py",
        "start": 210,
        "end": 227,
        "class_name": "WSGIRequestHandler",
        "method_name": "handle_one_request",
        "code": "210     def handle_one_request(self):\n211         \"\"\"Copy of WSGIRequestHandler.handle() but with different ServerHandler\"\"\"\n212         self.raw_requestline = self.rfile.readline(65537)\n213         if len(self.raw_requestline) > 65536:\n214             self.requestline = \"\"\n215             self.request_version = \"\"\n216             self.command = \"\"\n217             self.send_error(414)\n218             return\n219 \n220         if not self.parse_request():  # An error code has been sent, just exit\n221             return\n222 \n223         handler = ServerHandler(\n224             self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n225         )\n226         handler.request_handler = self  # backpointer for logging & connection closing\n227         handler.run(self.server.get_app())\n",
        "intended_behavior": "Within the handle_one_request method of the WSGIRequestHandler class, after the request has been successfully parsed and before the response is sent back to the client, introduce logic to check if the request is a HEAD request. If it is, ensure the response body is excluded from the final response sent to the client. This could potentially involve adjusting the behavior of ServerHandler.run(self.server.get_app()) or another downstream component of the response generation process, ensuring that while headers and status codes appropriate for the equivalent GET request are generated and sent, the body is omitted in compliance with HTTP specifications for HEAD requests.\n\nThis adjustment must allow WSGIRequestHandler to continue handling all other aspects of requests and responses as currently implemented, ensuring that the added logic for HEAD requests does not interfere with or alter the handling of any other HTTP method types, maintaining the existing functionality and performance characteristics of Django's development server."
    },
    {
        "rel_file_path": "django/core/servers/basehttp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/core/servers/basehttp.py",
        "start": 151,
        "end": 227,
        "class_name": "WSGIRequestHandler",
        "method_name": null,
        "code": "151 class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n152     protocol_version = \"HTTP/1.1\"\n153 \n154     def address_string(self):\n155         # Short-circuit parent method to not call socket.getfqdn\n156         return self.client_address[0]\n157 \n158     def log_message(self, format, *args):\n159         extra = {\n160             \"request\": self.request,\n161             \"server_time\": self.log_date_time_string(),\n162         }\n163         if args[1][0] == \"4\":\n164             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n165             if args[0].startswith(\"\\x16\\x03\"):\n166                 extra[\"status_code\"] = 500\n167                 logger.error(\n168                     \"You're accessing the development server over HTTPS, but \"\n169                     \"it only supports HTTP.\",\n170                     extra=extra,\n171                 )\n172                 return\n173 \n174         if args[1].isdigit() and len(args[1]) == 3:\n175             status_code = int(args[1])\n176             extra[\"status_code\"] = status_code\n177 \n178             if status_code >= 500:\n179                 level = logger.error\n180             elif status_code >= 400:\n181                 level = logger.warning\n182             else:\n183                 level = logger.info\n184         else:\n185             level = logger.info\n186 \n187         level(format, *args, extra=extra)\n188 \n189     def get_environ(self):\n190         # Strip all headers with underscores in the name before constructing\n191         # the WSGI environ. This prevents header-spoofing based on ambiguity\n192         # between underscores and dashes both normalized to underscores in WSGI\n193         # env vars. Nginx and Apache 2.4+ both do this as well.\n194         for k in self.headers:\n195             if \"_\" in k:\n196                 del self.headers[k]\n197 \n198         return super().get_environ()\n199 \n200     def handle(self):\n201         self.close_connection = True\n202         self.handle_one_request()\n203         while not self.close_connection:\n204             self.handle_one_request()\n205         try:\n206             self.connection.shutdown(socket.SHUT_WR)\n207         except (AttributeError, OSError):\n208             pass\n209 \n210     def handle_one_request(self):\n211         \"\"\"Copy of WSGIRequestHandler.handle() but with different ServerHandler\"\"\"\n212         self.raw_requestline = self.rfile.readline(65537)\n213         if len(self.raw_requestline) > 65536:\n214             self.requestline = \"\"\n215             self.request_version = \"\"\n216             self.command = \"\"\n217             self.send_error(414)\n218             return\n219 \n220         if not self.parse_request():  # An error code has been sent, just exit\n221             return\n222 \n223         handler = ServerHandler(\n224             self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n225         )\n226         handler.request_handler = self  # backpointer for logging & connection closing\n227         handler.run(self.server.get_app())\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]