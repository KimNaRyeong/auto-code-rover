2025-10-18 08:36:06.012 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 08:36:14.467 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=110, output_tokens=12, cost=0.001460
2025-10-18 08:36:14.468 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 08:36:14.472 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:36:20.502 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=418, output_tokens=253, cost=0.011770
2025-10-18 08:36:20.507 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:36:23.793 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=607, output_tokens=30, cost=0.006970
2025-10-18 08:36:23.794 | DEBUG    | Extracted a valid json.
2025-10-18 08:36:23.794 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"2//.5\")", "search_code(\"//\")"],
    "bug_locations": []
}
2025-10-18 08:36:30.307 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 08:36:30.307 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 08:36:45.022 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6430, output_tokens=615, cost=0.082750
2025-10-18 08:36:45.028 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:36:57.198 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7261, output_tokens=518, cost=0.088150
2025-10-18 08:36:57.207 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:37:07.220 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=872, output_tokens=405, cost=0.020870
2025-10-18 08:37:07.221 | DEBUG    | Extracted a valid json.
2025-10-18 08:37:07.221 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/evalf.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result."
        },
        {
            "file": "sympy/core/numbers.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result."
        }
    ]
}
2025-10-18 08:37:07.233 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/evalf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Adaptive numerical evaluation of SymPy expressions, using mpmath
3 for mathematical functions.
4 """
5 from __future__ import print_function, division
6 
7 import math
8 
9 import mpmath.libmp as libmp
10 from mpmath import (
11     make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec)
12 from mpmath import inf as mpmath_inf
13 from mpmath.libmp import (from_int, from_man_exp, from_rational, fhalf,
14         fnan, fnone, fone, fzero, mpf_abs, mpf_add,
15         mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt,
16         mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin,
17         mpf_sqrt, normalize, round_nearest, to_int, to_str)
18 from mpmath.libmp import bitcount as mpmath_bitcount
19 from mpmath.libmp.backend import MPZ
20 from mpmath.libmp.libmpc import _infs_nan
21 from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps
22 from mpmath.libmp.gammazeta import mpf_bernoulli
23 
24 from .compatibility import SYMPY_INTS, range
25 from .sympify import sympify
26 from .singleton import S
27 
28 from sympy.utilities.iterables import is_sequence
29 
30 LG10 = math.log(10, 2)
31 rnd = round_nearest
32 
33 
34 def bitcount(n):
35     """Return smallest integer, b, such that |n|/2**b < 1.
36     """
37     return mpmath_bitcount(abs(int(n)))
38 
39 # Used in a few places as placeholder values to denote exponents and
40 # precision levels, e.g. of exact numbers. Must be careful to avoid
41 # passing these to mpmath functions or returning them in final results.
42 INF = float(mpmath_inf)
43 MINUS_INF = float(-mpmath_inf)
44 
45 # ~= 100 digits. Real men set this to INF.
46 DEFAULT_MAXPREC = 333
47 
48 
49 class PrecisionExhausted(ArithmeticError):
50     pass
51 
52 #----------------------------------------------------------------------------#
53 #                                                                            #
54 #              Helper functions for arithmetic and complex parts             #
55 #                                                                            #
56 #----------------------------------------------------------------------------#
57 
58 """
59 An mpf value tuple is a tuple of integers (sign, man, exp, bc)
60 representing a floating-point number: [1, -1][sign]*man*2**exp where
61 sign is 0 or 1 and bc should correspond to the number of bits used to
62 represent the mantissa (man) in binary notation, e.g.
63 
64 >>> from sympy.core.evalf import bitcount
65 >>> sign, man, exp, bc = 0, 5, 1, 3
66 >>> n = [1, -1][sign]*man*2**exp
67 >>> n, bitcount(man)
68 (10, 3)
69 
70 A temporary result is a tuple (re, im, re_acc, im_acc) where
71 re and im are nonzero mpf value tuples representing approximate
72 numbers, or None to denote exact zeros.
73 
74 re_acc, im_acc are integers denoting log2(e) where e is the estimated
75 relative accuracy of the respective complex part, but may be anything
76 if the corresponding complex part is None.
77 
78 """
79 
80 
81 def fastlog(x):
82     """Fast approximation of log2(x) for an mpf value tuple x.
83 
84     Notes: Calculated as exponent + width of mantissa. This is an
85     approximation for two reasons: 1) it gives the ceil(log2(abs(x)))
86     value and 2) it is too high by 1 in the case that x is an exact
87     power of 2. Although this is easy to remedy by testing to see if
88     the odd mpf mantissa is 1 (indicating that one was dealing with
89     an exact power of 2) that would decrease the speed and is not
90     necessary as this is only being used as an approximation for the
91     number of bits in x. The correct return value could be written as
92     "x[2] + (x[3] if x[1] != 1 else 0)".
93         Since mpf tuples always have an odd mantissa, no check is done
94     to see if the mantissa is a multiple of 2 (in which case the
95     result would be too large by 1).
96 
97     Examples
98     ========
99 
100     >>> from sympy import log
101     >>> from sympy.core.evalf import fastlog, bitcount
102     >>> s, m, e = 0, 5, 1
103     >>> bc = bitcount(m)
104     >>> n = [1, -1][s]*m*2**e
105     >>> n, (log(n)/log(2)).evalf(2), fastlog((s, m, e, bc))
106     (10, 3.3, 4)
107     """
108 
109     if not x or x == fzero:
110         return MINUS_INF
111     return x[2] + x[3]
112 
113 
114 def pure_complex(v, or_real=False):
115     """Return a and b if v matches a + I*b where b is not zero and
116     a and b are Numbers, else None. If `or_real` is True then 0 will
117     be returned for `b` if `v` is a real number.
118 
119     >>> from sympy.core.evalf import pure_complex
120     >>> from sympy import sqrt, I, S
121     >>> a, b, surd = S(2), S(3), sqrt(2)
122     >>> pure_complex(a)
123     >>> pure_complex(a, or_real=True)
124     (2, 0)
125     >>> pure_complex(surd)
126     >>> pure_complex(a + b*I)
127     (2, 3)
128     >>> pure_complex(I)
129     (0, 1)
130     """
131     h, t = v.as_coeff_Add()
132     if not t:
133         if or_real:
134             return h, t
135         return
136     c, i = t.as_coeff_Mul()
137     if i is S.ImaginaryUnit:
138         return h, c
139 
140 
141 def scaled_zero(mag, sign=1):
142     """Return an mpf representing a power of two with magnitude ``mag``
143     and -1 for precision. Or, if ``mag`` is a scaled_zero tuple, then just
144     remove the sign from within the list that it was initially wrapped
145     in.
146 
147     Examples
148     ========
149 
150     >>> from sympy.core.evalf import scaled_zero
151     >>> from sympy import Float
152     >>> z, p = scaled_zero(100)
153     >>> z, p
154     (([0], 1, 100, 1), -1)
155     >>> ok = scaled_zero(z)
156     >>> ok
157     (0, 1, 100, 1)
158     >>> Float(ok)
159     1.26765060022823e+30
160     >>> Float(ok, p)
161     0.e+30
162     >>> ok, p = scaled_zero(100, -1)
163     >>> Float(scaled_zero(ok), p)
164     -0.e+30
165     """
166     if type(mag) is tuple and len(mag) == 4 and iszero(mag, scaled=True):
167         return (mag[0][0],) + mag[1:]
168     elif isinstance(mag, SYMPY_INTS):
169         if sign not in [-1, 1]:
170             raise ValueError('sign must be +/-1')
171         rv, p = mpf_shift(fone, mag), -1
172         s = 0 if sign == 1 else 1
173         rv = ([s],) + rv[1:]
174         return rv, p
175     else:
176         raise ValueError('scaled zero expects int or scaled_zero tuple.')
177 
178 
179 def iszero(mpf, scaled=False):
180     if not scaled:
181         return not mpf or not mpf[1] and not mpf[-1]
182     return mpf and type(mpf[0]) is list and mpf[1] == mpf[-1] == 1
183 
184 
185 def complex_accuracy(result):
186     """
187     Returns relative accuracy of a complex number with given accuracies
188     for the real and imaginary parts. The relative accuracy is defined
189     in the complex norm sense as ||z|+|error|| / |z| where error
190     is equal to (real absolute error) + (imag absolute error)*i.
191 
192     The full expression for the (logarithmic) error can be approximated
193     easily by using the max norm to approximate the complex norm.
194 
195     In the worst case (re and im equal), this is wrong by a factor
196     sqrt(2), or by log2(sqrt(2)) = 0.5 bit.
197     """
198     re, im, re_acc, im_acc = result
199     if not im:
200         if not re:
201             return INF
202         return re_acc
203     if not re:
204         return im_acc
205     re_size = fastlog(re)
206     im_size = fastlog(im)
207     absolute_error = max(re_size - re_acc, im_size - im_acc)
208     relative_error = absolute_error - max(re_size, im_size)
209     return -relative_error
210 
211 
212 def get_abs(expr, prec, options):
213     re, im, re_acc, im_acc = evalf(expr, prec + 2, options)
214 
215     if not re:
216         re, re_acc, im, im_acc = im, im_acc, re, re_acc
217     if im:
218         if expr.is_number:
219             abs_expr, _, acc, _ = evalf(abs(N(expr, prec + 2)),
220                                         prec + 2, options)
221             return abs_expr, None, acc, None
222         else:
223             if 'subs' in options:
224                 return libmp.mpc_abs((re, im), prec), None, re_acc, None
225             return abs(expr), None, prec, None
226     elif re:
227         return mpf_abs(re), None, re_acc, None
228     else:
229         return None, None, None, None
230 
231 
232 def get_complex_part(expr, no, prec, options):
233     """no = 0 for real part, no = 1 for imaginary part"""
234     workprec = prec
235     i = 0
236     while 1:
237         res = evalf(expr, workprec, options)
238         value, accuracy = res[no::2]
239         # XXX is the last one correct? Consider re((1+I)**2).n()
240         if (not value) or accuracy >= prec or -value[2] > prec:
241             return value, None, accuracy, None
242         workprec += max(30, 2**i)
243         i += 1
244 
245 
246 def evalf_abs(expr, prec, options):
247     return get_abs(expr.args[0], prec, options)
248 
249 
250 def evalf_re(expr, prec, options):
251     return get_complex_part(expr.args[0], 0, prec, options)
252 
253 
254 def evalf_im(expr, prec, options):
255     return get_complex_part(expr.args[0], 1, prec, options)
256 
257 
258 def finalize_complex(re, im, prec):
259     if re == fzero and im == fzero:
260         raise ValueError("got complex zero with unknown accuracy")
261     elif re == fzero:
262         return None, im, None, prec
263     elif im == fzero:
264         return re, None, prec, None
265 
266     size_re = fastlog(re)
267     size_im = fastlog(im)
268     if size_re > size_im:
269         re_acc = prec
270         im_acc = prec + min(-(size_re - size_im), 0)
271     else:
272         im_acc = prec
273         re_acc = prec + min(-(size_im - size_re), 0)
274     return re, im, re_acc, im_acc
275 
276 
277 def chop_parts(value, prec):
278     """
279     Chop off tiny real or complex parts.
280     """
281     re, im, re_acc, im_acc = value
282     # Method 1: chop based on absolute value
283     if re and re not in _infs_nan and (fastlog(re) < -prec + 4):
284         re, re_acc = None, None
285     if im and im not in _infs_nan and (fastlog(im) < -prec + 4):
286         im, im_acc = None, None
287     # Method 2: chop if inaccurate and relatively small
288     if re and im:
289         delta = fastlog(re) - fastlog(im)
290         if re_acc < 2 and (delta - re_acc <= -prec + 4):
291             re, re_acc = None, None
292         if im_acc < 2 and (delta - im_acc >= prec - 4):
293             im, im_acc = None, None
294     return re, im, re_acc, im_acc
295 
296 
297 def check_target(expr, result, prec):
298     a = complex_accuracy(result)
299     if a < prec:
300         raise PrecisionExhausted("Failed to distinguish the expression: \n\n%s\n\n"
301             "from zero. Try simplifying the input, using chop=True, or providing "
302             "a higher maxn for evalf" % (expr))
303 
304 
305 def get_integer_part(expr, no, options, return_ints=False):
306     """
307     With no = 1, computes ceiling(expr)
308     With no = -1, computes floor(expr)
309 
310     Note: this function either gives the exact result or signals failure.
311     """
312     from sympy.functions.elementary.complexes import re, im
313     # The expression is likely less than 2^30 or so
314     assumed_size = 30
315     ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)
316 
317     # We now know the size, so we can calculate how much extra precision
318     # (if any) is needed to get within the nearest integer
319     if ire and iim:
320         gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)
321     elif ire:
322         gap = fastlog(ire) - ire_acc
323     elif iim:
324         gap = fastlog(iim) - iim_acc
325     else:
326         # ... or maybe the expression was exactly zero
327         return None, None, None, None
328 
329     margin = 10
330 
331     if gap >= -margin:
332         prec = margin + assumed_size + gap
333         ire, iim, ire_acc, iim_acc = evalf(
334             expr, prec, options)
335     else:
336         prec = assumed_size
337 
338     # We can now easily find the nearest integer, but to find floor/ceil, we
339     # must also calculate whether the difference to the nearest integer is
340     # positive or negative (which may fail if very close).
341     def calc_part(re_im, nexpr):
342         from sympy.core.add import Add
343         n, c, p, b = nexpr
344         is_int = (p == 0)
345         nint = int(to_int(nexpr, rnd))
346         if is_int:
347             # make sure that we had enough precision to distinguish
348             # between nint and the re or im part (re_im) of expr that
349             # was passed to calc_part
350             ire, iim, ire_acc, iim_acc = evalf(
351                 re_im - nint, 10, options)  # don't need much precision
352             assert not iim
353             size = -fastlog(ire) + 2  # -ve b/c ire is less than 1
354             if size > prec:
355                 ire, iim, ire_acc, iim_acc = evalf(
356                     re_im, size, options)
357                 assert not iim
358                 nexpr = ire
359                 n, c, p, b = nexpr
360                 is_int = (p == 0)
361                 nint = int(to_int(nexpr, rnd))
362         if not is_int:
363             # if there are subs and they all contain integer re/im parts
364             # then we can (hopefully) safely substitute them into the
365             # expression
366             s = options.get('subs', False)
367             if s:
368                 doit = True
369                 from sympy.core.compatibility import as_int
370                 # use strict=False with as_int because we take
371                 # 2.0 == 2
372                 for v in s.values():
373                     try:
374                         as_int(v, strict=False)
375                     except ValueError:
376                         try:
377                             [as_int(i, strict=False) for i in v.as_real_imag()]
378                             continue
379                         except (ValueError, AttributeError):
380                             doit = False
381                             break
382                 if doit:
383                     re_im = re_im.subs(s)
384 
385             re_im = Add(re_im, -nint, evaluate=False)
386             x, _, x_acc, _ = evalf(re_im, 10, options)
387             try:
388                 check_target(re_im, (x, None, x_acc, None), 3)
389             except PrecisionExhausted:
390                 if not re_im.equals(0):
391                     raise PrecisionExhausted
392                 x = fzero
393             nint += int(no*(mpf_cmp(x or fzero, fzero) == no))
394         nint = from_int(nint)
395         return nint, INF
396 
397     re_, im_, re_acc, im_acc = None, None, None, None
398 
399     if ire:
400         re_, re_acc = calc_part(re(expr, evaluate=False), ire)
401     if iim:
402         im_, im_acc = calc_part(im(expr, evaluate=False), iim)
403 
404     if return_ints:
405         return int(to_int(re_ or fzero)), int(to_int(im_ or fzero))
406     return re_, im_, re_acc, im_acc
407 
408 
409 def evalf_ceiling(expr, prec, options):
410     return get_integer_part(expr.args[0], 1, options)
411 
412 
413 def evalf_floor(expr, prec, options):
414     return get_integer_part(expr.args[0], -1, options)
415 
416 #----------------------------------------------------------------------------#
417 #                                                                            #
418 #                            Arithmetic operations                           #
419 #                                                                            #
420 #----------------------------------------------------------------------------#
421 
422 
423 def add_terms(terms, prec, target_prec):
424     """
425     Helper for evalf_add. Adds a list of (mpfval, accuracy) terms.
426 
427     Returns
428     -------
429 
430     - None, None if there are no non-zero terms;
431     - terms[0] if there is only 1 term;
432     - scaled_zero if the sum of the terms produces a zero by cancellation
433       e.g. mpfs representing 1 and -1 would produce a scaled zero which need
434       special handling since they are not actually zero and they are purposely
435       malformed to ensure that they can't be used in anything but accuracy
436       calculations;
437     - a tuple that is scaled to target_prec that corresponds to the
438       sum of the terms.
439 
440     The returned mpf tuple will be normalized to target_prec; the input
441     prec is used to define the working precision.
442 
443     XXX explain why this is needed and why one can't just loop using mpf_add
444     """
445 
446     terms = [t for t in terms if not iszero(t[0])]
447     if not terms:
448         return None, None
449     elif len(terms) == 1:
450         return terms[0]
451 
452     # see if any argument is NaN or oo and thus warrants a special return
453     special = []
454     from sympy.core.numbers import Float
455     for t in terms:
456         arg = Float._new(t[0], 1)
457         if arg is S.NaN or arg.is_infinite:
458             special.append(arg)
459     if special:
460         from sympy.core.add import Add
461         rv = evalf(Add(*special), prec + 4, {})
462         return rv[0], rv[2]
463 
464     working_prec = 2*prec
465     sum_man, sum_exp, absolute_error = 0, 0, MINUS_INF
466 
467     for x, accuracy in terms:
468         sign, man, exp, bc = x
469         if sign:
470             man = -man
471         absolute_error = max(absolute_error, bc + exp - accuracy)
472         delta = exp - sum_exp
473         if exp >= sum_exp:
474             # x much larger than existing sum?
475             # first: quick test
476             if ((delta > working_prec) and
477                 ((not sum_man) or
478                  delta - bitcount(abs(sum_man)) > working_prec)):
479                 sum_man = man
480                 sum_exp = exp
481             else:
482                 sum_man += (man << delta)
483         else:
484             delta = -delta
485             # x much smaller than existing sum?
486             if delta - bc > working_prec:
487                 if not sum_man:
488                     sum_man, sum_exp = man, exp
489             else:
490                 sum_man = (sum_man << delta) + man
491                 sum_exp = exp
492     if not sum_man:
493         return scaled_zero(absolute_error)
494     if sum_man < 0:
495         sum_sign = 1
496         sum_man = -sum_man
497     else:
498         sum_sign = 0
499     sum_bc = bitcount(sum_man)
500     sum_accuracy = sum_exp + sum_bc - absolute_error
501     r = normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec,
502         rnd), sum_accuracy
503     return r
504 
505 
506 def evalf_add(v, prec, options):
507     res = pure_complex(v)
508     if res:
509         h, c = res
510         re, _, re_acc, _ = evalf(h, prec, options)
511         im, _, im_acc, _ = evalf(c, prec, options)
512         return re, im, re_acc, im_acc
513 
514     oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
515 
516     i = 0
517     target_prec = prec
518     while 1:
519         options['maxprec'] = min(oldmaxprec, 2*prec)
520 
521         terms = [evalf(arg, prec + 10, options) for arg in v.args]
522         re, re_acc = add_terms(
523             [a[0::2] for a in terms if a[0]], prec, target_prec)
524         im, im_acc = add_terms(
525             [a[1::2] for a in terms if a[1]], prec, target_prec)
526         acc = complex_accuracy((re, im, re_acc, im_acc))
527         if acc >= target_prec:
528             if options.get('verbose'):
529                 print("ADD: wanted", target_prec, "accurate bits, got", re_acc, im_acc)
530             break
531         else:
532             if (prec - target_prec) > options['maxprec']:
533                 break
534 
535             prec = prec + max(10 + 2**i, target_prec - acc)
536             i += 1
537             if options.get('verbose'):
538                 print("ADD: restarting with prec", prec)
539 
540     options['maxprec'] = oldmaxprec
541     if iszero(re, scaled=True):
542         re = scaled_zero(re)
543     if iszero(im, scaled=True):
544         im = scaled_zero(im)
545     return re, im, re_acc, im_acc
546 
547 
548 def evalf_mul(v, prec, options):
549     res = pure_complex(v)
550     if res:
551         # the only pure complex that is a mul is h*I
552         _, h = res
553         im, _, im_acc, _ = evalf(h, prec, options)
554         return None, im, None, im_acc
555     args = list(v.args)
556 
557     # see if any argument is NaN or oo and thus warrants a special return
558     special = []
559     from sympy.core.numbers import Float
560     for arg in args:
561         arg = evalf(arg, prec, options)
562         if arg[0] is None:
563             continue
564         arg = Float._new(arg[0], 1)
565         if arg is S.NaN or arg.is_infinite:
566             special.append(arg)
567     if special:
568         from sympy.core.mul import Mul
569         special = Mul(*special)
570         return evalf(special, prec + 4, {})
571 
572     # With guard digits, multiplication in the real case does not destroy
573     # accuracy. This is also true in the complex case when considering the
574     # total accuracy; however accuracy for the real or imaginary parts
575     # separately may be lower.
576     acc = prec
577 
578     # XXX: big overestimate
579     working_prec = prec + len(args) + 5
580 
581     # Empty product is 1
582     start = man, exp, bc = MPZ(1), 0, 1
583 
584     # First, we multiply all pure real or pure imaginary numbers.
585     # direction tells us that the result should be multiplied by
586     # I**direction; all other numbers get put into complex_factors
587     # to be multiplied out after the first phase.
588     last = len(args)
589     direction = 0
590     args.append(S.One)
591     complex_factors = []
592 
593     for i, arg in enumerate(args):
594         if i != last and pure_complex(arg):
595             args[-1] = (args[-1]*arg).expand()
596             continue
597         elif i == last and arg is S.One:
598             continue
599         re, im, re_acc, im_acc = evalf(arg, working_prec, options)
600         if re and im:
601             complex_factors.append((re, im, re_acc, im_acc))
602             continue
603         elif re:
604             (s, m, e, b), w_acc = re, re_acc
605         elif im:
606             (s, m, e, b), w_acc = im, im_acc
607             direction += 1
608         else:
609             return None, None, None, None
610         direction += 2*s
611         man *= m
612         exp += e
613         bc += b
614         if bc > 3*working_prec:
615             man >>= working_prec
616             exp += working_prec
617         acc = min(acc, w_acc)
618     sign = (direction & 2) >> 1
619     if not complex_factors:
620         v = normalize(sign, man, exp, bitcount(man), prec, rnd)
621         # multiply by i
622         if direction & 1:
623             return None, v, None, acc
624         else:
625             return v, None, acc, None
626     else:
627         # initialize with the first term
628         if (man, exp, bc) != start:
629             # there was a real part; give it an imaginary part
630             re, im = (sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0)
631             i0 = 0
632         else:
633             # there is no real part to start (other than the starting 1)
634             wre, wim, wre_acc, wim_acc = complex_factors[0]
635             acc = min(acc,
636                       complex_accuracy((wre, wim, wre_acc, wim_acc)))
637             re = wre
638             im = wim
639             i0 = 1
640 
641         for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:
642             # acc is the overall accuracy of the product; we aren't
643             # computing exact accuracies of the product.
644             acc = min(acc,
645                       complex_accuracy((wre, wim, wre_acc, wim_acc)))
646 
647             use_prec = working_prec
648             A = mpf_mul(re, wre, use_prec)
649             B = mpf_mul(mpf_neg(im), wim, use_prec)
650             C = mpf_mul(re, wim, use_prec)
651             D = mpf_mul(im, wre, use_prec)
652             re = mpf_add(A, B, use_prec)
653             im = mpf_add(C, D, use_prec)
654         if options.get('verbose'):
655             print("MUL: wanted", prec, "accurate bits, got", acc)
656         # multiply by I
657         if direction & 1:
658             re, im = mpf_neg(im), re
659         return re, im, acc, acc
660 
661 
662 def evalf_pow(v, prec, options):
663 
664     target_prec = prec
665     base, exp = v.args
666 
667     # We handle x**n separately. This has two purposes: 1) it is much
668     # faster, because we avoid calling evalf on the exponent, and 2) it
669     # allows better handling of real/imaginary parts that are exactly zero
670     if exp.is_Integer:
671         p = exp.p
672         # Exact
673         if not p:
674             return fone, None, prec, None
675         # Exponentiation by p magnifies relative error by |p|, so the
676         # base must be evaluated with increased precision if p is large
677         prec += int(math.log(abs(p), 2))
678         re, im, re_acc, im_acc = evalf(base, prec + 5, options)
679         # Real to integer power
680         if re and not im:
681             return mpf_pow_int(re, p, target_prec), None, target_prec, None
682         # (x*I)**n = I**n * x**n
683         if im and not re:
684             z = mpf_pow_int(im, p, target_prec)
685             case = p % 4
686             if case == 0:
687                 return z, None, target_prec, None
688             if case == 1:
689                 return None, z, None, target_prec
690             if case == 2:
691                 return mpf_neg(z), None, target_prec, None
692             if case == 3:
693                 return None, mpf_neg(z), None, target_prec
694         # Zero raised to an integer power
695         if not re:
696             return None, None, None, None
697         # General complex number to arbitrary integer power
698         re, im = libmp.mpc_pow_int((re, im), p, prec)
699         # Assumes full accuracy in input
700         return finalize_complex(re, im, target_prec)
701 
702     # Pure square root
703     if exp is S.Half:
704         xre, xim, _, _ = evalf(base, prec + 5, options)
705         # General complex square root
706         if xim:
707             re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)
708             return finalize_complex(re, im, prec)
709         if not xre:
710             return None, None, None, None
711         # Square root of a negative real number
712         if mpf_lt(xre, fzero):
713             return None, mpf_sqrt(mpf_neg(xre), prec), None, prec
714         # Positive square root
715         return mpf_sqrt(xre, prec), None, prec, None
716 
717     # We first evaluate the exponent to find its magnitude
718     # This determines the working precision that must be used
719     prec += 10
720     yre, yim, _, _ = evalf(exp, prec, options)
721     # Special cases: x**0
722     if not (yre or yim):
723         return fone, None, prec, None
724 
725     ysize = fastlog(yre)
726     # Restart if too big
727     # XXX: prec + ysize might exceed maxprec
728     if ysize > 5:
729         prec += ysize
730         yre, yim, _, _ = evalf(exp, prec, options)
731 
732     # Pure exponential function; no need to evalf the base
733     if base is S.Exp1:
734         if yim:
735             re, im = libmp.mpc_exp((yre or fzero, yim), prec)
736             return finalize_complex(re, im, target_prec)
737         return mpf_exp(yre, target_prec), None, target_prec, None
738 
739     xre, xim, _, _ = evalf(base, prec + 5, options)
740     # 0**y
741     if not (xre or xim):
742         return None, None, None, None
743 
744     # (real ** complex) or (complex ** complex)
745     if yim:
746         re, im = libmp.mpc_pow(
747             (xre or fzero, xim or fzero), (yre or fzero, yim),
748             target_prec)
749         return finalize_complex(re, im, target_prec)
750     # complex ** real
751     if xim:
752         re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)
753         return finalize_complex(re, im, target_prec)
754     # negative ** real
755     elif mpf_lt(xre, fzero):
756         re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)
757         return finalize_complex(re, im, target_prec)
758     # positive ** real
759     else:
760         return mpf_pow(xre, yre, target_prec), None, target_prec, None
761 
762 
763 #----------------------------------------------------------------------------#
764 #                                                                            #
765 #                            Special functions                               #
766 #                                                                            #
767 #----------------------------------------------------------------------------#
768 def evalf_trig(v, prec, options):
769     """
770     This function handles sin and cos of complex arguments.
771 
772     TODO: should also handle tan of complex arguments.
773     """
774     from sympy import cos, sin
775     if isinstance(v, cos):
776         func = mpf_cos
777     elif isinstance(v, sin):
778         func = mpf_sin
779     else:
780         raise NotImplementedError
781     arg = v.args[0]
782     # 20 extra bits is possibly overkill. It does make the need
783     # to restart very unlikely
784     xprec = prec + 20
785     re, im, re_acc, im_acc = evalf(arg, xprec, options)
786     if im:
787         if 'subs' in options:
788             v = v.subs(options['subs'])
789         return evalf(v._eval_evalf(prec), prec, options)
790     if not re:
791         if isinstance(v, cos):
792             return fone, None, prec, None
793         elif isinstance(v, sin):
794             return None, None, None, None
795         else:
796             raise NotImplementedError
797     # For trigonometric functions, we are interested in the
798     # fixed-point (absolute) accuracy of the argument.
799     xsize = fastlog(re)
800     # Magnitude <= 1.0. OK to compute directly, because there is no
801     # danger of hitting the first root of cos (with sin, magnitude
802     # <= 2.0 would actually be ok)
803     if xsize < 1:
804         return func(re, prec, rnd), None, prec, None
805     # Very large
806     if xsize >= 10:
807         xprec = prec + xsize
808         re, im, re_acc, im_acc = evalf(arg, xprec, options)
809     # Need to repeat in case the argument is very close to a
810     # multiple of pi (or pi/2), hitting close to a root
811     while 1:
812         y = func(re, prec, rnd)
813         ysize = fastlog(y)
814         gap = -ysize
815         accuracy = (xprec - xsize) - gap
816         if accuracy < prec:
817             if options.get('verbose'):
818                 print("SIN/COS", accuracy, "wanted", prec, "gap", gap)
819                 print(to_str(y, 10))
820             if xprec > options.get('maxprec', DEFAULT_MAXPREC):
821                 return y, None, accuracy, None
822             xprec += gap
823             re, im, re_acc, im_acc = evalf(arg, xprec, options)
824             continue
825         else:
826             return y, None, prec, None
827 
828 
829 def evalf_log(expr, prec, options):
830     from sympy import Abs, Add, log
831     if len(expr.args)>1:
832         expr = expr.doit()
833         return evalf(expr, prec, options)
834     arg = expr.args[0]
835     workprec = prec + 10
836     xre, xim, xacc, _ = evalf(arg, workprec, options)
837 
838     if xim:
839         # XXX: use get_abs etc instead
840         re = evalf_log(
841             log(Abs(arg, evaluate=False), evaluate=False), prec, options)
842         im = mpf_atan2(xim, xre or fzero, prec)
843         return re[0], im, re[2], prec
844 
845     imaginary_term = (mpf_cmp(xre, fzero) < 0)
846 
847     re = mpf_log(mpf_abs(xre), prec, rnd)
848     size = fastlog(re)
849     if prec - size > workprec and re != fzero:
850         # We actually need to compute 1+x accurately, not x
851         arg = Add(S.NegativeOne, arg, evaluate=False)
852         xre, xim, _, _ = evalf_add(arg, prec, options)
853         prec2 = workprec - fastlog(xre)
854         # xre is now x - 1 so we add 1 back here to calculate x
855         re = mpf_log(mpf_abs(mpf_add(xre, fone, prec2)), prec, rnd)
856 
857     re_acc = prec
858 
859     if imaginary_term:
860         return re, mpf_pi(prec), re_acc, prec
861     else:
862         return re, None, re_acc, None
863 
864 
865 def evalf_atan(v, prec, options):
866     arg = v.args[0]
867     xre, xim, reacc, imacc = evalf(arg, prec + 5, options)
868     if xre is xim is None:
869         return (None,)*4
870     if xim:
871         raise NotImplementedError
872     return mpf_atan(xre, prec, rnd), None, prec, None
873 
874 
875 def evalf_subs(prec, subs):
876     """ Change all Float entries in `subs` to have precision prec. """
877     newsubs = {}
878     for a, b in subs.items():
879         b = S(b)
880         if b.is_Float:
881             b = b._eval_evalf(prec)
882         newsubs[a] = b
883     return newsubs
884 
885 
886 def evalf_piecewise(expr, prec, options):
887     from sympy import Float, Integer
888     if 'subs' in options:
889         expr = expr.subs(evalf_subs(prec, options['subs']))
890         newopts = options.copy()
891         del newopts['subs']
892         if hasattr(expr, 'func'):
893             return evalf(expr, prec, newopts)
894         if type(expr) == float:
895             return evalf(Float(expr), prec, newopts)
896         if type(expr) == int:
897             return evalf(Integer(expr), prec, newopts)
898 
899     # We still have undefined symbols
900     raise NotImplementedError
901 
902 
903 def evalf_bernoulli(expr, prec, options):
904     arg = expr.args[0]
905     if not arg.is_Integer:
906         raise ValueError("Bernoulli number index must be an integer")
907     n = int(arg)
908     b = mpf_bernoulli(n, prec, rnd)
909     if b == fzero:
910         return None, None, None, None
911     return b, None, prec, None
912 
913 #----------------------------------------------------------------------------#
914 #                                                                            #
915 #                            High-level operations                           #
916 #                                                                            #
917 #----------------------------------------------------------------------------#
918 
919 
920 def as_mpmath(x, prec, options):
921     from sympy.core.numbers import Infinity, NegativeInfinity, Zero
922     x = sympify(x)
923     if isinstance(x, Zero) or x == 0:
924         return mpf(0)
925     if isinstance(x, Infinity):
926         return mpf('inf')
927     if isinstance(x, NegativeInfinity):
928         return mpf('-inf')
929     # XXX
930     re, im, _, _ = evalf(x, prec, options)
931     if im:
932         return mpc(re or fzero, im)
933     return mpf(re)
934 
935 
936 def do_integral(expr, prec, options):
937     func = expr.args[0]
938     x, xlow, xhigh = expr.args[1]
939     if xlow == xhigh:
940         xlow = xhigh = 0
941     elif x not in func.free_symbols:
942         # only the difference in limits matters in this case
943         # so if there is a symbol in common that will cancel
944         # out when taking the difference, then use that
945         # difference
946         if xhigh.free_symbols & xlow.free_symbols:
947             diff = xhigh - xlow
948             if diff.is_number:
949                 xlow, xhigh = 0, diff
950 
951     oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
952     options['maxprec'] = min(oldmaxprec, 2*prec)
953 
954     with workprec(prec + 5):
955         xlow = as_mpmath(xlow, prec + 15, options)
956         xhigh = as_mpmath(xhigh, prec + 15, options)
957 
958         # Integration is like summation, and we can phone home from
959         # the integrand function to update accuracy summation style
960         # Note that this accuracy is inaccurate, since it fails
961         # to account for the variable quadrature weights,
962         # but it is better than nothing
963 
964         from sympy import cos, sin, Wild
965 
966         have_part = [False, False]
967         max_real_term = [MINUS_INF]
968         max_imag_term = [MINUS_INF]
969 
970         def f(t):
971             re, im, re_acc, im_acc = evalf(func, mp.prec, {'subs': {x: t}})
972 
973             have_part[0] = re or have_part[0]
974             have_part[1] = im or have_part[1]
975 
976             max_real_term[0] = max(max_real_term[0], fastlog(re))
977             max_imag_term[0] = max(max_imag_term[0], fastlog(im))
978 
979             if im:
980                 return mpc(re or fzero, im)
981             return mpf(re or fzero)
982 
983         if options.get('quad') == 'osc':
984             A = Wild('A', exclude=[x])
985             B = Wild('B', exclude=[x])
986             D = Wild('D')
987             m = func.match(cos(A*x + B)*D)
988             if not m:
989                 m = func.match(sin(A*x + B)*D)
990             if not m:
991                 raise ValueError("An integrand of the form sin(A*x+B)*f(x) "
992                   "or cos(A*x+B)*f(x) is required for oscillatory quadrature")
993             period = as_mpmath(2*S.Pi/m[A], prec + 15, options)
994             result = quadosc(f, [xlow, xhigh], period=period)
995             # XXX: quadosc does not do error detection yet
996             quadrature_error = MINUS_INF
997         else:
998             result, quadrature_error = quadts(f, [xlow, xhigh], error=1)
999             quadrature_error = fastlog(quadrature_error._mpf_)
1000 
1001     options['maxprec'] = oldmaxprec
1002 
1003     if have_part[0]:
1004         re = result.real._mpf_
1005         if re == fzero:
1006             re, re_acc = scaled_zero(
1007                 min(-prec, -max_real_term[0], -quadrature_error))
1008             re = scaled_zero(re)  # handled ok in evalf_integral
1009         else:
1010             re_acc = -max(max_real_term[0] - fastlog(re) -
1011                           prec, quadrature_error)
1012     else:
1013         re, re_acc = None, None
1014 
1015     if have_part[1]:
1016         im = result.imag._mpf_
1017         if im == fzero:
1018             im, im_acc = scaled_zero(
1019                 min(-prec, -max_imag_term[0], -quadrature_error))
1020             im = scaled_zero(im)  # handled ok in evalf_integral
1021         else:
1022             im_acc = -max(max_imag_term[0] - fastlog(im) -
1023                           prec, quadrature_error)
1024     else:
1025         im, im_acc = None, None
1026 
1027     result = re, im, re_acc, im_acc
1028     return result
1029 
1030 
1031 def evalf_integral(expr, prec, options):
1032     limits = expr.limits
1033     if len(limits) != 1 or len(limits[0]) != 3:
1034         raise NotImplementedError
1035     workprec = prec
1036     i = 0
1037     maxprec = options.get('maxprec', INF)
1038     while 1:
1039         result = do_integral(expr, workprec, options)
1040         accuracy = complex_accuracy(result)
1041         if accuracy >= prec:  # achieved desired precision
1042             break
1043         if workprec >= maxprec:  # can't increase accuracy any more
1044             break
1045         if accuracy == -1:
1046             # maybe the answer really is zero and maybe we just haven't increased
1047             # the precision enough. So increase by doubling to not take too long
1048             # to get to maxprec.
1049             workprec *= 2
1050         else:
1051             workprec += max(prec, 2**i)
1052         workprec = min(workprec, maxprec)
1053         i += 1
1054     return result
1055 
1056 
1057 def check_convergence(numer, denom, n):
1058     """
1059     Returns (h, g, p) where
1060     -- h is:
1061         > 0 for convergence of rate 1/factorial(n)**h
1062         < 0 for divergence of rate factorial(n)**(-h)
1063         = 0 for geometric or polynomial convergence or divergence
1064 
1065     -- abs(g) is:
1066         > 1 for geometric convergence of rate 1/h**n
1067         < 1 for geometric divergence of rate h**n
1068         = 1 for polynomial convergence or divergence
1069 
1070         (g < 0 indicates an alternating series)
1071 
1072     -- p is:
1073         > 1 for polynomial convergence of rate 1/n**h
1074         <= 1 for polynomial divergence of rate n**(-h)
1075 
1076     """
1077     from sympy import Poly
1078     npol = Poly(numer, n)
1079     dpol = Poly(denom, n)
1080     p = npol.degree()
1081     q = dpol.degree()
1082     rate = q - p
1083     if rate:
1084         return rate, None, None
1085     constant = dpol.LC() / npol.LC()
1086     if abs(constant) != 1:
1087         return rate, constant, None
1088     if npol.degree() == dpol.degree() == 0:
1089         return rate, constant, 0
1090     pc = npol.all_coeffs()[1]
1091     qc = dpol.all_coeffs()[1]
1092     return rate, constant, (qc - pc)/dpol.LC()
1093 
1094 
1095 def hypsum(expr, n, start, prec):
1096     """
1097     Sum a rapidly convergent infinite hypergeometric series with
1098     given general term, e.g. e = hypsum(1/factorial(n), n). The
1099     quotient between successive terms must be a quotient of integer
1100     polynomials.
1101     """
1102     from sympy import Float, hypersimp, lambdify
1103 
1104     if prec == float('inf'):
1105         raise NotImplementedError('does not support inf prec')
1106 
1107     if start:
1108         expr = expr.subs(n, n + start)
1109     hs = hypersimp(expr, n)
1110     if hs is None:
1111         raise NotImplementedError("a hypergeometric series is required")
1112     num, den = hs.as_numer_denom()
1113 
1114     func1 = lambdify(n, num)
1115     func2 = lambdify(n, den)
1116 
1117     h, g, p = check_convergence(num, den, n)
1118 
1119     if h < 0:
1120         raise ValueError("Sum diverges like (n!)^%i" % (-h))
1121 
1122     term = expr.subs(n, 0)
1123     if not term.is_Rational:
1124         raise NotImplementedError("Non rational term functionality is not implemented.")
1125 
1126     # Direct summation if geometric or faster
1127     if h > 0 or (h == 0 and abs(g) > 1):
1128         term = (MPZ(term.p) << prec) // term.q
1129         s = term
1130         k = 1
1131         while abs(term) > 5:
1132             term *= MPZ(func1(k - 1))
1133             term //= MPZ(func2(k - 1))
1134             s += term
1135             k += 1
1136         return from_man_exp(s, -prec)
1137     else:
1138         alt = g < 0
1139         if abs(g) < 1:
1140             raise ValueError("Sum diverges like (%i)^n" % abs(1/g))
1141         if p < 1 or (p == 1 and not alt):
1142             raise ValueError("Sum diverges like n^%i" % (-p))
1143         # We have polynomial convergence: use Richardson extrapolation
1144         vold = None
1145         ndig = prec_to_dps(prec)
1146         while True:
1147             # Need to use at least quad precision because a lot of cancellation
1148             # might occur in the extrapolation process; we check the answer to
1149             # make sure that the desired precision has been reached, too.
1150             prec2 = 4*prec
1151             term0 = (MPZ(term.p) << prec2) // term.q
1152 
1153             def summand(k, _term=[term0]):
1154                 if k:
1155                     k = int(k)
1156                     _term[0] *= MPZ(func1(k - 1))
1157                     _term[0] //= MPZ(func2(k - 1))
1158                 return make_mpf(from_man_exp(_term[0], -prec2))
1159 
1160             with workprec(prec):
1161                 v = nsum(summand, [0, mpmath_inf], method='richardson')
1162             vf = Float(v, ndig)
1163             if vold is not None and vold == vf:
1164                 break
1165             prec += prec  # double precision each time
1166             vold = vf
1167 
1168         return v._mpf_
1169 
1170 
1171 def evalf_prod(expr, prec, options):
1172     from sympy import Sum
1173     if all((l[1] - l[2]).is_Integer for l in expr.limits):
1174         re, im, re_acc, im_acc = evalf(expr.doit(), prec=prec, options=options)
1175     else:
1176         re, im, re_acc, im_acc = evalf(expr.rewrite(Sum), prec=prec, options=options)
1177     return re, im, re_acc, im_acc
1178 
1179 
1180 def evalf_sum(expr, prec, options):
1181     from sympy import Float
1182     if 'subs' in options:
1183         expr = expr.subs(options['subs'])
1184     func = expr.function
1185     limits = expr.limits
1186     if len(limits) != 1 or len(limits[0]) != 3:
1187         raise NotImplementedError
1188     if func is S.Zero:
1189         return None, None, prec, None
1190     prec2 = prec + 10
1191     try:
1192         n, a, b = limits[0]
1193         if b != S.Infinity or a != int(a):
1194             raise NotImplementedError
1195         # Use fast hypergeometric summation if possible
1196         v = hypsum(func, n, int(a), prec2)
1197         delta = prec - fastlog(v)
1198         if fastlog(v) < -10:
1199             v = hypsum(func, n, int(a), delta)
1200         return v, None, min(prec, delta), None
1201     except NotImplementedError:
1202         # Euler-Maclaurin summation for general series
1203         eps = Float(2.0)**(-prec)
1204         for i in range(1, 5):
1205             m = n = 2**i * prec
1206             s, err = expr.euler_maclaurin(m=m, n=n, eps=eps,
1207                 eval_integral=False)
1208             err = err.evalf()
1209             if err <= eps:
1210                 break
1211         err = fastlog(evalf(abs(err), 20, options)[0])
1212         re, im, re_acc, im_acc = evalf(s, prec2, options)
1213         if re_acc is None:
1214             re_acc = -err
1215         if im_acc is None:
1216             im_acc = -err
1217         return re, im, re_acc, im_acc
1218 
1219 
1220 #----------------------------------------------------------------------------#
1221 #                                                                            #
1222 #                            Symbolic interface                              #
1223 #                                                                            #
1224 #----------------------------------------------------------------------------#
1225 
1226 def evalf_symbol(x, prec, options):
1227     val = options['subs'][x]
1228     if isinstance(val, mpf):
1229         if not val:
1230             return None, None, None, None
1231         return val._mpf_, None, prec, None
1232     else:
1233         if not '_cache' in options:
1234             options['_cache'] = {}
1235         cache = options['_cache']
1236         cached, cached_prec = cache.get(x, (None, MINUS_INF))
1237         if cached_prec >= prec:
1238             return cached
1239         v = evalf(sympify(val), prec, options)
1240         cache[x] = (v, prec)
1241         return v
1242 
1243 evalf_table = None
1244 
1245 
1246 def _create_evalf_table():
1247     global evalf_table
1248     from sympy.functions.combinatorial.numbers import bernoulli
1249     from sympy.concrete.products import Product
1250     from sympy.concrete.summations import Sum
1251     from sympy.core.add import Add
1252     from sympy.core.mul import Mul
1253     from sympy.core.numbers import Exp1, Float, Half, ImaginaryUnit, Integer, NaN, NegativeOne, One, Pi, Rational, Zero
1254     from sympy.core.power import Pow
1255     from sympy.core.symbol import Dummy, Symbol
1256     from sympy.functions.elementary.complexes import Abs, im, re
1257     from sympy.functions.elementary.exponential import exp, log
1258     from sympy.functions.elementary.integers import ceiling, floor
1259     from sympy.functions.elementary.piecewise import Piecewise
1260     from sympy.functions.elementary.trigonometric import atan, cos, sin
1261     from sympy.integrals.integrals import Integral
1262     evalf_table = {
1263         Symbol: evalf_symbol,
1264         Dummy: evalf_symbol,
1265         Float: lambda x, prec, options: (x._mpf_, None, prec, None),
1266         Rational: lambda x, prec, options: (from_rational(x.p, x.q, prec), None, prec, None),
1267         Integer: lambda x, prec, options: (from_int(x.p, prec), None, prec, None),
1268         Zero: lambda x, prec, options: (None, None, prec, None),
1269         One: lambda x, prec, options: (fone, None, prec, None),
1270         Half: lambda x, prec, options: (fhalf, None, prec, None),
1271         Pi: lambda x, prec, options: (mpf_pi(prec), None, prec, None),
1272         Exp1: lambda x, prec, options: (mpf_e(prec), None, prec, None),
1273         ImaginaryUnit: lambda x, prec, options: (None, fone, None, prec),
1274         NegativeOne: lambda x, prec, options: (fnone, None, prec, None),
1275         NaN: lambda x, prec, options: (fnan, None, prec, None),
1276 
1277         exp: lambda x, prec, options: evalf_pow(
1278             Pow(S.Exp1, x.args[0], evaluate=False), prec, options),
1279 
1280         cos: evalf_trig,
1281         sin: evalf_trig,
1282 
1283         Add: evalf_add,
1284         Mul: evalf_mul,
1285         Pow: evalf_pow,
1286 
1287         log: evalf_log,
1288         atan: evalf_atan,
1289         Abs: evalf_abs,
1290 
1291         re: evalf_re,
1292         im: evalf_im,
1293         floor: evalf_floor,
1294         ceiling: evalf_ceiling,
1295 
1296         Integral: evalf_integral,
1297         Sum: evalf_sum,
1298         Product: evalf_prod,
1299         Piecewise: evalf_piecewise,
1300 
1301         bernoulli: evalf_bernoulli,
1302     }
1303 
1304 
1305 def evalf(x, prec, options):
1306     from sympy import re as re_, im as im_
1307     try:
1308         rf = evalf_table[x.func]
1309         r = rf(x, prec, options)
1310     except KeyError:
1311         # Fall back to ordinary evalf if possible
1312         if 'subs' in options:
1313             x = x.subs(evalf_subs(prec, options['subs']))
1314         xe = x._eval_evalf(prec)
1315         if xe is None:
1316             raise NotImplementedError
1317         as_real_imag = getattr(xe, "as_real_imag", None)
1318         if as_real_imag is None:
1319             raise NotImplementedError # e.g. FiniteSet(-1.0, 1.0).evalf()
1320         re, im = as_real_imag()
1321         if re.has(re_) or im.has(im_):
1322             raise NotImplementedError
1323         if re == 0:
1324             re = None
1325             reprec = None
1326         elif re.is_number:
1327             re = re._to_mpmath(prec, allow_ints=False)._mpf_
1328             reprec = prec
1329         else:
1330             raise NotImplementedError
1331         if im == 0:
1332             im = None
1333             imprec = None
1334         elif im.is_number:
1335             im = im._to_mpmath(prec, allow_ints=False)._mpf_
1336             imprec = prec
1337         else:
1338             raise NotImplementedError
1339         r = re, im, reprec, imprec
1340 
1341     if options.get("verbose"):
1342         print("### input", x)
1343         print("### output", to_str(r[0] or fzero, 50))
1344         print("### raw", r) # r[0], r[2]
1345         print()
1346     chop = options.get('chop', False)
1347     if chop:
1348         if chop is True:
1349             chop_prec = prec
1350         else:
1351             # convert (approximately) from given tolerance;
1352             # the formula here will will make 1e-i rounds to 0 for
1353             # i in the range +/-27 while 2e-i will not be chopped
1354             chop_prec = int(round(-3.321*math.log10(chop) + 2.5))
1355             if chop_prec == 3:
1356                 chop_prec -= 1
1357         r = chop_parts(r, chop_prec)
1358     if options.get("strict"):
1359         check_target(x, r, prec)
1360     return r
1361 
1362 
1363 class EvalfMixin(object):
1364     """Mixin class adding evalf capabililty."""
1365 
1366     __slots__ = []
1367 
1368     def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
1369         """
1370         Evaluate the given formula to an accuracy of n digits.
1371         Optional keyword arguments:
1372 
1373             subs=<dict>
1374                 Substitute numerical values for symbols, e.g.
1375                 subs={x:3, y:1+pi}. The substitutions must be given as a
1376                 dictionary.
1377 
1378             maxn=<integer>
1379                 Allow a maximum temporary working precision of maxn digits
1380                 (default=100)
1381 
1382             chop=<bool>
1383                 Replace tiny real or imaginary parts in subresults
1384                 by exact zeros (default=False)
1385 
1386             strict=<bool>
1387                 Raise PrecisionExhausted if any subresult fails to evaluate
1388                 to full accuracy, given the available maxprec
1389                 (default=False)
1390 
1391             quad=<str>
1392                 Choose algorithm for numerical quadrature. By default,
1393                 tanh-sinh quadrature is used. For oscillatory
1394                 integrals on an infinite interval, try quad='osc'.
1395 
1396             verbose=<bool>
1397                 Print debug information (default=False)
1398 
1399         Notes
1400         =====
1401 
1402         When Floats are naively substituted into an expression, precision errors
1403         may adversely affect the result. For example, adding 1e16 (a Float) to 1
1404         will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
1405         That is exactly what happens in the following:
1406 
1407         >>> from sympy.abc import x, y, z
1408         >>> values = {x: 1e16, y: 1, z: 1e16}
1409         >>> (x + y - z).subs(values)
1410         0
1411 
1412         Using the subs argument for evalf is the accurate way to evaluate such an
1413         expression:
1414 
1415         >>> (x + y - z).evalf(subs=values)
1416         1.00000000000000
1417         """
1418         from sympy import Float, Number
1419         n = n if n is not None else 15
1420 
1421         if subs and is_sequence(subs):
1422             raise TypeError('subs must be given as a dictionary')
1423 
1424         # for sake of sage that doesn't like evalf(1)
1425         if n == 1 and isinstance(self, Number):
1426             from sympy.core.expr import _mag
1427             rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
1428             m = _mag(rv)
1429             rv = rv.round(1 - m)
1430             return rv
1431 
1432         if not evalf_table:
1433             _create_evalf_table()
1434         prec = dps_to_prec(n)
1435         options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,
1436                'strict': strict, 'verbose': verbose}
1437         if subs is not None:
1438             options['subs'] = subs
1439         if quad is not None:
1440             options['quad'] = quad
1441         try:
1442             result = evalf(self, prec + 4, options)
1443         except NotImplementedError:
1444             # Fall back to the ordinary evalf
1445             v = self._eval_evalf(prec)
1446             if v is None:
1447                 return self
1448             elif not v.is_number:
1449                 return v
1450             try:
1451                 # If the result is numerical, normalize it
1452                 result = evalf(v, prec, options)
1453             except NotImplementedError:
1454                 # Probably contains symbols or unknown functions
1455                 return v
1456         re, im, re_acc, im_acc = result
1457         if re:
1458             p = max(min(prec, re_acc), 1)
1459             re = Float._new(re, p)
1460         else:
1461             re = S.Zero
1462         if im:
1463             p = max(min(prec, im_acc), 1)
1464             im = Float._new(im, p)
1465             return re + im*S.ImaginaryUnit
1466         else:
1467             return re
1468 
1469     n = evalf
1470 
1471     def _evalf(self, prec):
1472         """Helper for evalf. Does the same thing but takes binary precision"""
1473         r = self._eval_evalf(prec)
1474         if r is None:
1475             r = self
1476         return r
1477 
1478     def _eval_evalf(self, prec):
1479         return
1480 
1481     def _to_mpmath(self, prec, allow_ints=True):
1482         # mpmath functions accept ints as input
1483         errmsg = "cannot convert to mpmath number"
1484         if allow_ints and self.is_Integer:
1485             return self.p
1486         if hasattr(self, '_as_mpf_val'):
1487             return make_mpf(self._as_mpf_val(prec))
1488         try:
1489             re, im, _, _ = evalf(self, prec, {})
1490             if im:
1491                 if not re:
1492                     re = fzero
1493                 return make_mpc((re, im))
1494             elif re:
1495                 return make_mpf(re)
1496             else:
1497                 return make_mpf(fzero)
1498         except NotImplementedError:
1499             v = self._eval_evalf(prec)
1500             if v is None:
1501                 raise ValueError(errmsg)
1502             if v.is_Float:
1503                 return make_mpf(v._mpf_)
1504             # Number + Number*I is also fine
1505             re, im = v.as_real_imag()
1506             if allow_ints and re.is_Integer:
1507                 re = from_int(re.p)
1508             elif re.is_Float:
1509                 re = re._mpf_
1510             else:
1511                 raise ValueError(errmsg)
1512             if allow_ints and im.is_Integer:
1513                 im = from_int(im.p)
1514             elif im.is_Float:
1515                 im = im._mpf_
1516             else:
1517                 raise ValueError(errmsg)
1518             return make_mpc((re, im))
1519 
1520 
1521 def N(x, n=15, **options):
1522     r"""
1523     Calls x.evalf(n, \*\*options).
1524 
1525     Both .n() and N() are equivalent to .evalf(); use the one that you like better.
1526     See also the docstring of .evalf() for information on the options.
1527 
1528     Examples
1529     ========
1530 
1531     >>> from sympy import Sum, oo, N
1532     >>> from sympy.abc import k
1533     >>> Sum(1/k**k, (k, 1, oo))
1534     Sum(k**(-k), (k, 1, oo))
1535     >>> N(_, 4)
1536     1.291
1537 
1538     """
1539     return sympify(x).evalf(n, **options)

</code><intended_behavior>The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result.</intended_behavior>, <file>sympy/core/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import absolute_import, print_function, division
2 
3 import numbers
4 import decimal
5 import fractions
6 import math
7 import re as regex
8 
9 from .containers import Tuple
10 from .sympify import converter, sympify, _sympify, SympifyError, _convert_numpy_types
11 from .singleton import S, Singleton
12 from .expr import Expr, AtomicExpr
13 from .decorators import _sympifyit
14 from .cache import cacheit, clear_cache
15 from .logic import fuzzy_not
16 from sympy.core.compatibility import (
17     as_int, integer_types, long, string_types, with_metaclass, HAS_GMPY,
18     SYMPY_INTS, int_info)
19 from sympy.core.cache import lru_cache
20 
21 import mpmath
22 import mpmath.libmp as mlib
23 from mpmath.libmp.backend import MPZ
24 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed
25 from mpmath.ctx_mp import mpnumeric
26 from mpmath.libmp.libmpf import (
27     finf as _mpf_inf, fninf as _mpf_ninf,
28     fnan as _mpf_nan, fzero as _mpf_zero, _normalize as mpf_normalize,
29     prec_to_dps)
30 from sympy.utilities.misc import debug, filldedent
31 from .evaluate import global_evaluate
32 
33 from sympy.utilities.exceptions import SymPyDeprecationWarning
34 
35 rnd = mlib.round_nearest
36 
37 _LOG2 = math.log(2)
38 
39 
40 def comp(z1, z2, tol=None):
41     """Return a bool indicating whether the error between z1 and z2 is <= tol.
42 
43     If ``tol`` is None then True will be returned if there is a significant
44     difference between the numbers: ``abs(z1 - z2)*10**p <= 1/2`` where ``p``
45     is the lower of the precisions of the values. A comparison of strings will
46     be made if ``z1`` is a Number and a) ``z2`` is a string or b) ``tol`` is ''
47     and ``z2`` is a Number.
48 
49     When ``tol`` is a nonzero value, if z2 is non-zero and ``|z1| > 1``
50     the error is normalized by ``|z1|``, so if you want to see if the
51     absolute error between ``z1`` and ``z2`` is <= ``tol`` then call this
52     as ``comp(z1 - z2, 0, tol)``.
53     """
54     if type(z2) is str:
55         if not isinstance(z1, Number):
56             raise ValueError('when z2 is a str z1 must be a Number')
57         return str(z1) == z2
58     if not z1:
59         z1, z2 = z2, z1
60     if not z1:
61         return True
62     if not tol:
63         if tol is None:
64             if type(z2) is str and getattr(z1, 'is_Number', False):
65                 return str(z1) == z2
66             a, b = Float(z1), Float(z2)
67             return int(abs(a - b)*10**prec_to_dps(
68                 min(a._prec, b._prec)))*2 <= 1
69         elif all(getattr(i, 'is_Number', False) for i in (z1, z2)):
70             return z1._prec == z2._prec and str(z1) == str(z2)
71         raise ValueError('exact comparison requires two Numbers')
72     diff = abs(z1 - z2)
73     az1 = abs(z1)
74     if z2 and az1 > 1:
75         return diff/az1 <= tol
76     else:
77         return diff <= tol
78 
79 
80 def mpf_norm(mpf, prec):
81     """Return the mpf tuple normalized appropriately for the indicated
82     precision after doing a check to see if zero should be returned or
83     not when the mantissa is 0. ``mpf_normlize`` always assumes that this
84     is zero, but it may not be since the mantissa for mpf's values "+inf",
85     "-inf" and "nan" have a mantissa of zero, too.
86 
87     Note: this is not intended to validate a given mpf tuple, so sending
88     mpf tuples that were not created by mpmath may produce bad results. This
89     is only a wrapper to ``mpf_normalize`` which provides the check for non-
90     zero mpfs that have a 0 for the mantissa.
91     """
92     sign, man, expt, bc = mpf
93     if not man:
94         # hack for mpf_normalize which does not do this;
95         # it assumes that if man is zero the result is 0
96         # (see issue 6639)
97         if not bc:
98             return _mpf_zero
99         else:
100             # don't change anything; this should already
101             # be a well formed mpf tuple
102             return mpf
103 
104     # Necessary if mpmath is using the gmpy backend
105     from mpmath.libmp.backend import MPZ
106     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
107     return rv
108 
109 # TODO: we should use the warnings module
110 _errdict = {"divide": False}
111 
112 
113 def seterr(divide=False):
114     """
115     Should sympy raise an exception on 0/0 or return a nan?
116 
117     divide == True .... raise an exception
118     divide == False ... return nan
119     """
120     if _errdict["divide"] != divide:
121         clear_cache()
122         _errdict["divide"] = divide
123 
124 
125 def _as_integer_ratio(p):
126     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)
127     p = [1, -1][neg_pow % 2]*man
128     if expt < 0:
129         q = 2**-expt
130     else:
131         q = 1
132         p *= 2**expt
133     return int(p), int(q)
134 
135 
136 def _decimal_to_Rational_prec(dec):
137     """Convert an ordinary decimal instance to a Rational."""
138     if not dec.is_finite():
139         raise TypeError("dec must be finite, got %s." % dec)
140     s, d, e = dec.as_tuple()
141     prec = len(d)
142     if e >= 0:  # it's an integer
143         rv = Integer(int(dec))
144     else:
145         s = (-1)**s
146         d = sum([di*10**i for i, di in enumerate(reversed(d))])
147         rv = Rational(s*d, 10**-e)
148     return rv, prec
149 
150 
151 _floatpat = regex.compile(r"[-+]?((\d*\.\d+)|(\d+\.?))")
152 def _literal_float(f):
153     """Return True if n starts like a floating point number."""
154     return bool(_floatpat.match(f))
155 
156 # (a,b) -> gcd(a,b)
157 
158 # TODO caching with decorator, but not to degrade performance
159 
160 @lru_cache(1024)
161 def igcd(*args):
162     """Computes nonnegative integer greatest common divisor.
163 
164     The algorithm is based on the well known Euclid's algorithm. To
165     improve speed, igcd() has its own caching mechanism implemented.
166 
167     Examples
168     ========
169 
170     >>> from sympy.core.numbers import igcd
171     >>> igcd(2, 4)
172     2
173     >>> igcd(5, 10, 15)
174     5
175 
176     """
177     if len(args) < 2:
178         raise TypeError(
179             'igcd() takes at least 2 arguments (%s given)' % len(args))
180     args_temp = [abs(as_int(i)) for i in args]
181     if 1 in args_temp:
182         return 1
183     a = args_temp.pop()
184     for b in args_temp:
185         a = igcd2(a, b) if b else a
186     return a
187 
188 
189 try:
190     from math import gcd as igcd2
191 except ImportError:
192     def igcd2(a, b):
193         """Compute gcd of two Python integers a and b."""
194         if (a.bit_length() > BIGBITS and
195             b.bit_length() > BIGBITS):
196             return igcd_lehmer(a, b)
197 
198         a, b = abs(a), abs(b)
199         while b:
200             a, b = b, a % b
201         return a
202 
203 
204 # Use Lehmer's algorithm only for very large numbers.
205 # The limit could be different on Python 2.7 and 3.x.
206 # If so, then this could be defined in compatibility.py.
207 BIGBITS = 5000
208 def igcd_lehmer(a, b):
209     """Computes greatest common divisor of two integers.
210 
211     Euclid's algorithm for the computation of the greatest
212     common divisor  gcd(a, b)  of two (positive) integers
213     a and b is based on the division identity
214         a = q*b + r,
215     where the quotient  q  and the remainder  r  are integers
216     and  0 <= r < b. Then each common divisor of  a  and  b
217     divides  r, and it follows that  gcd(a, b) == gcd(b, r).
218     The algorithm works by constructing the sequence
219     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn
220     is the remainder from the division of the two preceding
221     elements.
222 
223     In Python, q = a // b  and  r = a % b  are obtained by the
224     floor division and the remainder operations, respectively.
225     These are the most expensive arithmetic operations, especially
226     for large  a  and  b.
227 
228     Lehmer's algorithm is based on the observation that the quotients
229     qn = r(n-1) // rn  are in general small integers even
230     when  a  and  b  are very large. Hence the quotients can be
231     usually determined from a relatively small number of most
232     significant bits.
233 
234     The efficiency of the algorithm is further enhanced by not
235     computing each long remainder in Euclid's sequence. The remainders
236     are linear combinations of  a  and  b  with integer coefficients
237     derived from the quotients. The coefficients can be computed
238     as far as the quotients can be determined from the chosen
239     most significant parts of  a  and  b. Only then a new pair of
240     consecutive remainders is computed and the algorithm starts
241     anew with this pair.
242 
243     References
244     ==========
245 
246     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
247 
248     """
249     a, b = abs(as_int(a)), abs(as_int(b))
250     if a < b:
251         a, b = b, a
252 
253     # The algorithm works by using one or two digit division
254     # whenever possible. The outer loop will replace the
255     # pair (a, b) with a pair of shorter consecutive elements
256     # of the Euclidean gcd sequence until a and b
257     # fit into two Python (long) int digits.
258     nbits = 2*int_info.bits_per_digit
259 
260     while a.bit_length() > nbits and b != 0:
261         # Quotients are mostly small integers that can
262         # be determined from most significant bits.
263         n = a.bit_length() - nbits
264         x, y = int(a >> n), int(b >> n)  # most significant bits
265 
266         # Elements of the Euclidean gcd sequence are linear
267         # combinations of a and b with integer coefficients.
268         # Compute the coefficients of consecutive pairs
269         #     a' = A*a + B*b, b' = C*a + D*b
270         # using small integer arithmetic as far as possible.
271         A, B, C, D = 1, 0, 0, 1  # initial values
272 
273         while True:
274             # The coefficients alternate in sign while looping.
275             # The inner loop combines two steps to keep track
276             # of the signs.
277 
278             # At this point we have
279             #   A > 0, B <= 0, C <= 0, D > 0,
280             #   x' = x + B <= x < x" = x + A,
281             #   y' = y + C <= y < y" = y + D,
282             # and
283             #   x'*N <= a' < x"*N, y'*N <= b' < y"*N,
284             # where N = 2**n.
285 
286             # Now, if y' > 0, and x"//y' and x'//y" agree,
287             # then their common value is equal to  q = a'//b'.
288             # In addition,
289             #   x'%y" = x' - q*y" < x" - q*y' = x"%y',
290             # and
291             #   (x'%y")*N < a'%b' < (x"%y')*N.
292 
293             # On the other hand, we also have  x//y == q,
294             # and therefore
295             #   x'%y" = x + B - q*(y + D) = x%y + B',
296             #   x"%y' = x + A - q*(y + C) = x%y + A',
297             # where
298             #    B' = B - q*D < 0, A' = A - q*C > 0.
299 
300             if y + C <= 0:
301                 break
302             q = (x + A) // (y + C)
303 
304             # Now  x'//y" <= q, and equality holds if
305             #   x' - q*y" = (x - q*y) + (B - q*D) >= 0.
306             # This is a minor optimization to avoid division.
307             x_qy, B_qD = x - q*y, B - q*D
308             if x_qy + B_qD < 0:
309                 break
310 
311             # Next step in the Euclidean sequence.
312             x, y = y, x_qy
313             A, B, C, D = C, D, A - q*C, B_qD
314 
315             # At this point the signs of the coefficients
316             # change and their roles are interchanged.
317             #   A <= 0, B > 0, C > 0, D < 0,
318             #   x' = x + A <= x < x" = x + B,
319             #   y' = y + D < y < y" = y + C.
320 
321             if y + D <= 0:
322                 break
323             q = (x + B) // (y + D)
324             x_qy, A_qC = x - q*y, A - q*C
325             if x_qy + A_qC < 0:
326                 break
327 
328             x, y = y, x_qy
329             A, B, C, D = C, D, A_qC, B - q*D
330             # Now the conditions on top of the loop
331             # are again satisfied.
332             #   A > 0, B < 0, C < 0, D > 0.
333 
334         if B == 0:
335             # This can only happen when y == 0 in the beginning
336             # and the inner loop does nothing.
337             # Long division is forced.
338             a, b = b, a % b
339             continue
340 
341         # Compute new long arguments using the coefficients.
342         a, b = A*a + B*b, C*a + D*b
343 
344     # Small divisors. Finish with the standard algorithm.
345     while b:
346         a, b = b, a % b
347 
348     return a
349 
350 
351 def ilcm(*args):
352     """Computes integer least common multiple.
353 
354     Examples
355     ========
356 
357     >>> from sympy.core.numbers import ilcm
358     >>> ilcm(5, 10)
359     10
360     >>> ilcm(7, 3)
361     21
362     >>> ilcm(5, 10, 15)
363     30
364 
365     """
366     if len(args) < 2:
367         raise TypeError(
368             'ilcm() takes at least 2 arguments (%s given)' % len(args))
369     if 0 in args:
370         return 0
371     a = args[0]
372     for b in args[1:]:
373         a = a // igcd(a, b) * b # since gcd(a,b) | a
374     return a
375 
376 
377 def igcdex(a, b):
378     """Returns x, y, g such that g = x*a + y*b = gcd(a, b).
379 
380        >>> from sympy.core.numbers import igcdex
381        >>> igcdex(2, 3)
382        (-1, 1, 1)
383        >>> igcdex(10, 12)
384        (-1, 1, 2)
385 
386        >>> x, y, g = igcdex(100, 2004)
387        >>> x, y, g
388        (-20, 1, 4)
389        >>> x*100 + y*2004
390        4
391 
392     """
393     if (not a) and (not b):
394         return (0, 1, 0)
395 
396     if not a:
397         return (0, b//abs(b), abs(b))
398     if not b:
399         return (a//abs(a), 0, abs(a))
400 
401     if a < 0:
402         a, x_sign = -a, -1
403     else:
404         x_sign = 1
405 
406     if b < 0:
407         b, y_sign = -b, -1
408     else:
409         y_sign = 1
410 
411     x, y, r, s = 1, 0, 0, 1
412 
413     while b:
414         (c, q) = (a % b, a // b)
415         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)
416 
417     return (x*x_sign, y*y_sign, a)
418 
419 
420 def mod_inverse(a, m):
421     """
422     Return the number c such that, (a * c) = 1 (mod m)
423     where c has the same sign as m. If no such value exists,
424     a ValueError is raised.
425 
426     Examples
427     ========
428 
429     >>> from sympy import S
430     >>> from sympy.core.numbers import mod_inverse
431 
432     Suppose we wish to find multiplicative inverse x of
433     3 modulo 11. This is the same as finding x such
434     that 3 * x = 1 (mod 11). One value of x that satisfies
435     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).
436     This is the value return by mod_inverse:
437 
438     >>> mod_inverse(3, 11)
439     4
440     >>> mod_inverse(-3, 11)
441     7
442 
443     When there is a common factor between the numerators of
444     ``a`` and ``m`` the inverse does not exist:
445 
446     >>> mod_inverse(2, 4)
447     Traceback (most recent call last):
448     ...
449     ValueError: inverse of 2 mod 4 does not exist
450 
451     >>> mod_inverse(S(2)/7, S(5)/2)
452     7/2
453 
454     References
455     ==========
456     - https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
457     - https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
458     """
459     c = None
460     try:
461         a, m = as_int(a), as_int(m)
462         if m != 1 and m != -1:
463             x, y, g = igcdex(a, m)
464             if g == 1:
465                 c = x % m
466     except ValueError:
467         a, m = sympify(a), sympify(m)
468         if not (a.is_number and m.is_number):
469             raise TypeError(filldedent('''
470                 Expected numbers for arguments; symbolic `mod_inverse`
471                 is not implemented
472                 but symbolic expressions can be handled with the
473                 similar function,
474                 sympy.polys.polytools.invert'''))
475         big = (m > 1)
476         if not (big is S.true or big is S.false):
477             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)
478         elif big:
479             c = 1/a
480     if c is None:
481         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))
482     return c
483 
484 
485 class Number(AtomicExpr):
486     """Represents atomic numbers in SymPy.
487 
488     Floating point numbers are represented by the Float class.
489     Rational numbers (of any size) are represented by the Rational class.
490     Integer numbers (of any size) are represented by the Integer class.
491     Float and Rational are subclasses of Number; Integer is a subclass
492     of Rational.
493 
494     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is
495     a different object from the floating point number obtained with
496     Python division ``2/3``. Even for numbers that are exactly
497     represented in binary, there is a difference between how two forms,
498     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.
499     The rational form is to be preferred in symbolic computations.
500 
501     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or
502     complex numbers ``3 + 4*I``, are not instances of Number class as
503     they are not atomic.
504 
505     See Also
506     ========
507 
508     Float, Integer, Rational
509     """
510     is_commutative = True
511     is_number = True
512     is_Number = True
513 
514     __slots__ = []
515 
516     # Used to make max(x._prec, y._prec) return x._prec when only x is a float
517     _prec = -1
518 
519     def __new__(cls, *obj):
520         if len(obj) == 1:
521             obj = obj[0]
522 
523         if isinstance(obj, Number):
524             return obj
525         if isinstance(obj, SYMPY_INTS):
526             return Integer(obj)
527         if isinstance(obj, tuple) and len(obj) == 2:
528             return Rational(*obj)
529         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):
530             return Float(obj)
531         if isinstance(obj, string_types):
532             val = sympify(obj)
533             if isinstance(val, Number):
534                 return val
535             else:
536                 raise ValueError('String "%s" does not denote a Number' % obj)
537         msg = "expected str|int|long|float|Decimal|Number object but got %r"
538         raise TypeError(msg % type(obj).__name__)
539 
540     def invert(self, other, *gens, **args):
541         from sympy.polys.polytools import invert
542         if getattr(other, 'is_number', True):
543             return mod_inverse(self, other)
544         return invert(self, other, *gens, **args)
545 
546     def __divmod__(self, other):
547         from .containers import Tuple
548 
549         try:
550             other = Number(other)
551         except TypeError:
552             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
553             raise TypeError(msg % (type(self).__name__, type(other).__name__))
554         if not other:
555             raise ZeroDivisionError('modulo by zero')
556         if self.is_Integer and other.is_Integer:
557             return Tuple(*divmod(self.p, other.p))
558         else:
559             rat = self/other
560         w = int(rat) if rat > 0 else int(rat) - 1
561         r = self - other*w
562         return Tuple(w, r)
563 
564     def __rdivmod__(self, other):
565         try:
566             other = Number(other)
567         except TypeError:
568             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
569             raise TypeError(msg % (type(other).__name__, type(self).__name__))
570         return divmod(other, self)
571 
572     def _as_mpf_val(self, prec):
573         """Evaluation of mpf tuple accurate to at least prec bits."""
574         raise NotImplementedError('%s needs ._as_mpf_val() method' %
575             (self.__class__.__name__))
576 
577     def _eval_evalf(self, prec):
578         return Float._new(self._as_mpf_val(prec), prec)
579 
580     def _as_mpf_op(self, prec):
581         prec = max(prec, self._prec)
582         return self._as_mpf_val(prec), prec
583 
584     def __float__(self):
585         return mlib.to_float(self._as_mpf_val(53))
586 
587     def floor(self):
588         raise NotImplementedError('%s needs .floor() method' %
589             (self.__class__.__name__))
590 
591     def ceiling(self):
592         raise NotImplementedError('%s needs .ceiling() method' %
593             (self.__class__.__name__))
594 
595     def __floor__(self):
596         return self.floor()
597 
598     def __ceil__(self):
599         return self.ceiling()
600 
601     def _eval_conjugate(self):
602         return self
603 
604     def _eval_order(self, *symbols):
605         from sympy import Order
606         # Order(5, x, y) -> Order(1,x,y)
607         return Order(S.One, *symbols)
608 
609     def _eval_subs(self, old, new):
610         if old == -self:
611             return -new
612         return self  # there is no other possibility
613 
614     def _eval_is_finite(self):
615         return True
616 
617     @classmethod
618     def class_key(cls):
619         return 1, 0, 'Number'
620 
621     @cacheit
622     def sort_key(self, order=None):
623         return self.class_key(), (0, ()), (), self
624 
625     @_sympifyit('other', NotImplemented)
626     def __add__(self, other):
627         if isinstance(other, Number) and global_evaluate[0]:
628             if other is S.NaN:
629                 return S.NaN
630             elif other is S.Infinity:
631                 return S.Infinity
632             elif other is S.NegativeInfinity:
633                 return S.NegativeInfinity
634         return AtomicExpr.__add__(self, other)
635 
636     @_sympifyit('other', NotImplemented)
637     def __sub__(self, other):
638         if isinstance(other, Number) and global_evaluate[0]:
639             if other is S.NaN:
640                 return S.NaN
641             elif other is S.Infinity:
642                 return S.NegativeInfinity
643             elif other is S.NegativeInfinity:
644                 return S.Infinity
645         return AtomicExpr.__sub__(self, other)
646 
647     @_sympifyit('other', NotImplemented)
648     def __mul__(self, other):
649         if isinstance(other, Number) and global_evaluate[0]:
650             if other is S.NaN:
651                 return S.NaN
652             elif other is S.Infinity:
653                 if self.is_zero:
654                     return S.NaN
655                 elif self.is_positive:
656                     return S.Infinity
657                 else:
658                     return S.NegativeInfinity
659             elif other is S.NegativeInfinity:
660                 if self.is_zero:
661                     return S.NaN
662                 elif self.is_positive:
663                     return S.NegativeInfinity
664                 else:
665                     return S.Infinity
666         elif isinstance(other, Tuple):
667             return NotImplemented
668         return AtomicExpr.__mul__(self, other)
669 
670     @_sympifyit('other', NotImplemented)
671     def __div__(self, other):
672         if isinstance(other, Number) and global_evaluate[0]:
673             if other is S.NaN:
674                 return S.NaN
675             elif other is S.Infinity or other is S.NegativeInfinity:
676                 return S.Zero
677         return AtomicExpr.__div__(self, other)
678 
679     __truediv__ = __div__
680 
681     def __eq__(self, other):
682         raise NotImplementedError('%s needs .__eq__() method' %
683             (self.__class__.__name__))
684 
685     def __ne__(self, other):
686         raise NotImplementedError('%s needs .__ne__() method' %
687             (self.__class__.__name__))
688 
689     def __lt__(self, other):
690         try:
691             other = _sympify(other)
692         except SympifyError:
693             raise TypeError("Invalid comparison %s < %s" % (self, other))
694         raise NotImplementedError('%s needs .__lt__() method' %
695             (self.__class__.__name__))
696 
697     def __le__(self, other):
698         try:
699             other = _sympify(other)
700         except SympifyError:
701             raise TypeError("Invalid comparison %s <= %s" % (self, other))
702         raise NotImplementedError('%s needs .__le__() method' %
703             (self.__class__.__name__))
704 
705     def __gt__(self, other):
706         try:
707             other = _sympify(other)
708         except SympifyError:
709             raise TypeError("Invalid comparison %s > %s" % (self, other))
710         return _sympify(other).__lt__(self)
711 
712     def __ge__(self, other):
713         try:
714             other = _sympify(other)
715         except SympifyError:
716             raise TypeError("Invalid comparison %s >= %s" % (self, other))
717         return _sympify(other).__le__(self)
718 
719     def __hash__(self):
720         return super(Number, self).__hash__()
721 
722     def is_constant(self, *wrt, **flags):
723         return True
724 
725     def as_coeff_mul(self, *deps, **kwargs):
726         # a -> c*t
727         if self.is_Rational or not kwargs.pop('rational', True):
728             return self, tuple()
729         elif self.is_negative:
730             return S.NegativeOne, (-self,)
731         return S.One, (self,)
732 
733     def as_coeff_add(self, *deps):
734         # a -> c + t
735         if self.is_Rational:
736             return self, tuple()
737         return S.Zero, (self,)
738 
739     def as_coeff_Mul(self, rational=False):
740         """Efficiently extract the coefficient of a product. """
741         if rational and not self.is_Rational:
742             return S.One, self
743         return (self, S.One) if self else (S.One, self)
744 
745     def as_coeff_Add(self, rational=False):
746         """Efficiently extract the coefficient of a summation. """
747         if not rational:
748             return self, S.Zero
749         return S.Zero, self
750 
751     def gcd(self, other):
752         """Compute GCD of `self` and `other`. """
753         from sympy.polys import gcd
754         return gcd(self, other)
755 
756     def lcm(self, other):
757         """Compute LCM of `self` and `other`. """
758         from sympy.polys import lcm
759         return lcm(self, other)
760 
761     def cofactors(self, other):
762         """Compute GCD and cofactors of `self` and `other`. """
763         from sympy.polys import cofactors
764         return cofactors(self, other)
765 
766 
767 class Float(Number):
768     """Represent a floating-point number of arbitrary precision.
769 
770     Examples
771     ========
772 
773     >>> from sympy import Float
774     >>> Float(3.5)
775     3.50000000000000
776     >>> Float(3)
777     3.00000000000000
778 
779     Creating Floats from strings (and Python ``int`` and ``long``
780     types) will give a minimum precision of 15 digits, but the
781     precision will automatically increase to capture all digits
782     entered.
783 
784     >>> Float(1)
785     1.00000000000000
786     >>> Float(10**20)
787     100000000000000000000.
788     >>> Float('1e20')
789     100000000000000000000.
790 
791     However, *floating-point* numbers (Python ``float`` types) retain
792     only 15 digits of precision:
793 
794     >>> Float(1e20)
795     1.00000000000000e+20
796     >>> Float(1.23456789123456789)
797     1.23456789123457
798 
799     It may be preferable to enter high-precision decimal numbers
800     as strings:
801 
802     Float('1.23456789123456789')
803     1.23456789123456789
804 
805     The desired number of digits can also be specified:
806 
807     >>> Float('1e-3', 3)
808     0.00100
809     >>> Float(100, 4)
810     100.0
811 
812     Float can automatically count significant figures if a null string
813     is sent for the precision; spaces or underscores are also allowed. (Auto-
814     counting is only allowed for strings, ints and longs).
815 
816     >>> Float('123 456 789.123_456', '')
817     123456789.123456
818     >>> Float('12e-3', '')
819     0.012
820     >>> Float(3, '')
821     3.
822 
823     If a number is written in scientific notation, only the digits before the
824     exponent are considered significant if a decimal appears, otherwise the
825     "e" signifies only how to move the decimal:
826 
827     >>> Float('60.e2', '')  # 2 digits significant
828     6.0e+3
829     >>> Float('60e2', '')  # 4 digits significant
830     6000.
831     >>> Float('600e-2', '')  # 3 digits significant
832     6.00
833 
834     Notes
835     =====
836 
837     Floats are inexact by their nature unless their value is a binary-exact
838     value.
839 
840     >>> approx, exact = Float(.1, 1), Float(.125, 1)
841 
842     For calculation purposes, evalf needs to be able to change the precision
843     but this will not increase the accuracy of the inexact value. The
844     following is the most accurate 5-digit approximation of a value of 0.1
845     that had only 1 digit of precision:
846 
847     >>> approx.evalf(5)
848     0.099609
849 
850     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
851     can be passed to Float or evalf to obtain an arbitrary precision with
852     matching accuracy:
853 
854     >>> Float(exact, 5)
855     0.12500
856     >>> exact.evalf(20)
857     0.12500000000000000000
858 
859     Trying to make a high-precision Float from a float is not disallowed,
860     but one must keep in mind that the *underlying float* (not the apparent
861     decimal value) is being obtained with high precision. For example, 0.3
862     does not have a finite binary representation. The closest rational is
863     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
864     0.3 to 20 digits of precision you will not see the same thing as 0.3
865     followed by 19 zeros:
866 
867     >>> Float(0.3, 20)
868     0.29999999999999998890
869 
870     If you want a 20-digit value of the decimal 0.3 (not the floating point
871     approximation of 0.3) you should send the 0.3 as a string. The underlying
872     representation is still binary but a higher precision than Python's float
873     is used:
874 
875     >>> Float('0.3', 20)
876     0.30000000000000000000
877 
878     Although you can increase the precision of an existing Float using Float
879     it will not increase the accuracy -- the underlying value is not changed:
880 
881     >>> def show(f): # binary rep of Float
882     ...     from sympy import Mul, Pow
883     ...     s, m, e, b = f._mpf_
884     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
885     ...     print('%s at prec=%s' % (v, f._prec))
886     ...
887     >>> t = Float('0.3', 3)
888     >>> show(t)
889     4915/2**14 at prec=13
890     >>> show(Float(t, 20)) # higher prec, not higher accuracy
891     4915/2**14 at prec=70
892     >>> show(Float(t, 2)) # lower prec
893     307/2**10 at prec=10
894 
895     The same thing happens when evalf is used on a Float:
896 
897     >>> show(t.evalf(20))
898     4915/2**14 at prec=70
899     >>> show(t.evalf(2))
900     307/2**10 at prec=10
901 
902     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
903     produce the number (-1)**n*c*2**p:
904 
905     >>> n, c, p = 1, 5, 0
906     >>> (-1)**n*c*2**p
907     -5
908     >>> Float((1, 5, 0))
909     -5.00000000000000
910 
911     An actual mpf tuple also contains the number of bits in c as the last
912     element of the tuple:
913 
914     >>> _._mpf_
915     (1, 5, 0, 3)
916 
917     This is not needed for instantiation and is not the same thing as the
918     precision. The mpf tuple and the precision are two separate quantities
919     that Float tracks.
920 
921     """
922     __slots__ = ['_mpf_', '_prec']
923 
924     # A Float represents many real numbers,
925     # both rational and irrational.
926     is_rational = None
927     is_irrational = None
928     is_number = True
929 
930     is_real = True
931 
932     is_Float = True
933 
934     def __new__(cls, num, dps=None, prec=None, precision=None):
935         if prec is not None:
936             SymPyDeprecationWarning(
937                             feature="Using 'prec=XX' to denote decimal precision",
938                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
939                                               "for binary precision",
940                             issue=12820,
941                             deprecated_since_version="1.1").warn()
942             dps = prec
943         del prec  # avoid using this deprecated kwarg
944 
945         if dps is not None and precision is not None:
946             raise ValueError('Both decimal and binary precision supplied. '
947                              'Supply only one. ')
948 
949         if isinstance(num, string_types):
950             # Float already accepts spaces as digit separators; in Py 3.6
951             # underscores are allowed. In anticipation of that, we ignore
952             # legally placed underscores
953             num = num.replace(' ', '')
954             if '_' in num:
955                 if num.startswith('_') or num.endswith('_') or any(
956                         i in num for i in ('__', '_.', '._')):
957                     # copy Py 3.6 error
958                     raise ValueError("could not convert string to float: '%s'" % num)
959                 num = num.replace('_', '')
960             if num.startswith('.') and len(num) > 1:
961                 num = '0' + num
962             elif num.startswith('-.') and len(num) > 2:
963                 num = '-0.' + num[2:]
964             elif num == 'inf' or num == '+inf':
965                 return S.Infinity
966             elif num == '-inf':
967                 return S.NegativeInfinity
968         elif isinstance(num, float) and num == 0:
969             num = '0'
970         elif isinstance(num, float) and num == float('inf'):
971             return S.Infinity
972         elif isinstance(num, float) and num == float('-inf'):
973             return S.NegativeInfinity
974         elif isinstance(num, (SYMPY_INTS, Integer)):
975             num = str(num)  # faster than mlib.from_int
976         elif num is S.Infinity:
977             return num
978         elif num is S.NegativeInfinity:
979             return num
980         elif type(num).__module__ == 'numpy': # support for numpy datatypes
981             num = _convert_numpy_types(num)
982         elif isinstance(num, mpmath.mpf):
983             if precision is None:
984                 if dps is None:
985                     precision = num.context.prec
986             num = num._mpf_
987 
988         if dps is None and precision is None:
989             dps = 15
990             if isinstance(num, Float):
991                 return num
992             if isinstance(num, string_types) and _literal_float(num):
993                 try:
994                     Num = decimal.Decimal(num)
995                 except decimal.InvalidOperation:
996                     pass
997                 else:
998                     isint = '.' not in num
999                     num, dps = _decimal_to_Rational_prec(Num)
1000                     if num.is_Integer and isint:
1001                         dps = max(dps, len(str(num).lstrip('-')))
1002                     dps = max(15, dps)
1003                     precision = mlib.libmpf.dps_to_prec(dps)
1004         elif precision == '' and dps is None or precision is None and dps == '':
1005             if not isinstance(num, string_types):
1006                 raise ValueError('The null string can only be used when '
1007                 'the number to Float is passed as a string or an integer.')
1008             ok = None
1009             if _literal_float(num):
1010                 try:
1011                     Num = decimal.Decimal(num)
1012                 except decimal.InvalidOperation:
1013                     pass
1014                 else:
1015                     isint = '.' not in num
1016                     num, dps = _decimal_to_Rational_prec(Num)
1017                     if num.is_Integer and isint:
1018                         dps = max(dps, len(str(num).lstrip('-')))
1019                         precision = mlib.libmpf.dps_to_prec(dps)
1020                     ok = True
1021             if ok is None:
1022                 raise ValueError('string-float not recognized: %s' % num)
1023 
1024         # decimal precision(dps) is set and maybe binary precision(precision)
1025         # as well.From here on binary precision is used to compute the Float.
1026         # Hence, if supplied use binary precision else translate from decimal
1027         # precision.
1028 
1029         if precision is None or precision == '':
1030             precision = mlib.libmpf.dps_to_prec(dps)
1031 
1032         precision = int(precision)
1033 
1034         if isinstance(num, float):
1035             _mpf_ = mlib.from_float(num, precision, rnd)
1036         elif isinstance(num, string_types):
1037             _mpf_ = mlib.from_str(num, precision, rnd)
1038         elif isinstance(num, decimal.Decimal):
1039             if num.is_finite():
1040                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1041             elif num.is_nan():
1042                 return S.NaN
1043             elif num.is_infinite():
1044                 if num > 0:
1045                     return S.Infinity
1046                 else:
1047                     return S.NegativeInfinity
1048             else:
1049                 raise ValueError("unexpected decimal value %s" % str(num))
1050         elif isinstance(num, tuple) and len(num) in (3, 4):
1051             if type(num[1]) is str:
1052                 # it's a hexadecimal (coming from a pickled object)
1053                 # assume that it is in standard form
1054                 num = list(num)
1055                 # If we're loading an object pickled in Python 2 into
1056                 # Python 3, we may need to strip a tailing 'L' because
1057                 # of a shim for int on Python 3, see issue #13470.
1058                 if num[1].endswith('L'):
1059                     num[1] = num[1][:-1]
1060                 num[1] = MPZ(num[1], 16)
1061                 _mpf_ = tuple(num)
1062             else:
1063                 if len(num) == 4:
1064                     # handle normalization hack
1065                     return Float._new(num, precision)
1066                 else:
1067                     return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)
1068         else:
1069             try:
1070                 _mpf_ = num._as_mpf_val(precision)
1071             except (NotImplementedError, AttributeError):
1072                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1073 
1074         # special cases
1075         if _mpf_ == _mpf_zero:
1076             pass  # we want a Float
1077         elif _mpf_ == _mpf_nan:
1078             return S.NaN
1079         elif _mpf_ == _mpf_inf:
1080             return S.Infinity
1081         elif _mpf_ == _mpf_ninf:
1082             return S.NegativeInfinity
1083 
1084         obj = Expr.__new__(cls)
1085         obj._mpf_ = _mpf_
1086         obj._prec = precision
1087         return obj
1088 
1089     @classmethod
1090     def _new(cls, _mpf_, _prec):
1091         # special cases
1092         if _mpf_ == _mpf_zero:
1093             return S.Zero  # XXX this is different from Float which gives 0.0
1094         elif _mpf_ == _mpf_nan:
1095             return S.NaN
1096         elif _mpf_ == _mpf_inf:
1097             return S.Infinity
1098         elif _mpf_ == _mpf_ninf:
1099             return S.NegativeInfinity
1100 
1101         obj = Expr.__new__(cls)
1102         obj._mpf_ = mpf_norm(_mpf_, _prec)
1103         # XXX: Should this be obj._prec = obj._mpf_[3]?
1104         obj._prec = _prec
1105         return obj
1106 
1107     # mpz can't be pickled
1108     def __getnewargs__(self):
1109         return (mlib.to_pickable(self._mpf_),)
1110 
1111     def __getstate__(self):
1112         return {'_prec': self._prec}
1113 
1114     def _hashable_content(self):
1115         return (self._mpf_, self._prec)
1116 
1117     def floor(self):
1118         return Integer(int(mlib.to_int(
1119             mlib.mpf_floor(self._mpf_, self._prec))))
1120 
1121     def ceiling(self):
1122         return Integer(int(mlib.to_int(
1123             mlib.mpf_ceil(self._mpf_, self._prec))))
1124 
1125     def __floor__(self):
1126         return self.floor()
1127 
1128     def __ceil__(self):
1129         return self.ceiling()
1130 
1131 
1132     @property
1133     def num(self):
1134         return mpmath.mpf(self._mpf_)
1135 
1136     def _as_mpf_val(self, prec):
1137         rv = mpf_norm(self._mpf_, prec)
1138         if rv != self._mpf_ and self._prec == prec:
1139             debug(self._mpf_, rv)
1140         return rv
1141 
1142     def _as_mpf_op(self, prec):
1143         return self._mpf_, max(prec, self._prec)
1144 
1145     def _eval_is_finite(self):
1146         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1147             return False
1148         return True
1149 
1150     def _eval_is_infinite(self):
1151         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1152             return True
1153         return False
1154 
1155     def _eval_is_integer(self):
1156         return self._mpf_ == _mpf_zero
1157 
1158     def _eval_is_negative(self):
1159         if self._mpf_ == _mpf_ninf:
1160             return True
1161         if self._mpf_ == _mpf_inf:
1162             return False
1163         return self.num < 0
1164 
1165     def _eval_is_positive(self):
1166         if self._mpf_ == _mpf_inf:
1167             return True
1168         if self._mpf_ == _mpf_ninf:
1169             return False
1170         return self.num > 0
1171 
1172     def _eval_is_zero(self):
1173         return self._mpf_ == _mpf_zero
1174 
1175     def __nonzero__(self):
1176         return self._mpf_ != _mpf_zero
1177 
1178     __bool__ = __nonzero__
1179 
1180     def __neg__(self):
1181         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1182 
1183     @_sympifyit('other', NotImplemented)
1184     def __add__(self, other):
1185         if isinstance(other, Number) and global_evaluate[0]:
1186             rhs, prec = other._as_mpf_op(self._prec)
1187             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1188         return Number.__add__(self, other)
1189 
1190     @_sympifyit('other', NotImplemented)
1191     def __sub__(self, other):
1192         if isinstance(other, Number) and global_evaluate[0]:
1193             rhs, prec = other._as_mpf_op(self._prec)
1194             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1195         return Number.__sub__(self, other)
1196 
1197     @_sympifyit('other', NotImplemented)
1198     def __mul__(self, other):
1199         if isinstance(other, Number) and global_evaluate[0]:
1200             rhs, prec = other._as_mpf_op(self._prec)
1201             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1202         return Number.__mul__(self, other)
1203 
1204     @_sympifyit('other', NotImplemented)
1205     def __div__(self, other):
1206         if isinstance(other, Number) and other != 0 and global_evaluate[0]:
1207             rhs, prec = other._as_mpf_op(self._prec)
1208             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1209         return Number.__div__(self, other)
1210 
1211     __truediv__ = __div__
1212 
1213     @_sympifyit('other', NotImplemented)
1214     def __mod__(self, other):
1215         if isinstance(other, Rational) and other.q != 1 and global_evaluate[0]:
1216             # calculate mod with Rationals, *then* round the result
1217             return Float(Rational.__mod__(Rational(self), other),
1218                          precision=self._prec)
1219         if isinstance(other, Float) and global_evaluate[0]:
1220             r = self/other
1221             if r == int(r):
1222                 return Float(0, precision=max(self._prec, other._prec))
1223         if isinstance(other, Number) and global_evaluate[0]:
1224             rhs, prec = other._as_mpf_op(self._prec)
1225             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1226         return Number.__mod__(self, other)
1227 
1228     @_sympifyit('other', NotImplemented)
1229     def __rmod__(self, other):
1230         if isinstance(other, Float) and global_evaluate[0]:
1231             return other.__mod__(self)
1232         if isinstance(other, Number) and global_evaluate[0]:
1233             rhs, prec = other._as_mpf_op(self._prec)
1234             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1235         return Number.__rmod__(self, other)
1236 
1237     def _eval_power(self, expt):
1238         """
1239         expt is symbolic object but not equal to 0, 1
1240 
1241         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1242                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1243         """
1244         if self == 0:
1245             if expt.is_positive:
1246                 return S.Zero
1247             if expt.is_negative:
1248                 return S.Infinity
1249         if isinstance(expt, Number):
1250             if isinstance(expt, Integer):
1251                 prec = self._prec
1252                 return Float._new(
1253                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1254             elif isinstance(expt, Rational) and \
1255                     expt.p == 1 and expt.q % 2 and self.is_negative:
1256                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1257                     -self)._eval_power(expt)
1258             expt, prec = expt._as_mpf_op(self._prec)
1259             mpfself = self._mpf_
1260             try:
1261                 y = mpf_pow(mpfself, expt, prec, rnd)
1262                 return Float._new(y, prec)
1263             except mlib.ComplexResult:
1264                 re, im = mlib.mpc_pow(
1265                     (mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)
1266                 return Float._new(re, prec) + \
1267                     Float._new(im, prec)*S.ImaginaryUnit
1268 
1269     def __abs__(self):
1270         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1271 
1272     def __int__(self):
1273         if self._mpf_ == _mpf_zero:
1274             return 0
1275         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1276 
1277     __long__ = __int__
1278 
1279     def __eq__(self, other):
1280         if isinstance(other, float):
1281             # coerce to Float at same precision
1282             o = Float(other)
1283             try:
1284                 ompf = o._as_mpf_val(self._prec)
1285             except ValueError:
1286                 return False
1287             return bool(mlib.mpf_eq(self._mpf_, ompf))
1288         try:
1289             other = _sympify(other)
1290         except SympifyError:
1291             return NotImplemented
1292         if other.is_NumberSymbol:
1293             if other.is_irrational:
1294                 return False
1295             return other.__eq__(self)
1296         if other.is_Float:
1297             return bool(mlib.mpf_eq(self._mpf_, other._mpf_))
1298         if other.is_Number:
1299             # numbers should compare at the same precision;
1300             # all _as_mpf_val routines should be sure to abide
1301             # by the request to change the prec if necessary; if
1302             # they don't, the equality test will fail since it compares
1303             # the mpf tuples
1304             ompf = other._as_mpf_val(self._prec)
1305             return bool(mlib.mpf_eq(self._mpf_, ompf))
1306         return False    # Float != non-Number
1307 
1308     def __ne__(self, other):
1309         return not self == other
1310 
1311     def __gt__(self, other):
1312         try:
1313             other = _sympify(other)
1314         except SympifyError:
1315             raise TypeError("Invalid comparison %s > %s" % (self, other))
1316         if other.is_NumberSymbol:
1317             return other.__lt__(self)
1318         if other.is_Rational and not other.is_Integer:
1319             self *= other.q
1320             other = _sympify(other.p)
1321         elif other.is_comparable:
1322             other = other.evalf()
1323         if other.is_Number and other is not S.NaN:
1324             return _sympify(bool(
1325                 mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))
1326         return Expr.__gt__(self, other)
1327 
1328     def __ge__(self, other):
1329         try:
1330             other = _sympify(other)
1331         except SympifyError:
1332             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1333         if other.is_NumberSymbol:
1334             return other.__le__(self)
1335         if other.is_Rational and not other.is_Integer:
1336             self *= other.q
1337             other = _sympify(other.p)
1338         elif other.is_comparable:
1339             other = other.evalf()
1340         if other.is_Number and other is not S.NaN:
1341             return _sympify(bool(
1342                 mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))
1343         return Expr.__ge__(self, other)
1344 
1345     def __lt__(self, other):
1346         try:
1347             other = _sympify(other)
1348         except SympifyError:
1349             raise TypeError("Invalid comparison %s < %s" % (self, other))
1350         if other.is_NumberSymbol:
1351             return other.__gt__(self)
1352         if other.is_Rational and not other.is_Integer:
1353             self *= other.q
1354             other = _sympify(other.p)
1355         elif other.is_comparable:
1356             other = other.evalf()
1357         if other.is_Number and other is not S.NaN:
1358             return _sympify(bool(
1359                 mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))
1360         return Expr.__lt__(self, other)
1361 
1362     def __le__(self, other):
1363         try:
1364             other = _sympify(other)
1365         except SympifyError:
1366             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1367         if other.is_NumberSymbol:
1368             return other.__ge__(self)
1369         if other.is_Rational and not other.is_Integer:
1370             self *= other.q
1371             other = _sympify(other.p)
1372         elif other.is_comparable:
1373             other = other.evalf()
1374         if other.is_Number and other is not S.NaN:
1375             return _sympify(bool(
1376                 mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))
1377         return Expr.__le__(self, other)
1378 
1379     def __hash__(self):
1380         return super(Float, self).__hash__()
1381 
1382     def epsilon_eq(self, other, epsilon="1e-15"):
1383         return abs(self - other) < Float(epsilon)
1384 
1385     def _sage_(self):
1386         import sage.all as sage
1387         return sage.RealNumber(str(self))
1388 
1389     def __format__(self, format_spec):
1390         return format(decimal.Decimal(str(self)), format_spec)
1391 
1392 
1393 # Add sympify converters
1394 converter[float] = converter[decimal.Decimal] = Float
1395 
1396 # this is here to work nicely in Sage
1397 RealNumber = Float
1398 
1399 
1400 class Rational(Number):
1401     """Represents rational numbers (p/q) of any size.
1402 
1403     Examples
1404     ========
1405 
1406     >>> from sympy import Rational, nsimplify, S, pi
1407     >>> Rational(1, 2)
1408     1/2
1409 
1410     Rational is unprejudiced in accepting input. If a float is passed, the
1411     underlying value of the binary representation will be returned:
1412 
1413     >>> Rational(.5)
1414     1/2
1415     >>> Rational(.2)
1416     3602879701896397/18014398509481984
1417 
1418     If the simpler representation of the float is desired then consider
1419     limiting the denominator to the desired value or convert the float to
1420     a string (which is roughly equivalent to limiting the denominator to
1421     10**12):
1422 
1423     >>> Rational(str(.2))
1424     1/5
1425     >>> Rational(.2).limit_denominator(10**12)
1426     1/5
1427 
1428     An arbitrarily precise Rational is obtained when a string literal is
1429     passed:
1430 
1431     >>> Rational("1.23")
1432     123/100
1433     >>> Rational('1e-2')
1434     1/100
1435     >>> Rational(".1")
1436     1/10
1437     >>> Rational('1e-2/3.2')
1438     1/320
1439 
1440     The conversion of other types of strings can be handled by
1441     the sympify() function, and conversion of floats to expressions
1442     or simple fractions can be handled with nsimplify:
1443 
1444     >>> S('.[3]')  # repeating digits in brackets
1445     1/3
1446     >>> S('3**2/10')  # general expressions
1447     9/10
1448     >>> nsimplify(.3)  # numbers that have a simple form
1449     3/10
1450 
1451     But if the input does not reduce to a literal Rational, an error will
1452     be raised:
1453 
1454     >>> Rational(pi)
1455     Traceback (most recent call last):
1456     ...
1457     TypeError: invalid input: pi
1458 
1459 
1460     Low-level
1461     ---------
1462 
1463     Access numerator and denominator as .p and .q:
1464 
1465     >>> r = Rational(3, 4)
1466     >>> r
1467     3/4
1468     >>> r.p
1469     3
1470     >>> r.q
1471     4
1472 
1473     Note that p and q return integers (not SymPy Integers) so some care
1474     is needed when using them in expressions:
1475 
1476     >>> r.p/r.q
1477     0.75
1478 
1479     See Also
1480     ========
1481     sympify, sympy.simplify.simplify.nsimplify
1482     """
1483     is_real = True
1484     is_integer = False
1485     is_rational = True
1486     is_number = True
1487 
1488     __slots__ = ['p', 'q']
1489 
1490     is_Rational = True
1491 
1492     @cacheit
1493     def __new__(cls, p, q=None, gcd=None):
1494         if q is None:
1495             if isinstance(p, Rational):
1496                 return p
1497 
1498             if isinstance(p, SYMPY_INTS):
1499                 pass
1500             else:
1501                 if isinstance(p, (float, Float)):
1502                     return Rational(*_as_integer_ratio(p))
1503 
1504                 if not isinstance(p, string_types):
1505                     try:
1506                         p = sympify(p)
1507                     except (SympifyError, SyntaxError):
1508                         pass  # error will raise below
1509                 else:
1510                     if p.count('/') > 1:
1511                         raise TypeError('invalid input: %s' % p)
1512                     p = p.replace(' ', '')
1513                     pq = p.rsplit('/', 1)
1514                     if len(pq) == 2:
1515                         p, q = pq
1516                         fp = fractions.Fraction(p)
1517                         fq = fractions.Fraction(q)
1518                         p = fp/fq
1519                     try:
1520                         p = fractions.Fraction(p)
1521                     except ValueError:
1522                         pass  # error will raise below
1523                     else:
1524                         return Rational(p.numerator, p.denominator, 1)
1525 
1526                 if not isinstance(p, Rational):
1527                     raise TypeError('invalid input: %s' % p)
1528 
1529             q = 1
1530             gcd = 1
1531         else:
1532             p = Rational(p)
1533             q = Rational(q)
1534 
1535         if isinstance(q, Rational):
1536             p *= q.q
1537             q = q.p
1538         if isinstance(p, Rational):
1539             q *= p.q
1540             p = p.p
1541 
1542         # p and q are now integers
1543         if q == 0:
1544             if p == 0:
1545                 if _errdict["divide"]:
1546                     raise ValueError("Indeterminate 0/0")
1547                 else:
1548                     return S.NaN
1549             return S.ComplexInfinity
1550         if q < 0:
1551             q = -q
1552             p = -p
1553         if not gcd:
1554             gcd = igcd(abs(p), q)
1555         if gcd > 1:
1556             p //= gcd
1557             q //= gcd
1558         if q == 1:
1559             return Integer(p)
1560         if p == 1 and q == 2:
1561             return S.Half
1562         obj = Expr.__new__(cls)
1563         obj.p = p
1564         obj.q = q
1565         return obj
1566 
1567     def limit_denominator(self, max_denominator=1000000):
1568         """Closest Rational to self with denominator at most max_denominator.
1569 
1570         >>> from sympy import Rational
1571         >>> Rational('3.141592653589793').limit_denominator(10)
1572         22/7
1573         >>> Rational('3.141592653589793').limit_denominator(100)
1574         311/99
1575 
1576         """
1577         f = fractions.Fraction(self.p, self.q)
1578         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))
1579 
1580     def __getnewargs__(self):
1581         return (self.p, self.q)
1582 
1583     def _hashable_content(self):
1584         return (self.p, self.q)
1585 
1586     def _eval_is_positive(self):
1587         return self.p > 0
1588 
1589     def _eval_is_zero(self):
1590         return self.p == 0
1591 
1592     def __neg__(self):
1593         return Rational(-self.p, self.q)
1594 
1595     @_sympifyit('other', NotImplemented)
1596     def __add__(self, other):
1597         if global_evaluate[0]:
1598             if isinstance(other, Integer):
1599                 return Rational(self.p + self.q*other.p, self.q, 1)
1600             elif isinstance(other, Rational):
1601                 #TODO: this can probably be optimized more
1602                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)
1603             elif isinstance(other, Float):
1604                 return other + self
1605             else:
1606                 return Number.__add__(self, other)
1607         return Number.__add__(self, other)
1608     __radd__ = __add__
1609 
1610     @_sympifyit('other', NotImplemented)
1611     def __sub__(self, other):
1612         if global_evaluate[0]:
1613             if isinstance(other, Integer):
1614                 return Rational(self.p - self.q*other.p, self.q, 1)
1615             elif isinstance(other, Rational):
1616                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)
1617             elif isinstance(other, Float):
1618                 return -other + self
1619             else:
1620                 return Number.__sub__(self, other)
1621         return Number.__sub__(self, other)
1622     @_sympifyit('other', NotImplemented)
1623     def __rsub__(self, other):
1624         if global_evaluate[0]:
1625             if isinstance(other, Integer):
1626                 return Rational(self.q*other.p - self.p, self.q, 1)
1627             elif isinstance(other, Rational):
1628                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)
1629             elif isinstance(other, Float):
1630                 return -self + other
1631             else:
1632                 return Number.__rsub__(self, other)
1633         return Number.__rsub__(self, other)
1634     @_sympifyit('other', NotImplemented)
1635     def __mul__(self, other):
1636         if global_evaluate[0]:
1637             if isinstance(other, Integer):
1638                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))
1639             elif isinstance(other, Rational):
1640                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))
1641             elif isinstance(other, Float):
1642                 return other*self
1643             else:
1644                 return Number.__mul__(self, other)
1645         return Number.__mul__(self, other)
1646     __rmul__ = __mul__
1647 
1648     @_sympifyit('other', NotImplemented)
1649     def __div__(self, other):
1650         if global_evaluate[0]:
1651             if isinstance(other, Integer):
1652                 if self.p and other.p == S.Zero:
1653                     return S.ComplexInfinity
1654                 else:
1655                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))
1656             elif isinstance(other, Rational):
1657                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1658             elif isinstance(other, Float):
1659                 return self*(1/other)
1660             else:
1661                 return Number.__div__(self, other)
1662         return Number.__div__(self, other)
1663     @_sympifyit('other', NotImplemented)
1664     def __rdiv__(self, other):
1665         if global_evaluate[0]:
1666             if isinstance(other, Integer):
1667                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))
1668             elif isinstance(other, Rational):
1669                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1670             elif isinstance(other, Float):
1671                 return other*(1/self)
1672             else:
1673                 return Number.__rdiv__(self, other)
1674         return Number.__rdiv__(self, other)
1675     __truediv__ = __div__
1676 
1677     @_sympifyit('other', NotImplemented)
1678     def __mod__(self, other):
1679         if global_evaluate[0]:
1680             if isinstance(other, Rational):
1681                 n = (self.p*other.q) // (other.p*self.q)
1682                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)
1683             if isinstance(other, Float):
1684                 # calculate mod with Rationals, *then* round the answer
1685                 return Float(self.__mod__(Rational(other)),
1686                              precision=other._prec)
1687             return Number.__mod__(self, other)
1688         return Number.__mod__(self, other)
1689 
1690     @_sympifyit('other', NotImplemented)
1691     def __rmod__(self, other):
1692         if isinstance(other, Rational):
1693             return Rational.__mod__(other, self)
1694         return Number.__rmod__(self, other)
1695 
1696     def _eval_power(self, expt):
1697         if isinstance(expt, Number):
1698             if isinstance(expt, Float):
1699                 return self._eval_evalf(expt._prec)**expt
1700             if expt.is_negative:
1701                 # (3/4)**-2 -> (4/3)**2
1702                 ne = -expt
1703                 if (ne is S.One):
1704                     return Rational(self.q, self.p)
1705                 if self.is_negative:
1706                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne
1707                 else:
1708                     return Rational(self.q, self.p)**ne
1709             if expt is S.Infinity:  # -oo already caught by test for negative
1710                 if self.p > self.q:
1711                     # (3/2)**oo -> oo
1712                     return S.Infinity
1713                 if self.p < -self.q:
1714                     # (-3/2)**oo -> oo + I*oo
1715                     return S.Infinity + S.Infinity*S.ImaginaryUnit
1716                 return S.Zero
1717             if isinstance(expt, Integer):
1718                 # (4/3)**2 -> 4**2 / 3**2
1719                 return Rational(self.p**expt.p, self.q**expt.p, 1)
1720             if isinstance(expt, Rational):
1721                 if self.p != 1:
1722                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)
1723                     return Integer(self.p)**expt*Integer(self.q)**(-expt)
1724                 # as the above caught negative self.p, now self is positive
1725                 return Integer(self.q)**Rational(
1726                 expt.p*(expt.q - 1), expt.q) / \
1727                     Integer(self.q)**Integer(expt.p)
1728 
1729         if self.is_negative and expt.is_even:
1730             return (-self)**expt
1731 
1732         return
1733 
1734     def _as_mpf_val(self, prec):
1735         return mlib.from_rational(self.p, self.q, prec, rnd)
1736 
1737     def _mpmath_(self, prec, rnd):
1738         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))
1739 
1740     def __abs__(self):
1741         return Rational(abs(self.p), self.q)
1742 
1743     def __int__(self):
1744         p, q = self.p, self.q
1745         if p < 0:
1746             return -int(-p//q)
1747         return int(p//q)
1748 
1749     __long__ = __int__
1750 
1751     def floor(self):
1752         return Integer(self.p // self.q)
1753 
1754     def ceiling(self):
1755         return -Integer(-self.p // self.q)
1756 
1757     def __floor__(self):
1758         return self.floor()
1759 
1760     def __ceil__(self):
1761         return self.ceiling()
1762 
1763     def __eq__(self, other):
1764         try:
1765             other = _sympify(other)
1766         except SympifyError:
1767             return NotImplemented
1768         if other.is_NumberSymbol:
1769             if other.is_irrational:
1770                 return False
1771             return other.__eq__(self)
1772         if other.is_Number:
1773             if other.is_Rational:
1774                 # a Rational is always in reduced form so will never be 2/4
1775                 # so we can just check equivalence of args
1776                 return self.p == other.p and self.q == other.q
1777             if other.is_Float:
1778                 return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
1779         return False
1780 
1781     def __ne__(self, other):
1782         return not self == other
1783 
1784     def __gt__(self, other):
1785         try:
1786             other = _sympify(other)
1787         except SympifyError:
1788             raise TypeError("Invalid comparison %s > %s" % (self, other))
1789         if other.is_NumberSymbol:
1790             return other.__lt__(self)
1791         expr = self
1792         if other.is_Number:
1793             if other.is_Rational:
1794                 return _sympify(bool(self.p*other.q > self.q*other.p))
1795             if other.is_Float:
1796                 return _sympify(bool(mlib.mpf_gt(
1797                     self._as_mpf_val(other._prec), other._mpf_)))
1798         elif other.is_number and other.is_real:
1799             expr, other = Integer(self.p), self.q*other
1800         return Expr.__gt__(expr, other)
1801 
1802     def __ge__(self, other):
1803         try:
1804             other = _sympify(other)
1805         except SympifyError:
1806             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1807         if other.is_NumberSymbol:
1808             return other.__le__(self)
1809         expr = self
1810         if other.is_Number:
1811             if other.is_Rational:
1812                  return _sympify(bool(self.p*other.q >= self.q*other.p))
1813             if other.is_Float:
1814                 return _sympify(bool(mlib.mpf_ge(
1815                     self._as_mpf_val(other._prec), other._mpf_)))
1816         elif other.is_number and other.is_real:
1817             expr, other = Integer(self.p), self.q*other
1818         return Expr.__ge__(expr, other)
1819 
1820     def __lt__(self, other):
1821         try:
1822             other = _sympify(other)
1823         except SympifyError:
1824             raise TypeError("Invalid comparison %s < %s" % (self, other))
1825         if other.is_NumberSymbol:
1826             return other.__gt__(self)
1827         expr = self
1828         if other.is_Number:
1829             if other.is_Rational:
1830                 return _sympify(bool(self.p*other.q < self.q*other.p))
1831             if other.is_Float:
1832                 return _sympify(bool(mlib.mpf_lt(
1833                     self._as_mpf_val(other._prec), other._mpf_)))
1834         elif other.is_number and other.is_real:
1835             expr, other = Integer(self.p), self.q*other
1836         return Expr.__lt__(expr, other)
1837 
1838     def __le__(self, other):
1839         try:
1840             other = _sympify(other)
1841         except SympifyError:
1842             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1843         expr = self
1844         if other.is_NumberSymbol:
1845             return other.__ge__(self)
1846         elif other.is_Number:
1847             if other.is_Rational:
1848                 return _sympify(bool(self.p*other.q <= self.q*other.p))
1849             if other.is_Float:
1850                 return _sympify(bool(mlib.mpf_le(
1851                     self._as_mpf_val(other._prec), other._mpf_)))
1852         elif other.is_number and other.is_real:
1853             expr, other = Integer(self.p), self.q*other
1854         return Expr.__le__(expr, other)
1855 
1856     def __hash__(self):
1857         return super(Rational, self).__hash__()
1858 
1859     def factors(self, limit=None, use_trial=True, use_rho=False,
1860                 use_pm1=False, verbose=False, visual=False):
1861         """A wrapper to factorint which return factors of self that are
1862         smaller than limit (or cheap to compute). Special methods of
1863         factoring are disabled by default so that only trial division is used.
1864         """
1865         from sympy.ntheory import factorrat
1866 
1867         return factorrat(self, limit=limit, use_trial=use_trial,
1868                       use_rho=use_rho, use_pm1=use_pm1,
1869                       verbose=verbose).copy()
1870 
1871     def numerator(self):
1872         return self.p
1873 
1874     def denominator(self):
1875         return self.q
1876 
1877     @_sympifyit('other', NotImplemented)
1878     def gcd(self, other):
1879         if isinstance(other, Rational):
1880             if other is S.Zero:
1881                 return other
1882             return Rational(
1883                 Integer(igcd(self.p, other.p)),
1884                 Integer(ilcm(self.q, other.q)))
1885         return Number.gcd(self, other)
1886 
1887     @_sympifyit('other', NotImplemented)
1888     def lcm(self, other):
1889         if isinstance(other, Rational):
1890             return Rational(
1891                 self.p // igcd(self.p, other.p) * other.p,
1892                 igcd(self.q, other.q))
1893         return Number.lcm(self, other)
1894 
1895     def as_numer_denom(self):
1896         return Integer(self.p), Integer(self.q)
1897 
1898     def _sage_(self):
1899         import sage.all as sage
1900         return sage.Integer(self.p)/sage.Integer(self.q)
1901 
1902     def as_content_primitive(self, radical=False, clear=True):
1903         """Return the tuple (R, self/R) where R is the positive Rational
1904         extracted from self.
1905 
1906         Examples
1907         ========
1908 
1909         >>> from sympy import S
1910         >>> (S(-3)/2).as_content_primitive()
1911         (3/2, -1)
1912 
1913         See docstring of Expr.as_content_primitive for more examples.
1914         """
1915 
1916         if self:
1917             if self.is_positive:
1918                 return self, S.One
1919             return -self, S.NegativeOne
1920         return S.One, self
1921 
1922     def as_coeff_Mul(self, rational=False):
1923         """Efficiently extract the coefficient of a product. """
1924         return self, S.One
1925 
1926     def as_coeff_Add(self, rational=False):
1927         """Efficiently extract the coefficient of a summation. """
1928         return self, S.Zero
1929 
1930 
1931 class Integer(Rational):
1932     """Represents integer numbers of any size.
1933 
1934     Examples
1935     ========
1936 
1937     >>> from sympy import Integer
1938     >>> Integer(3)
1939     3
1940 
1941     If a float or a rational is passed to Integer, the fractional part
1942     will be discarded; the effect is of rounding toward zero.
1943 
1944     >>> Integer(3.8)
1945     3
1946     >>> Integer(-3.8)
1947     -3
1948 
1949     A string is acceptable input if it can be parsed as an integer:
1950 
1951     >>> Integer("9" * 20)
1952     99999999999999999999
1953 
1954     It is rarely needed to explicitly instantiate an Integer, because
1955     Python integers are automatically converted to Integer when they
1956     are used in SymPy expressions.
1957     """
1958     q = 1
1959     is_integer = True
1960     is_number = True
1961 
1962     is_Integer = True
1963 
1964     __slots__ = ['p']
1965 
1966     def _as_mpf_val(self, prec):
1967         return mlib.from_int(self.p, prec, rnd)
1968 
1969     def _mpmath_(self, prec, rnd):
1970         return mpmath.make_mpf(self._as_mpf_val(prec))
1971 
1972     @cacheit
1973     def __new__(cls, i):
1974         if isinstance(i, string_types):
1975             i = i.replace(' ', '')
1976         # whereas we cannot, in general, make a Rational from an
1977         # arbitrary expression, we can make an Integer unambiguously
1978         # (except when a non-integer expression happens to round to
1979         # an integer). So we proceed by taking int() of the input and
1980         # let the int routines determine whether the expression can
1981         # be made into an int or whether an error should be raised.
1982         try:
1983             ival = int(i)
1984         except TypeError:
1985             raise TypeError(
1986                 "Argument of Integer should be of numeric type, got %s." % i)
1987         # We only work with well-behaved integer types. This converts, for
1988         # example, numpy.int32 instances.
1989         if ival == 1:
1990             return S.One
1991         if ival == -1:
1992             return S.NegativeOne
1993         if ival == 0:
1994             return S.Zero
1995         obj = Expr.__new__(cls)
1996         obj.p = ival
1997         return obj
1998 
1999     def __getnewargs__(self):
2000         return (self.p,)
2001 
2002     # Arithmetic operations are here for efficiency
2003     def __int__(self):
2004         return self.p
2005 
2006     __long__ = __int__
2007 
2008     def floor(self):
2009         return Integer(self.p)
2010 
2011     def ceiling(self):
2012         return Integer(self.p)
2013 
2014     def __floor__(self):
2015         return self.floor()
2016 
2017     def __ceil__(self):
2018         return self.ceiling()
2019 
2020     def __neg__(self):
2021         return Integer(-self.p)
2022 
2023     def __abs__(self):
2024         if self.p >= 0:
2025             return self
2026         else:
2027             return Integer(-self.p)
2028 
2029     def __divmod__(self, other):
2030         from .containers import Tuple
2031         if isinstance(other, Integer) and global_evaluate[0]:
2032             return Tuple(*(divmod(self.p, other.p)))
2033         else:
2034             return Number.__divmod__(self, other)
2035 
2036     def __rdivmod__(self, other):
2037         from .containers import Tuple
2038         if isinstance(other, integer_types) and global_evaluate[0]:
2039             return Tuple(*(divmod(other, self.p)))
2040         else:
2041             try:
2042                 other = Number(other)
2043             except TypeError:
2044                 msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
2045                 oname = type(other).__name__
2046                 sname = type(self).__name__
2047                 raise TypeError(msg % (oname, sname))
2048             return Number.__divmod__(other, self)
2049 
2050     # TODO make it decorator + bytecodehacks?
2051     def __add__(self, other):
2052         if global_evaluate[0]:
2053             if isinstance(other, integer_types):
2054                 return Integer(self.p + other)
2055             elif isinstance(other, Integer):
2056                 return Integer(self.p + other.p)
2057             elif isinstance(other, Rational):
2058                 return Rational(self.p*other.q + other.p, other.q, 1)
2059             return Rational.__add__(self, other)
2060         else:
2061             return Add(self, other)
2062 
2063     def __radd__(self, other):
2064         if global_evaluate[0]:
2065             if isinstance(other, integer_types):
2066                 return Integer(other + self.p)
2067             elif isinstance(other, Rational):
2068                 return Rational(other.p + self.p*other.q, other.q, 1)
2069             return Rational.__radd__(self, other)
2070         return Rational.__radd__(self, other)
2071 
2072     def __sub__(self, other):
2073         if global_evaluate[0]:
2074             if isinstance(other, integer_types):
2075                 return Integer(self.p - other)
2076             elif isinstance(other, Integer):
2077                 return Integer(self.p - other.p)
2078             elif isinstance(other, Rational):
2079                 return Rational(self.p*other.q - other.p, other.q, 1)
2080             return Rational.__sub__(self, other)
2081         return Rational.__sub__(self, other)
2082 
2083     def __rsub__(self, other):
2084         if global_evaluate[0]:
2085             if isinstance(other, integer_types):
2086                 return Integer(other - self.p)
2087             elif isinstance(other, Rational):
2088                 return Rational(other.p - self.p*other.q, other.q, 1)
2089             return Rational.__rsub__(self, other)
2090         return Rational.__rsub__(self, other)
2091 
2092     def __mul__(self, other):
2093         if global_evaluate[0]:
2094             if isinstance(other, integer_types):
2095                 return Integer(self.p*other)
2096             elif isinstance(other, Integer):
2097                 return Integer(self.p*other.p)
2098             elif isinstance(other, Rational):
2099                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))
2100             return Rational.__mul__(self, other)
2101         return Rational.__mul__(self, other)
2102 
2103     def __rmul__(self, other):
2104         if global_evaluate[0]:
2105             if isinstance(other, integer_types):
2106                 return Integer(other*self.p)
2107             elif isinstance(other, Rational):
2108                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))
2109             return Rational.__rmul__(self, other)
2110         return Rational.__rmul__(self, other)
2111 
2112     def __mod__(self, other):
2113         if global_evaluate[0]:
2114             if isinstance(other, integer_types):
2115                 return Integer(self.p % other)
2116             elif isinstance(other, Integer):
2117                 return Integer(self.p % other.p)
2118             return Rational.__mod__(self, other)
2119         return Rational.__mod__(self, other)
2120 
2121     def __rmod__(self, other):
2122         if global_evaluate[0]:
2123             if isinstance(other, integer_types):
2124                 return Integer(other % self.p)
2125             elif isinstance(other, Integer):
2126                 return Integer(other.p % self.p)
2127             return Rational.__rmod__(self, other)
2128         return Rational.__rmod__(self, other)
2129 
2130     def __eq__(self, other):
2131         if isinstance(other, integer_types):
2132             return (self.p == other)
2133         elif isinstance(other, Integer):
2134             return (self.p == other.p)
2135         return Rational.__eq__(self, other)
2136 
2137     def __ne__(self, other):
2138         return not self == other
2139 
2140     def __gt__(self, other):
2141         try:
2142             other = _sympify(other)
2143         except SympifyError:
2144             raise TypeError("Invalid comparison %s > %s" % (self, other))
2145         if other.is_Integer:
2146             return _sympify(self.p > other.p)
2147         return Rational.__gt__(self, other)
2148 
2149     def __lt__(self, other):
2150         try:
2151             other = _sympify(other)
2152         except SympifyError:
2153             raise TypeError("Invalid comparison %s < %s" % (self, other))
2154         if other.is_Integer:
2155             return _sympify(self.p < other.p)
2156         return Rational.__lt__(self, other)
2157 
2158     def __ge__(self, other):
2159         try:
2160             other = _sympify(other)
2161         except SympifyError:
2162             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2163         if other.is_Integer:
2164             return _sympify(self.p >= other.p)
2165         return Rational.__ge__(self, other)
2166 
2167     def __le__(self, other):
2168         try:
2169             other = _sympify(other)
2170         except SympifyError:
2171             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2172         if other.is_Integer:
2173             return _sympify(self.p <= other.p)
2174         return Rational.__le__(self, other)
2175 
2176     def __hash__(self):
2177         return hash(self.p)
2178 
2179     def __index__(self):
2180         return self.p
2181 
2182     ########################################
2183 
2184     def _eval_is_odd(self):
2185         return bool(self.p % 2)
2186 
2187     def _eval_power(self, expt):
2188         """
2189         Tries to do some simplifications on self**expt
2190 
2191         Returns None if no further simplifications can be done
2192 
2193         When exponent is a fraction (so we have for example a square root),
2194         we try to find a simpler representation by factoring the argument
2195         up to factors of 2**15, e.g.
2196 
2197           - sqrt(4) becomes 2
2198           - sqrt(-4) becomes 2*I
2199           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)
2200 
2201         Further simplification would require a special call to factorint on
2202         the argument which is not done here for sake of speed.
2203 
2204         """
2205         from sympy import perfect_power
2206 
2207         if expt is S.Infinity:
2208             if self.p > S.One:
2209                 return S.Infinity
2210             # cases -1, 0, 1 are done in their respective classes
2211             return S.Infinity + S.ImaginaryUnit*S.Infinity
2212         if expt is S.NegativeInfinity:
2213             return Rational(1, self)**S.Infinity
2214         if not isinstance(expt, Number):
2215             # simplify when expt is even
2216             # (-2)**k --> 2**k
2217             if self.is_negative and expt.is_even:
2218                 return (-self)**expt
2219         if isinstance(expt, Float):
2220             # Rational knows how to exponentiate by a Float
2221             return super(Integer, self)._eval_power(expt)
2222         if not isinstance(expt, Rational):
2223             return
2224         if expt is S.Half and self.is_negative:
2225             # we extract I for this special case since everyone is doing so
2226             return S.ImaginaryUnit*Pow(-self, expt)
2227         if expt.is_negative:
2228             # invert base and change sign on exponent
2229             ne = -expt
2230             if self.is_negative:
2231                     return S.NegativeOne**expt*Rational(1, -self)**ne
2232             else:
2233                 return Rational(1, self.p)**ne
2234         # see if base is a perfect root, sqrt(4) --> 2
2235         x, xexact = integer_nthroot(abs(self.p), expt.q)
2236         if xexact:
2237             # if it's a perfect root we've finished
2238             result = Integer(x**abs(expt.p))
2239             if self.is_negative:
2240                 result *= S.NegativeOne**expt
2241             return result
2242 
2243         # The following is an algorithm where we collect perfect roots
2244         # from the factors of base.
2245 
2246         # if it's not an nth root, it still might be a perfect power
2247         b_pos = int(abs(self.p))
2248         p = perfect_power(b_pos)
2249         if p is not False:
2250             dict = {p[0]: p[1]}
2251         else:
2252             dict = Integer(b_pos).factors(limit=2**15)
2253 
2254         # now process the dict of factors
2255         out_int = 1  # integer part
2256         out_rad = 1  # extracted radicals
2257         sqr_int = 1
2258         sqr_gcd = 0
2259         sqr_dict = {}
2260         for prime, exponent in dict.items():
2261             exponent *= expt.p
2262             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)
2263             div_e, div_m = divmod(exponent, expt.q)
2264             if div_e > 0:
2265                 out_int *= prime**div_e
2266             if div_m > 0:
2267                 # see if the reduced exponent shares a gcd with e.q
2268                 # (2**2)**(1/10) -> 2**(1/5)
2269                 g = igcd(div_m, expt.q)
2270                 if g != 1:
2271                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))
2272                 else:
2273                     sqr_dict[prime] = div_m
2274         # identify gcd of remaining powers
2275         for p, ex in sqr_dict.items():
2276             if sqr_gcd == 0:
2277                 sqr_gcd = ex
2278             else:
2279                 sqr_gcd = igcd(sqr_gcd, ex)
2280                 if sqr_gcd == 1:
2281                     break
2282         for k, v in sqr_dict.items():
2283             sqr_int *= k**(v//sqr_gcd)
2284         if sqr_int == b_pos and out_int == 1 and out_rad == 1:
2285             result = None
2286         else:
2287             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))
2288             if self.is_negative:
2289                 result *= Pow(S.NegativeOne, expt)
2290         return result
2291 
2292     def _eval_is_prime(self):
2293         from sympy.ntheory import isprime
2294 
2295         return isprime(self)
2296 
2297     def _eval_is_composite(self):
2298         if self > 1:
2299             return fuzzy_not(self.is_prime)
2300         else:
2301             return False
2302 
2303     def as_numer_denom(self):
2304         return self, S.One
2305 
2306     def __floordiv__(self, other):
2307         return Integer(self.p // Integer(other).p)
2308 
2309     def __rfloordiv__(self, other):
2310         return Integer(Integer(other).p // self.p)
2311 
2312 # Add sympify converters
2313 for i_type in integer_types:
2314     converter[i_type] = Integer
2315 
2316 
2317 class AlgebraicNumber(Expr):
2318     """Class for representing algebraic numbers in SymPy. """
2319 
2320     __slots__ = ['rep', 'root', 'alias', 'minpoly']
2321 
2322     is_AlgebraicNumber = True
2323     is_algebraic = True
2324     is_number = True
2325 
2326     def __new__(cls, expr, coeffs=None, alias=None, **args):
2327         """Construct a new algebraic number. """
2328         from sympy import Poly
2329         from sympy.polys.polyclasses import ANP, DMP
2330         from sympy.polys.numberfields import minimal_polynomial
2331         from sympy.core.symbol import Symbol
2332 
2333         expr = sympify(expr)
2334 
2335         if isinstance(expr, (tuple, Tuple)):
2336             minpoly, root = expr
2337 
2338             if not minpoly.is_Poly:
2339                 minpoly = Poly(minpoly)
2340         elif expr.is_AlgebraicNumber:
2341             minpoly, root = expr.minpoly, expr.root
2342         else:
2343             minpoly, root = minimal_polynomial(
2344                 expr, args.get('gen'), polys=True), expr
2345 
2346         dom = minpoly.get_domain()
2347 
2348         if coeffs is not None:
2349             if not isinstance(coeffs, ANP):
2350                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)
2351                 scoeffs = Tuple(*coeffs)
2352             else:
2353                 rep = DMP.from_list(coeffs.to_list(), 0, dom)
2354                 scoeffs = Tuple(*coeffs.to_list())
2355 
2356             if rep.degree() >= minpoly.degree():
2357                 rep = rep.rem(minpoly.rep)
2358 
2359         else:
2360             rep = DMP.from_list([1, 0], 0, dom)
2361             scoeffs = Tuple(1, 0)
2362 
2363         sargs = (root, scoeffs)
2364 
2365         if alias is not None:
2366             if not isinstance(alias, Symbol):
2367                 alias = Symbol(alias)
2368             sargs = sargs + (alias,)
2369 
2370         obj = Expr.__new__(cls, *sargs)
2371 
2372         obj.rep = rep
2373         obj.root = root
2374         obj.alias = alias
2375         obj.minpoly = minpoly
2376 
2377         return obj
2378 
2379     def __hash__(self):
2380         return super(AlgebraicNumber, self).__hash__()
2381 
2382     def _eval_evalf(self, prec):
2383         return self.as_expr()._evalf(prec)
2384 
2385     @property
2386     def is_aliased(self):
2387         """Returns ``True`` if ``alias`` was set. """
2388         return self.alias is not None
2389 
2390     def as_poly(self, x=None):
2391         """Create a Poly instance from ``self``. """
2392         from sympy import Dummy, Poly, PurePoly
2393         if x is not None:
2394             return Poly.new(self.rep, x)
2395         else:
2396             if self.alias is not None:
2397                 return Poly.new(self.rep, self.alias)
2398             else:
2399                 return PurePoly.new(self.rep, Dummy('x'))
2400 
2401     def as_expr(self, x=None):
2402         """Create a Basic expression from ``self``. """
2403         return self.as_poly(x or self.root).as_expr().expand()
2404 
2405     def coeffs(self):
2406         """Returns all SymPy coefficients of an algebraic number. """
2407         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]
2408 
2409     def native_coeffs(self):
2410         """Returns all native coefficients of an algebraic number. """
2411         return self.rep.all_coeffs()
2412 
2413     def to_algebraic_integer(self):
2414         """Convert ``self`` to an algebraic integer. """
2415         from sympy import Poly
2416         f = self.minpoly
2417 
2418         if f.LC() == 1:
2419             return self
2420 
2421         coeff = f.LC()**(f.degree() - 1)
2422         poly = f.compose(Poly(f.gen/f.LC()))
2423 
2424         minpoly = poly*coeff
2425         root = f.LC()*self.root
2426 
2427         return AlgebraicNumber((minpoly, root), self.coeffs())
2428 
2429     def _eval_simplify(self, ratio, measure, rational, inverse):
2430         from sympy.polys import CRootOf, minpoly
2431 
2432         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:
2433             if minpoly(self.root - r).is_Symbol:
2434                 # use the matching root if it's simpler
2435                 if measure(r) < ratio*measure(self.root):
2436                     return AlgebraicNumber(r)
2437         return self
2438 
2439 
2440 class RationalConstant(Rational):
2441     """
2442     Abstract base class for rationals with specific behaviors
2443 
2444     Derived classes must define class attributes p and q and should probably all
2445     be singletons.
2446     """
2447     __slots__ = []
2448 
2449     def __new__(cls):
2450         return AtomicExpr.__new__(cls)
2451 
2452 
2453 class IntegerConstant(Integer):
2454     __slots__ = []
2455 
2456     def __new__(cls):
2457         return AtomicExpr.__new__(cls)
2458 
2459 
2460 class Zero(with_metaclass(Singleton, IntegerConstant)):
2461     """The number zero.
2462 
2463     Zero is a singleton, and can be accessed by ``S.Zero``
2464 
2465     Examples
2466     ========
2467 
2468     >>> from sympy import S, Integer, zoo
2469     >>> Integer(0) is S.Zero
2470     True
2471     >>> 1/S.Zero
2472     zoo
2473 
2474     References
2475     ==========
2476 
2477     .. [1] https://en.wikipedia.org/wiki/Zero
2478     """
2479 
2480     p = 0
2481     q = 1
2482     is_positive = False
2483     is_negative = False
2484     is_zero = True
2485     is_number = True
2486 
2487     __slots__ = []
2488 
2489     @staticmethod
2490     def __abs__():
2491         return S.Zero
2492 
2493     @staticmethod
2494     def __neg__():
2495         return S.Zero
2496 
2497     def _eval_power(self, expt):
2498         if expt.is_positive:
2499             return self
2500         if expt.is_negative:
2501             return S.ComplexInfinity
2502         if expt.is_real is False:
2503             return S.NaN
2504         # infinities are already handled with pos and neg
2505         # tests above; now throw away leading numbers on Mul
2506         # exponent
2507         coeff, terms = expt.as_coeff_Mul()
2508         if coeff.is_negative:
2509             return S.ComplexInfinity**terms
2510         if coeff is not S.One:  # there is a Number to discard
2511             return self**terms
2512 
2513     def _eval_order(self, *symbols):
2514         # Order(0,x) -> 0
2515         return self
2516 
2517     def __nonzero__(self):
2518         return False
2519 
2520     __bool__ = __nonzero__
2521 
2522     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted
2523         """Efficiently extract the coefficient of a summation. """
2524         return S.One, self
2525 
2526 
2527 class One(with_metaclass(Singleton, IntegerConstant)):
2528     """The number one.
2529 
2530     One is a singleton, and can be accessed by ``S.One``.
2531 
2532     Examples
2533     ========
2534 
2535     >>> from sympy import S, Integer
2536     >>> Integer(1) is S.One
2537     True
2538 
2539     References
2540     ==========
2541 
2542     .. [1] https://en.wikipedia.org/wiki/1_%28number%29
2543     """
2544     is_number = True
2545 
2546     p = 1
2547     q = 1
2548 
2549     __slots__ = []
2550 
2551     @staticmethod
2552     def __abs__():
2553         return S.One
2554 
2555     @staticmethod
2556     def __neg__():
2557         return S.NegativeOne
2558 
2559     def _eval_power(self, expt):
2560         return self
2561 
2562     def _eval_order(self, *symbols):
2563         return
2564 
2565     @staticmethod
2566     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,
2567                 verbose=False, visual=False):
2568         if visual:
2569             return S.One
2570         else:
2571             return {}
2572 
2573 
2574 class NegativeOne(with_metaclass(Singleton, IntegerConstant)):
2575     """The number negative one.
2576 
2577     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.
2578 
2579     Examples
2580     ========
2581 
2582     >>> from sympy import S, Integer
2583     >>> Integer(-1) is S.NegativeOne
2584     True
2585 
2586     See Also
2587     ========
2588 
2589     One
2590 
2591     References
2592     ==========
2593 
2594     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29
2595 
2596     """
2597     is_number = True
2598 
2599     p = -1
2600     q = 1
2601 
2602     __slots__ = []
2603 
2604     @staticmethod
2605     def __abs__():
2606         return S.One
2607 
2608     @staticmethod
2609     def __neg__():
2610         return S.One
2611 
2612     def _eval_power(self, expt):
2613         if expt.is_odd:
2614             return S.NegativeOne
2615         if expt.is_even:
2616             return S.One
2617         if isinstance(expt, Number):
2618             if isinstance(expt, Float):
2619                 return Float(-1.0)**expt
2620             if expt is S.NaN:
2621                 return S.NaN
2622             if expt is S.Infinity or expt is S.NegativeInfinity:
2623                 return S.NaN
2624             if expt is S.Half:
2625                 return S.ImaginaryUnit
2626             if isinstance(expt, Rational):
2627                 if expt.q == 2:
2628                     return S.ImaginaryUnit**Integer(expt.p)
2629                 i, r = divmod(expt.p, expt.q)
2630                 if i:
2631                     return self**i*self**Rational(r, expt.q)
2632         return
2633 
2634 
2635 class Half(with_metaclass(Singleton, RationalConstant)):
2636     """The rational number 1/2.
2637 
2638     Half is a singleton, and can be accessed by ``S.Half``.
2639 
2640     Examples
2641     ========
2642 
2643     >>> from sympy import S, Rational
2644     >>> Rational(1, 2) is S.Half
2645     True
2646 
2647     References
2648     ==========
2649 
2650     .. [1] https://en.wikipedia.org/wiki/One_half
2651     """
2652     is_number = True
2653 
2654     p = 1
2655     q = 2
2656 
2657     __slots__ = []
2658 
2659     @staticmethod
2660     def __abs__():
2661         return S.Half
2662 
2663 
2664 class Infinity(with_metaclass(Singleton, Number)):
2665     r"""Positive infinite quantity.
2666 
2667     In real analysis the symbol `\infty` denotes an unbounded
2668     limit: `x\to\infty` means that `x` grows without bound.
2669 
2670     Infinity is often used not only to define a limit but as a value
2671     in the affinely extended real number system.  Points labeled `+\infty`
2672     and `-\infty` can be added to the topological space of the real numbers,
2673     producing the two-point compactification of the real numbers.  Adding
2674     algebraic properties to this gives us the extended real numbers.
2675 
2676     Infinity is a singleton, and can be accessed by ``S.Infinity``,
2677     or can be imported as ``oo``.
2678 
2679     Examples
2680     ========
2681 
2682     >>> from sympy import oo, exp, limit, Symbol
2683     >>> 1 + oo
2684     oo
2685     >>> 42/oo
2686     0
2687     >>> x = Symbol('x')
2688     >>> limit(exp(x), x, oo)
2689     oo
2690 
2691     See Also
2692     ========
2693 
2694     NegativeInfinity, NaN
2695 
2696     References
2697     ==========
2698 
2699     .. [1] https://en.wikipedia.org/wiki/Infinity
2700     """
2701 
2702     is_commutative = True
2703     is_positive = True
2704     is_infinite = True
2705     is_number = True
2706     is_prime = False
2707 
2708     __slots__ = []
2709 
2710     def __new__(cls):
2711         return AtomicExpr.__new__(cls)
2712 
2713     def _latex(self, printer):
2714         return r"\infty"
2715 
2716     def _eval_subs(self, old, new):
2717         if self == old:
2718             return new
2719 
2720     @_sympifyit('other', NotImplemented)
2721     def __add__(self, other):
2722         if isinstance(other, Number):
2723             if other is S.NegativeInfinity or other is S.NaN:
2724                 return S.NaN
2725             return self
2726         return NotImplemented
2727     __radd__ = __add__
2728 
2729     @_sympifyit('other', NotImplemented)
2730     def __sub__(self, other):
2731         if isinstance(other, Number):
2732             if other is S.Infinity or other is S.NaN:
2733                 return S.NaN
2734             return self
2735         return NotImplemented
2736 
2737     @_sympifyit('other', NotImplemented)
2738     def __rsub__(self, other):
2739         return (-self).__add__(other)
2740 
2741     @_sympifyit('other', NotImplemented)
2742     def __mul__(self, other):
2743         if isinstance(other, Number):
2744             if other.is_zero or other is S.NaN:
2745                 return S.NaN
2746             if other.is_positive:
2747                 return self
2748             return S.NegativeInfinity
2749         return NotImplemented
2750     __rmul__ = __mul__
2751 
2752     @_sympifyit('other', NotImplemented)
2753     def __div__(self, other):
2754         if isinstance(other, Number):
2755             if other is S.Infinity or \
2756                 other is S.NegativeInfinity or \
2757                     other is S.NaN:
2758                 return S.NaN
2759             if other.is_nonnegative:
2760                 return self
2761             return S.NegativeInfinity
2762         return NotImplemented
2763 
2764     __truediv__ = __div__
2765 
2766     def __abs__(self):
2767         return S.Infinity
2768 
2769     def __neg__(self):
2770         return S.NegativeInfinity
2771 
2772     def _eval_power(self, expt):
2773         """
2774         ``expt`` is symbolic object but not equal to 0 or 1.
2775 
2776         ================ ======= ==============================
2777         Expression       Result  Notes
2778         ================ ======= ==============================
2779         ``oo ** nan``    ``nan``
2780         ``oo ** -p``     ``0``   ``p`` is number, ``oo``
2781         ================ ======= ==============================
2782 
2783         See Also
2784         ========
2785         Pow
2786         NaN
2787         NegativeInfinity
2788 
2789         """
2790         from sympy.functions import re
2791 
2792         if expt.is_positive:
2793             return S.Infinity
2794         if expt.is_negative:
2795             return S.Zero
2796         if expt is S.NaN:
2797             return S.NaN
2798         if expt is S.ComplexInfinity:
2799             return S.NaN
2800         if expt.is_real is False and expt.is_number:
2801             expt_real = re(expt)
2802             if expt_real.is_positive:
2803                 return S.ComplexInfinity
2804             if expt_real.is_negative:
2805                 return S.Zero
2806             if expt_real.is_zero:
2807                 return S.NaN
2808 
2809             return self**expt.evalf()
2810 
2811     def _as_mpf_val(self, prec):
2812         return mlib.finf
2813 
2814     def _sage_(self):
2815         import sage.all as sage
2816         return sage.oo
2817 
2818     def __hash__(self):
2819         return super(Infinity, self).__hash__()
2820 
2821     def __eq__(self, other):
2822         return other is S.Infinity or other == float('inf')
2823 
2824     def __ne__(self, other):
2825         return other is not S.Infinity and other != float('inf')
2826 
2827     def __lt__(self, other):
2828         try:
2829             other = _sympify(other)
2830         except SympifyError:
2831             raise TypeError("Invalid comparison %s < %s" % (self, other))
2832         if other.is_real:
2833             return S.false
2834         return Expr.__lt__(self, other)
2835 
2836     def __le__(self, other):
2837         try:
2838             other = _sympify(other)
2839         except SympifyError:
2840             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2841         if other.is_real:
2842             if other.is_finite or other is S.NegativeInfinity:
2843                 return S.false
2844             elif other.is_nonpositive:
2845                 return S.false
2846             elif other.is_infinite and other.is_positive:
2847                 return S.true
2848         return Expr.__le__(self, other)
2849 
2850     def __gt__(self, other):
2851         try:
2852             other = _sympify(other)
2853         except SympifyError:
2854             raise TypeError("Invalid comparison %s > %s" % (self, other))
2855         if other.is_real:
2856             if other.is_finite or other is S.NegativeInfinity:
2857                 return S.true
2858             elif other.is_nonpositive:
2859                 return S.true
2860             elif other.is_infinite and other.is_positive:
2861                 return S.false
2862         return Expr.__gt__(self, other)
2863 
2864     def __ge__(self, other):
2865         try:
2866             other = _sympify(other)
2867         except SympifyError:
2868             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2869         if other.is_real:
2870             return S.true
2871         return Expr.__ge__(self, other)
2872 
2873     def __mod__(self, other):
2874         return S.NaN
2875 
2876     __rmod__ = __mod__
2877 
2878     def floor(self):
2879         return self
2880 
2881     def ceiling(self):
2882         return self
2883 
2884 oo = S.Infinity
2885 
2886 
2887 class NegativeInfinity(with_metaclass(Singleton, Number)):
2888     """Negative infinite quantity.
2889 
2890     NegativeInfinity is a singleton, and can be accessed
2891     by ``S.NegativeInfinity``.
2892 
2893     See Also
2894     ========
2895 
2896     Infinity
2897     """
2898 
2899     is_commutative = True
2900     is_negative = True
2901     is_infinite = True
2902     is_number = True
2903 
2904     __slots__ = []
2905 
2906     def __new__(cls):
2907         return AtomicExpr.__new__(cls)
2908 
2909     def _latex(self, printer):
2910         return r"-\infty"
2911 
2912     def _eval_subs(self, old, new):
2913         if self == old:
2914             return new
2915 
2916     @_sympifyit('other', NotImplemented)
2917     def __add__(self, other):
2918         if isinstance(other, Number):
2919             if other is S.Infinity or other is S.NaN:
2920                 return S.NaN
2921             return self
2922         return NotImplemented
2923     __radd__ = __add__
2924 
2925     @_sympifyit('other', NotImplemented)
2926     def __sub__(self, other):
2927         if isinstance(other, Number):
2928             if other is S.NegativeInfinity or other is S.NaN:
2929                 return S.NaN
2930             return self
2931         return NotImplemented
2932 
2933     @_sympifyit('other', NotImplemented)
2934     def __rsub__(self, other):
2935         return (-self).__add__(other)
2936 
2937     @_sympifyit('other', NotImplemented)
2938     def __mul__(self, other):
2939         if isinstance(other, Number):
2940             if other.is_zero or other is S.NaN:
2941                 return S.NaN
2942             if other.is_positive:
2943                 return self
2944             return S.Infinity
2945         return NotImplemented
2946     __rmul__ = __mul__
2947 
2948     @_sympifyit('other', NotImplemented)
2949     def __div__(self, other):
2950         if isinstance(other, Number):
2951             if other is S.Infinity or \
2952                 other is S.NegativeInfinity or \
2953                     other is S.NaN:
2954                 return S.NaN
2955             if other.is_nonnegative:
2956                 return self
2957             return S.Infinity
2958         return NotImplemented
2959 
2960     __truediv__ = __div__
2961 
2962     def __abs__(self):
2963         return S.Infinity
2964 
2965     def __neg__(self):
2966         return S.Infinity
2967 
2968     def _eval_power(self, expt):
2969         """
2970         ``expt`` is symbolic object but not equal to 0 or 1.
2971 
2972         ================ ======= ==============================
2973         Expression       Result  Notes
2974         ================ ======= ==============================
2975         ``(-oo) ** nan`` ``nan``
2976         ``(-oo) ** oo``  ``nan``
2977         ``(-oo) ** -oo`` ``nan``
2978         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer
2979         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer
2980         ================ ======= ==============================
2981 
2982         See Also
2983         ========
2984 
2985         Infinity
2986         Pow
2987         NaN
2988 
2989         """
2990         if expt.is_number:
2991             if expt is S.NaN or \
2992                 expt is S.Infinity or \
2993                     expt is S.NegativeInfinity:
2994                 return S.NaN
2995 
2996             if isinstance(expt, Integer) and expt.is_positive:
2997                 if expt.is_odd:
2998                     return S.NegativeInfinity
2999                 else:
3000                     return S.Infinity
3001 
3002             return S.NegativeOne**expt*S.Infinity**expt
3003 
3004     def _as_mpf_val(self, prec):
3005         return mlib.fninf
3006 
3007     def _sage_(self):
3008         import sage.all as sage
3009         return -(sage.oo)
3010 
3011     def __hash__(self):
3012         return super(NegativeInfinity, self).__hash__()
3013 
3014     def __eq__(self, other):
3015         return other is S.NegativeInfinity or other == float('-inf')
3016 
3017     def __ne__(self, other):
3018         return other is not S.NegativeInfinity and other != float('-inf')
3019 
3020     def __lt__(self, other):
3021         try:
3022             other = _sympify(other)
3023         except SympifyError:
3024             raise TypeError("Invalid comparison %s < %s" % (self, other))
3025         if other.is_real:
3026             if other.is_finite or other is S.Infinity:
3027                 return S.true
3028             elif other.is_nonnegative:
3029                 return S.true
3030             elif other.is_infinite and other.is_negative:
3031                 return S.false
3032         return Expr.__lt__(self, other)
3033 
3034     def __le__(self, other):
3035         try:
3036             other = _sympify(other)
3037         except SympifyError:
3038             raise TypeError("Invalid comparison %s <= %s" % (self, other))
3039         if other.is_real:
3040             return S.true
3041         return Expr.__le__(self, other)
3042 
3043     def __gt__(self, other):
3044         try:
3045             other = _sympify(other)
3046         except SympifyError:
3047             raise TypeError("Invalid comparison %s > %s" % (self, other))
3048         if other.is_real:
3049             return S.false
3050         return Expr.__gt__(self, other)
3051 
3052     def __ge__(self, other):
3053         try:
3054             other = _sympify(other)
3055         except SympifyError:
3056             raise TypeError("Invalid comparison %s >= %s" % (self, other))
3057         if other.is_real:
3058             if other.is_finite or other is S.Infinity:
3059                 return S.false
3060             elif other.is_nonnegative:
3061                 return S.false
3062             elif other.is_infinite and other.is_negative:
3063                 return S.true
3064         return Expr.__ge__(self, other)
3065 
3066     def __mod__(self, other):
3067         return S.NaN
3068 
3069     __rmod__ = __mod__
3070 
3071     def floor(self):
3072         return self
3073 
3074     def ceiling(self):
3075         return self
3076 
3077 
3078 class NaN(with_metaclass(Singleton, Number)):
3079     """
3080     Not a Number.
3081 
3082     This serves as a place holder for numeric values that are indeterminate.
3083     Most operations on NaN, produce another NaN.  Most indeterminate forms,
3084     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``
3085     and ``oo**0``, which all produce ``1`` (this is consistent with Python's
3086     float).
3087 
3088     NaN is loosely related to floating point nan, which is defined in the
3089     IEEE 754 floating point standard, and corresponds to the Python
3090     ``float('nan')``.  Differences are noted below.
3091 
3092     NaN is mathematically not equal to anything else, even NaN itself.  This
3093     explains the initially counter-intuitive results with ``Eq`` and ``==`` in
3094     the examples below.
3095 
3096     NaN is not comparable so inequalities raise a TypeError.  This is in
3097     constrast with floating point nan where all inequalities are false.
3098 
3099     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported
3100     as ``nan``.
3101 
3102     Examples
3103     ========
3104 
3105     >>> from sympy import nan, S, oo, Eq
3106     >>> nan is S.NaN
3107     True
3108     >>> oo - oo
3109     nan
3110     >>> nan + 1
3111     nan
3112     >>> Eq(nan, nan)   # mathematical equality
3113     False
3114     >>> nan == nan     # structural equality
3115     True
3116 
3117     References
3118     ==========
3119 
3120     .. [1] https://en.wikipedia.org/wiki/NaN
3121 
3122     """
3123     is_commutative = True
3124     is_real = None
3125     is_rational = None
3126     is_algebraic = None
3127     is_transcendental = None
3128     is_integer = None
3129     is_comparable = False
3130     is_finite = None
3131     is_zero = None
3132     is_prime = None
3133     is_positive = None
3134     is_negative = None
3135     is_number = True
3136 
3137     __slots__ = []
3138 
3139     def __new__(cls):
3140         return AtomicExpr.__new__(cls)
3141 
3142     def _latex(self, printer):
3143         return r"\text{NaN}"
3144 
3145     @_sympifyit('other', NotImplemented)
3146     def __add__(self, other):
3147         return self
3148 
3149     @_sympifyit('other', NotImplemented)
3150     def __sub__(self, other):
3151         return self
3152 
3153     @_sympifyit('other', NotImplemented)
3154     def __mul__(self, other):
3155         return self
3156 
3157     @_sympifyit('other', NotImplemented)
3158     def __div__(self, other):
3159         return self
3160 
3161     __truediv__ = __div__
3162 
3163     def floor(self):
3164         return self
3165 
3166     def ceiling(self):
3167         return self
3168 
3169     def _as_mpf_val(self, prec):
3170         return _mpf_nan
3171 
3172     def _sage_(self):
3173         import sage.all as sage
3174         return sage.NaN
3175 
3176     def __hash__(self):
3177         return super(NaN, self).__hash__()
3178 
3179     def __eq__(self, other):
3180         # NaN is structurally equal to another NaN
3181         return other is S.NaN
3182 
3183     def __ne__(self, other):
3184         return other is not S.NaN
3185 
3186     def _eval_Eq(self, other):
3187         # NaN is not mathematically equal to anything, even NaN
3188         return S.false
3189 
3190     # Expr will _sympify and raise TypeError
3191     __gt__ = Expr.__gt__
3192     __ge__ = Expr.__ge__
3193     __lt__ = Expr.__lt__
3194     __le__ = Expr.__le__
3195 
3196 nan = S.NaN
3197 
3198 
3199 class ComplexInfinity(with_metaclass(Singleton, AtomicExpr)):
3200     r"""Complex infinity.
3201 
3202     In complex analysis the symbol `\tilde\infty`, called "complex
3203     infinity", represents a quantity with infinite magnitude, but
3204     undetermined complex phase.
3205 
3206     ComplexInfinity is a singleton, and can be accessed by
3207     ``S.ComplexInfinity``, or can be imported as ``zoo``.
3208 
3209     Examples
3210     ========
3211 
3212     >>> from sympy import zoo, oo
3213     >>> zoo + 42
3214     zoo
3215     >>> 42/zoo
3216     0
3217     >>> zoo + zoo
3218     nan
3219     >>> zoo*zoo
3220     zoo
3221 
3222     See Also
3223     ========
3224 
3225     Infinity
3226     """
3227 
3228     is_commutative = True
3229     is_infinite = True
3230     is_number = True
3231     is_prime = False
3232     is_complex = True
3233     is_real = False
3234 
3235     __slots__ = []
3236 
3237     def __new__(cls):
3238         return AtomicExpr.__new__(cls)
3239 
3240     def _latex(self, printer):
3241         return r"\tilde{\infty}"
3242 
3243     @staticmethod
3244     def __abs__():
3245         return S.Infinity
3246 
3247     def floor(self):
3248         return self
3249 
3250     def ceiling(self):
3251         return self
3252 
3253     @staticmethod
3254     def __neg__():
3255         return S.ComplexInfinity
3256 
3257     def _eval_power(self, expt):
3258         if expt is S.ComplexInfinity:
3259             return S.NaN
3260 
3261         if isinstance(expt, Number):
3262             if expt is S.Zero:
3263                 return S.NaN
3264             else:
3265                 if expt.is_positive:
3266                     return S.ComplexInfinity
3267                 else:
3268                     return S.Zero
3269 
3270     def _sage_(self):
3271         import sage.all as sage
3272         return sage.UnsignedInfinityRing.gen()
3273 
3274 
3275 zoo = S.ComplexInfinity
3276 
3277 
3278 class NumberSymbol(AtomicExpr):
3279 
3280     is_commutative = True
3281     is_finite = True
3282     is_number = True
3283 
3284     __slots__ = []
3285 
3286     is_NumberSymbol = True
3287 
3288     def __new__(cls):
3289         return AtomicExpr.__new__(cls)
3290 
3291     def approximation(self, number_cls):
3292         """ Return an interval with number_cls endpoints
3293         that contains the value of NumberSymbol.
3294         If not implemented, then return None.
3295         """
3296 
3297     def _eval_evalf(self, prec):
3298         return Float._new(self._as_mpf_val(prec), prec)
3299 
3300     def __eq__(self, other):
3301         try:
3302             other = _sympify(other)
3303         except SympifyError:
3304             return NotImplemented
3305         if self is other:
3306             return True
3307         if other.is_Number and self.is_irrational:
3308             return False
3309 
3310         return False    # NumberSymbol != non-(Number|self)
3311 
3312     def __ne__(self, other):
3313         return not self == other
3314 
3315     def __le__(self, other):
3316         if self is other:
3317             return S.true
3318         return Expr.__le__(self, other)
3319 
3320     def __ge__(self, other):
3321         if self is other:
3322             return S.true
3323         return Expr.__ge__(self, other)
3324 
3325     def __int__(self):
3326         # subclass with appropriate return value
3327         raise NotImplementedError
3328 
3329     def __long__(self):
3330         return self.__int__()
3331 
3332     def __hash__(self):
3333         return super(NumberSymbol, self).__hash__()
3334 
3335 
3336 class Exp1(with_metaclass(Singleton, NumberSymbol)):
3337     r"""The `e` constant.
3338 
3339     The transcendental number `e = 2.718281828\ldots` is the base of the
3340     natural logarithm and of the exponential function, `e = \exp(1)`.
3341     Sometimes called Euler's number or Napier's constant.
3342 
3343     Exp1 is a singleton, and can be accessed by ``S.Exp1``,
3344     or can be imported as ``E``.
3345 
3346     Examples
3347     ========
3348 
3349     >>> from sympy import exp, log, E
3350     >>> E is exp(1)
3351     True
3352     >>> log(E)
3353     1
3354 
3355     References
3356     ==========
3357 
3358     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29
3359     """
3360 
3361     is_real = True
3362     is_positive = True
3363     is_negative = False  # XXX Forces is_negative/is_nonnegative
3364     is_irrational = True
3365     is_number = True
3366     is_algebraic = False
3367     is_transcendental = True
3368 
3369     __slots__ = []
3370 
3371     def _latex(self, printer):
3372         return r"e"
3373 
3374     @staticmethod
3375     def __abs__():
3376         return S.Exp1
3377 
3378     def __int__(self):
3379         return 2
3380 
3381     def _as_mpf_val(self, prec):
3382         return mpf_e(prec)
3383 
3384     def approximation_interval(self, number_cls):
3385         if issubclass(number_cls, Integer):
3386             return (Integer(2), Integer(3))
3387         elif issubclass(number_cls, Rational):
3388             pass
3389 
3390     def _eval_power(self, expt):
3391         from sympy import exp
3392         return exp(expt)
3393 
3394     def _eval_rewrite_as_sin(self, **kwargs):
3395         from sympy import sin
3396         I = S.ImaginaryUnit
3397         return sin(I + S.Pi/2) - I*sin(I)
3398 
3399     def _eval_rewrite_as_cos(self, **kwargs):
3400         from sympy import cos
3401         I = S.ImaginaryUnit
3402         return cos(I) + I*cos(I + S.Pi/2)
3403 
3404     def _sage_(self):
3405         import sage.all as sage
3406         return sage.e
3407 E = S.Exp1
3408 
3409 
3410 class Pi(with_metaclass(Singleton, NumberSymbol)):
3411     r"""The `\pi` constant.
3412 
3413     The transcendental number `\pi = 3.141592654\ldots` represents the ratio
3414     of a circle's circumference to its diameter, the area of the unit circle,
3415     the half-period of trigonometric functions, and many other things
3416     in mathematics.
3417 
3418     Pi is a singleton, and can be accessed by ``S.Pi``, or can
3419     be imported as ``pi``.
3420 
3421     Examples
3422     ========
3423 
3424     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol
3425     >>> S.Pi
3426     pi
3427     >>> pi > 3
3428     True
3429     >>> pi.is_irrational
3430     True
3431     >>> x = Symbol('x')
3432     >>> sin(x + 2*pi)
3433     sin(x)
3434     >>> integrate(exp(-x**2), (x, -oo, oo))
3435     sqrt(pi)
3436 
3437     References
3438     ==========
3439 
3440     .. [1] https://en.wikipedia.org/wiki/Pi
3441     """
3442 
3443     is_real = True
3444     is_positive = True
3445     is_negative = False
3446     is_irrational = True
3447     is_number = True
3448     is_algebraic = False
3449     is_transcendental = True
3450 
3451     __slots__ = []
3452 
3453     def _latex(self, printer):
3454         return r"\pi"
3455 
3456     @staticmethod
3457     def __abs__():
3458         return S.Pi
3459 
3460     def __int__(self):
3461         return 3
3462 
3463     def _as_mpf_val(self, prec):
3464         return mpf_pi(prec)
3465 
3466     def approximation_interval(self, number_cls):
3467         if issubclass(number_cls, Integer):
3468             return (Integer(3), Integer(4))
3469         elif issubclass(number_cls, Rational):
3470             return (Rational(223, 71), Rational(22, 7))
3471 
3472     def _sage_(self):
3473         import sage.all as sage
3474         return sage.pi
3475 pi = S.Pi
3476 
3477 
3478 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):
3479     r"""The golden ratio, `\phi`.
3480 
3481     `\phi = \frac{1 + \sqrt{5}}{2}` is algebraic number.  Two quantities
3482     are in the golden ratio if their ratio is the same as the ratio of
3483     their sum to the larger of the two quantities, i.e. their maximum.
3484 
3485     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.
3486 
3487     Examples
3488     ========
3489 
3490     >>> from sympy import S
3491     >>> S.GoldenRatio > 1
3492     True
3493     >>> S.GoldenRatio.expand(func=True)
3494     1/2 + sqrt(5)/2
3495     >>> S.GoldenRatio.is_irrational
3496     True
3497 
3498     References
3499     ==========
3500 
3501     .. [1] https://en.wikipedia.org/wiki/Golden_ratio
3502     """
3503 
3504     is_real = True
3505     is_positive = True
3506     is_negative = False
3507     is_irrational = True
3508     is_number = True
3509     is_algebraic = True
3510     is_transcendental = False
3511 
3512     __slots__ = []
3513 
3514     def _latex(self, printer):
3515         return r"\phi"
3516 
3517     def __int__(self):
3518         return 1
3519 
3520     def _as_mpf_val(self, prec):
3521          # XXX track down why this has to be increased
3522         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
3523         return mpf_norm(rv, prec)
3524 
3525     def _eval_expand_func(self, **hints):
3526         from sympy import sqrt
3527         return S.Half + S.Half*sqrt(5)
3528 
3529     def approximation_interval(self, number_cls):
3530         if issubclass(number_cls, Integer):
3531             return (S.One, Rational(2))
3532         elif issubclass(number_cls, Rational):
3533             pass
3534 
3535     def _sage_(self):
3536         import sage.all as sage
3537         return sage.golden_ratio
3538 
3539     _eval_rewrite_as_sqrt = _eval_expand_func
3540 
3541 
3542 class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):
3543     r"""The tribonacci constant.
3544 
3545     The tribonacci numbers are like the Fibonacci numbers, but instead
3546     of starting with two predetermined terms, the sequence starts with
3547     three predetermined terms and each term afterwards is the sum of the
3548     preceding three terms.
3549 
3550     The tribonacci constant is the ratio toward which adjacent tribonacci
3551     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,
3552     and also satisfies the equation `x + x^{-3} = 2`.
3553 
3554     TribonacciConstant is a singleton, and can be accessed
3555     by ``S.TribonacciConstant``.
3556 
3557     Examples
3558     ========
3559 
3560     >>> from sympy import S
3561     >>> S.TribonacciConstant > 1
3562     True
3563     >>> S.TribonacciConstant.expand(func=True)
3564     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3
3565     >>> S.TribonacciConstant.is_irrational
3566     True
3567     >>> S.TribonacciConstant.n(20)
3568     1.8392867552141611326
3569 
3570     References
3571     ==========
3572 
3573     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers
3574     """
3575 
3576     is_real = True
3577     is_positive = True
3578     is_negative = False
3579     is_irrational = True
3580     is_number = True
3581     is_algebraic = True
3582     is_transcendental = False
3583 
3584     __slots__ = []
3585 
3586     def _latex(self, printer):
3587         return r"\text{TribonacciConstant}"
3588 
3589     def __int__(self):
3590         return 2
3591 
3592     def _eval_evalf(self, prec):
3593         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)
3594         return Float(rv, precision=prec)
3595 
3596     def _eval_expand_func(self, **hints):
3597         from sympy import sqrt, cbrt
3598         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3
3599 
3600     def approximation_interval(self, number_cls):
3601         if issubclass(number_cls, Integer):
3602             return (S.One, Rational(2))
3603         elif issubclass(number_cls, Rational):
3604             pass
3605 
3606     _eval_rewrite_as_sqrt = _eval_expand_func
3607 
3608 
3609 class EulerGamma(with_metaclass(Singleton, NumberSymbol)):
3610     r"""The Euler-Mascheroni constant.
3611 
3612     `\gamma = 0.5772157\ldots` (also called Euler's constant) is a mathematical
3613     constant recurring in analysis and number theory.  It is defined as the
3614     limiting difference between the harmonic series and the
3615     natural logarithm:
3616 
3617     .. math:: \gamma = \lim\limits_{n\to\infty}
3618               \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln n\right)
3619 
3620     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.
3621 
3622     Examples
3623     ========
3624 
3625     >>> from sympy import S
3626     >>> S.EulerGamma.is_irrational
3627     >>> S.EulerGamma > 0
3628     True
3629     >>> S.EulerGamma > 1
3630     False
3631 
3632     References
3633     ==========
3634 
3635     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant
3636     """
3637 
3638     is_real = True
3639     is_positive = True
3640     is_negative = False
3641     is_irrational = None
3642     is_number = True
3643 
3644     __slots__ = []
3645 
3646     def _latex(self, printer):
3647         return r"\gamma"
3648 
3649     def __int__(self):
3650         return 0
3651 
3652     def _as_mpf_val(self, prec):
3653          # XXX track down why this has to be increased
3654         v = mlib.libhyper.euler_fixed(prec + 10)
3655         rv = mlib.from_man_exp(v, -prec - 10)
3656         return mpf_norm(rv, prec)
3657 
3658     def approximation_interval(self, number_cls):
3659         if issubclass(number_cls, Integer):
3660             return (S.Zero, S.One)
3661         elif issubclass(number_cls, Rational):
3662             return (S.Half, Rational(3, 5))
3663 
3664     def _sage_(self):
3665         import sage.all as sage
3666         return sage.euler_gamma
3667 
3668 
3669 class Catalan(with_metaclass(Singleton, NumberSymbol)):
3670     r"""Catalan's constant.
3671 
3672     `K = 0.91596559\ldots` is given by the infinite series
3673 
3674     .. math:: K = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}
3675 
3676     Catalan is a singleton, and can be accessed by ``S.Catalan``.
3677 
3678     Examples
3679     ========
3680 
3681     >>> from sympy import S
3682     >>> S.Catalan.is_irrational
3683     >>> S.Catalan > 0
3684     True
3685     >>> S.Catalan > 1
3686     False
3687 
3688     References
3689     ==========
3690 
3691     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant
3692     """
3693 
3694     is_real = True
3695     is_positive = True
3696     is_negative = False
3697     is_irrational = None
3698     is_number = True
3699 
3700     __slots__ = []
3701 
3702     def __int__(self):
3703         return 0
3704 
3705     def _as_mpf_val(self, prec):
3706         # XXX track down why this has to be increased
3707         v = mlib.catalan_fixed(prec + 10)
3708         rv = mlib.from_man_exp(v, -prec - 10)
3709         return mpf_norm(rv, prec)
3710 
3711     def approximation_interval(self, number_cls):
3712         if issubclass(number_cls, Integer):
3713             return (S.Zero, S.One)
3714         elif issubclass(number_cls, Rational):
3715             return (Rational(9, 10), S.One)
3716 
3717     def _sage_(self):
3718         import sage.all as sage
3719         return sage.catalan
3720 
3721 
3722 class ImaginaryUnit(with_metaclass(Singleton, AtomicExpr)):
3723     r"""The imaginary unit, `i = \sqrt{-1}`.
3724 
3725     I is a singleton, and can be accessed by ``S.I``, or can be
3726     imported as ``I``.
3727 
3728     Examples
3729     ========
3730 
3731     >>> from sympy import I, sqrt
3732     >>> sqrt(-1)
3733     I
3734     >>> I*I
3735     -1
3736     >>> 1/I
3737     -I
3738 
3739     References
3740     ==========
3741 
3742     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit
3743     """
3744 
3745     is_commutative = True
3746     is_imaginary = True
3747     is_finite = True
3748     is_number = True
3749     is_algebraic = True
3750     is_transcendental = False
3751 
3752     __slots__ = []
3753 
3754     def _latex(self, printer):
3755         return printer._settings['imaginary_unit_latex']
3756 
3757     @staticmethod
3758     def __abs__():
3759         return S.One
3760 
3761     def _eval_evalf(self, prec):
3762         return self
3763 
3764     def _eval_conjugate(self):
3765         return -S.ImaginaryUnit
3766 
3767     def _eval_power(self, expt):
3768         """
3769         b is I = sqrt(-1)
3770         e is symbolic object but not equal to 0, 1
3771 
3772         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal
3773         I**0 mod 4 -> 1
3774         I**1 mod 4 -> I
3775         I**2 mod 4 -> -1
3776         I**3 mod 4 -> -I
3777         """
3778 
3779         if isinstance(expt, Number):
3780             if isinstance(expt, Integer):
3781                 expt = expt.p % 4
3782                 if expt == 0:
3783                     return S.One
3784                 if expt == 1:
3785                     return S.ImaginaryUnit
3786                 if expt == 2:
3787                     return -S.One
3788                 return -S.ImaginaryUnit
3789         return
3790 
3791     def as_base_exp(self):
3792         return S.NegativeOne, S.Half
3793 
3794     def _sage_(self):
3795         import sage.all as sage
3796         return sage.I
3797 
3798     @property
3799     def _mpc_(self):
3800         return (Float(0)._mpf_, Float(1)._mpf_)
3801 
3802 I = S.ImaginaryUnit
3803 
3804 
3805 def sympify_fractions(f):
3806     return Rational(f.numerator, f.denominator, 1)
3807 
3808 converter[fractions.Fraction] = sympify_fractions
3809 
3810 try:
3811     if HAS_GMPY == 2:
3812         import gmpy2 as gmpy
3813     elif HAS_GMPY == 1:
3814         import gmpy
3815     else:
3816         raise ImportError
3817 
3818     def sympify_mpz(x):
3819         return Integer(long(x))
3820 
3821     def sympify_mpq(x):
3822         return Rational(long(x.numerator), long(x.denominator))
3823 
3824     converter[type(gmpy.mpz(1))] = sympify_mpz
3825     converter[type(gmpy.mpq(1, 2))] = sympify_mpq
3826 except ImportError:
3827     pass
3828 
3829 
3830 def sympify_mpmath(x):
3831     return Expr._from_mpmath(x, x.context.prec)
3832 
3833 converter[mpnumeric] = sympify_mpmath
3834 
3835 
3836 def sympify_mpq(x):
3837     p, q = x._mpq_
3838     return Rational(p, q, 1)
3839 
3840 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpq
3841 
3842 
3843 def sympify_complex(a):
3844     real, imag = list(map(sympify, (a.real, a.imag)))
3845     return real + S.ImaginaryUnit*imag
3846 
3847 converter[complex] = sympify_complex
3848 
3849 from .power import Pow, integer_nthroot
3850 from .mul import Mul
3851 Mul.identity = One()
3852 from .add import Add
3853 Add.identity = Zero()
3854 
3855 def _register_classes():
3856     numbers.Number.register(Number)
3857     numbers.Real.register(Float)
3858     numbers.Rational.register(Rational)
3859     numbers.Rational.register(Integer)
3860 
3861 _register_classes()

</code><intended_behavior>The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result.</intended_behavior>]
2025-10-18 08:37:07.233 | INFO     | Search completed. Bug locations: [<file>sympy/core/evalf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Adaptive numerical evaluation of SymPy expressions, using mpmath
3 for mathematical functions.
4 """
5 from __future__ import print_function, division
6 
7 import math
8 
9 import mpmath.libmp as libmp
10 from mpmath import (
11     make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec)
12 from mpmath import inf as mpmath_inf
13 from mpmath.libmp import (from_int, from_man_exp, from_rational, fhalf,
14         fnan, fnone, fone, fzero, mpf_abs, mpf_add,
15         mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt,
16         mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin,
17         mpf_sqrt, normalize, round_nearest, to_int, to_str)
18 from mpmath.libmp import bitcount as mpmath_bitcount
19 from mpmath.libmp.backend import MPZ
20 from mpmath.libmp.libmpc import _infs_nan
21 from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps
22 from mpmath.libmp.gammazeta import mpf_bernoulli
23 
24 from .compatibility import SYMPY_INTS, range
25 from .sympify import sympify
26 from .singleton import S
27 
28 from sympy.utilities.iterables import is_sequence
29 
30 LG10 = math.log(10, 2)
31 rnd = round_nearest
32 
33 
34 def bitcount(n):
35     """Return smallest integer, b, such that |n|/2**b < 1.
36     """
37     return mpmath_bitcount(abs(int(n)))
38 
39 # Used in a few places as placeholder values to denote exponents and
40 # precision levels, e.g. of exact numbers. Must be careful to avoid
41 # passing these to mpmath functions or returning them in final results.
42 INF = float(mpmath_inf)
43 MINUS_INF = float(-mpmath_inf)
44 
45 # ~= 100 digits. Real men set this to INF.
46 DEFAULT_MAXPREC = 333
47 
48 
49 class PrecisionExhausted(ArithmeticError):
50     pass
51 
52 #----------------------------------------------------------------------------#
53 #                                                                            #
54 #              Helper functions for arithmetic and complex parts             #
55 #                                                                            #
56 #----------------------------------------------------------------------------#
57 
58 """
59 An mpf value tuple is a tuple of integers (sign, man, exp, bc)
60 representing a floating-point number: [1, -1][sign]*man*2**exp where
61 sign is 0 or 1 and bc should correspond to the number of bits used to
62 represent the mantissa (man) in binary notation, e.g.
63 
64 >>> from sympy.core.evalf import bitcount
65 >>> sign, man, exp, bc = 0, 5, 1, 3
66 >>> n = [1, -1][sign]*man*2**exp
67 >>> n, bitcount(man)
68 (10, 3)
69 
70 A temporary result is a tuple (re, im, re_acc, im_acc) where
71 re and im are nonzero mpf value tuples representing approximate
72 numbers, or None to denote exact zeros.
73 
74 re_acc, im_acc are integers denoting log2(e) where e is the estimated
75 relative accuracy of the respective complex part, but may be anything
76 if the corresponding complex part is None.
77 
78 """
79 
80 
81 def fastlog(x):
82     """Fast approximation of log2(x) for an mpf value tuple x.
83 
84     Notes: Calculated as exponent + width of mantissa. This is an
85     approximation for two reasons: 1) it gives the ceil(log2(abs(x)))
86     value and 2) it is too high by 1 in the case that x is an exact
87     power of 2. Although this is easy to remedy by testing to see if
88     the odd mpf mantissa is 1 (indicating that one was dealing with
89     an exact power of 2) that would decrease the speed and is not
90     necessary as this is only being used as an approximation for the
91     number of bits in x. The correct return value could be written as
92     "x[2] + (x[3] if x[1] != 1 else 0)".
93         Since mpf tuples always have an odd mantissa, no check is done
94     to see if the mantissa is a multiple of 2 (in which case the
95     result would be too large by 1).
96 
97     Examples
98     ========
99 
100     >>> from sympy import log
101     >>> from sympy.core.evalf import fastlog, bitcount
102     >>> s, m, e = 0, 5, 1
103     >>> bc = bitcount(m)
104     >>> n = [1, -1][s]*m*2**e
105     >>> n, (log(n)/log(2)).evalf(2), fastlog((s, m, e, bc))
106     (10, 3.3, 4)
107     """
108 
109     if not x or x == fzero:
110         return MINUS_INF
111     return x[2] + x[3]
112 
113 
114 def pure_complex(v, or_real=False):
115     """Return a and b if v matches a + I*b where b is not zero and
116     a and b are Numbers, else None. If `or_real` is True then 0 will
117     be returned for `b` if `v` is a real number.
118 
119     >>> from sympy.core.evalf import pure_complex
120     >>> from sympy import sqrt, I, S
121     >>> a, b, surd = S(2), S(3), sqrt(2)
122     >>> pure_complex(a)
123     >>> pure_complex(a, or_real=True)
124     (2, 0)
125     >>> pure_complex(surd)
126     >>> pure_complex(a + b*I)
127     (2, 3)
128     >>> pure_complex(I)
129     (0, 1)
130     """
131     h, t = v.as_coeff_Add()
132     if not t:
133         if or_real:
134             return h, t
135         return
136     c, i = t.as_coeff_Mul()
137     if i is S.ImaginaryUnit:
138         return h, c
139 
140 
141 def scaled_zero(mag, sign=1):
142     """Return an mpf representing a power of two with magnitude ``mag``
143     and -1 for precision. Or, if ``mag`` is a scaled_zero tuple, then just
144     remove the sign from within the list that it was initially wrapped
145     in.
146 
147     Examples
148     ========
149 
150     >>> from sympy.core.evalf import scaled_zero
151     >>> from sympy import Float
152     >>> z, p = scaled_zero(100)
153     >>> z, p
154     (([0], 1, 100, 1), -1)
155     >>> ok = scaled_zero(z)
156     >>> ok
157     (0, 1, 100, 1)
158     >>> Float(ok)
159     1.26765060022823e+30
160     >>> Float(ok, p)
161     0.e+30
162     >>> ok, p = scaled_zero(100, -1)
163     >>> Float(scaled_zero(ok), p)
164     -0.e+30
165     """
166     if type(mag) is tuple and len(mag) == 4 and iszero(mag, scaled=True):
167         return (mag[0][0],) + mag[1:]
168     elif isinstance(mag, SYMPY_INTS):
169         if sign not in [-1, 1]:
170             raise ValueError('sign must be +/-1')
171         rv, p = mpf_shift(fone, mag), -1
172         s = 0 if sign == 1 else 1
173         rv = ([s],) + rv[1:]
174         return rv, p
175     else:
176         raise ValueError('scaled zero expects int or scaled_zero tuple.')
177 
178 
179 def iszero(mpf, scaled=False):
180     if not scaled:
181         return not mpf or not mpf[1] and not mpf[-1]
182     return mpf and type(mpf[0]) is list and mpf[1] == mpf[-1] == 1
183 
184 
185 def complex_accuracy(result):
186     """
187     Returns relative accuracy of a complex number with given accuracies
188     for the real and imaginary parts. The relative accuracy is defined
189     in the complex norm sense as ||z|+|error|| / |z| where error
190     is equal to (real absolute error) + (imag absolute error)*i.
191 
192     The full expression for the (logarithmic) error can be approximated
193     easily by using the max norm to approximate the complex norm.
194 
195     In the worst case (re and im equal), this is wrong by a factor
196     sqrt(2), or by log2(sqrt(2)) = 0.5 bit.
197     """
198     re, im, re_acc, im_acc = result
199     if not im:
200         if not re:
201             return INF
202         return re_acc
203     if not re:
204         return im_acc
205     re_size = fastlog(re)
206     im_size = fastlog(im)
207     absolute_error = max(re_size - re_acc, im_size - im_acc)
208     relative_error = absolute_error - max(re_size, im_size)
209     return -relative_error
210 
211 
212 def get_abs(expr, prec, options):
213     re, im, re_acc, im_acc = evalf(expr, prec + 2, options)
214 
215     if not re:
216         re, re_acc, im, im_acc = im, im_acc, re, re_acc
217     if im:
218         if expr.is_number:
219             abs_expr, _, acc, _ = evalf(abs(N(expr, prec + 2)),
220                                         prec + 2, options)
221             return abs_expr, None, acc, None
222         else:
223             if 'subs' in options:
224                 return libmp.mpc_abs((re, im), prec), None, re_acc, None
225             return abs(expr), None, prec, None
226     elif re:
227         return mpf_abs(re), None, re_acc, None
228     else:
229         return None, None, None, None
230 
231 
232 def get_complex_part(expr, no, prec, options):
233     """no = 0 for real part, no = 1 for imaginary part"""
234     workprec = prec
235     i = 0
236     while 1:
237         res = evalf(expr, workprec, options)
238         value, accuracy = res[no::2]
239         # XXX is the last one correct? Consider re((1+I)**2).n()
240         if (not value) or accuracy >= prec or -value[2] > prec:
241             return value, None, accuracy, None
242         workprec += max(30, 2**i)
243         i += 1
244 
245 
246 def evalf_abs(expr, prec, options):
247     return get_abs(expr.args[0], prec, options)
248 
249 
250 def evalf_re(expr, prec, options):
251     return get_complex_part(expr.args[0], 0, prec, options)
252 
253 
254 def evalf_im(expr, prec, options):
255     return get_complex_part(expr.args[0], 1, prec, options)
256 
257 
258 def finalize_complex(re, im, prec):
259     if re == fzero and im == fzero:
260         raise ValueError("got complex zero with unknown accuracy")
261     elif re == fzero:
262         return None, im, None, prec
263     elif im == fzero:
264         return re, None, prec, None
265 
266     size_re = fastlog(re)
267     size_im = fastlog(im)
268     if size_re > size_im:
269         re_acc = prec
270         im_acc = prec + min(-(size_re - size_im), 0)
271     else:
272         im_acc = prec
273         re_acc = prec + min(-(size_im - size_re), 0)
274     return re, im, re_acc, im_acc
275 
276 
277 def chop_parts(value, prec):
278     """
279     Chop off tiny real or complex parts.
280     """
281     re, im, re_acc, im_acc = value
282     # Method 1: chop based on absolute value
283     if re and re not in _infs_nan and (fastlog(re) < -prec + 4):
284         re, re_acc = None, None
285     if im and im not in _infs_nan and (fastlog(im) < -prec + 4):
286         im, im_acc = None, None
287     # Method 2: chop if inaccurate and relatively small
288     if re and im:
289         delta = fastlog(re) - fastlog(im)
290         if re_acc < 2 and (delta - re_acc <= -prec + 4):
291             re, re_acc = None, None
292         if im_acc < 2 and (delta - im_acc >= prec - 4):
293             im, im_acc = None, None
294     return re, im, re_acc, im_acc
295 
296 
297 def check_target(expr, result, prec):
298     a = complex_accuracy(result)
299     if a < prec:
300         raise PrecisionExhausted("Failed to distinguish the expression: \n\n%s\n\n"
301             "from zero. Try simplifying the input, using chop=True, or providing "
302             "a higher maxn for evalf" % (expr))
303 
304 
305 def get_integer_part(expr, no, options, return_ints=False):
306     """
307     With no = 1, computes ceiling(expr)
308     With no = -1, computes floor(expr)
309 
310     Note: this function either gives the exact result or signals failure.
311     """
312     from sympy.functions.elementary.complexes import re, im
313     # The expression is likely less than 2^30 or so
314     assumed_size = 30
315     ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)
316 
317     # We now know the size, so we can calculate how much extra precision
318     # (if any) is needed to get within the nearest integer
319     if ire and iim:
320         gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)
321     elif ire:
322         gap = fastlog(ire) - ire_acc
323     elif iim:
324         gap = fastlog(iim) - iim_acc
325     else:
326         # ... or maybe the expression was exactly zero
327         return None, None, None, None
328 
329     margin = 10
330 
331     if gap >= -margin:
332         prec = margin + assumed_size + gap
333         ire, iim, ire_acc, iim_acc = evalf(
334             expr, prec, options)
335     else:
336         prec = assumed_size
337 
338     # We can now easily find the nearest integer, but to find floor/ceil, we
339     # must also calculate whether the difference to the nearest integer is
340     # positive or negative (which may fail if very close).
341     def calc_part(re_im, nexpr):
342         from sympy.core.add import Add
343         n, c, p, b = nexpr
344         is_int = (p == 0)
345         nint = int(to_int(nexpr, rnd))
346         if is_int:
347             # make sure that we had enough precision to distinguish
348             # between nint and the re or im part (re_im) of expr that
349             # was passed to calc_part
350             ire, iim, ire_acc, iim_acc = evalf(
351                 re_im - nint, 10, options)  # don't need much precision
352             assert not iim
353             size = -fastlog(ire) + 2  # -ve b/c ire is less than 1
354             if size > prec:
355                 ire, iim, ire_acc, iim_acc = evalf(
356                     re_im, size, options)
357                 assert not iim
358                 nexpr = ire
359                 n, c, p, b = nexpr
360                 is_int = (p == 0)
361                 nint = int(to_int(nexpr, rnd))
362         if not is_int:
363             # if there are subs and they all contain integer re/im parts
364             # then we can (hopefully) safely substitute them into the
365             # expression
366             s = options.get('subs', False)
367             if s:
368                 doit = True
369                 from sympy.core.compatibility import as_int
370                 # use strict=False with as_int because we take
371                 # 2.0 == 2
372                 for v in s.values():
373                     try:
374                         as_int(v, strict=False)
375                     except ValueError:
376                         try:
377                             [as_int(i, strict=False) for i in v.as_real_imag()]
378                             continue
379                         except (ValueError, AttributeError):
380                             doit = False
381                             break
382                 if doit:
383                     re_im = re_im.subs(s)
384 
385             re_im = Add(re_im, -nint, evaluate=False)
386             x, _, x_acc, _ = evalf(re_im, 10, options)
387             try:
388                 check_target(re_im, (x, None, x_acc, None), 3)
389             except PrecisionExhausted:
390                 if not re_im.equals(0):
391                     raise PrecisionExhausted
392                 x = fzero
393             nint += int(no*(mpf_cmp(x or fzero, fzero) == no))
394         nint = from_int(nint)
395         return nint, INF
396 
397     re_, im_, re_acc, im_acc = None, None, None, None
398 
399     if ire:
400         re_, re_acc = calc_part(re(expr, evaluate=False), ire)
401     if iim:
402         im_, im_acc = calc_part(im(expr, evaluate=False), iim)
403 
404     if return_ints:
405         return int(to_int(re_ or fzero)), int(to_int(im_ or fzero))
406     return re_, im_, re_acc, im_acc
407 
408 
409 def evalf_ceiling(expr, prec, options):
410     return get_integer_part(expr.args[0], 1, options)
411 
412 
413 def evalf_floor(expr, prec, options):
414     return get_integer_part(expr.args[0], -1, options)
415 
416 #----------------------------------------------------------------------------#
417 #                                                                            #
418 #                            Arithmetic operations                           #
419 #                                                                            #
420 #----------------------------------------------------------------------------#
421 
422 
423 def add_terms(terms, prec, target_prec):
424     """
425     Helper for evalf_add. Adds a list of (mpfval, accuracy) terms.
426 
427     Returns
428     -------
429 
430     - None, None if there are no non-zero terms;
431     - terms[0] if there is only 1 term;
432     - scaled_zero if the sum of the terms produces a zero by cancellation
433       e.g. mpfs representing 1 and -1 would produce a scaled zero which need
434       special handling since they are not actually zero and they are purposely
435       malformed to ensure that they can't be used in anything but accuracy
436       calculations;
437     - a tuple that is scaled to target_prec that corresponds to the
438       sum of the terms.
439 
440     The returned mpf tuple will be normalized to target_prec; the input
441     prec is used to define the working precision.
442 
443     XXX explain why this is needed and why one can't just loop using mpf_add
444     """
445 
446     terms = [t for t in terms if not iszero(t[0])]
447     if not terms:
448         return None, None
449     elif len(terms) == 1:
450         return terms[0]
451 
452     # see if any argument is NaN or oo and thus warrants a special return
453     special = []
454     from sympy.core.numbers import Float
455     for t in terms:
456         arg = Float._new(t[0], 1)
457         if arg is S.NaN or arg.is_infinite:
458             special.append(arg)
459     if special:
460         from sympy.core.add import Add
461         rv = evalf(Add(*special), prec + 4, {})
462         return rv[0], rv[2]
463 
464     working_prec = 2*prec
465     sum_man, sum_exp, absolute_error = 0, 0, MINUS_INF
466 
467     for x, accuracy in terms:
468         sign, man, exp, bc = x
469         if sign:
470             man = -man
471         absolute_error = max(absolute_error, bc + exp - accuracy)
472         delta = exp - sum_exp
473         if exp >= sum_exp:
474             # x much larger than existing sum?
475             # first: quick test
476             if ((delta > working_prec) and
477                 ((not sum_man) or
478                  delta - bitcount(abs(sum_man)) > working_prec)):
479                 sum_man = man
480                 sum_exp = exp
481             else:
482                 sum_man += (man << delta)
483         else:
484             delta = -delta
485             # x much smaller than existing sum?
486             if delta - bc > working_prec:
487                 if not sum_man:
488                     sum_man, sum_exp = man, exp
489             else:
490                 sum_man = (sum_man << delta) + man
491                 sum_exp = exp
492     if not sum_man:
493         return scaled_zero(absolute_error)
494     if sum_man < 0:
495         sum_sign = 1
496         sum_man = -sum_man
497     else:
498         sum_sign = 0
499     sum_bc = bitcount(sum_man)
500     sum_accuracy = sum_exp + sum_bc - absolute_error
501     r = normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec,
502         rnd), sum_accuracy
503     return r
504 
505 
506 def evalf_add(v, prec, options):
507     res = pure_complex(v)
508     if res:
509         h, c = res
510         re, _, re_acc, _ = evalf(h, prec, options)
511         im, _, im_acc, _ = evalf(c, prec, options)
512         return re, im, re_acc, im_acc
513 
514     oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
515 
516     i = 0
517     target_prec = prec
518     while 1:
519         options['maxprec'] = min(oldmaxprec, 2*prec)
520 
521         terms = [evalf(arg, prec + 10, options) for arg in v.args]
522         re, re_acc = add_terms(
523             [a[0::2] for a in terms if a[0]], prec, target_prec)
524         im, im_acc = add_terms(
525             [a[1::2] for a in terms if a[1]], prec, target_prec)
526         acc = complex_accuracy((re, im, re_acc, im_acc))
527         if acc >= target_prec:
528             if options.get('verbose'):
529                 print("ADD: wanted", target_prec, "accurate bits, got", re_acc, im_acc)
530             break
531         else:
532             if (prec - target_prec) > options['maxprec']:
533                 break
534 
535             prec = prec + max(10 + 2**i, target_prec - acc)
536             i += 1
537             if options.get('verbose'):
538                 print("ADD: restarting with prec", prec)
539 
540     options['maxprec'] = oldmaxprec
541     if iszero(re, scaled=True):
542         re = scaled_zero(re)
543     if iszero(im, scaled=True):
544         im = scaled_zero(im)
545     return re, im, re_acc, im_acc
546 
547 
548 def evalf_mul(v, prec, options):
549     res = pure_complex(v)
550     if res:
551         # the only pure complex that is a mul is h*I
552         _, h = res
553         im, _, im_acc, _ = evalf(h, prec, options)
554         return None, im, None, im_acc
555     args = list(v.args)
556 
557     # see if any argument is NaN or oo and thus warrants a special return
558     special = []
559     from sympy.core.numbers import Float
560     for arg in args:
561         arg = evalf(arg, prec, options)
562         if arg[0] is None:
563             continue
564         arg = Float._new(arg[0], 1)
565         if arg is S.NaN or arg.is_infinite:
566             special.append(arg)
567     if special:
568         from sympy.core.mul import Mul
569         special = Mul(*special)
570         return evalf(special, prec + 4, {})
571 
572     # With guard digits, multiplication in the real case does not destroy
573     # accuracy. This is also true in the complex case when considering the
574     # total accuracy; however accuracy for the real or imaginary parts
575     # separately may be lower.
576     acc = prec
577 
578     # XXX: big overestimate
579     working_prec = prec + len(args) + 5
580 
581     # Empty product is 1
582     start = man, exp, bc = MPZ(1), 0, 1
583 
584     # First, we multiply all pure real or pure imaginary numbers.
585     # direction tells us that the result should be multiplied by
586     # I**direction; all other numbers get put into complex_factors
587     # to be multiplied out after the first phase.
588     last = len(args)
589     direction = 0
590     args.append(S.One)
591     complex_factors = []
592 
593     for i, arg in enumerate(args):
594         if i != last and pure_complex(arg):
595             args[-1] = (args[-1]*arg).expand()
596             continue
597         elif i == last and arg is S.One:
598             continue
599         re, im, re_acc, im_acc = evalf(arg, working_prec, options)
600         if re and im:
601             complex_factors.append((re, im, re_acc, im_acc))
602             continue
603         elif re:
604             (s, m, e, b), w_acc = re, re_acc
605         elif im:
606             (s, m, e, b), w_acc = im, im_acc
607             direction += 1
608         else:
609             return None, None, None, None
610         direction += 2*s
611         man *= m
612         exp += e
613         bc += b
614         if bc > 3*working_prec:
615             man >>= working_prec
616             exp += working_prec
617         acc = min(acc, w_acc)
618     sign = (direction & 2) >> 1
619     if not complex_factors:
620         v = normalize(sign, man, exp, bitcount(man), prec, rnd)
621         # multiply by i
622         if direction & 1:
623             return None, v, None, acc
624         else:
625             return v, None, acc, None
626     else:
627         # initialize with the first term
628         if (man, exp, bc) != start:
629             # there was a real part; give it an imaginary part
630             re, im = (sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0)
631             i0 = 0
632         else:
633             # there is no real part to start (other than the starting 1)
634             wre, wim, wre_acc, wim_acc = complex_factors[0]
635             acc = min(acc,
636                       complex_accuracy((wre, wim, wre_acc, wim_acc)))
637             re = wre
638             im = wim
639             i0 = 1
640 
641         for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:
642             # acc is the overall accuracy of the product; we aren't
643             # computing exact accuracies of the product.
644             acc = min(acc,
645                       complex_accuracy((wre, wim, wre_acc, wim_acc)))
646 
647             use_prec = working_prec
648             A = mpf_mul(re, wre, use_prec)
649             B = mpf_mul(mpf_neg(im), wim, use_prec)
650             C = mpf_mul(re, wim, use_prec)
651             D = mpf_mul(im, wre, use_prec)
652             re = mpf_add(A, B, use_prec)
653             im = mpf_add(C, D, use_prec)
654         if options.get('verbose'):
655             print("MUL: wanted", prec, "accurate bits, got", acc)
656         # multiply by I
657         if direction & 1:
658             re, im = mpf_neg(im), re
659         return re, im, acc, acc
660 
661 
662 def evalf_pow(v, prec, options):
663 
664     target_prec = prec
665     base, exp = v.args
666 
667     # We handle x**n separately. This has two purposes: 1) it is much
668     # faster, because we avoid calling evalf on the exponent, and 2) it
669     # allows better handling of real/imaginary parts that are exactly zero
670     if exp.is_Integer:
671         p = exp.p
672         # Exact
673         if not p:
674             return fone, None, prec, None
675         # Exponentiation by p magnifies relative error by |p|, so the
676         # base must be evaluated with increased precision if p is large
677         prec += int(math.log(abs(p), 2))
678         re, im, re_acc, im_acc = evalf(base, prec + 5, options)
679         # Real to integer power
680         if re and not im:
681             return mpf_pow_int(re, p, target_prec), None, target_prec, None
682         # (x*I)**n = I**n * x**n
683         if im and not re:
684             z = mpf_pow_int(im, p, target_prec)
685             case = p % 4
686             if case == 0:
687                 return z, None, target_prec, None
688             if case == 1:
689                 return None, z, None, target_prec
690             if case == 2:
691                 return mpf_neg(z), None, target_prec, None
692             if case == 3:
693                 return None, mpf_neg(z), None, target_prec
694         # Zero raised to an integer power
695         if not re:
696             return None, None, None, None
697         # General complex number to arbitrary integer power
698         re, im = libmp.mpc_pow_int((re, im), p, prec)
699         # Assumes full accuracy in input
700         return finalize_complex(re, im, target_prec)
701 
702     # Pure square root
703     if exp is S.Half:
704         xre, xim, _, _ = evalf(base, prec + 5, options)
705         # General complex square root
706         if xim:
707             re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)
708             return finalize_complex(re, im, prec)
709         if not xre:
710             return None, None, None, None
711         # Square root of a negative real number
712         if mpf_lt(xre, fzero):
713             return None, mpf_sqrt(mpf_neg(xre), prec), None, prec
714         # Positive square root
715         return mpf_sqrt(xre, prec), None, prec, None
716 
717     # We first evaluate the exponent to find its magnitude
718     # This determines the working precision that must be used
719     prec += 10
720     yre, yim, _, _ = evalf(exp, prec, options)
721     # Special cases: x**0
722     if not (yre or yim):
723         return fone, None, prec, None
724 
725     ysize = fastlog(yre)
726     # Restart if too big
727     # XXX: prec + ysize might exceed maxprec
728     if ysize > 5:
729         prec += ysize
730         yre, yim, _, _ = evalf(exp, prec, options)
731 
732     # Pure exponential function; no need to evalf the base
733     if base is S.Exp1:
734         if yim:
735             re, im = libmp.mpc_exp((yre or fzero, yim), prec)
736             return finalize_complex(re, im, target_prec)
737         return mpf_exp(yre, target_prec), None, target_prec, None
738 
739     xre, xim, _, _ = evalf(base, prec + 5, options)
740     # 0**y
741     if not (xre or xim):
742         return None, None, None, None
743 
744     # (real ** complex) or (complex ** complex)
745     if yim:
746         re, im = libmp.mpc_pow(
747             (xre or fzero, xim or fzero), (yre or fzero, yim),
748             target_prec)
749         return finalize_complex(re, im, target_prec)
750     # complex ** real
751     if xim:
752         re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)
753         return finalize_complex(re, im, target_prec)
754     # negative ** real
755     elif mpf_lt(xre, fzero):
756         re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)
757         return finalize_complex(re, im, target_prec)
758     # positive ** real
759     else:
760         return mpf_pow(xre, yre, target_prec), None, target_prec, None
761 
762 
763 #----------------------------------------------------------------------------#
764 #                                                                            #
765 #                            Special functions                               #
766 #                                                                            #
767 #----------------------------------------------------------------------------#
768 def evalf_trig(v, prec, options):
769     """
770     This function handles sin and cos of complex arguments.
771 
772     TODO: should also handle tan of complex arguments.
773     """
774     from sympy import cos, sin
775     if isinstance(v, cos):
776         func = mpf_cos
777     elif isinstance(v, sin):
778         func = mpf_sin
779     else:
780         raise NotImplementedError
781     arg = v.args[0]
782     # 20 extra bits is possibly overkill. It does make the need
783     # to restart very unlikely
784     xprec = prec + 20
785     re, im, re_acc, im_acc = evalf(arg, xprec, options)
786     if im:
787         if 'subs' in options:
788             v = v.subs(options['subs'])
789         return evalf(v._eval_evalf(prec), prec, options)
790     if not re:
791         if isinstance(v, cos):
792             return fone, None, prec, None
793         elif isinstance(v, sin):
794             return None, None, None, None
795         else:
796             raise NotImplementedError
797     # For trigonometric functions, we are interested in the
798     # fixed-point (absolute) accuracy of the argument.
799     xsize = fastlog(re)
800     # Magnitude <= 1.0. OK to compute directly, because there is no
801     # danger of hitting the first root of cos (with sin, magnitude
802     # <= 2.0 would actually be ok)
803     if xsize < 1:
804         return func(re, prec, rnd), None, prec, None
805     # Very large
806     if xsize >= 10:
807         xprec = prec + xsize
808         re, im, re_acc, im_acc = evalf(arg, xprec, options)
809     # Need to repeat in case the argument is very close to a
810     # multiple of pi (or pi/2), hitting close to a root
811     while 1:
812         y = func(re, prec, rnd)
813         ysize = fastlog(y)
814         gap = -ysize
815         accuracy = (xprec - xsize) - gap
816         if accuracy < prec:
817             if options.get('verbose'):
818                 print("SIN/COS", accuracy, "wanted", prec, "gap", gap)
819                 print(to_str(y, 10))
820             if xprec > options.get('maxprec', DEFAULT_MAXPREC):
821                 return y, None, accuracy, None
822             xprec += gap
823             re, im, re_acc, im_acc = evalf(arg, xprec, options)
824             continue
825         else:
826             return y, None, prec, None
827 
828 
829 def evalf_log(expr, prec, options):
830     from sympy import Abs, Add, log
831     if len(expr.args)>1:
832         expr = expr.doit()
833         return evalf(expr, prec, options)
834     arg = expr.args[0]
835     workprec = prec + 10
836     xre, xim, xacc, _ = evalf(arg, workprec, options)
837 
838     if xim:
839         # XXX: use get_abs etc instead
840         re = evalf_log(
841             log(Abs(arg, evaluate=False), evaluate=False), prec, options)
842         im = mpf_atan2(xim, xre or fzero, prec)
843         return re[0], im, re[2], prec
844 
845     imaginary_term = (mpf_cmp(xre, fzero) < 0)
846 
847     re = mpf_log(mpf_abs(xre), prec, rnd)
848     size = fastlog(re)
849     if prec - size > workprec and re != fzero:
850         # We actually need to compute 1+x accurately, not x
851         arg = Add(S.NegativeOne, arg, evaluate=False)
852         xre, xim, _, _ = evalf_add(arg, prec, options)
853         prec2 = workprec - fastlog(xre)
854         # xre is now x - 1 so we add 1 back here to calculate x
855         re = mpf_log(mpf_abs(mpf_add(xre, fone, prec2)), prec, rnd)
856 
857     re_acc = prec
858 
859     if imaginary_term:
860         return re, mpf_pi(prec), re_acc, prec
861     else:
862         return re, None, re_acc, None
863 
864 
865 def evalf_atan(v, prec, options):
866     arg = v.args[0]
867     xre, xim, reacc, imacc = evalf(arg, prec + 5, options)
868     if xre is xim is None:
869         return (None,)*4
870     if xim:
871         raise NotImplementedError
872     return mpf_atan(xre, prec, rnd), None, prec, None
873 
874 
875 def evalf_subs(prec, subs):
876     """ Change all Float entries in `subs` to have precision prec. """
877     newsubs = {}
878     for a, b in subs.items():
879         b = S(b)
880         if b.is_Float:
881             b = b._eval_evalf(prec)
882         newsubs[a] = b
883     return newsubs
884 
885 
886 def evalf_piecewise(expr, prec, options):
887     from sympy import Float, Integer
888     if 'subs' in options:
889         expr = expr.subs(evalf_subs(prec, options['subs']))
890         newopts = options.copy()
891         del newopts['subs']
892         if hasattr(expr, 'func'):
893             return evalf(expr, prec, newopts)
894         if type(expr) == float:
895             return evalf(Float(expr), prec, newopts)
896         if type(expr) == int:
897             return evalf(Integer(expr), prec, newopts)
898 
899     # We still have undefined symbols
900     raise NotImplementedError
901 
902 
903 def evalf_bernoulli(expr, prec, options):
904     arg = expr.args[0]
905     if not arg.is_Integer:
906         raise ValueError("Bernoulli number index must be an integer")
907     n = int(arg)
908     b = mpf_bernoulli(n, prec, rnd)
909     if b == fzero:
910         return None, None, None, None
911     return b, None, prec, None
912 
913 #----------------------------------------------------------------------------#
914 #                                                                            #
915 #                            High-level operations                           #
916 #                                                                            #
917 #----------------------------------------------------------------------------#
918 
919 
920 def as_mpmath(x, prec, options):
921     from sympy.core.numbers import Infinity, NegativeInfinity, Zero
922     x = sympify(x)
923     if isinstance(x, Zero) or x == 0:
924         return mpf(0)
925     if isinstance(x, Infinity):
926         return mpf('inf')
927     if isinstance(x, NegativeInfinity):
928         return mpf('-inf')
929     # XXX
930     re, im, _, _ = evalf(x, prec, options)
931     if im:
932         return mpc(re or fzero, im)
933     return mpf(re)
934 
935 
936 def do_integral(expr, prec, options):
937     func = expr.args[0]
938     x, xlow, xhigh = expr.args[1]
939     if xlow == xhigh:
940         xlow = xhigh = 0
941     elif x not in func.free_symbols:
942         # only the difference in limits matters in this case
943         # so if there is a symbol in common that will cancel
944         # out when taking the difference, then use that
945         # difference
946         if xhigh.free_symbols & xlow.free_symbols:
947             diff = xhigh - xlow
948             if diff.is_number:
949                 xlow, xhigh = 0, diff
950 
951     oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)
952     options['maxprec'] = min(oldmaxprec, 2*prec)
953 
954     with workprec(prec + 5):
955         xlow = as_mpmath(xlow, prec + 15, options)
956         xhigh = as_mpmath(xhigh, prec + 15, options)
957 
958         # Integration is like summation, and we can phone home from
959         # the integrand function to update accuracy summation style
960         # Note that this accuracy is inaccurate, since it fails
961         # to account for the variable quadrature weights,
962         # but it is better than nothing
963 
964         from sympy import cos, sin, Wild
965 
966         have_part = [False, False]
967         max_real_term = [MINUS_INF]
968         max_imag_term = [MINUS_INF]
969 
970         def f(t):
971             re, im, re_acc, im_acc = evalf(func, mp.prec, {'subs': {x: t}})
972 
973             have_part[0] = re or have_part[0]
974             have_part[1] = im or have_part[1]
975 
976             max_real_term[0] = max(max_real_term[0], fastlog(re))
977             max_imag_term[0] = max(max_imag_term[0], fastlog(im))
978 
979             if im:
980                 return mpc(re or fzero, im)
981             return mpf(re or fzero)
982 
983         if options.get('quad') == 'osc':
984             A = Wild('A', exclude=[x])
985             B = Wild('B', exclude=[x])
986             D = Wild('D')
987             m = func.match(cos(A*x + B)*D)
988             if not m:
989                 m = func.match(sin(A*x + B)*D)
990             if not m:
991                 raise ValueError("An integrand of the form sin(A*x+B)*f(x) "
992                   "or cos(A*x+B)*f(x) is required for oscillatory quadrature")
993             period = as_mpmath(2*S.Pi/m[A], prec + 15, options)
994             result = quadosc(f, [xlow, xhigh], period=period)
995             # XXX: quadosc does not do error detection yet
996             quadrature_error = MINUS_INF
997         else:
998             result, quadrature_error = quadts(f, [xlow, xhigh], error=1)
999             quadrature_error = fastlog(quadrature_error._mpf_)
1000 
1001     options['maxprec'] = oldmaxprec
1002 
1003     if have_part[0]:
1004         re = result.real._mpf_
1005         if re == fzero:
1006             re, re_acc = scaled_zero(
1007                 min(-prec, -max_real_term[0], -quadrature_error))
1008             re = scaled_zero(re)  # handled ok in evalf_integral
1009         else:
1010             re_acc = -max(max_real_term[0] - fastlog(re) -
1011                           prec, quadrature_error)
1012     else:
1013         re, re_acc = None, None
1014 
1015     if have_part[1]:
1016         im = result.imag._mpf_
1017         if im == fzero:
1018             im, im_acc = scaled_zero(
1019                 min(-prec, -max_imag_term[0], -quadrature_error))
1020             im = scaled_zero(im)  # handled ok in evalf_integral
1021         else:
1022             im_acc = -max(max_imag_term[0] - fastlog(im) -
1023                           prec, quadrature_error)
1024     else:
1025         im, im_acc = None, None
1026 
1027     result = re, im, re_acc, im_acc
1028     return result
1029 
1030 
1031 def evalf_integral(expr, prec, options):
1032     limits = expr.limits
1033     if len(limits) != 1 or len(limits[0]) != 3:
1034         raise NotImplementedError
1035     workprec = prec
1036     i = 0
1037     maxprec = options.get('maxprec', INF)
1038     while 1:
1039         result = do_integral(expr, workprec, options)
1040         accuracy = complex_accuracy(result)
1041         if accuracy >= prec:  # achieved desired precision
1042             break
1043         if workprec >= maxprec:  # can't increase accuracy any more
1044             break
1045         if accuracy == -1:
1046             # maybe the answer really is zero and maybe we just haven't increased
1047             # the precision enough. So increase by doubling to not take too long
1048             # to get to maxprec.
1049             workprec *= 2
1050         else:
1051             workprec += max(prec, 2**i)
1052         workprec = min(workprec, maxprec)
1053         i += 1
1054     return result
1055 
1056 
1057 def check_convergence(numer, denom, n):
1058     """
1059     Returns (h, g, p) where
1060     -- h is:
1061         > 0 for convergence of rate 1/factorial(n)**h
1062         < 0 for divergence of rate factorial(n)**(-h)
1063         = 0 for geometric or polynomial convergence or divergence
1064 
1065     -- abs(g) is:
1066         > 1 for geometric convergence of rate 1/h**n
1067         < 1 for geometric divergence of rate h**n
1068         = 1 for polynomial convergence or divergence
1069 
1070         (g < 0 indicates an alternating series)
1071 
1072     -- p is:
1073         > 1 for polynomial convergence of rate 1/n**h
1074         <= 1 for polynomial divergence of rate n**(-h)
1075 
1076     """
1077     from sympy import Poly
1078     npol = Poly(numer, n)
1079     dpol = Poly(denom, n)
1080     p = npol.degree()
1081     q = dpol.degree()
1082     rate = q - p
1083     if rate:
1084         return rate, None, None
1085     constant = dpol.LC() / npol.LC()
1086     if abs(constant) != 1:
1087         return rate, constant, None
1088     if npol.degree() == dpol.degree() == 0:
1089         return rate, constant, 0
1090     pc = npol.all_coeffs()[1]
1091     qc = dpol.all_coeffs()[1]
1092     return rate, constant, (qc - pc)/dpol.LC()
1093 
1094 
1095 def hypsum(expr, n, start, prec):
1096     """
1097     Sum a rapidly convergent infinite hypergeometric series with
1098     given general term, e.g. e = hypsum(1/factorial(n), n). The
1099     quotient between successive terms must be a quotient of integer
1100     polynomials.
1101     """
1102     from sympy import Float, hypersimp, lambdify
1103 
1104     if prec == float('inf'):
1105         raise NotImplementedError('does not support inf prec')
1106 
1107     if start:
1108         expr = expr.subs(n, n + start)
1109     hs = hypersimp(expr, n)
1110     if hs is None:
1111         raise NotImplementedError("a hypergeometric series is required")
1112     num, den = hs.as_numer_denom()
1113 
1114     func1 = lambdify(n, num)
1115     func2 = lambdify(n, den)
1116 
1117     h, g, p = check_convergence(num, den, n)
1118 
1119     if h < 0:
1120         raise ValueError("Sum diverges like (n!)^%i" % (-h))
1121 
1122     term = expr.subs(n, 0)
1123     if not term.is_Rational:
1124         raise NotImplementedError("Non rational term functionality is not implemented.")
1125 
1126     # Direct summation if geometric or faster
1127     if h > 0 or (h == 0 and abs(g) > 1):
1128         term = (MPZ(term.p) << prec) // term.q
1129         s = term
1130         k = 1
1131         while abs(term) > 5:
1132             term *= MPZ(func1(k - 1))
1133             term //= MPZ(func2(k - 1))
1134             s += term
1135             k += 1
1136         return from_man_exp(s, -prec)
1137     else:
1138         alt = g < 0
1139         if abs(g) < 1:
1140             raise ValueError("Sum diverges like (%i)^n" % abs(1/g))
1141         if p < 1 or (p == 1 and not alt):
1142             raise ValueError("Sum diverges like n^%i" % (-p))
1143         # We have polynomial convergence: use Richardson extrapolation
1144         vold = None
1145         ndig = prec_to_dps(prec)
1146         while True:
1147             # Need to use at least quad precision because a lot of cancellation
1148             # might occur in the extrapolation process; we check the answer to
1149             # make sure that the desired precision has been reached, too.
1150             prec2 = 4*prec
1151             term0 = (MPZ(term.p) << prec2) // term.q
1152 
1153             def summand(k, _term=[term0]):
1154                 if k:
1155                     k = int(k)
1156                     _term[0] *= MPZ(func1(k - 1))
1157                     _term[0] //= MPZ(func2(k - 1))
1158                 return make_mpf(from_man_exp(_term[0], -prec2))
1159 
1160             with workprec(prec):
1161                 v = nsum(summand, [0, mpmath_inf], method='richardson')
1162             vf = Float(v, ndig)
1163             if vold is not None and vold == vf:
1164                 break
1165             prec += prec  # double precision each time
1166             vold = vf
1167 
1168         return v._mpf_
1169 
1170 
1171 def evalf_prod(expr, prec, options):
1172     from sympy import Sum
1173     if all((l[1] - l[2]).is_Integer for l in expr.limits):
1174         re, im, re_acc, im_acc = evalf(expr.doit(), prec=prec, options=options)
1175     else:
1176         re, im, re_acc, im_acc = evalf(expr.rewrite(Sum), prec=prec, options=options)
1177     return re, im, re_acc, im_acc
1178 
1179 
1180 def evalf_sum(expr, prec, options):
1181     from sympy import Float
1182     if 'subs' in options:
1183         expr = expr.subs(options['subs'])
1184     func = expr.function
1185     limits = expr.limits
1186     if len(limits) != 1 or len(limits[0]) != 3:
1187         raise NotImplementedError
1188     if func is S.Zero:
1189         return None, None, prec, None
1190     prec2 = prec + 10
1191     try:
1192         n, a, b = limits[0]
1193         if b != S.Infinity or a != int(a):
1194             raise NotImplementedError
1195         # Use fast hypergeometric summation if possible
1196         v = hypsum(func, n, int(a), prec2)
1197         delta = prec - fastlog(v)
1198         if fastlog(v) < -10:
1199             v = hypsum(func, n, int(a), delta)
1200         return v, None, min(prec, delta), None
1201     except NotImplementedError:
1202         # Euler-Maclaurin summation for general series
1203         eps = Float(2.0)**(-prec)
1204         for i in range(1, 5):
1205             m = n = 2**i * prec
1206             s, err = expr.euler_maclaurin(m=m, n=n, eps=eps,
1207                 eval_integral=False)
1208             err = err.evalf()
1209             if err <= eps:
1210                 break
1211         err = fastlog(evalf(abs(err), 20, options)[0])
1212         re, im, re_acc, im_acc = evalf(s, prec2, options)
1213         if re_acc is None:
1214             re_acc = -err
1215         if im_acc is None:
1216             im_acc = -err
1217         return re, im, re_acc, im_acc
1218 
1219 
1220 #----------------------------------------------------------------------------#
1221 #                                                                            #
1222 #                            Symbolic interface                              #
1223 #                                                                            #
1224 #----------------------------------------------------------------------------#
1225 
1226 def evalf_symbol(x, prec, options):
1227     val = options['subs'][x]
1228     if isinstance(val, mpf):
1229         if not val:
1230             return None, None, None, None
1231         return val._mpf_, None, prec, None
1232     else:
1233         if not '_cache' in options:
1234             options['_cache'] = {}
1235         cache = options['_cache']
1236         cached, cached_prec = cache.get(x, (None, MINUS_INF))
1237         if cached_prec >= prec:
1238             return cached
1239         v = evalf(sympify(val), prec, options)
1240         cache[x] = (v, prec)
1241         return v
1242 
1243 evalf_table = None
1244 
1245 
1246 def _create_evalf_table():
1247     global evalf_table
1248     from sympy.functions.combinatorial.numbers import bernoulli
1249     from sympy.concrete.products import Product
1250     from sympy.concrete.summations import Sum
1251     from sympy.core.add import Add
1252     from sympy.core.mul import Mul
1253     from sympy.core.numbers import Exp1, Float, Half, ImaginaryUnit, Integer, NaN, NegativeOne, One, Pi, Rational, Zero
1254     from sympy.core.power import Pow
1255     from sympy.core.symbol import Dummy, Symbol
1256     from sympy.functions.elementary.complexes import Abs, im, re
1257     from sympy.functions.elementary.exponential import exp, log
1258     from sympy.functions.elementary.integers import ceiling, floor
1259     from sympy.functions.elementary.piecewise import Piecewise
1260     from sympy.functions.elementary.trigonometric import atan, cos, sin
1261     from sympy.integrals.integrals import Integral
1262     evalf_table = {
1263         Symbol: evalf_symbol,
1264         Dummy: evalf_symbol,
1265         Float: lambda x, prec, options: (x._mpf_, None, prec, None),
1266         Rational: lambda x, prec, options: (from_rational(x.p, x.q, prec), None, prec, None),
1267         Integer: lambda x, prec, options: (from_int(x.p, prec), None, prec, None),
1268         Zero: lambda x, prec, options: (None, None, prec, None),
1269         One: lambda x, prec, options: (fone, None, prec, None),
1270         Half: lambda x, prec, options: (fhalf, None, prec, None),
1271         Pi: lambda x, prec, options: (mpf_pi(prec), None, prec, None),
1272         Exp1: lambda x, prec, options: (mpf_e(prec), None, prec, None),
1273         ImaginaryUnit: lambda x, prec, options: (None, fone, None, prec),
1274         NegativeOne: lambda x, prec, options: (fnone, None, prec, None),
1275         NaN: lambda x, prec, options: (fnan, None, prec, None),
1276 
1277         exp: lambda x, prec, options: evalf_pow(
1278             Pow(S.Exp1, x.args[0], evaluate=False), prec, options),
1279 
1280         cos: evalf_trig,
1281         sin: evalf_trig,
1282 
1283         Add: evalf_add,
1284         Mul: evalf_mul,
1285         Pow: evalf_pow,
1286 
1287         log: evalf_log,
1288         atan: evalf_atan,
1289         Abs: evalf_abs,
1290 
1291         re: evalf_re,
1292         im: evalf_im,
1293         floor: evalf_floor,
1294         ceiling: evalf_ceiling,
1295 
1296         Integral: evalf_integral,
1297         Sum: evalf_sum,
1298         Product: evalf_prod,
1299         Piecewise: evalf_piecewise,
1300 
1301         bernoulli: evalf_bernoulli,
1302     }
1303 
1304 
1305 def evalf(x, prec, options):
1306     from sympy import re as re_, im as im_
1307     try:
1308         rf = evalf_table[x.func]
1309         r = rf(x, prec, options)
1310     except KeyError:
1311         # Fall back to ordinary evalf if possible
1312         if 'subs' in options:
1313             x = x.subs(evalf_subs(prec, options['subs']))
1314         xe = x._eval_evalf(prec)
1315         if xe is None:
1316             raise NotImplementedError
1317         as_real_imag = getattr(xe, "as_real_imag", None)
1318         if as_real_imag is None:
1319             raise NotImplementedError # e.g. FiniteSet(-1.0, 1.0).evalf()
1320         re, im = as_real_imag()
1321         if re.has(re_) or im.has(im_):
1322             raise NotImplementedError
1323         if re == 0:
1324             re = None
1325             reprec = None
1326         elif re.is_number:
1327             re = re._to_mpmath(prec, allow_ints=False)._mpf_
1328             reprec = prec
1329         else:
1330             raise NotImplementedError
1331         if im == 0:
1332             im = None
1333             imprec = None
1334         elif im.is_number:
1335             im = im._to_mpmath(prec, allow_ints=False)._mpf_
1336             imprec = prec
1337         else:
1338             raise NotImplementedError
1339         r = re, im, reprec, imprec
1340 
1341     if options.get("verbose"):
1342         print("### input", x)
1343         print("### output", to_str(r[0] or fzero, 50))
1344         print("### raw", r) # r[0], r[2]
1345         print()
1346     chop = options.get('chop', False)
1347     if chop:
1348         if chop is True:
1349             chop_prec = prec
1350         else:
1351             # convert (approximately) from given tolerance;
1352             # the formula here will will make 1e-i rounds to 0 for
1353             # i in the range +/-27 while 2e-i will not be chopped
1354             chop_prec = int(round(-3.321*math.log10(chop) + 2.5))
1355             if chop_prec == 3:
1356                 chop_prec -= 1
1357         r = chop_parts(r, chop_prec)
1358     if options.get("strict"):
1359         check_target(x, r, prec)
1360     return r
1361 
1362 
1363 class EvalfMixin(object):
1364     """Mixin class adding evalf capabililty."""
1365 
1366     __slots__ = []
1367 
1368     def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
1369         """
1370         Evaluate the given formula to an accuracy of n digits.
1371         Optional keyword arguments:
1372 
1373             subs=<dict>
1374                 Substitute numerical values for symbols, e.g.
1375                 subs={x:3, y:1+pi}. The substitutions must be given as a
1376                 dictionary.
1377 
1378             maxn=<integer>
1379                 Allow a maximum temporary working precision of maxn digits
1380                 (default=100)
1381 
1382             chop=<bool>
1383                 Replace tiny real or imaginary parts in subresults
1384                 by exact zeros (default=False)
1385 
1386             strict=<bool>
1387                 Raise PrecisionExhausted if any subresult fails to evaluate
1388                 to full accuracy, given the available maxprec
1389                 (default=False)
1390 
1391             quad=<str>
1392                 Choose algorithm for numerical quadrature. By default,
1393                 tanh-sinh quadrature is used. For oscillatory
1394                 integrals on an infinite interval, try quad='osc'.
1395 
1396             verbose=<bool>
1397                 Print debug information (default=False)
1398 
1399         Notes
1400         =====
1401 
1402         When Floats are naively substituted into an expression, precision errors
1403         may adversely affect the result. For example, adding 1e16 (a Float) to 1
1404         will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.
1405         That is exactly what happens in the following:
1406 
1407         >>> from sympy.abc import x, y, z
1408         >>> values = {x: 1e16, y: 1, z: 1e16}
1409         >>> (x + y - z).subs(values)
1410         0
1411 
1412         Using the subs argument for evalf is the accurate way to evaluate such an
1413         expression:
1414 
1415         >>> (x + y - z).evalf(subs=values)
1416         1.00000000000000
1417         """
1418         from sympy import Float, Number
1419         n = n if n is not None else 15
1420 
1421         if subs and is_sequence(subs):
1422             raise TypeError('subs must be given as a dictionary')
1423 
1424         # for sake of sage that doesn't like evalf(1)
1425         if n == 1 and isinstance(self, Number):
1426             from sympy.core.expr import _mag
1427             rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)
1428             m = _mag(rv)
1429             rv = rv.round(1 - m)
1430             return rv
1431 
1432         if not evalf_table:
1433             _create_evalf_table()
1434         prec = dps_to_prec(n)
1435         options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,
1436                'strict': strict, 'verbose': verbose}
1437         if subs is not None:
1438             options['subs'] = subs
1439         if quad is not None:
1440             options['quad'] = quad
1441         try:
1442             result = evalf(self, prec + 4, options)
1443         except NotImplementedError:
1444             # Fall back to the ordinary evalf
1445             v = self._eval_evalf(prec)
1446             if v is None:
1447                 return self
1448             elif not v.is_number:
1449                 return v
1450             try:
1451                 # If the result is numerical, normalize it
1452                 result = evalf(v, prec, options)
1453             except NotImplementedError:
1454                 # Probably contains symbols or unknown functions
1455                 return v
1456         re, im, re_acc, im_acc = result
1457         if re:
1458             p = max(min(prec, re_acc), 1)
1459             re = Float._new(re, p)
1460         else:
1461             re = S.Zero
1462         if im:
1463             p = max(min(prec, im_acc), 1)
1464             im = Float._new(im, p)
1465             return re + im*S.ImaginaryUnit
1466         else:
1467             return re
1468 
1469     n = evalf
1470 
1471     def _evalf(self, prec):
1472         """Helper for evalf. Does the same thing but takes binary precision"""
1473         r = self._eval_evalf(prec)
1474         if r is None:
1475             r = self
1476         return r
1477 
1478     def _eval_evalf(self, prec):
1479         return
1480 
1481     def _to_mpmath(self, prec, allow_ints=True):
1482         # mpmath functions accept ints as input
1483         errmsg = "cannot convert to mpmath number"
1484         if allow_ints and self.is_Integer:
1485             return self.p
1486         if hasattr(self, '_as_mpf_val'):
1487             return make_mpf(self._as_mpf_val(prec))
1488         try:
1489             re, im, _, _ = evalf(self, prec, {})
1490             if im:
1491                 if not re:
1492                     re = fzero
1493                 return make_mpc((re, im))
1494             elif re:
1495                 return make_mpf(re)
1496             else:
1497                 return make_mpf(fzero)
1498         except NotImplementedError:
1499             v = self._eval_evalf(prec)
1500             if v is None:
1501                 raise ValueError(errmsg)
1502             if v.is_Float:
1503                 return make_mpf(v._mpf_)
1504             # Number + Number*I is also fine
1505             re, im = v.as_real_imag()
1506             if allow_ints and re.is_Integer:
1507                 re = from_int(re.p)
1508             elif re.is_Float:
1509                 re = re._mpf_
1510             else:
1511                 raise ValueError(errmsg)
1512             if allow_ints and im.is_Integer:
1513                 im = from_int(im.p)
1514             elif im.is_Float:
1515                 im = im._mpf_
1516             else:
1517                 raise ValueError(errmsg)
1518             return make_mpc((re, im))
1519 
1520 
1521 def N(x, n=15, **options):
1522     r"""
1523     Calls x.evalf(n, \*\*options).
1524 
1525     Both .n() and N() are equivalent to .evalf(); use the one that you like better.
1526     See also the docstring of .evalf() for information on the options.
1527 
1528     Examples
1529     ========
1530 
1531     >>> from sympy import Sum, oo, N
1532     >>> from sympy.abc import k
1533     >>> Sum(1/k**k, (k, 1, oo))
1534     Sum(k**(-k), (k, 1, oo))
1535     >>> N(_, 4)
1536     1.291
1537 
1538     """
1539     return sympify(x).evalf(n, **options)

</code><intended_behavior>The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result.</intended_behavior>, <file>sympy/core/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import absolute_import, print_function, division
2 
3 import numbers
4 import decimal
5 import fractions
6 import math
7 import re as regex
8 
9 from .containers import Tuple
10 from .sympify import converter, sympify, _sympify, SympifyError, _convert_numpy_types
11 from .singleton import S, Singleton
12 from .expr import Expr, AtomicExpr
13 from .decorators import _sympifyit
14 from .cache import cacheit, clear_cache
15 from .logic import fuzzy_not
16 from sympy.core.compatibility import (
17     as_int, integer_types, long, string_types, with_metaclass, HAS_GMPY,
18     SYMPY_INTS, int_info)
19 from sympy.core.cache import lru_cache
20 
21 import mpmath
22 import mpmath.libmp as mlib
23 from mpmath.libmp.backend import MPZ
24 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed
25 from mpmath.ctx_mp import mpnumeric
26 from mpmath.libmp.libmpf import (
27     finf as _mpf_inf, fninf as _mpf_ninf,
28     fnan as _mpf_nan, fzero as _mpf_zero, _normalize as mpf_normalize,
29     prec_to_dps)
30 from sympy.utilities.misc import debug, filldedent
31 from .evaluate import global_evaluate
32 
33 from sympy.utilities.exceptions import SymPyDeprecationWarning
34 
35 rnd = mlib.round_nearest
36 
37 _LOG2 = math.log(2)
38 
39 
40 def comp(z1, z2, tol=None):
41     """Return a bool indicating whether the error between z1 and z2 is <= tol.
42 
43     If ``tol`` is None then True will be returned if there is a significant
44     difference between the numbers: ``abs(z1 - z2)*10**p <= 1/2`` where ``p``
45     is the lower of the precisions of the values. A comparison of strings will
46     be made if ``z1`` is a Number and a) ``z2`` is a string or b) ``tol`` is ''
47     and ``z2`` is a Number.
48 
49     When ``tol`` is a nonzero value, if z2 is non-zero and ``|z1| > 1``
50     the error is normalized by ``|z1|``, so if you want to see if the
51     absolute error between ``z1`` and ``z2`` is <= ``tol`` then call this
52     as ``comp(z1 - z2, 0, tol)``.
53     """
54     if type(z2) is str:
55         if not isinstance(z1, Number):
56             raise ValueError('when z2 is a str z1 must be a Number')
57         return str(z1) == z2
58     if not z1:
59         z1, z2 = z2, z1
60     if not z1:
61         return True
62     if not tol:
63         if tol is None:
64             if type(z2) is str and getattr(z1, 'is_Number', False):
65                 return str(z1) == z2
66             a, b = Float(z1), Float(z2)
67             return int(abs(a - b)*10**prec_to_dps(
68                 min(a._prec, b._prec)))*2 <= 1
69         elif all(getattr(i, 'is_Number', False) for i in (z1, z2)):
70             return z1._prec == z2._prec and str(z1) == str(z2)
71         raise ValueError('exact comparison requires two Numbers')
72     diff = abs(z1 - z2)
73     az1 = abs(z1)
74     if z2 and az1 > 1:
75         return diff/az1 <= tol
76     else:
77         return diff <= tol
78 
79 
80 def mpf_norm(mpf, prec):
81     """Return the mpf tuple normalized appropriately for the indicated
82     precision after doing a check to see if zero should be returned or
83     not when the mantissa is 0. ``mpf_normlize`` always assumes that this
84     is zero, but it may not be since the mantissa for mpf's values "+inf",
85     "-inf" and "nan" have a mantissa of zero, too.
86 
87     Note: this is not intended to validate a given mpf tuple, so sending
88     mpf tuples that were not created by mpmath may produce bad results. This
89     is only a wrapper to ``mpf_normalize`` which provides the check for non-
90     zero mpfs that have a 0 for the mantissa.
91     """
92     sign, man, expt, bc = mpf
93     if not man:
94         # hack for mpf_normalize which does not do this;
95         # it assumes that if man is zero the result is 0
96         # (see issue 6639)
97         if not bc:
98             return _mpf_zero
99         else:
100             # don't change anything; this should already
101             # be a well formed mpf tuple
102             return mpf
103 
104     # Necessary if mpmath is using the gmpy backend
105     from mpmath.libmp.backend import MPZ
106     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
107     return rv
108 
109 # TODO: we should use the warnings module
110 _errdict = {"divide": False}
111 
112 
113 def seterr(divide=False):
114     """
115     Should sympy raise an exception on 0/0 or return a nan?
116 
117     divide == True .... raise an exception
118     divide == False ... return nan
119     """
120     if _errdict["divide"] != divide:
121         clear_cache()
122         _errdict["divide"] = divide
123 
124 
125 def _as_integer_ratio(p):
126     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)
127     p = [1, -1][neg_pow % 2]*man
128     if expt < 0:
129         q = 2**-expt
130     else:
131         q = 1
132         p *= 2**expt
133     return int(p), int(q)
134 
135 
136 def _decimal_to_Rational_prec(dec):
137     """Convert an ordinary decimal instance to a Rational."""
138     if not dec.is_finite():
139         raise TypeError("dec must be finite, got %s." % dec)
140     s, d, e = dec.as_tuple()
141     prec = len(d)
142     if e >= 0:  # it's an integer
143         rv = Integer(int(dec))
144     else:
145         s = (-1)**s
146         d = sum([di*10**i for i, di in enumerate(reversed(d))])
147         rv = Rational(s*d, 10**-e)
148     return rv, prec
149 
150 
151 _floatpat = regex.compile(r"[-+]?((\d*\.\d+)|(\d+\.?))")
152 def _literal_float(f):
153     """Return True if n starts like a floating point number."""
154     return bool(_floatpat.match(f))
155 
156 # (a,b) -> gcd(a,b)
157 
158 # TODO caching with decorator, but not to degrade performance
159 
160 @lru_cache(1024)
161 def igcd(*args):
162     """Computes nonnegative integer greatest common divisor.
163 
164     The algorithm is based on the well known Euclid's algorithm. To
165     improve speed, igcd() has its own caching mechanism implemented.
166 
167     Examples
168     ========
169 
170     >>> from sympy.core.numbers import igcd
171     >>> igcd(2, 4)
172     2
173     >>> igcd(5, 10, 15)
174     5
175 
176     """
177     if len(args) < 2:
178         raise TypeError(
179             'igcd() takes at least 2 arguments (%s given)' % len(args))
180     args_temp = [abs(as_int(i)) for i in args]
181     if 1 in args_temp:
182         return 1
183     a = args_temp.pop()
184     for b in args_temp:
185         a = igcd2(a, b) if b else a
186     return a
187 
188 
189 try:
190     from math import gcd as igcd2
191 except ImportError:
192     def igcd2(a, b):
193         """Compute gcd of two Python integers a and b."""
194         if (a.bit_length() > BIGBITS and
195             b.bit_length() > BIGBITS):
196             return igcd_lehmer(a, b)
197 
198         a, b = abs(a), abs(b)
199         while b:
200             a, b = b, a % b
201         return a
202 
203 
204 # Use Lehmer's algorithm only for very large numbers.
205 # The limit could be different on Python 2.7 and 3.x.
206 # If so, then this could be defined in compatibility.py.
207 BIGBITS = 5000
208 def igcd_lehmer(a, b):
209     """Computes greatest common divisor of two integers.
210 
211     Euclid's algorithm for the computation of the greatest
212     common divisor  gcd(a, b)  of two (positive) integers
213     a and b is based on the division identity
214         a = q*b + r,
215     where the quotient  q  and the remainder  r  are integers
216     and  0 <= r < b. Then each common divisor of  a  and  b
217     divides  r, and it follows that  gcd(a, b) == gcd(b, r).
218     The algorithm works by constructing the sequence
219     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn
220     is the remainder from the division of the two preceding
221     elements.
222 
223     In Python, q = a // b  and  r = a % b  are obtained by the
224     floor division and the remainder operations, respectively.
225     These are the most expensive arithmetic operations, especially
226     for large  a  and  b.
227 
228     Lehmer's algorithm is based on the observation that the quotients
229     qn = r(n-1) // rn  are in general small integers even
230     when  a  and  b  are very large. Hence the quotients can be
231     usually determined from a relatively small number of most
232     significant bits.
233 
234     The efficiency of the algorithm is further enhanced by not
235     computing each long remainder in Euclid's sequence. The remainders
236     are linear combinations of  a  and  b  with integer coefficients
237     derived from the quotients. The coefficients can be computed
238     as far as the quotients can be determined from the chosen
239     most significant parts of  a  and  b. Only then a new pair of
240     consecutive remainders is computed and the algorithm starts
241     anew with this pair.
242 
243     References
244     ==========
245 
246     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
247 
248     """
249     a, b = abs(as_int(a)), abs(as_int(b))
250     if a < b:
251         a, b = b, a
252 
253     # The algorithm works by using one or two digit division
254     # whenever possible. The outer loop will replace the
255     # pair (a, b) with a pair of shorter consecutive elements
256     # of the Euclidean gcd sequence until a and b
257     # fit into two Python (long) int digits.
258     nbits = 2*int_info.bits_per_digit
259 
260     while a.bit_length() > nbits and b != 0:
261         # Quotients are mostly small integers that can
262         # be determined from most significant bits.
263         n = a.bit_length() - nbits
264         x, y = int(a >> n), int(b >> n)  # most significant bits
265 
266         # Elements of the Euclidean gcd sequence are linear
267         # combinations of a and b with integer coefficients.
268         # Compute the coefficients of consecutive pairs
269         #     a' = A*a + B*b, b' = C*a + D*b
270         # using small integer arithmetic as far as possible.
271         A, B, C, D = 1, 0, 0, 1  # initial values
272 
273         while True:
274             # The coefficients alternate in sign while looping.
275             # The inner loop combines two steps to keep track
276             # of the signs.
277 
278             # At this point we have
279             #   A > 0, B <= 0, C <= 0, D > 0,
280             #   x' = x + B <= x < x" = x + A,
281             #   y' = y + C <= y < y" = y + D,
282             # and
283             #   x'*N <= a' < x"*N, y'*N <= b' < y"*N,
284             # where N = 2**n.
285 
286             # Now, if y' > 0, and x"//y' and x'//y" agree,
287             # then their common value is equal to  q = a'//b'.
288             # In addition,
289             #   x'%y" = x' - q*y" < x" - q*y' = x"%y',
290             # and
291             #   (x'%y")*N < a'%b' < (x"%y')*N.
292 
293             # On the other hand, we also have  x//y == q,
294             # and therefore
295             #   x'%y" = x + B - q*(y + D) = x%y + B',
296             #   x"%y' = x + A - q*(y + C) = x%y + A',
297             # where
298             #    B' = B - q*D < 0, A' = A - q*C > 0.
299 
300             if y + C <= 0:
301                 break
302             q = (x + A) // (y + C)
303 
304             # Now  x'//y" <= q, and equality holds if
305             #   x' - q*y" = (x - q*y) + (B - q*D) >= 0.
306             # This is a minor optimization to avoid division.
307             x_qy, B_qD = x - q*y, B - q*D
308             if x_qy + B_qD < 0:
309                 break
310 
311             # Next step in the Euclidean sequence.
312             x, y = y, x_qy
313             A, B, C, D = C, D, A - q*C, B_qD
314 
315             # At this point the signs of the coefficients
316             # change and their roles are interchanged.
317             #   A <= 0, B > 0, C > 0, D < 0,
318             #   x' = x + A <= x < x" = x + B,
319             #   y' = y + D < y < y" = y + C.
320 
321             if y + D <= 0:
322                 break
323             q = (x + B) // (y + D)
324             x_qy, A_qC = x - q*y, A - q*C
325             if x_qy + A_qC < 0:
326                 break
327 
328             x, y = y, x_qy
329             A, B, C, D = C, D, A_qC, B - q*D
330             # Now the conditions on top of the loop
331             # are again satisfied.
332             #   A > 0, B < 0, C < 0, D > 0.
333 
334         if B == 0:
335             # This can only happen when y == 0 in the beginning
336             # and the inner loop does nothing.
337             # Long division is forced.
338             a, b = b, a % b
339             continue
340 
341         # Compute new long arguments using the coefficients.
342         a, b = A*a + B*b, C*a + D*b
343 
344     # Small divisors. Finish with the standard algorithm.
345     while b:
346         a, b = b, a % b
347 
348     return a
349 
350 
351 def ilcm(*args):
352     """Computes integer least common multiple.
353 
354     Examples
355     ========
356 
357     >>> from sympy.core.numbers import ilcm
358     >>> ilcm(5, 10)
359     10
360     >>> ilcm(7, 3)
361     21
362     >>> ilcm(5, 10, 15)
363     30
364 
365     """
366     if len(args) < 2:
367         raise TypeError(
368             'ilcm() takes at least 2 arguments (%s given)' % len(args))
369     if 0 in args:
370         return 0
371     a = args[0]
372     for b in args[1:]:
373         a = a // igcd(a, b) * b # since gcd(a,b) | a
374     return a
375 
376 
377 def igcdex(a, b):
378     """Returns x, y, g such that g = x*a + y*b = gcd(a, b).
379 
380        >>> from sympy.core.numbers import igcdex
381        >>> igcdex(2, 3)
382        (-1, 1, 1)
383        >>> igcdex(10, 12)
384        (-1, 1, 2)
385 
386        >>> x, y, g = igcdex(100, 2004)
387        >>> x, y, g
388        (-20, 1, 4)
389        >>> x*100 + y*2004
390        4
391 
392     """
393     if (not a) and (not b):
394         return (0, 1, 0)
395 
396     if not a:
397         return (0, b//abs(b), abs(b))
398     if not b:
399         return (a//abs(a), 0, abs(a))
400 
401     if a < 0:
402         a, x_sign = -a, -1
403     else:
404         x_sign = 1
405 
406     if b < 0:
407         b, y_sign = -b, -1
408     else:
409         y_sign = 1
410 
411     x, y, r, s = 1, 0, 0, 1
412 
413     while b:
414         (c, q) = (a % b, a // b)
415         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)
416 
417     return (x*x_sign, y*y_sign, a)
418 
419 
420 def mod_inverse(a, m):
421     """
422     Return the number c such that, (a * c) = 1 (mod m)
423     where c has the same sign as m. If no such value exists,
424     a ValueError is raised.
425 
426     Examples
427     ========
428 
429     >>> from sympy import S
430     >>> from sympy.core.numbers import mod_inverse
431 
432     Suppose we wish to find multiplicative inverse x of
433     3 modulo 11. This is the same as finding x such
434     that 3 * x = 1 (mod 11). One value of x that satisfies
435     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).
436     This is the value return by mod_inverse:
437 
438     >>> mod_inverse(3, 11)
439     4
440     >>> mod_inverse(-3, 11)
441     7
442 
443     When there is a common factor between the numerators of
444     ``a`` and ``m`` the inverse does not exist:
445 
446     >>> mod_inverse(2, 4)
447     Traceback (most recent call last):
448     ...
449     ValueError: inverse of 2 mod 4 does not exist
450 
451     >>> mod_inverse(S(2)/7, S(5)/2)
452     7/2
453 
454     References
455     ==========
456     - https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
457     - https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
458     """
459     c = None
460     try:
461         a, m = as_int(a), as_int(m)
462         if m != 1 and m != -1:
463             x, y, g = igcdex(a, m)
464             if g == 1:
465                 c = x % m
466     except ValueError:
467         a, m = sympify(a), sympify(m)
468         if not (a.is_number and m.is_number):
469             raise TypeError(filldedent('''
470                 Expected numbers for arguments; symbolic `mod_inverse`
471                 is not implemented
472                 but symbolic expressions can be handled with the
473                 similar function,
474                 sympy.polys.polytools.invert'''))
475         big = (m > 1)
476         if not (big is S.true or big is S.false):
477             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)
478         elif big:
479             c = 1/a
480     if c is None:
481         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))
482     return c
483 
484 
485 class Number(AtomicExpr):
486     """Represents atomic numbers in SymPy.
487 
488     Floating point numbers are represented by the Float class.
489     Rational numbers (of any size) are represented by the Rational class.
490     Integer numbers (of any size) are represented by the Integer class.
491     Float and Rational are subclasses of Number; Integer is a subclass
492     of Rational.
493 
494     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is
495     a different object from the floating point number obtained with
496     Python division ``2/3``. Even for numbers that are exactly
497     represented in binary, there is a difference between how two forms,
498     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.
499     The rational form is to be preferred in symbolic computations.
500 
501     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or
502     complex numbers ``3 + 4*I``, are not instances of Number class as
503     they are not atomic.
504 
505     See Also
506     ========
507 
508     Float, Integer, Rational
509     """
510     is_commutative = True
511     is_number = True
512     is_Number = True
513 
514     __slots__ = []
515 
516     # Used to make max(x._prec, y._prec) return x._prec when only x is a float
517     _prec = -1
518 
519     def __new__(cls, *obj):
520         if len(obj) == 1:
521             obj = obj[0]
522 
523         if isinstance(obj, Number):
524             return obj
525         if isinstance(obj, SYMPY_INTS):
526             return Integer(obj)
527         if isinstance(obj, tuple) and len(obj) == 2:
528             return Rational(*obj)
529         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):
530             return Float(obj)
531         if isinstance(obj, string_types):
532             val = sympify(obj)
533             if isinstance(val, Number):
534                 return val
535             else:
536                 raise ValueError('String "%s" does not denote a Number' % obj)
537         msg = "expected str|int|long|float|Decimal|Number object but got %r"
538         raise TypeError(msg % type(obj).__name__)
539 
540     def invert(self, other, *gens, **args):
541         from sympy.polys.polytools import invert
542         if getattr(other, 'is_number', True):
543             return mod_inverse(self, other)
544         return invert(self, other, *gens, **args)
545 
546     def __divmod__(self, other):
547         from .containers import Tuple
548 
549         try:
550             other = Number(other)
551         except TypeError:
552             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
553             raise TypeError(msg % (type(self).__name__, type(other).__name__))
554         if not other:
555             raise ZeroDivisionError('modulo by zero')
556         if self.is_Integer and other.is_Integer:
557             return Tuple(*divmod(self.p, other.p))
558         else:
559             rat = self/other
560         w = int(rat) if rat > 0 else int(rat) - 1
561         r = self - other*w
562         return Tuple(w, r)
563 
564     def __rdivmod__(self, other):
565         try:
566             other = Number(other)
567         except TypeError:
568             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
569             raise TypeError(msg % (type(other).__name__, type(self).__name__))
570         return divmod(other, self)
571 
572     def _as_mpf_val(self, prec):
573         """Evaluation of mpf tuple accurate to at least prec bits."""
574         raise NotImplementedError('%s needs ._as_mpf_val() method' %
575             (self.__class__.__name__))
576 
577     def _eval_evalf(self, prec):
578         return Float._new(self._as_mpf_val(prec), prec)
579 
580     def _as_mpf_op(self, prec):
581         prec = max(prec, self._prec)
582         return self._as_mpf_val(prec), prec
583 
584     def __float__(self):
585         return mlib.to_float(self._as_mpf_val(53))
586 
587     def floor(self):
588         raise NotImplementedError('%s needs .floor() method' %
589             (self.__class__.__name__))
590 
591     def ceiling(self):
592         raise NotImplementedError('%s needs .ceiling() method' %
593             (self.__class__.__name__))
594 
595     def __floor__(self):
596         return self.floor()
597 
598     def __ceil__(self):
599         return self.ceiling()
600 
601     def _eval_conjugate(self):
602         return self
603 
604     def _eval_order(self, *symbols):
605         from sympy import Order
606         # Order(5, x, y) -> Order(1,x,y)
607         return Order(S.One, *symbols)
608 
609     def _eval_subs(self, old, new):
610         if old == -self:
611             return -new
612         return self  # there is no other possibility
613 
614     def _eval_is_finite(self):
615         return True
616 
617     @classmethod
618     def class_key(cls):
619         return 1, 0, 'Number'
620 
621     @cacheit
622     def sort_key(self, order=None):
623         return self.class_key(), (0, ()), (), self
624 
625     @_sympifyit('other', NotImplemented)
626     def __add__(self, other):
627         if isinstance(other, Number) and global_evaluate[0]:
628             if other is S.NaN:
629                 return S.NaN
630             elif other is S.Infinity:
631                 return S.Infinity
632             elif other is S.NegativeInfinity:
633                 return S.NegativeInfinity
634         return AtomicExpr.__add__(self, other)
635 
636     @_sympifyit('other', NotImplemented)
637     def __sub__(self, other):
638         if isinstance(other, Number) and global_evaluate[0]:
639             if other is S.NaN:
640                 return S.NaN
641             elif other is S.Infinity:
642                 return S.NegativeInfinity
643             elif other is S.NegativeInfinity:
644                 return S.Infinity
645         return AtomicExpr.__sub__(self, other)
646 
647     @_sympifyit('other', NotImplemented)
648     def __mul__(self, other):
649         if isinstance(other, Number) and global_evaluate[0]:
650             if other is S.NaN:
651                 return S.NaN
652             elif other is S.Infinity:
653                 if self.is_zero:
654                     return S.NaN
655                 elif self.is_positive:
656                     return S.Infinity
657                 else:
658                     return S.NegativeInfinity
659             elif other is S.NegativeInfinity:
660                 if self.is_zero:
661                     return S.NaN
662                 elif self.is_positive:
663                     return S.NegativeInfinity
664                 else:
665                     return S.Infinity
666         elif isinstance(other, Tuple):
667             return NotImplemented
668         return AtomicExpr.__mul__(self, other)
669 
670     @_sympifyit('other', NotImplemented)
671     def __div__(self, other):
672         if isinstance(other, Number) and global_evaluate[0]:
673             if other is S.NaN:
674                 return S.NaN
675             elif other is S.Infinity or other is S.NegativeInfinity:
676                 return S.Zero
677         return AtomicExpr.__div__(self, other)
678 
679     __truediv__ = __div__
680 
681     def __eq__(self, other):
682         raise NotImplementedError('%s needs .__eq__() method' %
683             (self.__class__.__name__))
684 
685     def __ne__(self, other):
686         raise NotImplementedError('%s needs .__ne__() method' %
687             (self.__class__.__name__))
688 
689     def __lt__(self, other):
690         try:
691             other = _sympify(other)
692         except SympifyError:
693             raise TypeError("Invalid comparison %s < %s" % (self, other))
694         raise NotImplementedError('%s needs .__lt__() method' %
695             (self.__class__.__name__))
696 
697     def __le__(self, other):
698         try:
699             other = _sympify(other)
700         except SympifyError:
701             raise TypeError("Invalid comparison %s <= %s" % (self, other))
702         raise NotImplementedError('%s needs .__le__() method' %
703             (self.__class__.__name__))
704 
705     def __gt__(self, other):
706         try:
707             other = _sympify(other)
708         except SympifyError:
709             raise TypeError("Invalid comparison %s > %s" % (self, other))
710         return _sympify(other).__lt__(self)
711 
712     def __ge__(self, other):
713         try:
714             other = _sympify(other)
715         except SympifyError:
716             raise TypeError("Invalid comparison %s >= %s" % (self, other))
717         return _sympify(other).__le__(self)
718 
719     def __hash__(self):
720         return super(Number, self).__hash__()
721 
722     def is_constant(self, *wrt, **flags):
723         return True
724 
725     def as_coeff_mul(self, *deps, **kwargs):
726         # a -> c*t
727         if self.is_Rational or not kwargs.pop('rational', True):
728             return self, tuple()
729         elif self.is_negative:
730             return S.NegativeOne, (-self,)
731         return S.One, (self,)
732 
733     def as_coeff_add(self, *deps):
734         # a -> c + t
735         if self.is_Rational:
736             return self, tuple()
737         return S.Zero, (self,)
738 
739     def as_coeff_Mul(self, rational=False):
740         """Efficiently extract the coefficient of a product. """
741         if rational and not self.is_Rational:
742             return S.One, self
743         return (self, S.One) if self else (S.One, self)
744 
745     def as_coeff_Add(self, rational=False):
746         """Efficiently extract the coefficient of a summation. """
747         if not rational:
748             return self, S.Zero
749         return S.Zero, self
750 
751     def gcd(self, other):
752         """Compute GCD of `self` and `other`. """
753         from sympy.polys import gcd
754         return gcd(self, other)
755 
756     def lcm(self, other):
757         """Compute LCM of `self` and `other`. """
758         from sympy.polys import lcm
759         return lcm(self, other)
760 
761     def cofactors(self, other):
762         """Compute GCD and cofactors of `self` and `other`. """
763         from sympy.polys import cofactors
764         return cofactors(self, other)
765 
766 
767 class Float(Number):
768     """Represent a floating-point number of arbitrary precision.
769 
770     Examples
771     ========
772 
773     >>> from sympy import Float
774     >>> Float(3.5)
775     3.50000000000000
776     >>> Float(3)
777     3.00000000000000
778 
779     Creating Floats from strings (and Python ``int`` and ``long``
780     types) will give a minimum precision of 15 digits, but the
781     precision will automatically increase to capture all digits
782     entered.
783 
784     >>> Float(1)
785     1.00000000000000
786     >>> Float(10**20)
787     100000000000000000000.
788     >>> Float('1e20')
789     100000000000000000000.
790 
791     However, *floating-point* numbers (Python ``float`` types) retain
792     only 15 digits of precision:
793 
794     >>> Float(1e20)
795     1.00000000000000e+20
796     >>> Float(1.23456789123456789)
797     1.23456789123457
798 
799     It may be preferable to enter high-precision decimal numbers
800     as strings:
801 
802     Float('1.23456789123456789')
803     1.23456789123456789
804 
805     The desired number of digits can also be specified:
806 
807     >>> Float('1e-3', 3)
808     0.00100
809     >>> Float(100, 4)
810     100.0
811 
812     Float can automatically count significant figures if a null string
813     is sent for the precision; spaces or underscores are also allowed. (Auto-
814     counting is only allowed for strings, ints and longs).
815 
816     >>> Float('123 456 789.123_456', '')
817     123456789.123456
818     >>> Float('12e-3', '')
819     0.012
820     >>> Float(3, '')
821     3.
822 
823     If a number is written in scientific notation, only the digits before the
824     exponent are considered significant if a decimal appears, otherwise the
825     "e" signifies only how to move the decimal:
826 
827     >>> Float('60.e2', '')  # 2 digits significant
828     6.0e+3
829     >>> Float('60e2', '')  # 4 digits significant
830     6000.
831     >>> Float('600e-2', '')  # 3 digits significant
832     6.00
833 
834     Notes
835     =====
836 
837     Floats are inexact by their nature unless their value is a binary-exact
838     value.
839 
840     >>> approx, exact = Float(.1, 1), Float(.125, 1)
841 
842     For calculation purposes, evalf needs to be able to change the precision
843     but this will not increase the accuracy of the inexact value. The
844     following is the most accurate 5-digit approximation of a value of 0.1
845     that had only 1 digit of precision:
846 
847     >>> approx.evalf(5)
848     0.099609
849 
850     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
851     can be passed to Float or evalf to obtain an arbitrary precision with
852     matching accuracy:
853 
854     >>> Float(exact, 5)
855     0.12500
856     >>> exact.evalf(20)
857     0.12500000000000000000
858 
859     Trying to make a high-precision Float from a float is not disallowed,
860     but one must keep in mind that the *underlying float* (not the apparent
861     decimal value) is being obtained with high precision. For example, 0.3
862     does not have a finite binary representation. The closest rational is
863     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
864     0.3 to 20 digits of precision you will not see the same thing as 0.3
865     followed by 19 zeros:
866 
867     >>> Float(0.3, 20)
868     0.29999999999999998890
869 
870     If you want a 20-digit value of the decimal 0.3 (not the floating point
871     approximation of 0.3) you should send the 0.3 as a string. The underlying
872     representation is still binary but a higher precision than Python's float
873     is used:
874 
875     >>> Float('0.3', 20)
876     0.30000000000000000000
877 
878     Although you can increase the precision of an existing Float using Float
879     it will not increase the accuracy -- the underlying value is not changed:
880 
881     >>> def show(f): # binary rep of Float
882     ...     from sympy import Mul, Pow
883     ...     s, m, e, b = f._mpf_
884     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
885     ...     print('%s at prec=%s' % (v, f._prec))
886     ...
887     >>> t = Float('0.3', 3)
888     >>> show(t)
889     4915/2**14 at prec=13
890     >>> show(Float(t, 20)) # higher prec, not higher accuracy
891     4915/2**14 at prec=70
892     >>> show(Float(t, 2)) # lower prec
893     307/2**10 at prec=10
894 
895     The same thing happens when evalf is used on a Float:
896 
897     >>> show(t.evalf(20))
898     4915/2**14 at prec=70
899     >>> show(t.evalf(2))
900     307/2**10 at prec=10
901 
902     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
903     produce the number (-1)**n*c*2**p:
904 
905     >>> n, c, p = 1, 5, 0
906     >>> (-1)**n*c*2**p
907     -5
908     >>> Float((1, 5, 0))
909     -5.00000000000000
910 
911     An actual mpf tuple also contains the number of bits in c as the last
912     element of the tuple:
913 
914     >>> _._mpf_
915     (1, 5, 0, 3)
916 
917     This is not needed for instantiation and is not the same thing as the
918     precision. The mpf tuple and the precision are two separate quantities
919     that Float tracks.
920 
921     """
922     __slots__ = ['_mpf_', '_prec']
923 
924     # A Float represents many real numbers,
925     # both rational and irrational.
926     is_rational = None
927     is_irrational = None
928     is_number = True
929 
930     is_real = True
931 
932     is_Float = True
933 
934     def __new__(cls, num, dps=None, prec=None, precision=None):
935         if prec is not None:
936             SymPyDeprecationWarning(
937                             feature="Using 'prec=XX' to denote decimal precision",
938                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
939                                               "for binary precision",
940                             issue=12820,
941                             deprecated_since_version="1.1").warn()
942             dps = prec
943         del prec  # avoid using this deprecated kwarg
944 
945         if dps is not None and precision is not None:
946             raise ValueError('Both decimal and binary precision supplied. '
947                              'Supply only one. ')
948 
949         if isinstance(num, string_types):
950             # Float already accepts spaces as digit separators; in Py 3.6
951             # underscores are allowed. In anticipation of that, we ignore
952             # legally placed underscores
953             num = num.replace(' ', '')
954             if '_' in num:
955                 if num.startswith('_') or num.endswith('_') or any(
956                         i in num for i in ('__', '_.', '._')):
957                     # copy Py 3.6 error
958                     raise ValueError("could not convert string to float: '%s'" % num)
959                 num = num.replace('_', '')
960             if num.startswith('.') and len(num) > 1:
961                 num = '0' + num
962             elif num.startswith('-.') and len(num) > 2:
963                 num = '-0.' + num[2:]
964             elif num == 'inf' or num == '+inf':
965                 return S.Infinity
966             elif num == '-inf':
967                 return S.NegativeInfinity
968         elif isinstance(num, float) and num == 0:
969             num = '0'
970         elif isinstance(num, float) and num == float('inf'):
971             return S.Infinity
972         elif isinstance(num, float) and num == float('-inf'):
973             return S.NegativeInfinity
974         elif isinstance(num, (SYMPY_INTS, Integer)):
975             num = str(num)  # faster than mlib.from_int
976         elif num is S.Infinity:
977             return num
978         elif num is S.NegativeInfinity:
979             return num
980         elif type(num).__module__ == 'numpy': # support for numpy datatypes
981             num = _convert_numpy_types(num)
982         elif isinstance(num, mpmath.mpf):
983             if precision is None:
984                 if dps is None:
985                     precision = num.context.prec
986             num = num._mpf_
987 
988         if dps is None and precision is None:
989             dps = 15
990             if isinstance(num, Float):
991                 return num
992             if isinstance(num, string_types) and _literal_float(num):
993                 try:
994                     Num = decimal.Decimal(num)
995                 except decimal.InvalidOperation:
996                     pass
997                 else:
998                     isint = '.' not in num
999                     num, dps = _decimal_to_Rational_prec(Num)
1000                     if num.is_Integer and isint:
1001                         dps = max(dps, len(str(num).lstrip('-')))
1002                     dps = max(15, dps)
1003                     precision = mlib.libmpf.dps_to_prec(dps)
1004         elif precision == '' and dps is None or precision is None and dps == '':
1005             if not isinstance(num, string_types):
1006                 raise ValueError('The null string can only be used when '
1007                 'the number to Float is passed as a string or an integer.')
1008             ok = None
1009             if _literal_float(num):
1010                 try:
1011                     Num = decimal.Decimal(num)
1012                 except decimal.InvalidOperation:
1013                     pass
1014                 else:
1015                     isint = '.' not in num
1016                     num, dps = _decimal_to_Rational_prec(Num)
1017                     if num.is_Integer and isint:
1018                         dps = max(dps, len(str(num).lstrip('-')))
1019                         precision = mlib.libmpf.dps_to_prec(dps)
1020                     ok = True
1021             if ok is None:
1022                 raise ValueError('string-float not recognized: %s' % num)
1023 
1024         # decimal precision(dps) is set and maybe binary precision(precision)
1025         # as well.From here on binary precision is used to compute the Float.
1026         # Hence, if supplied use binary precision else translate from decimal
1027         # precision.
1028 
1029         if precision is None or precision == '':
1030             precision = mlib.libmpf.dps_to_prec(dps)
1031 
1032         precision = int(precision)
1033 
1034         if isinstance(num, float):
1035             _mpf_ = mlib.from_float(num, precision, rnd)
1036         elif isinstance(num, string_types):
1037             _mpf_ = mlib.from_str(num, precision, rnd)
1038         elif isinstance(num, decimal.Decimal):
1039             if num.is_finite():
1040                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1041             elif num.is_nan():
1042                 return S.NaN
1043             elif num.is_infinite():
1044                 if num > 0:
1045                     return S.Infinity
1046                 else:
1047                     return S.NegativeInfinity
1048             else:
1049                 raise ValueError("unexpected decimal value %s" % str(num))
1050         elif isinstance(num, tuple) and len(num) in (3, 4):
1051             if type(num[1]) is str:
1052                 # it's a hexadecimal (coming from a pickled object)
1053                 # assume that it is in standard form
1054                 num = list(num)
1055                 # If we're loading an object pickled in Python 2 into
1056                 # Python 3, we may need to strip a tailing 'L' because
1057                 # of a shim for int on Python 3, see issue #13470.
1058                 if num[1].endswith('L'):
1059                     num[1] = num[1][:-1]
1060                 num[1] = MPZ(num[1], 16)
1061                 _mpf_ = tuple(num)
1062             else:
1063                 if len(num) == 4:
1064                     # handle normalization hack
1065                     return Float._new(num, precision)
1066                 else:
1067                     return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)
1068         else:
1069             try:
1070                 _mpf_ = num._as_mpf_val(precision)
1071             except (NotImplementedError, AttributeError):
1072                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1073 
1074         # special cases
1075         if _mpf_ == _mpf_zero:
1076             pass  # we want a Float
1077         elif _mpf_ == _mpf_nan:
1078             return S.NaN
1079         elif _mpf_ == _mpf_inf:
1080             return S.Infinity
1081         elif _mpf_ == _mpf_ninf:
1082             return S.NegativeInfinity
1083 
1084         obj = Expr.__new__(cls)
1085         obj._mpf_ = _mpf_
1086         obj._prec = precision
1087         return obj
1088 
1089     @classmethod
1090     def _new(cls, _mpf_, _prec):
1091         # special cases
1092         if _mpf_ == _mpf_zero:
1093             return S.Zero  # XXX this is different from Float which gives 0.0
1094         elif _mpf_ == _mpf_nan:
1095             return S.NaN
1096         elif _mpf_ == _mpf_inf:
1097             return S.Infinity
1098         elif _mpf_ == _mpf_ninf:
1099             return S.NegativeInfinity
1100 
1101         obj = Expr.__new__(cls)
1102         obj._mpf_ = mpf_norm(_mpf_, _prec)
1103         # XXX: Should this be obj._prec = obj._mpf_[3]?
1104         obj._prec = _prec
1105         return obj
1106 
1107     # mpz can't be pickled
1108     def __getnewargs__(self):
1109         return (mlib.to_pickable(self._mpf_),)
1110 
1111     def __getstate__(self):
1112         return {'_prec': self._prec}
1113 
1114     def _hashable_content(self):
1115         return (self._mpf_, self._prec)
1116 
1117     def floor(self):
1118         return Integer(int(mlib.to_int(
1119             mlib.mpf_floor(self._mpf_, self._prec))))
1120 
1121     def ceiling(self):
1122         return Integer(int(mlib.to_int(
1123             mlib.mpf_ceil(self._mpf_, self._prec))))
1124 
1125     def __floor__(self):
1126         return self.floor()
1127 
1128     def __ceil__(self):
1129         return self.ceiling()
1130 
1131 
1132     @property
1133     def num(self):
1134         return mpmath.mpf(self._mpf_)
1135 
1136     def _as_mpf_val(self, prec):
1137         rv = mpf_norm(self._mpf_, prec)
1138         if rv != self._mpf_ and self._prec == prec:
1139             debug(self._mpf_, rv)
1140         return rv
1141 
1142     def _as_mpf_op(self, prec):
1143         return self._mpf_, max(prec, self._prec)
1144 
1145     def _eval_is_finite(self):
1146         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1147             return False
1148         return True
1149 
1150     def _eval_is_infinite(self):
1151         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1152             return True
1153         return False
1154 
1155     def _eval_is_integer(self):
1156         return self._mpf_ == _mpf_zero
1157 
1158     def _eval_is_negative(self):
1159         if self._mpf_ == _mpf_ninf:
1160             return True
1161         if self._mpf_ == _mpf_inf:
1162             return False
1163         return self.num < 0
1164 
1165     def _eval_is_positive(self):
1166         if self._mpf_ == _mpf_inf:
1167             return True
1168         if self._mpf_ == _mpf_ninf:
1169             return False
1170         return self.num > 0
1171 
1172     def _eval_is_zero(self):
1173         return self._mpf_ == _mpf_zero
1174 
1175     def __nonzero__(self):
1176         return self._mpf_ != _mpf_zero
1177 
1178     __bool__ = __nonzero__
1179 
1180     def __neg__(self):
1181         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1182 
1183     @_sympifyit('other', NotImplemented)
1184     def __add__(self, other):
1185         if isinstance(other, Number) and global_evaluate[0]:
1186             rhs, prec = other._as_mpf_op(self._prec)
1187             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1188         return Number.__add__(self, other)
1189 
1190     @_sympifyit('other', NotImplemented)
1191     def __sub__(self, other):
1192         if isinstance(other, Number) and global_evaluate[0]:
1193             rhs, prec = other._as_mpf_op(self._prec)
1194             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1195         return Number.__sub__(self, other)
1196 
1197     @_sympifyit('other', NotImplemented)
1198     def __mul__(self, other):
1199         if isinstance(other, Number) and global_evaluate[0]:
1200             rhs, prec = other._as_mpf_op(self._prec)
1201             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1202         return Number.__mul__(self, other)
1203 
1204     @_sympifyit('other', NotImplemented)
1205     def __div__(self, other):
1206         if isinstance(other, Number) and other != 0 and global_evaluate[0]:
1207             rhs, prec = other._as_mpf_op(self._prec)
1208             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1209         return Number.__div__(self, other)
1210 
1211     __truediv__ = __div__
1212 
1213     @_sympifyit('other', NotImplemented)
1214     def __mod__(self, other):
1215         if isinstance(other, Rational) and other.q != 1 and global_evaluate[0]:
1216             # calculate mod with Rationals, *then* round the result
1217             return Float(Rational.__mod__(Rational(self), other),
1218                          precision=self._prec)
1219         if isinstance(other, Float) and global_evaluate[0]:
1220             r = self/other
1221             if r == int(r):
1222                 return Float(0, precision=max(self._prec, other._prec))
1223         if isinstance(other, Number) and global_evaluate[0]:
1224             rhs, prec = other._as_mpf_op(self._prec)
1225             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1226         return Number.__mod__(self, other)
1227 
1228     @_sympifyit('other', NotImplemented)
1229     def __rmod__(self, other):
1230         if isinstance(other, Float) and global_evaluate[0]:
1231             return other.__mod__(self)
1232         if isinstance(other, Number) and global_evaluate[0]:
1233             rhs, prec = other._as_mpf_op(self._prec)
1234             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1235         return Number.__rmod__(self, other)
1236 
1237     def _eval_power(self, expt):
1238         """
1239         expt is symbolic object but not equal to 0, 1
1240 
1241         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1242                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1243         """
1244         if self == 0:
1245             if expt.is_positive:
1246                 return S.Zero
1247             if expt.is_negative:
1248                 return S.Infinity
1249         if isinstance(expt, Number):
1250             if isinstance(expt, Integer):
1251                 prec = self._prec
1252                 return Float._new(
1253                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1254             elif isinstance(expt, Rational) and \
1255                     expt.p == 1 and expt.q % 2 and self.is_negative:
1256                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1257                     -self)._eval_power(expt)
1258             expt, prec = expt._as_mpf_op(self._prec)
1259             mpfself = self._mpf_
1260             try:
1261                 y = mpf_pow(mpfself, expt, prec, rnd)
1262                 return Float._new(y, prec)
1263             except mlib.ComplexResult:
1264                 re, im = mlib.mpc_pow(
1265                     (mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)
1266                 return Float._new(re, prec) + \
1267                     Float._new(im, prec)*S.ImaginaryUnit
1268 
1269     def __abs__(self):
1270         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1271 
1272     def __int__(self):
1273         if self._mpf_ == _mpf_zero:
1274             return 0
1275         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1276 
1277     __long__ = __int__
1278 
1279     def __eq__(self, other):
1280         if isinstance(other, float):
1281             # coerce to Float at same precision
1282             o = Float(other)
1283             try:
1284                 ompf = o._as_mpf_val(self._prec)
1285             except ValueError:
1286                 return False
1287             return bool(mlib.mpf_eq(self._mpf_, ompf))
1288         try:
1289             other = _sympify(other)
1290         except SympifyError:
1291             return NotImplemented
1292         if other.is_NumberSymbol:
1293             if other.is_irrational:
1294                 return False
1295             return other.__eq__(self)
1296         if other.is_Float:
1297             return bool(mlib.mpf_eq(self._mpf_, other._mpf_))
1298         if other.is_Number:
1299             # numbers should compare at the same precision;
1300             # all _as_mpf_val routines should be sure to abide
1301             # by the request to change the prec if necessary; if
1302             # they don't, the equality test will fail since it compares
1303             # the mpf tuples
1304             ompf = other._as_mpf_val(self._prec)
1305             return bool(mlib.mpf_eq(self._mpf_, ompf))
1306         return False    # Float != non-Number
1307 
1308     def __ne__(self, other):
1309         return not self == other
1310 
1311     def __gt__(self, other):
1312         try:
1313             other = _sympify(other)
1314         except SympifyError:
1315             raise TypeError("Invalid comparison %s > %s" % (self, other))
1316         if other.is_NumberSymbol:
1317             return other.__lt__(self)
1318         if other.is_Rational and not other.is_Integer:
1319             self *= other.q
1320             other = _sympify(other.p)
1321         elif other.is_comparable:
1322             other = other.evalf()
1323         if other.is_Number and other is not S.NaN:
1324             return _sympify(bool(
1325                 mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))
1326         return Expr.__gt__(self, other)
1327 
1328     def __ge__(self, other):
1329         try:
1330             other = _sympify(other)
1331         except SympifyError:
1332             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1333         if other.is_NumberSymbol:
1334             return other.__le__(self)
1335         if other.is_Rational and not other.is_Integer:
1336             self *= other.q
1337             other = _sympify(other.p)
1338         elif other.is_comparable:
1339             other = other.evalf()
1340         if other.is_Number and other is not S.NaN:
1341             return _sympify(bool(
1342                 mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))
1343         return Expr.__ge__(self, other)
1344 
1345     def __lt__(self, other):
1346         try:
1347             other = _sympify(other)
1348         except SympifyError:
1349             raise TypeError("Invalid comparison %s < %s" % (self, other))
1350         if other.is_NumberSymbol:
1351             return other.__gt__(self)
1352         if other.is_Rational and not other.is_Integer:
1353             self *= other.q
1354             other = _sympify(other.p)
1355         elif other.is_comparable:
1356             other = other.evalf()
1357         if other.is_Number and other is not S.NaN:
1358             return _sympify(bool(
1359                 mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))
1360         return Expr.__lt__(self, other)
1361 
1362     def __le__(self, other):
1363         try:
1364             other = _sympify(other)
1365         except SympifyError:
1366             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1367         if other.is_NumberSymbol:
1368             return other.__ge__(self)
1369         if other.is_Rational and not other.is_Integer:
1370             self *= other.q
1371             other = _sympify(other.p)
1372         elif other.is_comparable:
1373             other = other.evalf()
1374         if other.is_Number and other is not S.NaN:
1375             return _sympify(bool(
1376                 mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))
1377         return Expr.__le__(self, other)
1378 
1379     def __hash__(self):
1380         return super(Float, self).__hash__()
1381 
1382     def epsilon_eq(self, other, epsilon="1e-15"):
1383         return abs(self - other) < Float(epsilon)
1384 
1385     def _sage_(self):
1386         import sage.all as sage
1387         return sage.RealNumber(str(self))
1388 
1389     def __format__(self, format_spec):
1390         return format(decimal.Decimal(str(self)), format_spec)
1391 
1392 
1393 # Add sympify converters
1394 converter[float] = converter[decimal.Decimal] = Float
1395 
1396 # this is here to work nicely in Sage
1397 RealNumber = Float
1398 
1399 
1400 class Rational(Number):
1401     """Represents rational numbers (p/q) of any size.
1402 
1403     Examples
1404     ========
1405 
1406     >>> from sympy import Rational, nsimplify, S, pi
1407     >>> Rational(1, 2)
1408     1/2
1409 
1410     Rational is unprejudiced in accepting input. If a float is passed, the
1411     underlying value of the binary representation will be returned:
1412 
1413     >>> Rational(.5)
1414     1/2
1415     >>> Rational(.2)
1416     3602879701896397/18014398509481984
1417 
1418     If the simpler representation of the float is desired then consider
1419     limiting the denominator to the desired value or convert the float to
1420     a string (which is roughly equivalent to limiting the denominator to
1421     10**12):
1422 
1423     >>> Rational(str(.2))
1424     1/5
1425     >>> Rational(.2).limit_denominator(10**12)
1426     1/5
1427 
1428     An arbitrarily precise Rational is obtained when a string literal is
1429     passed:
1430 
1431     >>> Rational("1.23")
1432     123/100
1433     >>> Rational('1e-2')
1434     1/100
1435     >>> Rational(".1")
1436     1/10
1437     >>> Rational('1e-2/3.2')
1438     1/320
1439 
1440     The conversion of other types of strings can be handled by
1441     the sympify() function, and conversion of floats to expressions
1442     or simple fractions can be handled with nsimplify:
1443 
1444     >>> S('.[3]')  # repeating digits in brackets
1445     1/3
1446     >>> S('3**2/10')  # general expressions
1447     9/10
1448     >>> nsimplify(.3)  # numbers that have a simple form
1449     3/10
1450 
1451     But if the input does not reduce to a literal Rational, an error will
1452     be raised:
1453 
1454     >>> Rational(pi)
1455     Traceback (most recent call last):
1456     ...
1457     TypeError: invalid input: pi
1458 
1459 
1460     Low-level
1461     ---------
1462 
1463     Access numerator and denominator as .p and .q:
1464 
1465     >>> r = Rational(3, 4)
1466     >>> r
1467     3/4
1468     >>> r.p
1469     3
1470     >>> r.q
1471     4
1472 
1473     Note that p and q return integers (not SymPy Integers) so some care
1474     is needed when using them in expressions:
1475 
1476     >>> r.p/r.q
1477     0.75
1478 
1479     See Also
1480     ========
1481     sympify, sympy.simplify.simplify.nsimplify
1482     """
1483     is_real = True
1484     is_integer = False
1485     is_rational = True
1486     is_number = True
1487 
1488     __slots__ = ['p', 'q']
1489 
1490     is_Rational = True
1491 
1492     @cacheit
1493     def __new__(cls, p, q=None, gcd=None):
1494         if q is None:
1495             if isinstance(p, Rational):
1496                 return p
1497 
1498             if isinstance(p, SYMPY_INTS):
1499                 pass
1500             else:
1501                 if isinstance(p, (float, Float)):
1502                     return Rational(*_as_integer_ratio(p))
1503 
1504                 if not isinstance(p, string_types):
1505                     try:
1506                         p = sympify(p)
1507                     except (SympifyError, SyntaxError):
1508                         pass  # error will raise below
1509                 else:
1510                     if p.count('/') > 1:
1511                         raise TypeError('invalid input: %s' % p)
1512                     p = p.replace(' ', '')
1513                     pq = p.rsplit('/', 1)
1514                     if len(pq) == 2:
1515                         p, q = pq
1516                         fp = fractions.Fraction(p)
1517                         fq = fractions.Fraction(q)
1518                         p = fp/fq
1519                     try:
1520                         p = fractions.Fraction(p)
1521                     except ValueError:
1522                         pass  # error will raise below
1523                     else:
1524                         return Rational(p.numerator, p.denominator, 1)
1525 
1526                 if not isinstance(p, Rational):
1527                     raise TypeError('invalid input: %s' % p)
1528 
1529             q = 1
1530             gcd = 1
1531         else:
1532             p = Rational(p)
1533             q = Rational(q)
1534 
1535         if isinstance(q, Rational):
1536             p *= q.q
1537             q = q.p
1538         if isinstance(p, Rational):
1539             q *= p.q
1540             p = p.p
1541 
1542         # p and q are now integers
1543         if q == 0:
1544             if p == 0:
1545                 if _errdict["divide"]:
1546                     raise ValueError("Indeterminate 0/0")
1547                 else:
1548                     return S.NaN
1549             return S.ComplexInfinity
1550         if q < 0:
1551             q = -q
1552             p = -p
1553         if not gcd:
1554             gcd = igcd(abs(p), q)
1555         if gcd > 1:
1556             p //= gcd
1557             q //= gcd
1558         if q == 1:
1559             return Integer(p)
1560         if p == 1 and q == 2:
1561             return S.Half
1562         obj = Expr.__new__(cls)
1563         obj.p = p
1564         obj.q = q
1565         return obj
1566 
1567     def limit_denominator(self, max_denominator=1000000):
1568         """Closest Rational to self with denominator at most max_denominator.
1569 
1570         >>> from sympy import Rational
1571         >>> Rational('3.141592653589793').limit_denominator(10)
1572         22/7
1573         >>> Rational('3.141592653589793').limit_denominator(100)
1574         311/99
1575 
1576         """
1577         f = fractions.Fraction(self.p, self.q)
1578         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))
1579 
1580     def __getnewargs__(self):
1581         return (self.p, self.q)
1582 
1583     def _hashable_content(self):
1584         return (self.p, self.q)
1585 
1586     def _eval_is_positive(self):
1587         return self.p > 0
1588 
1589     def _eval_is_zero(self):
1590         return self.p == 0
1591 
1592     def __neg__(self):
1593         return Rational(-self.p, self.q)
1594 
1595     @_sympifyit('other', NotImplemented)
1596     def __add__(self, other):
1597         if global_evaluate[0]:
1598             if isinstance(other, Integer):
1599                 return Rational(self.p + self.q*other.p, self.q, 1)
1600             elif isinstance(other, Rational):
1601                 #TODO: this can probably be optimized more
1602                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)
1603             elif isinstance(other, Float):
1604                 return other + self
1605             else:
1606                 return Number.__add__(self, other)
1607         return Number.__add__(self, other)
1608     __radd__ = __add__
1609 
1610     @_sympifyit('other', NotImplemented)
1611     def __sub__(self, other):
1612         if global_evaluate[0]:
1613             if isinstance(other, Integer):
1614                 return Rational(self.p - self.q*other.p, self.q, 1)
1615             elif isinstance(other, Rational):
1616                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)
1617             elif isinstance(other, Float):
1618                 return -other + self
1619             else:
1620                 return Number.__sub__(self, other)
1621         return Number.__sub__(self, other)
1622     @_sympifyit('other', NotImplemented)
1623     def __rsub__(self, other):
1624         if global_evaluate[0]:
1625             if isinstance(other, Integer):
1626                 return Rational(self.q*other.p - self.p, self.q, 1)
1627             elif isinstance(other, Rational):
1628                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)
1629             elif isinstance(other, Float):
1630                 return -self + other
1631             else:
1632                 return Number.__rsub__(self, other)
1633         return Number.__rsub__(self, other)
1634     @_sympifyit('other', NotImplemented)
1635     def __mul__(self, other):
1636         if global_evaluate[0]:
1637             if isinstance(other, Integer):
1638                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))
1639             elif isinstance(other, Rational):
1640                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))
1641             elif isinstance(other, Float):
1642                 return other*self
1643             else:
1644                 return Number.__mul__(self, other)
1645         return Number.__mul__(self, other)
1646     __rmul__ = __mul__
1647 
1648     @_sympifyit('other', NotImplemented)
1649     def __div__(self, other):
1650         if global_evaluate[0]:
1651             if isinstance(other, Integer):
1652                 if self.p and other.p == S.Zero:
1653                     return S.ComplexInfinity
1654                 else:
1655                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))
1656             elif isinstance(other, Rational):
1657                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1658             elif isinstance(other, Float):
1659                 return self*(1/other)
1660             else:
1661                 return Number.__div__(self, other)
1662         return Number.__div__(self, other)
1663     @_sympifyit('other', NotImplemented)
1664     def __rdiv__(self, other):
1665         if global_evaluate[0]:
1666             if isinstance(other, Integer):
1667                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))
1668             elif isinstance(other, Rational):
1669                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1670             elif isinstance(other, Float):
1671                 return other*(1/self)
1672             else:
1673                 return Number.__rdiv__(self, other)
1674         return Number.__rdiv__(self, other)
1675     __truediv__ = __div__
1676 
1677     @_sympifyit('other', NotImplemented)
1678     def __mod__(self, other):
1679         if global_evaluate[0]:
1680             if isinstance(other, Rational):
1681                 n = (self.p*other.q) // (other.p*self.q)
1682                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)
1683             if isinstance(other, Float):
1684                 # calculate mod with Rationals, *then* round the answer
1685                 return Float(self.__mod__(Rational(other)),
1686                              precision=other._prec)
1687             return Number.__mod__(self, other)
1688         return Number.__mod__(self, other)
1689 
1690     @_sympifyit('other', NotImplemented)
1691     def __rmod__(self, other):
1692         if isinstance(other, Rational):
1693             return Rational.__mod__(other, self)
1694         return Number.__rmod__(self, other)
1695 
1696     def _eval_power(self, expt):
1697         if isinstance(expt, Number):
1698             if isinstance(expt, Float):
1699                 return self._eval_evalf(expt._prec)**expt
1700             if expt.is_negative:
1701                 # (3/4)**-2 -> (4/3)**2
1702                 ne = -expt
1703                 if (ne is S.One):
1704                     return Rational(self.q, self.p)
1705                 if self.is_negative:
1706                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne
1707                 else:
1708                     return Rational(self.q, self.p)**ne
1709             if expt is S.Infinity:  # -oo already caught by test for negative
1710                 if self.p > self.q:
1711                     # (3/2)**oo -> oo
1712                     return S.Infinity
1713                 if self.p < -self.q:
1714                     # (-3/2)**oo -> oo + I*oo
1715                     return S.Infinity + S.Infinity*S.ImaginaryUnit
1716                 return S.Zero
1717             if isinstance(expt, Integer):
1718                 # (4/3)**2 -> 4**2 / 3**2
1719                 return Rational(self.p**expt.p, self.q**expt.p, 1)
1720             if isinstance(expt, Rational):
1721                 if self.p != 1:
1722                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)
1723                     return Integer(self.p)**expt*Integer(self.q)**(-expt)
1724                 # as the above caught negative self.p, now self is positive
1725                 return Integer(self.q)**Rational(
1726                 expt.p*(expt.q - 1), expt.q) / \
1727                     Integer(self.q)**Integer(expt.p)
1728 
1729         if self.is_negative and expt.is_even:
1730             return (-self)**expt
1731 
1732         return
1733 
1734     def _as_mpf_val(self, prec):
1735         return mlib.from_rational(self.p, self.q, prec, rnd)
1736 
1737     def _mpmath_(self, prec, rnd):
1738         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))
1739 
1740     def __abs__(self):
1741         return Rational(abs(self.p), self.q)
1742 
1743     def __int__(self):
1744         p, q = self.p, self.q
1745         if p < 0:
1746             return -int(-p//q)
1747         return int(p//q)
1748 
1749     __long__ = __int__
1750 
1751     def floor(self):
1752         return Integer(self.p // self.q)
1753 
1754     def ceiling(self):
1755         return -Integer(-self.p // self.q)
1756 
1757     def __floor__(self):
1758         return self.floor()
1759 
1760     def __ceil__(self):
1761         return self.ceiling()
1762 
1763     def __eq__(self, other):
1764         try:
1765             other = _sympify(other)
1766         except SympifyError:
1767             return NotImplemented
1768         if other.is_NumberSymbol:
1769             if other.is_irrational:
1770                 return False
1771             return other.__eq__(self)
1772         if other.is_Number:
1773             if other.is_Rational:
1774                 # a Rational is always in reduced form so will never be 2/4
1775                 # so we can just check equivalence of args
1776                 return self.p == other.p and self.q == other.q
1777             if other.is_Float:
1778                 return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
1779         return False
1780 
1781     def __ne__(self, other):
1782         return not self == other
1783 
1784     def __gt__(self, other):
1785         try:
1786             other = _sympify(other)
1787         except SympifyError:
1788             raise TypeError("Invalid comparison %s > %s" % (self, other))
1789         if other.is_NumberSymbol:
1790             return other.__lt__(self)
1791         expr = self
1792         if other.is_Number:
1793             if other.is_Rational:
1794                 return _sympify(bool(self.p*other.q > self.q*other.p))
1795             if other.is_Float:
1796                 return _sympify(bool(mlib.mpf_gt(
1797                     self._as_mpf_val(other._prec), other._mpf_)))
1798         elif other.is_number and other.is_real:
1799             expr, other = Integer(self.p), self.q*other
1800         return Expr.__gt__(expr, other)
1801 
1802     def __ge__(self, other):
1803         try:
1804             other = _sympify(other)
1805         except SympifyError:
1806             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1807         if other.is_NumberSymbol:
1808             return other.__le__(self)
1809         expr = self
1810         if other.is_Number:
1811             if other.is_Rational:
1812                  return _sympify(bool(self.p*other.q >= self.q*other.p))
1813             if other.is_Float:
1814                 return _sympify(bool(mlib.mpf_ge(
1815                     self._as_mpf_val(other._prec), other._mpf_)))
1816         elif other.is_number and other.is_real:
1817             expr, other = Integer(self.p), self.q*other
1818         return Expr.__ge__(expr, other)
1819 
1820     def __lt__(self, other):
1821         try:
1822             other = _sympify(other)
1823         except SympifyError:
1824             raise TypeError("Invalid comparison %s < %s" % (self, other))
1825         if other.is_NumberSymbol:
1826             return other.__gt__(self)
1827         expr = self
1828         if other.is_Number:
1829             if other.is_Rational:
1830                 return _sympify(bool(self.p*other.q < self.q*other.p))
1831             if other.is_Float:
1832                 return _sympify(bool(mlib.mpf_lt(
1833                     self._as_mpf_val(other._prec), other._mpf_)))
1834         elif other.is_number and other.is_real:
1835             expr, other = Integer(self.p), self.q*other
1836         return Expr.__lt__(expr, other)
1837 
1838     def __le__(self, other):
1839         try:
1840             other = _sympify(other)
1841         except SympifyError:
1842             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1843         expr = self
1844         if other.is_NumberSymbol:
1845             return other.__ge__(self)
1846         elif other.is_Number:
1847             if other.is_Rational:
1848                 return _sympify(bool(self.p*other.q <= self.q*other.p))
1849             if other.is_Float:
1850                 return _sympify(bool(mlib.mpf_le(
1851                     self._as_mpf_val(other._prec), other._mpf_)))
1852         elif other.is_number and other.is_real:
1853             expr, other = Integer(self.p), self.q*other
1854         return Expr.__le__(expr, other)
1855 
1856     def __hash__(self):
1857         return super(Rational, self).__hash__()
1858 
1859     def factors(self, limit=None, use_trial=True, use_rho=False,
1860                 use_pm1=False, verbose=False, visual=False):
1861         """A wrapper to factorint which return factors of self that are
1862         smaller than limit (or cheap to compute). Special methods of
1863         factoring are disabled by default so that only trial division is used.
1864         """
1865         from sympy.ntheory import factorrat
1866 
1867         return factorrat(self, limit=limit, use_trial=use_trial,
1868                       use_rho=use_rho, use_pm1=use_pm1,
1869                       verbose=verbose).copy()
1870 
1871     def numerator(self):
1872         return self.p
1873 
1874     def denominator(self):
1875         return self.q
1876 
1877     @_sympifyit('other', NotImplemented)
1878     def gcd(self, other):
1879         if isinstance(other, Rational):
1880             if other is S.Zero:
1881                 return other
1882             return Rational(
1883                 Integer(igcd(self.p, other.p)),
1884                 Integer(ilcm(self.q, other.q)))
1885         return Number.gcd(self, other)
1886 
1887     @_sympifyit('other', NotImplemented)
1888     def lcm(self, other):
1889         if isinstance(other, Rational):
1890             return Rational(
1891                 self.p // igcd(self.p, other.p) * other.p,
1892                 igcd(self.q, other.q))
1893         return Number.lcm(self, other)
1894 
1895     def as_numer_denom(self):
1896         return Integer(self.p), Integer(self.q)
1897 
1898     def _sage_(self):
1899         import sage.all as sage
1900         return sage.Integer(self.p)/sage.Integer(self.q)
1901 
1902     def as_content_primitive(self, radical=False, clear=True):
1903         """Return the tuple (R, self/R) where R is the positive Rational
1904         extracted from self.
1905 
1906         Examples
1907         ========
1908 
1909         >>> from sympy import S
1910         >>> (S(-3)/2).as_content_primitive()
1911         (3/2, -1)
1912 
1913         See docstring of Expr.as_content_primitive for more examples.
1914         """
1915 
1916         if self:
1917             if self.is_positive:
1918                 return self, S.One
1919             return -self, S.NegativeOne
1920         return S.One, self
1921 
1922     def as_coeff_Mul(self, rational=False):
1923         """Efficiently extract the coefficient of a product. """
1924         return self, S.One
1925 
1926     def as_coeff_Add(self, rational=False):
1927         """Efficiently extract the coefficient of a summation. """
1928         return self, S.Zero
1929 
1930 
1931 class Integer(Rational):
1932     """Represents integer numbers of any size.
1933 
1934     Examples
1935     ========
1936 
1937     >>> from sympy import Integer
1938     >>> Integer(3)
1939     3
1940 
1941     If a float or a rational is passed to Integer, the fractional part
1942     will be discarded; the effect is of rounding toward zero.
1943 
1944     >>> Integer(3.8)
1945     3
1946     >>> Integer(-3.8)
1947     -3
1948 
1949     A string is acceptable input if it can be parsed as an integer:
1950 
1951     >>> Integer("9" * 20)
1952     99999999999999999999
1953 
1954     It is rarely needed to explicitly instantiate an Integer, because
1955     Python integers are automatically converted to Integer when they
1956     are used in SymPy expressions.
1957     """
1958     q = 1
1959     is_integer = True
1960     is_number = True
1961 
1962     is_Integer = True
1963 
1964     __slots__ = ['p']
1965 
1966     def _as_mpf_val(self, prec):
1967         return mlib.from_int(self.p, prec, rnd)
1968 
1969     def _mpmath_(self, prec, rnd):
1970         return mpmath.make_mpf(self._as_mpf_val(prec))
1971 
1972     @cacheit
1973     def __new__(cls, i):
1974         if isinstance(i, string_types):
1975             i = i.replace(' ', '')
1976         # whereas we cannot, in general, make a Rational from an
1977         # arbitrary expression, we can make an Integer unambiguously
1978         # (except when a non-integer expression happens to round to
1979         # an integer). So we proceed by taking int() of the input and
1980         # let the int routines determine whether the expression can
1981         # be made into an int or whether an error should be raised.
1982         try:
1983             ival = int(i)
1984         except TypeError:
1985             raise TypeError(
1986                 "Argument of Integer should be of numeric type, got %s." % i)
1987         # We only work with well-behaved integer types. This converts, for
1988         # example, numpy.int32 instances.
1989         if ival == 1:
1990             return S.One
1991         if ival == -1:
1992             return S.NegativeOne
1993         if ival == 0:
1994             return S.Zero
1995         obj = Expr.__new__(cls)
1996         obj.p = ival
1997         return obj
1998 
1999     def __getnewargs__(self):
2000         return (self.p,)
2001 
2002     # Arithmetic operations are here for efficiency
2003     def __int__(self):
2004         return self.p
2005 
2006     __long__ = __int__
2007 
2008     def floor(self):
2009         return Integer(self.p)
2010 
2011     def ceiling(self):
2012         return Integer(self.p)
2013 
2014     def __floor__(self):
2015         return self.floor()
2016 
2017     def __ceil__(self):
2018         return self.ceiling()
2019 
2020     def __neg__(self):
2021         return Integer(-self.p)
2022 
2023     def __abs__(self):
2024         if self.p >= 0:
2025             return self
2026         else:
2027             return Integer(-self.p)
2028 
2029     def __divmod__(self, other):
2030         from .containers import Tuple
2031         if isinstance(other, Integer) and global_evaluate[0]:
2032             return Tuple(*(divmod(self.p, other.p)))
2033         else:
2034             return Number.__divmod__(self, other)
2035 
2036     def __rdivmod__(self, other):
2037         from .containers import Tuple
2038         if isinstance(other, integer_types) and global_evaluate[0]:
2039             return Tuple(*(divmod(other, self.p)))
2040         else:
2041             try:
2042                 other = Number(other)
2043             except TypeError:
2044                 msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
2045                 oname = type(other).__name__
2046                 sname = type(self).__name__
2047                 raise TypeError(msg % (oname, sname))
2048             return Number.__divmod__(other, self)
2049 
2050     # TODO make it decorator + bytecodehacks?
2051     def __add__(self, other):
2052         if global_evaluate[0]:
2053             if isinstance(other, integer_types):
2054                 return Integer(self.p + other)
2055             elif isinstance(other, Integer):
2056                 return Integer(self.p + other.p)
2057             elif isinstance(other, Rational):
2058                 return Rational(self.p*other.q + other.p, other.q, 1)
2059             return Rational.__add__(self, other)
2060         else:
2061             return Add(self, other)
2062 
2063     def __radd__(self, other):
2064         if global_evaluate[0]:
2065             if isinstance(other, integer_types):
2066                 return Integer(other + self.p)
2067             elif isinstance(other, Rational):
2068                 return Rational(other.p + self.p*other.q, other.q, 1)
2069             return Rational.__radd__(self, other)
2070         return Rational.__radd__(self, other)
2071 
2072     def __sub__(self, other):
2073         if global_evaluate[0]:
2074             if isinstance(other, integer_types):
2075                 return Integer(self.p - other)
2076             elif isinstance(other, Integer):
2077                 return Integer(self.p - other.p)
2078             elif isinstance(other, Rational):
2079                 return Rational(self.p*other.q - other.p, other.q, 1)
2080             return Rational.__sub__(self, other)
2081         return Rational.__sub__(self, other)
2082 
2083     def __rsub__(self, other):
2084         if global_evaluate[0]:
2085             if isinstance(other, integer_types):
2086                 return Integer(other - self.p)
2087             elif isinstance(other, Rational):
2088                 return Rational(other.p - self.p*other.q, other.q, 1)
2089             return Rational.__rsub__(self, other)
2090         return Rational.__rsub__(self, other)
2091 
2092     def __mul__(self, other):
2093         if global_evaluate[0]:
2094             if isinstance(other, integer_types):
2095                 return Integer(self.p*other)
2096             elif isinstance(other, Integer):
2097                 return Integer(self.p*other.p)
2098             elif isinstance(other, Rational):
2099                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))
2100             return Rational.__mul__(self, other)
2101         return Rational.__mul__(self, other)
2102 
2103     def __rmul__(self, other):
2104         if global_evaluate[0]:
2105             if isinstance(other, integer_types):
2106                 return Integer(other*self.p)
2107             elif isinstance(other, Rational):
2108                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))
2109             return Rational.__rmul__(self, other)
2110         return Rational.__rmul__(self, other)
2111 
2112     def __mod__(self, other):
2113         if global_evaluate[0]:
2114             if isinstance(other, integer_types):
2115                 return Integer(self.p % other)
2116             elif isinstance(other, Integer):
2117                 return Integer(self.p % other.p)
2118             return Rational.__mod__(self, other)
2119         return Rational.__mod__(self, other)
2120 
2121     def __rmod__(self, other):
2122         if global_evaluate[0]:
2123             if isinstance(other, integer_types):
2124                 return Integer(other % self.p)
2125             elif isinstance(other, Integer):
2126                 return Integer(other.p % self.p)
2127             return Rational.__rmod__(self, other)
2128         return Rational.__rmod__(self, other)
2129 
2130     def __eq__(self, other):
2131         if isinstance(other, integer_types):
2132             return (self.p == other)
2133         elif isinstance(other, Integer):
2134             return (self.p == other.p)
2135         return Rational.__eq__(self, other)
2136 
2137     def __ne__(self, other):
2138         return not self == other
2139 
2140     def __gt__(self, other):
2141         try:
2142             other = _sympify(other)
2143         except SympifyError:
2144             raise TypeError("Invalid comparison %s > %s" % (self, other))
2145         if other.is_Integer:
2146             return _sympify(self.p > other.p)
2147         return Rational.__gt__(self, other)
2148 
2149     def __lt__(self, other):
2150         try:
2151             other = _sympify(other)
2152         except SympifyError:
2153             raise TypeError("Invalid comparison %s < %s" % (self, other))
2154         if other.is_Integer:
2155             return _sympify(self.p < other.p)
2156         return Rational.__lt__(self, other)
2157 
2158     def __ge__(self, other):
2159         try:
2160             other = _sympify(other)
2161         except SympifyError:
2162             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2163         if other.is_Integer:
2164             return _sympify(self.p >= other.p)
2165         return Rational.__ge__(self, other)
2166 
2167     def __le__(self, other):
2168         try:
2169             other = _sympify(other)
2170         except SympifyError:
2171             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2172         if other.is_Integer:
2173             return _sympify(self.p <= other.p)
2174         return Rational.__le__(self, other)
2175 
2176     def __hash__(self):
2177         return hash(self.p)
2178 
2179     def __index__(self):
2180         return self.p
2181 
2182     ########################################
2183 
2184     def _eval_is_odd(self):
2185         return bool(self.p % 2)
2186 
2187     def _eval_power(self, expt):
2188         """
2189         Tries to do some simplifications on self**expt
2190 
2191         Returns None if no further simplifications can be done
2192 
2193         When exponent is a fraction (so we have for example a square root),
2194         we try to find a simpler representation by factoring the argument
2195         up to factors of 2**15, e.g.
2196 
2197           - sqrt(4) becomes 2
2198           - sqrt(-4) becomes 2*I
2199           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)
2200 
2201         Further simplification would require a special call to factorint on
2202         the argument which is not done here for sake of speed.
2203 
2204         """
2205         from sympy import perfect_power
2206 
2207         if expt is S.Infinity:
2208             if self.p > S.One:
2209                 return S.Infinity
2210             # cases -1, 0, 1 are done in their respective classes
2211             return S.Infinity + S.ImaginaryUnit*S.Infinity
2212         if expt is S.NegativeInfinity:
2213             return Rational(1, self)**S.Infinity
2214         if not isinstance(expt, Number):
2215             # simplify when expt is even
2216             # (-2)**k --> 2**k
2217             if self.is_negative and expt.is_even:
2218                 return (-self)**expt
2219         if isinstance(expt, Float):
2220             # Rational knows how to exponentiate by a Float
2221             return super(Integer, self)._eval_power(expt)
2222         if not isinstance(expt, Rational):
2223             return
2224         if expt is S.Half and self.is_negative:
2225             # we extract I for this special case since everyone is doing so
2226             return S.ImaginaryUnit*Pow(-self, expt)
2227         if expt.is_negative:
2228             # invert base and change sign on exponent
2229             ne = -expt
2230             if self.is_negative:
2231                     return S.NegativeOne**expt*Rational(1, -self)**ne
2232             else:
2233                 return Rational(1, self.p)**ne
2234         # see if base is a perfect root, sqrt(4) --> 2
2235         x, xexact = integer_nthroot(abs(self.p), expt.q)
2236         if xexact:
2237             # if it's a perfect root we've finished
2238             result = Integer(x**abs(expt.p))
2239             if self.is_negative:
2240                 result *= S.NegativeOne**expt
2241             return result
2242 
2243         # The following is an algorithm where we collect perfect roots
2244         # from the factors of base.
2245 
2246         # if it's not an nth root, it still might be a perfect power
2247         b_pos = int(abs(self.p))
2248         p = perfect_power(b_pos)
2249         if p is not False:
2250             dict = {p[0]: p[1]}
2251         else:
2252             dict = Integer(b_pos).factors(limit=2**15)
2253 
2254         # now process the dict of factors
2255         out_int = 1  # integer part
2256         out_rad = 1  # extracted radicals
2257         sqr_int = 1
2258         sqr_gcd = 0
2259         sqr_dict = {}
2260         for prime, exponent in dict.items():
2261             exponent *= expt.p
2262             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)
2263             div_e, div_m = divmod(exponent, expt.q)
2264             if div_e > 0:
2265                 out_int *= prime**div_e
2266             if div_m > 0:
2267                 # see if the reduced exponent shares a gcd with e.q
2268                 # (2**2)**(1/10) -> 2**(1/5)
2269                 g = igcd(div_m, expt.q)
2270                 if g != 1:
2271                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))
2272                 else:
2273                     sqr_dict[prime] = div_m
2274         # identify gcd of remaining powers
2275         for p, ex in sqr_dict.items():
2276             if sqr_gcd == 0:
2277                 sqr_gcd = ex
2278             else:
2279                 sqr_gcd = igcd(sqr_gcd, ex)
2280                 if sqr_gcd == 1:
2281                     break
2282         for k, v in sqr_dict.items():
2283             sqr_int *= k**(v//sqr_gcd)
2284         if sqr_int == b_pos and out_int == 1 and out_rad == 1:
2285             result = None
2286         else:
2287             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))
2288             if self.is_negative:
2289                 result *= Pow(S.NegativeOne, expt)
2290         return result
2291 
2292     def _eval_is_prime(self):
2293         from sympy.ntheory import isprime
2294 
2295         return isprime(self)
2296 
2297     def _eval_is_composite(self):
2298         if self > 1:
2299             return fuzzy_not(self.is_prime)
2300         else:
2301             return False
2302 
2303     def as_numer_denom(self):
2304         return self, S.One
2305 
2306     def __floordiv__(self, other):
2307         return Integer(self.p // Integer(other).p)
2308 
2309     def __rfloordiv__(self, other):
2310         return Integer(Integer(other).p // self.p)
2311 
2312 # Add sympify converters
2313 for i_type in integer_types:
2314     converter[i_type] = Integer
2315 
2316 
2317 class AlgebraicNumber(Expr):
2318     """Class for representing algebraic numbers in SymPy. """
2319 
2320     __slots__ = ['rep', 'root', 'alias', 'minpoly']
2321 
2322     is_AlgebraicNumber = True
2323     is_algebraic = True
2324     is_number = True
2325 
2326     def __new__(cls, expr, coeffs=None, alias=None, **args):
2327         """Construct a new algebraic number. """
2328         from sympy import Poly
2329         from sympy.polys.polyclasses import ANP, DMP
2330         from sympy.polys.numberfields import minimal_polynomial
2331         from sympy.core.symbol import Symbol
2332 
2333         expr = sympify(expr)
2334 
2335         if isinstance(expr, (tuple, Tuple)):
2336             minpoly, root = expr
2337 
2338             if not minpoly.is_Poly:
2339                 minpoly = Poly(minpoly)
2340         elif expr.is_AlgebraicNumber:
2341             minpoly, root = expr.minpoly, expr.root
2342         else:
2343             minpoly, root = minimal_polynomial(
2344                 expr, args.get('gen'), polys=True), expr
2345 
2346         dom = minpoly.get_domain()
2347 
2348         if coeffs is not None:
2349             if not isinstance(coeffs, ANP):
2350                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)
2351                 scoeffs = Tuple(*coeffs)
2352             else:
2353                 rep = DMP.from_list(coeffs.to_list(), 0, dom)
2354                 scoeffs = Tuple(*coeffs.to_list())
2355 
2356             if rep.degree() >= minpoly.degree():
2357                 rep = rep.rem(minpoly.rep)
2358 
2359         else:
2360             rep = DMP.from_list([1, 0], 0, dom)
2361             scoeffs = Tuple(1, 0)
2362 
2363         sargs = (root, scoeffs)
2364 
2365         if alias is not None:
2366             if not isinstance(alias, Symbol):
2367                 alias = Symbol(alias)
2368             sargs = sargs + (alias,)
2369 
2370         obj = Expr.__new__(cls, *sargs)
2371 
2372         obj.rep = rep
2373         obj.root = root
2374         obj.alias = alias
2375         obj.minpoly = minpoly
2376 
2377         return obj
2378 
2379     def __hash__(self):
2380         return super(AlgebraicNumber, self).__hash__()
2381 
2382     def _eval_evalf(self, prec):
2383         return self.as_expr()._evalf(prec)
2384 
2385     @property
2386     def is_aliased(self):
2387         """Returns ``True`` if ``alias`` was set. """
2388         return self.alias is not None
2389 
2390     def as_poly(self, x=None):
2391         """Create a Poly instance from ``self``. """
2392         from sympy import Dummy, Poly, PurePoly
2393         if x is not None:
2394             return Poly.new(self.rep, x)
2395         else:
2396             if self.alias is not None:
2397                 return Poly.new(self.rep, self.alias)
2398             else:
2399                 return PurePoly.new(self.rep, Dummy('x'))
2400 
2401     def as_expr(self, x=None):
2402         """Create a Basic expression from ``self``. """
2403         return self.as_poly(x or self.root).as_expr().expand()
2404 
2405     def coeffs(self):
2406         """Returns all SymPy coefficients of an algebraic number. """
2407         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]
2408 
2409     def native_coeffs(self):
2410         """Returns all native coefficients of an algebraic number. """
2411         return self.rep.all_coeffs()
2412 
2413     def to_algebraic_integer(self):
2414         """Convert ``self`` to an algebraic integer. """
2415         from sympy import Poly
2416         f = self.minpoly
2417 
2418         if f.LC() == 1:
2419             return self
2420 
2421         coeff = f.LC()**(f.degree() - 1)
2422         poly = f.compose(Poly(f.gen/f.LC()))
2423 
2424         minpoly = poly*coeff
2425         root = f.LC()*self.root
2426 
2427         return AlgebraicNumber((minpoly, root), self.coeffs())
2428 
2429     def _eval_simplify(self, ratio, measure, rational, inverse):
2430         from sympy.polys import CRootOf, minpoly
2431 
2432         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:
2433             if minpoly(self.root - r).is_Symbol:
2434                 # use the matching root if it's simpler
2435                 if measure(r) < ratio*measure(self.root):
2436                     return AlgebraicNumber(r)
2437         return self
2438 
2439 
2440 class RationalConstant(Rational):
2441     """
2442     Abstract base class for rationals with specific behaviors
2443 
2444     Derived classes must define class attributes p and q and should probably all
2445     be singletons.
2446     """
2447     __slots__ = []
2448 
2449     def __new__(cls):
2450         return AtomicExpr.__new__(cls)
2451 
2452 
2453 class IntegerConstant(Integer):
2454     __slots__ = []
2455 
2456     def __new__(cls):
2457         return AtomicExpr.__new__(cls)
2458 
2459 
2460 class Zero(with_metaclass(Singleton, IntegerConstant)):
2461     """The number zero.
2462 
2463     Zero is a singleton, and can be accessed by ``S.Zero``
2464 
2465     Examples
2466     ========
2467 
2468     >>> from sympy import S, Integer, zoo
2469     >>> Integer(0) is S.Zero
2470     True
2471     >>> 1/S.Zero
2472     zoo
2473 
2474     References
2475     ==========
2476 
2477     .. [1] https://en.wikipedia.org/wiki/Zero
2478     """
2479 
2480     p = 0
2481     q = 1
2482     is_positive = False
2483     is_negative = False
2484     is_zero = True
2485     is_number = True
2486 
2487     __slots__ = []
2488 
2489     @staticmethod
2490     def __abs__():
2491         return S.Zero
2492 
2493     @staticmethod
2494     def __neg__():
2495         return S.Zero
2496 
2497     def _eval_power(self, expt):
2498         if expt.is_positive:
2499             return self
2500         if expt.is_negative:
2501             return S.ComplexInfinity
2502         if expt.is_real is False:
2503             return S.NaN
2504         # infinities are already handled with pos and neg
2505         # tests above; now throw away leading numbers on Mul
2506         # exponent
2507         coeff, terms = expt.as_coeff_Mul()
2508         if coeff.is_negative:
2509             return S.ComplexInfinity**terms
2510         if coeff is not S.One:  # there is a Number to discard
2511             return self**terms
2512 
2513     def _eval_order(self, *symbols):
2514         # Order(0,x) -> 0
2515         return self
2516 
2517     def __nonzero__(self):
2518         return False
2519 
2520     __bool__ = __nonzero__
2521 
2522     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted
2523         """Efficiently extract the coefficient of a summation. """
2524         return S.One, self
2525 
2526 
2527 class One(with_metaclass(Singleton, IntegerConstant)):
2528     """The number one.
2529 
2530     One is a singleton, and can be accessed by ``S.One``.
2531 
2532     Examples
2533     ========
2534 
2535     >>> from sympy import S, Integer
2536     >>> Integer(1) is S.One
2537     True
2538 
2539     References
2540     ==========
2541 
2542     .. [1] https://en.wikipedia.org/wiki/1_%28number%29
2543     """
2544     is_number = True
2545 
2546     p = 1
2547     q = 1
2548 
2549     __slots__ = []
2550 
2551     @staticmethod
2552     def __abs__():
2553         return S.One
2554 
2555     @staticmethod
2556     def __neg__():
2557         return S.NegativeOne
2558 
2559     def _eval_power(self, expt):
2560         return self
2561 
2562     def _eval_order(self, *symbols):
2563         return
2564 
2565     @staticmethod
2566     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,
2567                 verbose=False, visual=False):
2568         if visual:
2569             return S.One
2570         else:
2571             return {}
2572 
2573 
2574 class NegativeOne(with_metaclass(Singleton, IntegerConstant)):
2575     """The number negative one.
2576 
2577     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.
2578 
2579     Examples
2580     ========
2581 
2582     >>> from sympy import S, Integer
2583     >>> Integer(-1) is S.NegativeOne
2584     True
2585 
2586     See Also
2587     ========
2588 
2589     One
2590 
2591     References
2592     ==========
2593 
2594     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29
2595 
2596     """
2597     is_number = True
2598 
2599     p = -1
2600     q = 1
2601 
2602     __slots__ = []
2603 
2604     @staticmethod
2605     def __abs__():
2606         return S.One
2607 
2608     @staticmethod
2609     def __neg__():
2610         return S.One
2611 
2612     def _eval_power(self, expt):
2613         if expt.is_odd:
2614             return S.NegativeOne
2615         if expt.is_even:
2616             return S.One
2617         if isinstance(expt, Number):
2618             if isinstance(expt, Float):
2619                 return Float(-1.0)**expt
2620             if expt is S.NaN:
2621                 return S.NaN
2622             if expt is S.Infinity or expt is S.NegativeInfinity:
2623                 return S.NaN
2624             if expt is S.Half:
2625                 return S.ImaginaryUnit
2626             if isinstance(expt, Rational):
2627                 if expt.q == 2:
2628                     return S.ImaginaryUnit**Integer(expt.p)
2629                 i, r = divmod(expt.p, expt.q)
2630                 if i:
2631                     return self**i*self**Rational(r, expt.q)
2632         return
2633 
2634 
2635 class Half(with_metaclass(Singleton, RationalConstant)):
2636     """The rational number 1/2.
2637 
2638     Half is a singleton, and can be accessed by ``S.Half``.
2639 
2640     Examples
2641     ========
2642 
2643     >>> from sympy import S, Rational
2644     >>> Rational(1, 2) is S.Half
2645     True
2646 
2647     References
2648     ==========
2649 
2650     .. [1] https://en.wikipedia.org/wiki/One_half
2651     """
2652     is_number = True
2653 
2654     p = 1
2655     q = 2
2656 
2657     __slots__ = []
2658 
2659     @staticmethod
2660     def __abs__():
2661         return S.Half
2662 
2663 
2664 class Infinity(with_metaclass(Singleton, Number)):
2665     r"""Positive infinite quantity.
2666 
2667     In real analysis the symbol `\infty` denotes an unbounded
2668     limit: `x\to\infty` means that `x` grows without bound.
2669 
2670     Infinity is often used not only to define a limit but as a value
2671     in the affinely extended real number system.  Points labeled `+\infty`
2672     and `-\infty` can be added to the topological space of the real numbers,
2673     producing the two-point compactification of the real numbers.  Adding
2674     algebraic properties to this gives us the extended real numbers.
2675 
2676     Infinity is a singleton, and can be accessed by ``S.Infinity``,
2677     or can be imported as ``oo``.
2678 
2679     Examples
2680     ========
2681 
2682     >>> from sympy import oo, exp, limit, Symbol
2683     >>> 1 + oo
2684     oo
2685     >>> 42/oo
2686     0
2687     >>> x = Symbol('x')
2688     >>> limit(exp(x), x, oo)
2689     oo
2690 
2691     See Also
2692     ========
2693 
2694     NegativeInfinity, NaN
2695 
2696     References
2697     ==========
2698 
2699     .. [1] https://en.wikipedia.org/wiki/Infinity
2700     """
2701 
2702     is_commutative = True
2703     is_positive = True
2704     is_infinite = True
2705     is_number = True
2706     is_prime = False
2707 
2708     __slots__ = []
2709 
2710     def __new__(cls):
2711         return AtomicExpr.__new__(cls)
2712 
2713     def _latex(self, printer):
2714         return r"\infty"
2715 
2716     def _eval_subs(self, old, new):
2717         if self == old:
2718             return new
2719 
2720     @_sympifyit('other', NotImplemented)
2721     def __add__(self, other):
2722         if isinstance(other, Number):
2723             if other is S.NegativeInfinity or other is S.NaN:
2724                 return S.NaN
2725             return self
2726         return NotImplemented
2727     __radd__ = __add__
2728 
2729     @_sympifyit('other', NotImplemented)
2730     def __sub__(self, other):
2731         if isinstance(other, Number):
2732             if other is S.Infinity or other is S.NaN:
2733                 return S.NaN
2734             return self
2735         return NotImplemented
2736 
2737     @_sympifyit('other', NotImplemented)
2738     def __rsub__(self, other):
2739         return (-self).__add__(other)
2740 
2741     @_sympifyit('other', NotImplemented)
2742     def __mul__(self, other):
2743         if isinstance(other, Number):
2744             if other.is_zero or other is S.NaN:
2745                 return S.NaN
2746             if other.is_positive:
2747                 return self
2748             return S.NegativeInfinity
2749         return NotImplemented
2750     __rmul__ = __mul__
2751 
2752     @_sympifyit('other', NotImplemented)
2753     def __div__(self, other):
2754         if isinstance(other, Number):
2755             if other is S.Infinity or \
2756                 other is S.NegativeInfinity or \
2757                     other is S.NaN:
2758                 return S.NaN
2759             if other.is_nonnegative:
2760                 return self
2761             return S.NegativeInfinity
2762         return NotImplemented
2763 
2764     __truediv__ = __div__
2765 
2766     def __abs__(self):
2767         return S.Infinity
2768 
2769     def __neg__(self):
2770         return S.NegativeInfinity
2771 
2772     def _eval_power(self, expt):
2773         """
2774         ``expt`` is symbolic object but not equal to 0 or 1.
2775 
2776         ================ ======= ==============================
2777         Expression       Result  Notes
2778         ================ ======= ==============================
2779         ``oo ** nan``    ``nan``
2780         ``oo ** -p``     ``0``   ``p`` is number, ``oo``
2781         ================ ======= ==============================
2782 
2783         See Also
2784         ========
2785         Pow
2786         NaN
2787         NegativeInfinity
2788 
2789         """
2790         from sympy.functions import re
2791 
2792         if expt.is_positive:
2793             return S.Infinity
2794         if expt.is_negative:
2795             return S.Zero
2796         if expt is S.NaN:
2797             return S.NaN
2798         if expt is S.ComplexInfinity:
2799             return S.NaN
2800         if expt.is_real is False and expt.is_number:
2801             expt_real = re(expt)
2802             if expt_real.is_positive:
2803                 return S.ComplexInfinity
2804             if expt_real.is_negative:
2805                 return S.Zero
2806             if expt_real.is_zero:
2807                 return S.NaN
2808 
2809             return self**expt.evalf()
2810 
2811     def _as_mpf_val(self, prec):
2812         return mlib.finf
2813 
2814     def _sage_(self):
2815         import sage.all as sage
2816         return sage.oo
2817 
2818     def __hash__(self):
2819         return super(Infinity, self).__hash__()
2820 
2821     def __eq__(self, other):
2822         return other is S.Infinity or other == float('inf')
2823 
2824     def __ne__(self, other):
2825         return other is not S.Infinity and other != float('inf')
2826 
2827     def __lt__(self, other):
2828         try:
2829             other = _sympify(other)
2830         except SympifyError:
2831             raise TypeError("Invalid comparison %s < %s" % (self, other))
2832         if other.is_real:
2833             return S.false
2834         return Expr.__lt__(self, other)
2835 
2836     def __le__(self, other):
2837         try:
2838             other = _sympify(other)
2839         except SympifyError:
2840             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2841         if other.is_real:
2842             if other.is_finite or other is S.NegativeInfinity:
2843                 return S.false
2844             elif other.is_nonpositive:
2845                 return S.false
2846             elif other.is_infinite and other.is_positive:
2847                 return S.true
2848         return Expr.__le__(self, other)
2849 
2850     def __gt__(self, other):
2851         try:
2852             other = _sympify(other)
2853         except SympifyError:
2854             raise TypeError("Invalid comparison %s > %s" % (self, other))
2855         if other.is_real:
2856             if other.is_finite or other is S.NegativeInfinity:
2857                 return S.true
2858             elif other.is_nonpositive:
2859                 return S.true
2860             elif other.is_infinite and other.is_positive:
2861                 return S.false
2862         return Expr.__gt__(self, other)
2863 
2864     def __ge__(self, other):
2865         try:
2866             other = _sympify(other)
2867         except SympifyError:
2868             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2869         if other.is_real:
2870             return S.true
2871         return Expr.__ge__(self, other)
2872 
2873     def __mod__(self, other):
2874         return S.NaN
2875 
2876     __rmod__ = __mod__
2877 
2878     def floor(self):
2879         return self
2880 
2881     def ceiling(self):
2882         return self
2883 
2884 oo = S.Infinity
2885 
2886 
2887 class NegativeInfinity(with_metaclass(Singleton, Number)):
2888     """Negative infinite quantity.
2889 
2890     NegativeInfinity is a singleton, and can be accessed
2891     by ``S.NegativeInfinity``.
2892 
2893     See Also
2894     ========
2895 
2896     Infinity
2897     """
2898 
2899     is_commutative = True
2900     is_negative = True
2901     is_infinite = True
2902     is_number = True
2903 
2904     __slots__ = []
2905 
2906     def __new__(cls):
2907         return AtomicExpr.__new__(cls)
2908 
2909     def _latex(self, printer):
2910         return r"-\infty"
2911 
2912     def _eval_subs(self, old, new):
2913         if self == old:
2914             return new
2915 
2916     @_sympifyit('other', NotImplemented)
2917     def __add__(self, other):
2918         if isinstance(other, Number):
2919             if other is S.Infinity or other is S.NaN:
2920                 return S.NaN
2921             return self
2922         return NotImplemented
2923     __radd__ = __add__
2924 
2925     @_sympifyit('other', NotImplemented)
2926     def __sub__(self, other):
2927         if isinstance(other, Number):
2928             if other is S.NegativeInfinity or other is S.NaN:
2929                 return S.NaN
2930             return self
2931         return NotImplemented
2932 
2933     @_sympifyit('other', NotImplemented)
2934     def __rsub__(self, other):
2935         return (-self).__add__(other)
2936 
2937     @_sympifyit('other', NotImplemented)
2938     def __mul__(self, other):
2939         if isinstance(other, Number):
2940             if other.is_zero or other is S.NaN:
2941                 return S.NaN
2942             if other.is_positive:
2943                 return self
2944             return S.Infinity
2945         return NotImplemented
2946     __rmul__ = __mul__
2947 
2948     @_sympifyit('other', NotImplemented)
2949     def __div__(self, other):
2950         if isinstance(other, Number):
2951             if other is S.Infinity or \
2952                 other is S.NegativeInfinity or \
2953                     other is S.NaN:
2954                 return S.NaN
2955             if other.is_nonnegative:
2956                 return self
2957             return S.Infinity
2958         return NotImplemented
2959 
2960     __truediv__ = __div__
2961 
2962     def __abs__(self):
2963         return S.Infinity
2964 
2965     def __neg__(self):
2966         return S.Infinity
2967 
2968     def _eval_power(self, expt):
2969         """
2970         ``expt`` is symbolic object but not equal to 0 or 1.
2971 
2972         ================ ======= ==============================
2973         Expression       Result  Notes
2974         ================ ======= ==============================
2975         ``(-oo) ** nan`` ``nan``
2976         ``(-oo) ** oo``  ``nan``
2977         ``(-oo) ** -oo`` ``nan``
2978         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer
2979         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer
2980         ================ ======= ==============================
2981 
2982         See Also
2983         ========
2984 
2985         Infinity
2986         Pow
2987         NaN
2988 
2989         """
2990         if expt.is_number:
2991             if expt is S.NaN or \
2992                 expt is S.Infinity or \
2993                     expt is S.NegativeInfinity:
2994                 return S.NaN
2995 
2996             if isinstance(expt, Integer) and expt.is_positive:
2997                 if expt.is_odd:
2998                     return S.NegativeInfinity
2999                 else:
3000                     return S.Infinity
3001 
3002             return S.NegativeOne**expt*S.Infinity**expt
3003 
3004     def _as_mpf_val(self, prec):
3005         return mlib.fninf
3006 
3007     def _sage_(self):
3008         import sage.all as sage
3009         return -(sage.oo)
3010 
3011     def __hash__(self):
3012         return super(NegativeInfinity, self).__hash__()
3013 
3014     def __eq__(self, other):
3015         return other is S.NegativeInfinity or other == float('-inf')
3016 
3017     def __ne__(self, other):
3018         return other is not S.NegativeInfinity and other != float('-inf')
3019 
3020     def __lt__(self, other):
3021         try:
3022             other = _sympify(other)
3023         except SympifyError:
3024             raise TypeError("Invalid comparison %s < %s" % (self, other))
3025         if other.is_real:
3026             if other.is_finite or other is S.Infinity:
3027                 return S.true
3028             elif other.is_nonnegative:
3029                 return S.true
3030             elif other.is_infinite and other.is_negative:
3031                 return S.false
3032         return Expr.__lt__(self, other)
3033 
3034     def __le__(self, other):
3035         try:
3036             other = _sympify(other)
3037         except SympifyError:
3038             raise TypeError("Invalid comparison %s <= %s" % (self, other))
3039         if other.is_real:
3040             return S.true
3041         return Expr.__le__(self, other)
3042 
3043     def __gt__(self, other):
3044         try:
3045             other = _sympify(other)
3046         except SympifyError:
3047             raise TypeError("Invalid comparison %s > %s" % (self, other))
3048         if other.is_real:
3049             return S.false
3050         return Expr.__gt__(self, other)
3051 
3052     def __ge__(self, other):
3053         try:
3054             other = _sympify(other)
3055         except SympifyError:
3056             raise TypeError("Invalid comparison %s >= %s" % (self, other))
3057         if other.is_real:
3058             if other.is_finite or other is S.Infinity:
3059                 return S.false
3060             elif other.is_nonnegative:
3061                 return S.false
3062             elif other.is_infinite and other.is_negative:
3063                 return S.true
3064         return Expr.__ge__(self, other)
3065 
3066     def __mod__(self, other):
3067         return S.NaN
3068 
3069     __rmod__ = __mod__
3070 
3071     def floor(self):
3072         return self
3073 
3074     def ceiling(self):
3075         return self
3076 
3077 
3078 class NaN(with_metaclass(Singleton, Number)):
3079     """
3080     Not a Number.
3081 
3082     This serves as a place holder for numeric values that are indeterminate.
3083     Most operations on NaN, produce another NaN.  Most indeterminate forms,
3084     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``
3085     and ``oo**0``, which all produce ``1`` (this is consistent with Python's
3086     float).
3087 
3088     NaN is loosely related to floating point nan, which is defined in the
3089     IEEE 754 floating point standard, and corresponds to the Python
3090     ``float('nan')``.  Differences are noted below.
3091 
3092     NaN is mathematically not equal to anything else, even NaN itself.  This
3093     explains the initially counter-intuitive results with ``Eq`` and ``==`` in
3094     the examples below.
3095 
3096     NaN is not comparable so inequalities raise a TypeError.  This is in
3097     constrast with floating point nan where all inequalities are false.
3098 
3099     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported
3100     as ``nan``.
3101 
3102     Examples
3103     ========
3104 
3105     >>> from sympy import nan, S, oo, Eq
3106     >>> nan is S.NaN
3107     True
3108     >>> oo - oo
3109     nan
3110     >>> nan + 1
3111     nan
3112     >>> Eq(nan, nan)   # mathematical equality
3113     False
3114     >>> nan == nan     # structural equality
3115     True
3116 
3117     References
3118     ==========
3119 
3120     .. [1] https://en.wikipedia.org/wiki/NaN
3121 
3122     """
3123     is_commutative = True
3124     is_real = None
3125     is_rational = None
3126     is_algebraic = None
3127     is_transcendental = None
3128     is_integer = None
3129     is_comparable = False
3130     is_finite = None
3131     is_zero = None
3132     is_prime = None
3133     is_positive = None
3134     is_negative = None
3135     is_number = True
3136 
3137     __slots__ = []
3138 
3139     def __new__(cls):
3140         return AtomicExpr.__new__(cls)
3141 
3142     def _latex(self, printer):
3143         return r"\text{NaN}"
3144 
3145     @_sympifyit('other', NotImplemented)
3146     def __add__(self, other):
3147         return self
3148 
3149     @_sympifyit('other', NotImplemented)
3150     def __sub__(self, other):
3151         return self
3152 
3153     @_sympifyit('other', NotImplemented)
3154     def __mul__(self, other):
3155         return self
3156 
3157     @_sympifyit('other', NotImplemented)
3158     def __div__(self, other):
3159         return self
3160 
3161     __truediv__ = __div__
3162 
3163     def floor(self):
3164         return self
3165 
3166     def ceiling(self):
3167         return self
3168 
3169     def _as_mpf_val(self, prec):
3170         return _mpf_nan
3171 
3172     def _sage_(self):
3173         import sage.all as sage
3174         return sage.NaN
3175 
3176     def __hash__(self):
3177         return super(NaN, self).__hash__()
3178 
3179     def __eq__(self, other):
3180         # NaN is structurally equal to another NaN
3181         return other is S.NaN
3182 
3183     def __ne__(self, other):
3184         return other is not S.NaN
3185 
3186     def _eval_Eq(self, other):
3187         # NaN is not mathematically equal to anything, even NaN
3188         return S.false
3189 
3190     # Expr will _sympify and raise TypeError
3191     __gt__ = Expr.__gt__
3192     __ge__ = Expr.__ge__
3193     __lt__ = Expr.__lt__
3194     __le__ = Expr.__le__
3195 
3196 nan = S.NaN
3197 
3198 
3199 class ComplexInfinity(with_metaclass(Singleton, AtomicExpr)):
3200     r"""Complex infinity.
3201 
3202     In complex analysis the symbol `\tilde\infty`, called "complex
3203     infinity", represents a quantity with infinite magnitude, but
3204     undetermined complex phase.
3205 
3206     ComplexInfinity is a singleton, and can be accessed by
3207     ``S.ComplexInfinity``, or can be imported as ``zoo``.
3208 
3209     Examples
3210     ========
3211 
3212     >>> from sympy import zoo, oo
3213     >>> zoo + 42
3214     zoo
3215     >>> 42/zoo
3216     0
3217     >>> zoo + zoo
3218     nan
3219     >>> zoo*zoo
3220     zoo
3221 
3222     See Also
3223     ========
3224 
3225     Infinity
3226     """
3227 
3228     is_commutative = True
3229     is_infinite = True
3230     is_number = True
3231     is_prime = False
3232     is_complex = True
3233     is_real = False
3234 
3235     __slots__ = []
3236 
3237     def __new__(cls):
3238         return AtomicExpr.__new__(cls)
3239 
3240     def _latex(self, printer):
3241         return r"\tilde{\infty}"
3242 
3243     @staticmethod
3244     def __abs__():
3245         return S.Infinity
3246 
3247     def floor(self):
3248         return self
3249 
3250     def ceiling(self):
3251         return self
3252 
3253     @staticmethod
3254     def __neg__():
3255         return S.ComplexInfinity
3256 
3257     def _eval_power(self, expt):
3258         if expt is S.ComplexInfinity:
3259             return S.NaN
3260 
3261         if isinstance(expt, Number):
3262             if expt is S.Zero:
3263                 return S.NaN
3264             else:
3265                 if expt.is_positive:
3266                     return S.ComplexInfinity
3267                 else:
3268                     return S.Zero
3269 
3270     def _sage_(self):
3271         import sage.all as sage
3272         return sage.UnsignedInfinityRing.gen()
3273 
3274 
3275 zoo = S.ComplexInfinity
3276 
3277 
3278 class NumberSymbol(AtomicExpr):
3279 
3280     is_commutative = True
3281     is_finite = True
3282     is_number = True
3283 
3284     __slots__ = []
3285 
3286     is_NumberSymbol = True
3287 
3288     def __new__(cls):
3289         return AtomicExpr.__new__(cls)
3290 
3291     def approximation(self, number_cls):
3292         """ Return an interval with number_cls endpoints
3293         that contains the value of NumberSymbol.
3294         If not implemented, then return None.
3295         """
3296 
3297     def _eval_evalf(self, prec):
3298         return Float._new(self._as_mpf_val(prec), prec)
3299 
3300     def __eq__(self, other):
3301         try:
3302             other = _sympify(other)
3303         except SympifyError:
3304             return NotImplemented
3305         if self is other:
3306             return True
3307         if other.is_Number and self.is_irrational:
3308             return False
3309 
3310         return False    # NumberSymbol != non-(Number|self)
3311 
3312     def __ne__(self, other):
3313         return not self == other
3314 
3315     def __le__(self, other):
3316         if self is other:
3317             return S.true
3318         return Expr.__le__(self, other)
3319 
3320     def __ge__(self, other):
3321         if self is other:
3322             return S.true
3323         return Expr.__ge__(self, other)
3324 
3325     def __int__(self):
3326         # subclass with appropriate return value
3327         raise NotImplementedError
3328 
3329     def __long__(self):
3330         return self.__int__()
3331 
3332     def __hash__(self):
3333         return super(NumberSymbol, self).__hash__()
3334 
3335 
3336 class Exp1(with_metaclass(Singleton, NumberSymbol)):
3337     r"""The `e` constant.
3338 
3339     The transcendental number `e = 2.718281828\ldots` is the base of the
3340     natural logarithm and of the exponential function, `e = \exp(1)`.
3341     Sometimes called Euler's number or Napier's constant.
3342 
3343     Exp1 is a singleton, and can be accessed by ``S.Exp1``,
3344     or can be imported as ``E``.
3345 
3346     Examples
3347     ========
3348 
3349     >>> from sympy import exp, log, E
3350     >>> E is exp(1)
3351     True
3352     >>> log(E)
3353     1
3354 
3355     References
3356     ==========
3357 
3358     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29
3359     """
3360 
3361     is_real = True
3362     is_positive = True
3363     is_negative = False  # XXX Forces is_negative/is_nonnegative
3364     is_irrational = True
3365     is_number = True
3366     is_algebraic = False
3367     is_transcendental = True
3368 
3369     __slots__ = []
3370 
3371     def _latex(self, printer):
3372         return r"e"
3373 
3374     @staticmethod
3375     def __abs__():
3376         return S.Exp1
3377 
3378     def __int__(self):
3379         return 2
3380 
3381     def _as_mpf_val(self, prec):
3382         return mpf_e(prec)
3383 
3384     def approximation_interval(self, number_cls):
3385         if issubclass(number_cls, Integer):
3386             return (Integer(2), Integer(3))
3387         elif issubclass(number_cls, Rational):
3388             pass
3389 
3390     def _eval_power(self, expt):
3391         from sympy import exp
3392         return exp(expt)
3393 
3394     def _eval_rewrite_as_sin(self, **kwargs):
3395         from sympy import sin
3396         I = S.ImaginaryUnit
3397         return sin(I + S.Pi/2) - I*sin(I)
3398 
3399     def _eval_rewrite_as_cos(self, **kwargs):
3400         from sympy import cos
3401         I = S.ImaginaryUnit
3402         return cos(I) + I*cos(I + S.Pi/2)
3403 
3404     def _sage_(self):
3405         import sage.all as sage
3406         return sage.e
3407 E = S.Exp1
3408 
3409 
3410 class Pi(with_metaclass(Singleton, NumberSymbol)):
3411     r"""The `\pi` constant.
3412 
3413     The transcendental number `\pi = 3.141592654\ldots` represents the ratio
3414     of a circle's circumference to its diameter, the area of the unit circle,
3415     the half-period of trigonometric functions, and many other things
3416     in mathematics.
3417 
3418     Pi is a singleton, and can be accessed by ``S.Pi``, or can
3419     be imported as ``pi``.
3420 
3421     Examples
3422     ========
3423 
3424     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol
3425     >>> S.Pi
3426     pi
3427     >>> pi > 3
3428     True
3429     >>> pi.is_irrational
3430     True
3431     >>> x = Symbol('x')
3432     >>> sin(x + 2*pi)
3433     sin(x)
3434     >>> integrate(exp(-x**2), (x, -oo, oo))
3435     sqrt(pi)
3436 
3437     References
3438     ==========
3439 
3440     .. [1] https://en.wikipedia.org/wiki/Pi
3441     """
3442 
3443     is_real = True
3444     is_positive = True
3445     is_negative = False
3446     is_irrational = True
3447     is_number = True
3448     is_algebraic = False
3449     is_transcendental = True
3450 
3451     __slots__ = []
3452 
3453     def _latex(self, printer):
3454         return r"\pi"
3455 
3456     @staticmethod
3457     def __abs__():
3458         return S.Pi
3459 
3460     def __int__(self):
3461         return 3
3462 
3463     def _as_mpf_val(self, prec):
3464         return mpf_pi(prec)
3465 
3466     def approximation_interval(self, number_cls):
3467         if issubclass(number_cls, Integer):
3468             return (Integer(3), Integer(4))
3469         elif issubclass(number_cls, Rational):
3470             return (Rational(223, 71), Rational(22, 7))
3471 
3472     def _sage_(self):
3473         import sage.all as sage
3474         return sage.pi
3475 pi = S.Pi
3476 
3477 
3478 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):
3479     r"""The golden ratio, `\phi`.
3480 
3481     `\phi = \frac{1 + \sqrt{5}}{2}` is algebraic number.  Two quantities
3482     are in the golden ratio if their ratio is the same as the ratio of
3483     their sum to the larger of the two quantities, i.e. their maximum.
3484 
3485     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.
3486 
3487     Examples
3488     ========
3489 
3490     >>> from sympy import S
3491     >>> S.GoldenRatio > 1
3492     True
3493     >>> S.GoldenRatio.expand(func=True)
3494     1/2 + sqrt(5)/2
3495     >>> S.GoldenRatio.is_irrational
3496     True
3497 
3498     References
3499     ==========
3500 
3501     .. [1] https://en.wikipedia.org/wiki/Golden_ratio
3502     """
3503 
3504     is_real = True
3505     is_positive = True
3506     is_negative = False
3507     is_irrational = True
3508     is_number = True
3509     is_algebraic = True
3510     is_transcendental = False
3511 
3512     __slots__ = []
3513 
3514     def _latex(self, printer):
3515         return r"\phi"
3516 
3517     def __int__(self):
3518         return 1
3519 
3520     def _as_mpf_val(self, prec):
3521          # XXX track down why this has to be increased
3522         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
3523         return mpf_norm(rv, prec)
3524 
3525     def _eval_expand_func(self, **hints):
3526         from sympy import sqrt
3527         return S.Half + S.Half*sqrt(5)
3528 
3529     def approximation_interval(self, number_cls):
3530         if issubclass(number_cls, Integer):
3531             return (S.One, Rational(2))
3532         elif issubclass(number_cls, Rational):
3533             pass
3534 
3535     def _sage_(self):
3536         import sage.all as sage
3537         return sage.golden_ratio
3538 
3539     _eval_rewrite_as_sqrt = _eval_expand_func
3540 
3541 
3542 class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):
3543     r"""The tribonacci constant.
3544 
3545     The tribonacci numbers are like the Fibonacci numbers, but instead
3546     of starting with two predetermined terms, the sequence starts with
3547     three predetermined terms and each term afterwards is the sum of the
3548     preceding three terms.
3549 
3550     The tribonacci constant is the ratio toward which adjacent tribonacci
3551     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,
3552     and also satisfies the equation `x + x^{-3} = 2`.
3553 
3554     TribonacciConstant is a singleton, and can be accessed
3555     by ``S.TribonacciConstant``.
3556 
3557     Examples
3558     ========
3559 
3560     >>> from sympy import S
3561     >>> S.TribonacciConstant > 1
3562     True
3563     >>> S.TribonacciConstant.expand(func=True)
3564     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3
3565     >>> S.TribonacciConstant.is_irrational
3566     True
3567     >>> S.TribonacciConstant.n(20)
3568     1.8392867552141611326
3569 
3570     References
3571     ==========
3572 
3573     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers
3574     """
3575 
3576     is_real = True
3577     is_positive = True
3578     is_negative = False
3579     is_irrational = True
3580     is_number = True
3581     is_algebraic = True
3582     is_transcendental = False
3583 
3584     __slots__ = []
3585 
3586     def _latex(self, printer):
3587         return r"\text{TribonacciConstant}"
3588 
3589     def __int__(self):
3590         return 2
3591 
3592     def _eval_evalf(self, prec):
3593         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)
3594         return Float(rv, precision=prec)
3595 
3596     def _eval_expand_func(self, **hints):
3597         from sympy import sqrt, cbrt
3598         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3
3599 
3600     def approximation_interval(self, number_cls):
3601         if issubclass(number_cls, Integer):
3602             return (S.One, Rational(2))
3603         elif issubclass(number_cls, Rational):
3604             pass
3605 
3606     _eval_rewrite_as_sqrt = _eval_expand_func
3607 
3608 
3609 class EulerGamma(with_metaclass(Singleton, NumberSymbol)):
3610     r"""The Euler-Mascheroni constant.
3611 
3612     `\gamma = 0.5772157\ldots` (also called Euler's constant) is a mathematical
3613     constant recurring in analysis and number theory.  It is defined as the
3614     limiting difference between the harmonic series and the
3615     natural logarithm:
3616 
3617     .. math:: \gamma = \lim\limits_{n\to\infty}
3618               \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln n\right)
3619 
3620     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.
3621 
3622     Examples
3623     ========
3624 
3625     >>> from sympy import S
3626     >>> S.EulerGamma.is_irrational
3627     >>> S.EulerGamma > 0
3628     True
3629     >>> S.EulerGamma > 1
3630     False
3631 
3632     References
3633     ==========
3634 
3635     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant
3636     """
3637 
3638     is_real = True
3639     is_positive = True
3640     is_negative = False
3641     is_irrational = None
3642     is_number = True
3643 
3644     __slots__ = []
3645 
3646     def _latex(self, printer):
3647         return r"\gamma"
3648 
3649     def __int__(self):
3650         return 0
3651 
3652     def _as_mpf_val(self, prec):
3653          # XXX track down why this has to be increased
3654         v = mlib.libhyper.euler_fixed(prec + 10)
3655         rv = mlib.from_man_exp(v, -prec - 10)
3656         return mpf_norm(rv, prec)
3657 
3658     def approximation_interval(self, number_cls):
3659         if issubclass(number_cls, Integer):
3660             return (S.Zero, S.One)
3661         elif issubclass(number_cls, Rational):
3662             return (S.Half, Rational(3, 5))
3663 
3664     def _sage_(self):
3665         import sage.all as sage
3666         return sage.euler_gamma
3667 
3668 
3669 class Catalan(with_metaclass(Singleton, NumberSymbol)):
3670     r"""Catalan's constant.
3671 
3672     `K = 0.91596559\ldots` is given by the infinite series
3673 
3674     .. math:: K = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}
3675 
3676     Catalan is a singleton, and can be accessed by ``S.Catalan``.
3677 
3678     Examples
3679     ========
3680 
3681     >>> from sympy import S
3682     >>> S.Catalan.is_irrational
3683     >>> S.Catalan > 0
3684     True
3685     >>> S.Catalan > 1
3686     False
3687 
3688     References
3689     ==========
3690 
3691     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant
3692     """
3693 
3694     is_real = True
3695     is_positive = True
3696     is_negative = False
3697     is_irrational = None
3698     is_number = True
3699 
3700     __slots__ = []
3701 
3702     def __int__(self):
3703         return 0
3704 
3705     def _as_mpf_val(self, prec):
3706         # XXX track down why this has to be increased
3707         v = mlib.catalan_fixed(prec + 10)
3708         rv = mlib.from_man_exp(v, -prec - 10)
3709         return mpf_norm(rv, prec)
3710 
3711     def approximation_interval(self, number_cls):
3712         if issubclass(number_cls, Integer):
3713             return (S.Zero, S.One)
3714         elif issubclass(number_cls, Rational):
3715             return (Rational(9, 10), S.One)
3716 
3717     def _sage_(self):
3718         import sage.all as sage
3719         return sage.catalan
3720 
3721 
3722 class ImaginaryUnit(with_metaclass(Singleton, AtomicExpr)):
3723     r"""The imaginary unit, `i = \sqrt{-1}`.
3724 
3725     I is a singleton, and can be accessed by ``S.I``, or can be
3726     imported as ``I``.
3727 
3728     Examples
3729     ========
3730 
3731     >>> from sympy import I, sqrt
3732     >>> sqrt(-1)
3733     I
3734     >>> I*I
3735     -1
3736     >>> 1/I
3737     -I
3738 
3739     References
3740     ==========
3741 
3742     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit
3743     """
3744 
3745     is_commutative = True
3746     is_imaginary = True
3747     is_finite = True
3748     is_number = True
3749     is_algebraic = True
3750     is_transcendental = False
3751 
3752     __slots__ = []
3753 
3754     def _latex(self, printer):
3755         return printer._settings['imaginary_unit_latex']
3756 
3757     @staticmethod
3758     def __abs__():
3759         return S.One
3760 
3761     def _eval_evalf(self, prec):
3762         return self
3763 
3764     def _eval_conjugate(self):
3765         return -S.ImaginaryUnit
3766 
3767     def _eval_power(self, expt):
3768         """
3769         b is I = sqrt(-1)
3770         e is symbolic object but not equal to 0, 1
3771 
3772         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal
3773         I**0 mod 4 -> 1
3774         I**1 mod 4 -> I
3775         I**2 mod 4 -> -1
3776         I**3 mod 4 -> -I
3777         """
3778 
3779         if isinstance(expt, Number):
3780             if isinstance(expt, Integer):
3781                 expt = expt.p % 4
3782                 if expt == 0:
3783                     return S.One
3784                 if expt == 1:
3785                     return S.ImaginaryUnit
3786                 if expt == 2:
3787                     return -S.One
3788                 return -S.ImaginaryUnit
3789         return
3790 
3791     def as_base_exp(self):
3792         return S.NegativeOne, S.Half
3793 
3794     def _sage_(self):
3795         import sage.all as sage
3796         return sage.I
3797 
3798     @property
3799     def _mpc_(self):
3800         return (Float(0)._mpf_, Float(1)._mpf_)
3801 
3802 I = S.ImaginaryUnit
3803 
3804 
3805 def sympify_fractions(f):
3806     return Rational(f.numerator, f.denominator, 1)
3807 
3808 converter[fractions.Fraction] = sympify_fractions
3809 
3810 try:
3811     if HAS_GMPY == 2:
3812         import gmpy2 as gmpy
3813     elif HAS_GMPY == 1:
3814         import gmpy
3815     else:
3816         raise ImportError
3817 
3818     def sympify_mpz(x):
3819         return Integer(long(x))
3820 
3821     def sympify_mpq(x):
3822         return Rational(long(x.numerator), long(x.denominator))
3823 
3824     converter[type(gmpy.mpz(1))] = sympify_mpz
3825     converter[type(gmpy.mpq(1, 2))] = sympify_mpq
3826 except ImportError:
3827     pass
3828 
3829 
3830 def sympify_mpmath(x):
3831     return Expr._from_mpmath(x, x.context.prec)
3832 
3833 converter[mpnumeric] = sympify_mpmath
3834 
3835 
3836 def sympify_mpq(x):
3837     p, q = x._mpq_
3838     return Rational(p, q, 1)
3839 
3840 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpq
3841 
3842 
3843 def sympify_complex(a):
3844     real, imag = list(map(sympify, (a.real, a.imag)))
3845     return real + S.ImaginaryUnit*imag
3846 
3847 converter[complex] = sympify_complex
3848 
3849 from .power import Pow, integer_nthroot
3850 from .mul import Mul
3851 Mul.identity = One()
3852 from .add import Add
3853 Add.identity = Zero()
3854 
3855 def _register_classes():
3856     numbers.Number.register(Number)
3857     numbers.Real.register(Float)
3858     numbers.Rational.register(Rational)
3859     numbers.Rational.register(Integer)
3860 
3861 _register_classes()

</code><intended_behavior>The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result.</intended_behavior>]
2025-10-18 08:37:07.234 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 08:37:07.234 | INFO     | Search-only: skipping patch selection
2025-10-18 08:37:07.312 | INFO     | Task sympy__sympy-16840 completed successfully.
2025-10-18 08:37:07.313 | INFO     | No patch generated. You can try running ACR again.
