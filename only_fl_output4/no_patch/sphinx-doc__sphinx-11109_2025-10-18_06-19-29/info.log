2025-10-18 06:19:29.539 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:19:33.822 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=344, output_tokens=12, cost=0.003800
2025-10-18 06:19:33.823 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 06:19:33.831 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:19:39.031 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=650, output_tokens=226, cost=0.013280
2025-10-18 06:19:39.040 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:19:42.594 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=580, output_tokens=42, cost=0.007060
2025-10-18 06:19:42.595 | DEBUG    | Extracted a valid json.
2025-10-18 06:19:42.595 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"_parse_annotation\")",
        "search_code(\"config\")",
        "search_code(\"Literal\")"
    ],
    "bug_locations": []
}
2025-10-18 06:19:43.408 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:19:43.408 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:19:59.396 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4043, output_tokens=762, cost=0.063290
2025-10-18 06:19:59.592 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:20:09.644 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5021, output_tokens=418, cost=0.062750
2025-10-18 06:20:09.649 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:20:18.118 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=772, output_tokens=360, cost=0.018520
2025-10-18 06:20:18.119 | DEBUG    | Extracted a valid json.
2025-10-18 06:20:18.119 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/domains/python.py",
            "class": "",
            "method": "_parse_annotation",
            "intended_behavior": "This method should be modified to ensure it cleanly supports the formatting changes described in the issue: For 'Union' types, translate 'Union[X, Y, Z]' to 'X | Y | Z'. For 'Optional' types, translate 'Optional[X]' to 'X | None'. For 'Literal' types, translate 'Literal[\"X\"]' to '\"X\"'. Additionally, ensure 'Literal' values are displayed without the 'Literal' prefix and are highlighted using normal Python syntax highlighting. This might involve identifying 'Literal' usage within the AST parsing logic and transforming the associated nodes accordingly. These modifications should preserve existing functionality, ensuring that all other annotation types continue to be parsed and displayed as before. The changes to 'Union', 'Optional', and 'Literal' handling should only apply when a new configuration option is enabled."
        },
        {
            "file": "sphinx/config.py",
            "class": "",
            "method": "",
            "intended_behavior": "Introduce a new configuration option (e.g., 'simplified_type_annotations') that users can set in their project's 'conf.py' to enable or disable the simplified formatting of type annotations. The default behavior (with the option disabled) should preserve the current formatting of type annotations. Implement the logic to check this configuration option within '_parse_annotation' function (or relevant functions) and apply the new formatting rules accordingly. This ensures that the enhancements are opt-in, allowing users to upgrade Sphinx without forcing them to adopt the new annotation formatting immediately."
        }
    ]
}
2025-10-18 06:20:18.124 | DEBUG    | Bug location extracted successfully: [<file>sphinx/domains/python.py</file>
<class>None</class>
<method>_parse_annotation</method>
<code>
131 def _parse_annotation(annotation: str, env: BuildEnvironment | None) -> list[Node]:
132     """Parse type annotation."""
133     def unparse(node: ast.AST) -> list[Node]:
134         if isinstance(node, ast.Attribute):
135             return [nodes.Text(f"{unparse(node.value)[0]}.{node.attr}")]
136         if isinstance(node, ast.BinOp):
137             result: list[Node] = unparse(node.left)
138             result.extend(unparse(node.op))
139             result.extend(unparse(node.right))
140             return result
141         if isinstance(node, ast.BitOr):
142             return [addnodes.desc_sig_space(),
143                     addnodes.desc_sig_punctuation('', '|'),
144                     addnodes.desc_sig_space()]
145         if isinstance(node, ast.Constant):
146             if node.value is Ellipsis:
147                 return [addnodes.desc_sig_punctuation('', "...")]
148             if isinstance(node.value, bool):
149                 return [addnodes.desc_sig_keyword('', repr(node.value))]
150             if isinstance(node.value, int):
151                 return [addnodes.desc_sig_literal_number('', repr(node.value))]
152             if isinstance(node.value, str):
153                 return [addnodes.desc_sig_literal_string('', repr(node.value))]
154             else:
155                 # handles None, which is further handled by type_to_xref later
156                 # and fallback for other types that should be converted
157                 return [nodes.Text(repr(node.value))]
158         if isinstance(node, ast.Expr):
159             return unparse(node.value)
160         if isinstance(node, ast.Index):
161             return unparse(node.value)
162         if isinstance(node, ast.Invert):
163             return [addnodes.desc_sig_punctuation('', '~')]
164         if isinstance(node, ast.List):
165             result = [addnodes.desc_sig_punctuation('', '[')]
166             if node.elts:
167                 # check if there are elements in node.elts to only pop the
168                 # last element of result if the for-loop was run at least
169                 # once
170                 for elem in node.elts:
171                     result.extend(unparse(elem))
172                     result.append(addnodes.desc_sig_punctuation('', ','))
173                     result.append(addnodes.desc_sig_space())
174                 result.pop()
175                 result.pop()
176             result.append(addnodes.desc_sig_punctuation('', ']'))
177             return result
178         if isinstance(node, ast.Module):
179             return sum((unparse(e) for e in node.body), [])
180         if isinstance(node, ast.Name):
181             return [nodes.Text(node.id)]
182         if isinstance(node, ast.Subscript):
183             if getattr(node.value, 'id', '') in {'Optional', 'Union'}:
184                 return _unparse_pep_604_annotation(node)
185             result = unparse(node.value)
186             result.append(addnodes.desc_sig_punctuation('', '['))
187             result.extend(unparse(node.slice))
188             result.append(addnodes.desc_sig_punctuation('', ']'))
189 
190             # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal
191             if result[0] in ('Literal', 'typing.Literal'):
192                 for i, subnode in enumerate(result[1:], start=1):
193                     if isinstance(subnode, nodes.Text):
194                         result[i] = nodes.literal('', '', subnode)
195             return result
196         if isinstance(node, ast.UnaryOp):
197             return unparse(node.op) + unparse(node.operand)
198         if isinstance(node, ast.Tuple):
199             if node.elts:
200                 result = []
201                 for elem in node.elts:
202                     result.extend(unparse(elem))
203                     result.append(addnodes.desc_sig_punctuation('', ','))
204                     result.append(addnodes.desc_sig_space())
205                 result.pop()
206                 result.pop()
207             else:
208                 result = [addnodes.desc_sig_punctuation('', '('),
209                           addnodes.desc_sig_punctuation('', ')')]
210 
211             return result
212         raise SyntaxError  # unsupported syntax
213 
214     def _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:
215         subscript = node.slice
216         if isinstance(subscript, ast.Index):
217             # py38 only
218             subscript = subscript.value  # type: ignore[assignment]
219 
220         flattened: list[Node] = []
221         if isinstance(subscript, ast.Tuple):
222             flattened.extend(unparse(subscript.elts[0]))
223             for elt in subscript.elts[1:]:
224                 flattened.extend(unparse(ast.BitOr()))
225                 flattened.extend(unparse(elt))
226         else:
227             # e.g. a Union[] inside an Optional[]
228             flattened.extend(unparse(subscript))
229 
230         if getattr(node.value, 'id', '') == 'Optional':
231             flattened.extend(unparse(ast.BitOr()))
232             flattened.append(nodes.Text('None'))
233 
234         return flattened
235 
236     try:
237         tree = ast.parse(annotation, type_comments=True)
238         result: list[Node] = []
239         for node in unparse(tree):
240             if isinstance(node, nodes.literal):
241                 result.append(node[0])
242             elif isinstance(node, nodes.Text) and node.strip():
243                 if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and
244                         result[-1].astext() == '~'):
245                     result.pop()
246                     result.append(type_to_xref(str(node), env, suppress_prefix=True))
247                 else:
248                     result.append(type_to_xref(str(node), env))
249             else:
250                 result.append(node)
251         return result
252     except SyntaxError:
253         return [type_to_xref(annotation, env)]

</code><intended_behavior>This method should be modified to ensure it cleanly supports the formatting changes described in the issue: For 'Union' types, translate 'Union[X, Y, Z]' to 'X | Y | Z'. For 'Optional' types, translate 'Optional[X]' to 'X | None'. For 'Literal' types, translate 'Literal["X"]' to '"X"'. Additionally, ensure 'Literal' values are displayed without the 'Literal' prefix and are highlighted using normal Python syntax highlighting. This might involve identifying 'Literal' usage within the AST parsing logic and transforming the associated nodes accordingly. These modifications should preserve existing functionality, ensuring that all other annotation types continue to be parsed and displayed as before. The changes to 'Union', 'Optional', and 'Literal' handling should only apply when a new configuration option is enabled.</intended_behavior>, <file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Build configuration file handling."""
2 
3 from __future__ import annotations
4 
5 import re
6 import traceback
7 import types
8 from os import getenv, path
9 from typing import TYPE_CHECKING, Any, Callable, Generator, Iterator, NamedTuple
10 
11 from sphinx.errors import ConfigError, ExtensionError
12 from sphinx.locale import _, __
13 from sphinx.util import logging
14 from sphinx.util.i18n import format_date
15 from sphinx.util.osutil import fs_encoding
16 from sphinx.util.tags import Tags
17 from sphinx.util.typing import NoneType
18 
19 try:
20     from contextlib import chdir  # type: ignore[attr-defined]
21 except ImportError:
22     from sphinx.util.osutil import _chdir as chdir
23 
24 if TYPE_CHECKING:
25     from sphinx.application import Sphinx
26     from sphinx.environment import BuildEnvironment
27 
28 logger = logging.getLogger(__name__)
29 
30 CONFIG_FILENAME = 'conf.py'
31 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
32 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
33 
34 
35 class ConfigValue(NamedTuple):
36     name: str
37     value: Any
38     rebuild: bool | str
39 
40 
41 def is_serializable(obj: Any) -> bool:
42     """Check if object is serializable or not."""
43     if isinstance(obj, UNSERIALIZABLE_TYPES):
44         return False
45     elif isinstance(obj, dict):
46         for key, value in obj.items():
47             if not is_serializable(key) or not is_serializable(value):
48                 return False
49     elif isinstance(obj, (list, tuple, set)):
50         return all(is_serializable(i) for i in obj)
51 
52     return True
53 
54 
55 class ENUM:
56     """Represents the candidates which a config value should be one of.
57 
58     Example:
59         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
60     """
61     def __init__(self, *candidates: str) -> None:
62         self.candidates = candidates
63 
64     def match(self, value: str | list | tuple) -> bool:
65         if isinstance(value, (list, tuple)):
66             return all(item in self.candidates for item in value)
67         else:
68             return value in self.candidates
69 
70 
71 class Config:
72     """Configuration file abstraction.
73 
74     The config object makes the values of all config values available as
75     attributes.
76 
77     It is exposed via the :py:attr:`sphinx.application.Application.config` and
78     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
79     to get the value of :confval:`language`, use either ``app.config.language``
80     or ``env.config.language``.
81     """
82 
83     # the values are: (default, what needs to be rebuilt if changed)
84 
85     # If you add a value here, don't forget to include it in the
86     # quickstart.py file template as well as in the docs!
87 
88     config_values: dict[str, tuple] = {
89         # general options
90         'project': ('Python', 'env', []),
91         'author': ('unknown', 'env', []),
92         'project_copyright': ('', 'html', [str]),
93         'copyright': (lambda c: c.project_copyright, 'html', [str]),
94         'version': ('', 'env', []),
95         'release': ('', 'env', []),
96         'today': ('', 'env', []),
97         # the real default is locale-dependent
98         'today_fmt': (None, 'env', [str]),
99 
100         'language': ('en', 'env', [str]),
101         'locale_dirs': (['locales'], 'env', []),
102         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
103         'gettext_allow_fuzzy_translations': (False, 'gettext', []),
104 
105         'master_doc': ('index', 'env', []),
106         'root_doc': (lambda config: config.master_doc, 'env', []),
107         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
108         'source_encoding': ('utf-8-sig', 'env', []),
109         'exclude_patterns': ([], 'env', [str]),
110         'include_patterns': (["**"], 'env', [str]),
111         'default_role': (None, 'env', [str]),
112         'add_function_parentheses': (True, 'env', []),
113         'add_module_names': (True, 'env', []),
114         'toc_object_entries': (True, 'env', [bool]),
115         'toc_object_entries_show_parents': ('domain', 'env',
116                                             ENUM('domain', 'all', 'hide')),
117         'trim_footnote_reference_space': (False, 'env', []),
118         'show_authors': (False, 'env', []),
119         'pygments_style': (None, 'html', [str]),
120         'highlight_language': ('default', 'env', []),
121         'highlight_options': ({}, 'env', []),
122         'templates_path': ([], 'html', []),
123         'template_bridge': (None, 'html', [str]),
124         'keep_warnings': (False, 'env', []),
125         'suppress_warnings': ([], 'env', []),
126         'modindex_common_prefix': ([], 'html', []),
127         'rst_epilog': (None, 'env', [str]),
128         'rst_prolog': (None, 'env', [str]),
129         'trim_doctest_flags': (True, 'env', []),
130         'primary_domain': ('py', 'env', [NoneType]),
131         'needs_sphinx': (None, None, [str]),
132         'needs_extensions': ({}, None, []),
133         'manpages_url': (None, 'env', []),
134         'nitpicky': (False, None, []),
135         'nitpick_ignore': ([], None, []),
136         'nitpick_ignore_regex': ([], None, []),
137         'numfig': (False, 'env', []),
138         'numfig_secnum_depth': (1, 'env', []),
139         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
140 
141         'math_number_all': (False, 'env', []),
142         'math_eqref_format': (None, 'env', [str]),
143         'math_numfig': (True, 'env', []),
144         'tls_verify': (True, 'env', []),
145         'tls_cacerts': (None, 'env', []),
146         'user_agent': (None, 'env', [str]),
147         'smartquotes': (True, 'env', []),
148         'smartquotes_action': ('qDe', 'env', []),
149         'smartquotes_excludes': ({'languages': ['ja'],
150                                   'builders': ['man', 'text']},
151                                  'env', []),
152         'option_emphasise_placeholders': (False, 'env', []),
153     }
154 
155     def __init__(self, config: dict[str, Any] = {}, overrides: dict[str, Any] = {}) -> None:
156         self.overrides = dict(overrides)
157         self.values = Config.config_values.copy()
158         self._raw_config = config
159         self.setup: Callable | None = config.get('setup', None)
160 
161         if 'extensions' in self.overrides:
162             if isinstance(self.overrides['extensions'], str):
163                 config['extensions'] = self.overrides.pop('extensions').split(',')
164             else:
165                 config['extensions'] = self.overrides.pop('extensions')
166         self.extensions: list[str] = config.get('extensions', [])
167 
168     @classmethod
169     def read(
170         cls, confdir: str, overrides: dict | None = None, tags: Tags | None = None,
171     ) -> Config:
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         if not path.isfile(filename):
175             raise ConfigError(__("config directory doesn't contain a conf.py file (%s)") %
176                               confdir)
177         namespace = eval_config_file(filename, tags)
178 
179         # Note: Old sphinx projects have been configured as "language = None" because
180         #       sphinx-quickstart previously generated this by default.
181         #       To keep compatibility, they should be fallback to 'en' for a while
182         #       (This conversion should not be removed before 2025-01-01).
183         if namespace.get("language", ...) is None:
184             logger.warning(__("Invalid configuration value found: 'language = None'. "
185                               "Update your configuration to a valid language code. "
186                               "Falling back to 'en' (English)."))
187             namespace["language"] = "en"
188 
189         return cls(namespace, overrides or {})
190 
191     def convert_overrides(self, name: str, value: Any) -> Any:
192         if not isinstance(value, str):
193             return value
194         else:
195             defvalue = self.values[name][0]
196             if self.values[name][2] == Any:
197                 return value
198             elif self.values[name][2] == {bool, str}:
199                 if value == '0':
200                     # given falsy string from command line option
201                     return False
202                 elif value == '1':
203                     return True
204                 else:
205                     return value
206             elif type(defvalue) is bool or self.values[name][2] == [bool]:
207                 if value == '0':
208                     # given falsy string from command line option
209                     return False
210                 else:
211                     return bool(value)
212             elif isinstance(defvalue, dict):
213                 raise ValueError(__('cannot override dictionary config setting %r, '
214                                     'ignoring (use %r to set individual elements)') %
215                                  (name, name + '.key=value'))
216             elif isinstance(defvalue, list):
217                 return value.split(',')
218             elif isinstance(defvalue, int):
219                 try:
220                     return int(value)
221                 except ValueError as exc:
222                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
223                                      (value, name)) from exc
224             elif callable(defvalue):
225                 return value
226             elif defvalue is not None and not isinstance(defvalue, str):
227                 raise ValueError(__('cannot override config setting %r with unsupported '
228                                     'type, ignoring') % name)
229             else:
230                 return value
231 
232     def pre_init_values(self) -> None:
233         """
234         Initialize some limited config variables before initializing i18n and loading
235         extensions.
236         """
237         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
238         for name in variables:
239             try:
240                 if name in self.overrides:
241                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
242                 elif name in self._raw_config:
243                     self.__dict__[name] = self._raw_config[name]
244             except ValueError as exc:
245                 logger.warning("%s", exc)
246 
247     def init_values(self) -> None:
248         config = self._raw_config
249         for valname, value in self.overrides.items():
250             try:
251                 if '.' in valname:
252                     realvalname, key = valname.split('.', 1)
253                     config.setdefault(realvalname, {})[key] = value
254                     continue
255                 if valname not in self.values:
256                     logger.warning(__('unknown config value %r in override, ignoring'),
257                                    valname)
258                     continue
259                 if isinstance(value, str):
260                     config[valname] = self.convert_overrides(valname, value)
261                 else:
262                     config[valname] = value
263             except ValueError as exc:
264                 logger.warning("%s", exc)
265         for name in config:
266             if name in self.values:
267                 self.__dict__[name] = config[name]
268 
269     def post_init_values(self) -> None:
270         """
271         Initialize additional config variables that are added after init_values() called.
272         """
273         config = self._raw_config
274         for name in config:
275             if name not in self.__dict__ and name in self.values:
276                 self.__dict__[name] = config[name]
277 
278         check_confval_types(None, self)
279 
280     def __getattr__(self, name: str) -> Any:
281         if name.startswith('_'):
282             raise AttributeError(name)
283         if name not in self.values:
284             raise AttributeError(__('No such config value: %s') % name)
285         default = self.values[name][0]
286         if callable(default):
287             return default(self)
288         return default
289 
290     def __getitem__(self, name: str) -> Any:
291         return getattr(self, name)
292 
293     def __setitem__(self, name: str, value: Any) -> None:
294         setattr(self, name, value)
295 
296     def __delitem__(self, name: str) -> None:
297         delattr(self, name)
298 
299     def __contains__(self, name: str) -> bool:
300         return name in self.values
301 
302     def __iter__(self) -> Generator[ConfigValue, None, None]:
303         for name, value in self.values.items():
304             yield ConfigValue(name, getattr(self, name), value[1])
305 
306     def add(self, name: str, default: Any, rebuild: bool | str, types: Any) -> None:
307         if name in self.values:
308             raise ExtensionError(__('Config value %r already present') % name)
309         self.values[name] = (default, rebuild, types)
310 
311     def filter(self, rebuild: str | list[str]) -> Iterator[ConfigValue]:
312         if isinstance(rebuild, str):
313             rebuild = [rebuild]
314         return (value for value in self if value.rebuild in rebuild)
315 
316     def __getstate__(self) -> dict:
317         """Obtains serializable data for pickling."""
318         # remove potentially pickling-problematic values from config
319         __dict__ = {}
320         for key, value in self.__dict__.items():
321             if key.startswith('_') or not is_serializable(value):
322                 pass
323             else:
324                 __dict__[key] = value
325 
326         # create a picklable copy of values list
327         __dict__['values'] = {}
328         for key, value in self.values.items():
329             real_value = getattr(self, key)
330             if not is_serializable(real_value):
331                 # omit unserializable value
332                 real_value = None
333 
334             # types column is also omitted
335             __dict__['values'][key] = (real_value, value[1], None)
336 
337         return __dict__
338 
339     def __setstate__(self, state: dict) -> None:
340         self.__dict__.update(state)
341 
342 
343 def eval_config_file(filename: str, tags: Tags | None) -> dict[str, Any]:
344     """Evaluate a config file."""
345     namespace: dict[str, Any] = {}
346     namespace['__file__'] = filename
347     namespace['tags'] = tags
348 
349     with chdir(path.dirname(filename)):
350         # during executing config file, current dir is changed to ``confdir``.
351         try:
352             with open(filename, 'rb') as f:
353                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')
354                 exec(code, namespace)  # NoQA: S102
355         except SyntaxError as err:
356             msg = __("There is a syntax error in your configuration file: %s\n")
357             raise ConfigError(msg % err) from err
358         except SystemExit as exc:
359             msg = __("The configuration file (or one of the modules it imports) "
360                      "called sys.exit()")
361             raise ConfigError(msg) from exc
362         except ConfigError:
363             # pass through ConfigError from conf.py as is.  It will be shown in console.
364             raise
365         except Exception as exc:
366             msg = __("There is a programmable error in your configuration file:\n\n%s")
367             raise ConfigError(msg % traceback.format_exc()) from exc
368 
369     return namespace
370 
371 
372 def convert_source_suffix(app: Sphinx, config: Config) -> None:
373     """Convert old styled source_suffix to new styled one.
374 
375     * old style: str or list
376     * new style: a dict which maps from fileext to filetype
377     """
378     source_suffix = config.source_suffix
379     if isinstance(source_suffix, str):
380         # if str, considers as default filetype (None)
381         #
382         # The default filetype is determined on later step.
383         # By default, it is considered as restructuredtext.
384         config.source_suffix = {source_suffix: None}  # type: ignore[attr-defined]
385     elif isinstance(source_suffix, (list, tuple)):
386         # if list, considers as all of them are default filetype
387         config.source_suffix = {s: None for s in source_suffix}  # type: ignore[attr-defined]
388     elif not isinstance(source_suffix, dict):
389         logger.warning(__("The config value `source_suffix' expects "
390                           "a string, list of strings, or dictionary. "
391                           "But `%r' is given." % source_suffix))
392 
393 
394 def convert_highlight_options(app: Sphinx, config: Config) -> None:
395     """Convert old styled highlight_options to new styled one.
396 
397     * old style: options
398     * new style: a dict which maps from language name to options
399     """
400     options = config.highlight_options
401     if options and not all(isinstance(v, dict) for v in options.values()):
402         # old styled option detected because all values are not dictionary.
403         config.highlight_options = {config.highlight_language: options}  # type: ignore
404 
405 
406 def init_numfig_format(app: Sphinx, config: Config) -> None:
407     """Initialize :confval:`numfig_format`."""
408     numfig_format = {'section': _('Section %s'),
409                      'figure': _('Fig. %s'),
410                      'table': _('Table %s'),
411                      'code-block': _('Listing %s')}
412 
413     # override default labels by configuration
414     numfig_format.update(config.numfig_format)
415     config.numfig_format = numfig_format  # type: ignore
416 
417 
418 def correct_copyright_year(app: Sphinx, config: Config) -> None:
419     """Correct values of copyright year that are not coherent with
420     the SOURCE_DATE_EPOCH environment variable (if set)
421 
422     See https://reproducible-builds.org/specs/source-date-epoch/
423     """
424     if getenv('SOURCE_DATE_EPOCH') is not None:
425         for k in ('copyright', 'epub_copyright'):
426             if k in config:
427                 replace = r'\g<1>%s' % format_date('%Y', language='en')
428                 config[k] = copyright_year_re.sub(replace, config[k])
429 
430 
431 def check_confval_types(app: Sphinx | None, config: Config) -> None:
432     """Check all values for deviation from the default value's type, since
433     that can result in TypeErrors all over the place NB.
434     """
435     for confval in config:
436         default, rebuild, annotations = config.values[confval.name]
437 
438         if callable(default):
439             default = default(config)  # evaluate default value
440         if default is None and not annotations:
441             continue  # neither inferable nor expliclitly annotated types
442 
443         if annotations is Any:
444             # any type of value is accepted
445             pass
446         elif isinstance(annotations, ENUM):
447             if not annotations.match(confval.value):
448                 msg = __("The config value `{name}` has to be a one of {candidates}, "
449                          "but `{current}` is given.")
450                 logger.warning(msg.format(name=confval.name,
451                                           current=confval.value,
452                                           candidates=annotations.candidates), once=True)
453         else:
454             if type(confval.value) is type(default):
455                 continue
456             if type(confval.value) in annotations:
457                 continue
458 
459             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
460                             set(type(default).__bases__))
461             common_bases.discard(object)
462             if common_bases:
463                 continue  # at least we share a non-trivial base class
464 
465             if annotations:
466                 msg = __("The config value `{name}' has type `{current.__name__}'; "
467                          "expected {permitted}.")
468                 wrapped_annotations = [f"`{c.__name__}'" for c in annotations]
469                 if len(wrapped_annotations) > 2:
470                     permitted = (", ".join(wrapped_annotations[:-1])
471                                  + f", or {wrapped_annotations[-1]}")
472                 else:
473                     permitted = " or ".join(wrapped_annotations)
474                 logger.warning(msg.format(name=confval.name,
475                                           current=type(confval.value),
476                                           permitted=permitted), once=True)
477             else:
478                 msg = __("The config value `{name}' has type `{current.__name__}', "
479                          "defaults to `{default.__name__}'.")
480                 logger.warning(msg.format(name=confval.name,
481                                           current=type(confval.value),
482                                           default=type(default)), once=True)
483 
484 
485 def check_primary_domain(app: Sphinx, config: Config) -> None:
486     primary_domain = config.primary_domain
487     if primary_domain and not app.registry.has_domain(primary_domain):
488         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
489         config.primary_domain = None  # type: ignore
490 
491 
492 def check_root_doc(app: Sphinx, env: BuildEnvironment, added: set[str],
493                    changed: set[str], removed: set[str]) -> set[str]:
494     """Adjust root_doc to 'contents' to support an old project which does not have
495     any root_doc setting.
496     """
497     if (app.config.root_doc == 'index' and
498             'index' not in app.project.docnames and
499             'contents' in app.project.docnames):
500         logger.warning(__('Since v2.0, Sphinx uses "index" as root_doc by default. '
501                           'Please add "root_doc = \'contents\'" to your conf.py.'))
502         app.config.root_doc = "contents"  # type: ignore
503 
504     return changed
505 
506 
507 def setup(app: Sphinx) -> dict[str, Any]:
508     app.connect('config-inited', convert_source_suffix, priority=800)
509     app.connect('config-inited', convert_highlight_options, priority=800)
510     app.connect('config-inited', init_numfig_format, priority=800)
511     app.connect('config-inited', correct_copyright_year, priority=800)
512     app.connect('config-inited', check_confval_types, priority=800)
513     app.connect('config-inited', check_primary_domain, priority=800)
514     app.connect('env-get-outdated', check_root_doc)
515 
516     return {
517         'version': 'builtin',
518         'parallel_read_safe': True,
519         'parallel_write_safe': True,
520     }

</code><intended_behavior>Introduce a new configuration option (e.g., 'simplified_type_annotations') that users can set in their project's 'conf.py' to enable or disable the simplified formatting of type annotations. The default behavior (with the option disabled) should preserve the current formatting of type annotations. Implement the logic to check this configuration option within '_parse_annotation' function (or relevant functions) and apply the new formatting rules accordingly. This ensures that the enhancements are opt-in, allowing users to upgrade Sphinx without forcing them to adopt the new annotation formatting immediately.</intended_behavior>]
2025-10-18 06:20:18.124 | INFO     | Search completed. Bug locations: [<file>sphinx/domains/python.py</file>
<class>None</class>
<method>_parse_annotation</method>
<code>
131 def _parse_annotation(annotation: str, env: BuildEnvironment | None) -> list[Node]:
132     """Parse type annotation."""
133     def unparse(node: ast.AST) -> list[Node]:
134         if isinstance(node, ast.Attribute):
135             return [nodes.Text(f"{unparse(node.value)[0]}.{node.attr}")]
136         if isinstance(node, ast.BinOp):
137             result: list[Node] = unparse(node.left)
138             result.extend(unparse(node.op))
139             result.extend(unparse(node.right))
140             return result
141         if isinstance(node, ast.BitOr):
142             return [addnodes.desc_sig_space(),
143                     addnodes.desc_sig_punctuation('', '|'),
144                     addnodes.desc_sig_space()]
145         if isinstance(node, ast.Constant):
146             if node.value is Ellipsis:
147                 return [addnodes.desc_sig_punctuation('', "...")]
148             if isinstance(node.value, bool):
149                 return [addnodes.desc_sig_keyword('', repr(node.value))]
150             if isinstance(node.value, int):
151                 return [addnodes.desc_sig_literal_number('', repr(node.value))]
152             if isinstance(node.value, str):
153                 return [addnodes.desc_sig_literal_string('', repr(node.value))]
154             else:
155                 # handles None, which is further handled by type_to_xref later
156                 # and fallback for other types that should be converted
157                 return [nodes.Text(repr(node.value))]
158         if isinstance(node, ast.Expr):
159             return unparse(node.value)
160         if isinstance(node, ast.Index):
161             return unparse(node.value)
162         if isinstance(node, ast.Invert):
163             return [addnodes.desc_sig_punctuation('', '~')]
164         if isinstance(node, ast.List):
165             result = [addnodes.desc_sig_punctuation('', '[')]
166             if node.elts:
167                 # check if there are elements in node.elts to only pop the
168                 # last element of result if the for-loop was run at least
169                 # once
170                 for elem in node.elts:
171                     result.extend(unparse(elem))
172                     result.append(addnodes.desc_sig_punctuation('', ','))
173                     result.append(addnodes.desc_sig_space())
174                 result.pop()
175                 result.pop()
176             result.append(addnodes.desc_sig_punctuation('', ']'))
177             return result
178         if isinstance(node, ast.Module):
179             return sum((unparse(e) for e in node.body), [])
180         if isinstance(node, ast.Name):
181             return [nodes.Text(node.id)]
182         if isinstance(node, ast.Subscript):
183             if getattr(node.value, 'id', '') in {'Optional', 'Union'}:
184                 return _unparse_pep_604_annotation(node)
185             result = unparse(node.value)
186             result.append(addnodes.desc_sig_punctuation('', '['))
187             result.extend(unparse(node.slice))
188             result.append(addnodes.desc_sig_punctuation('', ']'))
189 
190             # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal
191             if result[0] in ('Literal', 'typing.Literal'):
192                 for i, subnode in enumerate(result[1:], start=1):
193                     if isinstance(subnode, nodes.Text):
194                         result[i] = nodes.literal('', '', subnode)
195             return result
196         if isinstance(node, ast.UnaryOp):
197             return unparse(node.op) + unparse(node.operand)
198         if isinstance(node, ast.Tuple):
199             if node.elts:
200                 result = []
201                 for elem in node.elts:
202                     result.extend(unparse(elem))
203                     result.append(addnodes.desc_sig_punctuation('', ','))
204                     result.append(addnodes.desc_sig_space())
205                 result.pop()
206                 result.pop()
207             else:
208                 result = [addnodes.desc_sig_punctuation('', '('),
209                           addnodes.desc_sig_punctuation('', ')')]
210 
211             return result
212         raise SyntaxError  # unsupported syntax
213 
214     def _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:
215         subscript = node.slice
216         if isinstance(subscript, ast.Index):
217             # py38 only
218             subscript = subscript.value  # type: ignore[assignment]
219 
220         flattened: list[Node] = []
221         if isinstance(subscript, ast.Tuple):
222             flattened.extend(unparse(subscript.elts[0]))
223             for elt in subscript.elts[1:]:
224                 flattened.extend(unparse(ast.BitOr()))
225                 flattened.extend(unparse(elt))
226         else:
227             # e.g. a Union[] inside an Optional[]
228             flattened.extend(unparse(subscript))
229 
230         if getattr(node.value, 'id', '') == 'Optional':
231             flattened.extend(unparse(ast.BitOr()))
232             flattened.append(nodes.Text('None'))
233 
234         return flattened
235 
236     try:
237         tree = ast.parse(annotation, type_comments=True)
238         result: list[Node] = []
239         for node in unparse(tree):
240             if isinstance(node, nodes.literal):
241                 result.append(node[0])
242             elif isinstance(node, nodes.Text) and node.strip():
243                 if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and
244                         result[-1].astext() == '~'):
245                     result.pop()
246                     result.append(type_to_xref(str(node), env, suppress_prefix=True))
247                 else:
248                     result.append(type_to_xref(str(node), env))
249             else:
250                 result.append(node)
251         return result
252     except SyntaxError:
253         return [type_to_xref(annotation, env)]

</code><intended_behavior>This method should be modified to ensure it cleanly supports the formatting changes described in the issue: For 'Union' types, translate 'Union[X, Y, Z]' to 'X | Y | Z'. For 'Optional' types, translate 'Optional[X]' to 'X | None'. For 'Literal' types, translate 'Literal["X"]' to '"X"'. Additionally, ensure 'Literal' values are displayed without the 'Literal' prefix and are highlighted using normal Python syntax highlighting. This might involve identifying 'Literal' usage within the AST parsing logic and transforming the associated nodes accordingly. These modifications should preserve existing functionality, ensuring that all other annotation types continue to be parsed and displayed as before. The changes to 'Union', 'Optional', and 'Literal' handling should only apply when a new configuration option is enabled.</intended_behavior>, <file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Build configuration file handling."""
2 
3 from __future__ import annotations
4 
5 import re
6 import traceback
7 import types
8 from os import getenv, path
9 from typing import TYPE_CHECKING, Any, Callable, Generator, Iterator, NamedTuple
10 
11 from sphinx.errors import ConfigError, ExtensionError
12 from sphinx.locale import _, __
13 from sphinx.util import logging
14 from sphinx.util.i18n import format_date
15 from sphinx.util.osutil import fs_encoding
16 from sphinx.util.tags import Tags
17 from sphinx.util.typing import NoneType
18 
19 try:
20     from contextlib import chdir  # type: ignore[attr-defined]
21 except ImportError:
22     from sphinx.util.osutil import _chdir as chdir
23 
24 if TYPE_CHECKING:
25     from sphinx.application import Sphinx
26     from sphinx.environment import BuildEnvironment
27 
28 logger = logging.getLogger(__name__)
29 
30 CONFIG_FILENAME = 'conf.py'
31 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
32 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
33 
34 
35 class ConfigValue(NamedTuple):
36     name: str
37     value: Any
38     rebuild: bool | str
39 
40 
41 def is_serializable(obj: Any) -> bool:
42     """Check if object is serializable or not."""
43     if isinstance(obj, UNSERIALIZABLE_TYPES):
44         return False
45     elif isinstance(obj, dict):
46         for key, value in obj.items():
47             if not is_serializable(key) or not is_serializable(value):
48                 return False
49     elif isinstance(obj, (list, tuple, set)):
50         return all(is_serializable(i) for i in obj)
51 
52     return True
53 
54 
55 class ENUM:
56     """Represents the candidates which a config value should be one of.
57 
58     Example:
59         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
60     """
61     def __init__(self, *candidates: str) -> None:
62         self.candidates = candidates
63 
64     def match(self, value: str | list | tuple) -> bool:
65         if isinstance(value, (list, tuple)):
66             return all(item in self.candidates for item in value)
67         else:
68             return value in self.candidates
69 
70 
71 class Config:
72     """Configuration file abstraction.
73 
74     The config object makes the values of all config values available as
75     attributes.
76 
77     It is exposed via the :py:attr:`sphinx.application.Application.config` and
78     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
79     to get the value of :confval:`language`, use either ``app.config.language``
80     or ``env.config.language``.
81     """
82 
83     # the values are: (default, what needs to be rebuilt if changed)
84 
85     # If you add a value here, don't forget to include it in the
86     # quickstart.py file template as well as in the docs!
87 
88     config_values: dict[str, tuple] = {
89         # general options
90         'project': ('Python', 'env', []),
91         'author': ('unknown', 'env', []),
92         'project_copyright': ('', 'html', [str]),
93         'copyright': (lambda c: c.project_copyright, 'html', [str]),
94         'version': ('', 'env', []),
95         'release': ('', 'env', []),
96         'today': ('', 'env', []),
97         # the real default is locale-dependent
98         'today_fmt': (None, 'env', [str]),
99 
100         'language': ('en', 'env', [str]),
101         'locale_dirs': (['locales'], 'env', []),
102         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
103         'gettext_allow_fuzzy_translations': (False, 'gettext', []),
104 
105         'master_doc': ('index', 'env', []),
106         'root_doc': (lambda config: config.master_doc, 'env', []),
107         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
108         'source_encoding': ('utf-8-sig', 'env', []),
109         'exclude_patterns': ([], 'env', [str]),
110         'include_patterns': (["**"], 'env', [str]),
111         'default_role': (None, 'env', [str]),
112         'add_function_parentheses': (True, 'env', []),
113         'add_module_names': (True, 'env', []),
114         'toc_object_entries': (True, 'env', [bool]),
115         'toc_object_entries_show_parents': ('domain', 'env',
116                                             ENUM('domain', 'all', 'hide')),
117         'trim_footnote_reference_space': (False, 'env', []),
118         'show_authors': (False, 'env', []),
119         'pygments_style': (None, 'html', [str]),
120         'highlight_language': ('default', 'env', []),
121         'highlight_options': ({}, 'env', []),
122         'templates_path': ([], 'html', []),
123         'template_bridge': (None, 'html', [str]),
124         'keep_warnings': (False, 'env', []),
125         'suppress_warnings': ([], 'env', []),
126         'modindex_common_prefix': ([], 'html', []),
127         'rst_epilog': (None, 'env', [str]),
128         'rst_prolog': (None, 'env', [str]),
129         'trim_doctest_flags': (True, 'env', []),
130         'primary_domain': ('py', 'env', [NoneType]),
131         'needs_sphinx': (None, None, [str]),
132         'needs_extensions': ({}, None, []),
133         'manpages_url': (None, 'env', []),
134         'nitpicky': (False, None, []),
135         'nitpick_ignore': ([], None, []),
136         'nitpick_ignore_regex': ([], None, []),
137         'numfig': (False, 'env', []),
138         'numfig_secnum_depth': (1, 'env', []),
139         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
140 
141         'math_number_all': (False, 'env', []),
142         'math_eqref_format': (None, 'env', [str]),
143         'math_numfig': (True, 'env', []),
144         'tls_verify': (True, 'env', []),
145         'tls_cacerts': (None, 'env', []),
146         'user_agent': (None, 'env', [str]),
147         'smartquotes': (True, 'env', []),
148         'smartquotes_action': ('qDe', 'env', []),
149         'smartquotes_excludes': ({'languages': ['ja'],
150                                   'builders': ['man', 'text']},
151                                  'env', []),
152         'option_emphasise_placeholders': (False, 'env', []),
153     }
154 
155     def __init__(self, config: dict[str, Any] = {}, overrides: dict[str, Any] = {}) -> None:
156         self.overrides = dict(overrides)
157         self.values = Config.config_values.copy()
158         self._raw_config = config
159         self.setup: Callable | None = config.get('setup', None)
160 
161         if 'extensions' in self.overrides:
162             if isinstance(self.overrides['extensions'], str):
163                 config['extensions'] = self.overrides.pop('extensions').split(',')
164             else:
165                 config['extensions'] = self.overrides.pop('extensions')
166         self.extensions: list[str] = config.get('extensions', [])
167 
168     @classmethod
169     def read(
170         cls, confdir: str, overrides: dict | None = None, tags: Tags | None = None,
171     ) -> Config:
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         if not path.isfile(filename):
175             raise ConfigError(__("config directory doesn't contain a conf.py file (%s)") %
176                               confdir)
177         namespace = eval_config_file(filename, tags)
178 
179         # Note: Old sphinx projects have been configured as "language = None" because
180         #       sphinx-quickstart previously generated this by default.
181         #       To keep compatibility, they should be fallback to 'en' for a while
182         #       (This conversion should not be removed before 2025-01-01).
183         if namespace.get("language", ...) is None:
184             logger.warning(__("Invalid configuration value found: 'language = None'. "
185                               "Update your configuration to a valid language code. "
186                               "Falling back to 'en' (English)."))
187             namespace["language"] = "en"
188 
189         return cls(namespace, overrides or {})
190 
191     def convert_overrides(self, name: str, value: Any) -> Any:
192         if not isinstance(value, str):
193             return value
194         else:
195             defvalue = self.values[name][0]
196             if self.values[name][2] == Any:
197                 return value
198             elif self.values[name][2] == {bool, str}:
199                 if value == '0':
200                     # given falsy string from command line option
201                     return False
202                 elif value == '1':
203                     return True
204                 else:
205                     return value
206             elif type(defvalue) is bool or self.values[name][2] == [bool]:
207                 if value == '0':
208                     # given falsy string from command line option
209                     return False
210                 else:
211                     return bool(value)
212             elif isinstance(defvalue, dict):
213                 raise ValueError(__('cannot override dictionary config setting %r, '
214                                     'ignoring (use %r to set individual elements)') %
215                                  (name, name + '.key=value'))
216             elif isinstance(defvalue, list):
217                 return value.split(',')
218             elif isinstance(defvalue, int):
219                 try:
220                     return int(value)
221                 except ValueError as exc:
222                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
223                                      (value, name)) from exc
224             elif callable(defvalue):
225                 return value
226             elif defvalue is not None and not isinstance(defvalue, str):
227                 raise ValueError(__('cannot override config setting %r with unsupported '
228                                     'type, ignoring') % name)
229             else:
230                 return value
231 
232     def pre_init_values(self) -> None:
233         """
234         Initialize some limited config variables before initializing i18n and loading
235         extensions.
236         """
237         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
238         for name in variables:
239             try:
240                 if name in self.overrides:
241                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
242                 elif name in self._raw_config:
243                     self.__dict__[name] = self._raw_config[name]
244             except ValueError as exc:
245                 logger.warning("%s", exc)
246 
247     def init_values(self) -> None:
248         config = self._raw_config
249         for valname, value in self.overrides.items():
250             try:
251                 if '.' in valname:
252                     realvalname, key = valname.split('.', 1)
253                     config.setdefault(realvalname, {})[key] = value
254                     continue
255                 if valname not in self.values:
256                     logger.warning(__('unknown config value %r in override, ignoring'),
257                                    valname)
258                     continue
259                 if isinstance(value, str):
260                     config[valname] = self.convert_overrides(valname, value)
261                 else:
262                     config[valname] = value
263             except ValueError as exc:
264                 logger.warning("%s", exc)
265         for name in config:
266             if name in self.values:
267                 self.__dict__[name] = config[name]
268 
269     def post_init_values(self) -> None:
270         """
271         Initialize additional config variables that are added after init_values() called.
272         """
273         config = self._raw_config
274         for name in config:
275             if name not in self.__dict__ and name in self.values:
276                 self.__dict__[name] = config[name]
277 
278         check_confval_types(None, self)
279 
280     def __getattr__(self, name: str) -> Any:
281         if name.startswith('_'):
282             raise AttributeError(name)
283         if name not in self.values:
284             raise AttributeError(__('No such config value: %s') % name)
285         default = self.values[name][0]
286         if callable(default):
287             return default(self)
288         return default
289 
290     def __getitem__(self, name: str) -> Any:
291         return getattr(self, name)
292 
293     def __setitem__(self, name: str, value: Any) -> None:
294         setattr(self, name, value)
295 
296     def __delitem__(self, name: str) -> None:
297         delattr(self, name)
298 
299     def __contains__(self, name: str) -> bool:
300         return name in self.values
301 
302     def __iter__(self) -> Generator[ConfigValue, None, None]:
303         for name, value in self.values.items():
304             yield ConfigValue(name, getattr(self, name), value[1])
305 
306     def add(self, name: str, default: Any, rebuild: bool | str, types: Any) -> None:
307         if name in self.values:
308             raise ExtensionError(__('Config value %r already present') % name)
309         self.values[name] = (default, rebuild, types)
310 
311     def filter(self, rebuild: str | list[str]) -> Iterator[ConfigValue]:
312         if isinstance(rebuild, str):
313             rebuild = [rebuild]
314         return (value for value in self if value.rebuild in rebuild)
315 
316     def __getstate__(self) -> dict:
317         """Obtains serializable data for pickling."""
318         # remove potentially pickling-problematic values from config
319         __dict__ = {}
320         for key, value in self.__dict__.items():
321             if key.startswith('_') or not is_serializable(value):
322                 pass
323             else:
324                 __dict__[key] = value
325 
326         # create a picklable copy of values list
327         __dict__['values'] = {}
328         for key, value in self.values.items():
329             real_value = getattr(self, key)
330             if not is_serializable(real_value):
331                 # omit unserializable value
332                 real_value = None
333 
334             # types column is also omitted
335             __dict__['values'][key] = (real_value, value[1], None)
336 
337         return __dict__
338 
339     def __setstate__(self, state: dict) -> None:
340         self.__dict__.update(state)
341 
342 
343 def eval_config_file(filename: str, tags: Tags | None) -> dict[str, Any]:
344     """Evaluate a config file."""
345     namespace: dict[str, Any] = {}
346     namespace['__file__'] = filename
347     namespace['tags'] = tags
348 
349     with chdir(path.dirname(filename)):
350         # during executing config file, current dir is changed to ``confdir``.
351         try:
352             with open(filename, 'rb') as f:
353                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')
354                 exec(code, namespace)  # NoQA: S102
355         except SyntaxError as err:
356             msg = __("There is a syntax error in your configuration file: %s\n")
357             raise ConfigError(msg % err) from err
358         except SystemExit as exc:
359             msg = __("The configuration file (or one of the modules it imports) "
360                      "called sys.exit()")
361             raise ConfigError(msg) from exc
362         except ConfigError:
363             # pass through ConfigError from conf.py as is.  It will be shown in console.
364             raise
365         except Exception as exc:
366             msg = __("There is a programmable error in your configuration file:\n\n%s")
367             raise ConfigError(msg % traceback.format_exc()) from exc
368 
369     return namespace
370 
371 
372 def convert_source_suffix(app: Sphinx, config: Config) -> None:
373     """Convert old styled source_suffix to new styled one.
374 
375     * old style: str or list
376     * new style: a dict which maps from fileext to filetype
377     """
378     source_suffix = config.source_suffix
379     if isinstance(source_suffix, str):
380         # if str, considers as default filetype (None)
381         #
382         # The default filetype is determined on later step.
383         # By default, it is considered as restructuredtext.
384         config.source_suffix = {source_suffix: None}  # type: ignore[attr-defined]
385     elif isinstance(source_suffix, (list, tuple)):
386         # if list, considers as all of them are default filetype
387         config.source_suffix = {s: None for s in source_suffix}  # type: ignore[attr-defined]
388     elif not isinstance(source_suffix, dict):
389         logger.warning(__("The config value `source_suffix' expects "
390                           "a string, list of strings, or dictionary. "
391                           "But `%r' is given." % source_suffix))
392 
393 
394 def convert_highlight_options(app: Sphinx, config: Config) -> None:
395     """Convert old styled highlight_options to new styled one.
396 
397     * old style: options
398     * new style: a dict which maps from language name to options
399     """
400     options = config.highlight_options
401     if options and not all(isinstance(v, dict) for v in options.values()):
402         # old styled option detected because all values are not dictionary.
403         config.highlight_options = {config.highlight_language: options}  # type: ignore
404 
405 
406 def init_numfig_format(app: Sphinx, config: Config) -> None:
407     """Initialize :confval:`numfig_format`."""
408     numfig_format = {'section': _('Section %s'),
409                      'figure': _('Fig. %s'),
410                      'table': _('Table %s'),
411                      'code-block': _('Listing %s')}
412 
413     # override default labels by configuration
414     numfig_format.update(config.numfig_format)
415     config.numfig_format = numfig_format  # type: ignore
416 
417 
418 def correct_copyright_year(app: Sphinx, config: Config) -> None:
419     """Correct values of copyright year that are not coherent with
420     the SOURCE_DATE_EPOCH environment variable (if set)
421 
422     See https://reproducible-builds.org/specs/source-date-epoch/
423     """
424     if getenv('SOURCE_DATE_EPOCH') is not None:
425         for k in ('copyright', 'epub_copyright'):
426             if k in config:
427                 replace = r'\g<1>%s' % format_date('%Y', language='en')
428                 config[k] = copyright_year_re.sub(replace, config[k])
429 
430 
431 def check_confval_types(app: Sphinx | None, config: Config) -> None:
432     """Check all values for deviation from the default value's type, since
433     that can result in TypeErrors all over the place NB.
434     """
435     for confval in config:
436         default, rebuild, annotations = config.values[confval.name]
437 
438         if callable(default):
439             default = default(config)  # evaluate default value
440         if default is None and not annotations:
441             continue  # neither inferable nor expliclitly annotated types
442 
443         if annotations is Any:
444             # any type of value is accepted
445             pass
446         elif isinstance(annotations, ENUM):
447             if not annotations.match(confval.value):
448                 msg = __("The config value `{name}` has to be a one of {candidates}, "
449                          "but `{current}` is given.")
450                 logger.warning(msg.format(name=confval.name,
451                                           current=confval.value,
452                                           candidates=annotations.candidates), once=True)
453         else:
454             if type(confval.value) is type(default):
455                 continue
456             if type(confval.value) in annotations:
457                 continue
458 
459             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
460                             set(type(default).__bases__))
461             common_bases.discard(object)
462             if common_bases:
463                 continue  # at least we share a non-trivial base class
464 
465             if annotations:
466                 msg = __("The config value `{name}' has type `{current.__name__}'; "
467                          "expected {permitted}.")
468                 wrapped_annotations = [f"`{c.__name__}'" for c in annotations]
469                 if len(wrapped_annotations) > 2:
470                     permitted = (", ".join(wrapped_annotations[:-1])
471                                  + f", or {wrapped_annotations[-1]}")
472                 else:
473                     permitted = " or ".join(wrapped_annotations)
474                 logger.warning(msg.format(name=confval.name,
475                                           current=type(confval.value),
476                                           permitted=permitted), once=True)
477             else:
478                 msg = __("The config value `{name}' has type `{current.__name__}', "
479                          "defaults to `{default.__name__}'.")
480                 logger.warning(msg.format(name=confval.name,
481                                           current=type(confval.value),
482                                           default=type(default)), once=True)
483 
484 
485 def check_primary_domain(app: Sphinx, config: Config) -> None:
486     primary_domain = config.primary_domain
487     if primary_domain and not app.registry.has_domain(primary_domain):
488         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
489         config.primary_domain = None  # type: ignore
490 
491 
492 def check_root_doc(app: Sphinx, env: BuildEnvironment, added: set[str],
493                    changed: set[str], removed: set[str]) -> set[str]:
494     """Adjust root_doc to 'contents' to support an old project which does not have
495     any root_doc setting.
496     """
497     if (app.config.root_doc == 'index' and
498             'index' not in app.project.docnames and
499             'contents' in app.project.docnames):
500         logger.warning(__('Since v2.0, Sphinx uses "index" as root_doc by default. '
501                           'Please add "root_doc = \'contents\'" to your conf.py.'))
502         app.config.root_doc = "contents"  # type: ignore
503 
504     return changed
505 
506 
507 def setup(app: Sphinx) -> dict[str, Any]:
508     app.connect('config-inited', convert_source_suffix, priority=800)
509     app.connect('config-inited', convert_highlight_options, priority=800)
510     app.connect('config-inited', init_numfig_format, priority=800)
511     app.connect('config-inited', correct_copyright_year, priority=800)
512     app.connect('config-inited', check_confval_types, priority=800)
513     app.connect('config-inited', check_primary_domain, priority=800)
514     app.connect('env-get-outdated', check_root_doc)
515 
516     return {
517         'version': 'builtin',
518         'parallel_read_safe': True,
519         'parallel_write_safe': True,
520     }

</code><intended_behavior>Introduce a new configuration option (e.g., 'simplified_type_annotations') that users can set in their project's 'conf.py' to enable or disable the simplified formatting of type annotations. The default behavior (with the option disabled) should preserve the current formatting of type annotations. Implement the logic to check this configuration option within '_parse_annotation' function (or relevant functions) and apply the new formatting rules accordingly. This ensures that the enhancements are opt-in, allowing users to upgrade Sphinx without forcing them to adopt the new annotation formatting immediately.</intended_behavior>]
2025-10-18 06:20:18.125 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:20:18.125 | INFO     | Search-only: skipping patch selection
2025-10-18 06:20:18.197 | INFO     | Task sphinx-doc__sphinx-11109 completed successfully.
2025-10-18 06:20:18.198 | INFO     | No patch generated. You can try running ACR again.
