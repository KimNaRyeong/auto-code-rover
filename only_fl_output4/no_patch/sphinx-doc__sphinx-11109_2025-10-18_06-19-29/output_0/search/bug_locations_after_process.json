[
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__6.2/sphinx/domains/python.py",
        "start": 131,
        "end": 253,
        "class_name": null,
        "method_name": "_parse_annotation",
        "code": "131 def _parse_annotation(annotation: str, env: BuildEnvironment | None) -> list[Node]:\n132     \"\"\"Parse type annotation.\"\"\"\n133     def unparse(node: ast.AST) -> list[Node]:\n134         if isinstance(node, ast.Attribute):\n135             return [nodes.Text(f\"{unparse(node.value)[0]}.{node.attr}\")]\n136         if isinstance(node, ast.BinOp):\n137             result: list[Node] = unparse(node.left)\n138             result.extend(unparse(node.op))\n139             result.extend(unparse(node.right))\n140             return result\n141         if isinstance(node, ast.BitOr):\n142             return [addnodes.desc_sig_space(),\n143                     addnodes.desc_sig_punctuation('', '|'),\n144                     addnodes.desc_sig_space()]\n145         if isinstance(node, ast.Constant):\n146             if node.value is Ellipsis:\n147                 return [addnodes.desc_sig_punctuation('', \"...\")]\n148             if isinstance(node.value, bool):\n149                 return [addnodes.desc_sig_keyword('', repr(node.value))]\n150             if isinstance(node.value, int):\n151                 return [addnodes.desc_sig_literal_number('', repr(node.value))]\n152             if isinstance(node.value, str):\n153                 return [addnodes.desc_sig_literal_string('', repr(node.value))]\n154             else:\n155                 # handles None, which is further handled by type_to_xref later\n156                 # and fallback for other types that should be converted\n157                 return [nodes.Text(repr(node.value))]\n158         if isinstance(node, ast.Expr):\n159             return unparse(node.value)\n160         if isinstance(node, ast.Index):\n161             return unparse(node.value)\n162         if isinstance(node, ast.Invert):\n163             return [addnodes.desc_sig_punctuation('', '~')]\n164         if isinstance(node, ast.List):\n165             result = [addnodes.desc_sig_punctuation('', '[')]\n166             if node.elts:\n167                 # check if there are elements in node.elts to only pop the\n168                 # last element of result if the for-loop was run at least\n169                 # once\n170                 for elem in node.elts:\n171                     result.extend(unparse(elem))\n172                     result.append(addnodes.desc_sig_punctuation('', ','))\n173                     result.append(addnodes.desc_sig_space())\n174                 result.pop()\n175                 result.pop()\n176             result.append(addnodes.desc_sig_punctuation('', ']'))\n177             return result\n178         if isinstance(node, ast.Module):\n179             return sum((unparse(e) for e in node.body), [])\n180         if isinstance(node, ast.Name):\n181             return [nodes.Text(node.id)]\n182         if isinstance(node, ast.Subscript):\n183             if getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n184                 return _unparse_pep_604_annotation(node)\n185             result = unparse(node.value)\n186             result.append(addnodes.desc_sig_punctuation('', '['))\n187             result.extend(unparse(node.slice))\n188             result.append(addnodes.desc_sig_punctuation('', ']'))\n189 \n190             # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal\n191             if result[0] in ('Literal', 'typing.Literal'):\n192                 for i, subnode in enumerate(result[1:], start=1):\n193                     if isinstance(subnode, nodes.Text):\n194                         result[i] = nodes.literal('', '', subnode)\n195             return result\n196         if isinstance(node, ast.UnaryOp):\n197             return unparse(node.op) + unparse(node.operand)\n198         if isinstance(node, ast.Tuple):\n199             if node.elts:\n200                 result = []\n201                 for elem in node.elts:\n202                     result.extend(unparse(elem))\n203                     result.append(addnodes.desc_sig_punctuation('', ','))\n204                     result.append(addnodes.desc_sig_space())\n205                 result.pop()\n206                 result.pop()\n207             else:\n208                 result = [addnodes.desc_sig_punctuation('', '('),\n209                           addnodes.desc_sig_punctuation('', ')')]\n210 \n211             return result\n212         raise SyntaxError  # unsupported syntax\n213 \n214     def _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n215         subscript = node.slice\n216         if isinstance(subscript, ast.Index):\n217             # py38 only\n218             subscript = subscript.value  # type: ignore[assignment]\n219 \n220         flattened: list[Node] = []\n221         if isinstance(subscript, ast.Tuple):\n222             flattened.extend(unparse(subscript.elts[0]))\n223             for elt in subscript.elts[1:]:\n224                 flattened.extend(unparse(ast.BitOr()))\n225                 flattened.extend(unparse(elt))\n226         else:\n227             # e.g. a Union[] inside an Optional[]\n228             flattened.extend(unparse(subscript))\n229 \n230         if getattr(node.value, 'id', '') == 'Optional':\n231             flattened.extend(unparse(ast.BitOr()))\n232             flattened.append(nodes.Text('None'))\n233 \n234         return flattened\n235 \n236     try:\n237         tree = ast.parse(annotation, type_comments=True)\n238         result: list[Node] = []\n239         for node in unparse(tree):\n240             if isinstance(node, nodes.literal):\n241                 result.append(node[0])\n242             elif isinstance(node, nodes.Text) and node.strip():\n243                 if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and\n244                         result[-1].astext() == '~'):\n245                     result.pop()\n246                     result.append(type_to_xref(str(node), env, suppress_prefix=True))\n247                 else:\n248                     result.append(type_to_xref(str(node), env))\n249             else:\n250                 result.append(node)\n251         return result\n252     except SyntaxError:\n253         return [type_to_xref(annotation, env)]\n",
        "intended_behavior": "This method should be modified to ensure it cleanly supports the formatting changes described in the issue: For 'Union' types, translate 'Union[X, Y, Z]' to 'X | Y | Z'. For 'Optional' types, translate 'Optional[X]' to 'X | None'. For 'Literal' types, translate 'Literal[\"X\"]' to '\"X\"'. Additionally, ensure 'Literal' values are displayed without the 'Literal' prefix and are highlighted using normal Python syntax highlighting. This might involve identifying 'Literal' usage within the AST parsing logic and transforming the associated nodes accordingly. These modifications should preserve existing functionality, ensuring that all other annotation types continue to be parsed and displayed as before. The changes to 'Union', 'Optional', and 'Literal' handling should only apply when a new configuration option is enabled."
    },
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__6.2/sphinx/config.py",
        "start": 1,
        "end": 520,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Build configuration file handling.\"\"\"\n2 \n3 from __future__ import annotations\n4 \n5 import re\n6 import traceback\n7 import types\n8 from os import getenv, path\n9 from typing import TYPE_CHECKING, Any, Callable, Generator, Iterator, NamedTuple\n10 \n11 from sphinx.errors import ConfigError, ExtensionError\n12 from sphinx.locale import _, __\n13 from sphinx.util import logging\n14 from sphinx.util.i18n import format_date\n15 from sphinx.util.osutil import fs_encoding\n16 from sphinx.util.tags import Tags\n17 from sphinx.util.typing import NoneType\n18 \n19 try:\n20     from contextlib import chdir  # type: ignore[attr-defined]\n21 except ImportError:\n22     from sphinx.util.osutil import _chdir as chdir\n23 \n24 if TYPE_CHECKING:\n25     from sphinx.application import Sphinx\n26     from sphinx.environment import BuildEnvironment\n27 \n28 logger = logging.getLogger(__name__)\n29 \n30 CONFIG_FILENAME = 'conf.py'\n31 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)\n32 copyright_year_re = re.compile(r'^((\\d{4}-)?)(\\d{4})(?=[ ,])')\n33 \n34 \n35 class ConfigValue(NamedTuple):\n36     name: str\n37     value: Any\n38     rebuild: bool | str\n39 \n40 \n41 def is_serializable(obj: Any) -> bool:\n42     \"\"\"Check if object is serializable or not.\"\"\"\n43     if isinstance(obj, UNSERIALIZABLE_TYPES):\n44         return False\n45     elif isinstance(obj, dict):\n46         for key, value in obj.items():\n47             if not is_serializable(key) or not is_serializable(value):\n48                 return False\n49     elif isinstance(obj, (list, tuple, set)):\n50         return all(is_serializable(i) for i in obj)\n51 \n52     return True\n53 \n54 \n55 class ENUM:\n56     \"\"\"Represents the candidates which a config value should be one of.\n57 \n58     Example:\n59         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))\n60     \"\"\"\n61     def __init__(self, *candidates: str) -> None:\n62         self.candidates = candidates\n63 \n64     def match(self, value: str | list | tuple) -> bool:\n65         if isinstance(value, (list, tuple)):\n66             return all(item in self.candidates for item in value)\n67         else:\n68             return value in self.candidates\n69 \n70 \n71 class Config:\n72     \"\"\"Configuration file abstraction.\n73 \n74     The config object makes the values of all config values available as\n75     attributes.\n76 \n77     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n78     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n79     to get the value of :confval:`language`, use either ``app.config.language``\n80     or ``env.config.language``.\n81     \"\"\"\n82 \n83     # the values are: (default, what needs to be rebuilt if changed)\n84 \n85     # If you add a value here, don't forget to include it in the\n86     # quickstart.py file template as well as in the docs!\n87 \n88     config_values: dict[str, tuple] = {\n89         # general options\n90         'project': ('Python', 'env', []),\n91         'author': ('unknown', 'env', []),\n92         'project_copyright': ('', 'html', [str]),\n93         'copyright': (lambda c: c.project_copyright, 'html', [str]),\n94         'version': ('', 'env', []),\n95         'release': ('', 'env', []),\n96         'today': ('', 'env', []),\n97         # the real default is locale-dependent\n98         'today_fmt': (None, 'env', [str]),\n99 \n100         'language': ('en', 'env', [str]),\n101         'locale_dirs': (['locales'], 'env', []),\n102         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n103         'gettext_allow_fuzzy_translations': (False, 'gettext', []),\n104 \n105         'master_doc': ('index', 'env', []),\n106         'root_doc': (lambda config: config.master_doc, 'env', []),\n107         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n108         'source_encoding': ('utf-8-sig', 'env', []),\n109         'exclude_patterns': ([], 'env', [str]),\n110         'include_patterns': ([\"**\"], 'env', [str]),\n111         'default_role': (None, 'env', [str]),\n112         'add_function_parentheses': (True, 'env', []),\n113         'add_module_names': (True, 'env', []),\n114         'toc_object_entries': (True, 'env', [bool]),\n115         'toc_object_entries_show_parents': ('domain', 'env',\n116                                             ENUM('domain', 'all', 'hide')),\n117         'trim_footnote_reference_space': (False, 'env', []),\n118         'show_authors': (False, 'env', []),\n119         'pygments_style': (None, 'html', [str]),\n120         'highlight_language': ('default', 'env', []),\n121         'highlight_options': ({}, 'env', []),\n122         'templates_path': ([], 'html', []),\n123         'template_bridge': (None, 'html', [str]),\n124         'keep_warnings': (False, 'env', []),\n125         'suppress_warnings': ([], 'env', []),\n126         'modindex_common_prefix': ([], 'html', []),\n127         'rst_epilog': (None, 'env', [str]),\n128         'rst_prolog': (None, 'env', [str]),\n129         'trim_doctest_flags': (True, 'env', []),\n130         'primary_domain': ('py', 'env', [NoneType]),\n131         'needs_sphinx': (None, None, [str]),\n132         'needs_extensions': ({}, None, []),\n133         'manpages_url': (None, 'env', []),\n134         'nitpicky': (False, None, []),\n135         'nitpick_ignore': ([], None, []),\n136         'nitpick_ignore_regex': ([], None, []),\n137         'numfig': (False, 'env', []),\n138         'numfig_secnum_depth': (1, 'env', []),\n139         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n140 \n141         'math_number_all': (False, 'env', []),\n142         'math_eqref_format': (None, 'env', [str]),\n143         'math_numfig': (True, 'env', []),\n144         'tls_verify': (True, 'env', []),\n145         'tls_cacerts': (None, 'env', []),\n146         'user_agent': (None, 'env', [str]),\n147         'smartquotes': (True, 'env', []),\n148         'smartquotes_action': ('qDe', 'env', []),\n149         'smartquotes_excludes': ({'languages': ['ja'],\n150                                   'builders': ['man', 'text']},\n151                                  'env', []),\n152         'option_emphasise_placeholders': (False, 'env', []),\n153     }\n154 \n155     def __init__(self, config: dict[str, Any] = {}, overrides: dict[str, Any] = {}) -> None:\n156         self.overrides = dict(overrides)\n157         self.values = Config.config_values.copy()\n158         self._raw_config = config\n159         self.setup: Callable | None = config.get('setup', None)\n160 \n161         if 'extensions' in self.overrides:\n162             if isinstance(self.overrides['extensions'], str):\n163                 config['extensions'] = self.overrides.pop('extensions').split(',')\n164             else:\n165                 config['extensions'] = self.overrides.pop('extensions')\n166         self.extensions: list[str] = config.get('extensions', [])\n167 \n168     @classmethod\n169     def read(\n170         cls, confdir: str, overrides: dict | None = None, tags: Tags | None = None,\n171     ) -> Config:\n172         \"\"\"Create a Config object from configuration file.\"\"\"\n173         filename = path.join(confdir, CONFIG_FILENAME)\n174         if not path.isfile(filename):\n175             raise ConfigError(__(\"config directory doesn't contain a conf.py file (%s)\") %\n176                               confdir)\n177         namespace = eval_config_file(filename, tags)\n178 \n179         # Note: Old sphinx projects have been configured as \"language = None\" because\n180         #       sphinx-quickstart previously generated this by default.\n181         #       To keep compatibility, they should be fallback to 'en' for a while\n182         #       (This conversion should not be removed before 2025-01-01).\n183         if namespace.get(\"language\", ...) is None:\n184             logger.warning(__(\"Invalid configuration value found: 'language = None'. \"\n185                               \"Update your configuration to a valid language code. \"\n186                               \"Falling back to 'en' (English).\"))\n187             namespace[\"language\"] = \"en\"\n188 \n189         return cls(namespace, overrides or {})\n190 \n191     def convert_overrides(self, name: str, value: Any) -> Any:\n192         if not isinstance(value, str):\n193             return value\n194         else:\n195             defvalue = self.values[name][0]\n196             if self.values[name][2] == Any:\n197                 return value\n198             elif self.values[name][2] == {bool, str}:\n199                 if value == '0':\n200                     # given falsy string from command line option\n201                     return False\n202                 elif value == '1':\n203                     return True\n204                 else:\n205                     return value\n206             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n207                 if value == '0':\n208                     # given falsy string from command line option\n209                     return False\n210                 else:\n211                     return bool(value)\n212             elif isinstance(defvalue, dict):\n213                 raise ValueError(__('cannot override dictionary config setting %r, '\n214                                     'ignoring (use %r to set individual elements)') %\n215                                  (name, name + '.key=value'))\n216             elif isinstance(defvalue, list):\n217                 return value.split(',')\n218             elif isinstance(defvalue, int):\n219                 try:\n220                     return int(value)\n221                 except ValueError as exc:\n222                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n223                                      (value, name)) from exc\n224             elif callable(defvalue):\n225                 return value\n226             elif defvalue is not None and not isinstance(defvalue, str):\n227                 raise ValueError(__('cannot override config setting %r with unsupported '\n228                                     'type, ignoring') % name)\n229             else:\n230                 return value\n231 \n232     def pre_init_values(self) -> None:\n233         \"\"\"\n234         Initialize some limited config variables before initializing i18n and loading\n235         extensions.\n236         \"\"\"\n237         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n238         for name in variables:\n239             try:\n240                 if name in self.overrides:\n241                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n242                 elif name in self._raw_config:\n243                     self.__dict__[name] = self._raw_config[name]\n244             except ValueError as exc:\n245                 logger.warning(\"%s\", exc)\n246 \n247     def init_values(self) -> None:\n248         config = self._raw_config\n249         for valname, value in self.overrides.items():\n250             try:\n251                 if '.' in valname:\n252                     realvalname, key = valname.split('.', 1)\n253                     config.setdefault(realvalname, {})[key] = value\n254                     continue\n255                 if valname not in self.values:\n256                     logger.warning(__('unknown config value %r in override, ignoring'),\n257                                    valname)\n258                     continue\n259                 if isinstance(value, str):\n260                     config[valname] = self.convert_overrides(valname, value)\n261                 else:\n262                     config[valname] = value\n263             except ValueError as exc:\n264                 logger.warning(\"%s\", exc)\n265         for name in config:\n266             if name in self.values:\n267                 self.__dict__[name] = config[name]\n268 \n269     def post_init_values(self) -> None:\n270         \"\"\"\n271         Initialize additional config variables that are added after init_values() called.\n272         \"\"\"\n273         config = self._raw_config\n274         for name in config:\n275             if name not in self.__dict__ and name in self.values:\n276                 self.__dict__[name] = config[name]\n277 \n278         check_confval_types(None, self)\n279 \n280     def __getattr__(self, name: str) -> Any:\n281         if name.startswith('_'):\n282             raise AttributeError(name)\n283         if name not in self.values:\n284             raise AttributeError(__('No such config value: %s') % name)\n285         default = self.values[name][0]\n286         if callable(default):\n287             return default(self)\n288         return default\n289 \n290     def __getitem__(self, name: str) -> Any:\n291         return getattr(self, name)\n292 \n293     def __setitem__(self, name: str, value: Any) -> None:\n294         setattr(self, name, value)\n295 \n296     def __delitem__(self, name: str) -> None:\n297         delattr(self, name)\n298 \n299     def __contains__(self, name: str) -> bool:\n300         return name in self.values\n301 \n302     def __iter__(self) -> Generator[ConfigValue, None, None]:\n303         for name, value in self.values.items():\n304             yield ConfigValue(name, getattr(self, name), value[1])\n305 \n306     def add(self, name: str, default: Any, rebuild: bool | str, types: Any) -> None:\n307         if name in self.values:\n308             raise ExtensionError(__('Config value %r already present') % name)\n309         self.values[name] = (default, rebuild, types)\n310 \n311     def filter(self, rebuild: str | list[str]) -> Iterator[ConfigValue]:\n312         if isinstance(rebuild, str):\n313             rebuild = [rebuild]\n314         return (value for value in self if value.rebuild in rebuild)\n315 \n316     def __getstate__(self) -> dict:\n317         \"\"\"Obtains serializable data for pickling.\"\"\"\n318         # remove potentially pickling-problematic values from config\n319         __dict__ = {}\n320         for key, value in self.__dict__.items():\n321             if key.startswith('_') or not is_serializable(value):\n322                 pass\n323             else:\n324                 __dict__[key] = value\n325 \n326         # create a picklable copy of values list\n327         __dict__['values'] = {}\n328         for key, value in self.values.items():\n329             real_value = getattr(self, key)\n330             if not is_serializable(real_value):\n331                 # omit unserializable value\n332                 real_value = None\n333 \n334             # types column is also omitted\n335             __dict__['values'][key] = (real_value, value[1], None)\n336 \n337         return __dict__\n338 \n339     def __setstate__(self, state: dict) -> None:\n340         self.__dict__.update(state)\n341 \n342 \n343 def eval_config_file(filename: str, tags: Tags | None) -> dict[str, Any]:\n344     \"\"\"Evaluate a config file.\"\"\"\n345     namespace: dict[str, Any] = {}\n346     namespace['__file__'] = filename\n347     namespace['tags'] = tags\n348 \n349     with chdir(path.dirname(filename)):\n350         # during executing config file, current dir is changed to ``confdir``.\n351         try:\n352             with open(filename, 'rb') as f:\n353                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')\n354                 exec(code, namespace)  # NoQA: S102\n355         except SyntaxError as err:\n356             msg = __(\"There is a syntax error in your configuration file: %s\\n\")\n357             raise ConfigError(msg % err) from err\n358         except SystemExit as exc:\n359             msg = __(\"The configuration file (or one of the modules it imports) \"\n360                      \"called sys.exit()\")\n361             raise ConfigError(msg) from exc\n362         except ConfigError:\n363             # pass through ConfigError from conf.py as is.  It will be shown in console.\n364             raise\n365         except Exception as exc:\n366             msg = __(\"There is a programmable error in your configuration file:\\n\\n%s\")\n367             raise ConfigError(msg % traceback.format_exc()) from exc\n368 \n369     return namespace\n370 \n371 \n372 def convert_source_suffix(app: Sphinx, config: Config) -> None:\n373     \"\"\"Convert old styled source_suffix to new styled one.\n374 \n375     * old style: str or list\n376     * new style: a dict which maps from fileext to filetype\n377     \"\"\"\n378     source_suffix = config.source_suffix\n379     if isinstance(source_suffix, str):\n380         # if str, considers as default filetype (None)\n381         #\n382         # The default filetype is determined on later step.\n383         # By default, it is considered as restructuredtext.\n384         config.source_suffix = {source_suffix: None}  # type: ignore[attr-defined]\n385     elif isinstance(source_suffix, (list, tuple)):\n386         # if list, considers as all of them are default filetype\n387         config.source_suffix = {s: None for s in source_suffix}  # type: ignore[attr-defined]\n388     elif not isinstance(source_suffix, dict):\n389         logger.warning(__(\"The config value `source_suffix' expects \"\n390                           \"a string, list of strings, or dictionary. \"\n391                           \"But `%r' is given.\" % source_suffix))\n392 \n393 \n394 def convert_highlight_options(app: Sphinx, config: Config) -> None:\n395     \"\"\"Convert old styled highlight_options to new styled one.\n396 \n397     * old style: options\n398     * new style: a dict which maps from language name to options\n399     \"\"\"\n400     options = config.highlight_options\n401     if options and not all(isinstance(v, dict) for v in options.values()):\n402         # old styled option detected because all values are not dictionary.\n403         config.highlight_options = {config.highlight_language: options}  # type: ignore\n404 \n405 \n406 def init_numfig_format(app: Sphinx, config: Config) -> None:\n407     \"\"\"Initialize :confval:`numfig_format`.\"\"\"\n408     numfig_format = {'section': _('Section %s'),\n409                      'figure': _('Fig. %s'),\n410                      'table': _('Table %s'),\n411                      'code-block': _('Listing %s')}\n412 \n413     # override default labels by configuration\n414     numfig_format.update(config.numfig_format)\n415     config.numfig_format = numfig_format  # type: ignore\n416 \n417 \n418 def correct_copyright_year(app: Sphinx, config: Config) -> None:\n419     \"\"\"Correct values of copyright year that are not coherent with\n420     the SOURCE_DATE_EPOCH environment variable (if set)\n421 \n422     See https://reproducible-builds.org/specs/source-date-epoch/\n423     \"\"\"\n424     if getenv('SOURCE_DATE_EPOCH') is not None:\n425         for k in ('copyright', 'epub_copyright'):\n426             if k in config:\n427                 replace = r'\\g<1>%s' % format_date('%Y', language='en')\n428                 config[k] = copyright_year_re.sub(replace, config[k])\n429 \n430 \n431 def check_confval_types(app: Sphinx | None, config: Config) -> None:\n432     \"\"\"Check all values for deviation from the default value's type, since\n433     that can result in TypeErrors all over the place NB.\n434     \"\"\"\n435     for confval in config:\n436         default, rebuild, annotations = config.values[confval.name]\n437 \n438         if callable(default):\n439             default = default(config)  # evaluate default value\n440         if default is None and not annotations:\n441             continue  # neither inferable nor expliclitly annotated types\n442 \n443         if annotations is Any:\n444             # any type of value is accepted\n445             pass\n446         elif isinstance(annotations, ENUM):\n447             if not annotations.match(confval.value):\n448                 msg = __(\"The config value `{name}` has to be a one of {candidates}, \"\n449                          \"but `{current}` is given.\")\n450                 logger.warning(msg.format(name=confval.name,\n451                                           current=confval.value,\n452                                           candidates=annotations.candidates), once=True)\n453         else:\n454             if type(confval.value) is type(default):\n455                 continue\n456             if type(confval.value) in annotations:\n457                 continue\n458 \n459             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &\n460                             set(type(default).__bases__))\n461             common_bases.discard(object)\n462             if common_bases:\n463                 continue  # at least we share a non-trivial base class\n464 \n465             if annotations:\n466                 msg = __(\"The config value `{name}' has type `{current.__name__}'; \"\n467                          \"expected {permitted}.\")\n468                 wrapped_annotations = [f\"`{c.__name__}'\" for c in annotations]\n469                 if len(wrapped_annotations) > 2:\n470                     permitted = (\", \".join(wrapped_annotations[:-1])\n471                                  + f\", or {wrapped_annotations[-1]}\")\n472                 else:\n473                     permitted = \" or \".join(wrapped_annotations)\n474                 logger.warning(msg.format(name=confval.name,\n475                                           current=type(confval.value),\n476                                           permitted=permitted), once=True)\n477             else:\n478                 msg = __(\"The config value `{name}' has type `{current.__name__}', \"\n479                          \"defaults to `{default.__name__}'.\")\n480                 logger.warning(msg.format(name=confval.name,\n481                                           current=type(confval.value),\n482                                           default=type(default)), once=True)\n483 \n484 \n485 def check_primary_domain(app: Sphinx, config: Config) -> None:\n486     primary_domain = config.primary_domain\n487     if primary_domain and not app.registry.has_domain(primary_domain):\n488         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)\n489         config.primary_domain = None  # type: ignore\n490 \n491 \n492 def check_root_doc(app: Sphinx, env: BuildEnvironment, added: set[str],\n493                    changed: set[str], removed: set[str]) -> set[str]:\n494     \"\"\"Adjust root_doc to 'contents' to support an old project which does not have\n495     any root_doc setting.\n496     \"\"\"\n497     if (app.config.root_doc == 'index' and\n498             'index' not in app.project.docnames and\n499             'contents' in app.project.docnames):\n500         logger.warning(__('Since v2.0, Sphinx uses \"index\" as root_doc by default. '\n501                           'Please add \"root_doc = \\'contents\\'\" to your conf.py.'))\n502         app.config.root_doc = \"contents\"  # type: ignore\n503 \n504     return changed\n505 \n506 \n507 def setup(app: Sphinx) -> dict[str, Any]:\n508     app.connect('config-inited', convert_source_suffix, priority=800)\n509     app.connect('config-inited', convert_highlight_options, priority=800)\n510     app.connect('config-inited', init_numfig_format, priority=800)\n511     app.connect('config-inited', correct_copyright_year, priority=800)\n512     app.connect('config-inited', check_confval_types, priority=800)\n513     app.connect('config-inited', check_primary_domain, priority=800)\n514     app.connect('env-get-outdated', check_root_doc)\n515 \n516     return {\n517         'version': 'builtin',\n518         'parallel_read_safe': True,\n519         'parallel_write_safe': True,\n520     }\n",
        "intended_behavior": "Introduce a new configuration option (e.g., 'simplified_type_annotations') that users can set in their project's 'conf.py' to enable or disable the simplified formatting of type annotations. The default behavior (with the option disabled) should preserve the current formatting of type annotations. Implement the logic to check this configuration option within '_parse_annotation' function (or relevant functions) and apply the new formatting rules accordingly. This ensures that the enhancements are opt-in, allowing users to upgrade Sphinx without forcing them to adopt the new annotation formatting immediately."
    }
]