[
    {
        "rel_file_path": "django/views/defaults.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/views/defaults.py",
        "start": 1,
        "end": 125,
        "class_name": null,
        "method_name": null,
        "code": "1 from urllib.parse import quote\n2 \n3 from django.http import (\n4     HttpResponseBadRequest, HttpResponseForbidden, HttpResponseNotFound,\n5     HttpResponseServerError,\n6 )\n7 from django.template import Context, Engine, TemplateDoesNotExist, loader\n8 from django.views.decorators.csrf import requires_csrf_token\n9 \n10 ERROR_404_TEMPLATE_NAME = '404.html'\n11 ERROR_403_TEMPLATE_NAME = '403.html'\n12 ERROR_400_TEMPLATE_NAME = '400.html'\n13 ERROR_500_TEMPLATE_NAME = '500.html'\n14 \n15 \n16 # This can be called when CsrfViewMiddleware.process_view has not run,\n17 # therefore need @requires_csrf_token in case the template needs\n18 # {% csrf_token %}.\n19 @requires_csrf_token\n20 def page_not_found(request, exception, template_name=ERROR_404_TEMPLATE_NAME):\n21     \"\"\"\n22     Default 404 handler.\n23 \n24     Templates: :template:`404.html`\n25     Context:\n26         request_path\n27             The path of the requested URL (e.g., '/app/pages/bad_page/'). It's\n28             quoted to prevent a content injection attack.\n29         exception\n30             The message from the exception which triggered the 404 (if one was\n31             supplied), or the exception class name\n32     \"\"\"\n33     exception_repr = exception.__class__.__name__\n34     # Try to get an \"interesting\" exception message, if any (and not the ugly\n35     # Resolver404 dictionary)\n36     try:\n37         message = exception.args[0]\n38     except (AttributeError, IndexError):\n39         pass\n40     else:\n41         if isinstance(message, str):\n42             exception_repr = message\n43     context = {\n44         'request_path': quote(request.path),\n45         'exception': exception_repr,\n46     }\n47     try:\n48         template = loader.get_template(template_name)\n49         body = template.render(context, request)\n50         content_type = None             # Django will use 'text/html'.\n51     except TemplateDoesNotExist:\n52         if template_name != ERROR_404_TEMPLATE_NAME:\n53             # Reraise if it's a missing custom template.\n54             raise\n55         # Render template (even though there are no substitutions) to allow\n56         # inspecting the context in tests.\n57         template = Engine().from_string(\n58             '<h1>Not Found</h1>'\n59             '<p>The requested resource was not found on this server.</p>')\n60         body = template.render(Context(context))\n61         content_type = 'text/html'\n62     return HttpResponseNotFound(body, content_type=content_type)\n63 \n64 \n65 @requires_csrf_token\n66 def server_error(request, template_name=ERROR_500_TEMPLATE_NAME):\n67     \"\"\"\n68     500 error handler.\n69 \n70     Templates: :template:`500.html`\n71     Context: None\n72     \"\"\"\n73     try:\n74         template = loader.get_template(template_name)\n75     except TemplateDoesNotExist:\n76         if template_name != ERROR_500_TEMPLATE_NAME:\n77             # Reraise if it's a missing custom template.\n78             raise\n79         return HttpResponseServerError('<h1>Server Error (500)</h1>', content_type='text/html')\n80     return HttpResponseServerError(template.render())\n81 \n82 \n83 @requires_csrf_token\n84 def bad_request(request, exception, template_name=ERROR_400_TEMPLATE_NAME):\n85     \"\"\"\n86     400 error handler.\n87 \n88     Templates: :template:`400.html`\n89     Context: None\n90     \"\"\"\n91     try:\n92         template = loader.get_template(template_name)\n93     except TemplateDoesNotExist:\n94         if template_name != ERROR_400_TEMPLATE_NAME:\n95             # Reraise if it's a missing custom template.\n96             raise\n97         return HttpResponseBadRequest('<h1>Bad Request (400)</h1>', content_type='text/html')\n98     # No exception content is passed to the template, to not disclose any sensitive information.\n99     return HttpResponseBadRequest(template.render())\n100 \n101 \n102 # This can be called when CsrfViewMiddleware.process_view has not run,\n103 # therefore need @requires_csrf_token in case the template needs\n104 # {% csrf_token %}.\n105 @requires_csrf_token\n106 def permission_denied(request, exception, template_name=ERROR_403_TEMPLATE_NAME):\n107     \"\"\"\n108     Permission denied (403) handler.\n109 \n110     Templates: :template:`403.html`\n111     Context: None\n112 \n113     If the template does not exist, an Http403 response containing the text\n114     \"403 Forbidden\" (as per RFC 7231) will be returned.\n115     \"\"\"\n116     try:\n117         template = loader.get_template(template_name)\n118     except TemplateDoesNotExist:\n119         if template_name != ERROR_403_TEMPLATE_NAME:\n120             # Reraise if it's a missing custom template.\n121             raise\n122         return HttpResponseForbidden('<h1>403 Forbidden</h1>', content_type='text/html')\n123     return HttpResponseForbidden(\n124         template.render(request=request, context={'exception': str(exception)})\n125     )\n",
        "intended_behavior": "The function responsible for handling 404 errors should ensure that if it fails to find a custom 404 template and resorts to rendering default content, this content is a well-formed HTML document."
    }
]