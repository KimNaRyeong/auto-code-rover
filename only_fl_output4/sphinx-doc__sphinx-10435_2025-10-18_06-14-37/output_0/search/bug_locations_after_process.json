[
    {
        "rel_file_path": "sphinx/writers/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/writers/latex.py",
        "start": 66,
        "end": 87,
        "class_name": "LaTeXWriter",
        "method_name": null,
        "code": "66 class LaTeXWriter(writers.Writer):\n67 \n68     supported = ('sphinxlatex',)\n69 \n70     settings_spec = ('LaTeX writer options', '', (\n71         ('Document name', ['--docname'], {'default': ''}),\n72         ('Document class', ['--docclass'], {'default': 'manual'}),\n73         ('Author', ['--author'], {'default': ''}),\n74     ))\n75     settings_defaults: Dict = {}\n76 \n77     output = None\n78 \n79     def __init__(self, builder: \"LaTeXBuilder\") -> None:\n80         super().__init__()\n81         self.builder = builder\n82         self.theme: Theme = None\n83 \n84     def translate(self) -> None:\n85         visitor = self.builder.create_translator(self.document, self.builder, self.theme)\n86         self.document.walkabout(visitor)\n87         self.output = cast(LaTeXTranslator, visitor).astext()\n",
        "intended_behavior": "The code within these methods should ensure inline code is formatted without additional spaces around it when converted to LaTeX syntax. This involves properly handling escape sequences and formatting commands like \\sphinxcode, \\sphinxupquote, and \\PYG directives, ensuring they do not introduce or are not followed by unwanted whitespace. The intended behavior should maintain syntax highlighting without altering the intended output spacing."
    },
    {
        "rel_file_path": "sphinx/highlighting.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/highlighting.py",
        "start": 1,
        "end": 171,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Highlight code blocks using Pygments.\"\"\"\n2 \n3 from functools import partial\n4 from importlib import import_module\n5 from typing import Any, Dict\n6 \n7 from packaging import version\n8 from pygments import __version__ as pygmentsversion\n9 from pygments import highlight\n10 from pygments.filters import ErrorToken\n11 from pygments.formatter import Formatter\n12 from pygments.formatters import HtmlFormatter, LatexFormatter\n13 from pygments.lexer import Lexer\n14 from pygments.lexers import (CLexer, Python3Lexer, PythonConsoleLexer, PythonLexer, RstLexer,\n15                              TextLexer, get_lexer_by_name, guess_lexer)\n16 from pygments.style import Style\n17 from pygments.styles import get_style_by_name\n18 from pygments.util import ClassNotFound\n19 \n20 from sphinx.locale import __\n21 from sphinx.pygments_styles import NoneStyle, SphinxStyle\n22 from sphinx.util import logging, texescape\n23 \n24 logger = logging.getLogger(__name__)\n25 \n26 lexers: Dict[str, Lexer] = {}\n27 lexer_classes: Dict[str, Lexer] = {\n28     'none': partial(TextLexer, stripnl=False),\n29     'python': partial(PythonLexer, stripnl=False),\n30     'python3': partial(Python3Lexer, stripnl=False),\n31     'pycon': partial(PythonConsoleLexer, stripnl=False),\n32     'pycon3': partial(PythonConsoleLexer, python3=True, stripnl=False),\n33     'rest': partial(RstLexer, stripnl=False),\n34     'c': partial(CLexer, stripnl=False),\n35 }\n36 \n37 \n38 escape_hl_chars = {ord('\\\\'): '\\\\PYGZbs{}',\n39                    ord('{'): '\\\\PYGZob{}',\n40                    ord('}'): '\\\\PYGZcb{}'}\n41 \n42 # used if Pygments is available\n43 # use textcomp quote to get a true single quote\n44 _LATEX_ADD_STYLES = r'''\n45 \\renewcommand\\PYGZsq{\\textquotesingle}\n46 '''\n47 # fix extra space between lines when Pygments highlighting uses \\fcolorbox\n48 # add a {..} to limit \\fboxsep scope, and force \\fcolorbox use correct value\n49 # cf pygments #1708 which makes this unneeded for Pygments > 2.7.4\n50 _LATEX_ADD_STYLES_FIXPYG = r'''\n51 \\makeatletter\n52 % fix for Pygments <= 2.7.4\n53 \\let\\spx@original@fcolorbox\\fcolorbox\n54 \\def\\spx@fixpyg@fcolorbox{\\fboxsep-\\fboxrule\\spx@original@fcolorbox}\n55 \\def\\PYG#1#2{\\PYG@reset\\PYG@toks#1+\\relax+%\n56              {\\let\\fcolorbox\\spx@fixpyg@fcolorbox\\PYG@do{#2}}}\n57 \\makeatother\n58 '''\n59 if version.parse(pygmentsversion).release <= (2, 7, 4):\n60     _LATEX_ADD_STYLES += _LATEX_ADD_STYLES_FIXPYG\n61 \n62 \n63 class PygmentsBridge:\n64     # Set these attributes if you want to have different Pygments formatters\n65     # than the default ones.\n66     html_formatter = HtmlFormatter\n67     latex_formatter = LatexFormatter\n68 \n69     def __init__(self, dest: str = 'html', stylename: str = 'sphinx',\n70                  latex_engine: str = None) -> None:\n71         self.dest = dest\n72         self.latex_engine = latex_engine\n73 \n74         style = self.get_style(stylename)\n75         self.formatter_args: Dict[str, Any] = {'style': style}\n76         if dest == 'html':\n77             self.formatter = self.html_formatter\n78         else:\n79             self.formatter = self.latex_formatter\n80             self.formatter_args['commandprefix'] = 'PYG'\n81 \n82     def get_style(self, stylename: str) -> Style:\n83         if stylename is None or stylename == 'sphinx':\n84             return SphinxStyle\n85         elif stylename == 'none':\n86             return NoneStyle\n87         elif '.' in stylename:\n88             module, stylename = stylename.rsplit('.', 1)\n89             return getattr(import_module(module), stylename)\n90         else:\n91             return get_style_by_name(stylename)\n92 \n93     def get_formatter(self, **kwargs: Any) -> Formatter:\n94         kwargs.update(self.formatter_args)\n95         return self.formatter(**kwargs)\n96 \n97     def get_lexer(self, source: str, lang: str, opts: Dict = None,\n98                   force: bool = False, location: Any = None) -> Lexer:\n99         if not opts:\n100             opts = {}\n101 \n102         # find out which lexer to use\n103         if lang in ('py', 'python'):\n104             if source.startswith('>>>'):\n105                 # interactive session\n106                 lang = 'pycon'\n107             else:\n108                 lang = 'python'\n109         elif lang in ('py3', 'python3', 'default'):\n110             if source.startswith('>>>'):\n111                 lang = 'pycon3'\n112             else:\n113                 lang = 'python3'\n114 \n115         if lang in lexers:\n116             # just return custom lexers here (without installing raiseonerror filter)\n117             return lexers[lang]\n118         elif lang in lexer_classes:\n119             lexer = lexer_classes[lang](**opts)\n120         else:\n121             try:\n122                 if lang == 'guess':\n123                     lexer = guess_lexer(source, **opts)\n124                 else:\n125                     lexer = get_lexer_by_name(lang, **opts)\n126             except ClassNotFound:\n127                 logger.warning(__('Pygments lexer name %r is not known'), lang,\n128                                location=location)\n129                 lexer = lexer_classes['none'](**opts)\n130 \n131         if not force:\n132             lexer.add_filter('raiseonerror')\n133 \n134         return lexer\n135 \n136     def highlight_block(self, source: str, lang: str, opts: Dict = None,\n137                         force: bool = False, location: Any = None, **kwargs: Any) -> str:\n138         if not isinstance(source, str):\n139             source = source.decode()\n140 \n141         lexer = self.get_lexer(source, lang, opts, force, location)\n142 \n143         # highlight via Pygments\n144         formatter = self.get_formatter(**kwargs)\n145         try:\n146             hlsource = highlight(source, lexer, formatter)\n147         except ErrorToken:\n148             # this is most probably not the selected language,\n149             # so let it pass unhighlighted\n150             if lang == 'default':\n151                 pass  # automatic highlighting failed.\n152             else:\n153                 logger.warning(__('Could not lex literal_block as \"%s\". '\n154                                   'Highlighting skipped.'), lang,\n155                                type='misc', subtype='highlighting_failure',\n156                                location=location)\n157             lexer = self.get_lexer(source, 'none', opts, force, location)\n158             hlsource = highlight(source, lexer, formatter)\n159 \n160         if self.dest == 'html':\n161             return hlsource\n162         else:\n163             # MEMO: this is done to escape Unicode chars with non-Unicode engines\n164             return texescape.hlescape(hlsource, self.latex_engine)\n165 \n166     def get_stylesheet(self) -> str:\n167         formatter = self.get_formatter()\n168         if self.dest == 'html':\n169             return formatter.get_style_defs('.highlight')\n170         else:\n171             return formatter.get_style_defs() + _LATEX_ADD_STYLES\n",
        "intended_behavior": "Ensure that the handling of escaped characters and syntax highlighting commands for LaTeX does not introduce additional spaces around inline code blocks. This might involve adjusting how escape sequences are inserted or ensuring that any function responsible for wrapping code in highlighting commands trims or explicitly manages surrounding spaces."
    }
]