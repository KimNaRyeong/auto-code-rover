2025-10-18 04:48:24.850 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 04:48:27.616 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=167, output_tokens=12, cost=0.002030
2025-10-18 04:48:37.362 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=347, output_tokens=369, cost=0.014540
2025-10-18 04:48:49.444 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=347, output_tokens=474, cost=0.017690
2025-10-18 04:48:50.403 | INFO     | registered non reproducing test 1
2025-10-18 04:49:01.857 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1166, output_tokens=496, cost=0.026540
2025-10-18 04:49:02.814 | INFO     | registered non reproducing test 2
2025-10-18 04:49:02.814 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 04:49:02.820 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:49:12.290 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=360, cost=0.015540
2025-10-18 04:49:12.297 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:49:15.723 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=714, output_tokens=37, cost=0.008250
2025-10-18 04:49:15.724 | DEBUG    | Extracted a valid json.
2025-10-18 04:49:15.725 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method('pytest.raises')",
        "search_code('assertionError, match=')"
    ],
    "bug_locations": []
}
2025-10-18 04:49:15.740 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:49:15.741 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:49:28.455 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=531, cost=0.025850
2025-10-18 04:49:28.467 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:49:30.166 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1739, output_tokens=39, cost=0.018560
2025-10-18 04:49:30.169 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:49:34.174 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=393, output_tokens=49, cost=0.005400
2025-10-18 04:49:34.175 | DEBUG    | Extracted a valid json.
2025-10-18 04:49:34.175 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code('encode')",
        "search_code('decode')",
        "search_code('assert ')",
        "search_code('with pytest.raises')"
    ],
    "bug_locations": []
}
2025-10-18 04:49:35.314 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:49:35.315 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:49:52.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4854, output_tokens=773, cost=0.071730
2025-10-18 04:49:52.669 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:50:04.685 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5843, output_tokens=520, cost=0.074030
2025-10-18 04:50:04.694 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:50:12.227 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=874, output_tokens=281, cost=0.017170
2025-10-18 04:50:12.229 | DEBUG    | Extracted a valid json.
2025-10-18 04:50:12.229 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/assertion/rewrite.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that methods dealing with assertion errors properly handle Unicode characters, possibly by making sure encoding conversions are handled correctly under Python 2. This may involve explicitly encoding Unicode strings to UTF-8 (or another appropriate encoding) before they are processed or outputted."
        },
        {
            "file": "src/_pytest/compat.py",
            "class": "",
            "method": "",
            "intended_behavior": "Verify and, if necessary, adjust the encoding and decoding utilities to ensure they gracefully handle Unicode strings, especially in the context of assertions and exceptions. For example, utility functions could be designed to encode Unicode strings to a specific encoding only when running under Python 2, using `sys.version_info` checks."
        },
        {
            "file": "testing/python/raises.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure any test cases that use `pytest.raises` with Unicode strings are correctly designed to handle or expect Unicode characters without causing encoding errors. If this file contains custom utility functions or helpers around `pytest.raises`, verify these helpers manage Unicode strings properly under Python 2."
        }
    ]
}
2025-10-18 04:50:12.238 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/assertion/rewrite.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 """Rewrite assertion AST to produce nice error messages"""
3 from __future__ import absolute_import
4 from __future__ import division
5 from __future__ import print_function
6 
7 import ast
8 import errno
9 import imp
10 import itertools
11 import marshal
12 import os
13 import re
14 import string
15 import struct
16 import sys
17 import types
18 
19 import atomicwrites
20 import py
21 import six
22 
23 from _pytest._io.saferepr import saferepr
24 from _pytest.assertion import util
25 from _pytest.assertion.util import (  # noqa: F401
26     format_explanation as _format_explanation,
27 )
28 from _pytest.compat import spec_from_file_location
29 from _pytest.pathlib import fnmatch_ex
30 from _pytest.pathlib import PurePath
31 
32 # pytest caches rewritten pycs in __pycache__.
33 if hasattr(imp, "get_tag"):
34     PYTEST_TAG = imp.get_tag() + "-PYTEST"
35 else:
36     if hasattr(sys, "pypy_version_info"):
37         impl = "pypy"
38     elif sys.platform == "java":
39         impl = "jython"
40     else:
41         impl = "cpython"
42     ver = sys.version_info
43     PYTEST_TAG = "%s-%s%s-PYTEST" % (impl, ver[0], ver[1])
44     del ver, impl
45 
46 PYC_EXT = ".py" + (__debug__ and "c" or "o")
47 PYC_TAIL = "." + PYTEST_TAG + PYC_EXT
48 
49 ASCII_IS_DEFAULT_ENCODING = sys.version_info[0] < 3
50 
51 if sys.version_info >= (3, 5):
52     ast_Call = ast.Call
53 else:
54 
55     def ast_Call(a, b, c):
56         return ast.Call(a, b, c, None, None)
57 
58 
59 class AssertionRewritingHook(object):
60     """PEP302 Import hook which rewrites asserts."""
61 
62     def __init__(self, config):
63         self.config = config
64         try:
65             self.fnpats = config.getini("python_files")
66         except ValueError:
67             self.fnpats = ["test_*.py", "*_test.py"]
68         self.session = None
69         self.modules = {}
70         self._rewritten_names = set()
71         self._must_rewrite = set()
72         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
73         # which might result in infinite recursion (#3506)
74         self._writing_pyc = False
75         self._basenames_to_check_rewrite = {"conftest"}
76         self._marked_for_rewrite_cache = {}
77         self._session_paths_checked = False
78 
79     def set_session(self, session):
80         self.session = session
81         self._session_paths_checked = False
82 
83     def _imp_find_module(self, name, path=None):
84         """Indirection so we can mock calls to find_module originated from the hook during testing"""
85         return imp.find_module(name, path)
86 
87     def find_module(self, name, path=None):
88         if self._writing_pyc:
89             return None
90         state = self.config._assertstate
91         if self._early_rewrite_bailout(name, state):
92             return None
93         state.trace("find_module called for: %s" % name)
94         names = name.rsplit(".", 1)
95         lastname = names[-1]
96         pth = None
97         if path is not None:
98             # Starting with Python 3.3, path is a _NamespacePath(), which
99             # causes problems if not converted to list.
100             path = list(path)
101             if len(path) == 1:
102                 pth = path[0]
103         if pth is None:
104             try:
105                 fd, fn, desc = self._imp_find_module(lastname, path)
106             except ImportError:
107                 return None
108             if fd is not None:
109                 fd.close()
110             tp = desc[2]
111             if tp == imp.PY_COMPILED:
112                 if hasattr(imp, "source_from_cache"):
113                     try:
114                         fn = imp.source_from_cache(fn)
115                     except ValueError:
116                         # Python 3 doesn't like orphaned but still-importable
117                         # .pyc files.
118                         fn = fn[:-1]
119                 else:
120                     fn = fn[:-1]
121             elif tp != imp.PY_SOURCE:
122                 # Don't know what this is.
123                 return None
124         else:
125             fn = os.path.join(pth, name.rpartition(".")[2] + ".py")
126 
127         fn_pypath = py.path.local(fn)
128         if not self._should_rewrite(name, fn_pypath, state):
129             return None
130 
131         self._rewritten_names.add(name)
132 
133         # The requested module looks like a test file, so rewrite it. This is
134         # the most magical part of the process: load the source, rewrite the
135         # asserts, and load the rewritten source. We also cache the rewritten
136         # module code in a special pyc. We must be aware of the possibility of
137         # concurrent pytest processes rewriting and loading pycs. To avoid
138         # tricky race conditions, we maintain the following invariant: The
139         # cached pyc is always a complete, valid pyc. Operations on it must be
140         # atomic. POSIX's atomic rename comes in handy.
141         write = not sys.dont_write_bytecode
142         cache_dir = os.path.join(fn_pypath.dirname, "__pycache__")
143         if write:
144             try:
145                 os.mkdir(cache_dir)
146             except OSError:
147                 e = sys.exc_info()[1].errno
148                 if e == errno.EEXIST:
149                     # Either the __pycache__ directory already exists (the
150                     # common case) or it's blocked by a non-dir node. In the
151                     # latter case, we'll ignore it in _write_pyc.
152                     pass
153                 elif e in [errno.ENOENT, errno.ENOTDIR]:
154                     # One of the path components was not a directory, likely
155                     # because we're in a zip file.
156                     write = False
157                 elif e in [errno.EACCES, errno.EROFS, errno.EPERM]:
158                     state.trace("read only directory: %r" % fn_pypath.dirname)
159                     write = False
160                 else:
161                     raise
162         cache_name = fn_pypath.basename[:-3] + PYC_TAIL
163         pyc = os.path.join(cache_dir, cache_name)
164         # Notice that even if we're in a read-only directory, I'm going
165         # to check for a cached pyc. This may not be optimal...
166         co = _read_pyc(fn_pypath, pyc, state.trace)
167         if co is None:
168             state.trace("rewriting %r" % (fn,))
169             source_stat, co = _rewrite_test(self.config, fn_pypath)
170             if co is None:
171                 # Probably a SyntaxError in the test.
172                 return None
173             if write:
174                 self._writing_pyc = True
175                 try:
176                     _write_pyc(state, co, source_stat, pyc)
177                 finally:
178                     self._writing_pyc = False
179         else:
180             state.trace("found cached rewritten pyc for %r" % (fn,))
181         self.modules[name] = co, pyc
182         return self
183 
184     def _early_rewrite_bailout(self, name, state):
185         """
186         This is a fast way to get out of rewriting modules. Profiling has
187         shown that the call to imp.find_module (inside of the find_module
188         from this class) is a major slowdown, so, this method tries to
189         filter what we're sure won't be rewritten before getting to it.
190         """
191         if self.session is not None and not self._session_paths_checked:
192             self._session_paths_checked = True
193             for path in self.session._initialpaths:
194                 # Make something as c:/projects/my_project/path.py ->
195                 #     ['c:', 'projects', 'my_project', 'path.py']
196                 parts = str(path).split(os.path.sep)
197                 # add 'path' to basenames to be checked.
198                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])
199 
200         # Note: conftest already by default in _basenames_to_check_rewrite.
201         parts = name.split(".")
202         if parts[-1] in self._basenames_to_check_rewrite:
203             return False
204 
205         # For matching the name it must be as if it was a filename.
206         path = PurePath(os.path.sep.join(parts) + ".py")
207 
208         for pat in self.fnpats:
209             # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
210             # on the name alone because we need to match against the full path
211             if os.path.dirname(pat):
212                 return False
213             if fnmatch_ex(pat, path):
214                 return False
215 
216         if self._is_marked_for_rewrite(name, state):
217             return False
218 
219         state.trace("early skip of rewriting module: %s" % (name,))
220         return True
221 
222     def _should_rewrite(self, name, fn_pypath, state):
223         # always rewrite conftest files
224         fn = str(fn_pypath)
225         if fn_pypath.basename == "conftest.py":
226             state.trace("rewriting conftest file: %r" % (fn,))
227             return True
228 
229         if self.session is not None:
230             if self.session.isinitpath(fn):
231                 state.trace("matched test file (was specified on cmdline): %r" % (fn,))
232                 return True
233 
234         # modules not passed explicitly on the command line are only
235         # rewritten if they match the naming convention for test files
236         for pat in self.fnpats:
237             if fn_pypath.fnmatch(pat):
238                 state.trace("matched test file %r" % (fn,))
239                 return True
240 
241         return self._is_marked_for_rewrite(name, state)
242 
243     def _is_marked_for_rewrite(self, name, state):
244         try:
245             return self._marked_for_rewrite_cache[name]
246         except KeyError:
247             for marked in self._must_rewrite:
248                 if name == marked or name.startswith(marked + "."):
249                     state.trace("matched marked file %r (from %r)" % (name, marked))
250                     self._marked_for_rewrite_cache[name] = True
251                     return True
252 
253             self._marked_for_rewrite_cache[name] = False
254             return False
255 
256     def mark_rewrite(self, *names):
257         """Mark import names as needing to be rewritten.
258 
259         The named module or package as well as any nested modules will
260         be rewritten on import.
261         """
262         already_imported = (
263             set(names).intersection(sys.modules).difference(self._rewritten_names)
264         )
265         for name in already_imported:
266             if not AssertionRewriter.is_rewrite_disabled(
267                 sys.modules[name].__doc__ or ""
268             ):
269                 self._warn_already_imported(name)
270         self._must_rewrite.update(names)
271         self._marked_for_rewrite_cache.clear()
272 
273     def _warn_already_imported(self, name):
274         from _pytest.warning_types import PytestAssertRewriteWarning
275         from _pytest.warnings import _issue_warning_captured
276 
277         _issue_warning_captured(
278             PytestAssertRewriteWarning(
279                 "Module already imported so cannot be rewritten: %s" % name
280             ),
281             self.config.hook,
282             stacklevel=5,
283         )
284 
285     def load_module(self, name):
286         co, pyc = self.modules.pop(name)
287         if name in sys.modules:
288             # If there is an existing module object named 'fullname' in
289             # sys.modules, the loader must use that existing module. (Otherwise,
290             # the reload() builtin will not work correctly.)
291             mod = sys.modules[name]
292         else:
293             # I wish I could just call imp.load_compiled here, but __file__ has to
294             # be set properly. In Python 3.2+, this all would be handled correctly
295             # by load_compiled.
296             mod = sys.modules[name] = imp.new_module(name)
297         try:
298             mod.__file__ = co.co_filename
299             # Normally, this attribute is 3.2+.
300             mod.__cached__ = pyc
301             mod.__loader__ = self
302             # Normally, this attribute is 3.4+
303             mod.__spec__ = spec_from_file_location(name, co.co_filename, loader=self)
304             exec(co, mod.__dict__)
305         except:  # noqa
306             if name in sys.modules:
307                 del sys.modules[name]
308             raise
309         return sys.modules[name]
310 
311     def is_package(self, name):
312         try:
313             fd, fn, desc = self._imp_find_module(name)
314         except ImportError:
315             return False
316         if fd is not None:
317             fd.close()
318         tp = desc[2]
319         return tp == imp.PKG_DIRECTORY
320 
321     def get_data(self, pathname):
322         """Optional PEP302 get_data API.
323         """
324         with open(pathname, "rb") as f:
325             return f.read()
326 
327 
328 def _write_pyc(state, co, source_stat, pyc):
329     # Technically, we don't have to have the same pyc format as
330     # (C)Python, since these "pycs" should never be seen by builtin
331     # import. However, there's little reason deviate, and I hope
332     # sometime to be able to use imp.load_compiled to load them. (See
333     # the comment in load_module above.)
334     try:
335         with atomicwrites.atomic_write(pyc, mode="wb", overwrite=True) as fp:
336             fp.write(imp.get_magic())
337             # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
338             mtime = int(source_stat.mtime) & 0xFFFFFFFF
339             size = source_stat.size & 0xFFFFFFFF
340             # "<LL" stands for 2 unsigned longs, little-ending
341             fp.write(struct.pack("<LL", mtime, size))
342             fp.write(marshal.dumps(co))
343     except EnvironmentError as e:
344         state.trace("error writing pyc file at %s: errno=%s" % (pyc, e.errno))
345         # we ignore any failure to write the cache file
346         # there are many reasons, permission-denied, __pycache__ being a
347         # file etc.
348         return False
349     return True
350 
351 
352 RN = "\r\n".encode("utf-8")
353 N = "\n".encode("utf-8")
354 
355 cookie_re = re.compile(r"^[ \t\f]*#.*coding[:=][ \t]*[-\w.]+")
356 BOM_UTF8 = "\xef\xbb\xbf"
357 
358 
359 def _rewrite_test(config, fn):
360     """Try to read and rewrite *fn* and return the code object."""
361     state = config._assertstate
362     try:
363         stat = fn.stat()
364         source = fn.read("rb")
365     except EnvironmentError:
366         return None, None
367     if ASCII_IS_DEFAULT_ENCODING:
368         # ASCII is the default encoding in Python 2. Without a coding
369         # declaration, Python 2 will complain about any bytes in the file
370         # outside the ASCII range. Sadly, this behavior does not extend to
371         # compile() or ast.parse(), which prefer to interpret the bytes as
372         # latin-1. (At least they properly handle explicit coding cookies.) To
373         # preserve this error behavior, we could force ast.parse() to use ASCII
374         # as the encoding by inserting a coding cookie. Unfortunately, that
375         # messes up line numbers. Thus, we have to check ourselves if anything
376         # is outside the ASCII range in the case no encoding is explicitly
377         # declared. For more context, see issue #269. Yay for Python 3 which
378         # gets this right.
379         end1 = source.find("\n")
380         end2 = source.find("\n", end1 + 1)
381         if (
382             not source.startswith(BOM_UTF8)
383             and cookie_re.match(source[0:end1]) is None
384             and cookie_re.match(source[end1 + 1 : end2]) is None
385         ):
386             if hasattr(state, "_indecode"):
387                 # encodings imported us again, so don't rewrite.
388                 return None, None
389             state._indecode = True
390             try:
391                 try:
392                     source.decode("ascii")
393                 except UnicodeDecodeError:
394                     # Let it fail in real import.
395                     return None, None
396             finally:
397                 del state._indecode
398     try:
399         tree = ast.parse(source, filename=fn.strpath)
400     except SyntaxError:
401         # Let this pop up again in the real import.
402         state.trace("failed to parse: %r" % (fn,))
403         return None, None
404     rewrite_asserts(tree, fn, config)
405     try:
406         co = compile(tree, fn.strpath, "exec", dont_inherit=True)
407     except SyntaxError:
408         # It's possible that this error is from some bug in the
409         # assertion rewriting, but I don't know of a fast way to tell.
410         state.trace("failed to compile: %r" % (fn,))
411         return None, None
412     return stat, co
413 
414 
415 def _read_pyc(source, pyc, trace=lambda x: None):
416     """Possibly read a pytest pyc containing rewritten code.
417 
418     Return rewritten code if successful or None if not.
419     """
420     try:
421         fp = open(pyc, "rb")
422     except IOError:
423         return None
424     with fp:
425         try:
426             mtime = int(source.mtime())
427             size = source.size()
428             data = fp.read(12)
429         except EnvironmentError as e:
430             trace("_read_pyc(%s): EnvironmentError %s" % (source, e))
431             return None
432         # Check for invalid or out of date pyc file.
433         if (
434             len(data) != 12
435             or data[:4] != imp.get_magic()
436             or struct.unpack("<LL", data[4:]) != (mtime & 0xFFFFFFFF, size & 0xFFFFFFFF)
437         ):
438             trace("_read_pyc(%s): invalid or out of date pyc" % source)
439             return None
440         try:
441             co = marshal.load(fp)
442         except Exception as e:
443             trace("_read_pyc(%s): marshal.load error %s" % (source, e))
444             return None
445         if not isinstance(co, types.CodeType):
446             trace("_read_pyc(%s): not a code object" % source)
447             return None
448         return co
449 
450 
451 def rewrite_asserts(mod, module_path=None, config=None):
452     """Rewrite the assert statements in mod."""
453     AssertionRewriter(module_path, config).run(mod)
454 
455 
456 def _saferepr(obj):
457     """Get a safe repr of an object for assertion error messages.
458 
459     The assertion formatting (util.format_explanation()) requires
460     newlines to be escaped since they are a special character for it.
461     Normally assertion.util.format_explanation() does this but for a
462     custom repr it is possible to contain one of the special escape
463     sequences, especially '\n{' and '\n}' are likely to be present in
464     JSON reprs.
465 
466     """
467     r = saferepr(obj)
468     # only occurs in python2.x, repr must return text in python3+
469     if isinstance(r, bytes):
470         # Represent unprintable bytes as `\x##`
471         r = u"".join(
472             u"\\x{:x}".format(ord(c)) if c not in string.printable else c.decode()
473             for c in r
474         )
475     return r.replace(u"\n", u"\\n")
476 
477 
478 def _format_assertmsg(obj):
479     """Format the custom assertion message given.
480 
481     For strings this simply replaces newlines with '\n~' so that
482     util.format_explanation() will preserve them instead of escaping
483     newlines.  For other objects saferepr() is used first.
484 
485     """
486     # reprlib appears to have a bug which means that if a string
487     # contains a newline it gets escaped, however if an object has a
488     # .__repr__() which contains newlines it does not get escaped.
489     # However in either case we want to preserve the newline.
490     replaces = [(u"\n", u"\n~"), (u"%", u"%%")]
491     if not isinstance(obj, six.string_types):
492         obj = saferepr(obj)
493         replaces.append((u"\\n", u"\n~"))
494 
495     if isinstance(obj, bytes):
496         replaces = [(r1.encode(), r2.encode()) for r1, r2 in replaces]
497 
498     for r1, r2 in replaces:
499         obj = obj.replace(r1, r2)
500 
501     return obj
502 
503 
504 def _should_repr_global_name(obj):
505     if callable(obj):
506         return False
507 
508     try:
509         return not hasattr(obj, "__name__")
510     except Exception:
511         return True
512 
513 
514 def _format_boolop(explanations, is_or):
515     explanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
516     if isinstance(explanation, six.text_type):
517         return explanation.replace(u"%", u"%%")
518     else:
519         return explanation.replace(b"%", b"%%")
520 
521 
522 def _call_reprcompare(ops, results, expls, each_obj):
523     for i, res, expl in zip(range(len(ops)), results, expls):
524         try:
525             done = not res
526         except Exception:
527             done = True
528         if done:
529             break
530     if util._reprcompare is not None:
531         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
532         if custom is not None:
533             return custom
534     return expl
535 
536 
537 unary_map = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}
538 
539 binop_map = {
540     ast.BitOr: "|",
541     ast.BitXor: "^",
542     ast.BitAnd: "&",
543     ast.LShift: "<<",
544     ast.RShift: ">>",
545     ast.Add: "+",
546     ast.Sub: "-",
547     ast.Mult: "*",
548     ast.Div: "/",
549     ast.FloorDiv: "//",
550     ast.Mod: "%%",  # escaped for string formatting
551     ast.Eq: "==",
552     ast.NotEq: "!=",
553     ast.Lt: "<",
554     ast.LtE: "<=",
555     ast.Gt: ">",
556     ast.GtE: ">=",
557     ast.Pow: "**",
558     ast.Is: "is",
559     ast.IsNot: "is not",
560     ast.In: "in",
561     ast.NotIn: "not in",
562 }
563 # Python 3.5+ compatibility
564 try:
565     binop_map[ast.MatMult] = "@"
566 except AttributeError:
567     pass
568 
569 # Python 3.4+ compatibility
570 if hasattr(ast, "NameConstant"):
571     _NameConstant = ast.NameConstant
572 else:
573 
574     def _NameConstant(c):
575         return ast.Name(str(c), ast.Load())
576 
577 
578 def set_location(node, lineno, col_offset):
579     """Set node location information recursively."""
580 
581     def _fix(node, lineno, col_offset):
582         if "lineno" in node._attributes:
583             node.lineno = lineno
584         if "col_offset" in node._attributes:
585             node.col_offset = col_offset
586         for child in ast.iter_child_nodes(node):
587             _fix(child, lineno, col_offset)
588 
589     _fix(node, lineno, col_offset)
590     return node
591 
592 
593 class AssertionRewriter(ast.NodeVisitor):
594     """Assertion rewriting implementation.
595 
596     The main entrypoint is to call .run() with an ast.Module instance,
597     this will then find all the assert statements and rewrite them to
598     provide intermediate values and a detailed assertion error.  See
599     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
600     for an overview of how this works.
601 
602     The entry point here is .run() which will iterate over all the
603     statements in an ast.Module and for each ast.Assert statement it
604     finds call .visit() with it.  Then .visit_Assert() takes over and
605     is responsible for creating new ast statements to replace the
606     original assert statement: it rewrites the test of an assertion
607     to provide intermediate values and replace it with an if statement
608     which raises an assertion error with a detailed explanation in
609     case the expression is false.
610 
611     For this .visit_Assert() uses the visitor pattern to visit all the
612     AST nodes of the ast.Assert.test field, each visit call returning
613     an AST node and the corresponding explanation string.  During this
614     state is kept in several instance attributes:
615 
616     :statements: All the AST statements which will replace the assert
617        statement.
618 
619     :variables: This is populated by .variable() with each variable
620        used by the statements so that they can all be set to None at
621        the end of the statements.
622 
623     :variable_counter: Counter to create new unique variables needed
624        by statements.  Variables are created using .variable() and
625        have the form of "@py_assert0".
626 
627     :on_failure: The AST statements which will be executed if the
628        assertion test fails.  This is the code which will construct
629        the failure message and raises the AssertionError.
630 
631     :explanation_specifiers: A dict filled by .explanation_param()
632        with %-formatting placeholders and their corresponding
633        expressions to use in the building of an assertion message.
634        This is used by .pop_format_context() to build a message.
635 
636     :stack: A stack of the explanation_specifiers dicts maintained by
637        .push_format_context() and .pop_format_context() which allows
638        to build another %-formatted string while already building one.
639 
640     This state is reset on every new assert statement visited and used
641     by the other visitors.
642 
643     """
644 
645     def __init__(self, module_path, config):
646         super(AssertionRewriter, self).__init__()
647         self.module_path = module_path
648         self.config = config
649 
650     def run(self, mod):
651         """Find all assert statements in *mod* and rewrite them."""
652         if not mod.body:
653             # Nothing to do.
654             return
655         # Insert some special imports at the top of the module but after any
656         # docstrings and __future__ imports.
657         aliases = [
658             ast.alias(six.moves.builtins.__name__, "@py_builtins"),
659             ast.alias("_pytest.assertion.rewrite", "@pytest_ar"),
660         ]
661         doc = getattr(mod, "docstring", None)
662         expect_docstring = doc is None
663         if doc is not None and self.is_rewrite_disabled(doc):
664             return
665         pos = 0
666         lineno = 1
667         for item in mod.body:
668             if (
669                 expect_docstring
670                 and isinstance(item, ast.Expr)
671                 and isinstance(item.value, ast.Str)
672             ):
673                 doc = item.value.s
674                 if self.is_rewrite_disabled(doc):
675                     return
676                 expect_docstring = False
677             elif (
678                 not isinstance(item, ast.ImportFrom)
679                 or item.level > 0
680                 or item.module != "__future__"
681             ):
682                 lineno = item.lineno
683                 break
684             pos += 1
685         else:
686             lineno = item.lineno
687         imports = [
688             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
689         ]
690         mod.body[pos:pos] = imports
691         # Collect asserts.
692         nodes = [mod]
693         while nodes:
694             node = nodes.pop()
695             for name, field in ast.iter_fields(node):
696                 if isinstance(field, list):
697                     new = []
698                     for i, child in enumerate(field):
699                         if isinstance(child, ast.Assert):
700                             # Transform assert.
701                             new.extend(self.visit(child))
702                         else:
703                             new.append(child)
704                             if isinstance(child, ast.AST):
705                                 nodes.append(child)
706                     setattr(node, name, new)
707                 elif (
708                     isinstance(field, ast.AST)
709                     # Don't recurse into expressions as they can't contain
710                     # asserts.
711                     and not isinstance(field, ast.expr)
712                 ):
713                     nodes.append(field)
714 
715     @staticmethod
716     def is_rewrite_disabled(docstring):
717         return "PYTEST_DONT_REWRITE" in docstring
718 
719     def variable(self):
720         """Get a new variable."""
721         # Use a character invalid in python identifiers to avoid clashing.
722         name = "@py_assert" + str(next(self.variable_counter))
723         self.variables.append(name)
724         return name
725 
726     def assign(self, expr):
727         """Give *expr* a name."""
728         name = self.variable()
729         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
730         return ast.Name(name, ast.Load())
731 
732     def display(self, expr):
733         """Call saferepr on the expression."""
734         return self.helper("_saferepr", expr)
735 
736     def helper(self, name, *args):
737         """Call a helper in this module."""
738         py_name = ast.Name("@pytest_ar", ast.Load())
739         attr = ast.Attribute(py_name, name, ast.Load())
740         return ast_Call(attr, list(args), [])
741 
742     def builtin(self, name):
743         """Return the builtin called *name*."""
744         builtin_name = ast.Name("@py_builtins", ast.Load())
745         return ast.Attribute(builtin_name, name, ast.Load())
746 
747     def explanation_param(self, expr):
748         """Return a new named %-formatting placeholder for expr.
749 
750         This creates a %-formatting placeholder for expr in the
751         current formatting context, e.g. ``%(py0)s``.  The placeholder
752         and expr are placed in the current format context so that it
753         can be used on the next call to .pop_format_context().
754 
755         """
756         specifier = "py" + str(next(self.variable_counter))
757         self.explanation_specifiers[specifier] = expr
758         return "%(" + specifier + ")s"
759 
760     def push_format_context(self):
761         """Create a new formatting context.
762 
763         The format context is used for when an explanation wants to
764         have a variable value formatted in the assertion message.  In
765         this case the value required can be added using
766         .explanation_param().  Finally .pop_format_context() is used
767         to format a string of %-formatted values as added by
768         .explanation_param().
769 
770         """
771         self.explanation_specifiers = {}
772         self.stack.append(self.explanation_specifiers)
773 
774     def pop_format_context(self, expl_expr):
775         """Format the %-formatted string with current format context.
776 
777         The expl_expr should be an ast.Str instance constructed from
778         the %-placeholders created by .explanation_param().  This will
779         add the required code to format said string to .on_failure and
780         return the ast.Name instance of the formatted string.
781 
782         """
783         current = self.stack.pop()
784         if self.stack:
785             self.explanation_specifiers = self.stack[-1]
786         keys = [ast.Str(key) for key in current.keys()]
787         format_dict = ast.Dict(keys, list(current.values()))
788         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)
789         name = "@py_format" + str(next(self.variable_counter))
790         self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))
791         return ast.Name(name, ast.Load())
792 
793     def generic_visit(self, node):
794         """Handle expressions we don't have custom code for."""
795         assert isinstance(node, ast.expr)
796         res = self.assign(node)
797         return res, self.explanation_param(self.display(res))
798 
799     def visit_Assert(self, assert_):
800         """Return the AST statements to replace the ast.Assert instance.
801 
802         This rewrites the test of an assertion to provide
803         intermediate values and replace it with an if statement which
804         raises an assertion error with a detailed explanation in case
805         the expression is false.
806 
807         """
808         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
809             from _pytest.warning_types import PytestAssertRewriteWarning
810             import warnings
811 
812             warnings.warn_explicit(
813                 PytestAssertRewriteWarning(
814                     "assertion is always true, perhaps remove parentheses?"
815                 ),
816                 category=None,
817                 filename=str(self.module_path),
818                 lineno=assert_.lineno,
819             )
820 
821         self.statements = []
822         self.variables = []
823         self.variable_counter = itertools.count()
824         self.stack = []
825         self.on_failure = []
826         self.push_format_context()
827         # Rewrite assert into a bunch of statements.
828         top_condition, explanation = self.visit(assert_.test)
829         # If in a test module, check if directly asserting None, in order to warn [Issue #3191]
830         if self.module_path is not None:
831             self.statements.append(
832                 self.warn_about_none_ast(
833                     top_condition, module_path=self.module_path, lineno=assert_.lineno
834                 )
835             )
836         # Create failure message.
837         body = self.on_failure
838         negation = ast.UnaryOp(ast.Not(), top_condition)
839         self.statements.append(ast.If(negation, body, []))
840         if assert_.msg:
841             assertmsg = self.helper("_format_assertmsg", assert_.msg)
842             explanation = "\n>assert " + explanation
843         else:
844             assertmsg = ast.Str("")
845             explanation = "assert " + explanation
846         template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))
847         msg = self.pop_format_context(template)
848         fmt = self.helper("_format_explanation", msg)
849         err_name = ast.Name("AssertionError", ast.Load())
850         exc = ast_Call(err_name, [fmt], [])
851         if sys.version_info[0] >= 3:
852             raise_ = ast.Raise(exc, None)
853         else:
854             raise_ = ast.Raise(exc, None, None)
855         body.append(raise_)
856         # Clear temporary variables by setting them to None.
857         if self.variables:
858             variables = [ast.Name(name, ast.Store()) for name in self.variables]
859             clear = ast.Assign(variables, _NameConstant(None))
860             self.statements.append(clear)
861         # Fix line numbers.
862         for stmt in self.statements:
863             set_location(stmt, assert_.lineno, assert_.col_offset)
864         return self.statements
865 
866     def warn_about_none_ast(self, node, module_path, lineno):
867         """
868         Returns an AST issuing a warning if the value of node is `None`.
869         This is used to warn the user when asserting a function that asserts
870         internally already.
871         See issue #3191 for more details.
872         """
873 
874         # Using parse because it is different between py2 and py3.
875         AST_NONE = ast.parse("None").body[0].value
876         val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])
877         send_warning = ast.parse(
878             """
879 from _pytest.warning_types import PytestAssertRewriteWarning
880 from warnings import warn_explicit
881 warn_explicit(
882     PytestAssertRewriteWarning('asserting the value None, please use "assert is None"'),
883     category=None,
884     filename={filename!r},
885     lineno={lineno},
886 )
887             """.format(
888                 filename=module_path.strpath, lineno=lineno
889             )
890         ).body
891         return ast.If(val_is_none, send_warning, [])
892 
893     def visit_Name(self, name):
894         # Display the repr of the name if it's a local variable or
895         # _should_repr_global_name() thinks it's acceptable.
896         locs = ast_Call(self.builtin("locals"), [], [])
897         inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])
898         dorepr = self.helper("_should_repr_global_name", name)
899         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
900         expr = ast.IfExp(test, self.display(name), ast.Str(name.id))
901         return name, self.explanation_param(expr)
902 
903     def visit_BoolOp(self, boolop):
904         res_var = self.variable()
905         expl_list = self.assign(ast.List([], ast.Load()))
906         app = ast.Attribute(expl_list, "append", ast.Load())
907         is_or = int(isinstance(boolop.op, ast.Or))
908         body = save = self.statements
909         fail_save = self.on_failure
910         levels = len(boolop.values) - 1
911         self.push_format_context()
912         # Process each operand, short-circuting if needed.
913         for i, v in enumerate(boolop.values):
914             if i:
915                 fail_inner = []
916                 # cond is set in a prior loop iteration below
917                 self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa
918                 self.on_failure = fail_inner
919             self.push_format_context()
920             res, expl = self.visit(v)
921             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
922             expl_format = self.pop_format_context(ast.Str(expl))
923             call = ast_Call(app, [expl_format], [])
924             self.on_failure.append(ast.Expr(call))
925             if i < levels:
926                 cond = res
927                 if is_or:
928                     cond = ast.UnaryOp(ast.Not(), cond)
929                 inner = []
930                 self.statements.append(ast.If(cond, inner, []))
931                 self.statements = body = inner
932         self.statements = save
933         self.on_failure = fail_save
934         expl_template = self.helper("_format_boolop", expl_list, ast.Num(is_or))
935         expl = self.pop_format_context(expl_template)
936         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)
937 
938     def visit_UnaryOp(self, unary):
939         pattern = unary_map[unary.op.__class__]
940         operand_res, operand_expl = self.visit(unary.operand)
941         res = self.assign(ast.UnaryOp(unary.op, operand_res))
942         return res, pattern % (operand_expl,)
943 
944     def visit_BinOp(self, binop):
945         symbol = binop_map[binop.op.__class__]
946         left_expr, left_expl = self.visit(binop.left)
947         right_expr, right_expl = self.visit(binop.right)
948         explanation = "(%s %s %s)" % (left_expl, symbol, right_expl)
949         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
950         return res, explanation
951 
952     def visit_Call_35(self, call):
953         """
954         visit `ast.Call` nodes on Python3.5 and after
955         """
956         new_func, func_expl = self.visit(call.func)
957         arg_expls = []
958         new_args = []
959         new_kwargs = []
960         for arg in call.args:
961             res, expl = self.visit(arg)
962             arg_expls.append(expl)
963             new_args.append(res)
964         for keyword in call.keywords:
965             res, expl = self.visit(keyword.value)
966             new_kwargs.append(ast.keyword(keyword.arg, res))
967             if keyword.arg:
968                 arg_expls.append(keyword.arg + "=" + expl)
969             else:  # **args have `arg` keywords with an .arg of None
970                 arg_expls.append("**" + expl)
971 
972         expl = "%s(%s)" % (func_expl, ", ".join(arg_expls))
973         new_call = ast.Call(new_func, new_args, new_kwargs)
974         res = self.assign(new_call)
975         res_expl = self.explanation_param(self.display(res))
976         outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
977         return res, outer_expl
978 
979     def visit_Starred(self, starred):
980         # From Python 3.5, a Starred node can appear in a function call
981         res, expl = self.visit(starred.value)
982         new_starred = ast.Starred(res, starred.ctx)
983         return new_starred, "*" + expl
984 
985     def visit_Call_legacy(self, call):
986         """
987         visit `ast.Call nodes on 3.4 and below`
988         """
989         new_func, func_expl = self.visit(call.func)
990         arg_expls = []
991         new_args = []
992         new_kwargs = []
993         new_star = new_kwarg = None
994         for arg in call.args:
995             res, expl = self.visit(arg)
996             new_args.append(res)
997             arg_expls.append(expl)
998         for keyword in call.keywords:
999             res, expl = self.visit(keyword.value)
1000             new_kwargs.append(ast.keyword(keyword.arg, res))
1001             arg_expls.append(keyword.arg + "=" + expl)
1002         if call.starargs:
1003             new_star, expl = self.visit(call.starargs)
1004             arg_expls.append("*" + expl)
1005         if call.kwargs:
1006             new_kwarg, expl = self.visit(call.kwargs)
1007             arg_expls.append("**" + expl)
1008         expl = "%s(%s)" % (func_expl, ", ".join(arg_expls))
1009         new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)
1010         res = self.assign(new_call)
1011         res_expl = self.explanation_param(self.display(res))
1012         outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
1013         return res, outer_expl
1014 
1015     # ast.Call signature changed on 3.5,
1016     # conditionally change  which methods is named
1017     # visit_Call depending on Python version
1018     if sys.version_info >= (3, 5):
1019         visit_Call = visit_Call_35
1020     else:
1021         visit_Call = visit_Call_legacy
1022 
1023     def visit_Attribute(self, attr):
1024         if not isinstance(attr.ctx, ast.Load):
1025             return self.generic_visit(attr)
1026         value, value_expl = self.visit(attr.value)
1027         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
1028         res_expl = self.explanation_param(self.display(res))
1029         pat = "%s\n{%s = %s.%s\n}"
1030         expl = pat % (res_expl, res_expl, value_expl, attr.attr)
1031         return res, expl
1032 
1033     def visit_Compare(self, comp):
1034         self.push_format_context()
1035         left_res, left_expl = self.visit(comp.left)
1036         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):
1037             left_expl = "({})".format(left_expl)
1038         res_variables = [self.variable() for i in range(len(comp.ops))]
1039         load_names = [ast.Name(v, ast.Load()) for v in res_variables]
1040         store_names = [ast.Name(v, ast.Store()) for v in res_variables]
1041         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)
1042         expls = []
1043         syms = []
1044         results = [left_res]
1045         for i, op, next_operand in it:
1046             next_res, next_expl = self.visit(next_operand)
1047             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):
1048                 next_expl = "({})".format(next_expl)
1049             results.append(next_res)
1050             sym = binop_map[op.__class__]
1051             syms.append(ast.Str(sym))
1052             expl = "%s %s %s" % (left_expl, sym, next_expl)
1053             expls.append(ast.Str(expl))
1054             res_expr = ast.Compare(left_res, [op], [next_res])
1055             self.statements.append(ast.Assign([store_names[i]], res_expr))
1056             left_res, left_expl = next_res, next_expl
1057         # Use pytest.assertion.util._reprcompare if that's available.
1058         expl_call = self.helper(
1059             "_call_reprcompare",
1060             ast.Tuple(syms, ast.Load()),
1061             ast.Tuple(load_names, ast.Load()),
1062             ast.Tuple(expls, ast.Load()),
1063             ast.Tuple(results, ast.Load()),
1064         )
1065         if len(comp.ops) > 1:
1066             res = ast.BoolOp(ast.And(), load_names)
1067         else:
1068             res = load_names[0]
1069         return res, self.explanation_param(self.pop_format_context(expl_call))

</code><intended_behavior>Ensure that methods dealing with assertion errors properly handle Unicode characters, possibly by making sure encoding conversions are handled correctly under Python 2. This may involve explicitly encoding Unicode strings to UTF-8 (or another appropriate encoding) before they are processed or outputted.</intended_behavior>, <file>src/_pytest/compat.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 """
3 python version compatibility code
4 """
5 from __future__ import absolute_import
6 from __future__ import division
7 from __future__ import print_function
8 
9 import codecs
10 import functools
11 import inspect
12 import re
13 import sys
14 from contextlib import contextmanager
15 
16 import py
17 import six
18 from six import text_type
19 
20 import _pytest
21 from _pytest._io.saferepr import saferepr
22 from _pytest.outcomes import fail
23 from _pytest.outcomes import TEST_OUTCOME
24 
25 try:
26     import enum
27 except ImportError:  # pragma: no cover
28     # Only available in Python 3.4+ or as a backport
29     enum = None
30 
31 _PY3 = sys.version_info > (3, 0)
32 _PY2 = not _PY3
33 
34 
35 if _PY3:
36     from inspect import signature, Parameter as Parameter
37 else:
38     from funcsigs import signature, Parameter as Parameter
39 
40 NOTSET = object()
41 
42 PY35 = sys.version_info[:2] >= (3, 5)
43 PY36 = sys.version_info[:2] >= (3, 6)
44 MODULE_NOT_FOUND_ERROR = "ModuleNotFoundError" if PY36 else "ImportError"
45 
46 
47 if _PY3:
48     from collections.abc import MutableMapping as MappingMixin
49     from collections.abc import Iterable, Mapping, Sequence, Sized
50 else:
51     # those raise DeprecationWarnings in Python >=3.7
52     from collections import MutableMapping as MappingMixin  # noqa
53     from collections import Iterable, Mapping, Sequence, Sized  # noqa
54 
55 
56 if sys.version_info >= (3, 4):
57     from importlib.util import spec_from_file_location
58 else:
59 
60     def spec_from_file_location(*_, **__):
61         return None
62 
63 
64 def _format_args(func):
65     return str(signature(func))
66 
67 
68 isfunction = inspect.isfunction
69 isclass = inspect.isclass
70 # used to work around a python2 exception info leak
71 exc_clear = getattr(sys, "exc_clear", lambda: None)
72 # The type of re.compile objects is not exposed in Python.
73 REGEX_TYPE = type(re.compile(""))
74 
75 
76 def is_generator(func):
77     genfunc = inspect.isgeneratorfunction(func)
78     return genfunc and not iscoroutinefunction(func)
79 
80 
81 def iscoroutinefunction(func):
82     """Return True if func is a decorated coroutine function.
83 
84     Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,
85     which in turns also initializes the "logging" module as side-effect (see issue #8).
86     """
87     return getattr(func, "_is_coroutine", False) or (
88         hasattr(inspect, "iscoroutinefunction") and inspect.iscoroutinefunction(func)
89     )
90 
91 
92 def getlocation(function, curdir):
93     function = get_real_func(function)
94     fn = py.path.local(inspect.getfile(function))
95     lineno = function.__code__.co_firstlineno
96     if fn.relto(curdir):
97         fn = fn.relto(curdir)
98     return "%s:%d" % (fn, lineno + 1)
99 
100 
101 def num_mock_patch_args(function):
102     """ return number of arguments used up by mock arguments (if any) """
103     patchings = getattr(function, "patchings", None)
104     if not patchings:
105         return 0
106     mock_modules = [sys.modules.get("mock"), sys.modules.get("unittest.mock")]
107     if any(mock_modules):
108         sentinels = [m.DEFAULT for m in mock_modules if m is not None]
109         return len(
110             [p for p in patchings if not p.attribute_name and p.new in sentinels]
111         )
112     return len(patchings)
113 
114 
115 def getfuncargnames(function, is_method=False, cls=None):
116     """Returns the names of a function's mandatory arguments.
117 
118     This should return the names of all function arguments that:
119         * Aren't bound to an instance or type as in instance or class methods.
120         * Don't have default values.
121         * Aren't bound with functools.partial.
122         * Aren't replaced with mocks.
123 
124     The is_method and cls arguments indicate that the function should
125     be treated as a bound method even though it's not unless, only in
126     the case of cls, the function is a static method.
127 
128     @RonnyPfannschmidt: This function should be refactored when we
129     revisit fixtures. The fixture mechanism should ask the node for
130     the fixture names, and not try to obtain directly from the
131     function object well after collection has occurred.
132 
133     """
134     # The parameters attribute of a Signature object contains an
135     # ordered mapping of parameter names to Parameter instances.  This
136     # creates a tuple of the names of the parameters that don't have
137     # defaults.
138     try:
139         parameters = signature(function).parameters
140     except (ValueError, TypeError) as e:
141         fail(
142             "Could not determine arguments of {!r}: {}".format(function, e),
143             pytrace=False,
144         )
145 
146     arg_names = tuple(
147         p.name
148         for p in parameters.values()
149         if (
150             p.kind is Parameter.POSITIONAL_OR_KEYWORD
151             or p.kind is Parameter.KEYWORD_ONLY
152         )
153         and p.default is Parameter.empty
154     )
155     # If this function should be treated as a bound method even though
156     # it's passed as an unbound method or function, remove the first
157     # parameter name.
158     if is_method or (
159         cls and not isinstance(cls.__dict__.get(function.__name__, None), staticmethod)
160     ):
161         arg_names = arg_names[1:]
162     # Remove any names that will be replaced with mocks.
163     if hasattr(function, "__wrapped__"):
164         arg_names = arg_names[num_mock_patch_args(function) :]
165     return arg_names
166 
167 
168 @contextmanager
169 def dummy_context_manager():
170     """Context manager that does nothing, useful in situations where you might need an actual context manager or not
171     depending on some condition. Using this allow to keep the same code"""
172     yield
173 
174 
175 def get_default_arg_names(function):
176     # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,
177     # to get the arguments which were excluded from its result because they had default values
178     return tuple(
179         p.name
180         for p in signature(function).parameters.values()
181         if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)
182         and p.default is not Parameter.empty
183     )
184 
185 
186 _non_printable_ascii_translate_table = {
187     i: u"\\x{:02x}".format(i) for i in range(128) if i not in range(32, 127)
188 }
189 _non_printable_ascii_translate_table.update(
190     {ord("\t"): u"\\t", ord("\r"): u"\\r", ord("\n"): u"\\n"}
191 )
192 
193 
194 def _translate_non_printable(s):
195     return s.translate(_non_printable_ascii_translate_table)
196 
197 
198 if _PY3:
199     STRING_TYPES = bytes, str
200     UNICODE_TYPES = six.text_type
201 
202     if PY35:
203 
204         def _bytes_to_ascii(val):
205             return val.decode("ascii", "backslashreplace")
206 
207     else:
208 
209         def _bytes_to_ascii(val):
210             if val:
211                 # source: http://goo.gl/bGsnwC
212                 encoded_bytes, _ = codecs.escape_encode(val)
213                 return encoded_bytes.decode("ascii")
214             else:
215                 # empty bytes crashes codecs.escape_encode (#1087)
216                 return ""
217 
218     def ascii_escaped(val):
219         """If val is pure ascii, returns it as a str().  Otherwise, escapes
220         bytes objects into a sequence of escaped bytes:
221 
222         b'\xc3\xb4\xc5\xd6' -> u'\\xc3\\xb4\\xc5\\xd6'
223 
224         and escapes unicode objects into a sequence of escaped unicode
225         ids, e.g.:
226 
227         '4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'
228 
229         note:
230            the obvious "v.decode('unicode-escape')" will return
231            valid utf-8 unicode if it finds them in bytes, but we
232            want to return escaped bytes for any byte, even if they match
233            a utf-8 string.
234 
235         """
236         if isinstance(val, bytes):
237             ret = _bytes_to_ascii(val)
238         else:
239             ret = val.encode("unicode_escape").decode("ascii")
240         return _translate_non_printable(ret)
241 
242 
243 else:
244     STRING_TYPES = six.string_types
245     UNICODE_TYPES = six.text_type
246 
247     def ascii_escaped(val):
248         """In py2 bytes and str are the same type, so return if it's a bytes
249         object, return it unchanged if it is a full ascii string,
250         otherwise escape it into its binary form.
251 
252         If it's a unicode string, change the unicode characters into
253         unicode escapes.
254 
255         """
256         if isinstance(val, bytes):
257             try:
258                 ret = val.decode("ascii")
259             except UnicodeDecodeError:
260                 ret = val.encode("string-escape").decode("ascii")
261         else:
262             ret = val.encode("unicode-escape").decode("ascii")
263         return _translate_non_printable(ret)
264 
265 
266 class _PytestWrapper(object):
267     """Dummy wrapper around a function object for internal use only.
268 
269     Used to correctly unwrap the underlying function object
270     when we are creating fixtures, because we wrap the function object ourselves with a decorator
271     to issue warnings when the fixture function is called directly.
272     """
273 
274     def __init__(self, obj):
275         self.obj = obj
276 
277 
278 def get_real_func(obj):
279     """ gets the real function object of the (possibly) wrapped object by
280     functools.wraps or functools.partial.
281     """
282     start_obj = obj
283     for i in range(100):
284         # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function
285         # to trigger a warning if it gets called directly instead of by pytest: we don't
286         # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)
287         new_obj = getattr(obj, "__pytest_wrapped__", None)
288         if isinstance(new_obj, _PytestWrapper):
289             obj = new_obj.obj
290             break
291         new_obj = getattr(obj, "__wrapped__", None)
292         if new_obj is None:
293             break
294         obj = new_obj
295     else:
296         raise ValueError(
297             ("could not find real function of {start}\nstopped at {current}").format(
298                 start=saferepr(start_obj), current=saferepr(obj)
299             )
300         )
301     if isinstance(obj, functools.partial):
302         obj = obj.func
303     return obj
304 
305 
306 def get_real_method(obj, holder):
307     """
308     Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time
309     returning a bound method to ``holder`` if the original object was a bound method.
310     """
311     try:
312         is_method = hasattr(obj, "__func__")
313         obj = get_real_func(obj)
314     except Exception:
315         return obj
316     if is_method and hasattr(obj, "__get__") and callable(obj.__get__):
317         obj = obj.__get__(holder)
318     return obj
319 
320 
321 def getfslineno(obj):
322     # xxx let decorators etc specify a sane ordering
323     obj = get_real_func(obj)
324     if hasattr(obj, "place_as"):
325         obj = obj.place_as
326     fslineno = _pytest._code.getfslineno(obj)
327     assert isinstance(fslineno[1], int), obj
328     return fslineno
329 
330 
331 def getimfunc(func):
332     try:
333         return func.__func__
334     except AttributeError:
335         return func
336 
337 
338 def safe_getattr(object, name, default):
339     """ Like getattr but return default upon any Exception or any OutcomeException.
340 
341     Attribute access can potentially fail for 'evil' Python objects.
342     See issue #214.
343     It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException
344     instead of Exception (for more details check #2707)
345     """
346     try:
347         return getattr(object, name, default)
348     except TEST_OUTCOME:
349         return default
350 
351 
352 def safe_isclass(obj):
353     """Ignore any exception via isinstance on Python 3."""
354     try:
355         return isclass(obj)
356     except Exception:
357         return False
358 
359 
360 def _is_unittest_unexpected_success_a_failure():
361     """Return if the test suite should fail if an @expectedFailure unittest test PASSES.
362 
363     From https://docs.python.org/3/library/unittest.html?highlight=unittest#unittest.TestResult.wasSuccessful:
364         Changed in version 3.4: Returns False if there were any
365         unexpectedSuccesses from tests marked with the expectedFailure() decorator.
366     """
367     return sys.version_info >= (3, 4)
368 
369 
370 if _PY3:
371 
372     def safe_str(v):
373         """returns v as string"""
374         return str(v)
375 
376 
377 else:
378 
379     def safe_str(v):
380         """returns v as string, converting to utf-8 if necessary"""
381         try:
382             return str(v)
383         except UnicodeError:
384             if not isinstance(v, text_type):
385                 v = text_type(v)
386             errors = "replace"
387             return v.encode("utf-8", errors)
388 
389 
390 COLLECT_FAKEMODULE_ATTRIBUTES = (
391     "Collector",
392     "Module",
393     "Function",
394     "Instance",
395     "Session",
396     "Item",
397     "Class",
398     "File",
399     "_fillfuncargs",
400 )
401 
402 
403 def _setup_collect_fakemodule():
404     from types import ModuleType
405     import pytest
406 
407     pytest.collect = ModuleType("pytest.collect")
408     pytest.collect.__all__ = []  # used for setns
409     for attr in COLLECT_FAKEMODULE_ATTRIBUTES:
410         setattr(pytest.collect, attr, getattr(pytest, attr))
411 
412 
413 if _PY2:
414     # Without this the test_dupfile_on_textio will fail, otherwise CaptureIO could directly inherit from StringIO.
415     from py.io import TextIO
416 
417     class CaptureIO(TextIO):
418         @property
419         def encoding(self):
420             return getattr(self, "_encoding", "UTF-8")
421 
422 
423 else:
424     import io
425 
426     class CaptureIO(io.TextIOWrapper):
427         def __init__(self):
428             super(CaptureIO, self).__init__(
429                 io.BytesIO(), encoding="UTF-8", newline="", write_through=True
430             )
431 
432         def getvalue(self):
433             return self.buffer.getvalue().decode("UTF-8")
434 
435 
436 class FuncargnamesCompatAttr(object):
437     """ helper class so that Metafunc, Function and FixtureRequest
438     don't need to each define the "funcargnames" compatibility attribute.
439     """
440 
441     @property
442     def funcargnames(self):
443         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
444         return self.fixturenames
445 
446 
447 if six.PY2:
448 
449     def lru_cache(*_, **__):
450         def dec(fn):
451             return fn
452 
453         return dec
454 
455 
456 else:
457     from functools import lru_cache  # noqa: F401

</code><intended_behavior>Verify and, if necessary, adjust the encoding and decoding utilities to ensure they gracefully handle Unicode strings, especially in the context of assertions and exceptions. For example, utility functions could be designed to encode Unicode strings to a specific encoding only when running under Python 2, using `sys.version_info` checks.</intended_behavior>, <file>testing/python/raises.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 import sys
3 
4 import six
5 
6 import pytest
7 from _pytest.outcomes import Failed
8 from _pytest.warning_types import PytestDeprecationWarning
9 
10 
11 class TestRaises(object):
12     def test_raises(self):
13         source = "int('qwe')"
14         with pytest.warns(PytestDeprecationWarning):
15             excinfo = pytest.raises(ValueError, source)
16         code = excinfo.traceback[-1].frame.code
17         s = str(code.fullsource)
18         assert s == source
19 
20     def test_raises_exec(self):
21         with pytest.warns(PytestDeprecationWarning) as warninfo:
22             pytest.raises(ValueError, "a,x = []")
23         assert warninfo[0].filename == __file__
24 
25     def test_raises_exec_correct_filename(self):
26         with pytest.warns(PytestDeprecationWarning):
27             excinfo = pytest.raises(ValueError, 'int("s")')
28             assert __file__ in excinfo.traceback[-1].path
29 
30     def test_raises_syntax_error(self):
31         with pytest.warns(PytestDeprecationWarning) as warninfo:
32             pytest.raises(SyntaxError, "qwe qwe qwe")
33         assert warninfo[0].filename == __file__
34 
35     def test_raises_function(self):
36         pytest.raises(ValueError, int, "hello")
37 
38     def test_raises_callable_no_exception(self):
39         class A(object):
40             def __call__(self):
41                 pass
42 
43         try:
44             pytest.raises(ValueError, A())
45         except pytest.raises.Exception:
46             pass
47 
48     def test_raises_falsey_type_error(self):
49         with pytest.raises(TypeError):
50             with pytest.raises(AssertionError, match=0):
51                 raise AssertionError("ohai")
52 
53     def test_raises_repr_inflight(self):
54         """Ensure repr() on an exception info inside a pytest.raises with block works (#4386)"""
55 
56         class E(Exception):
57             pass
58 
59         with pytest.raises(E) as excinfo:
60             # this test prints the inflight uninitialized object
61             # using repr and str as well as pprint to demonstrate
62             # it works
63             print(str(excinfo))
64             print(repr(excinfo))
65             import pprint
66 
67             pprint.pprint(excinfo)
68             raise E()
69 
70     def test_raises_as_contextmanager(self, testdir):
71         testdir.makepyfile(
72             """
73             import pytest
74             import _pytest._code
75 
76             def test_simple():
77                 with pytest.raises(ZeroDivisionError) as excinfo:
78                     assert isinstance(excinfo, _pytest._code.ExceptionInfo)
79                     1/0
80                 print(excinfo)
81                 assert excinfo.type == ZeroDivisionError
82                 assert isinstance(excinfo.value, ZeroDivisionError)
83 
84             def test_noraise():
85                 with pytest.raises(pytest.raises.Exception):
86                     with pytest.raises(ValueError):
87                            int()
88 
89             def test_raise_wrong_exception_passes_by():
90                 with pytest.raises(ZeroDivisionError):
91                     with pytest.raises(ValueError):
92                            1/0
93         """
94         )
95         result = testdir.runpytest()
96         result.stdout.fnmatch_lines(["*3 passed*"])
97 
98     def test_does_not_raise(self, testdir):
99         testdir.makepyfile(
100             """
101             from contextlib import contextmanager
102             import pytest
103 
104             @contextmanager
105             def does_not_raise():
106                 yield
107 
108             @pytest.mark.parametrize('example_input,expectation', [
109                 (3, does_not_raise()),
110                 (2, does_not_raise()),
111                 (1, does_not_raise()),
112                 (0, pytest.raises(ZeroDivisionError)),
113             ])
114             def test_division(example_input, expectation):
115                 '''Test how much I know division.'''
116                 with expectation:
117                     assert (6 / example_input) is not None
118         """
119         )
120         result = testdir.runpytest()
121         result.stdout.fnmatch_lines(["*4 passed*"])
122 
123     def test_does_not_raise_does_raise(self, testdir):
124         testdir.makepyfile(
125             """
126             from contextlib import contextmanager
127             import pytest
128 
129             @contextmanager
130             def does_not_raise():
131                 yield
132 
133             @pytest.mark.parametrize('example_input,expectation', [
134                 (0, does_not_raise()),
135                 (1, pytest.raises(ZeroDivisionError)),
136             ])
137             def test_division(example_input, expectation):
138                 '''Test how much I know division.'''
139                 with expectation:
140                     assert (6 / example_input) is not None
141         """
142         )
143         result = testdir.runpytest()
144         result.stdout.fnmatch_lines(["*2 failed*"])
145 
146     def test_noclass(self):
147         with pytest.raises(TypeError):
148             pytest.raises("wrong", lambda: None)
149 
150     def test_invalid_arguments_to_raises(self):
151         with pytest.raises(TypeError, match="unknown"):
152             with pytest.raises(TypeError, unknown="bogus"):
153                 raise ValueError()
154 
155     def test_tuple(self):
156         with pytest.raises((KeyError, ValueError)):
157             raise KeyError("oops")
158 
159     def test_no_raise_message(self):
160         try:
161             pytest.raises(ValueError, int, "0")
162         except pytest.raises.Exception as e:
163             assert e.msg == "DID NOT RAISE {}".format(repr(ValueError))
164         else:
165             assert False, "Expected pytest.raises.Exception"
166 
167         try:
168             with pytest.raises(ValueError):
169                 pass
170         except pytest.raises.Exception as e:
171             assert e.msg == "DID NOT RAISE {}".format(repr(ValueError))
172         else:
173             assert False, "Expected pytest.raises.Exception"
174 
175     def test_custom_raise_message(self):
176         message = "TEST_MESSAGE"
177         try:
178             with pytest.warns(PytestDeprecationWarning):
179                 with pytest.raises(ValueError, message=message):
180                     pass
181         except pytest.raises.Exception as e:
182             assert e.msg == message
183         else:
184             assert False, "Expected pytest.raises.Exception"
185 
186     @pytest.mark.parametrize("method", ["function", "with"])
187     def test_raises_cyclic_reference(self, method):
188         """
189         Ensure pytest.raises does not leave a reference cycle (#1965).
190         """
191         import gc
192 
193         class T(object):
194             def __call__(self):
195                 raise ValueError
196 
197         t = T()
198         if method == "function":
199             pytest.raises(ValueError, t)
200         else:
201             with pytest.raises(ValueError):
202                 t()
203 
204         # ensure both forms of pytest.raises don't leave exceptions in sys.exc_info()
205         assert sys.exc_info() == (None, None, None)
206 
207         del t
208 
209         # ensure the t instance is not stuck in a cyclic reference
210         for o in gc.get_objects():
211             assert type(o) is not T
212 
213     def test_raises_match(self):
214         msg = r"with base \d+"
215         with pytest.raises(ValueError, match=msg):
216             int("asdf")
217 
218         msg = "with base 10"
219         with pytest.raises(ValueError, match=msg):
220             int("asdf")
221 
222         msg = "with base 16"
223         expr = r"Pattern '{}' not found in 'invalid literal for int\(\) with base 10: 'asdf''".format(
224             msg
225         )
226         with pytest.raises(AssertionError, match=expr):
227             with pytest.raises(ValueError, match=msg):
228                 int("asdf", base=10)
229 
230     def test_raises_match_wrong_type(self):
231         """Raising an exception with the wrong type and match= given.
232 
233         pytest should throw the unexpected exception - the pattern match is not
234         really relevant if we got a different exception.
235         """
236         with pytest.raises(ValueError):
237             with pytest.raises(IndexError, match="nomatch"):
238                 int("asdf")
239 
240     def test_raises_exception_looks_iterable(self):
241         from six import add_metaclass
242 
243         class Meta(type(object)):
244             def __getitem__(self, item):
245                 return 1 / 0
246 
247             def __len__(self):
248                 return 1
249 
250         @add_metaclass(Meta)
251         class ClassLooksIterableException(Exception):
252             pass
253 
254         with pytest.raises(
255             Failed,
256             match=r"DID NOT RAISE <class 'raises(\..*)*ClassLooksIterableException'>",
257         ):
258             pytest.raises(ClassLooksIterableException, lambda: None)
259 
260     def test_raises_with_raising_dunder_class(self):
261         """Test current behavior with regard to exceptions via __class__ (#4284)."""
262 
263         class CrappyClass(Exception):
264             @property
265             def __class__(self):
266                 assert False, "via __class__"
267 
268         if six.PY2:
269             with pytest.raises(pytest.fail.Exception) as excinfo:
270                 with pytest.raises(CrappyClass()):
271                     pass
272             assert "DID NOT RAISE" in excinfo.value.args[0]
273 
274             with pytest.raises(CrappyClass) as excinfo:
275                 raise CrappyClass()
276         else:
277             with pytest.raises(AssertionError) as excinfo:
278                 with pytest.raises(CrappyClass()):
279                     pass
280             assert "via __class__" in excinfo.value.args[0]

</code><intended_behavior>Ensure any test cases that use `pytest.raises` with Unicode strings are correctly designed to handle or expect Unicode characters without causing encoding errors. If this file contains custom utility functions or helpers around `pytest.raises`, verify these helpers manage Unicode strings properly under Python 2.</intended_behavior>]
2025-10-18 04:50:12.239 | INFO     | Search completed. Bug locations: [<file>src/_pytest/assertion/rewrite.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 """Rewrite assertion AST to produce nice error messages"""
3 from __future__ import absolute_import
4 from __future__ import division
5 from __future__ import print_function
6 
7 import ast
8 import errno
9 import imp
10 import itertools
11 import marshal
12 import os
13 import re
14 import string
15 import struct
16 import sys
17 import types
18 
19 import atomicwrites
20 import py
21 import six
22 
23 from _pytest._io.saferepr import saferepr
24 from _pytest.assertion import util
25 from _pytest.assertion.util import (  # noqa: F401
26     format_explanation as _format_explanation,
27 )
28 from _pytest.compat import spec_from_file_location
29 from _pytest.pathlib import fnmatch_ex
30 from _pytest.pathlib import PurePath
31 
32 # pytest caches rewritten pycs in __pycache__.
33 if hasattr(imp, "get_tag"):
34     PYTEST_TAG = imp.get_tag() + "-PYTEST"
35 else:
36     if hasattr(sys, "pypy_version_info"):
37         impl = "pypy"
38     elif sys.platform == "java":
39         impl = "jython"
40     else:
41         impl = "cpython"
42     ver = sys.version_info
43     PYTEST_TAG = "%s-%s%s-PYTEST" % (impl, ver[0], ver[1])
44     del ver, impl
45 
46 PYC_EXT = ".py" + (__debug__ and "c" or "o")
47 PYC_TAIL = "." + PYTEST_TAG + PYC_EXT
48 
49 ASCII_IS_DEFAULT_ENCODING = sys.version_info[0] < 3
50 
51 if sys.version_info >= (3, 5):
52     ast_Call = ast.Call
53 else:
54 
55     def ast_Call(a, b, c):
56         return ast.Call(a, b, c, None, None)
57 
58 
59 class AssertionRewritingHook(object):
60     """PEP302 Import hook which rewrites asserts."""
61 
62     def __init__(self, config):
63         self.config = config
64         try:
65             self.fnpats = config.getini("python_files")
66         except ValueError:
67             self.fnpats = ["test_*.py", "*_test.py"]
68         self.session = None
69         self.modules = {}
70         self._rewritten_names = set()
71         self._must_rewrite = set()
72         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
73         # which might result in infinite recursion (#3506)
74         self._writing_pyc = False
75         self._basenames_to_check_rewrite = {"conftest"}
76         self._marked_for_rewrite_cache = {}
77         self._session_paths_checked = False
78 
79     def set_session(self, session):
80         self.session = session
81         self._session_paths_checked = False
82 
83     def _imp_find_module(self, name, path=None):
84         """Indirection so we can mock calls to find_module originated from the hook during testing"""
85         return imp.find_module(name, path)
86 
87     def find_module(self, name, path=None):
88         if self._writing_pyc:
89             return None
90         state = self.config._assertstate
91         if self._early_rewrite_bailout(name, state):
92             return None
93         state.trace("find_module called for: %s" % name)
94         names = name.rsplit(".", 1)
95         lastname = names[-1]
96         pth = None
97         if path is not None:
98             # Starting with Python 3.3, path is a _NamespacePath(), which
99             # causes problems if not converted to list.
100             path = list(path)
101             if len(path) == 1:
102                 pth = path[0]
103         if pth is None:
104             try:
105                 fd, fn, desc = self._imp_find_module(lastname, path)
106             except ImportError:
107                 return None
108             if fd is not None:
109                 fd.close()
110             tp = desc[2]
111             if tp == imp.PY_COMPILED:
112                 if hasattr(imp, "source_from_cache"):
113                     try:
114                         fn = imp.source_from_cache(fn)
115                     except ValueError:
116                         # Python 3 doesn't like orphaned but still-importable
117                         # .pyc files.
118                         fn = fn[:-1]
119                 else:
120                     fn = fn[:-1]
121             elif tp != imp.PY_SOURCE:
122                 # Don't know what this is.
123                 return None
124         else:
125             fn = os.path.join(pth, name.rpartition(".")[2] + ".py")
126 
127         fn_pypath = py.path.local(fn)
128         if not self._should_rewrite(name, fn_pypath, state):
129             return None
130 
131         self._rewritten_names.add(name)
132 
133         # The requested module looks like a test file, so rewrite it. This is
134         # the most magical part of the process: load the source, rewrite the
135         # asserts, and load the rewritten source. We also cache the rewritten
136         # module code in a special pyc. We must be aware of the possibility of
137         # concurrent pytest processes rewriting and loading pycs. To avoid
138         # tricky race conditions, we maintain the following invariant: The
139         # cached pyc is always a complete, valid pyc. Operations on it must be
140         # atomic. POSIX's atomic rename comes in handy.
141         write = not sys.dont_write_bytecode
142         cache_dir = os.path.join(fn_pypath.dirname, "__pycache__")
143         if write:
144             try:
145                 os.mkdir(cache_dir)
146             except OSError:
147                 e = sys.exc_info()[1].errno
148                 if e == errno.EEXIST:
149                     # Either the __pycache__ directory already exists (the
150                     # common case) or it's blocked by a non-dir node. In the
151                     # latter case, we'll ignore it in _write_pyc.
152                     pass
153                 elif e in [errno.ENOENT, errno.ENOTDIR]:
154                     # One of the path components was not a directory, likely
155                     # because we're in a zip file.
156                     write = False
157                 elif e in [errno.EACCES, errno.EROFS, errno.EPERM]:
158                     state.trace("read only directory: %r" % fn_pypath.dirname)
159                     write = False
160                 else:
161                     raise
162         cache_name = fn_pypath.basename[:-3] + PYC_TAIL
163         pyc = os.path.join(cache_dir, cache_name)
164         # Notice that even if we're in a read-only directory, I'm going
165         # to check for a cached pyc. This may not be optimal...
166         co = _read_pyc(fn_pypath, pyc, state.trace)
167         if co is None:
168             state.trace("rewriting %r" % (fn,))
169             source_stat, co = _rewrite_test(self.config, fn_pypath)
170             if co is None:
171                 # Probably a SyntaxError in the test.
172                 return None
173             if write:
174                 self._writing_pyc = True
175                 try:
176                     _write_pyc(state, co, source_stat, pyc)
177                 finally:
178                     self._writing_pyc = False
179         else:
180             state.trace("found cached rewritten pyc for %r" % (fn,))
181         self.modules[name] = co, pyc
182         return self
183 
184     def _early_rewrite_bailout(self, name, state):
185         """
186         This is a fast way to get out of rewriting modules. Profiling has
187         shown that the call to imp.find_module (inside of the find_module
188         from this class) is a major slowdown, so, this method tries to
189         filter what we're sure won't be rewritten before getting to it.
190         """
191         if self.session is not None and not self._session_paths_checked:
192             self._session_paths_checked = True
193             for path in self.session._initialpaths:
194                 # Make something as c:/projects/my_project/path.py ->
195                 #     ['c:', 'projects', 'my_project', 'path.py']
196                 parts = str(path).split(os.path.sep)
197                 # add 'path' to basenames to be checked.
198                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])
199 
200         # Note: conftest already by default in _basenames_to_check_rewrite.
201         parts = name.split(".")
202         if parts[-1] in self._basenames_to_check_rewrite:
203             return False
204 
205         # For matching the name it must be as if it was a filename.
206         path = PurePath(os.path.sep.join(parts) + ".py")
207 
208         for pat in self.fnpats:
209             # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
210             # on the name alone because we need to match against the full path
211             if os.path.dirname(pat):
212                 return False
213             if fnmatch_ex(pat, path):
214                 return False
215 
216         if self._is_marked_for_rewrite(name, state):
217             return False
218 
219         state.trace("early skip of rewriting module: %s" % (name,))
220         return True
221 
222     def _should_rewrite(self, name, fn_pypath, state):
223         # always rewrite conftest files
224         fn = str(fn_pypath)
225         if fn_pypath.basename == "conftest.py":
226             state.trace("rewriting conftest file: %r" % (fn,))
227             return True
228 
229         if self.session is not None:
230             if self.session.isinitpath(fn):
231                 state.trace("matched test file (was specified on cmdline): %r" % (fn,))
232                 return True
233 
234         # modules not passed explicitly on the command line are only
235         # rewritten if they match the naming convention for test files
236         for pat in self.fnpats:
237             if fn_pypath.fnmatch(pat):
238                 state.trace("matched test file %r" % (fn,))
239                 return True
240 
241         return self._is_marked_for_rewrite(name, state)
242 
243     def _is_marked_for_rewrite(self, name, state):
244         try:
245             return self._marked_for_rewrite_cache[name]
246         except KeyError:
247             for marked in self._must_rewrite:
248                 if name == marked or name.startswith(marked + "."):
249                     state.trace("matched marked file %r (from %r)" % (name, marked))
250                     self._marked_for_rewrite_cache[name] = True
251                     return True
252 
253             self._marked_for_rewrite_cache[name] = False
254             return False
255 
256     def mark_rewrite(self, *names):
257         """Mark import names as needing to be rewritten.
258 
259         The named module or package as well as any nested modules will
260         be rewritten on import.
261         """
262         already_imported = (
263             set(names).intersection(sys.modules).difference(self._rewritten_names)
264         )
265         for name in already_imported:
266             if not AssertionRewriter.is_rewrite_disabled(
267                 sys.modules[name].__doc__ or ""
268             ):
269                 self._warn_already_imported(name)
270         self._must_rewrite.update(names)
271         self._marked_for_rewrite_cache.clear()
272 
273     def _warn_already_imported(self, name):
274         from _pytest.warning_types import PytestAssertRewriteWarning
275         from _pytest.warnings import _issue_warning_captured
276 
277         _issue_warning_captured(
278             PytestAssertRewriteWarning(
279                 "Module already imported so cannot be rewritten: %s" % name
280             ),
281             self.config.hook,
282             stacklevel=5,
283         )
284 
285     def load_module(self, name):
286         co, pyc = self.modules.pop(name)
287         if name in sys.modules:
288             # If there is an existing module object named 'fullname' in
289             # sys.modules, the loader must use that existing module. (Otherwise,
290             # the reload() builtin will not work correctly.)
291             mod = sys.modules[name]
292         else:
293             # I wish I could just call imp.load_compiled here, but __file__ has to
294             # be set properly. In Python 3.2+, this all would be handled correctly
295             # by load_compiled.
296             mod = sys.modules[name] = imp.new_module(name)
297         try:
298             mod.__file__ = co.co_filename
299             # Normally, this attribute is 3.2+.
300             mod.__cached__ = pyc
301             mod.__loader__ = self
302             # Normally, this attribute is 3.4+
303             mod.__spec__ = spec_from_file_location(name, co.co_filename, loader=self)
304             exec(co, mod.__dict__)
305         except:  # noqa
306             if name in sys.modules:
307                 del sys.modules[name]
308             raise
309         return sys.modules[name]
310 
311     def is_package(self, name):
312         try:
313             fd, fn, desc = self._imp_find_module(name)
314         except ImportError:
315             return False
316         if fd is not None:
317             fd.close()
318         tp = desc[2]
319         return tp == imp.PKG_DIRECTORY
320 
321     def get_data(self, pathname):
322         """Optional PEP302 get_data API.
323         """
324         with open(pathname, "rb") as f:
325             return f.read()
326 
327 
328 def _write_pyc(state, co, source_stat, pyc):
329     # Technically, we don't have to have the same pyc format as
330     # (C)Python, since these "pycs" should never be seen by builtin
331     # import. However, there's little reason deviate, and I hope
332     # sometime to be able to use imp.load_compiled to load them. (See
333     # the comment in load_module above.)
334     try:
335         with atomicwrites.atomic_write(pyc, mode="wb", overwrite=True) as fp:
336             fp.write(imp.get_magic())
337             # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
338             mtime = int(source_stat.mtime) & 0xFFFFFFFF
339             size = source_stat.size & 0xFFFFFFFF
340             # "<LL" stands for 2 unsigned longs, little-ending
341             fp.write(struct.pack("<LL", mtime, size))
342             fp.write(marshal.dumps(co))
343     except EnvironmentError as e:
344         state.trace("error writing pyc file at %s: errno=%s" % (pyc, e.errno))
345         # we ignore any failure to write the cache file
346         # there are many reasons, permission-denied, __pycache__ being a
347         # file etc.
348         return False
349     return True
350 
351 
352 RN = "\r\n".encode("utf-8")
353 N = "\n".encode("utf-8")
354 
355 cookie_re = re.compile(r"^[ \t\f]*#.*coding[:=][ \t]*[-\w.]+")
356 BOM_UTF8 = "\xef\xbb\xbf"
357 
358 
359 def _rewrite_test(config, fn):
360     """Try to read and rewrite *fn* and return the code object."""
361     state = config._assertstate
362     try:
363         stat = fn.stat()
364         source = fn.read("rb")
365     except EnvironmentError:
366         return None, None
367     if ASCII_IS_DEFAULT_ENCODING:
368         # ASCII is the default encoding in Python 2. Without a coding
369         # declaration, Python 2 will complain about any bytes in the file
370         # outside the ASCII range. Sadly, this behavior does not extend to
371         # compile() or ast.parse(), which prefer to interpret the bytes as
372         # latin-1. (At least they properly handle explicit coding cookies.) To
373         # preserve this error behavior, we could force ast.parse() to use ASCII
374         # as the encoding by inserting a coding cookie. Unfortunately, that
375         # messes up line numbers. Thus, we have to check ourselves if anything
376         # is outside the ASCII range in the case no encoding is explicitly
377         # declared. For more context, see issue #269. Yay for Python 3 which
378         # gets this right.
379         end1 = source.find("\n")
380         end2 = source.find("\n", end1 + 1)
381         if (
382             not source.startswith(BOM_UTF8)
383             and cookie_re.match(source[0:end1]) is None
384             and cookie_re.match(source[end1 + 1 : end2]) is None
385         ):
386             if hasattr(state, "_indecode"):
387                 # encodings imported us again, so don't rewrite.
388                 return None, None
389             state._indecode = True
390             try:
391                 try:
392                     source.decode("ascii")
393                 except UnicodeDecodeError:
394                     # Let it fail in real import.
395                     return None, None
396             finally:
397                 del state._indecode
398     try:
399         tree = ast.parse(source, filename=fn.strpath)
400     except SyntaxError:
401         # Let this pop up again in the real import.
402         state.trace("failed to parse: %r" % (fn,))
403         return None, None
404     rewrite_asserts(tree, fn, config)
405     try:
406         co = compile(tree, fn.strpath, "exec", dont_inherit=True)
407     except SyntaxError:
408         # It's possible that this error is from some bug in the
409         # assertion rewriting, but I don't know of a fast way to tell.
410         state.trace("failed to compile: %r" % (fn,))
411         return None, None
412     return stat, co
413 
414 
415 def _read_pyc(source, pyc, trace=lambda x: None):
416     """Possibly read a pytest pyc containing rewritten code.
417 
418     Return rewritten code if successful or None if not.
419     """
420     try:
421         fp = open(pyc, "rb")
422     except IOError:
423         return None
424     with fp:
425         try:
426             mtime = int(source.mtime())
427             size = source.size()
428             data = fp.read(12)
429         except EnvironmentError as e:
430             trace("_read_pyc(%s): EnvironmentError %s" % (source, e))
431             return None
432         # Check for invalid or out of date pyc file.
433         if (
434             len(data) != 12
435             or data[:4] != imp.get_magic()
436             or struct.unpack("<LL", data[4:]) != (mtime & 0xFFFFFFFF, size & 0xFFFFFFFF)
437         ):
438             trace("_read_pyc(%s): invalid or out of date pyc" % source)
439             return None
440         try:
441             co = marshal.load(fp)
442         except Exception as e:
443             trace("_read_pyc(%s): marshal.load error %s" % (source, e))
444             return None
445         if not isinstance(co, types.CodeType):
446             trace("_read_pyc(%s): not a code object" % source)
447             return None
448         return co
449 
450 
451 def rewrite_asserts(mod, module_path=None, config=None):
452     """Rewrite the assert statements in mod."""
453     AssertionRewriter(module_path, config).run(mod)
454 
455 
456 def _saferepr(obj):
457     """Get a safe repr of an object for assertion error messages.
458 
459     The assertion formatting (util.format_explanation()) requires
460     newlines to be escaped since they are a special character for it.
461     Normally assertion.util.format_explanation() does this but for a
462     custom repr it is possible to contain one of the special escape
463     sequences, especially '\n{' and '\n}' are likely to be present in
464     JSON reprs.
465 
466     """
467     r = saferepr(obj)
468     # only occurs in python2.x, repr must return text in python3+
469     if isinstance(r, bytes):
470         # Represent unprintable bytes as `\x##`
471         r = u"".join(
472             u"\\x{:x}".format(ord(c)) if c not in string.printable else c.decode()
473             for c in r
474         )
475     return r.replace(u"\n", u"\\n")
476 
477 
478 def _format_assertmsg(obj):
479     """Format the custom assertion message given.
480 
481     For strings this simply replaces newlines with '\n~' so that
482     util.format_explanation() will preserve them instead of escaping
483     newlines.  For other objects saferepr() is used first.
484 
485     """
486     # reprlib appears to have a bug which means that if a string
487     # contains a newline it gets escaped, however if an object has a
488     # .__repr__() which contains newlines it does not get escaped.
489     # However in either case we want to preserve the newline.
490     replaces = [(u"\n", u"\n~"), (u"%", u"%%")]
491     if not isinstance(obj, six.string_types):
492         obj = saferepr(obj)
493         replaces.append((u"\\n", u"\n~"))
494 
495     if isinstance(obj, bytes):
496         replaces = [(r1.encode(), r2.encode()) for r1, r2 in replaces]
497 
498     for r1, r2 in replaces:
499         obj = obj.replace(r1, r2)
500 
501     return obj
502 
503 
504 def _should_repr_global_name(obj):
505     if callable(obj):
506         return False
507 
508     try:
509         return not hasattr(obj, "__name__")
510     except Exception:
511         return True
512 
513 
514 def _format_boolop(explanations, is_or):
515     explanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
516     if isinstance(explanation, six.text_type):
517         return explanation.replace(u"%", u"%%")
518     else:
519         return explanation.replace(b"%", b"%%")
520 
521 
522 def _call_reprcompare(ops, results, expls, each_obj):
523     for i, res, expl in zip(range(len(ops)), results, expls):
524         try:
525             done = not res
526         except Exception:
527             done = True
528         if done:
529             break
530     if util._reprcompare is not None:
531         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
532         if custom is not None:
533             return custom
534     return expl
535 
536 
537 unary_map = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}
538 
539 binop_map = {
540     ast.BitOr: "|",
541     ast.BitXor: "^",
542     ast.BitAnd: "&",
543     ast.LShift: "<<",
544     ast.RShift: ">>",
545     ast.Add: "+",
546     ast.Sub: "-",
547     ast.Mult: "*",
548     ast.Div: "/",
549     ast.FloorDiv: "//",
550     ast.Mod: "%%",  # escaped for string formatting
551     ast.Eq: "==",
552     ast.NotEq: "!=",
553     ast.Lt: "<",
554     ast.LtE: "<=",
555     ast.Gt: ">",
556     ast.GtE: ">=",
557     ast.Pow: "**",
558     ast.Is: "is",
559     ast.IsNot: "is not",
560     ast.In: "in",
561     ast.NotIn: "not in",
562 }
563 # Python 3.5+ compatibility
564 try:
565     binop_map[ast.MatMult] = "@"
566 except AttributeError:
567     pass
568 
569 # Python 3.4+ compatibility
570 if hasattr(ast, "NameConstant"):
571     _NameConstant = ast.NameConstant
572 else:
573 
574     def _NameConstant(c):
575         return ast.Name(str(c), ast.Load())
576 
577 
578 def set_location(node, lineno, col_offset):
579     """Set node location information recursively."""
580 
581     def _fix(node, lineno, col_offset):
582         if "lineno" in node._attributes:
583             node.lineno = lineno
584         if "col_offset" in node._attributes:
585             node.col_offset = col_offset
586         for child in ast.iter_child_nodes(node):
587             _fix(child, lineno, col_offset)
588 
589     _fix(node, lineno, col_offset)
590     return node
591 
592 
593 class AssertionRewriter(ast.NodeVisitor):
594     """Assertion rewriting implementation.
595 
596     The main entrypoint is to call .run() with an ast.Module instance,
597     this will then find all the assert statements and rewrite them to
598     provide intermediate values and a detailed assertion error.  See
599     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
600     for an overview of how this works.
601 
602     The entry point here is .run() which will iterate over all the
603     statements in an ast.Module and for each ast.Assert statement it
604     finds call .visit() with it.  Then .visit_Assert() takes over and
605     is responsible for creating new ast statements to replace the
606     original assert statement: it rewrites the test of an assertion
607     to provide intermediate values and replace it with an if statement
608     which raises an assertion error with a detailed explanation in
609     case the expression is false.
610 
611     For this .visit_Assert() uses the visitor pattern to visit all the
612     AST nodes of the ast.Assert.test field, each visit call returning
613     an AST node and the corresponding explanation string.  During this
614     state is kept in several instance attributes:
615 
616     :statements: All the AST statements which will replace the assert
617        statement.
618 
619     :variables: This is populated by .variable() with each variable
620        used by the statements so that they can all be set to None at
621        the end of the statements.
622 
623     :variable_counter: Counter to create new unique variables needed
624        by statements.  Variables are created using .variable() and
625        have the form of "@py_assert0".
626 
627     :on_failure: The AST statements which will be executed if the
628        assertion test fails.  This is the code which will construct
629        the failure message and raises the AssertionError.
630 
631     :explanation_specifiers: A dict filled by .explanation_param()
632        with %-formatting placeholders and their corresponding
633        expressions to use in the building of an assertion message.
634        This is used by .pop_format_context() to build a message.
635 
636     :stack: A stack of the explanation_specifiers dicts maintained by
637        .push_format_context() and .pop_format_context() which allows
638        to build another %-formatted string while already building one.
639 
640     This state is reset on every new assert statement visited and used
641     by the other visitors.
642 
643     """
644 
645     def __init__(self, module_path, config):
646         super(AssertionRewriter, self).__init__()
647         self.module_path = module_path
648         self.config = config
649 
650     def run(self, mod):
651         """Find all assert statements in *mod* and rewrite them."""
652         if not mod.body:
653             # Nothing to do.
654             return
655         # Insert some special imports at the top of the module but after any
656         # docstrings and __future__ imports.
657         aliases = [
658             ast.alias(six.moves.builtins.__name__, "@py_builtins"),
659             ast.alias("_pytest.assertion.rewrite", "@pytest_ar"),
660         ]
661         doc = getattr(mod, "docstring", None)
662         expect_docstring = doc is None
663         if doc is not None and self.is_rewrite_disabled(doc):
664             return
665         pos = 0
666         lineno = 1
667         for item in mod.body:
668             if (
669                 expect_docstring
670                 and isinstance(item, ast.Expr)
671                 and isinstance(item.value, ast.Str)
672             ):
673                 doc = item.value.s
674                 if self.is_rewrite_disabled(doc):
675                     return
676                 expect_docstring = False
677             elif (
678                 not isinstance(item, ast.ImportFrom)
679                 or item.level > 0
680                 or item.module != "__future__"
681             ):
682                 lineno = item.lineno
683                 break
684             pos += 1
685         else:
686             lineno = item.lineno
687         imports = [
688             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
689         ]
690         mod.body[pos:pos] = imports
691         # Collect asserts.
692         nodes = [mod]
693         while nodes:
694             node = nodes.pop()
695             for name, field in ast.iter_fields(node):
696                 if isinstance(field, list):
697                     new = []
698                     for i, child in enumerate(field):
699                         if isinstance(child, ast.Assert):
700                             # Transform assert.
701                             new.extend(self.visit(child))
702                         else:
703                             new.append(child)
704                             if isinstance(child, ast.AST):
705                                 nodes.append(child)
706                     setattr(node, name, new)
707                 elif (
708                     isinstance(field, ast.AST)
709                     # Don't recurse into expressions as they can't contain
710                     # asserts.
711                     and not isinstance(field, ast.expr)
712                 ):
713                     nodes.append(field)
714 
715     @staticmethod
716     def is_rewrite_disabled(docstring):
717         return "PYTEST_DONT_REWRITE" in docstring
718 
719     def variable(self):
720         """Get a new variable."""
721         # Use a character invalid in python identifiers to avoid clashing.
722         name = "@py_assert" + str(next(self.variable_counter))
723         self.variables.append(name)
724         return name
725 
726     def assign(self, expr):
727         """Give *expr* a name."""
728         name = self.variable()
729         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
730         return ast.Name(name, ast.Load())
731 
732     def display(self, expr):
733         """Call saferepr on the expression."""
734         return self.helper("_saferepr", expr)
735 
736     def helper(self, name, *args):
737         """Call a helper in this module."""
738         py_name = ast.Name("@pytest_ar", ast.Load())
739         attr = ast.Attribute(py_name, name, ast.Load())
740         return ast_Call(attr, list(args), [])
741 
742     def builtin(self, name):
743         """Return the builtin called *name*."""
744         builtin_name = ast.Name("@py_builtins", ast.Load())
745         return ast.Attribute(builtin_name, name, ast.Load())
746 
747     def explanation_param(self, expr):
748         """Return a new named %-formatting placeholder for expr.
749 
750         This creates a %-formatting placeholder for expr in the
751         current formatting context, e.g. ``%(py0)s``.  The placeholder
752         and expr are placed in the current format context so that it
753         can be used on the next call to .pop_format_context().
754 
755         """
756         specifier = "py" + str(next(self.variable_counter))
757         self.explanation_specifiers[specifier] = expr
758         return "%(" + specifier + ")s"
759 
760     def push_format_context(self):
761         """Create a new formatting context.
762 
763         The format context is used for when an explanation wants to
764         have a variable value formatted in the assertion message.  In
765         this case the value required can be added using
766         .explanation_param().  Finally .pop_format_context() is used
767         to format a string of %-formatted values as added by
768         .explanation_param().
769 
770         """
771         self.explanation_specifiers = {}
772         self.stack.append(self.explanation_specifiers)
773 
774     def pop_format_context(self, expl_expr):
775         """Format the %-formatted string with current format context.
776 
777         The expl_expr should be an ast.Str instance constructed from
778         the %-placeholders created by .explanation_param().  This will
779         add the required code to format said string to .on_failure and
780         return the ast.Name instance of the formatted string.
781 
782         """
783         current = self.stack.pop()
784         if self.stack:
785             self.explanation_specifiers = self.stack[-1]
786         keys = [ast.Str(key) for key in current.keys()]
787         format_dict = ast.Dict(keys, list(current.values()))
788         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)
789         name = "@py_format" + str(next(self.variable_counter))
790         self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))
791         return ast.Name(name, ast.Load())
792 
793     def generic_visit(self, node):
794         """Handle expressions we don't have custom code for."""
795         assert isinstance(node, ast.expr)
796         res = self.assign(node)
797         return res, self.explanation_param(self.display(res))
798 
799     def visit_Assert(self, assert_):
800         """Return the AST statements to replace the ast.Assert instance.
801 
802         This rewrites the test of an assertion to provide
803         intermediate values and replace it with an if statement which
804         raises an assertion error with a detailed explanation in case
805         the expression is false.
806 
807         """
808         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
809             from _pytest.warning_types import PytestAssertRewriteWarning
810             import warnings
811 
812             warnings.warn_explicit(
813                 PytestAssertRewriteWarning(
814                     "assertion is always true, perhaps remove parentheses?"
815                 ),
816                 category=None,
817                 filename=str(self.module_path),
818                 lineno=assert_.lineno,
819             )
820 
821         self.statements = []
822         self.variables = []
823         self.variable_counter = itertools.count()
824         self.stack = []
825         self.on_failure = []
826         self.push_format_context()
827         # Rewrite assert into a bunch of statements.
828         top_condition, explanation = self.visit(assert_.test)
829         # If in a test module, check if directly asserting None, in order to warn [Issue #3191]
830         if self.module_path is not None:
831             self.statements.append(
832                 self.warn_about_none_ast(
833                     top_condition, module_path=self.module_path, lineno=assert_.lineno
834                 )
835             )
836         # Create failure message.
837         body = self.on_failure
838         negation = ast.UnaryOp(ast.Not(), top_condition)
839         self.statements.append(ast.If(negation, body, []))
840         if assert_.msg:
841             assertmsg = self.helper("_format_assertmsg", assert_.msg)
842             explanation = "\n>assert " + explanation
843         else:
844             assertmsg = ast.Str("")
845             explanation = "assert " + explanation
846         template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))
847         msg = self.pop_format_context(template)
848         fmt = self.helper("_format_explanation", msg)
849         err_name = ast.Name("AssertionError", ast.Load())
850         exc = ast_Call(err_name, [fmt], [])
851         if sys.version_info[0] >= 3:
852             raise_ = ast.Raise(exc, None)
853         else:
854             raise_ = ast.Raise(exc, None, None)
855         body.append(raise_)
856         # Clear temporary variables by setting them to None.
857         if self.variables:
858             variables = [ast.Name(name, ast.Store()) for name in self.variables]
859             clear = ast.Assign(variables, _NameConstant(None))
860             self.statements.append(clear)
861         # Fix line numbers.
862         for stmt in self.statements:
863             set_location(stmt, assert_.lineno, assert_.col_offset)
864         return self.statements
865 
866     def warn_about_none_ast(self, node, module_path, lineno):
867         """
868         Returns an AST issuing a warning if the value of node is `None`.
869         This is used to warn the user when asserting a function that asserts
870         internally already.
871         See issue #3191 for more details.
872         """
873 
874         # Using parse because it is different between py2 and py3.
875         AST_NONE = ast.parse("None").body[0].value
876         val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])
877         send_warning = ast.parse(
878             """
879 from _pytest.warning_types import PytestAssertRewriteWarning
880 from warnings import warn_explicit
881 warn_explicit(
882     PytestAssertRewriteWarning('asserting the value None, please use "assert is None"'),
883     category=None,
884     filename={filename!r},
885     lineno={lineno},
886 )
887             """.format(
888                 filename=module_path.strpath, lineno=lineno
889             )
890         ).body
891         return ast.If(val_is_none, send_warning, [])
892 
893     def visit_Name(self, name):
894         # Display the repr of the name if it's a local variable or
895         # _should_repr_global_name() thinks it's acceptable.
896         locs = ast_Call(self.builtin("locals"), [], [])
897         inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])
898         dorepr = self.helper("_should_repr_global_name", name)
899         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
900         expr = ast.IfExp(test, self.display(name), ast.Str(name.id))
901         return name, self.explanation_param(expr)
902 
903     def visit_BoolOp(self, boolop):
904         res_var = self.variable()
905         expl_list = self.assign(ast.List([], ast.Load()))
906         app = ast.Attribute(expl_list, "append", ast.Load())
907         is_or = int(isinstance(boolop.op, ast.Or))
908         body = save = self.statements
909         fail_save = self.on_failure
910         levels = len(boolop.values) - 1
911         self.push_format_context()
912         # Process each operand, short-circuting if needed.
913         for i, v in enumerate(boolop.values):
914             if i:
915                 fail_inner = []
916                 # cond is set in a prior loop iteration below
917                 self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa
918                 self.on_failure = fail_inner
919             self.push_format_context()
920             res, expl = self.visit(v)
921             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
922             expl_format = self.pop_format_context(ast.Str(expl))
923             call = ast_Call(app, [expl_format], [])
924             self.on_failure.append(ast.Expr(call))
925             if i < levels:
926                 cond = res
927                 if is_or:
928                     cond = ast.UnaryOp(ast.Not(), cond)
929                 inner = []
930                 self.statements.append(ast.If(cond, inner, []))
931                 self.statements = body = inner
932         self.statements = save
933         self.on_failure = fail_save
934         expl_template = self.helper("_format_boolop", expl_list, ast.Num(is_or))
935         expl = self.pop_format_context(expl_template)
936         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)
937 
938     def visit_UnaryOp(self, unary):
939         pattern = unary_map[unary.op.__class__]
940         operand_res, operand_expl = self.visit(unary.operand)
941         res = self.assign(ast.UnaryOp(unary.op, operand_res))
942         return res, pattern % (operand_expl,)
943 
944     def visit_BinOp(self, binop):
945         symbol = binop_map[binop.op.__class__]
946         left_expr, left_expl = self.visit(binop.left)
947         right_expr, right_expl = self.visit(binop.right)
948         explanation = "(%s %s %s)" % (left_expl, symbol, right_expl)
949         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
950         return res, explanation
951 
952     def visit_Call_35(self, call):
953         """
954         visit `ast.Call` nodes on Python3.5 and after
955         """
956         new_func, func_expl = self.visit(call.func)
957         arg_expls = []
958         new_args = []
959         new_kwargs = []
960         for arg in call.args:
961             res, expl = self.visit(arg)
962             arg_expls.append(expl)
963             new_args.append(res)
964         for keyword in call.keywords:
965             res, expl = self.visit(keyword.value)
966             new_kwargs.append(ast.keyword(keyword.arg, res))
967             if keyword.arg:
968                 arg_expls.append(keyword.arg + "=" + expl)
969             else:  # **args have `arg` keywords with an .arg of None
970                 arg_expls.append("**" + expl)
971 
972         expl = "%s(%s)" % (func_expl, ", ".join(arg_expls))
973         new_call = ast.Call(new_func, new_args, new_kwargs)
974         res = self.assign(new_call)
975         res_expl = self.explanation_param(self.display(res))
976         outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
977         return res, outer_expl
978 
979     def visit_Starred(self, starred):
980         # From Python 3.5, a Starred node can appear in a function call
981         res, expl = self.visit(starred.value)
982         new_starred = ast.Starred(res, starred.ctx)
983         return new_starred, "*" + expl
984 
985     def visit_Call_legacy(self, call):
986         """
987         visit `ast.Call nodes on 3.4 and below`
988         """
989         new_func, func_expl = self.visit(call.func)
990         arg_expls = []
991         new_args = []
992         new_kwargs = []
993         new_star = new_kwarg = None
994         for arg in call.args:
995             res, expl = self.visit(arg)
996             new_args.append(res)
997             arg_expls.append(expl)
998         for keyword in call.keywords:
999             res, expl = self.visit(keyword.value)
1000             new_kwargs.append(ast.keyword(keyword.arg, res))
1001             arg_expls.append(keyword.arg + "=" + expl)
1002         if call.starargs:
1003             new_star, expl = self.visit(call.starargs)
1004             arg_expls.append("*" + expl)
1005         if call.kwargs:
1006             new_kwarg, expl = self.visit(call.kwargs)
1007             arg_expls.append("**" + expl)
1008         expl = "%s(%s)" % (func_expl, ", ".join(arg_expls))
1009         new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)
1010         res = self.assign(new_call)
1011         res_expl = self.explanation_param(self.display(res))
1012         outer_expl = "%s\n{%s = %s\n}" % (res_expl, res_expl, expl)
1013         return res, outer_expl
1014 
1015     # ast.Call signature changed on 3.5,
1016     # conditionally change  which methods is named
1017     # visit_Call depending on Python version
1018     if sys.version_info >= (3, 5):
1019         visit_Call = visit_Call_35
1020     else:
1021         visit_Call = visit_Call_legacy
1022 
1023     def visit_Attribute(self, attr):
1024         if not isinstance(attr.ctx, ast.Load):
1025             return self.generic_visit(attr)
1026         value, value_expl = self.visit(attr.value)
1027         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
1028         res_expl = self.explanation_param(self.display(res))
1029         pat = "%s\n{%s = %s.%s\n}"
1030         expl = pat % (res_expl, res_expl, value_expl, attr.attr)
1031         return res, expl
1032 
1033     def visit_Compare(self, comp):
1034         self.push_format_context()
1035         left_res, left_expl = self.visit(comp.left)
1036         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):
1037             left_expl = "({})".format(left_expl)
1038         res_variables = [self.variable() for i in range(len(comp.ops))]
1039         load_names = [ast.Name(v, ast.Load()) for v in res_variables]
1040         store_names = [ast.Name(v, ast.Store()) for v in res_variables]
1041         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)
1042         expls = []
1043         syms = []
1044         results = [left_res]
1045         for i, op, next_operand in it:
1046             next_res, next_expl = self.visit(next_operand)
1047             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):
1048                 next_expl = "({})".format(next_expl)
1049             results.append(next_res)
1050             sym = binop_map[op.__class__]
1051             syms.append(ast.Str(sym))
1052             expl = "%s %s %s" % (left_expl, sym, next_expl)
1053             expls.append(ast.Str(expl))
1054             res_expr = ast.Compare(left_res, [op], [next_res])
1055             self.statements.append(ast.Assign([store_names[i]], res_expr))
1056             left_res, left_expl = next_res, next_expl
1057         # Use pytest.assertion.util._reprcompare if that's available.
1058         expl_call = self.helper(
1059             "_call_reprcompare",
1060             ast.Tuple(syms, ast.Load()),
1061             ast.Tuple(load_names, ast.Load()),
1062             ast.Tuple(expls, ast.Load()),
1063             ast.Tuple(results, ast.Load()),
1064         )
1065         if len(comp.ops) > 1:
1066             res = ast.BoolOp(ast.And(), load_names)
1067         else:
1068             res = load_names[0]
1069         return res, self.explanation_param(self.pop_format_context(expl_call))

</code><intended_behavior>Ensure that methods dealing with assertion errors properly handle Unicode characters, possibly by making sure encoding conversions are handled correctly under Python 2. This may involve explicitly encoding Unicode strings to UTF-8 (or another appropriate encoding) before they are processed or outputted.</intended_behavior>, <file>src/_pytest/compat.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 """
3 python version compatibility code
4 """
5 from __future__ import absolute_import
6 from __future__ import division
7 from __future__ import print_function
8 
9 import codecs
10 import functools
11 import inspect
12 import re
13 import sys
14 from contextlib import contextmanager
15 
16 import py
17 import six
18 from six import text_type
19 
20 import _pytest
21 from _pytest._io.saferepr import saferepr
22 from _pytest.outcomes import fail
23 from _pytest.outcomes import TEST_OUTCOME
24 
25 try:
26     import enum
27 except ImportError:  # pragma: no cover
28     # Only available in Python 3.4+ or as a backport
29     enum = None
30 
31 _PY3 = sys.version_info > (3, 0)
32 _PY2 = not _PY3
33 
34 
35 if _PY3:
36     from inspect import signature, Parameter as Parameter
37 else:
38     from funcsigs import signature, Parameter as Parameter
39 
40 NOTSET = object()
41 
42 PY35 = sys.version_info[:2] >= (3, 5)
43 PY36 = sys.version_info[:2] >= (3, 6)
44 MODULE_NOT_FOUND_ERROR = "ModuleNotFoundError" if PY36 else "ImportError"
45 
46 
47 if _PY3:
48     from collections.abc import MutableMapping as MappingMixin
49     from collections.abc import Iterable, Mapping, Sequence, Sized
50 else:
51     # those raise DeprecationWarnings in Python >=3.7
52     from collections import MutableMapping as MappingMixin  # noqa
53     from collections import Iterable, Mapping, Sequence, Sized  # noqa
54 
55 
56 if sys.version_info >= (3, 4):
57     from importlib.util import spec_from_file_location
58 else:
59 
60     def spec_from_file_location(*_, **__):
61         return None
62 
63 
64 def _format_args(func):
65     return str(signature(func))
66 
67 
68 isfunction = inspect.isfunction
69 isclass = inspect.isclass
70 # used to work around a python2 exception info leak
71 exc_clear = getattr(sys, "exc_clear", lambda: None)
72 # The type of re.compile objects is not exposed in Python.
73 REGEX_TYPE = type(re.compile(""))
74 
75 
76 def is_generator(func):
77     genfunc = inspect.isgeneratorfunction(func)
78     return genfunc and not iscoroutinefunction(func)
79 
80 
81 def iscoroutinefunction(func):
82     """Return True if func is a decorated coroutine function.
83 
84     Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,
85     which in turns also initializes the "logging" module as side-effect (see issue #8).
86     """
87     return getattr(func, "_is_coroutine", False) or (
88         hasattr(inspect, "iscoroutinefunction") and inspect.iscoroutinefunction(func)
89     )
90 
91 
92 def getlocation(function, curdir):
93     function = get_real_func(function)
94     fn = py.path.local(inspect.getfile(function))
95     lineno = function.__code__.co_firstlineno
96     if fn.relto(curdir):
97         fn = fn.relto(curdir)
98     return "%s:%d" % (fn, lineno + 1)
99 
100 
101 def num_mock_patch_args(function):
102     """ return number of arguments used up by mock arguments (if any) """
103     patchings = getattr(function, "patchings", None)
104     if not patchings:
105         return 0
106     mock_modules = [sys.modules.get("mock"), sys.modules.get("unittest.mock")]
107     if any(mock_modules):
108         sentinels = [m.DEFAULT for m in mock_modules if m is not None]
109         return len(
110             [p for p in patchings if not p.attribute_name and p.new in sentinels]
111         )
112     return len(patchings)
113 
114 
115 def getfuncargnames(function, is_method=False, cls=None):
116     """Returns the names of a function's mandatory arguments.
117 
118     This should return the names of all function arguments that:
119         * Aren't bound to an instance or type as in instance or class methods.
120         * Don't have default values.
121         * Aren't bound with functools.partial.
122         * Aren't replaced with mocks.
123 
124     The is_method and cls arguments indicate that the function should
125     be treated as a bound method even though it's not unless, only in
126     the case of cls, the function is a static method.
127 
128     @RonnyPfannschmidt: This function should be refactored when we
129     revisit fixtures. The fixture mechanism should ask the node for
130     the fixture names, and not try to obtain directly from the
131     function object well after collection has occurred.
132 
133     """
134     # The parameters attribute of a Signature object contains an
135     # ordered mapping of parameter names to Parameter instances.  This
136     # creates a tuple of the names of the parameters that don't have
137     # defaults.
138     try:
139         parameters = signature(function).parameters
140     except (ValueError, TypeError) as e:
141         fail(
142             "Could not determine arguments of {!r}: {}".format(function, e),
143             pytrace=False,
144         )
145 
146     arg_names = tuple(
147         p.name
148         for p in parameters.values()
149         if (
150             p.kind is Parameter.POSITIONAL_OR_KEYWORD
151             or p.kind is Parameter.KEYWORD_ONLY
152         )
153         and p.default is Parameter.empty
154     )
155     # If this function should be treated as a bound method even though
156     # it's passed as an unbound method or function, remove the first
157     # parameter name.
158     if is_method or (
159         cls and not isinstance(cls.__dict__.get(function.__name__, None), staticmethod)
160     ):
161         arg_names = arg_names[1:]
162     # Remove any names that will be replaced with mocks.
163     if hasattr(function, "__wrapped__"):
164         arg_names = arg_names[num_mock_patch_args(function) :]
165     return arg_names
166 
167 
168 @contextmanager
169 def dummy_context_manager():
170     """Context manager that does nothing, useful in situations where you might need an actual context manager or not
171     depending on some condition. Using this allow to keep the same code"""
172     yield
173 
174 
175 def get_default_arg_names(function):
176     # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,
177     # to get the arguments which were excluded from its result because they had default values
178     return tuple(
179         p.name
180         for p in signature(function).parameters.values()
181         if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)
182         and p.default is not Parameter.empty
183     )
184 
185 
186 _non_printable_ascii_translate_table = {
187     i: u"\\x{:02x}".format(i) for i in range(128) if i not in range(32, 127)
188 }
189 _non_printable_ascii_translate_table.update(
190     {ord("\t"): u"\\t", ord("\r"): u"\\r", ord("\n"): u"\\n"}
191 )
192 
193 
194 def _translate_non_printable(s):
195     return s.translate(_non_printable_ascii_translate_table)
196 
197 
198 if _PY3:
199     STRING_TYPES = bytes, str
200     UNICODE_TYPES = six.text_type
201 
202     if PY35:
203 
204         def _bytes_to_ascii(val):
205             return val.decode("ascii", "backslashreplace")
206 
207     else:
208 
209         def _bytes_to_ascii(val):
210             if val:
211                 # source: http://goo.gl/bGsnwC
212                 encoded_bytes, _ = codecs.escape_encode(val)
213                 return encoded_bytes.decode("ascii")
214             else:
215                 # empty bytes crashes codecs.escape_encode (#1087)
216                 return ""
217 
218     def ascii_escaped(val):
219         """If val is pure ascii, returns it as a str().  Otherwise, escapes
220         bytes objects into a sequence of escaped bytes:
221 
222         b'\xc3\xb4\xc5\xd6' -> u'\\xc3\\xb4\\xc5\\xd6'
223 
224         and escapes unicode objects into a sequence of escaped unicode
225         ids, e.g.:
226 
227         '4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'
228 
229         note:
230            the obvious "v.decode('unicode-escape')" will return
231            valid utf-8 unicode if it finds them in bytes, but we
232            want to return escaped bytes for any byte, even if they match
233            a utf-8 string.
234 
235         """
236         if isinstance(val, bytes):
237             ret = _bytes_to_ascii(val)
238         else:
239             ret = val.encode("unicode_escape").decode("ascii")
240         return _translate_non_printable(ret)
241 
242 
243 else:
244     STRING_TYPES = six.string_types
245     UNICODE_TYPES = six.text_type
246 
247     def ascii_escaped(val):
248         """In py2 bytes and str are the same type, so return if it's a bytes
249         object, return it unchanged if it is a full ascii string,
250         otherwise escape it into its binary form.
251 
252         If it's a unicode string, change the unicode characters into
253         unicode escapes.
254 
255         """
256         if isinstance(val, bytes):
257             try:
258                 ret = val.decode("ascii")
259             except UnicodeDecodeError:
260                 ret = val.encode("string-escape").decode("ascii")
261         else:
262             ret = val.encode("unicode-escape").decode("ascii")
263         return _translate_non_printable(ret)
264 
265 
266 class _PytestWrapper(object):
267     """Dummy wrapper around a function object for internal use only.
268 
269     Used to correctly unwrap the underlying function object
270     when we are creating fixtures, because we wrap the function object ourselves with a decorator
271     to issue warnings when the fixture function is called directly.
272     """
273 
274     def __init__(self, obj):
275         self.obj = obj
276 
277 
278 def get_real_func(obj):
279     """ gets the real function object of the (possibly) wrapped object by
280     functools.wraps or functools.partial.
281     """
282     start_obj = obj
283     for i in range(100):
284         # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function
285         # to trigger a warning if it gets called directly instead of by pytest: we don't
286         # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)
287         new_obj = getattr(obj, "__pytest_wrapped__", None)
288         if isinstance(new_obj, _PytestWrapper):
289             obj = new_obj.obj
290             break
291         new_obj = getattr(obj, "__wrapped__", None)
292         if new_obj is None:
293             break
294         obj = new_obj
295     else:
296         raise ValueError(
297             ("could not find real function of {start}\nstopped at {current}").format(
298                 start=saferepr(start_obj), current=saferepr(obj)
299             )
300         )
301     if isinstance(obj, functools.partial):
302         obj = obj.func
303     return obj
304 
305 
306 def get_real_method(obj, holder):
307     """
308     Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time
309     returning a bound method to ``holder`` if the original object was a bound method.
310     """
311     try:
312         is_method = hasattr(obj, "__func__")
313         obj = get_real_func(obj)
314     except Exception:
315         return obj
316     if is_method and hasattr(obj, "__get__") and callable(obj.__get__):
317         obj = obj.__get__(holder)
318     return obj
319 
320 
321 def getfslineno(obj):
322     # xxx let decorators etc specify a sane ordering
323     obj = get_real_func(obj)
324     if hasattr(obj, "place_as"):
325         obj = obj.place_as
326     fslineno = _pytest._code.getfslineno(obj)
327     assert isinstance(fslineno[1], int), obj
328     return fslineno
329 
330 
331 def getimfunc(func):
332     try:
333         return func.__func__
334     except AttributeError:
335         return func
336 
337 
338 def safe_getattr(object, name, default):
339     """ Like getattr but return default upon any Exception or any OutcomeException.
340 
341     Attribute access can potentially fail for 'evil' Python objects.
342     See issue #214.
343     It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException
344     instead of Exception (for more details check #2707)
345     """
346     try:
347         return getattr(object, name, default)
348     except TEST_OUTCOME:
349         return default
350 
351 
352 def safe_isclass(obj):
353     """Ignore any exception via isinstance on Python 3."""
354     try:
355         return isclass(obj)
356     except Exception:
357         return False
358 
359 
360 def _is_unittest_unexpected_success_a_failure():
361     """Return if the test suite should fail if an @expectedFailure unittest test PASSES.
362 
363     From https://docs.python.org/3/library/unittest.html?highlight=unittest#unittest.TestResult.wasSuccessful:
364         Changed in version 3.4: Returns False if there were any
365         unexpectedSuccesses from tests marked with the expectedFailure() decorator.
366     """
367     return sys.version_info >= (3, 4)
368 
369 
370 if _PY3:
371 
372     def safe_str(v):
373         """returns v as string"""
374         return str(v)
375 
376 
377 else:
378 
379     def safe_str(v):
380         """returns v as string, converting to utf-8 if necessary"""
381         try:
382             return str(v)
383         except UnicodeError:
384             if not isinstance(v, text_type):
385                 v = text_type(v)
386             errors = "replace"
387             return v.encode("utf-8", errors)
388 
389 
390 COLLECT_FAKEMODULE_ATTRIBUTES = (
391     "Collector",
392     "Module",
393     "Function",
394     "Instance",
395     "Session",
396     "Item",
397     "Class",
398     "File",
399     "_fillfuncargs",
400 )
401 
402 
403 def _setup_collect_fakemodule():
404     from types import ModuleType
405     import pytest
406 
407     pytest.collect = ModuleType("pytest.collect")
408     pytest.collect.__all__ = []  # used for setns
409     for attr in COLLECT_FAKEMODULE_ATTRIBUTES:
410         setattr(pytest.collect, attr, getattr(pytest, attr))
411 
412 
413 if _PY2:
414     # Without this the test_dupfile_on_textio will fail, otherwise CaptureIO could directly inherit from StringIO.
415     from py.io import TextIO
416 
417     class CaptureIO(TextIO):
418         @property
419         def encoding(self):
420             return getattr(self, "_encoding", "UTF-8")
421 
422 
423 else:
424     import io
425 
426     class CaptureIO(io.TextIOWrapper):
427         def __init__(self):
428             super(CaptureIO, self).__init__(
429                 io.BytesIO(), encoding="UTF-8", newline="", write_through=True
430             )
431 
432         def getvalue(self):
433             return self.buffer.getvalue().decode("UTF-8")
434 
435 
436 class FuncargnamesCompatAttr(object):
437     """ helper class so that Metafunc, Function and FixtureRequest
438     don't need to each define the "funcargnames" compatibility attribute.
439     """
440 
441     @property
442     def funcargnames(self):
443         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
444         return self.fixturenames
445 
446 
447 if six.PY2:
448 
449     def lru_cache(*_, **__):
450         def dec(fn):
451             return fn
452 
453         return dec
454 
455 
456 else:
457     from functools import lru_cache  # noqa: F401

</code><intended_behavior>Verify and, if necessary, adjust the encoding and decoding utilities to ensure they gracefully handle Unicode strings, especially in the context of assertions and exceptions. For example, utility functions could be designed to encode Unicode strings to a specific encoding only when running under Python 2, using `sys.version_info` checks.</intended_behavior>, <file>testing/python/raises.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 import sys
3 
4 import six
5 
6 import pytest
7 from _pytest.outcomes import Failed
8 from _pytest.warning_types import PytestDeprecationWarning
9 
10 
11 class TestRaises(object):
12     def test_raises(self):
13         source = "int('qwe')"
14         with pytest.warns(PytestDeprecationWarning):
15             excinfo = pytest.raises(ValueError, source)
16         code = excinfo.traceback[-1].frame.code
17         s = str(code.fullsource)
18         assert s == source
19 
20     def test_raises_exec(self):
21         with pytest.warns(PytestDeprecationWarning) as warninfo:
22             pytest.raises(ValueError, "a,x = []")
23         assert warninfo[0].filename == __file__
24 
25     def test_raises_exec_correct_filename(self):
26         with pytest.warns(PytestDeprecationWarning):
27             excinfo = pytest.raises(ValueError, 'int("s")')
28             assert __file__ in excinfo.traceback[-1].path
29 
30     def test_raises_syntax_error(self):
31         with pytest.warns(PytestDeprecationWarning) as warninfo:
32             pytest.raises(SyntaxError, "qwe qwe qwe")
33         assert warninfo[0].filename == __file__
34 
35     def test_raises_function(self):
36         pytest.raises(ValueError, int, "hello")
37 
38     def test_raises_callable_no_exception(self):
39         class A(object):
40             def __call__(self):
41                 pass
42 
43         try:
44             pytest.raises(ValueError, A())
45         except pytest.raises.Exception:
46             pass
47 
48     def test_raises_falsey_type_error(self):
49         with pytest.raises(TypeError):
50             with pytest.raises(AssertionError, match=0):
51                 raise AssertionError("ohai")
52 
53     def test_raises_repr_inflight(self):
54         """Ensure repr() on an exception info inside a pytest.raises with block works (#4386)"""
55 
56         class E(Exception):
57             pass
58 
59         with pytest.raises(E) as excinfo:
60             # this test prints the inflight uninitialized object
61             # using repr and str as well as pprint to demonstrate
62             # it works
63             print(str(excinfo))
64             print(repr(excinfo))
65             import pprint
66 
67             pprint.pprint(excinfo)
68             raise E()
69 
70     def test_raises_as_contextmanager(self, testdir):
71         testdir.makepyfile(
72             """
73             import pytest
74             import _pytest._code
75 
76             def test_simple():
77                 with pytest.raises(ZeroDivisionError) as excinfo:
78                     assert isinstance(excinfo, _pytest._code.ExceptionInfo)
79                     1/0
80                 print(excinfo)
81                 assert excinfo.type == ZeroDivisionError
82                 assert isinstance(excinfo.value, ZeroDivisionError)
83 
84             def test_noraise():
85                 with pytest.raises(pytest.raises.Exception):
86                     with pytest.raises(ValueError):
87                            int()
88 
89             def test_raise_wrong_exception_passes_by():
90                 with pytest.raises(ZeroDivisionError):
91                     with pytest.raises(ValueError):
92                            1/0
93         """
94         )
95         result = testdir.runpytest()
96         result.stdout.fnmatch_lines(["*3 passed*"])
97 
98     def test_does_not_raise(self, testdir):
99         testdir.makepyfile(
100             """
101             from contextlib import contextmanager
102             import pytest
103 
104             @contextmanager
105             def does_not_raise():
106                 yield
107 
108             @pytest.mark.parametrize('example_input,expectation', [
109                 (3, does_not_raise()),
110                 (2, does_not_raise()),
111                 (1, does_not_raise()),
112                 (0, pytest.raises(ZeroDivisionError)),
113             ])
114             def test_division(example_input, expectation):
115                 '''Test how much I know division.'''
116                 with expectation:
117                     assert (6 / example_input) is not None
118         """
119         )
120         result = testdir.runpytest()
121         result.stdout.fnmatch_lines(["*4 passed*"])
122 
123     def test_does_not_raise_does_raise(self, testdir):
124         testdir.makepyfile(
125             """
126             from contextlib import contextmanager
127             import pytest
128 
129             @contextmanager
130             def does_not_raise():
131                 yield
132 
133             @pytest.mark.parametrize('example_input,expectation', [
134                 (0, does_not_raise()),
135                 (1, pytest.raises(ZeroDivisionError)),
136             ])
137             def test_division(example_input, expectation):
138                 '''Test how much I know division.'''
139                 with expectation:
140                     assert (6 / example_input) is not None
141         """
142         )
143         result = testdir.runpytest()
144         result.stdout.fnmatch_lines(["*2 failed*"])
145 
146     def test_noclass(self):
147         with pytest.raises(TypeError):
148             pytest.raises("wrong", lambda: None)
149 
150     def test_invalid_arguments_to_raises(self):
151         with pytest.raises(TypeError, match="unknown"):
152             with pytest.raises(TypeError, unknown="bogus"):
153                 raise ValueError()
154 
155     def test_tuple(self):
156         with pytest.raises((KeyError, ValueError)):
157             raise KeyError("oops")
158 
159     def test_no_raise_message(self):
160         try:
161             pytest.raises(ValueError, int, "0")
162         except pytest.raises.Exception as e:
163             assert e.msg == "DID NOT RAISE {}".format(repr(ValueError))
164         else:
165             assert False, "Expected pytest.raises.Exception"
166 
167         try:
168             with pytest.raises(ValueError):
169                 pass
170         except pytest.raises.Exception as e:
171             assert e.msg == "DID NOT RAISE {}".format(repr(ValueError))
172         else:
173             assert False, "Expected pytest.raises.Exception"
174 
175     def test_custom_raise_message(self):
176         message = "TEST_MESSAGE"
177         try:
178             with pytest.warns(PytestDeprecationWarning):
179                 with pytest.raises(ValueError, message=message):
180                     pass
181         except pytest.raises.Exception as e:
182             assert e.msg == message
183         else:
184             assert False, "Expected pytest.raises.Exception"
185 
186     @pytest.mark.parametrize("method", ["function", "with"])
187     def test_raises_cyclic_reference(self, method):
188         """
189         Ensure pytest.raises does not leave a reference cycle (#1965).
190         """
191         import gc
192 
193         class T(object):
194             def __call__(self):
195                 raise ValueError
196 
197         t = T()
198         if method == "function":
199             pytest.raises(ValueError, t)
200         else:
201             with pytest.raises(ValueError):
202                 t()
203 
204         # ensure both forms of pytest.raises don't leave exceptions in sys.exc_info()
205         assert sys.exc_info() == (None, None, None)
206 
207         del t
208 
209         # ensure the t instance is not stuck in a cyclic reference
210         for o in gc.get_objects():
211             assert type(o) is not T
212 
213     def test_raises_match(self):
214         msg = r"with base \d+"
215         with pytest.raises(ValueError, match=msg):
216             int("asdf")
217 
218         msg = "with base 10"
219         with pytest.raises(ValueError, match=msg):
220             int("asdf")
221 
222         msg = "with base 16"
223         expr = r"Pattern '{}' not found in 'invalid literal for int\(\) with base 10: 'asdf''".format(
224             msg
225         )
226         with pytest.raises(AssertionError, match=expr):
227             with pytest.raises(ValueError, match=msg):
228                 int("asdf", base=10)
229 
230     def test_raises_match_wrong_type(self):
231         """Raising an exception with the wrong type and match= given.
232 
233         pytest should throw the unexpected exception - the pattern match is not
234         really relevant if we got a different exception.
235         """
236         with pytest.raises(ValueError):
237             with pytest.raises(IndexError, match="nomatch"):
238                 int("asdf")
239 
240     def test_raises_exception_looks_iterable(self):
241         from six import add_metaclass
242 
243         class Meta(type(object)):
244             def __getitem__(self, item):
245                 return 1 / 0
246 
247             def __len__(self):
248                 return 1
249 
250         @add_metaclass(Meta)
251         class ClassLooksIterableException(Exception):
252             pass
253 
254         with pytest.raises(
255             Failed,
256             match=r"DID NOT RAISE <class 'raises(\..*)*ClassLooksIterableException'>",
257         ):
258             pytest.raises(ClassLooksIterableException, lambda: None)
259 
260     def test_raises_with_raising_dunder_class(self):
261         """Test current behavior with regard to exceptions via __class__ (#4284)."""
262 
263         class CrappyClass(Exception):
264             @property
265             def __class__(self):
266                 assert False, "via __class__"
267 
268         if six.PY2:
269             with pytest.raises(pytest.fail.Exception) as excinfo:
270                 with pytest.raises(CrappyClass()):
271                     pass
272             assert "DID NOT RAISE" in excinfo.value.args[0]
273 
274             with pytest.raises(CrappyClass) as excinfo:
275                 raise CrappyClass()
276         else:
277             with pytest.raises(AssertionError) as excinfo:
278                 with pytest.raises(CrappyClass()):
279                     pass
280             assert "via __class__" in excinfo.value.args[0]

</code><intended_behavior>Ensure any test cases that use `pytest.raises` with Unicode strings are correctly designed to handle or expect Unicode characters without causing encoding errors. If this file contains custom utility functions or helpers around `pytest.raises`, verify these helpers manage Unicode strings properly under Python 2.</intended_behavior>]
2025-10-18 04:50:12.239 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 04:50:12.239 | INFO     | Search-only: skipping patch selection
2025-10-18 04:50:12.320 | INFO     | Task pytest-dev__pytest-5479 completed successfully.
2025-10-18 04:50:12.321 | INFO     | No patch generated. You can try running ACR again.
