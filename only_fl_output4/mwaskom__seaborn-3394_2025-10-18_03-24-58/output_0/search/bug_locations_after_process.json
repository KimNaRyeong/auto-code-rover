[
    {
        "rel_file_path": "seaborn/relational.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/relational.py",
        "start": 570,
        "end": 613,
        "class_name": null,
        "method_name": "lineplot",
        "code": "570 def lineplot(\n571     data=None, *,\n572     x=None, y=None, hue=None, size=None, style=None, units=None,\n573     palette=None, hue_order=None, hue_norm=None,\n574     sizes=None, size_order=None, size_norm=None,\n575     dashes=True, markers=None, style_order=None,\n576     estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,\n577     orient=\"x\", sort=True, err_style=\"band\", err_kws=None,\n578     legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs\n579 ):\n580 \n581     # Handle deprecation of ci parameter\n582     errorbar = _deprecate_ci(errorbar, ci)\n583 \n584     variables = _LinePlotter.get_semantics(locals())\n585     p = _LinePlotter(\n586         data=data, variables=variables,\n587         estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,\n588         sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,\n589         legend=legend,\n590     )\n591 \n592     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n593     p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n594     p.map_style(markers=markers, dashes=dashes, order=style_order)\n595 \n596     if ax is None:\n597         ax = plt.gca()\n598 \n599     if \"style\" not in p.variables and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX\n600         kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes\n601 \n602     if not p.has_xy_data:\n603         return ax\n604 \n605     p._attach(ax)\n606 \n607     # Other functions have color as an explicit param,\n608     # and we should probably do that here too\n609     color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n610     kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n611 \n612     p.plot(ax, kwargs)\n613     return ax\n",
        "intended_behavior": "The `lineplot` function should maintain the axis ordering consistent with the input data, regardless of the presence of `pd.NA`. It means ensuring that during data preparation before plotting, `pd.NA` values are handled in a way that does not affect sorting or ordering of the axis. This might involve better integration or checks during the data transformation steps that happen prior to plotting, such as ensuring that `pd.NA` values are treated correctly in comparisons or sorting operations, without reversing the axis order. The fix should ensure that the presence of `pd.NA` does not lead to automatic or unintended reordering of plot axes, thus maintaining a predictable and consistent plotting behavior that aligns with user expectations."
    },
    {
        "rel_file_path": "seaborn/_core/scales.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/_core/scales.py",
        "start": 164,
        "end": 200,
        "class_name": "Boolean",
        "method_name": "_setup",
        "code": "164     def _setup(\n165         self, data: Series, prop: Property, axis: Axis | None = None,\n166     ) -> Scale:\n167 \n168         new = copy(self)\n169         if new._tick_params is None:\n170             new = new.tick()\n171         if new._label_params is None:\n172             new = new.label()\n173 \n174         def na_safe_cast(x):\n175             # TODO this doesn't actually need to be a closure\n176             if np.isscalar(x):\n177                 return float(bool(x))\n178             else:\n179                 if hasattr(x, \"notna\"):\n180                     # Handle pd.NA; np<>pd interop with NA is tricky\n181                     use = x.notna().to_numpy()\n182                 else:\n183                     use = np.isfinite(x)\n184                 out = np.full(len(x), np.nan, dtype=float)\n185                 out[use] = x[use].astype(bool).astype(float)\n186                 return out\n187 \n188         new._pipeline = [na_safe_cast, prop.get_mapping(new, data)]\n189         new._spacer = _default_spacer\n190         if prop.legend:\n191             new._legend = [True, False], [\"True\", \"False\"]\n192 \n193         forward, inverse = _make_identity_transforms()\n194         mpl_scale = new._get_scale(str(data.name), forward, inverse)\n195 \n196         axis = PseudoAxis(mpl_scale) if axis is None else axis\n197         mpl_scale.set_default_locators_and_formatters(axis)\n198         new._matplotlib_scale = mpl_scale\n199 \n200         return new\n",
        "intended_behavior": "While the direct issue doesn\u2019t stem from this specific location, the handling of `pd.NA` shown here represents seaborn\u2019s approach to dealing with pandas' newer missing value type. The intended change is not in the method itself but suggests a broader review and possibly updating other areas of the seaborn codebase to consistently manage `pd.NA` in a way that does not impact the logical flow or output of the visualization functions. Specifically, it would involve ensuring that wherever `pd.NA` values could impact plot outputs (beyond Boolean scaling), those areas should correctly interpret `pd.NA` to either exclude such values from affecting plot scales, legends, or axis ordering, or handle them in a manner that matches user expectations and pandas behavior closely."
    },
    {
        "rel_file_path": "seaborn/_core/scales.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/_core/scales.py",
        "start": 149,
        "end": 238,
        "class_name": "Boolean",
        "method_name": null,
        "code": "149 class Boolean(Scale):\n150     \"\"\"\n151     A scale with a discrete domain of True and False values.\n152 \n153     The behavior is similar to the :class:`Nominal` scale, but property\n154     mappings and legends will use a [True, False] ordering rather than\n155     a sort using numeric rules. Coordinate variables accomplish this by\n156     inverting axis limits so as to maintain underlying numeric positioning.\n157     Input data are cast to boolean values, respecting missing data.\n158 \n159     \"\"\"\n160     values: tuple | list | dict | None = None\n161 \n162     _priority: ClassVar[int] = 3\n163 \n164     def _setup(\n165         self, data: Series, prop: Property, axis: Axis | None = None,\n166     ) -> Scale:\n167 \n168         new = copy(self)\n169         if new._tick_params is None:\n170             new = new.tick()\n171         if new._label_params is None:\n172             new = new.label()\n173 \n174         def na_safe_cast(x):\n175             # TODO this doesn't actually need to be a closure\n176             if np.isscalar(x):\n177                 return float(bool(x))\n178             else:\n179                 if hasattr(x, \"notna\"):\n180                     # Handle pd.NA; np<>pd interop with NA is tricky\n181                     use = x.notna().to_numpy()\n182                 else:\n183                     use = np.isfinite(x)\n184                 out = np.full(len(x), np.nan, dtype=float)\n185                 out[use] = x[use].astype(bool).astype(float)\n186                 return out\n187 \n188         new._pipeline = [na_safe_cast, prop.get_mapping(new, data)]\n189         new._spacer = _default_spacer\n190         if prop.legend:\n191             new._legend = [True, False], [\"True\", \"False\"]\n192 \n193         forward, inverse = _make_identity_transforms()\n194         mpl_scale = new._get_scale(str(data.name), forward, inverse)\n195 \n196         axis = PseudoAxis(mpl_scale) if axis is None else axis\n197         mpl_scale.set_default_locators_and_formatters(axis)\n198         new._matplotlib_scale = mpl_scale\n199 \n200         return new\n201 \n202     def _finalize(self, p: Plot, axis: Axis) -> None:\n203 \n204         # We want values to appear in a True, False order but also want\n205         # True/False to be drawn at 1/0 positions respectively to avoid nasty\n206         # surprises if additional artists are added through the matplotlib API.\n207         # We accomplish this using axis inversion akin to what we do in Nominal.\n208 \n209         ax = axis.axes\n210         name = axis.axis_name\n211         axis.grid(False, which=\"both\")\n212         if name not in p._limits:\n213             nticks = len(axis.get_major_ticks())\n214             lo, hi = -.5, nticks - .5\n215             if name == \"x\":\n216                 lo, hi = hi, lo\n217             set_lim = getattr(ax, f\"set_{name}lim\")\n218             set_lim(lo, hi, auto=None)\n219 \n220     def tick(self, locator: Locator | None = None):\n221         new = copy(self)\n222         new._tick_params = {\"locator\": locator}\n223         return new\n224 \n225     def label(self, formatter: Formatter | None = None):\n226         new = copy(self)\n227         new._label_params = {\"formatter\": formatter}\n228         return new\n229 \n230     def _get_locators(self, locator):\n231         if locator is not None:\n232             return locator\n233         return FixedLocator([0, 1]), None\n234 \n235     def _get_formatter(self, locator, formatter):\n236         if formatter is not None:\n237             return formatter\n238         return FuncFormatter(lambda x, _: str(bool(x)))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]