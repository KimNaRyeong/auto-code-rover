[
    {
        "rel_file_path": "sympy/core/evalf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/evalf.py",
        "start": 1,
        "end": 1539,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Adaptive numerical evaluation of SymPy expressions, using mpmath\n3 for mathematical functions.\n4 \"\"\"\n5 from __future__ import print_function, division\n6 \n7 import math\n8 \n9 import mpmath.libmp as libmp\n10 from mpmath import (\n11     make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec)\n12 from mpmath import inf as mpmath_inf\n13 from mpmath.libmp import (from_int, from_man_exp, from_rational, fhalf,\n14         fnan, fnone, fone, fzero, mpf_abs, mpf_add,\n15         mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt,\n16         mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin,\n17         mpf_sqrt, normalize, round_nearest, to_int, to_str)\n18 from mpmath.libmp import bitcount as mpmath_bitcount\n19 from mpmath.libmp.backend import MPZ\n20 from mpmath.libmp.libmpc import _infs_nan\n21 from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps\n22 from mpmath.libmp.gammazeta import mpf_bernoulli\n23 \n24 from .compatibility import SYMPY_INTS, range\n25 from .sympify import sympify\n26 from .singleton import S\n27 \n28 from sympy.utilities.iterables import is_sequence\n29 \n30 LG10 = math.log(10, 2)\n31 rnd = round_nearest\n32 \n33 \n34 def bitcount(n):\n35     \"\"\"Return smallest integer, b, such that |n|/2**b < 1.\n36     \"\"\"\n37     return mpmath_bitcount(abs(int(n)))\n38 \n39 # Used in a few places as placeholder values to denote exponents and\n40 # precision levels, e.g. of exact numbers. Must be careful to avoid\n41 # passing these to mpmath functions or returning them in final results.\n42 INF = float(mpmath_inf)\n43 MINUS_INF = float(-mpmath_inf)\n44 \n45 # ~= 100 digits. Real men set this to INF.\n46 DEFAULT_MAXPREC = 333\n47 \n48 \n49 class PrecisionExhausted(ArithmeticError):\n50     pass\n51 \n52 #----------------------------------------------------------------------------#\n53 #                                                                            #\n54 #              Helper functions for arithmetic and complex parts             #\n55 #                                                                            #\n56 #----------------------------------------------------------------------------#\n57 \n58 \"\"\"\n59 An mpf value tuple is a tuple of integers (sign, man, exp, bc)\n60 representing a floating-point number: [1, -1][sign]*man*2**exp where\n61 sign is 0 or 1 and bc should correspond to the number of bits used to\n62 represent the mantissa (man) in binary notation, e.g.\n63 \n64 >>> from sympy.core.evalf import bitcount\n65 >>> sign, man, exp, bc = 0, 5, 1, 3\n66 >>> n = [1, -1][sign]*man*2**exp\n67 >>> n, bitcount(man)\n68 (10, 3)\n69 \n70 A temporary result is a tuple (re, im, re_acc, im_acc) where\n71 re and im are nonzero mpf value tuples representing approximate\n72 numbers, or None to denote exact zeros.\n73 \n74 re_acc, im_acc are integers denoting log2(e) where e is the estimated\n75 relative accuracy of the respective complex part, but may be anything\n76 if the corresponding complex part is None.\n77 \n78 \"\"\"\n79 \n80 \n81 def fastlog(x):\n82     \"\"\"Fast approximation of log2(x) for an mpf value tuple x.\n83 \n84     Notes: Calculated as exponent + width of mantissa. This is an\n85     approximation for two reasons: 1) it gives the ceil(log2(abs(x)))\n86     value and 2) it is too high by 1 in the case that x is an exact\n87     power of 2. Although this is easy to remedy by testing to see if\n88     the odd mpf mantissa is 1 (indicating that one was dealing with\n89     an exact power of 2) that would decrease the speed and is not\n90     necessary as this is only being used as an approximation for the\n91     number of bits in x. The correct return value could be written as\n92     \"x[2] + (x[3] if x[1] != 1 else 0)\".\n93         Since mpf tuples always have an odd mantissa, no check is done\n94     to see if the mantissa is a multiple of 2 (in which case the\n95     result would be too large by 1).\n96 \n97     Examples\n98     ========\n99 \n100     >>> from sympy import log\n101     >>> from sympy.core.evalf import fastlog, bitcount\n102     >>> s, m, e = 0, 5, 1\n103     >>> bc = bitcount(m)\n104     >>> n = [1, -1][s]*m*2**e\n105     >>> n, (log(n)/log(2)).evalf(2), fastlog((s, m, e, bc))\n106     (10, 3.3, 4)\n107     \"\"\"\n108 \n109     if not x or x == fzero:\n110         return MINUS_INF\n111     return x[2] + x[3]\n112 \n113 \n114 def pure_complex(v, or_real=False):\n115     \"\"\"Return a and b if v matches a + I*b where b is not zero and\n116     a and b are Numbers, else None. If `or_real` is True then 0 will\n117     be returned for `b` if `v` is a real number.\n118 \n119     >>> from sympy.core.evalf import pure_complex\n120     >>> from sympy import sqrt, I, S\n121     >>> a, b, surd = S(2), S(3), sqrt(2)\n122     >>> pure_complex(a)\n123     >>> pure_complex(a, or_real=True)\n124     (2, 0)\n125     >>> pure_complex(surd)\n126     >>> pure_complex(a + b*I)\n127     (2, 3)\n128     >>> pure_complex(I)\n129     (0, 1)\n130     \"\"\"\n131     h, t = v.as_coeff_Add()\n132     if not t:\n133         if or_real:\n134             return h, t\n135         return\n136     c, i = t.as_coeff_Mul()\n137     if i is S.ImaginaryUnit:\n138         return h, c\n139 \n140 \n141 def scaled_zero(mag, sign=1):\n142     \"\"\"Return an mpf representing a power of two with magnitude ``mag``\n143     and -1 for precision. Or, if ``mag`` is a scaled_zero tuple, then just\n144     remove the sign from within the list that it was initially wrapped\n145     in.\n146 \n147     Examples\n148     ========\n149 \n150     >>> from sympy.core.evalf import scaled_zero\n151     >>> from sympy import Float\n152     >>> z, p = scaled_zero(100)\n153     >>> z, p\n154     (([0], 1, 100, 1), -1)\n155     >>> ok = scaled_zero(z)\n156     >>> ok\n157     (0, 1, 100, 1)\n158     >>> Float(ok)\n159     1.26765060022823e+30\n160     >>> Float(ok, p)\n161     0.e+30\n162     >>> ok, p = scaled_zero(100, -1)\n163     >>> Float(scaled_zero(ok), p)\n164     -0.e+30\n165     \"\"\"\n166     if type(mag) is tuple and len(mag) == 4 and iszero(mag, scaled=True):\n167         return (mag[0][0],) + mag[1:]\n168     elif isinstance(mag, SYMPY_INTS):\n169         if sign not in [-1, 1]:\n170             raise ValueError('sign must be +/-1')\n171         rv, p = mpf_shift(fone, mag), -1\n172         s = 0 if sign == 1 else 1\n173         rv = ([s],) + rv[1:]\n174         return rv, p\n175     else:\n176         raise ValueError('scaled zero expects int or scaled_zero tuple.')\n177 \n178 \n179 def iszero(mpf, scaled=False):\n180     if not scaled:\n181         return not mpf or not mpf[1] and not mpf[-1]\n182     return mpf and type(mpf[0]) is list and mpf[1] == mpf[-1] == 1\n183 \n184 \n185 def complex_accuracy(result):\n186     \"\"\"\n187     Returns relative accuracy of a complex number with given accuracies\n188     for the real and imaginary parts. The relative accuracy is defined\n189     in the complex norm sense as ||z|+|error|| / |z| where error\n190     is equal to (real absolute error) + (imag absolute error)*i.\n191 \n192     The full expression for the (logarithmic) error can be approximated\n193     easily by using the max norm to approximate the complex norm.\n194 \n195     In the worst case (re and im equal), this is wrong by a factor\n196     sqrt(2), or by log2(sqrt(2)) = 0.5 bit.\n197     \"\"\"\n198     re, im, re_acc, im_acc = result\n199     if not im:\n200         if not re:\n201             return INF\n202         return re_acc\n203     if not re:\n204         return im_acc\n205     re_size = fastlog(re)\n206     im_size = fastlog(im)\n207     absolute_error = max(re_size - re_acc, im_size - im_acc)\n208     relative_error = absolute_error - max(re_size, im_size)\n209     return -relative_error\n210 \n211 \n212 def get_abs(expr, prec, options):\n213     re, im, re_acc, im_acc = evalf(expr, prec + 2, options)\n214 \n215     if not re:\n216         re, re_acc, im, im_acc = im, im_acc, re, re_acc\n217     if im:\n218         if expr.is_number:\n219             abs_expr, _, acc, _ = evalf(abs(N(expr, prec + 2)),\n220                                         prec + 2, options)\n221             return abs_expr, None, acc, None\n222         else:\n223             if 'subs' in options:\n224                 return libmp.mpc_abs((re, im), prec), None, re_acc, None\n225             return abs(expr), None, prec, None\n226     elif re:\n227         return mpf_abs(re), None, re_acc, None\n228     else:\n229         return None, None, None, None\n230 \n231 \n232 def get_complex_part(expr, no, prec, options):\n233     \"\"\"no = 0 for real part, no = 1 for imaginary part\"\"\"\n234     workprec = prec\n235     i = 0\n236     while 1:\n237         res = evalf(expr, workprec, options)\n238         value, accuracy = res[no::2]\n239         # XXX is the last one correct? Consider re((1+I)**2).n()\n240         if (not value) or accuracy >= prec or -value[2] > prec:\n241             return value, None, accuracy, None\n242         workprec += max(30, 2**i)\n243         i += 1\n244 \n245 \n246 def evalf_abs(expr, prec, options):\n247     return get_abs(expr.args[0], prec, options)\n248 \n249 \n250 def evalf_re(expr, prec, options):\n251     return get_complex_part(expr.args[0], 0, prec, options)\n252 \n253 \n254 def evalf_im(expr, prec, options):\n255     return get_complex_part(expr.args[0], 1, prec, options)\n256 \n257 \n258 def finalize_complex(re, im, prec):\n259     if re == fzero and im == fzero:\n260         raise ValueError(\"got complex zero with unknown accuracy\")\n261     elif re == fzero:\n262         return None, im, None, prec\n263     elif im == fzero:\n264         return re, None, prec, None\n265 \n266     size_re = fastlog(re)\n267     size_im = fastlog(im)\n268     if size_re > size_im:\n269         re_acc = prec\n270         im_acc = prec + min(-(size_re - size_im), 0)\n271     else:\n272         im_acc = prec\n273         re_acc = prec + min(-(size_im - size_re), 0)\n274     return re, im, re_acc, im_acc\n275 \n276 \n277 def chop_parts(value, prec):\n278     \"\"\"\n279     Chop off tiny real or complex parts.\n280     \"\"\"\n281     re, im, re_acc, im_acc = value\n282     # Method 1: chop based on absolute value\n283     if re and re not in _infs_nan and (fastlog(re) < -prec + 4):\n284         re, re_acc = None, None\n285     if im and im not in _infs_nan and (fastlog(im) < -prec + 4):\n286         im, im_acc = None, None\n287     # Method 2: chop if inaccurate and relatively small\n288     if re and im:\n289         delta = fastlog(re) - fastlog(im)\n290         if re_acc < 2 and (delta - re_acc <= -prec + 4):\n291             re, re_acc = None, None\n292         if im_acc < 2 and (delta - im_acc >= prec - 4):\n293             im, im_acc = None, None\n294     return re, im, re_acc, im_acc\n295 \n296 \n297 def check_target(expr, result, prec):\n298     a = complex_accuracy(result)\n299     if a < prec:\n300         raise PrecisionExhausted(\"Failed to distinguish the expression: \\n\\n%s\\n\\n\"\n301             \"from zero. Try simplifying the input, using chop=True, or providing \"\n302             \"a higher maxn for evalf\" % (expr))\n303 \n304 \n305 def get_integer_part(expr, no, options, return_ints=False):\n306     \"\"\"\n307     With no = 1, computes ceiling(expr)\n308     With no = -1, computes floor(expr)\n309 \n310     Note: this function either gives the exact result or signals failure.\n311     \"\"\"\n312     from sympy.functions.elementary.complexes import re, im\n313     # The expression is likely less than 2^30 or so\n314     assumed_size = 30\n315     ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)\n316 \n317     # We now know the size, so we can calculate how much extra precision\n318     # (if any) is needed to get within the nearest integer\n319     if ire and iim:\n320         gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)\n321     elif ire:\n322         gap = fastlog(ire) - ire_acc\n323     elif iim:\n324         gap = fastlog(iim) - iim_acc\n325     else:\n326         # ... or maybe the expression was exactly zero\n327         return None, None, None, None\n328 \n329     margin = 10\n330 \n331     if gap >= -margin:\n332         prec = margin + assumed_size + gap\n333         ire, iim, ire_acc, iim_acc = evalf(\n334             expr, prec, options)\n335     else:\n336         prec = assumed_size\n337 \n338     # We can now easily find the nearest integer, but to find floor/ceil, we\n339     # must also calculate whether the difference to the nearest integer is\n340     # positive or negative (which may fail if very close).\n341     def calc_part(re_im, nexpr):\n342         from sympy.core.add import Add\n343         n, c, p, b = nexpr\n344         is_int = (p == 0)\n345         nint = int(to_int(nexpr, rnd))\n346         if is_int:\n347             # make sure that we had enough precision to distinguish\n348             # between nint and the re or im part (re_im) of expr that\n349             # was passed to calc_part\n350             ire, iim, ire_acc, iim_acc = evalf(\n351                 re_im - nint, 10, options)  # don't need much precision\n352             assert not iim\n353             size = -fastlog(ire) + 2  # -ve b/c ire is less than 1\n354             if size > prec:\n355                 ire, iim, ire_acc, iim_acc = evalf(\n356                     re_im, size, options)\n357                 assert not iim\n358                 nexpr = ire\n359                 n, c, p, b = nexpr\n360                 is_int = (p == 0)\n361                 nint = int(to_int(nexpr, rnd))\n362         if not is_int:\n363             # if there are subs and they all contain integer re/im parts\n364             # then we can (hopefully) safely substitute them into the\n365             # expression\n366             s = options.get('subs', False)\n367             if s:\n368                 doit = True\n369                 from sympy.core.compatibility import as_int\n370                 # use strict=False with as_int because we take\n371                 # 2.0 == 2\n372                 for v in s.values():\n373                     try:\n374                         as_int(v, strict=False)\n375                     except ValueError:\n376                         try:\n377                             [as_int(i, strict=False) for i in v.as_real_imag()]\n378                             continue\n379                         except (ValueError, AttributeError):\n380                             doit = False\n381                             break\n382                 if doit:\n383                     re_im = re_im.subs(s)\n384 \n385             re_im = Add(re_im, -nint, evaluate=False)\n386             x, _, x_acc, _ = evalf(re_im, 10, options)\n387             try:\n388                 check_target(re_im, (x, None, x_acc, None), 3)\n389             except PrecisionExhausted:\n390                 if not re_im.equals(0):\n391                     raise PrecisionExhausted\n392                 x = fzero\n393             nint += int(no*(mpf_cmp(x or fzero, fzero) == no))\n394         nint = from_int(nint)\n395         return nint, INF\n396 \n397     re_, im_, re_acc, im_acc = None, None, None, None\n398 \n399     if ire:\n400         re_, re_acc = calc_part(re(expr, evaluate=False), ire)\n401     if iim:\n402         im_, im_acc = calc_part(im(expr, evaluate=False), iim)\n403 \n404     if return_ints:\n405         return int(to_int(re_ or fzero)), int(to_int(im_ or fzero))\n406     return re_, im_, re_acc, im_acc\n407 \n408 \n409 def evalf_ceiling(expr, prec, options):\n410     return get_integer_part(expr.args[0], 1, options)\n411 \n412 \n413 def evalf_floor(expr, prec, options):\n414     return get_integer_part(expr.args[0], -1, options)\n415 \n416 #----------------------------------------------------------------------------#\n417 #                                                                            #\n418 #                            Arithmetic operations                           #\n419 #                                                                            #\n420 #----------------------------------------------------------------------------#\n421 \n422 \n423 def add_terms(terms, prec, target_prec):\n424     \"\"\"\n425     Helper for evalf_add. Adds a list of (mpfval, accuracy) terms.\n426 \n427     Returns\n428     -------\n429 \n430     - None, None if there are no non-zero terms;\n431     - terms[0] if there is only 1 term;\n432     - scaled_zero if the sum of the terms produces a zero by cancellation\n433       e.g. mpfs representing 1 and -1 would produce a scaled zero which need\n434       special handling since they are not actually zero and they are purposely\n435       malformed to ensure that they can't be used in anything but accuracy\n436       calculations;\n437     - a tuple that is scaled to target_prec that corresponds to the\n438       sum of the terms.\n439 \n440     The returned mpf tuple will be normalized to target_prec; the input\n441     prec is used to define the working precision.\n442 \n443     XXX explain why this is needed and why one can't just loop using mpf_add\n444     \"\"\"\n445 \n446     terms = [t for t in terms if not iszero(t[0])]\n447     if not terms:\n448         return None, None\n449     elif len(terms) == 1:\n450         return terms[0]\n451 \n452     # see if any argument is NaN or oo and thus warrants a special return\n453     special = []\n454     from sympy.core.numbers import Float\n455     for t in terms:\n456         arg = Float._new(t[0], 1)\n457         if arg is S.NaN or arg.is_infinite:\n458             special.append(arg)\n459     if special:\n460         from sympy.core.add import Add\n461         rv = evalf(Add(*special), prec + 4, {})\n462         return rv[0], rv[2]\n463 \n464     working_prec = 2*prec\n465     sum_man, sum_exp, absolute_error = 0, 0, MINUS_INF\n466 \n467     for x, accuracy in terms:\n468         sign, man, exp, bc = x\n469         if sign:\n470             man = -man\n471         absolute_error = max(absolute_error, bc + exp - accuracy)\n472         delta = exp - sum_exp\n473         if exp >= sum_exp:\n474             # x much larger than existing sum?\n475             # first: quick test\n476             if ((delta > working_prec) and\n477                 ((not sum_man) or\n478                  delta - bitcount(abs(sum_man)) > working_prec)):\n479                 sum_man = man\n480                 sum_exp = exp\n481             else:\n482                 sum_man += (man << delta)\n483         else:\n484             delta = -delta\n485             # x much smaller than existing sum?\n486             if delta - bc > working_prec:\n487                 if not sum_man:\n488                     sum_man, sum_exp = man, exp\n489             else:\n490                 sum_man = (sum_man << delta) + man\n491                 sum_exp = exp\n492     if not sum_man:\n493         return scaled_zero(absolute_error)\n494     if sum_man < 0:\n495         sum_sign = 1\n496         sum_man = -sum_man\n497     else:\n498         sum_sign = 0\n499     sum_bc = bitcount(sum_man)\n500     sum_accuracy = sum_exp + sum_bc - absolute_error\n501     r = normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec,\n502         rnd), sum_accuracy\n503     return r\n504 \n505 \n506 def evalf_add(v, prec, options):\n507     res = pure_complex(v)\n508     if res:\n509         h, c = res\n510         re, _, re_acc, _ = evalf(h, prec, options)\n511         im, _, im_acc, _ = evalf(c, prec, options)\n512         return re, im, re_acc, im_acc\n513 \n514     oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n515 \n516     i = 0\n517     target_prec = prec\n518     while 1:\n519         options['maxprec'] = min(oldmaxprec, 2*prec)\n520 \n521         terms = [evalf(arg, prec + 10, options) for arg in v.args]\n522         re, re_acc = add_terms(\n523             [a[0::2] for a in terms if a[0]], prec, target_prec)\n524         im, im_acc = add_terms(\n525             [a[1::2] for a in terms if a[1]], prec, target_prec)\n526         acc = complex_accuracy((re, im, re_acc, im_acc))\n527         if acc >= target_prec:\n528             if options.get('verbose'):\n529                 print(\"ADD: wanted\", target_prec, \"accurate bits, got\", re_acc, im_acc)\n530             break\n531         else:\n532             if (prec - target_prec) > options['maxprec']:\n533                 break\n534 \n535             prec = prec + max(10 + 2**i, target_prec - acc)\n536             i += 1\n537             if options.get('verbose'):\n538                 print(\"ADD: restarting with prec\", prec)\n539 \n540     options['maxprec'] = oldmaxprec\n541     if iszero(re, scaled=True):\n542         re = scaled_zero(re)\n543     if iszero(im, scaled=True):\n544         im = scaled_zero(im)\n545     return re, im, re_acc, im_acc\n546 \n547 \n548 def evalf_mul(v, prec, options):\n549     res = pure_complex(v)\n550     if res:\n551         # the only pure complex that is a mul is h*I\n552         _, h = res\n553         im, _, im_acc, _ = evalf(h, prec, options)\n554         return None, im, None, im_acc\n555     args = list(v.args)\n556 \n557     # see if any argument is NaN or oo and thus warrants a special return\n558     special = []\n559     from sympy.core.numbers import Float\n560     for arg in args:\n561         arg = evalf(arg, prec, options)\n562         if arg[0] is None:\n563             continue\n564         arg = Float._new(arg[0], 1)\n565         if arg is S.NaN or arg.is_infinite:\n566             special.append(arg)\n567     if special:\n568         from sympy.core.mul import Mul\n569         special = Mul(*special)\n570         return evalf(special, prec + 4, {})\n571 \n572     # With guard digits, multiplication in the real case does not destroy\n573     # accuracy. This is also true in the complex case when considering the\n574     # total accuracy; however accuracy for the real or imaginary parts\n575     # separately may be lower.\n576     acc = prec\n577 \n578     # XXX: big overestimate\n579     working_prec = prec + len(args) + 5\n580 \n581     # Empty product is 1\n582     start = man, exp, bc = MPZ(1), 0, 1\n583 \n584     # First, we multiply all pure real or pure imaginary numbers.\n585     # direction tells us that the result should be multiplied by\n586     # I**direction; all other numbers get put into complex_factors\n587     # to be multiplied out after the first phase.\n588     last = len(args)\n589     direction = 0\n590     args.append(S.One)\n591     complex_factors = []\n592 \n593     for i, arg in enumerate(args):\n594         if i != last and pure_complex(arg):\n595             args[-1] = (args[-1]*arg).expand()\n596             continue\n597         elif i == last and arg is S.One:\n598             continue\n599         re, im, re_acc, im_acc = evalf(arg, working_prec, options)\n600         if re and im:\n601             complex_factors.append((re, im, re_acc, im_acc))\n602             continue\n603         elif re:\n604             (s, m, e, b), w_acc = re, re_acc\n605         elif im:\n606             (s, m, e, b), w_acc = im, im_acc\n607             direction += 1\n608         else:\n609             return None, None, None, None\n610         direction += 2*s\n611         man *= m\n612         exp += e\n613         bc += b\n614         if bc > 3*working_prec:\n615             man >>= working_prec\n616             exp += working_prec\n617         acc = min(acc, w_acc)\n618     sign = (direction & 2) >> 1\n619     if not complex_factors:\n620         v = normalize(sign, man, exp, bitcount(man), prec, rnd)\n621         # multiply by i\n622         if direction & 1:\n623             return None, v, None, acc\n624         else:\n625             return v, None, acc, None\n626     else:\n627         # initialize with the first term\n628         if (man, exp, bc) != start:\n629             # there was a real part; give it an imaginary part\n630             re, im = (sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0)\n631             i0 = 0\n632         else:\n633             # there is no real part to start (other than the starting 1)\n634             wre, wim, wre_acc, wim_acc = complex_factors[0]\n635             acc = min(acc,\n636                       complex_accuracy((wre, wim, wre_acc, wim_acc)))\n637             re = wre\n638             im = wim\n639             i0 = 1\n640 \n641         for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:\n642             # acc is the overall accuracy of the product; we aren't\n643             # computing exact accuracies of the product.\n644             acc = min(acc,\n645                       complex_accuracy((wre, wim, wre_acc, wim_acc)))\n646 \n647             use_prec = working_prec\n648             A = mpf_mul(re, wre, use_prec)\n649             B = mpf_mul(mpf_neg(im), wim, use_prec)\n650             C = mpf_mul(re, wim, use_prec)\n651             D = mpf_mul(im, wre, use_prec)\n652             re = mpf_add(A, B, use_prec)\n653             im = mpf_add(C, D, use_prec)\n654         if options.get('verbose'):\n655             print(\"MUL: wanted\", prec, \"accurate bits, got\", acc)\n656         # multiply by I\n657         if direction & 1:\n658             re, im = mpf_neg(im), re\n659         return re, im, acc, acc\n660 \n661 \n662 def evalf_pow(v, prec, options):\n663 \n664     target_prec = prec\n665     base, exp = v.args\n666 \n667     # We handle x**n separately. This has two purposes: 1) it is much\n668     # faster, because we avoid calling evalf on the exponent, and 2) it\n669     # allows better handling of real/imaginary parts that are exactly zero\n670     if exp.is_Integer:\n671         p = exp.p\n672         # Exact\n673         if not p:\n674             return fone, None, prec, None\n675         # Exponentiation by p magnifies relative error by |p|, so the\n676         # base must be evaluated with increased precision if p is large\n677         prec += int(math.log(abs(p), 2))\n678         re, im, re_acc, im_acc = evalf(base, prec + 5, options)\n679         # Real to integer power\n680         if re and not im:\n681             return mpf_pow_int(re, p, target_prec), None, target_prec, None\n682         # (x*I)**n = I**n * x**n\n683         if im and not re:\n684             z = mpf_pow_int(im, p, target_prec)\n685             case = p % 4\n686             if case == 0:\n687                 return z, None, target_prec, None\n688             if case == 1:\n689                 return None, z, None, target_prec\n690             if case == 2:\n691                 return mpf_neg(z), None, target_prec, None\n692             if case == 3:\n693                 return None, mpf_neg(z), None, target_prec\n694         # Zero raised to an integer power\n695         if not re:\n696             return None, None, None, None\n697         # General complex number to arbitrary integer power\n698         re, im = libmp.mpc_pow_int((re, im), p, prec)\n699         # Assumes full accuracy in input\n700         return finalize_complex(re, im, target_prec)\n701 \n702     # Pure square root\n703     if exp is S.Half:\n704         xre, xim, _, _ = evalf(base, prec + 5, options)\n705         # General complex square root\n706         if xim:\n707             re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)\n708             return finalize_complex(re, im, prec)\n709         if not xre:\n710             return None, None, None, None\n711         # Square root of a negative real number\n712         if mpf_lt(xre, fzero):\n713             return None, mpf_sqrt(mpf_neg(xre), prec), None, prec\n714         # Positive square root\n715         return mpf_sqrt(xre, prec), None, prec, None\n716 \n717     # We first evaluate the exponent to find its magnitude\n718     # This determines the working precision that must be used\n719     prec += 10\n720     yre, yim, _, _ = evalf(exp, prec, options)\n721     # Special cases: x**0\n722     if not (yre or yim):\n723         return fone, None, prec, None\n724 \n725     ysize = fastlog(yre)\n726     # Restart if too big\n727     # XXX: prec + ysize might exceed maxprec\n728     if ysize > 5:\n729         prec += ysize\n730         yre, yim, _, _ = evalf(exp, prec, options)\n731 \n732     # Pure exponential function; no need to evalf the base\n733     if base is S.Exp1:\n734         if yim:\n735             re, im = libmp.mpc_exp((yre or fzero, yim), prec)\n736             return finalize_complex(re, im, target_prec)\n737         return mpf_exp(yre, target_prec), None, target_prec, None\n738 \n739     xre, xim, _, _ = evalf(base, prec + 5, options)\n740     # 0**y\n741     if not (xre or xim):\n742         return None, None, None, None\n743 \n744     # (real ** complex) or (complex ** complex)\n745     if yim:\n746         re, im = libmp.mpc_pow(\n747             (xre or fzero, xim or fzero), (yre or fzero, yim),\n748             target_prec)\n749         return finalize_complex(re, im, target_prec)\n750     # complex ** real\n751     if xim:\n752         re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)\n753         return finalize_complex(re, im, target_prec)\n754     # negative ** real\n755     elif mpf_lt(xre, fzero):\n756         re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)\n757         return finalize_complex(re, im, target_prec)\n758     # positive ** real\n759     else:\n760         return mpf_pow(xre, yre, target_prec), None, target_prec, None\n761 \n762 \n763 #----------------------------------------------------------------------------#\n764 #                                                                            #\n765 #                            Special functions                               #\n766 #                                                                            #\n767 #----------------------------------------------------------------------------#\n768 def evalf_trig(v, prec, options):\n769     \"\"\"\n770     This function handles sin and cos of complex arguments.\n771 \n772     TODO: should also handle tan of complex arguments.\n773     \"\"\"\n774     from sympy import cos, sin\n775     if isinstance(v, cos):\n776         func = mpf_cos\n777     elif isinstance(v, sin):\n778         func = mpf_sin\n779     else:\n780         raise NotImplementedError\n781     arg = v.args[0]\n782     # 20 extra bits is possibly overkill. It does make the need\n783     # to restart very unlikely\n784     xprec = prec + 20\n785     re, im, re_acc, im_acc = evalf(arg, xprec, options)\n786     if im:\n787         if 'subs' in options:\n788             v = v.subs(options['subs'])\n789         return evalf(v._eval_evalf(prec), prec, options)\n790     if not re:\n791         if isinstance(v, cos):\n792             return fone, None, prec, None\n793         elif isinstance(v, sin):\n794             return None, None, None, None\n795         else:\n796             raise NotImplementedError\n797     # For trigonometric functions, we are interested in the\n798     # fixed-point (absolute) accuracy of the argument.\n799     xsize = fastlog(re)\n800     # Magnitude <= 1.0. OK to compute directly, because there is no\n801     # danger of hitting the first root of cos (with sin, magnitude\n802     # <= 2.0 would actually be ok)\n803     if xsize < 1:\n804         return func(re, prec, rnd), None, prec, None\n805     # Very large\n806     if xsize >= 10:\n807         xprec = prec + xsize\n808         re, im, re_acc, im_acc = evalf(arg, xprec, options)\n809     # Need to repeat in case the argument is very close to a\n810     # multiple of pi (or pi/2), hitting close to a root\n811     while 1:\n812         y = func(re, prec, rnd)\n813         ysize = fastlog(y)\n814         gap = -ysize\n815         accuracy = (xprec - xsize) - gap\n816         if accuracy < prec:\n817             if options.get('verbose'):\n818                 print(\"SIN/COS\", accuracy, \"wanted\", prec, \"gap\", gap)\n819                 print(to_str(y, 10))\n820             if xprec > options.get('maxprec', DEFAULT_MAXPREC):\n821                 return y, None, accuracy, None\n822             xprec += gap\n823             re, im, re_acc, im_acc = evalf(arg, xprec, options)\n824             continue\n825         else:\n826             return y, None, prec, None\n827 \n828 \n829 def evalf_log(expr, prec, options):\n830     from sympy import Abs, Add, log\n831     if len(expr.args)>1:\n832         expr = expr.doit()\n833         return evalf(expr, prec, options)\n834     arg = expr.args[0]\n835     workprec = prec + 10\n836     xre, xim, xacc, _ = evalf(arg, workprec, options)\n837 \n838     if xim:\n839         # XXX: use get_abs etc instead\n840         re = evalf_log(\n841             log(Abs(arg, evaluate=False), evaluate=False), prec, options)\n842         im = mpf_atan2(xim, xre or fzero, prec)\n843         return re[0], im, re[2], prec\n844 \n845     imaginary_term = (mpf_cmp(xre, fzero) < 0)\n846 \n847     re = mpf_log(mpf_abs(xre), prec, rnd)\n848     size = fastlog(re)\n849     if prec - size > workprec and re != fzero:\n850         # We actually need to compute 1+x accurately, not x\n851         arg = Add(S.NegativeOne, arg, evaluate=False)\n852         xre, xim, _, _ = evalf_add(arg, prec, options)\n853         prec2 = workprec - fastlog(xre)\n854         # xre is now x - 1 so we add 1 back here to calculate x\n855         re = mpf_log(mpf_abs(mpf_add(xre, fone, prec2)), prec, rnd)\n856 \n857     re_acc = prec\n858 \n859     if imaginary_term:\n860         return re, mpf_pi(prec), re_acc, prec\n861     else:\n862         return re, None, re_acc, None\n863 \n864 \n865 def evalf_atan(v, prec, options):\n866     arg = v.args[0]\n867     xre, xim, reacc, imacc = evalf(arg, prec + 5, options)\n868     if xre is xim is None:\n869         return (None,)*4\n870     if xim:\n871         raise NotImplementedError\n872     return mpf_atan(xre, prec, rnd), None, prec, None\n873 \n874 \n875 def evalf_subs(prec, subs):\n876     \"\"\" Change all Float entries in `subs` to have precision prec. \"\"\"\n877     newsubs = {}\n878     for a, b in subs.items():\n879         b = S(b)\n880         if b.is_Float:\n881             b = b._eval_evalf(prec)\n882         newsubs[a] = b\n883     return newsubs\n884 \n885 \n886 def evalf_piecewise(expr, prec, options):\n887     from sympy import Float, Integer\n888     if 'subs' in options:\n889         expr = expr.subs(evalf_subs(prec, options['subs']))\n890         newopts = options.copy()\n891         del newopts['subs']\n892         if hasattr(expr, 'func'):\n893             return evalf(expr, prec, newopts)\n894         if type(expr) == float:\n895             return evalf(Float(expr), prec, newopts)\n896         if type(expr) == int:\n897             return evalf(Integer(expr), prec, newopts)\n898 \n899     # We still have undefined symbols\n900     raise NotImplementedError\n901 \n902 \n903 def evalf_bernoulli(expr, prec, options):\n904     arg = expr.args[0]\n905     if not arg.is_Integer:\n906         raise ValueError(\"Bernoulli number index must be an integer\")\n907     n = int(arg)\n908     b = mpf_bernoulli(n, prec, rnd)\n909     if b == fzero:\n910         return None, None, None, None\n911     return b, None, prec, None\n912 \n913 #----------------------------------------------------------------------------#\n914 #                                                                            #\n915 #                            High-level operations                           #\n916 #                                                                            #\n917 #----------------------------------------------------------------------------#\n918 \n919 \n920 def as_mpmath(x, prec, options):\n921     from sympy.core.numbers import Infinity, NegativeInfinity, Zero\n922     x = sympify(x)\n923     if isinstance(x, Zero) or x == 0:\n924         return mpf(0)\n925     if isinstance(x, Infinity):\n926         return mpf('inf')\n927     if isinstance(x, NegativeInfinity):\n928         return mpf('-inf')\n929     # XXX\n930     re, im, _, _ = evalf(x, prec, options)\n931     if im:\n932         return mpc(re or fzero, im)\n933     return mpf(re)\n934 \n935 \n936 def do_integral(expr, prec, options):\n937     func = expr.args[0]\n938     x, xlow, xhigh = expr.args[1]\n939     if xlow == xhigh:\n940         xlow = xhigh = 0\n941     elif x not in func.free_symbols:\n942         # only the difference in limits matters in this case\n943         # so if there is a symbol in common that will cancel\n944         # out when taking the difference, then use that\n945         # difference\n946         if xhigh.free_symbols & xlow.free_symbols:\n947             diff = xhigh - xlow\n948             if diff.is_number:\n949                 xlow, xhigh = 0, diff\n950 \n951     oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n952     options['maxprec'] = min(oldmaxprec, 2*prec)\n953 \n954     with workprec(prec + 5):\n955         xlow = as_mpmath(xlow, prec + 15, options)\n956         xhigh = as_mpmath(xhigh, prec + 15, options)\n957 \n958         # Integration is like summation, and we can phone home from\n959         # the integrand function to update accuracy summation style\n960         # Note that this accuracy is inaccurate, since it fails\n961         # to account for the variable quadrature weights,\n962         # but it is better than nothing\n963 \n964         from sympy import cos, sin, Wild\n965 \n966         have_part = [False, False]\n967         max_real_term = [MINUS_INF]\n968         max_imag_term = [MINUS_INF]\n969 \n970         def f(t):\n971             re, im, re_acc, im_acc = evalf(func, mp.prec, {'subs': {x: t}})\n972 \n973             have_part[0] = re or have_part[0]\n974             have_part[1] = im or have_part[1]\n975 \n976             max_real_term[0] = max(max_real_term[0], fastlog(re))\n977             max_imag_term[0] = max(max_imag_term[0], fastlog(im))\n978 \n979             if im:\n980                 return mpc(re or fzero, im)\n981             return mpf(re or fzero)\n982 \n983         if options.get('quad') == 'osc':\n984             A = Wild('A', exclude=[x])\n985             B = Wild('B', exclude=[x])\n986             D = Wild('D')\n987             m = func.match(cos(A*x + B)*D)\n988             if not m:\n989                 m = func.match(sin(A*x + B)*D)\n990             if not m:\n991                 raise ValueError(\"An integrand of the form sin(A*x+B)*f(x) \"\n992                   \"or cos(A*x+B)*f(x) is required for oscillatory quadrature\")\n993             period = as_mpmath(2*S.Pi/m[A], prec + 15, options)\n994             result = quadosc(f, [xlow, xhigh], period=period)\n995             # XXX: quadosc does not do error detection yet\n996             quadrature_error = MINUS_INF\n997         else:\n998             result, quadrature_error = quadts(f, [xlow, xhigh], error=1)\n999             quadrature_error = fastlog(quadrature_error._mpf_)\n1000 \n1001     options['maxprec'] = oldmaxprec\n1002 \n1003     if have_part[0]:\n1004         re = result.real._mpf_\n1005         if re == fzero:\n1006             re, re_acc = scaled_zero(\n1007                 min(-prec, -max_real_term[0], -quadrature_error))\n1008             re = scaled_zero(re)  # handled ok in evalf_integral\n1009         else:\n1010             re_acc = -max(max_real_term[0] - fastlog(re) -\n1011                           prec, quadrature_error)\n1012     else:\n1013         re, re_acc = None, None\n1014 \n1015     if have_part[1]:\n1016         im = result.imag._mpf_\n1017         if im == fzero:\n1018             im, im_acc = scaled_zero(\n1019                 min(-prec, -max_imag_term[0], -quadrature_error))\n1020             im = scaled_zero(im)  # handled ok in evalf_integral\n1021         else:\n1022             im_acc = -max(max_imag_term[0] - fastlog(im) -\n1023                           prec, quadrature_error)\n1024     else:\n1025         im, im_acc = None, None\n1026 \n1027     result = re, im, re_acc, im_acc\n1028     return result\n1029 \n1030 \n1031 def evalf_integral(expr, prec, options):\n1032     limits = expr.limits\n1033     if len(limits) != 1 or len(limits[0]) != 3:\n1034         raise NotImplementedError\n1035     workprec = prec\n1036     i = 0\n1037     maxprec = options.get('maxprec', INF)\n1038     while 1:\n1039         result = do_integral(expr, workprec, options)\n1040         accuracy = complex_accuracy(result)\n1041         if accuracy >= prec:  # achieved desired precision\n1042             break\n1043         if workprec >= maxprec:  # can't increase accuracy any more\n1044             break\n1045         if accuracy == -1:\n1046             # maybe the answer really is zero and maybe we just haven't increased\n1047             # the precision enough. So increase by doubling to not take too long\n1048             # to get to maxprec.\n1049             workprec *= 2\n1050         else:\n1051             workprec += max(prec, 2**i)\n1052         workprec = min(workprec, maxprec)\n1053         i += 1\n1054     return result\n1055 \n1056 \n1057 def check_convergence(numer, denom, n):\n1058     \"\"\"\n1059     Returns (h, g, p) where\n1060     -- h is:\n1061         > 0 for convergence of rate 1/factorial(n)**h\n1062         < 0 for divergence of rate factorial(n)**(-h)\n1063         = 0 for geometric or polynomial convergence or divergence\n1064 \n1065     -- abs(g) is:\n1066         > 1 for geometric convergence of rate 1/h**n\n1067         < 1 for geometric divergence of rate h**n\n1068         = 1 for polynomial convergence or divergence\n1069 \n1070         (g < 0 indicates an alternating series)\n1071 \n1072     -- p is:\n1073         > 1 for polynomial convergence of rate 1/n**h\n1074         <= 1 for polynomial divergence of rate n**(-h)\n1075 \n1076     \"\"\"\n1077     from sympy import Poly\n1078     npol = Poly(numer, n)\n1079     dpol = Poly(denom, n)\n1080     p = npol.degree()\n1081     q = dpol.degree()\n1082     rate = q - p\n1083     if rate:\n1084         return rate, None, None\n1085     constant = dpol.LC() / npol.LC()\n1086     if abs(constant) != 1:\n1087         return rate, constant, None\n1088     if npol.degree() == dpol.degree() == 0:\n1089         return rate, constant, 0\n1090     pc = npol.all_coeffs()[1]\n1091     qc = dpol.all_coeffs()[1]\n1092     return rate, constant, (qc - pc)/dpol.LC()\n1093 \n1094 \n1095 def hypsum(expr, n, start, prec):\n1096     \"\"\"\n1097     Sum a rapidly convergent infinite hypergeometric series with\n1098     given general term, e.g. e = hypsum(1/factorial(n), n). The\n1099     quotient between successive terms must be a quotient of integer\n1100     polynomials.\n1101     \"\"\"\n1102     from sympy import Float, hypersimp, lambdify\n1103 \n1104     if prec == float('inf'):\n1105         raise NotImplementedError('does not support inf prec')\n1106 \n1107     if start:\n1108         expr = expr.subs(n, n + start)\n1109     hs = hypersimp(expr, n)\n1110     if hs is None:\n1111         raise NotImplementedError(\"a hypergeometric series is required\")\n1112     num, den = hs.as_numer_denom()\n1113 \n1114     func1 = lambdify(n, num)\n1115     func2 = lambdify(n, den)\n1116 \n1117     h, g, p = check_convergence(num, den, n)\n1118 \n1119     if h < 0:\n1120         raise ValueError(\"Sum diverges like (n!)^%i\" % (-h))\n1121 \n1122     term = expr.subs(n, 0)\n1123     if not term.is_Rational:\n1124         raise NotImplementedError(\"Non rational term functionality is not implemented.\")\n1125 \n1126     # Direct summation if geometric or faster\n1127     if h > 0 or (h == 0 and abs(g) > 1):\n1128         term = (MPZ(term.p) << prec) // term.q\n1129         s = term\n1130         k = 1\n1131         while abs(term) > 5:\n1132             term *= MPZ(func1(k - 1))\n1133             term //= MPZ(func2(k - 1))\n1134             s += term\n1135             k += 1\n1136         return from_man_exp(s, -prec)\n1137     else:\n1138         alt = g < 0\n1139         if abs(g) < 1:\n1140             raise ValueError(\"Sum diverges like (%i)^n\" % abs(1/g))\n1141         if p < 1 or (p == 1 and not alt):\n1142             raise ValueError(\"Sum diverges like n^%i\" % (-p))\n1143         # We have polynomial convergence: use Richardson extrapolation\n1144         vold = None\n1145         ndig = prec_to_dps(prec)\n1146         while True:\n1147             # Need to use at least quad precision because a lot of cancellation\n1148             # might occur in the extrapolation process; we check the answer to\n1149             # make sure that the desired precision has been reached, too.\n1150             prec2 = 4*prec\n1151             term0 = (MPZ(term.p) << prec2) // term.q\n1152 \n1153             def summand(k, _term=[term0]):\n1154                 if k:\n1155                     k = int(k)\n1156                     _term[0] *= MPZ(func1(k - 1))\n1157                     _term[0] //= MPZ(func2(k - 1))\n1158                 return make_mpf(from_man_exp(_term[0], -prec2))\n1159 \n1160             with workprec(prec):\n1161                 v = nsum(summand, [0, mpmath_inf], method='richardson')\n1162             vf = Float(v, ndig)\n1163             if vold is not None and vold == vf:\n1164                 break\n1165             prec += prec  # double precision each time\n1166             vold = vf\n1167 \n1168         return v._mpf_\n1169 \n1170 \n1171 def evalf_prod(expr, prec, options):\n1172     from sympy import Sum\n1173     if all((l[1] - l[2]).is_Integer for l in expr.limits):\n1174         re, im, re_acc, im_acc = evalf(expr.doit(), prec=prec, options=options)\n1175     else:\n1176         re, im, re_acc, im_acc = evalf(expr.rewrite(Sum), prec=prec, options=options)\n1177     return re, im, re_acc, im_acc\n1178 \n1179 \n1180 def evalf_sum(expr, prec, options):\n1181     from sympy import Float\n1182     if 'subs' in options:\n1183         expr = expr.subs(options['subs'])\n1184     func = expr.function\n1185     limits = expr.limits\n1186     if len(limits) != 1 or len(limits[0]) != 3:\n1187         raise NotImplementedError\n1188     if func is S.Zero:\n1189         return None, None, prec, None\n1190     prec2 = prec + 10\n1191     try:\n1192         n, a, b = limits[0]\n1193         if b != S.Infinity or a != int(a):\n1194             raise NotImplementedError\n1195         # Use fast hypergeometric summation if possible\n1196         v = hypsum(func, n, int(a), prec2)\n1197         delta = prec - fastlog(v)\n1198         if fastlog(v) < -10:\n1199             v = hypsum(func, n, int(a), delta)\n1200         return v, None, min(prec, delta), None\n1201     except NotImplementedError:\n1202         # Euler-Maclaurin summation for general series\n1203         eps = Float(2.0)**(-prec)\n1204         for i in range(1, 5):\n1205             m = n = 2**i * prec\n1206             s, err = expr.euler_maclaurin(m=m, n=n, eps=eps,\n1207                 eval_integral=False)\n1208             err = err.evalf()\n1209             if err <= eps:\n1210                 break\n1211         err = fastlog(evalf(abs(err), 20, options)[0])\n1212         re, im, re_acc, im_acc = evalf(s, prec2, options)\n1213         if re_acc is None:\n1214             re_acc = -err\n1215         if im_acc is None:\n1216             im_acc = -err\n1217         return re, im, re_acc, im_acc\n1218 \n1219 \n1220 #----------------------------------------------------------------------------#\n1221 #                                                                            #\n1222 #                            Symbolic interface                              #\n1223 #                                                                            #\n1224 #----------------------------------------------------------------------------#\n1225 \n1226 def evalf_symbol(x, prec, options):\n1227     val = options['subs'][x]\n1228     if isinstance(val, mpf):\n1229         if not val:\n1230             return None, None, None, None\n1231         return val._mpf_, None, prec, None\n1232     else:\n1233         if not '_cache' in options:\n1234             options['_cache'] = {}\n1235         cache = options['_cache']\n1236         cached, cached_prec = cache.get(x, (None, MINUS_INF))\n1237         if cached_prec >= prec:\n1238             return cached\n1239         v = evalf(sympify(val), prec, options)\n1240         cache[x] = (v, prec)\n1241         return v\n1242 \n1243 evalf_table = None\n1244 \n1245 \n1246 def _create_evalf_table():\n1247     global evalf_table\n1248     from sympy.functions.combinatorial.numbers import bernoulli\n1249     from sympy.concrete.products import Product\n1250     from sympy.concrete.summations import Sum\n1251     from sympy.core.add import Add\n1252     from sympy.core.mul import Mul\n1253     from sympy.core.numbers import Exp1, Float, Half, ImaginaryUnit, Integer, NaN, NegativeOne, One, Pi, Rational, Zero\n1254     from sympy.core.power import Pow\n1255     from sympy.core.symbol import Dummy, Symbol\n1256     from sympy.functions.elementary.complexes import Abs, im, re\n1257     from sympy.functions.elementary.exponential import exp, log\n1258     from sympy.functions.elementary.integers import ceiling, floor\n1259     from sympy.functions.elementary.piecewise import Piecewise\n1260     from sympy.functions.elementary.trigonometric import atan, cos, sin\n1261     from sympy.integrals.integrals import Integral\n1262     evalf_table = {\n1263         Symbol: evalf_symbol,\n1264         Dummy: evalf_symbol,\n1265         Float: lambda x, prec, options: (x._mpf_, None, prec, None),\n1266         Rational: lambda x, prec, options: (from_rational(x.p, x.q, prec), None, prec, None),\n1267         Integer: lambda x, prec, options: (from_int(x.p, prec), None, prec, None),\n1268         Zero: lambda x, prec, options: (None, None, prec, None),\n1269         One: lambda x, prec, options: (fone, None, prec, None),\n1270         Half: lambda x, prec, options: (fhalf, None, prec, None),\n1271         Pi: lambda x, prec, options: (mpf_pi(prec), None, prec, None),\n1272         Exp1: lambda x, prec, options: (mpf_e(prec), None, prec, None),\n1273         ImaginaryUnit: lambda x, prec, options: (None, fone, None, prec),\n1274         NegativeOne: lambda x, prec, options: (fnone, None, prec, None),\n1275         NaN: lambda x, prec, options: (fnan, None, prec, None),\n1276 \n1277         exp: lambda x, prec, options: evalf_pow(\n1278             Pow(S.Exp1, x.args[0], evaluate=False), prec, options),\n1279 \n1280         cos: evalf_trig,\n1281         sin: evalf_trig,\n1282 \n1283         Add: evalf_add,\n1284         Mul: evalf_mul,\n1285         Pow: evalf_pow,\n1286 \n1287         log: evalf_log,\n1288         atan: evalf_atan,\n1289         Abs: evalf_abs,\n1290 \n1291         re: evalf_re,\n1292         im: evalf_im,\n1293         floor: evalf_floor,\n1294         ceiling: evalf_ceiling,\n1295 \n1296         Integral: evalf_integral,\n1297         Sum: evalf_sum,\n1298         Product: evalf_prod,\n1299         Piecewise: evalf_piecewise,\n1300 \n1301         bernoulli: evalf_bernoulli,\n1302     }\n1303 \n1304 \n1305 def evalf(x, prec, options):\n1306     from sympy import re as re_, im as im_\n1307     try:\n1308         rf = evalf_table[x.func]\n1309         r = rf(x, prec, options)\n1310     except KeyError:\n1311         # Fall back to ordinary evalf if possible\n1312         if 'subs' in options:\n1313             x = x.subs(evalf_subs(prec, options['subs']))\n1314         xe = x._eval_evalf(prec)\n1315         if xe is None:\n1316             raise NotImplementedError\n1317         as_real_imag = getattr(xe, \"as_real_imag\", None)\n1318         if as_real_imag is None:\n1319             raise NotImplementedError # e.g. FiniteSet(-1.0, 1.0).evalf()\n1320         re, im = as_real_imag()\n1321         if re.has(re_) or im.has(im_):\n1322             raise NotImplementedError\n1323         if re == 0:\n1324             re = None\n1325             reprec = None\n1326         elif re.is_number:\n1327             re = re._to_mpmath(prec, allow_ints=False)._mpf_\n1328             reprec = prec\n1329         else:\n1330             raise NotImplementedError\n1331         if im == 0:\n1332             im = None\n1333             imprec = None\n1334         elif im.is_number:\n1335             im = im._to_mpmath(prec, allow_ints=False)._mpf_\n1336             imprec = prec\n1337         else:\n1338             raise NotImplementedError\n1339         r = re, im, reprec, imprec\n1340 \n1341     if options.get(\"verbose\"):\n1342         print(\"### input\", x)\n1343         print(\"### output\", to_str(r[0] or fzero, 50))\n1344         print(\"### raw\", r) # r[0], r[2]\n1345         print()\n1346     chop = options.get('chop', False)\n1347     if chop:\n1348         if chop is True:\n1349             chop_prec = prec\n1350         else:\n1351             # convert (approximately) from given tolerance;\n1352             # the formula here will will make 1e-i rounds to 0 for\n1353             # i in the range +/-27 while 2e-i will not be chopped\n1354             chop_prec = int(round(-3.321*math.log10(chop) + 2.5))\n1355             if chop_prec == 3:\n1356                 chop_prec -= 1\n1357         r = chop_parts(r, chop_prec)\n1358     if options.get(\"strict\"):\n1359         check_target(x, r, prec)\n1360     return r\n1361 \n1362 \n1363 class EvalfMixin(object):\n1364     \"\"\"Mixin class adding evalf capabililty.\"\"\"\n1365 \n1366     __slots__ = []\n1367 \n1368     def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n1369         \"\"\"\n1370         Evaluate the given formula to an accuracy of n digits.\n1371         Optional keyword arguments:\n1372 \n1373             subs=<dict>\n1374                 Substitute numerical values for symbols, e.g.\n1375                 subs={x:3, y:1+pi}. The substitutions must be given as a\n1376                 dictionary.\n1377 \n1378             maxn=<integer>\n1379                 Allow a maximum temporary working precision of maxn digits\n1380                 (default=100)\n1381 \n1382             chop=<bool>\n1383                 Replace tiny real or imaginary parts in subresults\n1384                 by exact zeros (default=False)\n1385 \n1386             strict=<bool>\n1387                 Raise PrecisionExhausted if any subresult fails to evaluate\n1388                 to full accuracy, given the available maxprec\n1389                 (default=False)\n1390 \n1391             quad=<str>\n1392                 Choose algorithm for numerical quadrature. By default,\n1393                 tanh-sinh quadrature is used. For oscillatory\n1394                 integrals on an infinite interval, try quad='osc'.\n1395 \n1396             verbose=<bool>\n1397                 Print debug information (default=False)\n1398 \n1399         Notes\n1400         =====\n1401 \n1402         When Floats are naively substituted into an expression, precision errors\n1403         may adversely affect the result. For example, adding 1e16 (a Float) to 1\n1404         will truncate to 1e16; if 1e16 is then subtracted, the result will be 0.\n1405         That is exactly what happens in the following:\n1406 \n1407         >>> from sympy.abc import x, y, z\n1408         >>> values = {x: 1e16, y: 1, z: 1e16}\n1409         >>> (x + y - z).subs(values)\n1410         0\n1411 \n1412         Using the subs argument for evalf is the accurate way to evaluate such an\n1413         expression:\n1414 \n1415         >>> (x + y - z).evalf(subs=values)\n1416         1.00000000000000\n1417         \"\"\"\n1418         from sympy import Float, Number\n1419         n = n if n is not None else 15\n1420 \n1421         if subs and is_sequence(subs):\n1422             raise TypeError('subs must be given as a dictionary')\n1423 \n1424         # for sake of sage that doesn't like evalf(1)\n1425         if n == 1 and isinstance(self, Number):\n1426             from sympy.core.expr import _mag\n1427             rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n1428             m = _mag(rv)\n1429             rv = rv.round(1 - m)\n1430             return rv\n1431 \n1432         if not evalf_table:\n1433             _create_evalf_table()\n1434         prec = dps_to_prec(n)\n1435         options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n1436                'strict': strict, 'verbose': verbose}\n1437         if subs is not None:\n1438             options['subs'] = subs\n1439         if quad is not None:\n1440             options['quad'] = quad\n1441         try:\n1442             result = evalf(self, prec + 4, options)\n1443         except NotImplementedError:\n1444             # Fall back to the ordinary evalf\n1445             v = self._eval_evalf(prec)\n1446             if v is None:\n1447                 return self\n1448             elif not v.is_number:\n1449                 return v\n1450             try:\n1451                 # If the result is numerical, normalize it\n1452                 result = evalf(v, prec, options)\n1453             except NotImplementedError:\n1454                 # Probably contains symbols or unknown functions\n1455                 return v\n1456         re, im, re_acc, im_acc = result\n1457         if re:\n1458             p = max(min(prec, re_acc), 1)\n1459             re = Float._new(re, p)\n1460         else:\n1461             re = S.Zero\n1462         if im:\n1463             p = max(min(prec, im_acc), 1)\n1464             im = Float._new(im, p)\n1465             return re + im*S.ImaginaryUnit\n1466         else:\n1467             return re\n1468 \n1469     n = evalf\n1470 \n1471     def _evalf(self, prec):\n1472         \"\"\"Helper for evalf. Does the same thing but takes binary precision\"\"\"\n1473         r = self._eval_evalf(prec)\n1474         if r is None:\n1475             r = self\n1476         return r\n1477 \n1478     def _eval_evalf(self, prec):\n1479         return\n1480 \n1481     def _to_mpmath(self, prec, allow_ints=True):\n1482         # mpmath functions accept ints as input\n1483         errmsg = \"cannot convert to mpmath number\"\n1484         if allow_ints and self.is_Integer:\n1485             return self.p\n1486         if hasattr(self, '_as_mpf_val'):\n1487             return make_mpf(self._as_mpf_val(prec))\n1488         try:\n1489             re, im, _, _ = evalf(self, prec, {})\n1490             if im:\n1491                 if not re:\n1492                     re = fzero\n1493                 return make_mpc((re, im))\n1494             elif re:\n1495                 return make_mpf(re)\n1496             else:\n1497                 return make_mpf(fzero)\n1498         except NotImplementedError:\n1499             v = self._eval_evalf(prec)\n1500             if v is None:\n1501                 raise ValueError(errmsg)\n1502             if v.is_Float:\n1503                 return make_mpf(v._mpf_)\n1504             # Number + Number*I is also fine\n1505             re, im = v.as_real_imag()\n1506             if allow_ints and re.is_Integer:\n1507                 re = from_int(re.p)\n1508             elif re.is_Float:\n1509                 re = re._mpf_\n1510             else:\n1511                 raise ValueError(errmsg)\n1512             if allow_ints and im.is_Integer:\n1513                 im = from_int(im.p)\n1514             elif im.is_Float:\n1515                 im = im._mpf_\n1516             else:\n1517                 raise ValueError(errmsg)\n1518             return make_mpc((re, im))\n1519 \n1520 \n1521 def N(x, n=15, **options):\n1522     r\"\"\"\n1523     Calls x.evalf(n, \\*\\*options).\n1524 \n1525     Both .n() and N() are equivalent to .evalf(); use the one that you like better.\n1526     See also the docstring of .evalf() for information on the options.\n1527 \n1528     Examples\n1529     ========\n1530 \n1531     >>> from sympy import Sum, oo, N\n1532     >>> from sympy.abc import k\n1533     >>> Sum(1/k**k, (k, 1, oo))\n1534     Sum(k**(-k), (k, 1, oo))\n1535     >>> N(_, 4)\n1536     1.291\n1537 \n1538     \"\"\"\n1539     return sympify(x).evalf(n, **options)\n",
        "intended_behavior": "The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result."
    },
    {
        "rel_file_path": "sympy/core/numbers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/numbers.py",
        "start": 1,
        "end": 3861,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import absolute_import, print_function, division\n2 \n3 import numbers\n4 import decimal\n5 import fractions\n6 import math\n7 import re as regex\n8 \n9 from .containers import Tuple\n10 from .sympify import converter, sympify, _sympify, SympifyError, _convert_numpy_types\n11 from .singleton import S, Singleton\n12 from .expr import Expr, AtomicExpr\n13 from .decorators import _sympifyit\n14 from .cache import cacheit, clear_cache\n15 from .logic import fuzzy_not\n16 from sympy.core.compatibility import (\n17     as_int, integer_types, long, string_types, with_metaclass, HAS_GMPY,\n18     SYMPY_INTS, int_info)\n19 from sympy.core.cache import lru_cache\n20 \n21 import mpmath\n22 import mpmath.libmp as mlib\n23 from mpmath.libmp.backend import MPZ\n24 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed\n25 from mpmath.ctx_mp import mpnumeric\n26 from mpmath.libmp.libmpf import (\n27     finf as _mpf_inf, fninf as _mpf_ninf,\n28     fnan as _mpf_nan, fzero as _mpf_zero, _normalize as mpf_normalize,\n29     prec_to_dps)\n30 from sympy.utilities.misc import debug, filldedent\n31 from .evaluate import global_evaluate\n32 \n33 from sympy.utilities.exceptions import SymPyDeprecationWarning\n34 \n35 rnd = mlib.round_nearest\n36 \n37 _LOG2 = math.log(2)\n38 \n39 \n40 def comp(z1, z2, tol=None):\n41     \"\"\"Return a bool indicating whether the error between z1 and z2 is <= tol.\n42 \n43     If ``tol`` is None then True will be returned if there is a significant\n44     difference between the numbers: ``abs(z1 - z2)*10**p <= 1/2`` where ``p``\n45     is the lower of the precisions of the values. A comparison of strings will\n46     be made if ``z1`` is a Number and a) ``z2`` is a string or b) ``tol`` is ''\n47     and ``z2`` is a Number.\n48 \n49     When ``tol`` is a nonzero value, if z2 is non-zero and ``|z1| > 1``\n50     the error is normalized by ``|z1|``, so if you want to see if the\n51     absolute error between ``z1`` and ``z2`` is <= ``tol`` then call this\n52     as ``comp(z1 - z2, 0, tol)``.\n53     \"\"\"\n54     if type(z2) is str:\n55         if not isinstance(z1, Number):\n56             raise ValueError('when z2 is a str z1 must be a Number')\n57         return str(z1) == z2\n58     if not z1:\n59         z1, z2 = z2, z1\n60     if not z1:\n61         return True\n62     if not tol:\n63         if tol is None:\n64             if type(z2) is str and getattr(z1, 'is_Number', False):\n65                 return str(z1) == z2\n66             a, b = Float(z1), Float(z2)\n67             return int(abs(a - b)*10**prec_to_dps(\n68                 min(a._prec, b._prec)))*2 <= 1\n69         elif all(getattr(i, 'is_Number', False) for i in (z1, z2)):\n70             return z1._prec == z2._prec and str(z1) == str(z2)\n71         raise ValueError('exact comparison requires two Numbers')\n72     diff = abs(z1 - z2)\n73     az1 = abs(z1)\n74     if z2 and az1 > 1:\n75         return diff/az1 <= tol\n76     else:\n77         return diff <= tol\n78 \n79 \n80 def mpf_norm(mpf, prec):\n81     \"\"\"Return the mpf tuple normalized appropriately for the indicated\n82     precision after doing a check to see if zero should be returned or\n83     not when the mantissa is 0. ``mpf_normlize`` always assumes that this\n84     is zero, but it may not be since the mantissa for mpf's values \"+inf\",\n85     \"-inf\" and \"nan\" have a mantissa of zero, too.\n86 \n87     Note: this is not intended to validate a given mpf tuple, so sending\n88     mpf tuples that were not created by mpmath may produce bad results. This\n89     is only a wrapper to ``mpf_normalize`` which provides the check for non-\n90     zero mpfs that have a 0 for the mantissa.\n91     \"\"\"\n92     sign, man, expt, bc = mpf\n93     if not man:\n94         # hack for mpf_normalize which does not do this;\n95         # it assumes that if man is zero the result is 0\n96         # (see issue 6639)\n97         if not bc:\n98             return _mpf_zero\n99         else:\n100             # don't change anything; this should already\n101             # be a well formed mpf tuple\n102             return mpf\n103 \n104     # Necessary if mpmath is using the gmpy backend\n105     from mpmath.libmp.backend import MPZ\n106     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n107     return rv\n108 \n109 # TODO: we should use the warnings module\n110 _errdict = {\"divide\": False}\n111 \n112 \n113 def seterr(divide=False):\n114     \"\"\"\n115     Should sympy raise an exception on 0/0 or return a nan?\n116 \n117     divide == True .... raise an exception\n118     divide == False ... return nan\n119     \"\"\"\n120     if _errdict[\"divide\"] != divide:\n121         clear_cache()\n122         _errdict[\"divide\"] = divide\n123 \n124 \n125 def _as_integer_ratio(p):\n126     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)\n127     p = [1, -1][neg_pow % 2]*man\n128     if expt < 0:\n129         q = 2**-expt\n130     else:\n131         q = 1\n132         p *= 2**expt\n133     return int(p), int(q)\n134 \n135 \n136 def _decimal_to_Rational_prec(dec):\n137     \"\"\"Convert an ordinary decimal instance to a Rational.\"\"\"\n138     if not dec.is_finite():\n139         raise TypeError(\"dec must be finite, got %s.\" % dec)\n140     s, d, e = dec.as_tuple()\n141     prec = len(d)\n142     if e >= 0:  # it's an integer\n143         rv = Integer(int(dec))\n144     else:\n145         s = (-1)**s\n146         d = sum([di*10**i for i, di in enumerate(reversed(d))])\n147         rv = Rational(s*d, 10**-e)\n148     return rv, prec\n149 \n150 \n151 _floatpat = regex.compile(r\"[-+]?((\\d*\\.\\d+)|(\\d+\\.?))\")\n152 def _literal_float(f):\n153     \"\"\"Return True if n starts like a floating point number.\"\"\"\n154     return bool(_floatpat.match(f))\n155 \n156 # (a,b) -> gcd(a,b)\n157 \n158 # TODO caching with decorator, but not to degrade performance\n159 \n160 @lru_cache(1024)\n161 def igcd(*args):\n162     \"\"\"Computes nonnegative integer greatest common divisor.\n163 \n164     The algorithm is based on the well known Euclid's algorithm. To\n165     improve speed, igcd() has its own caching mechanism implemented.\n166 \n167     Examples\n168     ========\n169 \n170     >>> from sympy.core.numbers import igcd\n171     >>> igcd(2, 4)\n172     2\n173     >>> igcd(5, 10, 15)\n174     5\n175 \n176     \"\"\"\n177     if len(args) < 2:\n178         raise TypeError(\n179             'igcd() takes at least 2 arguments (%s given)' % len(args))\n180     args_temp = [abs(as_int(i)) for i in args]\n181     if 1 in args_temp:\n182         return 1\n183     a = args_temp.pop()\n184     for b in args_temp:\n185         a = igcd2(a, b) if b else a\n186     return a\n187 \n188 \n189 try:\n190     from math import gcd as igcd2\n191 except ImportError:\n192     def igcd2(a, b):\n193         \"\"\"Compute gcd of two Python integers a and b.\"\"\"\n194         if (a.bit_length() > BIGBITS and\n195             b.bit_length() > BIGBITS):\n196             return igcd_lehmer(a, b)\n197 \n198         a, b = abs(a), abs(b)\n199         while b:\n200             a, b = b, a % b\n201         return a\n202 \n203 \n204 # Use Lehmer's algorithm only for very large numbers.\n205 # The limit could be different on Python 2.7 and 3.x.\n206 # If so, then this could be defined in compatibility.py.\n207 BIGBITS = 5000\n208 def igcd_lehmer(a, b):\n209     \"\"\"Computes greatest common divisor of two integers.\n210 \n211     Euclid's algorithm for the computation of the greatest\n212     common divisor  gcd(a, b)  of two (positive) integers\n213     a and b is based on the division identity\n214         a = q*b + r,\n215     where the quotient  q  and the remainder  r  are integers\n216     and  0 <= r < b. Then each common divisor of  a  and  b\n217     divides  r, and it follows that  gcd(a, b) == gcd(b, r).\n218     The algorithm works by constructing the sequence\n219     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn\n220     is the remainder from the division of the two preceding\n221     elements.\n222 \n223     In Python, q = a // b  and  r = a % b  are obtained by the\n224     floor division and the remainder operations, respectively.\n225     These are the most expensive arithmetic operations, especially\n226     for large  a  and  b.\n227 \n228     Lehmer's algorithm is based on the observation that the quotients\n229     qn = r(n-1) // rn  are in general small integers even\n230     when  a  and  b  are very large. Hence the quotients can be\n231     usually determined from a relatively small number of most\n232     significant bits.\n233 \n234     The efficiency of the algorithm is further enhanced by not\n235     computing each long remainder in Euclid's sequence. The remainders\n236     are linear combinations of  a  and  b  with integer coefficients\n237     derived from the quotients. The coefficients can be computed\n238     as far as the quotients can be determined from the chosen\n239     most significant parts of  a  and  b. Only then a new pair of\n240     consecutive remainders is computed and the algorithm starts\n241     anew with this pair.\n242 \n243     References\n244     ==========\n245 \n246     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm\n247 \n248     \"\"\"\n249     a, b = abs(as_int(a)), abs(as_int(b))\n250     if a < b:\n251         a, b = b, a\n252 \n253     # The algorithm works by using one or two digit division\n254     # whenever possible. The outer loop will replace the\n255     # pair (a, b) with a pair of shorter consecutive elements\n256     # of the Euclidean gcd sequence until a and b\n257     # fit into two Python (long) int digits.\n258     nbits = 2*int_info.bits_per_digit\n259 \n260     while a.bit_length() > nbits and b != 0:\n261         # Quotients are mostly small integers that can\n262         # be determined from most significant bits.\n263         n = a.bit_length() - nbits\n264         x, y = int(a >> n), int(b >> n)  # most significant bits\n265 \n266         # Elements of the Euclidean gcd sequence are linear\n267         # combinations of a and b with integer coefficients.\n268         # Compute the coefficients of consecutive pairs\n269         #     a' = A*a + B*b, b' = C*a + D*b\n270         # using small integer arithmetic as far as possible.\n271         A, B, C, D = 1, 0, 0, 1  # initial values\n272 \n273         while True:\n274             # The coefficients alternate in sign while looping.\n275             # The inner loop combines two steps to keep track\n276             # of the signs.\n277 \n278             # At this point we have\n279             #   A > 0, B <= 0, C <= 0, D > 0,\n280             #   x' = x + B <= x < x\" = x + A,\n281             #   y' = y + C <= y < y\" = y + D,\n282             # and\n283             #   x'*N <= a' < x\"*N, y'*N <= b' < y\"*N,\n284             # where N = 2**n.\n285 \n286             # Now, if y' > 0, and x\"//y' and x'//y\" agree,\n287             # then their common value is equal to  q = a'//b'.\n288             # In addition,\n289             #   x'%y\" = x' - q*y\" < x\" - q*y' = x\"%y',\n290             # and\n291             #   (x'%y\")*N < a'%b' < (x\"%y')*N.\n292 \n293             # On the other hand, we also have  x//y == q,\n294             # and therefore\n295             #   x'%y\" = x + B - q*(y + D) = x%y + B',\n296             #   x\"%y' = x + A - q*(y + C) = x%y + A',\n297             # where\n298             #    B' = B - q*D < 0, A' = A - q*C > 0.\n299 \n300             if y + C <= 0:\n301                 break\n302             q = (x + A) // (y + C)\n303 \n304             # Now  x'//y\" <= q, and equality holds if\n305             #   x' - q*y\" = (x - q*y) + (B - q*D) >= 0.\n306             # This is a minor optimization to avoid division.\n307             x_qy, B_qD = x - q*y, B - q*D\n308             if x_qy + B_qD < 0:\n309                 break\n310 \n311             # Next step in the Euclidean sequence.\n312             x, y = y, x_qy\n313             A, B, C, D = C, D, A - q*C, B_qD\n314 \n315             # At this point the signs of the coefficients\n316             # change and their roles are interchanged.\n317             #   A <= 0, B > 0, C > 0, D < 0,\n318             #   x' = x + A <= x < x\" = x + B,\n319             #   y' = y + D < y < y\" = y + C.\n320 \n321             if y + D <= 0:\n322                 break\n323             q = (x + B) // (y + D)\n324             x_qy, A_qC = x - q*y, A - q*C\n325             if x_qy + A_qC < 0:\n326                 break\n327 \n328             x, y = y, x_qy\n329             A, B, C, D = C, D, A_qC, B - q*D\n330             # Now the conditions on top of the loop\n331             # are again satisfied.\n332             #   A > 0, B < 0, C < 0, D > 0.\n333 \n334         if B == 0:\n335             # This can only happen when y == 0 in the beginning\n336             # and the inner loop does nothing.\n337             # Long division is forced.\n338             a, b = b, a % b\n339             continue\n340 \n341         # Compute new long arguments using the coefficients.\n342         a, b = A*a + B*b, C*a + D*b\n343 \n344     # Small divisors. Finish with the standard algorithm.\n345     while b:\n346         a, b = b, a % b\n347 \n348     return a\n349 \n350 \n351 def ilcm(*args):\n352     \"\"\"Computes integer least common multiple.\n353 \n354     Examples\n355     ========\n356 \n357     >>> from sympy.core.numbers import ilcm\n358     >>> ilcm(5, 10)\n359     10\n360     >>> ilcm(7, 3)\n361     21\n362     >>> ilcm(5, 10, 15)\n363     30\n364 \n365     \"\"\"\n366     if len(args) < 2:\n367         raise TypeError(\n368             'ilcm() takes at least 2 arguments (%s given)' % len(args))\n369     if 0 in args:\n370         return 0\n371     a = args[0]\n372     for b in args[1:]:\n373         a = a // igcd(a, b) * b # since gcd(a,b) | a\n374     return a\n375 \n376 \n377 def igcdex(a, b):\n378     \"\"\"Returns x, y, g such that g = x*a + y*b = gcd(a, b).\n379 \n380        >>> from sympy.core.numbers import igcdex\n381        >>> igcdex(2, 3)\n382        (-1, 1, 1)\n383        >>> igcdex(10, 12)\n384        (-1, 1, 2)\n385 \n386        >>> x, y, g = igcdex(100, 2004)\n387        >>> x, y, g\n388        (-20, 1, 4)\n389        >>> x*100 + y*2004\n390        4\n391 \n392     \"\"\"\n393     if (not a) and (not b):\n394         return (0, 1, 0)\n395 \n396     if not a:\n397         return (0, b//abs(b), abs(b))\n398     if not b:\n399         return (a//abs(a), 0, abs(a))\n400 \n401     if a < 0:\n402         a, x_sign = -a, -1\n403     else:\n404         x_sign = 1\n405 \n406     if b < 0:\n407         b, y_sign = -b, -1\n408     else:\n409         y_sign = 1\n410 \n411     x, y, r, s = 1, 0, 0, 1\n412 \n413     while b:\n414         (c, q) = (a % b, a // b)\n415         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)\n416 \n417     return (x*x_sign, y*y_sign, a)\n418 \n419 \n420 def mod_inverse(a, m):\n421     \"\"\"\n422     Return the number c such that, (a * c) = 1 (mod m)\n423     where c has the same sign as m. If no such value exists,\n424     a ValueError is raised.\n425 \n426     Examples\n427     ========\n428 \n429     >>> from sympy import S\n430     >>> from sympy.core.numbers import mod_inverse\n431 \n432     Suppose we wish to find multiplicative inverse x of\n433     3 modulo 11. This is the same as finding x such\n434     that 3 * x = 1 (mod 11). One value of x that satisfies\n435     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).\n436     This is the value return by mod_inverse:\n437 \n438     >>> mod_inverse(3, 11)\n439     4\n440     >>> mod_inverse(-3, 11)\n441     7\n442 \n443     When there is a common factor between the numerators of\n444     ``a`` and ``m`` the inverse does not exist:\n445 \n446     >>> mod_inverse(2, 4)\n447     Traceback (most recent call last):\n448     ...\n449     ValueError: inverse of 2 mod 4 does not exist\n450 \n451     >>> mod_inverse(S(2)/7, S(5)/2)\n452     7/2\n453 \n454     References\n455     ==========\n456     - https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n457     - https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n458     \"\"\"\n459     c = None\n460     try:\n461         a, m = as_int(a), as_int(m)\n462         if m != 1 and m != -1:\n463             x, y, g = igcdex(a, m)\n464             if g == 1:\n465                 c = x % m\n466     except ValueError:\n467         a, m = sympify(a), sympify(m)\n468         if not (a.is_number and m.is_number):\n469             raise TypeError(filldedent('''\n470                 Expected numbers for arguments; symbolic `mod_inverse`\n471                 is not implemented\n472                 but symbolic expressions can be handled with the\n473                 similar function,\n474                 sympy.polys.polytools.invert'''))\n475         big = (m > 1)\n476         if not (big is S.true or big is S.false):\n477             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)\n478         elif big:\n479             c = 1/a\n480     if c is None:\n481         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))\n482     return c\n483 \n484 \n485 class Number(AtomicExpr):\n486     \"\"\"Represents atomic numbers in SymPy.\n487 \n488     Floating point numbers are represented by the Float class.\n489     Rational numbers (of any size) are represented by the Rational class.\n490     Integer numbers (of any size) are represented by the Integer class.\n491     Float and Rational are subclasses of Number; Integer is a subclass\n492     of Rational.\n493 \n494     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is\n495     a different object from the floating point number obtained with\n496     Python division ``2/3``. Even for numbers that are exactly\n497     represented in binary, there is a difference between how two forms,\n498     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.\n499     The rational form is to be preferred in symbolic computations.\n500 \n501     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or\n502     complex numbers ``3 + 4*I``, are not instances of Number class as\n503     they are not atomic.\n504 \n505     See Also\n506     ========\n507 \n508     Float, Integer, Rational\n509     \"\"\"\n510     is_commutative = True\n511     is_number = True\n512     is_Number = True\n513 \n514     __slots__ = []\n515 \n516     # Used to make max(x._prec, y._prec) return x._prec when only x is a float\n517     _prec = -1\n518 \n519     def __new__(cls, *obj):\n520         if len(obj) == 1:\n521             obj = obj[0]\n522 \n523         if isinstance(obj, Number):\n524             return obj\n525         if isinstance(obj, SYMPY_INTS):\n526             return Integer(obj)\n527         if isinstance(obj, tuple) and len(obj) == 2:\n528             return Rational(*obj)\n529         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):\n530             return Float(obj)\n531         if isinstance(obj, string_types):\n532             val = sympify(obj)\n533             if isinstance(val, Number):\n534                 return val\n535             else:\n536                 raise ValueError('String \"%s\" does not denote a Number' % obj)\n537         msg = \"expected str|int|long|float|Decimal|Number object but got %r\"\n538         raise TypeError(msg % type(obj).__name__)\n539 \n540     def invert(self, other, *gens, **args):\n541         from sympy.polys.polytools import invert\n542         if getattr(other, 'is_number', True):\n543             return mod_inverse(self, other)\n544         return invert(self, other, *gens, **args)\n545 \n546     def __divmod__(self, other):\n547         from .containers import Tuple\n548 \n549         try:\n550             other = Number(other)\n551         except TypeError:\n552             msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n553             raise TypeError(msg % (type(self).__name__, type(other).__name__))\n554         if not other:\n555             raise ZeroDivisionError('modulo by zero')\n556         if self.is_Integer and other.is_Integer:\n557             return Tuple(*divmod(self.p, other.p))\n558         else:\n559             rat = self/other\n560         w = int(rat) if rat > 0 else int(rat) - 1\n561         r = self - other*w\n562         return Tuple(w, r)\n563 \n564     def __rdivmod__(self, other):\n565         try:\n566             other = Number(other)\n567         except TypeError:\n568             msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n569             raise TypeError(msg % (type(other).__name__, type(self).__name__))\n570         return divmod(other, self)\n571 \n572     def _as_mpf_val(self, prec):\n573         \"\"\"Evaluation of mpf tuple accurate to at least prec bits.\"\"\"\n574         raise NotImplementedError('%s needs ._as_mpf_val() method' %\n575             (self.__class__.__name__))\n576 \n577     def _eval_evalf(self, prec):\n578         return Float._new(self._as_mpf_val(prec), prec)\n579 \n580     def _as_mpf_op(self, prec):\n581         prec = max(prec, self._prec)\n582         return self._as_mpf_val(prec), prec\n583 \n584     def __float__(self):\n585         return mlib.to_float(self._as_mpf_val(53))\n586 \n587     def floor(self):\n588         raise NotImplementedError('%s needs .floor() method' %\n589             (self.__class__.__name__))\n590 \n591     def ceiling(self):\n592         raise NotImplementedError('%s needs .ceiling() method' %\n593             (self.__class__.__name__))\n594 \n595     def __floor__(self):\n596         return self.floor()\n597 \n598     def __ceil__(self):\n599         return self.ceiling()\n600 \n601     def _eval_conjugate(self):\n602         return self\n603 \n604     def _eval_order(self, *symbols):\n605         from sympy import Order\n606         # Order(5, x, y) -> Order(1,x,y)\n607         return Order(S.One, *symbols)\n608 \n609     def _eval_subs(self, old, new):\n610         if old == -self:\n611             return -new\n612         return self  # there is no other possibility\n613 \n614     def _eval_is_finite(self):\n615         return True\n616 \n617     @classmethod\n618     def class_key(cls):\n619         return 1, 0, 'Number'\n620 \n621     @cacheit\n622     def sort_key(self, order=None):\n623         return self.class_key(), (0, ()), (), self\n624 \n625     @_sympifyit('other', NotImplemented)\n626     def __add__(self, other):\n627         if isinstance(other, Number) and global_evaluate[0]:\n628             if other is S.NaN:\n629                 return S.NaN\n630             elif other is S.Infinity:\n631                 return S.Infinity\n632             elif other is S.NegativeInfinity:\n633                 return S.NegativeInfinity\n634         return AtomicExpr.__add__(self, other)\n635 \n636     @_sympifyit('other', NotImplemented)\n637     def __sub__(self, other):\n638         if isinstance(other, Number) and global_evaluate[0]:\n639             if other is S.NaN:\n640                 return S.NaN\n641             elif other is S.Infinity:\n642                 return S.NegativeInfinity\n643             elif other is S.NegativeInfinity:\n644                 return S.Infinity\n645         return AtomicExpr.__sub__(self, other)\n646 \n647     @_sympifyit('other', NotImplemented)\n648     def __mul__(self, other):\n649         if isinstance(other, Number) and global_evaluate[0]:\n650             if other is S.NaN:\n651                 return S.NaN\n652             elif other is S.Infinity:\n653                 if self.is_zero:\n654                     return S.NaN\n655                 elif self.is_positive:\n656                     return S.Infinity\n657                 else:\n658                     return S.NegativeInfinity\n659             elif other is S.NegativeInfinity:\n660                 if self.is_zero:\n661                     return S.NaN\n662                 elif self.is_positive:\n663                     return S.NegativeInfinity\n664                 else:\n665                     return S.Infinity\n666         elif isinstance(other, Tuple):\n667             return NotImplemented\n668         return AtomicExpr.__mul__(self, other)\n669 \n670     @_sympifyit('other', NotImplemented)\n671     def __div__(self, other):\n672         if isinstance(other, Number) and global_evaluate[0]:\n673             if other is S.NaN:\n674                 return S.NaN\n675             elif other is S.Infinity or other is S.NegativeInfinity:\n676                 return S.Zero\n677         return AtomicExpr.__div__(self, other)\n678 \n679     __truediv__ = __div__\n680 \n681     def __eq__(self, other):\n682         raise NotImplementedError('%s needs .__eq__() method' %\n683             (self.__class__.__name__))\n684 \n685     def __ne__(self, other):\n686         raise NotImplementedError('%s needs .__ne__() method' %\n687             (self.__class__.__name__))\n688 \n689     def __lt__(self, other):\n690         try:\n691             other = _sympify(other)\n692         except SympifyError:\n693             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n694         raise NotImplementedError('%s needs .__lt__() method' %\n695             (self.__class__.__name__))\n696 \n697     def __le__(self, other):\n698         try:\n699             other = _sympify(other)\n700         except SympifyError:\n701             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n702         raise NotImplementedError('%s needs .__le__() method' %\n703             (self.__class__.__name__))\n704 \n705     def __gt__(self, other):\n706         try:\n707             other = _sympify(other)\n708         except SympifyError:\n709             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n710         return _sympify(other).__lt__(self)\n711 \n712     def __ge__(self, other):\n713         try:\n714             other = _sympify(other)\n715         except SympifyError:\n716             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n717         return _sympify(other).__le__(self)\n718 \n719     def __hash__(self):\n720         return super(Number, self).__hash__()\n721 \n722     def is_constant(self, *wrt, **flags):\n723         return True\n724 \n725     def as_coeff_mul(self, *deps, **kwargs):\n726         # a -> c*t\n727         if self.is_Rational or not kwargs.pop('rational', True):\n728             return self, tuple()\n729         elif self.is_negative:\n730             return S.NegativeOne, (-self,)\n731         return S.One, (self,)\n732 \n733     def as_coeff_add(self, *deps):\n734         # a -> c + t\n735         if self.is_Rational:\n736             return self, tuple()\n737         return S.Zero, (self,)\n738 \n739     def as_coeff_Mul(self, rational=False):\n740         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n741         if rational and not self.is_Rational:\n742             return S.One, self\n743         return (self, S.One) if self else (S.One, self)\n744 \n745     def as_coeff_Add(self, rational=False):\n746         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n747         if not rational:\n748             return self, S.Zero\n749         return S.Zero, self\n750 \n751     def gcd(self, other):\n752         \"\"\"Compute GCD of `self` and `other`. \"\"\"\n753         from sympy.polys import gcd\n754         return gcd(self, other)\n755 \n756     def lcm(self, other):\n757         \"\"\"Compute LCM of `self` and `other`. \"\"\"\n758         from sympy.polys import lcm\n759         return lcm(self, other)\n760 \n761     def cofactors(self, other):\n762         \"\"\"Compute GCD and cofactors of `self` and `other`. \"\"\"\n763         from sympy.polys import cofactors\n764         return cofactors(self, other)\n765 \n766 \n767 class Float(Number):\n768     \"\"\"Represent a floating-point number of arbitrary precision.\n769 \n770     Examples\n771     ========\n772 \n773     >>> from sympy import Float\n774     >>> Float(3.5)\n775     3.50000000000000\n776     >>> Float(3)\n777     3.00000000000000\n778 \n779     Creating Floats from strings (and Python ``int`` and ``long``\n780     types) will give a minimum precision of 15 digits, but the\n781     precision will automatically increase to capture all digits\n782     entered.\n783 \n784     >>> Float(1)\n785     1.00000000000000\n786     >>> Float(10**20)\n787     100000000000000000000.\n788     >>> Float('1e20')\n789     100000000000000000000.\n790 \n791     However, *floating-point* numbers (Python ``float`` types) retain\n792     only 15 digits of precision:\n793 \n794     >>> Float(1e20)\n795     1.00000000000000e+20\n796     >>> Float(1.23456789123456789)\n797     1.23456789123457\n798 \n799     It may be preferable to enter high-precision decimal numbers\n800     as strings:\n801 \n802     Float('1.23456789123456789')\n803     1.23456789123456789\n804 \n805     The desired number of digits can also be specified:\n806 \n807     >>> Float('1e-3', 3)\n808     0.00100\n809     >>> Float(100, 4)\n810     100.0\n811 \n812     Float can automatically count significant figures if a null string\n813     is sent for the precision; spaces or underscores are also allowed. (Auto-\n814     counting is only allowed for strings, ints and longs).\n815 \n816     >>> Float('123 456 789.123_456', '')\n817     123456789.123456\n818     >>> Float('12e-3', '')\n819     0.012\n820     >>> Float(3, '')\n821     3.\n822 \n823     If a number is written in scientific notation, only the digits before the\n824     exponent are considered significant if a decimal appears, otherwise the\n825     \"e\" signifies only how to move the decimal:\n826 \n827     >>> Float('60.e2', '')  # 2 digits significant\n828     6.0e+3\n829     >>> Float('60e2', '')  # 4 digits significant\n830     6000.\n831     >>> Float('600e-2', '')  # 3 digits significant\n832     6.00\n833 \n834     Notes\n835     =====\n836 \n837     Floats are inexact by their nature unless their value is a binary-exact\n838     value.\n839 \n840     >>> approx, exact = Float(.1, 1), Float(.125, 1)\n841 \n842     For calculation purposes, evalf needs to be able to change the precision\n843     but this will not increase the accuracy of the inexact value. The\n844     following is the most accurate 5-digit approximation of a value of 0.1\n845     that had only 1 digit of precision:\n846 \n847     >>> approx.evalf(5)\n848     0.099609\n849 \n850     By contrast, 0.125 is exact in binary (as it is in base 10) and so it\n851     can be passed to Float or evalf to obtain an arbitrary precision with\n852     matching accuracy:\n853 \n854     >>> Float(exact, 5)\n855     0.12500\n856     >>> exact.evalf(20)\n857     0.12500000000000000000\n858 \n859     Trying to make a high-precision Float from a float is not disallowed,\n860     but one must keep in mind that the *underlying float* (not the apparent\n861     decimal value) is being obtained with high precision. For example, 0.3\n862     does not have a finite binary representation. The closest rational is\n863     the fraction 5404319552844595/2**54. So if you try to obtain a Float of\n864     0.3 to 20 digits of precision you will not see the same thing as 0.3\n865     followed by 19 zeros:\n866 \n867     >>> Float(0.3, 20)\n868     0.29999999999999998890\n869 \n870     If you want a 20-digit value of the decimal 0.3 (not the floating point\n871     approximation of 0.3) you should send the 0.3 as a string. The underlying\n872     representation is still binary but a higher precision than Python's float\n873     is used:\n874 \n875     >>> Float('0.3', 20)\n876     0.30000000000000000000\n877 \n878     Although you can increase the precision of an existing Float using Float\n879     it will not increase the accuracy -- the underlying value is not changed:\n880 \n881     >>> def show(f): # binary rep of Float\n882     ...     from sympy import Mul, Pow\n883     ...     s, m, e, b = f._mpf_\n884     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)\n885     ...     print('%s at prec=%s' % (v, f._prec))\n886     ...\n887     >>> t = Float('0.3', 3)\n888     >>> show(t)\n889     4915/2**14 at prec=13\n890     >>> show(Float(t, 20)) # higher prec, not higher accuracy\n891     4915/2**14 at prec=70\n892     >>> show(Float(t, 2)) # lower prec\n893     307/2**10 at prec=10\n894 \n895     The same thing happens when evalf is used on a Float:\n896 \n897     >>> show(t.evalf(20))\n898     4915/2**14 at prec=70\n899     >>> show(t.evalf(2))\n900     307/2**10 at prec=10\n901 \n902     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to\n903     produce the number (-1)**n*c*2**p:\n904 \n905     >>> n, c, p = 1, 5, 0\n906     >>> (-1)**n*c*2**p\n907     -5\n908     >>> Float((1, 5, 0))\n909     -5.00000000000000\n910 \n911     An actual mpf tuple also contains the number of bits in c as the last\n912     element of the tuple:\n913 \n914     >>> _._mpf_\n915     (1, 5, 0, 3)\n916 \n917     This is not needed for instantiation and is not the same thing as the\n918     precision. The mpf tuple and the precision are two separate quantities\n919     that Float tracks.\n920 \n921     \"\"\"\n922     __slots__ = ['_mpf_', '_prec']\n923 \n924     # A Float represents many real numbers,\n925     # both rational and irrational.\n926     is_rational = None\n927     is_irrational = None\n928     is_number = True\n929 \n930     is_real = True\n931 \n932     is_Float = True\n933 \n934     def __new__(cls, num, dps=None, prec=None, precision=None):\n935         if prec is not None:\n936             SymPyDeprecationWarning(\n937                             feature=\"Using 'prec=XX' to denote decimal precision\",\n938                             useinstead=\"'dps=XX' for decimal precision and 'precision=XX' \"\\\n939                                               \"for binary precision\",\n940                             issue=12820,\n941                             deprecated_since_version=\"1.1\").warn()\n942             dps = prec\n943         del prec  # avoid using this deprecated kwarg\n944 \n945         if dps is not None and precision is not None:\n946             raise ValueError('Both decimal and binary precision supplied. '\n947                              'Supply only one. ')\n948 \n949         if isinstance(num, string_types):\n950             # Float already accepts spaces as digit separators; in Py 3.6\n951             # underscores are allowed. In anticipation of that, we ignore\n952             # legally placed underscores\n953             num = num.replace(' ', '')\n954             if '_' in num:\n955                 if num.startswith('_') or num.endswith('_') or any(\n956                         i in num for i in ('__', '_.', '._')):\n957                     # copy Py 3.6 error\n958                     raise ValueError(\"could not convert string to float: '%s'\" % num)\n959                 num = num.replace('_', '')\n960             if num.startswith('.') and len(num) > 1:\n961                 num = '0' + num\n962             elif num.startswith('-.') and len(num) > 2:\n963                 num = '-0.' + num[2:]\n964             elif num == 'inf' or num == '+inf':\n965                 return S.Infinity\n966             elif num == '-inf':\n967                 return S.NegativeInfinity\n968         elif isinstance(num, float) and num == 0:\n969             num = '0'\n970         elif isinstance(num, float) and num == float('inf'):\n971             return S.Infinity\n972         elif isinstance(num, float) and num == float('-inf'):\n973             return S.NegativeInfinity\n974         elif isinstance(num, (SYMPY_INTS, Integer)):\n975             num = str(num)  # faster than mlib.from_int\n976         elif num is S.Infinity:\n977             return num\n978         elif num is S.NegativeInfinity:\n979             return num\n980         elif type(num).__module__ == 'numpy': # support for numpy datatypes\n981             num = _convert_numpy_types(num)\n982         elif isinstance(num, mpmath.mpf):\n983             if precision is None:\n984                 if dps is None:\n985                     precision = num.context.prec\n986             num = num._mpf_\n987 \n988         if dps is None and precision is None:\n989             dps = 15\n990             if isinstance(num, Float):\n991                 return num\n992             if isinstance(num, string_types) and _literal_float(num):\n993                 try:\n994                     Num = decimal.Decimal(num)\n995                 except decimal.InvalidOperation:\n996                     pass\n997                 else:\n998                     isint = '.' not in num\n999                     num, dps = _decimal_to_Rational_prec(Num)\n1000                     if num.is_Integer and isint:\n1001                         dps = max(dps, len(str(num).lstrip('-')))\n1002                     dps = max(15, dps)\n1003                     precision = mlib.libmpf.dps_to_prec(dps)\n1004         elif precision == '' and dps is None or precision is None and dps == '':\n1005             if not isinstance(num, string_types):\n1006                 raise ValueError('The null string can only be used when '\n1007                 'the number to Float is passed as a string or an integer.')\n1008             ok = None\n1009             if _literal_float(num):\n1010                 try:\n1011                     Num = decimal.Decimal(num)\n1012                 except decimal.InvalidOperation:\n1013                     pass\n1014                 else:\n1015                     isint = '.' not in num\n1016                     num, dps = _decimal_to_Rational_prec(Num)\n1017                     if num.is_Integer and isint:\n1018                         dps = max(dps, len(str(num).lstrip('-')))\n1019                         precision = mlib.libmpf.dps_to_prec(dps)\n1020                     ok = True\n1021             if ok is None:\n1022                 raise ValueError('string-float not recognized: %s' % num)\n1023 \n1024         # decimal precision(dps) is set and maybe binary precision(precision)\n1025         # as well.From here on binary precision is used to compute the Float.\n1026         # Hence, if supplied use binary precision else translate from decimal\n1027         # precision.\n1028 \n1029         if precision is None or precision == '':\n1030             precision = mlib.libmpf.dps_to_prec(dps)\n1031 \n1032         precision = int(precision)\n1033 \n1034         if isinstance(num, float):\n1035             _mpf_ = mlib.from_float(num, precision, rnd)\n1036         elif isinstance(num, string_types):\n1037             _mpf_ = mlib.from_str(num, precision, rnd)\n1038         elif isinstance(num, decimal.Decimal):\n1039             if num.is_finite():\n1040                 _mpf_ = mlib.from_str(str(num), precision, rnd)\n1041             elif num.is_nan():\n1042                 return S.NaN\n1043             elif num.is_infinite():\n1044                 if num > 0:\n1045                     return S.Infinity\n1046                 else:\n1047                     return S.NegativeInfinity\n1048             else:\n1049                 raise ValueError(\"unexpected decimal value %s\" % str(num))\n1050         elif isinstance(num, tuple) and len(num) in (3, 4):\n1051             if type(num[1]) is str:\n1052                 # it's a hexadecimal (coming from a pickled object)\n1053                 # assume that it is in standard form\n1054                 num = list(num)\n1055                 # If we're loading an object pickled in Python 2 into\n1056                 # Python 3, we may need to strip a tailing 'L' because\n1057                 # of a shim for int on Python 3, see issue #13470.\n1058                 if num[1].endswith('L'):\n1059                     num[1] = num[1][:-1]\n1060                 num[1] = MPZ(num[1], 16)\n1061                 _mpf_ = tuple(num)\n1062             else:\n1063                 if len(num) == 4:\n1064                     # handle normalization hack\n1065                     return Float._new(num, precision)\n1066                 else:\n1067                     return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)\n1068         else:\n1069             try:\n1070                 _mpf_ = num._as_mpf_val(precision)\n1071             except (NotImplementedError, AttributeError):\n1072                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n1073 \n1074         # special cases\n1075         if _mpf_ == _mpf_zero:\n1076             pass  # we want a Float\n1077         elif _mpf_ == _mpf_nan:\n1078             return S.NaN\n1079         elif _mpf_ == _mpf_inf:\n1080             return S.Infinity\n1081         elif _mpf_ == _mpf_ninf:\n1082             return S.NegativeInfinity\n1083 \n1084         obj = Expr.__new__(cls)\n1085         obj._mpf_ = _mpf_\n1086         obj._prec = precision\n1087         return obj\n1088 \n1089     @classmethod\n1090     def _new(cls, _mpf_, _prec):\n1091         # special cases\n1092         if _mpf_ == _mpf_zero:\n1093             return S.Zero  # XXX this is different from Float which gives 0.0\n1094         elif _mpf_ == _mpf_nan:\n1095             return S.NaN\n1096         elif _mpf_ == _mpf_inf:\n1097             return S.Infinity\n1098         elif _mpf_ == _mpf_ninf:\n1099             return S.NegativeInfinity\n1100 \n1101         obj = Expr.__new__(cls)\n1102         obj._mpf_ = mpf_norm(_mpf_, _prec)\n1103         # XXX: Should this be obj._prec = obj._mpf_[3]?\n1104         obj._prec = _prec\n1105         return obj\n1106 \n1107     # mpz can't be pickled\n1108     def __getnewargs__(self):\n1109         return (mlib.to_pickable(self._mpf_),)\n1110 \n1111     def __getstate__(self):\n1112         return {'_prec': self._prec}\n1113 \n1114     def _hashable_content(self):\n1115         return (self._mpf_, self._prec)\n1116 \n1117     def floor(self):\n1118         return Integer(int(mlib.to_int(\n1119             mlib.mpf_floor(self._mpf_, self._prec))))\n1120 \n1121     def ceiling(self):\n1122         return Integer(int(mlib.to_int(\n1123             mlib.mpf_ceil(self._mpf_, self._prec))))\n1124 \n1125     def __floor__(self):\n1126         return self.floor()\n1127 \n1128     def __ceil__(self):\n1129         return self.ceiling()\n1130 \n1131 \n1132     @property\n1133     def num(self):\n1134         return mpmath.mpf(self._mpf_)\n1135 \n1136     def _as_mpf_val(self, prec):\n1137         rv = mpf_norm(self._mpf_, prec)\n1138         if rv != self._mpf_ and self._prec == prec:\n1139             debug(self._mpf_, rv)\n1140         return rv\n1141 \n1142     def _as_mpf_op(self, prec):\n1143         return self._mpf_, max(prec, self._prec)\n1144 \n1145     def _eval_is_finite(self):\n1146         if self._mpf_ in (_mpf_inf, _mpf_ninf):\n1147             return False\n1148         return True\n1149 \n1150     def _eval_is_infinite(self):\n1151         if self._mpf_ in (_mpf_inf, _mpf_ninf):\n1152             return True\n1153         return False\n1154 \n1155     def _eval_is_integer(self):\n1156         return self._mpf_ == _mpf_zero\n1157 \n1158     def _eval_is_negative(self):\n1159         if self._mpf_ == _mpf_ninf:\n1160             return True\n1161         if self._mpf_ == _mpf_inf:\n1162             return False\n1163         return self.num < 0\n1164 \n1165     def _eval_is_positive(self):\n1166         if self._mpf_ == _mpf_inf:\n1167             return True\n1168         if self._mpf_ == _mpf_ninf:\n1169             return False\n1170         return self.num > 0\n1171 \n1172     def _eval_is_zero(self):\n1173         return self._mpf_ == _mpf_zero\n1174 \n1175     def __nonzero__(self):\n1176         return self._mpf_ != _mpf_zero\n1177 \n1178     __bool__ = __nonzero__\n1179 \n1180     def __neg__(self):\n1181         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)\n1182 \n1183     @_sympifyit('other', NotImplemented)\n1184     def __add__(self, other):\n1185         if isinstance(other, Number) and global_evaluate[0]:\n1186             rhs, prec = other._as_mpf_op(self._prec)\n1187             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)\n1188         return Number.__add__(self, other)\n1189 \n1190     @_sympifyit('other', NotImplemented)\n1191     def __sub__(self, other):\n1192         if isinstance(other, Number) and global_evaluate[0]:\n1193             rhs, prec = other._as_mpf_op(self._prec)\n1194             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)\n1195         return Number.__sub__(self, other)\n1196 \n1197     @_sympifyit('other', NotImplemented)\n1198     def __mul__(self, other):\n1199         if isinstance(other, Number) and global_evaluate[0]:\n1200             rhs, prec = other._as_mpf_op(self._prec)\n1201             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)\n1202         return Number.__mul__(self, other)\n1203 \n1204     @_sympifyit('other', NotImplemented)\n1205     def __div__(self, other):\n1206         if isinstance(other, Number) and other != 0 and global_evaluate[0]:\n1207             rhs, prec = other._as_mpf_op(self._prec)\n1208             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)\n1209         return Number.__div__(self, other)\n1210 \n1211     __truediv__ = __div__\n1212 \n1213     @_sympifyit('other', NotImplemented)\n1214     def __mod__(self, other):\n1215         if isinstance(other, Rational) and other.q != 1 and global_evaluate[0]:\n1216             # calculate mod with Rationals, *then* round the result\n1217             return Float(Rational.__mod__(Rational(self), other),\n1218                          precision=self._prec)\n1219         if isinstance(other, Float) and global_evaluate[0]:\n1220             r = self/other\n1221             if r == int(r):\n1222                 return Float(0, precision=max(self._prec, other._prec))\n1223         if isinstance(other, Number) and global_evaluate[0]:\n1224             rhs, prec = other._as_mpf_op(self._prec)\n1225             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)\n1226         return Number.__mod__(self, other)\n1227 \n1228     @_sympifyit('other', NotImplemented)\n1229     def __rmod__(self, other):\n1230         if isinstance(other, Float) and global_evaluate[0]:\n1231             return other.__mod__(self)\n1232         if isinstance(other, Number) and global_evaluate[0]:\n1233             rhs, prec = other._as_mpf_op(self._prec)\n1234             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)\n1235         return Number.__rmod__(self, other)\n1236 \n1237     def _eval_power(self, expt):\n1238         \"\"\"\n1239         expt is symbolic object but not equal to 0, 1\n1240 \n1241         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->\n1242                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)\n1243         \"\"\"\n1244         if self == 0:\n1245             if expt.is_positive:\n1246                 return S.Zero\n1247             if expt.is_negative:\n1248                 return S.Infinity\n1249         if isinstance(expt, Number):\n1250             if isinstance(expt, Integer):\n1251                 prec = self._prec\n1252                 return Float._new(\n1253                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)\n1254             elif isinstance(expt, Rational) and \\\n1255                     expt.p == 1 and expt.q % 2 and self.is_negative:\n1256                 return Pow(S.NegativeOne, expt, evaluate=False)*(\n1257                     -self)._eval_power(expt)\n1258             expt, prec = expt._as_mpf_op(self._prec)\n1259             mpfself = self._mpf_\n1260             try:\n1261                 y = mpf_pow(mpfself, expt, prec, rnd)\n1262                 return Float._new(y, prec)\n1263             except mlib.ComplexResult:\n1264                 re, im = mlib.mpc_pow(\n1265                     (mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)\n1266                 return Float._new(re, prec) + \\\n1267                     Float._new(im, prec)*S.ImaginaryUnit\n1268 \n1269     def __abs__(self):\n1270         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)\n1271 \n1272     def __int__(self):\n1273         if self._mpf_ == _mpf_zero:\n1274             return 0\n1275         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down\n1276 \n1277     __long__ = __int__\n1278 \n1279     def __eq__(self, other):\n1280         if isinstance(other, float):\n1281             # coerce to Float at same precision\n1282             o = Float(other)\n1283             try:\n1284                 ompf = o._as_mpf_val(self._prec)\n1285             except ValueError:\n1286                 return False\n1287             return bool(mlib.mpf_eq(self._mpf_, ompf))\n1288         try:\n1289             other = _sympify(other)\n1290         except SympifyError:\n1291             return NotImplemented\n1292         if other.is_NumberSymbol:\n1293             if other.is_irrational:\n1294                 return False\n1295             return other.__eq__(self)\n1296         if other.is_Float:\n1297             return bool(mlib.mpf_eq(self._mpf_, other._mpf_))\n1298         if other.is_Number:\n1299             # numbers should compare at the same precision;\n1300             # all _as_mpf_val routines should be sure to abide\n1301             # by the request to change the prec if necessary; if\n1302             # they don't, the equality test will fail since it compares\n1303             # the mpf tuples\n1304             ompf = other._as_mpf_val(self._prec)\n1305             return bool(mlib.mpf_eq(self._mpf_, ompf))\n1306         return False    # Float != non-Number\n1307 \n1308     def __ne__(self, other):\n1309         return not self == other\n1310 \n1311     def __gt__(self, other):\n1312         try:\n1313             other = _sympify(other)\n1314         except SympifyError:\n1315             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n1316         if other.is_NumberSymbol:\n1317             return other.__lt__(self)\n1318         if other.is_Rational and not other.is_Integer:\n1319             self *= other.q\n1320             other = _sympify(other.p)\n1321         elif other.is_comparable:\n1322             other = other.evalf()\n1323         if other.is_Number and other is not S.NaN:\n1324             return _sympify(bool(\n1325                 mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))\n1326         return Expr.__gt__(self, other)\n1327 \n1328     def __ge__(self, other):\n1329         try:\n1330             other = _sympify(other)\n1331         except SympifyError:\n1332             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n1333         if other.is_NumberSymbol:\n1334             return other.__le__(self)\n1335         if other.is_Rational and not other.is_Integer:\n1336             self *= other.q\n1337             other = _sympify(other.p)\n1338         elif other.is_comparable:\n1339             other = other.evalf()\n1340         if other.is_Number and other is not S.NaN:\n1341             return _sympify(bool(\n1342                 mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))\n1343         return Expr.__ge__(self, other)\n1344 \n1345     def __lt__(self, other):\n1346         try:\n1347             other = _sympify(other)\n1348         except SympifyError:\n1349             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n1350         if other.is_NumberSymbol:\n1351             return other.__gt__(self)\n1352         if other.is_Rational and not other.is_Integer:\n1353             self *= other.q\n1354             other = _sympify(other.p)\n1355         elif other.is_comparable:\n1356             other = other.evalf()\n1357         if other.is_Number and other is not S.NaN:\n1358             return _sympify(bool(\n1359                 mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n1360         return Expr.__lt__(self, other)\n1361 \n1362     def __le__(self, other):\n1363         try:\n1364             other = _sympify(other)\n1365         except SympifyError:\n1366             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n1367         if other.is_NumberSymbol:\n1368             return other.__ge__(self)\n1369         if other.is_Rational and not other.is_Integer:\n1370             self *= other.q\n1371             other = _sympify(other.p)\n1372         elif other.is_comparable:\n1373             other = other.evalf()\n1374         if other.is_Number and other is not S.NaN:\n1375             return _sympify(bool(\n1376                 mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))\n1377         return Expr.__le__(self, other)\n1378 \n1379     def __hash__(self):\n1380         return super(Float, self).__hash__()\n1381 \n1382     def epsilon_eq(self, other, epsilon=\"1e-15\"):\n1383         return abs(self - other) < Float(epsilon)\n1384 \n1385     def _sage_(self):\n1386         import sage.all as sage\n1387         return sage.RealNumber(str(self))\n1388 \n1389     def __format__(self, format_spec):\n1390         return format(decimal.Decimal(str(self)), format_spec)\n1391 \n1392 \n1393 # Add sympify converters\n1394 converter[float] = converter[decimal.Decimal] = Float\n1395 \n1396 # this is here to work nicely in Sage\n1397 RealNumber = Float\n1398 \n1399 \n1400 class Rational(Number):\n1401     \"\"\"Represents rational numbers (p/q) of any size.\n1402 \n1403     Examples\n1404     ========\n1405 \n1406     >>> from sympy import Rational, nsimplify, S, pi\n1407     >>> Rational(1, 2)\n1408     1/2\n1409 \n1410     Rational is unprejudiced in accepting input. If a float is passed, the\n1411     underlying value of the binary representation will be returned:\n1412 \n1413     >>> Rational(.5)\n1414     1/2\n1415     >>> Rational(.2)\n1416     3602879701896397/18014398509481984\n1417 \n1418     If the simpler representation of the float is desired then consider\n1419     limiting the denominator to the desired value or convert the float to\n1420     a string (which is roughly equivalent to limiting the denominator to\n1421     10**12):\n1422 \n1423     >>> Rational(str(.2))\n1424     1/5\n1425     >>> Rational(.2).limit_denominator(10**12)\n1426     1/5\n1427 \n1428     An arbitrarily precise Rational is obtained when a string literal is\n1429     passed:\n1430 \n1431     >>> Rational(\"1.23\")\n1432     123/100\n1433     >>> Rational('1e-2')\n1434     1/100\n1435     >>> Rational(\".1\")\n1436     1/10\n1437     >>> Rational('1e-2/3.2')\n1438     1/320\n1439 \n1440     The conversion of other types of strings can be handled by\n1441     the sympify() function, and conversion of floats to expressions\n1442     or simple fractions can be handled with nsimplify:\n1443 \n1444     >>> S('.[3]')  # repeating digits in brackets\n1445     1/3\n1446     >>> S('3**2/10')  # general expressions\n1447     9/10\n1448     >>> nsimplify(.3)  # numbers that have a simple form\n1449     3/10\n1450 \n1451     But if the input does not reduce to a literal Rational, an error will\n1452     be raised:\n1453 \n1454     >>> Rational(pi)\n1455     Traceback (most recent call last):\n1456     ...\n1457     TypeError: invalid input: pi\n1458 \n1459 \n1460     Low-level\n1461     ---------\n1462 \n1463     Access numerator and denominator as .p and .q:\n1464 \n1465     >>> r = Rational(3, 4)\n1466     >>> r\n1467     3/4\n1468     >>> r.p\n1469     3\n1470     >>> r.q\n1471     4\n1472 \n1473     Note that p and q return integers (not SymPy Integers) so some care\n1474     is needed when using them in expressions:\n1475 \n1476     >>> r.p/r.q\n1477     0.75\n1478 \n1479     See Also\n1480     ========\n1481     sympify, sympy.simplify.simplify.nsimplify\n1482     \"\"\"\n1483     is_real = True\n1484     is_integer = False\n1485     is_rational = True\n1486     is_number = True\n1487 \n1488     __slots__ = ['p', 'q']\n1489 \n1490     is_Rational = True\n1491 \n1492     @cacheit\n1493     def __new__(cls, p, q=None, gcd=None):\n1494         if q is None:\n1495             if isinstance(p, Rational):\n1496                 return p\n1497 \n1498             if isinstance(p, SYMPY_INTS):\n1499                 pass\n1500             else:\n1501                 if isinstance(p, (float, Float)):\n1502                     return Rational(*_as_integer_ratio(p))\n1503 \n1504                 if not isinstance(p, string_types):\n1505                     try:\n1506                         p = sympify(p)\n1507                     except (SympifyError, SyntaxError):\n1508                         pass  # error will raise below\n1509                 else:\n1510                     if p.count('/') > 1:\n1511                         raise TypeError('invalid input: %s' % p)\n1512                     p = p.replace(' ', '')\n1513                     pq = p.rsplit('/', 1)\n1514                     if len(pq) == 2:\n1515                         p, q = pq\n1516                         fp = fractions.Fraction(p)\n1517                         fq = fractions.Fraction(q)\n1518                         p = fp/fq\n1519                     try:\n1520                         p = fractions.Fraction(p)\n1521                     except ValueError:\n1522                         pass  # error will raise below\n1523                     else:\n1524                         return Rational(p.numerator, p.denominator, 1)\n1525 \n1526                 if not isinstance(p, Rational):\n1527                     raise TypeError('invalid input: %s' % p)\n1528 \n1529             q = 1\n1530             gcd = 1\n1531         else:\n1532             p = Rational(p)\n1533             q = Rational(q)\n1534 \n1535         if isinstance(q, Rational):\n1536             p *= q.q\n1537             q = q.p\n1538         if isinstance(p, Rational):\n1539             q *= p.q\n1540             p = p.p\n1541 \n1542         # p and q are now integers\n1543         if q == 0:\n1544             if p == 0:\n1545                 if _errdict[\"divide\"]:\n1546                     raise ValueError(\"Indeterminate 0/0\")\n1547                 else:\n1548                     return S.NaN\n1549             return S.ComplexInfinity\n1550         if q < 0:\n1551             q = -q\n1552             p = -p\n1553         if not gcd:\n1554             gcd = igcd(abs(p), q)\n1555         if gcd > 1:\n1556             p //= gcd\n1557             q //= gcd\n1558         if q == 1:\n1559             return Integer(p)\n1560         if p == 1 and q == 2:\n1561             return S.Half\n1562         obj = Expr.__new__(cls)\n1563         obj.p = p\n1564         obj.q = q\n1565         return obj\n1566 \n1567     def limit_denominator(self, max_denominator=1000000):\n1568         \"\"\"Closest Rational to self with denominator at most max_denominator.\n1569 \n1570         >>> from sympy import Rational\n1571         >>> Rational('3.141592653589793').limit_denominator(10)\n1572         22/7\n1573         >>> Rational('3.141592653589793').limit_denominator(100)\n1574         311/99\n1575 \n1576         \"\"\"\n1577         f = fractions.Fraction(self.p, self.q)\n1578         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))\n1579 \n1580     def __getnewargs__(self):\n1581         return (self.p, self.q)\n1582 \n1583     def _hashable_content(self):\n1584         return (self.p, self.q)\n1585 \n1586     def _eval_is_positive(self):\n1587         return self.p > 0\n1588 \n1589     def _eval_is_zero(self):\n1590         return self.p == 0\n1591 \n1592     def __neg__(self):\n1593         return Rational(-self.p, self.q)\n1594 \n1595     @_sympifyit('other', NotImplemented)\n1596     def __add__(self, other):\n1597         if global_evaluate[0]:\n1598             if isinstance(other, Integer):\n1599                 return Rational(self.p + self.q*other.p, self.q, 1)\n1600             elif isinstance(other, Rational):\n1601                 #TODO: this can probably be optimized more\n1602                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)\n1603             elif isinstance(other, Float):\n1604                 return other + self\n1605             else:\n1606                 return Number.__add__(self, other)\n1607         return Number.__add__(self, other)\n1608     __radd__ = __add__\n1609 \n1610     @_sympifyit('other', NotImplemented)\n1611     def __sub__(self, other):\n1612         if global_evaluate[0]:\n1613             if isinstance(other, Integer):\n1614                 return Rational(self.p - self.q*other.p, self.q, 1)\n1615             elif isinstance(other, Rational):\n1616                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)\n1617             elif isinstance(other, Float):\n1618                 return -other + self\n1619             else:\n1620                 return Number.__sub__(self, other)\n1621         return Number.__sub__(self, other)\n1622     @_sympifyit('other', NotImplemented)\n1623     def __rsub__(self, other):\n1624         if global_evaluate[0]:\n1625             if isinstance(other, Integer):\n1626                 return Rational(self.q*other.p - self.p, self.q, 1)\n1627             elif isinstance(other, Rational):\n1628                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)\n1629             elif isinstance(other, Float):\n1630                 return -self + other\n1631             else:\n1632                 return Number.__rsub__(self, other)\n1633         return Number.__rsub__(self, other)\n1634     @_sympifyit('other', NotImplemented)\n1635     def __mul__(self, other):\n1636         if global_evaluate[0]:\n1637             if isinstance(other, Integer):\n1638                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))\n1639             elif isinstance(other, Rational):\n1640                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))\n1641             elif isinstance(other, Float):\n1642                 return other*self\n1643             else:\n1644                 return Number.__mul__(self, other)\n1645         return Number.__mul__(self, other)\n1646     __rmul__ = __mul__\n1647 \n1648     @_sympifyit('other', NotImplemented)\n1649     def __div__(self, other):\n1650         if global_evaluate[0]:\n1651             if isinstance(other, Integer):\n1652                 if self.p and other.p == S.Zero:\n1653                     return S.ComplexInfinity\n1654                 else:\n1655                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))\n1656             elif isinstance(other, Rational):\n1657                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1658             elif isinstance(other, Float):\n1659                 return self*(1/other)\n1660             else:\n1661                 return Number.__div__(self, other)\n1662         return Number.__div__(self, other)\n1663     @_sympifyit('other', NotImplemented)\n1664     def __rdiv__(self, other):\n1665         if global_evaluate[0]:\n1666             if isinstance(other, Integer):\n1667                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))\n1668             elif isinstance(other, Rational):\n1669                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1670             elif isinstance(other, Float):\n1671                 return other*(1/self)\n1672             else:\n1673                 return Number.__rdiv__(self, other)\n1674         return Number.__rdiv__(self, other)\n1675     __truediv__ = __div__\n1676 \n1677     @_sympifyit('other', NotImplemented)\n1678     def __mod__(self, other):\n1679         if global_evaluate[0]:\n1680             if isinstance(other, Rational):\n1681                 n = (self.p*other.q) // (other.p*self.q)\n1682                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)\n1683             if isinstance(other, Float):\n1684                 # calculate mod with Rationals, *then* round the answer\n1685                 return Float(self.__mod__(Rational(other)),\n1686                              precision=other._prec)\n1687             return Number.__mod__(self, other)\n1688         return Number.__mod__(self, other)\n1689 \n1690     @_sympifyit('other', NotImplemented)\n1691     def __rmod__(self, other):\n1692         if isinstance(other, Rational):\n1693             return Rational.__mod__(other, self)\n1694         return Number.__rmod__(self, other)\n1695 \n1696     def _eval_power(self, expt):\n1697         if isinstance(expt, Number):\n1698             if isinstance(expt, Float):\n1699                 return self._eval_evalf(expt._prec)**expt\n1700             if expt.is_negative:\n1701                 # (3/4)**-2 -> (4/3)**2\n1702                 ne = -expt\n1703                 if (ne is S.One):\n1704                     return Rational(self.q, self.p)\n1705                 if self.is_negative:\n1706                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne\n1707                 else:\n1708                     return Rational(self.q, self.p)**ne\n1709             if expt is S.Infinity:  # -oo already caught by test for negative\n1710                 if self.p > self.q:\n1711                     # (3/2)**oo -> oo\n1712                     return S.Infinity\n1713                 if self.p < -self.q:\n1714                     # (-3/2)**oo -> oo + I*oo\n1715                     return S.Infinity + S.Infinity*S.ImaginaryUnit\n1716                 return S.Zero\n1717             if isinstance(expt, Integer):\n1718                 # (4/3)**2 -> 4**2 / 3**2\n1719                 return Rational(self.p**expt.p, self.q**expt.p, 1)\n1720             if isinstance(expt, Rational):\n1721                 if self.p != 1:\n1722                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)\n1723                     return Integer(self.p)**expt*Integer(self.q)**(-expt)\n1724                 # as the above caught negative self.p, now self is positive\n1725                 return Integer(self.q)**Rational(\n1726                 expt.p*(expt.q - 1), expt.q) / \\\n1727                     Integer(self.q)**Integer(expt.p)\n1728 \n1729         if self.is_negative and expt.is_even:\n1730             return (-self)**expt\n1731 \n1732         return\n1733 \n1734     def _as_mpf_val(self, prec):\n1735         return mlib.from_rational(self.p, self.q, prec, rnd)\n1736 \n1737     def _mpmath_(self, prec, rnd):\n1738         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))\n1739 \n1740     def __abs__(self):\n1741         return Rational(abs(self.p), self.q)\n1742 \n1743     def __int__(self):\n1744         p, q = self.p, self.q\n1745         if p < 0:\n1746             return -int(-p//q)\n1747         return int(p//q)\n1748 \n1749     __long__ = __int__\n1750 \n1751     def floor(self):\n1752         return Integer(self.p // self.q)\n1753 \n1754     def ceiling(self):\n1755         return -Integer(-self.p // self.q)\n1756 \n1757     def __floor__(self):\n1758         return self.floor()\n1759 \n1760     def __ceil__(self):\n1761         return self.ceiling()\n1762 \n1763     def __eq__(self, other):\n1764         try:\n1765             other = _sympify(other)\n1766         except SympifyError:\n1767             return NotImplemented\n1768         if other.is_NumberSymbol:\n1769             if other.is_irrational:\n1770                 return False\n1771             return other.__eq__(self)\n1772         if other.is_Number:\n1773             if other.is_Rational:\n1774                 # a Rational is always in reduced form so will never be 2/4\n1775                 # so we can just check equivalence of args\n1776                 return self.p == other.p and self.q == other.q\n1777             if other.is_Float:\n1778                 return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n1779         return False\n1780 \n1781     def __ne__(self, other):\n1782         return not self == other\n1783 \n1784     def __gt__(self, other):\n1785         try:\n1786             other = _sympify(other)\n1787         except SympifyError:\n1788             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n1789         if other.is_NumberSymbol:\n1790             return other.__lt__(self)\n1791         expr = self\n1792         if other.is_Number:\n1793             if other.is_Rational:\n1794                 return _sympify(bool(self.p*other.q > self.q*other.p))\n1795             if other.is_Float:\n1796                 return _sympify(bool(mlib.mpf_gt(\n1797                     self._as_mpf_val(other._prec), other._mpf_)))\n1798         elif other.is_number and other.is_real:\n1799             expr, other = Integer(self.p), self.q*other\n1800         return Expr.__gt__(expr, other)\n1801 \n1802     def __ge__(self, other):\n1803         try:\n1804             other = _sympify(other)\n1805         except SympifyError:\n1806             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n1807         if other.is_NumberSymbol:\n1808             return other.__le__(self)\n1809         expr = self\n1810         if other.is_Number:\n1811             if other.is_Rational:\n1812                  return _sympify(bool(self.p*other.q >= self.q*other.p))\n1813             if other.is_Float:\n1814                 return _sympify(bool(mlib.mpf_ge(\n1815                     self._as_mpf_val(other._prec), other._mpf_)))\n1816         elif other.is_number and other.is_real:\n1817             expr, other = Integer(self.p), self.q*other\n1818         return Expr.__ge__(expr, other)\n1819 \n1820     def __lt__(self, other):\n1821         try:\n1822             other = _sympify(other)\n1823         except SympifyError:\n1824             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n1825         if other.is_NumberSymbol:\n1826             return other.__gt__(self)\n1827         expr = self\n1828         if other.is_Number:\n1829             if other.is_Rational:\n1830                 return _sympify(bool(self.p*other.q < self.q*other.p))\n1831             if other.is_Float:\n1832                 return _sympify(bool(mlib.mpf_lt(\n1833                     self._as_mpf_val(other._prec), other._mpf_)))\n1834         elif other.is_number and other.is_real:\n1835             expr, other = Integer(self.p), self.q*other\n1836         return Expr.__lt__(expr, other)\n1837 \n1838     def __le__(self, other):\n1839         try:\n1840             other = _sympify(other)\n1841         except SympifyError:\n1842             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n1843         expr = self\n1844         if other.is_NumberSymbol:\n1845             return other.__ge__(self)\n1846         elif other.is_Number:\n1847             if other.is_Rational:\n1848                 return _sympify(bool(self.p*other.q <= self.q*other.p))\n1849             if other.is_Float:\n1850                 return _sympify(bool(mlib.mpf_le(\n1851                     self._as_mpf_val(other._prec), other._mpf_)))\n1852         elif other.is_number and other.is_real:\n1853             expr, other = Integer(self.p), self.q*other\n1854         return Expr.__le__(expr, other)\n1855 \n1856     def __hash__(self):\n1857         return super(Rational, self).__hash__()\n1858 \n1859     def factors(self, limit=None, use_trial=True, use_rho=False,\n1860                 use_pm1=False, verbose=False, visual=False):\n1861         \"\"\"A wrapper to factorint which return factors of self that are\n1862         smaller than limit (or cheap to compute). Special methods of\n1863         factoring are disabled by default so that only trial division is used.\n1864         \"\"\"\n1865         from sympy.ntheory import factorrat\n1866 \n1867         return factorrat(self, limit=limit, use_trial=use_trial,\n1868                       use_rho=use_rho, use_pm1=use_pm1,\n1869                       verbose=verbose).copy()\n1870 \n1871     def numerator(self):\n1872         return self.p\n1873 \n1874     def denominator(self):\n1875         return self.q\n1876 \n1877     @_sympifyit('other', NotImplemented)\n1878     def gcd(self, other):\n1879         if isinstance(other, Rational):\n1880             if other is S.Zero:\n1881                 return other\n1882             return Rational(\n1883                 Integer(igcd(self.p, other.p)),\n1884                 Integer(ilcm(self.q, other.q)))\n1885         return Number.gcd(self, other)\n1886 \n1887     @_sympifyit('other', NotImplemented)\n1888     def lcm(self, other):\n1889         if isinstance(other, Rational):\n1890             return Rational(\n1891                 self.p // igcd(self.p, other.p) * other.p,\n1892                 igcd(self.q, other.q))\n1893         return Number.lcm(self, other)\n1894 \n1895     def as_numer_denom(self):\n1896         return Integer(self.p), Integer(self.q)\n1897 \n1898     def _sage_(self):\n1899         import sage.all as sage\n1900         return sage.Integer(self.p)/sage.Integer(self.q)\n1901 \n1902     def as_content_primitive(self, radical=False, clear=True):\n1903         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n1904         extracted from self.\n1905 \n1906         Examples\n1907         ========\n1908 \n1909         >>> from sympy import S\n1910         >>> (S(-3)/2).as_content_primitive()\n1911         (3/2, -1)\n1912 \n1913         See docstring of Expr.as_content_primitive for more examples.\n1914         \"\"\"\n1915 \n1916         if self:\n1917             if self.is_positive:\n1918                 return self, S.One\n1919             return -self, S.NegativeOne\n1920         return S.One, self\n1921 \n1922     def as_coeff_Mul(self, rational=False):\n1923         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n1924         return self, S.One\n1925 \n1926     def as_coeff_Add(self, rational=False):\n1927         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n1928         return self, S.Zero\n1929 \n1930 \n1931 class Integer(Rational):\n1932     \"\"\"Represents integer numbers of any size.\n1933 \n1934     Examples\n1935     ========\n1936 \n1937     >>> from sympy import Integer\n1938     >>> Integer(3)\n1939     3\n1940 \n1941     If a float or a rational is passed to Integer, the fractional part\n1942     will be discarded; the effect is of rounding toward zero.\n1943 \n1944     >>> Integer(3.8)\n1945     3\n1946     >>> Integer(-3.8)\n1947     -3\n1948 \n1949     A string is acceptable input if it can be parsed as an integer:\n1950 \n1951     >>> Integer(\"9\" * 20)\n1952     99999999999999999999\n1953 \n1954     It is rarely needed to explicitly instantiate an Integer, because\n1955     Python integers are automatically converted to Integer when they\n1956     are used in SymPy expressions.\n1957     \"\"\"\n1958     q = 1\n1959     is_integer = True\n1960     is_number = True\n1961 \n1962     is_Integer = True\n1963 \n1964     __slots__ = ['p']\n1965 \n1966     def _as_mpf_val(self, prec):\n1967         return mlib.from_int(self.p, prec, rnd)\n1968 \n1969     def _mpmath_(self, prec, rnd):\n1970         return mpmath.make_mpf(self._as_mpf_val(prec))\n1971 \n1972     @cacheit\n1973     def __new__(cls, i):\n1974         if isinstance(i, string_types):\n1975             i = i.replace(' ', '')\n1976         # whereas we cannot, in general, make a Rational from an\n1977         # arbitrary expression, we can make an Integer unambiguously\n1978         # (except when a non-integer expression happens to round to\n1979         # an integer). So we proceed by taking int() of the input and\n1980         # let the int routines determine whether the expression can\n1981         # be made into an int or whether an error should be raised.\n1982         try:\n1983             ival = int(i)\n1984         except TypeError:\n1985             raise TypeError(\n1986                 \"Argument of Integer should be of numeric type, got %s.\" % i)\n1987         # We only work with well-behaved integer types. This converts, for\n1988         # example, numpy.int32 instances.\n1989         if ival == 1:\n1990             return S.One\n1991         if ival == -1:\n1992             return S.NegativeOne\n1993         if ival == 0:\n1994             return S.Zero\n1995         obj = Expr.__new__(cls)\n1996         obj.p = ival\n1997         return obj\n1998 \n1999     def __getnewargs__(self):\n2000         return (self.p,)\n2001 \n2002     # Arithmetic operations are here for efficiency\n2003     def __int__(self):\n2004         return self.p\n2005 \n2006     __long__ = __int__\n2007 \n2008     def floor(self):\n2009         return Integer(self.p)\n2010 \n2011     def ceiling(self):\n2012         return Integer(self.p)\n2013 \n2014     def __floor__(self):\n2015         return self.floor()\n2016 \n2017     def __ceil__(self):\n2018         return self.ceiling()\n2019 \n2020     def __neg__(self):\n2021         return Integer(-self.p)\n2022 \n2023     def __abs__(self):\n2024         if self.p >= 0:\n2025             return self\n2026         else:\n2027             return Integer(-self.p)\n2028 \n2029     def __divmod__(self, other):\n2030         from .containers import Tuple\n2031         if isinstance(other, Integer) and global_evaluate[0]:\n2032             return Tuple(*(divmod(self.p, other.p)))\n2033         else:\n2034             return Number.__divmod__(self, other)\n2035 \n2036     def __rdivmod__(self, other):\n2037         from .containers import Tuple\n2038         if isinstance(other, integer_types) and global_evaluate[0]:\n2039             return Tuple(*(divmod(other, self.p)))\n2040         else:\n2041             try:\n2042                 other = Number(other)\n2043             except TypeError:\n2044                 msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n2045                 oname = type(other).__name__\n2046                 sname = type(self).__name__\n2047                 raise TypeError(msg % (oname, sname))\n2048             return Number.__divmod__(other, self)\n2049 \n2050     # TODO make it decorator + bytecodehacks?\n2051     def __add__(self, other):\n2052         if global_evaluate[0]:\n2053             if isinstance(other, integer_types):\n2054                 return Integer(self.p + other)\n2055             elif isinstance(other, Integer):\n2056                 return Integer(self.p + other.p)\n2057             elif isinstance(other, Rational):\n2058                 return Rational(self.p*other.q + other.p, other.q, 1)\n2059             return Rational.__add__(self, other)\n2060         else:\n2061             return Add(self, other)\n2062 \n2063     def __radd__(self, other):\n2064         if global_evaluate[0]:\n2065             if isinstance(other, integer_types):\n2066                 return Integer(other + self.p)\n2067             elif isinstance(other, Rational):\n2068                 return Rational(other.p + self.p*other.q, other.q, 1)\n2069             return Rational.__radd__(self, other)\n2070         return Rational.__radd__(self, other)\n2071 \n2072     def __sub__(self, other):\n2073         if global_evaluate[0]:\n2074             if isinstance(other, integer_types):\n2075                 return Integer(self.p - other)\n2076             elif isinstance(other, Integer):\n2077                 return Integer(self.p - other.p)\n2078             elif isinstance(other, Rational):\n2079                 return Rational(self.p*other.q - other.p, other.q, 1)\n2080             return Rational.__sub__(self, other)\n2081         return Rational.__sub__(self, other)\n2082 \n2083     def __rsub__(self, other):\n2084         if global_evaluate[0]:\n2085             if isinstance(other, integer_types):\n2086                 return Integer(other - self.p)\n2087             elif isinstance(other, Rational):\n2088                 return Rational(other.p - self.p*other.q, other.q, 1)\n2089             return Rational.__rsub__(self, other)\n2090         return Rational.__rsub__(self, other)\n2091 \n2092     def __mul__(self, other):\n2093         if global_evaluate[0]:\n2094             if isinstance(other, integer_types):\n2095                 return Integer(self.p*other)\n2096             elif isinstance(other, Integer):\n2097                 return Integer(self.p*other.p)\n2098             elif isinstance(other, Rational):\n2099                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))\n2100             return Rational.__mul__(self, other)\n2101         return Rational.__mul__(self, other)\n2102 \n2103     def __rmul__(self, other):\n2104         if global_evaluate[0]:\n2105             if isinstance(other, integer_types):\n2106                 return Integer(other*self.p)\n2107             elif isinstance(other, Rational):\n2108                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))\n2109             return Rational.__rmul__(self, other)\n2110         return Rational.__rmul__(self, other)\n2111 \n2112     def __mod__(self, other):\n2113         if global_evaluate[0]:\n2114             if isinstance(other, integer_types):\n2115                 return Integer(self.p % other)\n2116             elif isinstance(other, Integer):\n2117                 return Integer(self.p % other.p)\n2118             return Rational.__mod__(self, other)\n2119         return Rational.__mod__(self, other)\n2120 \n2121     def __rmod__(self, other):\n2122         if global_evaluate[0]:\n2123             if isinstance(other, integer_types):\n2124                 return Integer(other % self.p)\n2125             elif isinstance(other, Integer):\n2126                 return Integer(other.p % self.p)\n2127             return Rational.__rmod__(self, other)\n2128         return Rational.__rmod__(self, other)\n2129 \n2130     def __eq__(self, other):\n2131         if isinstance(other, integer_types):\n2132             return (self.p == other)\n2133         elif isinstance(other, Integer):\n2134             return (self.p == other.p)\n2135         return Rational.__eq__(self, other)\n2136 \n2137     def __ne__(self, other):\n2138         return not self == other\n2139 \n2140     def __gt__(self, other):\n2141         try:\n2142             other = _sympify(other)\n2143         except SympifyError:\n2144             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n2145         if other.is_Integer:\n2146             return _sympify(self.p > other.p)\n2147         return Rational.__gt__(self, other)\n2148 \n2149     def __lt__(self, other):\n2150         try:\n2151             other = _sympify(other)\n2152         except SympifyError:\n2153             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n2154         if other.is_Integer:\n2155             return _sympify(self.p < other.p)\n2156         return Rational.__lt__(self, other)\n2157 \n2158     def __ge__(self, other):\n2159         try:\n2160             other = _sympify(other)\n2161         except SympifyError:\n2162             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n2163         if other.is_Integer:\n2164             return _sympify(self.p >= other.p)\n2165         return Rational.__ge__(self, other)\n2166 \n2167     def __le__(self, other):\n2168         try:\n2169             other = _sympify(other)\n2170         except SympifyError:\n2171             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n2172         if other.is_Integer:\n2173             return _sympify(self.p <= other.p)\n2174         return Rational.__le__(self, other)\n2175 \n2176     def __hash__(self):\n2177         return hash(self.p)\n2178 \n2179     def __index__(self):\n2180         return self.p\n2181 \n2182     ########################################\n2183 \n2184     def _eval_is_odd(self):\n2185         return bool(self.p % 2)\n2186 \n2187     def _eval_power(self, expt):\n2188         \"\"\"\n2189         Tries to do some simplifications on self**expt\n2190 \n2191         Returns None if no further simplifications can be done\n2192 \n2193         When exponent is a fraction (so we have for example a square root),\n2194         we try to find a simpler representation by factoring the argument\n2195         up to factors of 2**15, e.g.\n2196 \n2197           - sqrt(4) becomes 2\n2198           - sqrt(-4) becomes 2*I\n2199           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)\n2200 \n2201         Further simplification would require a special call to factorint on\n2202         the argument which is not done here for sake of speed.\n2203 \n2204         \"\"\"\n2205         from sympy import perfect_power\n2206 \n2207         if expt is S.Infinity:\n2208             if self.p > S.One:\n2209                 return S.Infinity\n2210             # cases -1, 0, 1 are done in their respective classes\n2211             return S.Infinity + S.ImaginaryUnit*S.Infinity\n2212         if expt is S.NegativeInfinity:\n2213             return Rational(1, self)**S.Infinity\n2214         if not isinstance(expt, Number):\n2215             # simplify when expt is even\n2216             # (-2)**k --> 2**k\n2217             if self.is_negative and expt.is_even:\n2218                 return (-self)**expt\n2219         if isinstance(expt, Float):\n2220             # Rational knows how to exponentiate by a Float\n2221             return super(Integer, self)._eval_power(expt)\n2222         if not isinstance(expt, Rational):\n2223             return\n2224         if expt is S.Half and self.is_negative:\n2225             # we extract I for this special case since everyone is doing so\n2226             return S.ImaginaryUnit*Pow(-self, expt)\n2227         if expt.is_negative:\n2228             # invert base and change sign on exponent\n2229             ne = -expt\n2230             if self.is_negative:\n2231                     return S.NegativeOne**expt*Rational(1, -self)**ne\n2232             else:\n2233                 return Rational(1, self.p)**ne\n2234         # see if base is a perfect root, sqrt(4) --> 2\n2235         x, xexact = integer_nthroot(abs(self.p), expt.q)\n2236         if xexact:\n2237             # if it's a perfect root we've finished\n2238             result = Integer(x**abs(expt.p))\n2239             if self.is_negative:\n2240                 result *= S.NegativeOne**expt\n2241             return result\n2242 \n2243         # The following is an algorithm where we collect perfect roots\n2244         # from the factors of base.\n2245 \n2246         # if it's not an nth root, it still might be a perfect power\n2247         b_pos = int(abs(self.p))\n2248         p = perfect_power(b_pos)\n2249         if p is not False:\n2250             dict = {p[0]: p[1]}\n2251         else:\n2252             dict = Integer(b_pos).factors(limit=2**15)\n2253 \n2254         # now process the dict of factors\n2255         out_int = 1  # integer part\n2256         out_rad = 1  # extracted radicals\n2257         sqr_int = 1\n2258         sqr_gcd = 0\n2259         sqr_dict = {}\n2260         for prime, exponent in dict.items():\n2261             exponent *= expt.p\n2262             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)\n2263             div_e, div_m = divmod(exponent, expt.q)\n2264             if div_e > 0:\n2265                 out_int *= prime**div_e\n2266             if div_m > 0:\n2267                 # see if the reduced exponent shares a gcd with e.q\n2268                 # (2**2)**(1/10) -> 2**(1/5)\n2269                 g = igcd(div_m, expt.q)\n2270                 if g != 1:\n2271                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))\n2272                 else:\n2273                     sqr_dict[prime] = div_m\n2274         # identify gcd of remaining powers\n2275         for p, ex in sqr_dict.items():\n2276             if sqr_gcd == 0:\n2277                 sqr_gcd = ex\n2278             else:\n2279                 sqr_gcd = igcd(sqr_gcd, ex)\n2280                 if sqr_gcd == 1:\n2281                     break\n2282         for k, v in sqr_dict.items():\n2283             sqr_int *= k**(v//sqr_gcd)\n2284         if sqr_int == b_pos and out_int == 1 and out_rad == 1:\n2285             result = None\n2286         else:\n2287             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))\n2288             if self.is_negative:\n2289                 result *= Pow(S.NegativeOne, expt)\n2290         return result\n2291 \n2292     def _eval_is_prime(self):\n2293         from sympy.ntheory import isprime\n2294 \n2295         return isprime(self)\n2296 \n2297     def _eval_is_composite(self):\n2298         if self > 1:\n2299             return fuzzy_not(self.is_prime)\n2300         else:\n2301             return False\n2302 \n2303     def as_numer_denom(self):\n2304         return self, S.One\n2305 \n2306     def __floordiv__(self, other):\n2307         return Integer(self.p // Integer(other).p)\n2308 \n2309     def __rfloordiv__(self, other):\n2310         return Integer(Integer(other).p // self.p)\n2311 \n2312 # Add sympify converters\n2313 for i_type in integer_types:\n2314     converter[i_type] = Integer\n2315 \n2316 \n2317 class AlgebraicNumber(Expr):\n2318     \"\"\"Class for representing algebraic numbers in SymPy. \"\"\"\n2319 \n2320     __slots__ = ['rep', 'root', 'alias', 'minpoly']\n2321 \n2322     is_AlgebraicNumber = True\n2323     is_algebraic = True\n2324     is_number = True\n2325 \n2326     def __new__(cls, expr, coeffs=None, alias=None, **args):\n2327         \"\"\"Construct a new algebraic number. \"\"\"\n2328         from sympy import Poly\n2329         from sympy.polys.polyclasses import ANP, DMP\n2330         from sympy.polys.numberfields import minimal_polynomial\n2331         from sympy.core.symbol import Symbol\n2332 \n2333         expr = sympify(expr)\n2334 \n2335         if isinstance(expr, (tuple, Tuple)):\n2336             minpoly, root = expr\n2337 \n2338             if not minpoly.is_Poly:\n2339                 minpoly = Poly(minpoly)\n2340         elif expr.is_AlgebraicNumber:\n2341             minpoly, root = expr.minpoly, expr.root\n2342         else:\n2343             minpoly, root = minimal_polynomial(\n2344                 expr, args.get('gen'), polys=True), expr\n2345 \n2346         dom = minpoly.get_domain()\n2347 \n2348         if coeffs is not None:\n2349             if not isinstance(coeffs, ANP):\n2350                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)\n2351                 scoeffs = Tuple(*coeffs)\n2352             else:\n2353                 rep = DMP.from_list(coeffs.to_list(), 0, dom)\n2354                 scoeffs = Tuple(*coeffs.to_list())\n2355 \n2356             if rep.degree() >= minpoly.degree():\n2357                 rep = rep.rem(minpoly.rep)\n2358 \n2359         else:\n2360             rep = DMP.from_list([1, 0], 0, dom)\n2361             scoeffs = Tuple(1, 0)\n2362 \n2363         sargs = (root, scoeffs)\n2364 \n2365         if alias is not None:\n2366             if not isinstance(alias, Symbol):\n2367                 alias = Symbol(alias)\n2368             sargs = sargs + (alias,)\n2369 \n2370         obj = Expr.__new__(cls, *sargs)\n2371 \n2372         obj.rep = rep\n2373         obj.root = root\n2374         obj.alias = alias\n2375         obj.minpoly = minpoly\n2376 \n2377         return obj\n2378 \n2379     def __hash__(self):\n2380         return super(AlgebraicNumber, self).__hash__()\n2381 \n2382     def _eval_evalf(self, prec):\n2383         return self.as_expr()._evalf(prec)\n2384 \n2385     @property\n2386     def is_aliased(self):\n2387         \"\"\"Returns ``True`` if ``alias`` was set. \"\"\"\n2388         return self.alias is not None\n2389 \n2390     def as_poly(self, x=None):\n2391         \"\"\"Create a Poly instance from ``self``. \"\"\"\n2392         from sympy import Dummy, Poly, PurePoly\n2393         if x is not None:\n2394             return Poly.new(self.rep, x)\n2395         else:\n2396             if self.alias is not None:\n2397                 return Poly.new(self.rep, self.alias)\n2398             else:\n2399                 return PurePoly.new(self.rep, Dummy('x'))\n2400 \n2401     def as_expr(self, x=None):\n2402         \"\"\"Create a Basic expression from ``self``. \"\"\"\n2403         return self.as_poly(x or self.root).as_expr().expand()\n2404 \n2405     def coeffs(self):\n2406         \"\"\"Returns all SymPy coefficients of an algebraic number. \"\"\"\n2407         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]\n2408 \n2409     def native_coeffs(self):\n2410         \"\"\"Returns all native coefficients of an algebraic number. \"\"\"\n2411         return self.rep.all_coeffs()\n2412 \n2413     def to_algebraic_integer(self):\n2414         \"\"\"Convert ``self`` to an algebraic integer. \"\"\"\n2415         from sympy import Poly\n2416         f = self.minpoly\n2417 \n2418         if f.LC() == 1:\n2419             return self\n2420 \n2421         coeff = f.LC()**(f.degree() - 1)\n2422         poly = f.compose(Poly(f.gen/f.LC()))\n2423 \n2424         minpoly = poly*coeff\n2425         root = f.LC()*self.root\n2426 \n2427         return AlgebraicNumber((minpoly, root), self.coeffs())\n2428 \n2429     def _eval_simplify(self, ratio, measure, rational, inverse):\n2430         from sympy.polys import CRootOf, minpoly\n2431 \n2432         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:\n2433             if minpoly(self.root - r).is_Symbol:\n2434                 # use the matching root if it's simpler\n2435                 if measure(r) < ratio*measure(self.root):\n2436                     return AlgebraicNumber(r)\n2437         return self\n2438 \n2439 \n2440 class RationalConstant(Rational):\n2441     \"\"\"\n2442     Abstract base class for rationals with specific behaviors\n2443 \n2444     Derived classes must define class attributes p and q and should probably all\n2445     be singletons.\n2446     \"\"\"\n2447     __slots__ = []\n2448 \n2449     def __new__(cls):\n2450         return AtomicExpr.__new__(cls)\n2451 \n2452 \n2453 class IntegerConstant(Integer):\n2454     __slots__ = []\n2455 \n2456     def __new__(cls):\n2457         return AtomicExpr.__new__(cls)\n2458 \n2459 \n2460 class Zero(with_metaclass(Singleton, IntegerConstant)):\n2461     \"\"\"The number zero.\n2462 \n2463     Zero is a singleton, and can be accessed by ``S.Zero``\n2464 \n2465     Examples\n2466     ========\n2467 \n2468     >>> from sympy import S, Integer, zoo\n2469     >>> Integer(0) is S.Zero\n2470     True\n2471     >>> 1/S.Zero\n2472     zoo\n2473 \n2474     References\n2475     ==========\n2476 \n2477     .. [1] https://en.wikipedia.org/wiki/Zero\n2478     \"\"\"\n2479 \n2480     p = 0\n2481     q = 1\n2482     is_positive = False\n2483     is_negative = False\n2484     is_zero = True\n2485     is_number = True\n2486 \n2487     __slots__ = []\n2488 \n2489     @staticmethod\n2490     def __abs__():\n2491         return S.Zero\n2492 \n2493     @staticmethod\n2494     def __neg__():\n2495         return S.Zero\n2496 \n2497     def _eval_power(self, expt):\n2498         if expt.is_positive:\n2499             return self\n2500         if expt.is_negative:\n2501             return S.ComplexInfinity\n2502         if expt.is_real is False:\n2503             return S.NaN\n2504         # infinities are already handled with pos and neg\n2505         # tests above; now throw away leading numbers on Mul\n2506         # exponent\n2507         coeff, terms = expt.as_coeff_Mul()\n2508         if coeff.is_negative:\n2509             return S.ComplexInfinity**terms\n2510         if coeff is not S.One:  # there is a Number to discard\n2511             return self**terms\n2512 \n2513     def _eval_order(self, *symbols):\n2514         # Order(0,x) -> 0\n2515         return self\n2516 \n2517     def __nonzero__(self):\n2518         return False\n2519 \n2520     __bool__ = __nonzero__\n2521 \n2522     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted\n2523         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2524         return S.One, self\n2525 \n2526 \n2527 class One(with_metaclass(Singleton, IntegerConstant)):\n2528     \"\"\"The number one.\n2529 \n2530     One is a singleton, and can be accessed by ``S.One``.\n2531 \n2532     Examples\n2533     ========\n2534 \n2535     >>> from sympy import S, Integer\n2536     >>> Integer(1) is S.One\n2537     True\n2538 \n2539     References\n2540     ==========\n2541 \n2542     .. [1] https://en.wikipedia.org/wiki/1_%28number%29\n2543     \"\"\"\n2544     is_number = True\n2545 \n2546     p = 1\n2547     q = 1\n2548 \n2549     __slots__ = []\n2550 \n2551     @staticmethod\n2552     def __abs__():\n2553         return S.One\n2554 \n2555     @staticmethod\n2556     def __neg__():\n2557         return S.NegativeOne\n2558 \n2559     def _eval_power(self, expt):\n2560         return self\n2561 \n2562     def _eval_order(self, *symbols):\n2563         return\n2564 \n2565     @staticmethod\n2566     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,\n2567                 verbose=False, visual=False):\n2568         if visual:\n2569             return S.One\n2570         else:\n2571             return {}\n2572 \n2573 \n2574 class NegativeOne(with_metaclass(Singleton, IntegerConstant)):\n2575     \"\"\"The number negative one.\n2576 \n2577     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.\n2578 \n2579     Examples\n2580     ========\n2581 \n2582     >>> from sympy import S, Integer\n2583     >>> Integer(-1) is S.NegativeOne\n2584     True\n2585 \n2586     See Also\n2587     ========\n2588 \n2589     One\n2590 \n2591     References\n2592     ==========\n2593 \n2594     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29\n2595 \n2596     \"\"\"\n2597     is_number = True\n2598 \n2599     p = -1\n2600     q = 1\n2601 \n2602     __slots__ = []\n2603 \n2604     @staticmethod\n2605     def __abs__():\n2606         return S.One\n2607 \n2608     @staticmethod\n2609     def __neg__():\n2610         return S.One\n2611 \n2612     def _eval_power(self, expt):\n2613         if expt.is_odd:\n2614             return S.NegativeOne\n2615         if expt.is_even:\n2616             return S.One\n2617         if isinstance(expt, Number):\n2618             if isinstance(expt, Float):\n2619                 return Float(-1.0)**expt\n2620             if expt is S.NaN:\n2621                 return S.NaN\n2622             if expt is S.Infinity or expt is S.NegativeInfinity:\n2623                 return S.NaN\n2624             if expt is S.Half:\n2625                 return S.ImaginaryUnit\n2626             if isinstance(expt, Rational):\n2627                 if expt.q == 2:\n2628                     return S.ImaginaryUnit**Integer(expt.p)\n2629                 i, r = divmod(expt.p, expt.q)\n2630                 if i:\n2631                     return self**i*self**Rational(r, expt.q)\n2632         return\n2633 \n2634 \n2635 class Half(with_metaclass(Singleton, RationalConstant)):\n2636     \"\"\"The rational number 1/2.\n2637 \n2638     Half is a singleton, and can be accessed by ``S.Half``.\n2639 \n2640     Examples\n2641     ========\n2642 \n2643     >>> from sympy import S, Rational\n2644     >>> Rational(1, 2) is S.Half\n2645     True\n2646 \n2647     References\n2648     ==========\n2649 \n2650     .. [1] https://en.wikipedia.org/wiki/One_half\n2651     \"\"\"\n2652     is_number = True\n2653 \n2654     p = 1\n2655     q = 2\n2656 \n2657     __slots__ = []\n2658 \n2659     @staticmethod\n2660     def __abs__():\n2661         return S.Half\n2662 \n2663 \n2664 class Infinity(with_metaclass(Singleton, Number)):\n2665     r\"\"\"Positive infinite quantity.\n2666 \n2667     In real analysis the symbol `\\infty` denotes an unbounded\n2668     limit: `x\\to\\infty` means that `x` grows without bound.\n2669 \n2670     Infinity is often used not only to define a limit but as a value\n2671     in the affinely extended real number system.  Points labeled `+\\infty`\n2672     and `-\\infty` can be added to the topological space of the real numbers,\n2673     producing the two-point compactification of the real numbers.  Adding\n2674     algebraic properties to this gives us the extended real numbers.\n2675 \n2676     Infinity is a singleton, and can be accessed by ``S.Infinity``,\n2677     or can be imported as ``oo``.\n2678 \n2679     Examples\n2680     ========\n2681 \n2682     >>> from sympy import oo, exp, limit, Symbol\n2683     >>> 1 + oo\n2684     oo\n2685     >>> 42/oo\n2686     0\n2687     >>> x = Symbol('x')\n2688     >>> limit(exp(x), x, oo)\n2689     oo\n2690 \n2691     See Also\n2692     ========\n2693 \n2694     NegativeInfinity, NaN\n2695 \n2696     References\n2697     ==========\n2698 \n2699     .. [1] https://en.wikipedia.org/wiki/Infinity\n2700     \"\"\"\n2701 \n2702     is_commutative = True\n2703     is_positive = True\n2704     is_infinite = True\n2705     is_number = True\n2706     is_prime = False\n2707 \n2708     __slots__ = []\n2709 \n2710     def __new__(cls):\n2711         return AtomicExpr.__new__(cls)\n2712 \n2713     def _latex(self, printer):\n2714         return r\"\\infty\"\n2715 \n2716     def _eval_subs(self, old, new):\n2717         if self == old:\n2718             return new\n2719 \n2720     @_sympifyit('other', NotImplemented)\n2721     def __add__(self, other):\n2722         if isinstance(other, Number):\n2723             if other is S.NegativeInfinity or other is S.NaN:\n2724                 return S.NaN\n2725             return self\n2726         return NotImplemented\n2727     __radd__ = __add__\n2728 \n2729     @_sympifyit('other', NotImplemented)\n2730     def __sub__(self, other):\n2731         if isinstance(other, Number):\n2732             if other is S.Infinity or other is S.NaN:\n2733                 return S.NaN\n2734             return self\n2735         return NotImplemented\n2736 \n2737     @_sympifyit('other', NotImplemented)\n2738     def __rsub__(self, other):\n2739         return (-self).__add__(other)\n2740 \n2741     @_sympifyit('other', NotImplemented)\n2742     def __mul__(self, other):\n2743         if isinstance(other, Number):\n2744             if other.is_zero or other is S.NaN:\n2745                 return S.NaN\n2746             if other.is_positive:\n2747                 return self\n2748             return S.NegativeInfinity\n2749         return NotImplemented\n2750     __rmul__ = __mul__\n2751 \n2752     @_sympifyit('other', NotImplemented)\n2753     def __div__(self, other):\n2754         if isinstance(other, Number):\n2755             if other is S.Infinity or \\\n2756                 other is S.NegativeInfinity or \\\n2757                     other is S.NaN:\n2758                 return S.NaN\n2759             if other.is_nonnegative:\n2760                 return self\n2761             return S.NegativeInfinity\n2762         return NotImplemented\n2763 \n2764     __truediv__ = __div__\n2765 \n2766     def __abs__(self):\n2767         return S.Infinity\n2768 \n2769     def __neg__(self):\n2770         return S.NegativeInfinity\n2771 \n2772     def _eval_power(self, expt):\n2773         \"\"\"\n2774         ``expt`` is symbolic object but not equal to 0 or 1.\n2775 \n2776         ================ ======= ==============================\n2777         Expression       Result  Notes\n2778         ================ ======= ==============================\n2779         ``oo ** nan``    ``nan``\n2780         ``oo ** -p``     ``0``   ``p`` is number, ``oo``\n2781         ================ ======= ==============================\n2782 \n2783         See Also\n2784         ========\n2785         Pow\n2786         NaN\n2787         NegativeInfinity\n2788 \n2789         \"\"\"\n2790         from sympy.functions import re\n2791 \n2792         if expt.is_positive:\n2793             return S.Infinity\n2794         if expt.is_negative:\n2795             return S.Zero\n2796         if expt is S.NaN:\n2797             return S.NaN\n2798         if expt is S.ComplexInfinity:\n2799             return S.NaN\n2800         if expt.is_real is False and expt.is_number:\n2801             expt_real = re(expt)\n2802             if expt_real.is_positive:\n2803                 return S.ComplexInfinity\n2804             if expt_real.is_negative:\n2805                 return S.Zero\n2806             if expt_real.is_zero:\n2807                 return S.NaN\n2808 \n2809             return self**expt.evalf()\n2810 \n2811     def _as_mpf_val(self, prec):\n2812         return mlib.finf\n2813 \n2814     def _sage_(self):\n2815         import sage.all as sage\n2816         return sage.oo\n2817 \n2818     def __hash__(self):\n2819         return super(Infinity, self).__hash__()\n2820 \n2821     def __eq__(self, other):\n2822         return other is S.Infinity or other == float('inf')\n2823 \n2824     def __ne__(self, other):\n2825         return other is not S.Infinity and other != float('inf')\n2826 \n2827     def __lt__(self, other):\n2828         try:\n2829             other = _sympify(other)\n2830         except SympifyError:\n2831             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n2832         if other.is_real:\n2833             return S.false\n2834         return Expr.__lt__(self, other)\n2835 \n2836     def __le__(self, other):\n2837         try:\n2838             other = _sympify(other)\n2839         except SympifyError:\n2840             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n2841         if other.is_real:\n2842             if other.is_finite or other is S.NegativeInfinity:\n2843                 return S.false\n2844             elif other.is_nonpositive:\n2845                 return S.false\n2846             elif other.is_infinite and other.is_positive:\n2847                 return S.true\n2848         return Expr.__le__(self, other)\n2849 \n2850     def __gt__(self, other):\n2851         try:\n2852             other = _sympify(other)\n2853         except SympifyError:\n2854             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n2855         if other.is_real:\n2856             if other.is_finite or other is S.NegativeInfinity:\n2857                 return S.true\n2858             elif other.is_nonpositive:\n2859                 return S.true\n2860             elif other.is_infinite and other.is_positive:\n2861                 return S.false\n2862         return Expr.__gt__(self, other)\n2863 \n2864     def __ge__(self, other):\n2865         try:\n2866             other = _sympify(other)\n2867         except SympifyError:\n2868             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n2869         if other.is_real:\n2870             return S.true\n2871         return Expr.__ge__(self, other)\n2872 \n2873     def __mod__(self, other):\n2874         return S.NaN\n2875 \n2876     __rmod__ = __mod__\n2877 \n2878     def floor(self):\n2879         return self\n2880 \n2881     def ceiling(self):\n2882         return self\n2883 \n2884 oo = S.Infinity\n2885 \n2886 \n2887 class NegativeInfinity(with_metaclass(Singleton, Number)):\n2888     \"\"\"Negative infinite quantity.\n2889 \n2890     NegativeInfinity is a singleton, and can be accessed\n2891     by ``S.NegativeInfinity``.\n2892 \n2893     See Also\n2894     ========\n2895 \n2896     Infinity\n2897     \"\"\"\n2898 \n2899     is_commutative = True\n2900     is_negative = True\n2901     is_infinite = True\n2902     is_number = True\n2903 \n2904     __slots__ = []\n2905 \n2906     def __new__(cls):\n2907         return AtomicExpr.__new__(cls)\n2908 \n2909     def _latex(self, printer):\n2910         return r\"-\\infty\"\n2911 \n2912     def _eval_subs(self, old, new):\n2913         if self == old:\n2914             return new\n2915 \n2916     @_sympifyit('other', NotImplemented)\n2917     def __add__(self, other):\n2918         if isinstance(other, Number):\n2919             if other is S.Infinity or other is S.NaN:\n2920                 return S.NaN\n2921             return self\n2922         return NotImplemented\n2923     __radd__ = __add__\n2924 \n2925     @_sympifyit('other', NotImplemented)\n2926     def __sub__(self, other):\n2927         if isinstance(other, Number):\n2928             if other is S.NegativeInfinity or other is S.NaN:\n2929                 return S.NaN\n2930             return self\n2931         return NotImplemented\n2932 \n2933     @_sympifyit('other', NotImplemented)\n2934     def __rsub__(self, other):\n2935         return (-self).__add__(other)\n2936 \n2937     @_sympifyit('other', NotImplemented)\n2938     def __mul__(self, other):\n2939         if isinstance(other, Number):\n2940             if other.is_zero or other is S.NaN:\n2941                 return S.NaN\n2942             if other.is_positive:\n2943                 return self\n2944             return S.Infinity\n2945         return NotImplemented\n2946     __rmul__ = __mul__\n2947 \n2948     @_sympifyit('other', NotImplemented)\n2949     def __div__(self, other):\n2950         if isinstance(other, Number):\n2951             if other is S.Infinity or \\\n2952                 other is S.NegativeInfinity or \\\n2953                     other is S.NaN:\n2954                 return S.NaN\n2955             if other.is_nonnegative:\n2956                 return self\n2957             return S.Infinity\n2958         return NotImplemented\n2959 \n2960     __truediv__ = __div__\n2961 \n2962     def __abs__(self):\n2963         return S.Infinity\n2964 \n2965     def __neg__(self):\n2966         return S.Infinity\n2967 \n2968     def _eval_power(self, expt):\n2969         \"\"\"\n2970         ``expt`` is symbolic object but not equal to 0 or 1.\n2971 \n2972         ================ ======= ==============================\n2973         Expression       Result  Notes\n2974         ================ ======= ==============================\n2975         ``(-oo) ** nan`` ``nan``\n2976         ``(-oo) ** oo``  ``nan``\n2977         ``(-oo) ** -oo`` ``nan``\n2978         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer\n2979         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer\n2980         ================ ======= ==============================\n2981 \n2982         See Also\n2983         ========\n2984 \n2985         Infinity\n2986         Pow\n2987         NaN\n2988 \n2989         \"\"\"\n2990         if expt.is_number:\n2991             if expt is S.NaN or \\\n2992                 expt is S.Infinity or \\\n2993                     expt is S.NegativeInfinity:\n2994                 return S.NaN\n2995 \n2996             if isinstance(expt, Integer) and expt.is_positive:\n2997                 if expt.is_odd:\n2998                     return S.NegativeInfinity\n2999                 else:\n3000                     return S.Infinity\n3001 \n3002             return S.NegativeOne**expt*S.Infinity**expt\n3003 \n3004     def _as_mpf_val(self, prec):\n3005         return mlib.fninf\n3006 \n3007     def _sage_(self):\n3008         import sage.all as sage\n3009         return -(sage.oo)\n3010 \n3011     def __hash__(self):\n3012         return super(NegativeInfinity, self).__hash__()\n3013 \n3014     def __eq__(self, other):\n3015         return other is S.NegativeInfinity or other == float('-inf')\n3016 \n3017     def __ne__(self, other):\n3018         return other is not S.NegativeInfinity and other != float('-inf')\n3019 \n3020     def __lt__(self, other):\n3021         try:\n3022             other = _sympify(other)\n3023         except SympifyError:\n3024             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n3025         if other.is_real:\n3026             if other.is_finite or other is S.Infinity:\n3027                 return S.true\n3028             elif other.is_nonnegative:\n3029                 return S.true\n3030             elif other.is_infinite and other.is_negative:\n3031                 return S.false\n3032         return Expr.__lt__(self, other)\n3033 \n3034     def __le__(self, other):\n3035         try:\n3036             other = _sympify(other)\n3037         except SympifyError:\n3038             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n3039         if other.is_real:\n3040             return S.true\n3041         return Expr.__le__(self, other)\n3042 \n3043     def __gt__(self, other):\n3044         try:\n3045             other = _sympify(other)\n3046         except SympifyError:\n3047             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n3048         if other.is_real:\n3049             return S.false\n3050         return Expr.__gt__(self, other)\n3051 \n3052     def __ge__(self, other):\n3053         try:\n3054             other = _sympify(other)\n3055         except SympifyError:\n3056             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n3057         if other.is_real:\n3058             if other.is_finite or other is S.Infinity:\n3059                 return S.false\n3060             elif other.is_nonnegative:\n3061                 return S.false\n3062             elif other.is_infinite and other.is_negative:\n3063                 return S.true\n3064         return Expr.__ge__(self, other)\n3065 \n3066     def __mod__(self, other):\n3067         return S.NaN\n3068 \n3069     __rmod__ = __mod__\n3070 \n3071     def floor(self):\n3072         return self\n3073 \n3074     def ceiling(self):\n3075         return self\n3076 \n3077 \n3078 class NaN(with_metaclass(Singleton, Number)):\n3079     \"\"\"\n3080     Not a Number.\n3081 \n3082     This serves as a place holder for numeric values that are indeterminate.\n3083     Most operations on NaN, produce another NaN.  Most indeterminate forms,\n3084     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``\n3085     and ``oo**0``, which all produce ``1`` (this is consistent with Python's\n3086     float).\n3087 \n3088     NaN is loosely related to floating point nan, which is defined in the\n3089     IEEE 754 floating point standard, and corresponds to the Python\n3090     ``float('nan')``.  Differences are noted below.\n3091 \n3092     NaN is mathematically not equal to anything else, even NaN itself.  This\n3093     explains the initially counter-intuitive results with ``Eq`` and ``==`` in\n3094     the examples below.\n3095 \n3096     NaN is not comparable so inequalities raise a TypeError.  This is in\n3097     constrast with floating point nan where all inequalities are false.\n3098 \n3099     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported\n3100     as ``nan``.\n3101 \n3102     Examples\n3103     ========\n3104 \n3105     >>> from sympy import nan, S, oo, Eq\n3106     >>> nan is S.NaN\n3107     True\n3108     >>> oo - oo\n3109     nan\n3110     >>> nan + 1\n3111     nan\n3112     >>> Eq(nan, nan)   # mathematical equality\n3113     False\n3114     >>> nan == nan     # structural equality\n3115     True\n3116 \n3117     References\n3118     ==========\n3119 \n3120     .. [1] https://en.wikipedia.org/wiki/NaN\n3121 \n3122     \"\"\"\n3123     is_commutative = True\n3124     is_real = None\n3125     is_rational = None\n3126     is_algebraic = None\n3127     is_transcendental = None\n3128     is_integer = None\n3129     is_comparable = False\n3130     is_finite = None\n3131     is_zero = None\n3132     is_prime = None\n3133     is_positive = None\n3134     is_negative = None\n3135     is_number = True\n3136 \n3137     __slots__ = []\n3138 \n3139     def __new__(cls):\n3140         return AtomicExpr.__new__(cls)\n3141 \n3142     def _latex(self, printer):\n3143         return r\"\\text{NaN}\"\n3144 \n3145     @_sympifyit('other', NotImplemented)\n3146     def __add__(self, other):\n3147         return self\n3148 \n3149     @_sympifyit('other', NotImplemented)\n3150     def __sub__(self, other):\n3151         return self\n3152 \n3153     @_sympifyit('other', NotImplemented)\n3154     def __mul__(self, other):\n3155         return self\n3156 \n3157     @_sympifyit('other', NotImplemented)\n3158     def __div__(self, other):\n3159         return self\n3160 \n3161     __truediv__ = __div__\n3162 \n3163     def floor(self):\n3164         return self\n3165 \n3166     def ceiling(self):\n3167         return self\n3168 \n3169     def _as_mpf_val(self, prec):\n3170         return _mpf_nan\n3171 \n3172     def _sage_(self):\n3173         import sage.all as sage\n3174         return sage.NaN\n3175 \n3176     def __hash__(self):\n3177         return super(NaN, self).__hash__()\n3178 \n3179     def __eq__(self, other):\n3180         # NaN is structurally equal to another NaN\n3181         return other is S.NaN\n3182 \n3183     def __ne__(self, other):\n3184         return other is not S.NaN\n3185 \n3186     def _eval_Eq(self, other):\n3187         # NaN is not mathematically equal to anything, even NaN\n3188         return S.false\n3189 \n3190     # Expr will _sympify and raise TypeError\n3191     __gt__ = Expr.__gt__\n3192     __ge__ = Expr.__ge__\n3193     __lt__ = Expr.__lt__\n3194     __le__ = Expr.__le__\n3195 \n3196 nan = S.NaN\n3197 \n3198 \n3199 class ComplexInfinity(with_metaclass(Singleton, AtomicExpr)):\n3200     r\"\"\"Complex infinity.\n3201 \n3202     In complex analysis the symbol `\\tilde\\infty`, called \"complex\n3203     infinity\", represents a quantity with infinite magnitude, but\n3204     undetermined complex phase.\n3205 \n3206     ComplexInfinity is a singleton, and can be accessed by\n3207     ``S.ComplexInfinity``, or can be imported as ``zoo``.\n3208 \n3209     Examples\n3210     ========\n3211 \n3212     >>> from sympy import zoo, oo\n3213     >>> zoo + 42\n3214     zoo\n3215     >>> 42/zoo\n3216     0\n3217     >>> zoo + zoo\n3218     nan\n3219     >>> zoo*zoo\n3220     zoo\n3221 \n3222     See Also\n3223     ========\n3224 \n3225     Infinity\n3226     \"\"\"\n3227 \n3228     is_commutative = True\n3229     is_infinite = True\n3230     is_number = True\n3231     is_prime = False\n3232     is_complex = True\n3233     is_real = False\n3234 \n3235     __slots__ = []\n3236 \n3237     def __new__(cls):\n3238         return AtomicExpr.__new__(cls)\n3239 \n3240     def _latex(self, printer):\n3241         return r\"\\tilde{\\infty}\"\n3242 \n3243     @staticmethod\n3244     def __abs__():\n3245         return S.Infinity\n3246 \n3247     def floor(self):\n3248         return self\n3249 \n3250     def ceiling(self):\n3251         return self\n3252 \n3253     @staticmethod\n3254     def __neg__():\n3255         return S.ComplexInfinity\n3256 \n3257     def _eval_power(self, expt):\n3258         if expt is S.ComplexInfinity:\n3259             return S.NaN\n3260 \n3261         if isinstance(expt, Number):\n3262             if expt is S.Zero:\n3263                 return S.NaN\n3264             else:\n3265                 if expt.is_positive:\n3266                     return S.ComplexInfinity\n3267                 else:\n3268                     return S.Zero\n3269 \n3270     def _sage_(self):\n3271         import sage.all as sage\n3272         return sage.UnsignedInfinityRing.gen()\n3273 \n3274 \n3275 zoo = S.ComplexInfinity\n3276 \n3277 \n3278 class NumberSymbol(AtomicExpr):\n3279 \n3280     is_commutative = True\n3281     is_finite = True\n3282     is_number = True\n3283 \n3284     __slots__ = []\n3285 \n3286     is_NumberSymbol = True\n3287 \n3288     def __new__(cls):\n3289         return AtomicExpr.__new__(cls)\n3290 \n3291     def approximation(self, number_cls):\n3292         \"\"\" Return an interval with number_cls endpoints\n3293         that contains the value of NumberSymbol.\n3294         If not implemented, then return None.\n3295         \"\"\"\n3296 \n3297     def _eval_evalf(self, prec):\n3298         return Float._new(self._as_mpf_val(prec), prec)\n3299 \n3300     def __eq__(self, other):\n3301         try:\n3302             other = _sympify(other)\n3303         except SympifyError:\n3304             return NotImplemented\n3305         if self is other:\n3306             return True\n3307         if other.is_Number and self.is_irrational:\n3308             return False\n3309 \n3310         return False    # NumberSymbol != non-(Number|self)\n3311 \n3312     def __ne__(self, other):\n3313         return not self == other\n3314 \n3315     def __le__(self, other):\n3316         if self is other:\n3317             return S.true\n3318         return Expr.__le__(self, other)\n3319 \n3320     def __ge__(self, other):\n3321         if self is other:\n3322             return S.true\n3323         return Expr.__ge__(self, other)\n3324 \n3325     def __int__(self):\n3326         # subclass with appropriate return value\n3327         raise NotImplementedError\n3328 \n3329     def __long__(self):\n3330         return self.__int__()\n3331 \n3332     def __hash__(self):\n3333         return super(NumberSymbol, self).__hash__()\n3334 \n3335 \n3336 class Exp1(with_metaclass(Singleton, NumberSymbol)):\n3337     r\"\"\"The `e` constant.\n3338 \n3339     The transcendental number `e = 2.718281828\\ldots` is the base of the\n3340     natural logarithm and of the exponential function, `e = \\exp(1)`.\n3341     Sometimes called Euler's number or Napier's constant.\n3342 \n3343     Exp1 is a singleton, and can be accessed by ``S.Exp1``,\n3344     or can be imported as ``E``.\n3345 \n3346     Examples\n3347     ========\n3348 \n3349     >>> from sympy import exp, log, E\n3350     >>> E is exp(1)\n3351     True\n3352     >>> log(E)\n3353     1\n3354 \n3355     References\n3356     ==========\n3357 \n3358     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29\n3359     \"\"\"\n3360 \n3361     is_real = True\n3362     is_positive = True\n3363     is_negative = False  # XXX Forces is_negative/is_nonnegative\n3364     is_irrational = True\n3365     is_number = True\n3366     is_algebraic = False\n3367     is_transcendental = True\n3368 \n3369     __slots__ = []\n3370 \n3371     def _latex(self, printer):\n3372         return r\"e\"\n3373 \n3374     @staticmethod\n3375     def __abs__():\n3376         return S.Exp1\n3377 \n3378     def __int__(self):\n3379         return 2\n3380 \n3381     def _as_mpf_val(self, prec):\n3382         return mpf_e(prec)\n3383 \n3384     def approximation_interval(self, number_cls):\n3385         if issubclass(number_cls, Integer):\n3386             return (Integer(2), Integer(3))\n3387         elif issubclass(number_cls, Rational):\n3388             pass\n3389 \n3390     def _eval_power(self, expt):\n3391         from sympy import exp\n3392         return exp(expt)\n3393 \n3394     def _eval_rewrite_as_sin(self, **kwargs):\n3395         from sympy import sin\n3396         I = S.ImaginaryUnit\n3397         return sin(I + S.Pi/2) - I*sin(I)\n3398 \n3399     def _eval_rewrite_as_cos(self, **kwargs):\n3400         from sympy import cos\n3401         I = S.ImaginaryUnit\n3402         return cos(I) + I*cos(I + S.Pi/2)\n3403 \n3404     def _sage_(self):\n3405         import sage.all as sage\n3406         return sage.e\n3407 E = S.Exp1\n3408 \n3409 \n3410 class Pi(with_metaclass(Singleton, NumberSymbol)):\n3411     r\"\"\"The `\\pi` constant.\n3412 \n3413     The transcendental number `\\pi = 3.141592654\\ldots` represents the ratio\n3414     of a circle's circumference to its diameter, the area of the unit circle,\n3415     the half-period of trigonometric functions, and many other things\n3416     in mathematics.\n3417 \n3418     Pi is a singleton, and can be accessed by ``S.Pi``, or can\n3419     be imported as ``pi``.\n3420 \n3421     Examples\n3422     ========\n3423 \n3424     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol\n3425     >>> S.Pi\n3426     pi\n3427     >>> pi > 3\n3428     True\n3429     >>> pi.is_irrational\n3430     True\n3431     >>> x = Symbol('x')\n3432     >>> sin(x + 2*pi)\n3433     sin(x)\n3434     >>> integrate(exp(-x**2), (x, -oo, oo))\n3435     sqrt(pi)\n3436 \n3437     References\n3438     ==========\n3439 \n3440     .. [1] https://en.wikipedia.org/wiki/Pi\n3441     \"\"\"\n3442 \n3443     is_real = True\n3444     is_positive = True\n3445     is_negative = False\n3446     is_irrational = True\n3447     is_number = True\n3448     is_algebraic = False\n3449     is_transcendental = True\n3450 \n3451     __slots__ = []\n3452 \n3453     def _latex(self, printer):\n3454         return r\"\\pi\"\n3455 \n3456     @staticmethod\n3457     def __abs__():\n3458         return S.Pi\n3459 \n3460     def __int__(self):\n3461         return 3\n3462 \n3463     def _as_mpf_val(self, prec):\n3464         return mpf_pi(prec)\n3465 \n3466     def approximation_interval(self, number_cls):\n3467         if issubclass(number_cls, Integer):\n3468             return (Integer(3), Integer(4))\n3469         elif issubclass(number_cls, Rational):\n3470             return (Rational(223, 71), Rational(22, 7))\n3471 \n3472     def _sage_(self):\n3473         import sage.all as sage\n3474         return sage.pi\n3475 pi = S.Pi\n3476 \n3477 \n3478 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):\n3479     r\"\"\"The golden ratio, `\\phi`.\n3480 \n3481     `\\phi = \\frac{1 + \\sqrt{5}}{2}` is algebraic number.  Two quantities\n3482     are in the golden ratio if their ratio is the same as the ratio of\n3483     their sum to the larger of the two quantities, i.e. their maximum.\n3484 \n3485     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.\n3486 \n3487     Examples\n3488     ========\n3489 \n3490     >>> from sympy import S\n3491     >>> S.GoldenRatio > 1\n3492     True\n3493     >>> S.GoldenRatio.expand(func=True)\n3494     1/2 + sqrt(5)/2\n3495     >>> S.GoldenRatio.is_irrational\n3496     True\n3497 \n3498     References\n3499     ==========\n3500 \n3501     .. [1] https://en.wikipedia.org/wiki/Golden_ratio\n3502     \"\"\"\n3503 \n3504     is_real = True\n3505     is_positive = True\n3506     is_negative = False\n3507     is_irrational = True\n3508     is_number = True\n3509     is_algebraic = True\n3510     is_transcendental = False\n3511 \n3512     __slots__ = []\n3513 \n3514     def _latex(self, printer):\n3515         return r\"\\phi\"\n3516 \n3517     def __int__(self):\n3518         return 1\n3519 \n3520     def _as_mpf_val(self, prec):\n3521          # XXX track down why this has to be increased\n3522         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)\n3523         return mpf_norm(rv, prec)\n3524 \n3525     def _eval_expand_func(self, **hints):\n3526         from sympy import sqrt\n3527         return S.Half + S.Half*sqrt(5)\n3528 \n3529     def approximation_interval(self, number_cls):\n3530         if issubclass(number_cls, Integer):\n3531             return (S.One, Rational(2))\n3532         elif issubclass(number_cls, Rational):\n3533             pass\n3534 \n3535     def _sage_(self):\n3536         import sage.all as sage\n3537         return sage.golden_ratio\n3538 \n3539     _eval_rewrite_as_sqrt = _eval_expand_func\n3540 \n3541 \n3542 class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):\n3543     r\"\"\"The tribonacci constant.\n3544 \n3545     The tribonacci numbers are like the Fibonacci numbers, but instead\n3546     of starting with two predetermined terms, the sequence starts with\n3547     three predetermined terms and each term afterwards is the sum of the\n3548     preceding three terms.\n3549 \n3550     The tribonacci constant is the ratio toward which adjacent tribonacci\n3551     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,\n3552     and also satisfies the equation `x + x^{-3} = 2`.\n3553 \n3554     TribonacciConstant is a singleton, and can be accessed\n3555     by ``S.TribonacciConstant``.\n3556 \n3557     Examples\n3558     ========\n3559 \n3560     >>> from sympy import S\n3561     >>> S.TribonacciConstant > 1\n3562     True\n3563     >>> S.TribonacciConstant.expand(func=True)\n3564     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3\n3565     >>> S.TribonacciConstant.is_irrational\n3566     True\n3567     >>> S.TribonacciConstant.n(20)\n3568     1.8392867552141611326\n3569 \n3570     References\n3571     ==========\n3572 \n3573     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers\n3574     \"\"\"\n3575 \n3576     is_real = True\n3577     is_positive = True\n3578     is_negative = False\n3579     is_irrational = True\n3580     is_number = True\n3581     is_algebraic = True\n3582     is_transcendental = False\n3583 \n3584     __slots__ = []\n3585 \n3586     def _latex(self, printer):\n3587         return r\"\\text{TribonacciConstant}\"\n3588 \n3589     def __int__(self):\n3590         return 2\n3591 \n3592     def _eval_evalf(self, prec):\n3593         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)\n3594         return Float(rv, precision=prec)\n3595 \n3596     def _eval_expand_func(self, **hints):\n3597         from sympy import sqrt, cbrt\n3598         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3\n3599 \n3600     def approximation_interval(self, number_cls):\n3601         if issubclass(number_cls, Integer):\n3602             return (S.One, Rational(2))\n3603         elif issubclass(number_cls, Rational):\n3604             pass\n3605 \n3606     _eval_rewrite_as_sqrt = _eval_expand_func\n3607 \n3608 \n3609 class EulerGamma(with_metaclass(Singleton, NumberSymbol)):\n3610     r\"\"\"The Euler-Mascheroni constant.\n3611 \n3612     `\\gamma = 0.5772157\\ldots` (also called Euler's constant) is a mathematical\n3613     constant recurring in analysis and number theory.  It is defined as the\n3614     limiting difference between the harmonic series and the\n3615     natural logarithm:\n3616 \n3617     .. math:: \\gamma = \\lim\\limits_{n\\to\\infty}\n3618               \\left(\\sum\\limits_{k=1}^n\\frac{1}{k} - \\ln n\\right)\n3619 \n3620     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.\n3621 \n3622     Examples\n3623     ========\n3624 \n3625     >>> from sympy import S\n3626     >>> S.EulerGamma.is_irrational\n3627     >>> S.EulerGamma > 0\n3628     True\n3629     >>> S.EulerGamma > 1\n3630     False\n3631 \n3632     References\n3633     ==========\n3634 \n3635     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant\n3636     \"\"\"\n3637 \n3638     is_real = True\n3639     is_positive = True\n3640     is_negative = False\n3641     is_irrational = None\n3642     is_number = True\n3643 \n3644     __slots__ = []\n3645 \n3646     def _latex(self, printer):\n3647         return r\"\\gamma\"\n3648 \n3649     def __int__(self):\n3650         return 0\n3651 \n3652     def _as_mpf_val(self, prec):\n3653          # XXX track down why this has to be increased\n3654         v = mlib.libhyper.euler_fixed(prec + 10)\n3655         rv = mlib.from_man_exp(v, -prec - 10)\n3656         return mpf_norm(rv, prec)\n3657 \n3658     def approximation_interval(self, number_cls):\n3659         if issubclass(number_cls, Integer):\n3660             return (S.Zero, S.One)\n3661         elif issubclass(number_cls, Rational):\n3662             return (S.Half, Rational(3, 5))\n3663 \n3664     def _sage_(self):\n3665         import sage.all as sage\n3666         return sage.euler_gamma\n3667 \n3668 \n3669 class Catalan(with_metaclass(Singleton, NumberSymbol)):\n3670     r\"\"\"Catalan's constant.\n3671 \n3672     `K = 0.91596559\\ldots` is given by the infinite series\n3673 \n3674     .. math:: K = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{(2k+1)^2}\n3675 \n3676     Catalan is a singleton, and can be accessed by ``S.Catalan``.\n3677 \n3678     Examples\n3679     ========\n3680 \n3681     >>> from sympy import S\n3682     >>> S.Catalan.is_irrational\n3683     >>> S.Catalan > 0\n3684     True\n3685     >>> S.Catalan > 1\n3686     False\n3687 \n3688     References\n3689     ==========\n3690 \n3691     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant\n3692     \"\"\"\n3693 \n3694     is_real = True\n3695     is_positive = True\n3696     is_negative = False\n3697     is_irrational = None\n3698     is_number = True\n3699 \n3700     __slots__ = []\n3701 \n3702     def __int__(self):\n3703         return 0\n3704 \n3705     def _as_mpf_val(self, prec):\n3706         # XXX track down why this has to be increased\n3707         v = mlib.catalan_fixed(prec + 10)\n3708         rv = mlib.from_man_exp(v, -prec - 10)\n3709         return mpf_norm(rv, prec)\n3710 \n3711     def approximation_interval(self, number_cls):\n3712         if issubclass(number_cls, Integer):\n3713             return (S.Zero, S.One)\n3714         elif issubclass(number_cls, Rational):\n3715             return (Rational(9, 10), S.One)\n3716 \n3717     def _sage_(self):\n3718         import sage.all as sage\n3719         return sage.catalan\n3720 \n3721 \n3722 class ImaginaryUnit(with_metaclass(Singleton, AtomicExpr)):\n3723     r\"\"\"The imaginary unit, `i = \\sqrt{-1}`.\n3724 \n3725     I is a singleton, and can be accessed by ``S.I``, or can be\n3726     imported as ``I``.\n3727 \n3728     Examples\n3729     ========\n3730 \n3731     >>> from sympy import I, sqrt\n3732     >>> sqrt(-1)\n3733     I\n3734     >>> I*I\n3735     -1\n3736     >>> 1/I\n3737     -I\n3738 \n3739     References\n3740     ==========\n3741 \n3742     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit\n3743     \"\"\"\n3744 \n3745     is_commutative = True\n3746     is_imaginary = True\n3747     is_finite = True\n3748     is_number = True\n3749     is_algebraic = True\n3750     is_transcendental = False\n3751 \n3752     __slots__ = []\n3753 \n3754     def _latex(self, printer):\n3755         return printer._settings['imaginary_unit_latex']\n3756 \n3757     @staticmethod\n3758     def __abs__():\n3759         return S.One\n3760 \n3761     def _eval_evalf(self, prec):\n3762         return self\n3763 \n3764     def _eval_conjugate(self):\n3765         return -S.ImaginaryUnit\n3766 \n3767     def _eval_power(self, expt):\n3768         \"\"\"\n3769         b is I = sqrt(-1)\n3770         e is symbolic object but not equal to 0, 1\n3771 \n3772         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal\n3773         I**0 mod 4 -> 1\n3774         I**1 mod 4 -> I\n3775         I**2 mod 4 -> -1\n3776         I**3 mod 4 -> -I\n3777         \"\"\"\n3778 \n3779         if isinstance(expt, Number):\n3780             if isinstance(expt, Integer):\n3781                 expt = expt.p % 4\n3782                 if expt == 0:\n3783                     return S.One\n3784                 if expt == 1:\n3785                     return S.ImaginaryUnit\n3786                 if expt == 2:\n3787                     return -S.One\n3788                 return -S.ImaginaryUnit\n3789         return\n3790 \n3791     def as_base_exp(self):\n3792         return S.NegativeOne, S.Half\n3793 \n3794     def _sage_(self):\n3795         import sage.all as sage\n3796         return sage.I\n3797 \n3798     @property\n3799     def _mpc_(self):\n3800         return (Float(0)._mpf_, Float(1)._mpf_)\n3801 \n3802 I = S.ImaginaryUnit\n3803 \n3804 \n3805 def sympify_fractions(f):\n3806     return Rational(f.numerator, f.denominator, 1)\n3807 \n3808 converter[fractions.Fraction] = sympify_fractions\n3809 \n3810 try:\n3811     if HAS_GMPY == 2:\n3812         import gmpy2 as gmpy\n3813     elif HAS_GMPY == 1:\n3814         import gmpy\n3815     else:\n3816         raise ImportError\n3817 \n3818     def sympify_mpz(x):\n3819         return Integer(long(x))\n3820 \n3821     def sympify_mpq(x):\n3822         return Rational(long(x.numerator), long(x.denominator))\n3823 \n3824     converter[type(gmpy.mpz(1))] = sympify_mpz\n3825     converter[type(gmpy.mpq(1, 2))] = sympify_mpq\n3826 except ImportError:\n3827     pass\n3828 \n3829 \n3830 def sympify_mpmath(x):\n3831     return Expr._from_mpmath(x, x.context.prec)\n3832 \n3833 converter[mpnumeric] = sympify_mpmath\n3834 \n3835 \n3836 def sympify_mpq(x):\n3837     p, q = x._mpq_\n3838     return Rational(p, q, 1)\n3839 \n3840 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpq\n3841 \n3842 \n3843 def sympify_complex(a):\n3844     real, imag = list(map(sympify, (a.real, a.imag)))\n3845     return real + S.ImaginaryUnit*imag\n3846 \n3847 converter[complex] = sympify_complex\n3848 \n3849 from .power import Pow, integer_nthroot\n3850 from .mul import Mul\n3851 Mul.identity = One()\n3852 from .add import Add\n3853 Add.identity = Zero()\n3854 \n3855 def _register_classes():\n3856     numbers.Number.register(Number)\n3857     numbers.Real.register(Float)\n3858     numbers.Rational.register(Rational)\n3859     numbers.Rational.register(Integer)\n3860 \n3861 _register_classes()\n",
        "intended_behavior": "The code handling division, specifically integer division with a denominator that is a decimal or results in a fractional value, should correctly interpret Python's division rules, ensuring: Integer division by any non-integer (e.g., .5) should not cause a ZeroDivisionError but should instead either correctly perform the division as per Python's arithmetic rules or raise an appropriate error/message explaining why the operation isn't allowed if indeed such operations are intended to be restricted by the design of the project. Proper type handling and casting should be implemented to prevent unexpected results or exceptions when performing arithmetic operations, especially divisions that involve floating-point numbers. For example, before performing the division, checks should be in place to ensure that if the divisor is a decimal, the operation should gracefully handle or convert types to yield the correct result."
    }
]