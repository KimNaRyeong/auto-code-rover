[
    {
        "rel_file_path": "lib/matplotlib/pyplot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/pyplot.py",
        "start": 1,
        "end": 4315,
        "class_name": null,
        "method_name": null,
        "code": "1 # Note: The first part of this file can be modified in place, but the latter\n2 # part is autogenerated by the boilerplate.py script.\n3 \n4 \"\"\"\n5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides\n6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your\n7 screen, and acts as the figure GUI manager.\n8 \n9 pyplot is mainly intended for interactive plots and simple cases of\n10 programmatic plot generation::\n11 \n12     import numpy as np\n13     import matplotlib.pyplot as plt\n14 \n15     x = np.arange(0, 5, 0.1)\n16     y = np.sin(x)\n17     plt.plot(x, y)\n18 \n19 The explicit object-oriented API is recommended for complex plots, though\n20 pyplot is still usually used to create the figure and often the axes in the\n21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and\n22 `.pyplot.subplot_mosaic` to create figures, and\n23 :doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::\n24 \n25     import numpy as np\n26     import matplotlib.pyplot as plt\n27 \n28     x = np.arange(0, 5, 0.1)\n29     y = np.sin(x)\n30     fig, ax = plt.subplots()\n31     ax.plot(x, y)\n32 \n33 \n34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n35 implicit and explicit interfaces.\n36 \"\"\"\n37 \n38 # fmt: off\n39 \n40 from __future__ import annotations\n41 \n42 from contextlib import AbstractContextManager, ExitStack\n43 from enum import Enum\n44 import functools\n45 import importlib\n46 import inspect\n47 import logging\n48 import re\n49 import sys\n50 import threading\n51 import time\n52 from typing import cast, overload\n53 \n54 from cycler import cycler\n55 import matplotlib\n56 import matplotlib.colorbar\n57 import matplotlib.image\n58 from matplotlib import _api\n59 from matplotlib import (  # Re-exported for typing.\n60     cm as cm, get_backend as get_backend, rcParams as rcParams, style as style)\n61 from matplotlib import _pylab_helpers, interactive\n62 from matplotlib import cbook\n63 from matplotlib import _docstring\n64 from matplotlib.backend_bases import (\n65     FigureCanvasBase, FigureManagerBase, MouseButton)\n66 from matplotlib.figure import Figure, FigureBase, figaspect\n67 from matplotlib.gridspec import GridSpec, SubplotSpec\n68 from matplotlib import rcsetup, rcParamsDefault, rcParamsOrig\n69 from matplotlib.artist import Artist\n70 from matplotlib.axes import Axes, Subplot  # type: ignore\n71 from matplotlib.projections import PolarAxes  # type: ignore\n72 from matplotlib import mlab  # for detrend_none, window_hanning\n73 from matplotlib.scale import get_scale_names\n74 \n75 from matplotlib.cm import _colormaps\n76 from matplotlib.cm import register_cmap  # type: ignore\n77 from matplotlib.colors import _color_sequences\n78 \n79 import numpy as np\n80 \n81 from typing import TYPE_CHECKING, cast\n82 \n83 if TYPE_CHECKING:\n84     from collections.abc import Callable, Hashable, Iterable, Sequence\n85     import datetime\n86     import pathlib\n87     import os\n88     from typing import Any, BinaryIO, Literal, TypeVar\n89     from typing_extensions import ParamSpec\n90 \n91     import PIL\n92     from numpy.typing import ArrayLike\n93 \n94     from matplotlib.axis import Tick\n95     from matplotlib.axes._base import _AxesBase\n96     from matplotlib.backend_bases import RendererBase, Event\n97     from matplotlib.cm import ScalarMappable\n98     from matplotlib.contour import ContourSet, QuadContourSet\n99     from matplotlib.collections import (\n100         Collection,\n101         LineCollection,\n102         BrokenBarHCollection,\n103         PolyCollection,\n104         PathCollection,\n105         EventCollection,\n106         QuadMesh,\n107     )\n108     from matplotlib.colorbar import Colorbar\n109     from matplotlib.colors import Colormap\n110     from matplotlib.container import (\n111         BarContainer,\n112         ErrorbarContainer,\n113         StemContainer,\n114     )\n115     from matplotlib.figure import SubFigure\n116     from matplotlib.legend import Legend\n117     from matplotlib.mlab import GaussianKDE\n118     from matplotlib.image import AxesImage, FigureImage\n119     from matplotlib.patches import FancyArrow, StepPatch, Wedge\n120     from matplotlib.quiver import Barbs, Quiver, QuiverKey\n121     from matplotlib.scale import ScaleBase\n122     from matplotlib.transforms import Transform, Bbox\n123     from matplotlib.typing import ColorType, LineStyleType, MarkerType, HashableList\n124     from matplotlib.widgets import SubplotTool\n125 \n126     _P = ParamSpec('_P')\n127     _R = TypeVar('_R')\n128 \n129 \n130 # We may not need the following imports here:\n131 from matplotlib.colors import Normalize\n132 from matplotlib.lines import Line2D\n133 from matplotlib.text import Text, Annotation\n134 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow\n135 from matplotlib.widgets import Button, Slider, Widget\n136 \n137 from .ticker import (\n138     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,\n139     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,\n140     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,\n141     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)\n142 \n143 _log = logging.getLogger(__name__)\n144 \n145 \n146 # Explicit rename instead of import-as for typing's sake.\n147 colormaps = _colormaps\n148 color_sequences = _color_sequences\n149 \n150 \n151 @overload\n152 def _copy_docstring_and_deprecators(\n153     method: Any,\n154     func: Literal[None] = None\n155 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]: ...\n156 \n157 \n158 @overload\n159 def _copy_docstring_and_deprecators(\n160     method: Any, func: Callable[_P, _R]) -> Callable[_P, _R]: ...\n161 \n162 \n163 def _copy_docstring_and_deprecators(\n164     method: Any,\n165     func: Callable[_P, _R] | None = None\n166 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]] | Callable[_P, _R]:\n167     if func is None:\n168         return cast('Callable[[Callable[_P, _R]], Callable[_P, _R]]',\n169                     functools.partial(_copy_docstring_and_deprecators, method))\n170     decorators: list[Callable[[Callable[_P, _R]], Callable[_P, _R]]] = [\n171         _docstring.copy(method)\n172     ]\n173     # Check whether the definition of *method* includes @_api.rename_parameter\n174     # or @_api.make_keyword_only decorators; if so, propagate them to the\n175     # pyplot wrapper as well.\n176     while hasattr(method, \"__wrapped__\"):\n177         potential_decorator = _api.deprecation.DECORATORS.get(method)\n178         if potential_decorator:\n179             decorators.append(potential_decorator)\n180         method = method.__wrapped__\n181     for decorator in decorators[::-1]:\n182         func = decorator(func)\n183     return func\n184 \n185 \n186 ## Global ##\n187 \n188 \n189 # The state controlled by {,un}install_repl_displayhook().\n190 _ReplDisplayHook = Enum(\"_ReplDisplayHook\", [\"NONE\", \"PLAIN\", \"IPYTHON\"])\n191 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n192 \n193 \n194 def _draw_all_if_interactive() -> None:\n195     if matplotlib.is_interactive():\n196         draw_all()\n197 \n198 \n199 def install_repl_displayhook() -> None:\n200     \"\"\"\n201     Connect to the display hook of the current shell.\n202 \n203     The display hook gets called when the read-evaluate-print-loop (REPL) of\n204     the shell has finished the execution of a command. We use this callback\n205     to be able to automatically update a figure in interactive mode.\n206 \n207     This works both with IPython and with vanilla python shells.\n208     \"\"\"\n209     global _REPL_DISPLAYHOOK\n210 \n211     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n212         return\n213 \n214     # See if we have IPython hooks around, if so use them.\n215     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as\n216     # entries can also have been explicitly set to None.\n217     mod_ipython = sys.modules.get(\"IPython\")\n218     if not mod_ipython:\n219         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n220         return\n221     ip = mod_ipython.get_ipython()\n222     if not ip:\n223         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n224         return\n225 \n226     ip.events.register(\"post_execute\", _draw_all_if_interactive)\n227     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON\n228 \n229     from IPython.core.pylabtools import backend2gui  # type: ignore\n230     # trigger IPython's eventloop integration, if available\n231     ipython_gui_name = backend2gui.get(get_backend())\n232     if ipython_gui_name:\n233         ip.enable_gui(ipython_gui_name)\n234 \n235 \n236 def uninstall_repl_displayhook() -> None:\n237     \"\"\"Disconnect from the display hook of the current shell.\"\"\"\n238     global _REPL_DISPLAYHOOK\n239     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n240         from IPython import get_ipython  # type: ignore\n241         ip = get_ipython()\n242         ip.events.unregister(\"post_execute\", _draw_all_if_interactive)\n243     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n244 \n245 \n246 draw_all = _pylab_helpers.Gcf.draw_all\n247 \n248 \n249 # Ensure this appears in the pyplot docs.\n250 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)\n251 def set_loglevel(*args, **kwargs) -> None:\n252     return matplotlib.set_loglevel(*args, **kwargs)\n253 \n254 \n255 @_copy_docstring_and_deprecators(Artist.findobj)\n256 def findobj(\n257     o: Artist | None = None,\n258     match: Callable[[Artist], bool] | type[Artist] | None = None,\n259     include_self: bool = True\n260 ) -> list[Artist]:\n261     if o is None:\n262         o = gcf()\n263     return o.findobj(match, include_self=include_self)\n264 \n265 \n266 _backend_mod: type[matplotlib.backend_bases._Backend] | None = None\n267 \n268 \n269 def _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:\n270     \"\"\"\n271     Ensure that a backend is selected and return it.\n272 \n273     This is currently private, but may be made public in the future.\n274     \"\"\"\n275     if _backend_mod is None:\n276         # Use rcParams._get(\"backend\") to avoid going through the fallback\n277         # logic (which will (re)import pyplot and then call switch_backend if\n278         # we need to resolve the auto sentinel)\n279         switch_backend(rcParams._get(\"backend\"))  # type: ignore[attr-defined]\n280     return cast(type[matplotlib.backend_bases._Backend], _backend_mod)\n281 \n282 \n283 def switch_backend(newbackend: str) -> None:\n284     \"\"\"\n285     Set the pyplot backend.\n286 \n287     Switching to an interactive backend is possible only if no event loop for\n288     another interactive backend has started.  Switching to and from\n289     non-interactive backends is always possible.\n290 \n291     If the new backend is different than the current backend then all open\n292     Figures will be closed via ``plt.close('all')``.\n293 \n294     Parameters\n295     ----------\n296     newbackend : str\n297         The case-insensitive name of the backend to use.\n298 \n299     \"\"\"\n300     global _backend_mod\n301     # make sure the init is pulled up so we can assign to it later\n302     import matplotlib.backends\n303 \n304     if newbackend is rcsetup._auto_backend_sentinel:\n305         current_framework = cbook._get_running_interactive_framework()\n306         mapping = {'qt': 'qtagg',\n307                    'gtk3': 'gtk3agg',\n308                    'gtk4': 'gtk4agg',\n309                    'wx': 'wxagg',\n310                    'tk': 'tkagg',\n311                    'macosx': 'macosx',\n312                    'headless': 'agg'}\n313 \n314         if current_framework in mapping:\n315             candidates = [mapping[current_framework]]\n316         else:\n317             candidates = []\n318         candidates += [\n319             \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n320 \n321         # Don't try to fallback on the cairo-based backends as they each have\n322         # an additional dependency (pycairo) over the agg-based backend, and\n323         # are of worse quality.\n324         for candidate in candidates:\n325             try:\n326                 switch_backend(candidate)\n327             except ImportError:\n328                 continue\n329             else:\n330                 rcParamsOrig['backend'] = candidate\n331                 return\n332         else:\n333             # Switching to Agg should always succeed; if it doesn't, let the\n334             # exception propagate out.\n335             switch_backend(\"agg\")\n336             rcParamsOrig[\"backend\"] = \"agg\"\n337             return\n338     # have to escape the switch on access logic\n339     old_backend = dict.__getitem__(rcParams, 'backend')\n340 \n341     module = importlib.import_module(cbook._backend_module_name(newbackend))\n342 \n343     required_framework = module.FigureCanvas.required_interactive_framework\n344     if required_framework is not None:\n345         current_framework = cbook._get_running_interactive_framework()\n346         if (current_framework and required_framework\n347                 and current_framework != required_framework):\n348             raise ImportError(\n349                 \"Cannot load backend {!r} which requires the {!r} interactive \"\n350                 \"framework, as {!r} is currently running\".format(\n351                     newbackend, required_framework, current_framework))\n352 \n353     # Load the new_figure_manager() and show() functions from the backend.\n354 \n355     # Classically, backends can directly export these functions.  This should\n356     # keep working for backcompat.\n357     new_figure_manager = getattr(module, \"new_figure_manager\", None)\n358     show = getattr(module, \"show\", None)\n359 \n360     # In that classical approach, backends are implemented as modules, but\n361     # \"inherit\" default method implementations from backend_bases._Backend.\n362     # This is achieved by creating a \"class\" that inherits from\n363     # backend_bases._Backend and whose body is filled with the module globals.\n364     class backend_mod(matplotlib.backend_bases._Backend):\n365         locals().update(vars(module))\n366 \n367     # However, the newer approach for defining new_figure_manager and\n368     # show is to derive them from canvas methods.  In that case, also\n369     # update backend_mod accordingly; also, per-backend customization of\n370     # draw_if_interactive is disabled.\n371     if new_figure_manager is None:\n372         # Only try to get the canvas class if have opted into the new scheme.\n373         canvas_class = backend_mod.FigureCanvas\n374 \n375         def new_figure_manager_given_figure(num, figure):\n376             return canvas_class.new_manager(figure, num)\n377 \n378         def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n379             fig = FigureClass(*args, **kwargs)\n380             return new_figure_manager_given_figure(num, fig)\n381 \n382         def draw_if_interactive() -> None:\n383             if matplotlib.is_interactive():\n384                 manager = _pylab_helpers.Gcf.get_active()\n385                 if manager:\n386                     manager.canvas.draw_idle()\n387 \n388         backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]\n389             new_figure_manager_given_figure)\n390         backend_mod.new_figure_manager = (  # type: ignore[method-assign]\n391             new_figure_manager)\n392         backend_mod.draw_if_interactive = (  # type: ignore[method-assign]\n393             draw_if_interactive)\n394 \n395     # If the manager explicitly overrides pyplot_show, use it even if a global\n396     # show is already present, as the latter may be here for backcompat.\n397     manager_class = getattr(getattr(backend_mod, \"FigureCanvas\", None),\n398                             \"manager_class\", None)\n399     # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because\n400     # pyplot_show is a classmethod so the above constructs are bound classmethods, and\n401     # thus always different (being bound to different classes).  We also have to use\n402     # getattr_static instead of vars as manager_class could have no __dict__.\n403     manager_pyplot_show = inspect.getattr_static(manager_class, \"pyplot_show\", None)\n404     base_pyplot_show = inspect.getattr_static(FigureManagerBase, \"pyplot_show\", None)\n405     if (show is None\n406             or (manager_pyplot_show is not None\n407                 and manager_pyplot_show != base_pyplot_show)):\n408         _pyplot_show = cast('Any', manager_class).pyplot_show\n409         backend_mod.show = _pyplot_show  # type: ignore[method-assign]\n410 \n411     _log.debug(\"Loaded backend %s version %s.\",\n412                newbackend, backend_mod.backend_version)\n413 \n414     rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n415     _backend_mod = backend_mod\n416     for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n417         globals()[func_name].__signature__ = inspect.signature(\n418             getattr(backend_mod, func_name))\n419 \n420     # Need to keep a global reference to the backend for compatibility reasons.\n421     # See https://github.com/matplotlib/matplotlib/issues/6092\n422     matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]\n423     if not cbook._str_equal(old_backend, newbackend):\n424         close(\"all\")\n425 \n426     # make sure the repl display hook is installed in case we become\n427     # interactive\n428     install_repl_displayhook()\n429 \n430 \n431 def _warn_if_gui_out_of_main_thread() -> None:\n432     warn = False\n433     canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)\n434     if canvas_class.required_interactive_framework:\n435         if hasattr(threading, 'get_native_id'):\n436             # This compares native thread ids because even if Python-level\n437             # Thread objects match, the underlying OS thread (which is what\n438             # really matters) may be different on Python implementations with\n439             # green threads.\n440             if threading.get_native_id() != threading.main_thread().native_id:\n441                 warn = True\n442         else:\n443             # Fall back to Python-level Thread if native IDs are unavailable,\n444             # mainly for PyPy.\n445             if threading.current_thread() is not threading.main_thread():\n446                 warn = True\n447     if warn:\n448         _api.warn_external(\n449             \"Starting a Matplotlib GUI outside of the main thread will likely \"\n450             \"fail.\")\n451 \n452 \n453 # This function's signature is rewritten upon backend-load by switch_backend.\n454 def new_figure_manager(*args, **kwargs):\n455     \"\"\"Create a new figure manager instance.\"\"\"\n456     _warn_if_gui_out_of_main_thread()\n457     return _get_backend_mod().new_figure_manager(*args, **kwargs)\n458 \n459 \n460 # This function's signature is rewritten upon backend-load by switch_backend.\n461 def draw_if_interactive(*args, **kwargs):\n462     \"\"\"\n463     Redraw the current figure if in interactive mode.\n464 \n465     .. warning::\n466 \n467         End users will typically not have to call this function because the\n468         the interactive mode takes care of this.\n469     \"\"\"\n470     return _get_backend_mod().draw_if_interactive(*args, **kwargs)\n471 \n472 \n473 # This function's signature is rewritten upon backend-load by switch_backend.\n474 def show(*args, **kwargs):\n475     \"\"\"\n476     Display all open figures.\n477 \n478     Parameters\n479     ----------\n480     block : bool, optional\n481         Whether to wait for all figures to be closed before returning.\n482 \n483         If `True` block and run the GUI main loop until all figure windows\n484         are closed.\n485 \n486         If `False` ensure that all figure windows are displayed and return\n487         immediately.  In this case, you are responsible for ensuring\n488         that the event loop is running to have responsive figures.\n489 \n490         Defaults to True in non-interactive mode and to False in interactive\n491         mode (see `.pyplot.isinteractive`).\n492 \n493     See Also\n494     --------\n495     ion : Enable interactive mode, which shows / updates the figure after\n496           every plotting command, so that calling ``show()`` is not necessary.\n497     ioff : Disable interactive mode.\n498     savefig : Save the figure to an image file instead of showing it on screen.\n499 \n500     Notes\n501     -----\n502     **Saving figures to file and showing a window at the same time**\n503 \n504     If you want an image file as well as a user interface window, use\n505     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)\n506     ``show()`` the figure is closed and thus unregistered from pyplot. Calling\n507     `.pyplot.savefig` afterwards would save a new and thus empty figure. This\n508     limitation of command order does not apply if the show is non-blocking or\n509     if you keep a reference to the figure and use `.Figure.savefig`.\n510 \n511     **Auto-show in jupyter notebooks**\n512 \n513     The jupyter backends (activated via ``%matplotlib inline``,\n514     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at\n515     the end of every cell by default. Thus, you usually don't have to call it\n516     explicitly there.\n517     \"\"\"\n518     _warn_if_gui_out_of_main_thread()\n519     return _get_backend_mod().show(*args, **kwargs)\n520 \n521 \n522 def isinteractive() -> bool:\n523     \"\"\"\n524     Return whether plots are updated after every plotting command.\n525 \n526     The interactive mode is mainly useful if you build plots from the command\n527     line and want to see the effect of each command while you are building the\n528     figure.\n529 \n530     In interactive mode:\n531 \n532     - newly created figures will be shown immediately;\n533     - figures will automatically redraw on change;\n534     - `.pyplot.show` will not block by default.\n535 \n536     In non-interactive mode:\n537 \n538     - newly created figures and changes to figures will not be reflected until\n539       explicitly asked to be;\n540     - `.pyplot.show` will block by default.\n541 \n542     See Also\n543     --------\n544     ion : Enable interactive mode.\n545     ioff : Disable interactive mode.\n546     show : Show all figures (and maybe block).\n547     pause : Show all figures, and block for a time.\n548     \"\"\"\n549     return matplotlib.is_interactive()\n550 \n551 \n552 def ioff() -> ExitStack:\n553     \"\"\"\n554     Disable interactive mode.\n555 \n556     See `.pyplot.isinteractive` for more details.\n557 \n558     See Also\n559     --------\n560     ion : Enable interactive mode.\n561     isinteractive : Whether interactive mode is enabled.\n562     show : Show all figures (and maybe block).\n563     pause : Show all figures, and block for a time.\n564 \n565     Notes\n566     -----\n567     For a temporary change, this can be used as a context manager::\n568 \n569         # if interactive mode is on\n570         # then figures will be shown on creation\n571         plt.ion()\n572         # This figure will be shown immediately\n573         fig = plt.figure()\n574 \n575         with plt.ioff():\n576             # interactive mode will be off\n577             # figures will not automatically be shown\n578             fig2 = plt.figure()\n579             # ...\n580 \n581     To enable optional usage as a context manager, this function returns a\n582     `~contextlib.ExitStack` object, which is not intended to be stored or\n583     accessed by the user.\n584     \"\"\"\n585     stack = ExitStack()\n586     stack.callback(ion if isinteractive() else ioff)\n587     matplotlib.interactive(False)\n588     uninstall_repl_displayhook()\n589     return stack\n590 \n591 \n592 def ion() -> ExitStack:\n593     \"\"\"\n594     Enable interactive mode.\n595 \n596     See `.pyplot.isinteractive` for more details.\n597 \n598     See Also\n599     --------\n600     ioff : Disable interactive mode.\n601     isinteractive : Whether interactive mode is enabled.\n602     show : Show all figures (and maybe block).\n603     pause : Show all figures, and block for a time.\n604 \n605     Notes\n606     -----\n607     For a temporary change, this can be used as a context manager::\n608 \n609         # if interactive mode is off\n610         # then figures will not be shown on creation\n611         plt.ioff()\n612         # This figure will not be shown immediately\n613         fig = plt.figure()\n614 \n615         with plt.ion():\n616             # interactive mode will be on\n617             # figures will automatically be shown\n618             fig2 = plt.figure()\n619             # ...\n620 \n621     To enable optional usage as a context manager, this function returns a\n622     `~contextlib.ExitStack` object, which is not intended to be stored or\n623     accessed by the user.\n624     \"\"\"\n625     stack = ExitStack()\n626     stack.callback(ion if isinteractive() else ioff)\n627     matplotlib.interactive(True)\n628     install_repl_displayhook()\n629     return stack\n630 \n631 \n632 def pause(interval: float) -> None:\n633     \"\"\"\n634     Run the GUI event loop for *interval* seconds.\n635 \n636     If there is an active figure, it will be updated and displayed before the\n637     pause, and the GUI event loop (if any) will run during the pause.\n638 \n639     This can be used for crude animation.  For more complex animation use\n640     :mod:`matplotlib.animation`.\n641 \n642     If there is no active figure, sleep for *interval* seconds instead.\n643 \n644     See Also\n645     --------\n646     matplotlib.animation : Proper animations\n647     show : Show all figures and optional block until all figures are closed.\n648     \"\"\"\n649     manager = _pylab_helpers.Gcf.get_active()\n650     if manager is not None:\n651         canvas = manager.canvas\n652         if canvas.figure.stale:\n653             canvas.draw_idle()\n654         show(block=False)\n655         canvas.start_event_loop(interval)\n656     else:\n657         time.sleep(interval)\n658 \n659 \n660 @_copy_docstring_and_deprecators(matplotlib.rc)\n661 def rc(group: str, **kwargs) -> None:\n662     matplotlib.rc(group, **kwargs)\n663 \n664 \n665 @_copy_docstring_and_deprecators(matplotlib.rc_context)\n666 def rc_context(\n667     rc: dict[str, Any] | None = None,\n668     fname: str | pathlib.Path | os.PathLike | None = None,\n669 ) -> AbstractContextManager[None]:\n670     return matplotlib.rc_context(rc, fname)\n671 \n672 \n673 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)\n674 def rcdefaults() -> None:\n675     matplotlib.rcdefaults()\n676     if matplotlib.is_interactive():\n677         draw_all()\n678 \n679 \n680 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.\n681 \n682 \n683 @_copy_docstring_and_deprecators(matplotlib.artist.getp)\n684 def getp(obj, *args, **kwargs):\n685     return matplotlib.artist.getp(obj, *args, **kwargs)\n686 \n687 \n688 @_copy_docstring_and_deprecators(matplotlib.artist.get)\n689 def get(obj, *args, **kwargs):\n690     return matplotlib.artist.get(obj, *args, **kwargs)\n691 \n692 \n693 @_copy_docstring_and_deprecators(matplotlib.artist.setp)\n694 def setp(obj, *args, **kwargs):\n695     return matplotlib.artist.setp(obj, *args, **kwargs)\n696 \n697 \n698 def xkcd(\n699     scale: float = 1, length: float = 100, randomness: float = 2\n700 ) -> ExitStack:\n701     \"\"\"\n702     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will\n703     only have effect on things drawn after this function is called.\n704 \n705     For best results, the \"Humor Sans\" font should be installed: it is\n706     not included with Matplotlib.\n707 \n708     Parameters\n709     ----------\n710     scale : float, optional\n711         The amplitude of the wiggle perpendicular to the source line.\n712     length : float, optional\n713         The length of the wiggle along the line.\n714     randomness : float, optional\n715         The scale factor by which the length is shrunken or expanded.\n716 \n717     Notes\n718     -----\n719     This function works by a number of rcParams, so it will probably\n720     override others you have set before.\n721 \n722     If you want the effects of this function to be temporary, it can\n723     be used as a context manager, for example::\n724 \n725         with plt.xkcd():\n726             # This figure will be in XKCD-style\n727             fig1 = plt.figure()\n728             # ...\n729 \n730         # This figure will be in regular style\n731         fig2 = plt.figure()\n732     \"\"\"\n733     # This cannot be implemented in terms of contextmanager() or rc_context()\n734     # because this needs to work as a non-contextmanager too.\n735 \n736     if rcParams['text.usetex']:\n737         raise RuntimeError(\n738             \"xkcd mode is not compatible with text.usetex = True\")\n739 \n740     stack = ExitStack()\n741     stack.callback(dict.update, rcParams, rcParams.copy())  # type: ignore\n742 \n743     from matplotlib import patheffects\n744     rcParams.update({\n745         'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',\n746                         'Comic Sans MS'],\n747         'font.size': 14.0,\n748         'path.sketch': (scale, length, randomness),\n749         'path.effects': [\n750             patheffects.withStroke(linewidth=4, foreground=\"w\")],\n751         'axes.linewidth': 1.5,\n752         'lines.linewidth': 2.0,\n753         'figure.facecolor': 'white',\n754         'grid.linewidth': 0.0,\n755         'axes.grid': False,\n756         'axes.unicode_minus': False,\n757         'axes.edgecolor': 'black',\n758         'xtick.major.size': 8,\n759         'xtick.major.width': 3,\n760         'ytick.major.size': 8,\n761         'ytick.major.width': 3,\n762     })\n763 \n764     return stack\n765 \n766 \n767 ## Figures ##\n768 \n769 def figure(\n770     # autoincrement if None, else integer from 1-N\n771     num: int | str | Figure | SubFigure | None = None,\n772     # defaults to rc figure.figsize\n773     figsize: tuple[float, float] | None = None,\n774     # defaults to rc figure.dpi\n775     dpi: float | None = None,\n776     *,\n777     # defaults to rc figure.facecolor\n778     facecolor: ColorType | None = None,\n779     # defaults to rc figure.edgecolor\n780     edgecolor: ColorType | None = None,\n781     frameon: bool = True,\n782     FigureClass: type[Figure] = Figure,\n783     clear: bool = False,\n784     **kwargs\n785 ) -> Figure:\n786     \"\"\"\n787     Create a new figure, or activate an existing figure.\n788 \n789     Parameters\n790     ----------\n791     num : int or str or `.Figure` or `.SubFigure`, optional\n792         A unique identifier for the figure.\n793 \n794         If a figure with that identifier already exists, this figure is made\n795         active and returned. An integer refers to the ``Figure.number``\n796         attribute, a string refers to the figure label.\n797 \n798         If there is no figure with the identifier or *num* is not given, a new\n799         figure is created, made active and returned.  If *num* is an int, it\n800         will be used for the ``Figure.number`` attribute, otherwise, an\n801         auto-generated integer value is used (starting at 1 and incremented\n802         for each new figure). If *num* is a string, the figure label and the\n803         window title is set to this value.  If num is a ``SubFigure``, its\n804         parent ``Figure`` is activated.\n805 \n806     figsize : (float, float), default: :rc:`figure.figsize`\n807         Width, height in inches.\n808 \n809     dpi : float, default: :rc:`figure.dpi`\n810         The resolution of the figure in dots-per-inch.\n811 \n812     facecolor : color, default: :rc:`figure.facecolor`\n813         The background color.\n814 \n815     edgecolor : color, default: :rc:`figure.edgecolor`\n816         The border color.\n817 \n818     frameon : bool, default: True\n819         If False, suppress drawing the figure frame.\n820 \n821     FigureClass : subclass of `~matplotlib.figure.Figure`\n822         If set, an instance of this subclass will be created, rather than a\n823         plain `.Figure`.\n824 \n825     clear : bool, default: False\n826         If True and the figure already exists, then it is cleared.\n827 \n828     layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \\\n829 default: None\n830         The layout mechanism for positioning of plot elements to avoid\n831         overlapping Axes decorations (labels, ticks, etc). Note that layout\n832         managers can measurably slow down figure display.\n833 \n834         - 'constrained': The constrained layout solver adjusts axes sizes\n835           to avoid overlapping axes decorations.  Can handle complex plot\n836           layouts and colorbars, and is thus recommended.\n837 \n838           See :ref:`constrainedlayout_guide`\n839           for examples.\n840 \n841         - 'compressed': uses the same algorithm as 'constrained', but\n842           removes extra space between fixed-aspect-ratio Axes.  Best for\n843           simple grids of axes.\n844 \n845         - 'tight': Use the tight layout mechanism. This is a relatively\n846           simple algorithm that adjusts the subplot parameters so that\n847           decorations do not overlap. See `.Figure.set_tight_layout` for\n848           further details.\n849 \n850         - 'none': Do not use a layout engine.\n851 \n852         - A `.LayoutEngine` instance. Builtin layout classes are\n853           `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily\n854           accessible by 'constrained' and 'tight'.  Passing an instance\n855           allows third parties to provide their own layout engine.\n856 \n857         If not given, fall back to using the parameters *tight_layout* and\n858         *constrained_layout*, including their config defaults\n859         :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.\n860 \n861     **kwargs\n862         Additional keyword arguments are passed to the `.Figure` constructor.\n863 \n864     Returns\n865     -------\n866     `~matplotlib.figure.Figure`\n867 \n868     Notes\n869     -----\n870     A newly created figure is passed to the `~.FigureCanvasBase.new_manager`\n871     method or the `new_figure_manager` function provided by the current\n872     backend, which install a canvas and a manager on the figure.\n873 \n874     Once this is done, :rc:`figure.hooks` are called, one at a time, on the\n875     figure; these hooks allow arbitrary customization of the figure (e.g.,\n876     attaching callbacks) or of associated elements (e.g., modifying the\n877     toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of\n878     toolbar customization.\n879 \n880     If you are creating many figures, make sure you explicitly call\n881     `.pyplot.close` on the figures you are not using, because this will\n882     enable pyplot to properly clean up the memory.\n883 \n884     `~matplotlib.rcParams` defines the default values, which can be modified\n885     in the matplotlibrc file.\n886     \"\"\"\n887     if isinstance(num, FigureBase):\n888         # type narrowed to `Figure | SubFigure` by combination of input and isinstance\n889         if num.canvas.manager is None:\n890             raise ValueError(\"The passed figure is not managed by pyplot\")\n891         _pylab_helpers.Gcf.set_active(num.canvas.manager)\n892         return num.figure\n893 \n894     allnums = get_fignums()\n895     next_num = max(allnums) + 1 if allnums else 1\n896     fig_label = ''\n897     if num is None:\n898         num = next_num\n899     elif isinstance(num, str):\n900         fig_label = num\n901         all_labels = get_figlabels()\n902         if fig_label not in all_labels:\n903             if fig_label == 'all':\n904                 _api.warn_external(\"close('all') closes all existing figures.\")\n905             num = next_num\n906         else:\n907             inum = all_labels.index(fig_label)\n908             num = allnums[inum]\n909     else:\n910         num = int(num)  # crude validation of num argument\n911 \n912     # Type of \"num\" has narrowed to int, but mypy can't quite see it\n913     manager = _pylab_helpers.Gcf.get_fig_manager(num)  # type: ignore[arg-type]\n914     if manager is None:\n915         max_open_warning = rcParams['figure.max_open_warning']\n916         if len(allnums) == max_open_warning >= 1:\n917             _api.warn_external(\n918                 f\"More than {max_open_warning} figures have been opened. \"\n919                 f\"Figures created through the pyplot interface \"\n920                 f\"(`matplotlib.pyplot.figure`) are retained until explicitly \"\n921                 f\"closed and may consume too much memory. (To control this \"\n922                 f\"warning, see the rcParam `figure.max_open_warning`). \"\n923                 f\"Consider using `matplotlib.pyplot.close()`.\",\n924                 RuntimeWarning)\n925 \n926         manager = new_figure_manager(\n927             num, figsize=figsize, dpi=dpi,\n928             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,\n929             FigureClass=FigureClass, **kwargs)\n930         fig = manager.canvas.figure\n931         if fig_label:\n932             fig.set_label(fig_label)\n933 \n934         for hookspecs in rcParams[\"figure.hooks\"]:\n935             module_name, dotted_name = hookspecs.split(\":\")\n936             obj = importlib.import_module(module_name)\n937             for part in dotted_name.split(\".\"):\n938                 obj = getattr(obj, part)\n939             obj(fig)\n940 \n941         _pylab_helpers.Gcf._set_new_active_manager(manager)\n942 \n943         # make sure backends (inline) that we don't ship that expect this\n944         # to be called in plotting commands to make the figure call show\n945         # still work.  There is probably a better way to do this in the\n946         # FigureManager base class.\n947         draw_if_interactive()\n948 \n949         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:\n950             fig.stale_callback = _auto_draw_if_interactive\n951 \n952     if clear:\n953         manager.canvas.figure.clear()\n954 \n955     return manager.canvas.figure\n956 \n957 \n958 def _auto_draw_if_interactive(fig, val):\n959     \"\"\"\n960     An internal helper function for making sure that auto-redrawing\n961     works as intended in the plain python repl.\n962 \n963     Parameters\n964     ----------\n965     fig : Figure\n966         A figure object which is assumed to be associated with a canvas\n967     \"\"\"\n968     if (val and matplotlib.is_interactive()\n969             and not fig.canvas.is_saving()\n970             and not fig.canvas._is_idle_drawing):\n971         # Some artists can mark themselves as stale in the middle of drawing\n972         # (e.g. axes position & tick labels being computed at draw time), but\n973         # this shouldn't trigger a redraw because the current redraw will\n974         # already take them into account.\n975         with fig.canvas._idle_draw_cntx():\n976             fig.canvas.draw_idle()\n977 \n978 \n979 def gcf() -> Figure:\n980     \"\"\"\n981     Get the current figure.\n982 \n983     If there is currently no figure on the pyplot figure stack, a new one is\n984     created using `~.pyplot.figure()`.  (To test whether there is currently a\n985     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`\n986     is empty.)\n987     \"\"\"\n988     manager = _pylab_helpers.Gcf.get_active()\n989     if manager is not None:\n990         return manager.canvas.figure\n991     else:\n992         return figure()\n993 \n994 \n995 def fignum_exists(num: int) -> bool:\n996     \"\"\"Return whether the figure with the given id exists.\"\"\"\n997     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()\n998 \n999 \n1000 def get_fignums() -> list[int]:\n1001     \"\"\"Return a list of existing figure numbers.\"\"\"\n1002     return sorted(_pylab_helpers.Gcf.figs)\n1003 \n1004 \n1005 def get_figlabels() -> list[Any]:\n1006     \"\"\"Return a list of existing figure labels.\"\"\"\n1007     managers = _pylab_helpers.Gcf.get_all_fig_managers()\n1008     managers.sort(key=lambda m: m.num)\n1009     return [m.canvas.figure.get_label() for m in managers]\n1010 \n1011 \n1012 def get_current_fig_manager() -> FigureManagerBase | None:\n1013     \"\"\"\n1014     Return the figure manager of the current figure.\n1015 \n1016     The figure manager is a container for the actual backend-depended window\n1017     that displays the figure on screen.\n1018 \n1019     If no current figure exists, a new one is created, and its figure\n1020     manager is returned.\n1021 \n1022     Returns\n1023     -------\n1024     `.FigureManagerBase` or backend-dependent subclass thereof\n1025     \"\"\"\n1026     return gcf().canvas.manager\n1027 \n1028 \n1029 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)\n1030 def connect(s: str, func: Callable[[Event], Any]) -> int:\n1031     return gcf().canvas.mpl_connect(s, func)\n1032 \n1033 \n1034 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)\n1035 def disconnect(cid: int) -> None:\n1036     gcf().canvas.mpl_disconnect(cid)\n1037 \n1038 \n1039 def close(fig: None | int | str | Figure | Literal[\"all\"] = None) -> None:\n1040     \"\"\"\n1041     Close a figure window.\n1042 \n1043     Parameters\n1044     ----------\n1045     fig : None or int or str or `.Figure`\n1046         The figure to close. There are a number of ways to specify this:\n1047 \n1048         - *None*: the current figure\n1049         - `.Figure`: the given `.Figure` instance\n1050         - ``int``: a figure number\n1051         - ``str``: a figure name\n1052         - 'all': all figures\n1053 \n1054     \"\"\"\n1055     if fig is None:\n1056         manager = _pylab_helpers.Gcf.get_active()\n1057         if manager is None:\n1058             return\n1059         else:\n1060             _pylab_helpers.Gcf.destroy(manager)\n1061     elif fig == 'all':\n1062         _pylab_helpers.Gcf.destroy_all()\n1063     elif isinstance(fig, int):\n1064         _pylab_helpers.Gcf.destroy(fig)\n1065     elif hasattr(fig, 'int'):\n1066         # if we are dealing with a type UUID, we\n1067         # can use its integer representation\n1068         _pylab_helpers.Gcf.destroy(fig.int)\n1069     elif isinstance(fig, str):\n1070         all_labels = get_figlabels()\n1071         if fig in all_labels:\n1072             num = get_fignums()[all_labels.index(fig)]\n1073             _pylab_helpers.Gcf.destroy(num)\n1074     elif isinstance(fig, Figure):\n1075         _pylab_helpers.Gcf.destroy_fig(fig)\n1076     else:\n1077         raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n1078                         \"or None, not %s\" % type(fig))\n1079 \n1080 \n1081 def clf() -> None:\n1082     \"\"\"Clear the current figure.\"\"\"\n1083     gcf().clear()\n1084 \n1085 \n1086 def draw() -> None:\n1087     \"\"\"\n1088     Redraw the current figure.\n1089 \n1090     This is used to update a figure that has been altered, but not\n1091     automatically re-drawn.  If interactive mode is on (via `.ion()`), this\n1092     should be only rarely needed, but there may be ways to modify the state of\n1093     a figure without marking it as \"stale\".  Please report these cases as bugs.\n1094 \n1095     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is\n1096     the current figure.\n1097 \n1098     See Also\n1099     --------\n1100     .FigureCanvasBase.draw_idle\n1101     .FigureCanvasBase.draw\n1102     \"\"\"\n1103     gcf().canvas.draw_idle()\n1104 \n1105 \n1106 @_copy_docstring_and_deprecators(Figure.savefig)\n1107 def savefig(*args, **kwargs) -> None:\n1108     fig = gcf()\n1109     # savefig default implementation has no return, so mypy is unhappy\n1110     # presumably this is here because subclasses can return?\n1111     res = fig.savefig(*args, **kwargs)  # type: ignore[func-returns-value]\n1112     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.\n1113     return res\n1114 \n1115 \n1116 ## Putting things in figures ##\n1117 \n1118 \n1119 def figlegend(*args, **kwargs) -> Legend:\n1120     return gcf().legend(*args, **kwargs)\n1121 if Figure.legend.__doc__:\n1122     figlegend.__doc__ = Figure.legend.__doc__ \\\n1123         .replace(\" legend(\", \" figlegend(\") \\\n1124         .replace(\"fig.legend(\", \"plt.figlegend(\") \\\n1125         .replace(\"ax.plot(\", \"plt.plot(\")\n1126 \n1127 \n1128 ## Axes ##\n1129 \n1130 @_docstring.dedent_interpd\n1131 def axes(\n1132     arg: None | tuple[float, float, float, float] = None,\n1133     **kwargs\n1134 ) -> matplotlib.axes.Axes:\n1135     \"\"\"\n1136     Add an Axes to the current figure and make it the current Axes.\n1137 \n1138     Call signatures::\n1139 \n1140         plt.axes()\n1141         plt.axes(rect, projection=None, polar=False, **kwargs)\n1142         plt.axes(ax)\n1143 \n1144     Parameters\n1145     ----------\n1146     arg : None or 4-tuple\n1147         The exact behavior of this function depends on the type:\n1148 \n1149         - *None*: A new full window Axes is added using\n1150           ``subplot(**kwargs)``.\n1151         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.\n1152           A new Axes is added with dimensions *rect* in normalized\n1153           (0, 1) units using `~.Figure.add_axes` on the current figure.\n1154 \n1155     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1156 'polar', 'rectilinear', str}, optional\n1157         The projection type of the `~.axes.Axes`. *str* is the name of\n1158         a custom projection, see `~matplotlib.projections`. The default\n1159         None results in a 'rectilinear' projection.\n1160 \n1161     polar : bool, default: False\n1162         If True, equivalent to projection='polar'.\n1163 \n1164     sharex, sharey : `~matplotlib.axes.Axes`, optional\n1165         Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n1166         The axis will have the same limits, ticks, and scale as the axis\n1167         of the shared Axes.\n1168 \n1169     label : str\n1170         A label for the returned Axes.\n1171 \n1172     Returns\n1173     -------\n1174     `~.axes.Axes`, or a subclass of `~.axes.Axes`\n1175         The returned axes class depends on the projection used. It is\n1176         `~.axes.Axes` if rectilinear projection is used and\n1177         `.projections.polar.PolarAxes` if polar projection is used.\n1178 \n1179     Other Parameters\n1180     ----------------\n1181     **kwargs\n1182         This method also takes the keyword arguments for\n1183         the returned Axes class. The keyword arguments for the\n1184         rectilinear Axes class `~.axes.Axes` can be found in\n1185         the following table but there might also be other keyword\n1186         arguments if another projection is used, see the actual Axes\n1187         class.\n1188 \n1189         %(Axes:kwdoc)s\n1190 \n1191     See Also\n1192     --------\n1193     .Figure.add_axes\n1194     .pyplot.subplot\n1195     .Figure.add_subplot\n1196     .Figure.subplots\n1197     .pyplot.subplots\n1198 \n1199     Examples\n1200     --------\n1201     ::\n1202 \n1203         # Creating a new full window Axes\n1204         plt.axes()\n1205 \n1206         # Creating a new Axes with specified dimensions and a grey background\n1207         plt.axes((left, bottom, width, height), facecolor='grey')\n1208     \"\"\"\n1209     fig = gcf()\n1210     pos = kwargs.pop('position', None)\n1211     if arg is None:\n1212         if pos is None:\n1213             return fig.add_subplot(**kwargs)\n1214         else:\n1215             return fig.add_axes(pos, **kwargs)\n1216     else:\n1217         return fig.add_axes(arg, **kwargs)\n1218 \n1219 \n1220 def delaxes(ax: matplotlib.axes.Axes | None = None) -> None:\n1221     \"\"\"\n1222     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.\n1223     \"\"\"\n1224     if ax is None:\n1225         ax = gca()\n1226     ax.remove()\n1227 \n1228 \n1229 def sca(ax: Axes) -> None:\n1230     \"\"\"\n1231     Set the current Axes to *ax* and the current Figure to the parent of *ax*.\n1232     \"\"\"\n1233     # Mypy sees ax.figure as potentially None,\n1234     # but if you are calling this, it won't be None\n1235     # Additionally the slight difference between `Figure` and `FigureBase` mypy catches\n1236     figure(ax.figure)  # type: ignore[arg-type]\n1237     ax.figure.sca(ax)  # type: ignore[union-attr]\n1238 \n1239 \n1240 def cla() -> None:\n1241     \"\"\"Clear the current axes.\"\"\"\n1242     # Not generated via boilerplate.py to allow a different docstring.\n1243     return gca().cla()\n1244 \n1245 \n1246 ## More ways of creating axes ##\n1247 \n1248 @_docstring.dedent_interpd\n1249 def subplot(*args, **kwargs) -> Axes:\n1250     \"\"\"\n1251     Add an Axes to the current figure or retrieve an existing Axes.\n1252 \n1253     This is a wrapper of `.Figure.add_subplot` which provides additional\n1254     behavior when working with the implicit API (see the notes section).\n1255 \n1256     Call signatures::\n1257 \n1258        subplot(nrows, ncols, index, **kwargs)\n1259        subplot(pos, **kwargs)\n1260        subplot(**kwargs)\n1261        subplot(ax)\n1262 \n1263     Parameters\n1264     ----------\n1265     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n1266         The position of the subplot described by one of\n1267 \n1268         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the\n1269           *index* position on a grid with *nrows* rows and *ncols* columns.\n1270           *index* starts at 1 in the upper left corner and increases to the\n1271           right. *index* can also be a two-tuple specifying the (*first*,\n1272           *last*) indices (1-based, and including *last*) of the subplot, e.g.,\n1273           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the\n1274           upper 2/3 of the figure.\n1275         - A 3-digit integer. The digits are interpreted as if given separately\n1276           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the\n1277           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n1278           if there are no more than 9 subplots.\n1279         - A `.SubplotSpec`.\n1280 \n1281     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1282 'polar', 'rectilinear', str}, optional\n1283         The projection type of the subplot (`~.axes.Axes`). *str* is the name\n1284         of a custom projection, see `~matplotlib.projections`. The default\n1285         None results in a 'rectilinear' projection.\n1286 \n1287     polar : bool, default: False\n1288         If True, equivalent to projection='polar'.\n1289 \n1290     sharex, sharey : `~matplotlib.axes.Axes`, optional\n1291         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n1292         axis will have the same limits, ticks, and scale as the axis of the\n1293         shared axes.\n1294 \n1295     label : str\n1296         A label for the returned axes.\n1297 \n1298     Returns\n1299     -------\n1300     `~.axes.Axes`\n1301 \n1302         The Axes of the subplot. The returned Axes can actually be an instance\n1303         of a subclass, such as `.projections.polar.PolarAxes` for polar\n1304         projections.\n1305 \n1306     Other Parameters\n1307     ----------------\n1308     **kwargs\n1309         This method also takes the keyword arguments for the returned axes\n1310         base class; except for the *figure* argument. The keyword arguments\n1311         for the rectilinear base class `~.axes.Axes` can be found in\n1312         the following table but there might also be other keyword\n1313         arguments if another projection is used.\n1314 \n1315         %(Axes:kwdoc)s\n1316 \n1317     Notes\n1318     -----\n1319     Creating a new Axes will delete any preexisting Axes that\n1320     overlaps with it beyond sharing a boundary::\n1321 \n1322         import matplotlib.pyplot as plt\n1323         # plot a line, implicitly creating a subplot(111)\n1324         plt.plot([1, 2, 3])\n1325         # now create a subplot which represents the top plot of a grid\n1326         # with 2 rows and 1 column. Since this subplot will overlap the\n1327         # first, the plot (and its axes) previously created, will be removed\n1328         plt.subplot(211)\n1329 \n1330     If you do not want this behavior, use the `.Figure.add_subplot` method\n1331     or the `.pyplot.axes` function instead.\n1332 \n1333     If no *kwargs* are passed and there exists an Axes in the location\n1334     specified by *args* then that Axes will be returned rather than a new\n1335     Axes being created.\n1336 \n1337     If *kwargs* are passed and there exists an Axes in the location\n1338     specified by *args*, the projection type is the same, and the\n1339     *kwargs* match with the existing Axes, then the existing Axes is\n1340     returned.  Otherwise a new Axes is created with the specified\n1341     parameters.  We save a reference to the *kwargs* which we use\n1342     for this comparison.  If any of the values in *kwargs* are\n1343     mutable we will not detect the case where they are mutated.\n1344     In these cases we suggest using `.Figure.add_subplot` and the\n1345     explicit Axes API rather than the implicit pyplot API.\n1346 \n1347     See Also\n1348     --------\n1349     .Figure.add_subplot\n1350     .pyplot.subplots\n1351     .pyplot.axes\n1352     .Figure.subplots\n1353 \n1354     Examples\n1355     --------\n1356     ::\n1357 \n1358         plt.subplot(221)\n1359 \n1360         # equivalent but more general\n1361         ax1 = plt.subplot(2, 2, 1)\n1362 \n1363         # add a subplot with no frame\n1364         ax2 = plt.subplot(222, frameon=False)\n1365 \n1366         # add a polar subplot\n1367         plt.subplot(223, projection='polar')\n1368 \n1369         # add a red subplot that shares the x-axis with ax1\n1370         plt.subplot(224, sharex=ax1, facecolor='red')\n1371 \n1372         # delete ax2 from the figure\n1373         plt.delaxes(ax2)\n1374 \n1375         # add ax2 to the figure again\n1376         plt.subplot(ax2)\n1377 \n1378         # make the first axes \"current\" again\n1379         plt.subplot(221)\n1380 \n1381     \"\"\"\n1382     # Here we will only normalize `polar=True` vs `projection='polar'` and let\n1383     # downstream code deal with the rest.\n1384     unset = object()\n1385     projection = kwargs.get('projection', unset)\n1386     polar = kwargs.pop('polar', unset)\n1387     if polar is not unset and polar:\n1388         # if we got mixed messages from the user, raise\n1389         if projection is not unset and projection != 'polar':\n1390             raise ValueError(\n1391                 f\"polar={polar}, yet projection={projection!r}. \"\n1392                 \"Only one of these arguments should be supplied.\"\n1393             )\n1394         kwargs['projection'] = projection = 'polar'\n1395 \n1396     # if subplot called without arguments, create subplot(1, 1, 1)\n1397     if len(args) == 0:\n1398         args = (1, 1, 1)\n1399 \n1400     # This check was added because it is very easy to type subplot(1, 2, False)\n1401     # when subplots(1, 2, False) was intended (sharex=False, that is). In most\n1402     # cases, no error will ever occur, but mysterious behavior can result\n1403     # because what was intended to be the sharex argument is instead treated as\n1404     # a subplot index for subplot()\n1405     if len(args) >= 3 and isinstance(args[2], bool):\n1406         _api.warn_external(\"The subplot index argument to subplot() appears \"\n1407                            \"to be a boolean. Did you intend to use \"\n1408                            \"subplots()?\")\n1409     # Check for nrows and ncols, which are not valid subplot args:\n1410     if 'nrows' in kwargs or 'ncols' in kwargs:\n1411         raise TypeError(\"subplot() got an unexpected keyword argument 'ncols' \"\n1412                         \"and/or 'nrows'.  Did you intend to call subplots()?\")\n1413 \n1414     fig = gcf()\n1415 \n1416     # First, search for an existing subplot with a matching spec.\n1417     key = SubplotSpec._from_subplot_args(fig, args)\n1418 \n1419     for ax in fig.axes:\n1420         # If we found an Axes at the position, we can re-use it if the user passed no\n1421         # kwargs or if the axes class and kwargs are identical.\n1422         if (ax.get_subplotspec() == key\n1423             and (kwargs == {}\n1424                  or (ax._projection_init\n1425                      == fig._process_projection_requirements(**kwargs)))):\n1426             break\n1427     else:\n1428         # we have exhausted the known Axes and none match, make a new one!\n1429         ax = fig.add_subplot(*args, **kwargs)\n1430 \n1431     fig.sca(ax)\n1432 \n1433     return ax\n1434 \n1435 \n1436 def subplots(\n1437     nrows: int = 1, ncols: int = 1, *,\n1438     sharex: bool | Literal[\"none\", \"all\", \"row\", \"col\"] = False,\n1439     sharey: bool | Literal[\"none\", \"all\", \"row\", \"col\"] = False,\n1440     squeeze: bool = True,\n1441     width_ratios: Sequence[float] | None = None,\n1442     height_ratios: Sequence[float] | None = None,\n1443     subplot_kw: dict[str, Any] | None = None,\n1444     gridspec_kw: dict[str, Any] | None = None,\n1445     **fig_kw\n1446 ) -> tuple[Figure, Any]:\n1447     \"\"\"\n1448     Create a figure and a set of subplots.\n1449 \n1450     This utility wrapper makes it convenient to create common layouts of\n1451     subplots, including the enclosing figure object, in a single call.\n1452 \n1453     Parameters\n1454     ----------\n1455     nrows, ncols : int, default: 1\n1456         Number of rows/columns of the subplot grid.\n1457 \n1458     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n1459         Controls sharing of properties among x (*sharex*) or y (*sharey*)\n1460         axes:\n1461 \n1462         - True or 'all': x- or y-axis will be shared among all subplots.\n1463         - False or 'none': each subplot x- or y-axis will be independent.\n1464         - 'row': each subplot row will share an x- or y-axis.\n1465         - 'col': each subplot column will share an x- or y-axis.\n1466 \n1467         When subplots have a shared x-axis along a column, only the x tick\n1468         labels of the bottom subplot are created. Similarly, when subplots\n1469         have a shared y-axis along a row, only the y tick labels of the first\n1470         column subplot are created. To later turn other subplots' ticklabels\n1471         on, use `~matplotlib.axes.Axes.tick_params`.\n1472 \n1473         When subplots have a shared axis that has units, calling\n1474         `~matplotlib.axis.Axis.set_units` will update each axis with the\n1475         new units.\n1476 \n1477     squeeze : bool, default: True\n1478         - If True, extra dimensions are squeezed out from the returned\n1479           array of `~matplotlib.axes.Axes`:\n1480 \n1481           - if only one subplot is constructed (nrows=ncols=1), the\n1482             resulting single Axes object is returned as a scalar.\n1483           - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n1484             object array of Axes objects.\n1485           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n1486 \n1487         - If False, no squeezing at all is done: the returned Axes object is\n1488           always a 2D array containing Axes instances, even if it ends up\n1489           being 1x1.\n1490 \n1491     width_ratios : array-like of length *ncols*, optional\n1492         Defines the relative widths of the columns. Each column gets a\n1493         relative width of ``width_ratios[i] / sum(width_ratios)``.\n1494         If not given, all columns will have the same width.  Equivalent\n1495         to ``gridspec_kw={'width_ratios': [...]}``.\n1496 \n1497     height_ratios : array-like of length *nrows*, optional\n1498         Defines the relative heights of the rows. Each row gets a\n1499         relative height of ``height_ratios[i] / sum(height_ratios)``.\n1500         If not given, all rows will have the same height. Convenience\n1501         for ``gridspec_kw={'height_ratios': [...]}``.\n1502 \n1503     subplot_kw : dict, optional\n1504         Dict with keywords passed to the\n1505         `~matplotlib.figure.Figure.add_subplot` call used to create each\n1506         subplot.\n1507 \n1508     gridspec_kw : dict, optional\n1509         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`\n1510         constructor used to create the grid the subplots are placed on.\n1511 \n1512     **fig_kw\n1513         All additional keyword arguments are passed to the\n1514         `.pyplot.figure` call.\n1515 \n1516     Returns\n1517     -------\n1518     fig : `.Figure`\n1519 \n1520     ax : `~matplotlib.axes.Axes` or array of Axes\n1521         *ax* can be either a single `~.axes.Axes` object, or an array of Axes\n1522         objects if more than one subplot was created.  The dimensions of the\n1523         resulting array can be controlled with the squeeze keyword, see above.\n1524 \n1525         Typical idioms for handling the return value are::\n1526 \n1527             # using the variable ax for single a Axes\n1528             fig, ax = plt.subplots()\n1529 \n1530             # using the variable axs for multiple Axes\n1531             fig, axs = plt.subplots(2, 2)\n1532 \n1533             # using tuple unpacking for multiple Axes\n1534             fig, (ax1, ax2) = plt.subplots(1, 2)\n1535             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n1536 \n1537         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``\n1538         because for the latter it's not clear if it refers to a single\n1539         `~.axes.Axes` instance or a collection of these.\n1540 \n1541     See Also\n1542     --------\n1543     .pyplot.figure\n1544     .pyplot.subplot\n1545     .pyplot.axes\n1546     .Figure.subplots\n1547     .Figure.add_subplot\n1548 \n1549     Examples\n1550     --------\n1551     ::\n1552 \n1553         # First create some toy data:\n1554         x = np.linspace(0, 2*np.pi, 400)\n1555         y = np.sin(x**2)\n1556 \n1557         # Create just a figure and only one subplot\n1558         fig, ax = plt.subplots()\n1559         ax.plot(x, y)\n1560         ax.set_title('Simple plot')\n1561 \n1562         # Create two subplots and unpack the output array immediately\n1563         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n1564         ax1.plot(x, y)\n1565         ax1.set_title('Sharing Y axis')\n1566         ax2.scatter(x, y)\n1567 \n1568         # Create four polar axes and access them through the returned array\n1569         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection=\"polar\"))\n1570         axs[0, 0].plot(x, y)\n1571         axs[1, 1].scatter(x, y)\n1572 \n1573         # Share a X axis with each column of subplots\n1574         plt.subplots(2, 2, sharex='col')\n1575 \n1576         # Share a Y axis with each row of subplots\n1577         plt.subplots(2, 2, sharey='row')\n1578 \n1579         # Share both X and Y axes with all subplots\n1580         plt.subplots(2, 2, sharex='all', sharey='all')\n1581 \n1582         # Note that this is the same as\n1583         plt.subplots(2, 2, sharex=True, sharey=True)\n1584 \n1585         # Create figure number 10 with a single subplot\n1586         # and clears it if it already exists.\n1587         fig, ax = plt.subplots(num=10, clear=True)\n1588 \n1589     \"\"\"\n1590     fig = figure(**fig_kw)\n1591     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n1592                        squeeze=squeeze, subplot_kw=subplot_kw,\n1593                        gridspec_kw=gridspec_kw, height_ratios=height_ratios,\n1594                        width_ratios=width_ratios)\n1595     return fig, axs\n1596 \n1597 \n1598 def subplot_mosaic(\n1599     mosaic: str | HashableList,\n1600     *,\n1601     sharex: bool = False,\n1602     sharey: bool = False,\n1603     width_ratios: ArrayLike | None = None,\n1604     height_ratios: ArrayLike | None = None,\n1605     empty_sentinel: Any = '.',\n1606     subplot_kw: dict[str, Any] | None = None,\n1607     gridspec_kw: dict[str, Any] | None = None,\n1608     per_subplot_kw: dict[Hashable, dict[str, Any]] | None = None,\n1609     **fig_kw\n1610 ) -> tuple[Figure, dict[Hashable, matplotlib.axes.Axes]]:\n1611     \"\"\"\n1612     Build a layout of Axes based on ASCII art or nested lists.\n1613 \n1614     This is a helper function to build complex GridSpec layouts visually.\n1615 \n1616     See :ref:`mosaic`\n1617     for an example and full API documentation\n1618 \n1619     Parameters\n1620     ----------\n1621     mosaic : list of list of {hashable or nested} or str\n1622 \n1623         A visual layout of how you want your Axes to be arranged\n1624         labeled as strings.  For example ::\n1625 \n1626            x = [['A panel', 'A panel', 'edge'],\n1627                 ['C panel', '.',       'edge']]\n1628 \n1629         produces 4 axes:\n1630 \n1631         - 'A panel' which is 1 row high and spans the first two columns\n1632         - 'edge' which is 2 rows high and is on the right edge\n1633         - 'C panel' which in 1 row and 1 column wide in the bottom left\n1634         - a blank space 1 row and 1 column wide in the bottom center\n1635 \n1636         Any of the entries in the layout can be a list of lists\n1637         of the same form to create nested layouts.\n1638 \n1639         If input is a str, then it must be of the form ::\n1640 \n1641           '''\n1642           AAE\n1643           C.E\n1644           '''\n1645 \n1646         where each character is a column and each line is a row.\n1647         This only allows only single character Axes labels and does\n1648         not allow nesting but is very terse.\n1649 \n1650     sharex, sharey : bool, default: False\n1651         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1652         among all subplots.  In that case, tick label visibility and axis units\n1653         behave as for `subplots`.  If False, each subplot's x- or y-axis will\n1654         be independent.\n1655 \n1656     width_ratios : array-like of length *ncols*, optional\n1657         Defines the relative widths of the columns. Each column gets a\n1658         relative width of ``width_ratios[i] / sum(width_ratios)``.\n1659         If not given, all columns will have the same width.  Convenience\n1660         for ``gridspec_kw={'width_ratios': [...]}``.\n1661 \n1662     height_ratios : array-like of length *nrows*, optional\n1663         Defines the relative heights of the rows. Each row gets a\n1664         relative height of ``height_ratios[i] / sum(height_ratios)``.\n1665         If not given, all rows will have the same height. Convenience\n1666         for ``gridspec_kw={'height_ratios': [...]}``.\n1667 \n1668     empty_sentinel : object, optional\n1669         Entry in the layout to mean \"leave this space empty\".  Defaults\n1670         to ``'.'``. Note, if *layout* is a string, it is processed via\n1671         `inspect.cleandoc` to remove leading white space, which may\n1672         interfere with using white-space as the empty sentinel.\n1673 \n1674     subplot_kw : dict, optional\n1675         Dictionary with keywords passed to the `.Figure.add_subplot` call\n1676         used to create each subplot.  These values may be overridden by\n1677         values in *per_subplot_kw*.\n1678 \n1679     per_subplot_kw : dict, optional\n1680         A dictionary mapping the Axes identifiers or tuples of identifiers\n1681         to a dictionary of keyword arguments to be passed to the\n1682         `.Figure.add_subplot` call used to create each subplot.  The values\n1683         in these dictionaries have precedence over the values in\n1684         *subplot_kw*.\n1685 \n1686         If *mosaic* is a string, and thus all keys are single characters,\n1687         it is possible to use a single string instead of a tuple as keys;\n1688         i.e. ``\"AB\"`` is equivalent to ``(\"A\", \"B\")``.\n1689 \n1690         .. versionadded:: 3.7\n1691 \n1692     gridspec_kw : dict, optional\n1693         Dictionary with keywords passed to the `.GridSpec` constructor used\n1694         to create the grid the subplots are placed on.\n1695 \n1696     **fig_kw\n1697         All additional keyword arguments are passed to the\n1698         `.pyplot.figure` call.\n1699 \n1700     Returns\n1701     -------\n1702     fig : `.Figure`\n1703        The new figure\n1704 \n1705     dict[label, Axes]\n1706        A dictionary mapping the labels to the Axes objects.  The order of\n1707        the axes is left-to-right and top-to-bottom of their position in the\n1708        total layout.\n1709 \n1710     \"\"\"\n1711     fig = figure(**fig_kw)\n1712     ax_dict = fig.subplot_mosaic(\n1713         mosaic, sharex=sharex, sharey=sharey,\n1714         height_ratios=height_ratios, width_ratios=width_ratios,\n1715         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,\n1716         empty_sentinel=empty_sentinel,\n1717         per_subplot_kw=per_subplot_kw,\n1718     )\n1719     return fig, ax_dict\n1720 \n1721 \n1722 def subplot2grid(\n1723     shape: tuple[int, int], loc: tuple[int, int],\n1724     rowspan: int = 1, colspan: int = 1,\n1725     fig: Figure | None = None,\n1726     **kwargs\n1727 ) -> matplotlib.axes.Axes:\n1728     \"\"\"\n1729     Create a subplot at a specific location inside a regular grid.\n1730 \n1731     Parameters\n1732     ----------\n1733     shape : (int, int)\n1734         Number of rows and of columns of the grid in which to place axis.\n1735     loc : (int, int)\n1736         Row number and column number of the axis location within the grid.\n1737     rowspan : int, default: 1\n1738         Number of rows for the axis to span downwards.\n1739     colspan : int, default: 1\n1740         Number of columns for the axis to span to the right.\n1741     fig : `.Figure`, optional\n1742         Figure to place the subplot in. Defaults to the current figure.\n1743     **kwargs\n1744         Additional keyword arguments are handed to `~.Figure.add_subplot`.\n1745 \n1746     Returns\n1747     -------\n1748     `~.axes.Axes`\n1749 \n1750         The Axes of the subplot. The returned Axes can actually be an instance\n1751         of a subclass, such as `.projections.polar.PolarAxes` for polar\n1752         projections.\n1753 \n1754     Notes\n1755     -----\n1756     The following call ::\n1757 \n1758         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)\n1759 \n1760     is identical to ::\n1761 \n1762         fig = gcf()\n1763         gs = fig.add_gridspec(nrows, ncols)\n1764         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])\n1765     \"\"\"\n1766     if fig is None:\n1767         fig = gcf()\n1768     rows, cols = shape\n1769     gs = GridSpec._check_gridspec_exists(fig, rows, cols)\n1770     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)\n1771     return fig.add_subplot(subplotspec, **kwargs)\n1772 \n1773 \n1774 def twinx(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:\n1775     \"\"\"\n1776     Make and return a second axes that shares the *x*-axis.  The new axes will\n1777     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n1778     on the right.\n1779 \n1780     Examples\n1781     --------\n1782     :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1783     \"\"\"\n1784     if ax is None:\n1785         ax = gca()\n1786     ax1 = ax.twinx()\n1787     return ax1\n1788 \n1789 \n1790 def twiny(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:\n1791     \"\"\"\n1792     Make and return a second axes that shares the *y*-axis.  The new axes will\n1793     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n1794     on the top.\n1795 \n1796     Examples\n1797     --------\n1798     :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1799     \"\"\"\n1800     if ax is None:\n1801         ax = gca()\n1802     ax1 = ax.twiny()\n1803     return ax1\n1804 \n1805 \n1806 def subplot_tool(targetfig: Figure | None = None) -> SubplotTool | None:\n1807     \"\"\"\n1808     Launch a subplot tool window for a figure.\n1809 \n1810     Returns\n1811     -------\n1812     `matplotlib.widgets.SubplotTool`\n1813     \"\"\"\n1814     if targetfig is None:\n1815         targetfig = gcf()\n1816     tb = targetfig.canvas.manager.toolbar  # type: ignore[union-attr]\n1817     if hasattr(tb, \"configure_subplots\"):  # toolbar2\n1818         from matplotlib.backend_bases import NavigationToolbar2\n1819         return cast(NavigationToolbar2, tb).configure_subplots()\n1820     elif hasattr(tb, \"trigger_tool\"):  # toolmanager\n1821         from matplotlib.backend_bases import ToolContainerBase\n1822         cast(ToolContainerBase, tb).trigger_tool(\"subplots\")\n1823         return None\n1824     else:\n1825         raise ValueError(\"subplot_tool can only be launched for figures with \"\n1826                          \"an associated toolbar\")\n1827 \n1828 \n1829 def box(on: bool | None = None) -> None:\n1830     \"\"\"\n1831     Turn the axes box on or off on the current axes.\n1832 \n1833     Parameters\n1834     ----------\n1835     on : bool or None\n1836         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle\n1837         the state.\n1838 \n1839     See Also\n1840     --------\n1841     :meth:`matplotlib.axes.Axes.set_frame_on`\n1842     :meth:`matplotlib.axes.Axes.get_frame_on`\n1843     \"\"\"\n1844     ax = gca()\n1845     if on is None:\n1846         on = not ax.get_frame_on()\n1847     ax.set_frame_on(on)\n1848 \n1849 ## Axis ##\n1850 \n1851 \n1852 def xlim(*args, **kwargs) -> tuple[float, float]:\n1853     \"\"\"\n1854     Get or set the x limits of the current axes.\n1855 \n1856     Call signatures::\n1857 \n1858         left, right = xlim()  # return the current xlim\n1859         xlim((left, right))   # set the xlim to left, right\n1860         xlim(left, right)     # set the xlim to left, right\n1861 \n1862     If you do not specify args, you can pass *left* or *right* as kwargs,\n1863     i.e.::\n1864 \n1865         xlim(right=3)  # adjust the right leaving left unchanged\n1866         xlim(left=1)  # adjust the left leaving right unchanged\n1867 \n1868     Setting limits turns autoscaling off for the x-axis.\n1869 \n1870     Returns\n1871     -------\n1872     left, right\n1873         A tuple of the new x-axis limits.\n1874 \n1875     Notes\n1876     -----\n1877     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot\n1878     equivalent of calling `~.Axes.get_xlim` on the current axes.\n1879     Calling this function with arguments is the pyplot equivalent of calling\n1880     `~.Axes.set_xlim` on the current axes. All arguments are passed though.\n1881     \"\"\"\n1882     ax = gca()\n1883     if not args and not kwargs:\n1884         return ax.get_xlim()\n1885     ret = ax.set_xlim(*args, **kwargs)\n1886     return ret\n1887 \n1888 \n1889 def ylim(*args, **kwargs) -> tuple[float, float]:\n1890     \"\"\"\n1891     Get or set the y-limits of the current axes.\n1892 \n1893     Call signatures::\n1894 \n1895         bottom, top = ylim()  # return the current ylim\n1896         ylim((bottom, top))   # set the ylim to bottom, top\n1897         ylim(bottom, top)     # set the ylim to bottom, top\n1898 \n1899     If you do not specify args, you can alternatively pass *bottom* or\n1900     *top* as kwargs, i.e.::\n1901 \n1902         ylim(top=3)  # adjust the top leaving bottom unchanged\n1903         ylim(bottom=1)  # adjust the bottom leaving top unchanged\n1904 \n1905     Setting limits turns autoscaling off for the y-axis.\n1906 \n1907     Returns\n1908     -------\n1909     bottom, top\n1910         A tuple of the new y-axis limits.\n1911 \n1912     Notes\n1913     -----\n1914     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot\n1915     equivalent of calling `~.Axes.get_ylim` on the current axes.\n1916     Calling this function with arguments is the pyplot equivalent of calling\n1917     `~.Axes.set_ylim` on the current axes. All arguments are passed though.\n1918     \"\"\"\n1919     ax = gca()\n1920     if not args and not kwargs:\n1921         return ax.get_ylim()\n1922     ret = ax.set_ylim(*args, **kwargs)\n1923     return ret\n1924 \n1925 \n1926 def xticks(\n1927     ticks: ArrayLike | None = None,\n1928     labels: Sequence[str] | None = None,\n1929     *,\n1930     minor: bool = False,\n1931     **kwargs\n1932 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:\n1933     \"\"\"\n1934     Get or set the current tick locations and labels of the x-axis.\n1935 \n1936     Pass no arguments to return the current values without modifying them.\n1937 \n1938     Parameters\n1939     ----------\n1940     ticks : array-like, optional\n1941         The list of xtick locations.  Passing an empty list removes all xticks.\n1942     labels : array-like, optional\n1943         The labels to place at the given *ticks* locations.  This argument can\n1944         only be passed if *ticks* is passed as well.\n1945     minor : bool, default: False\n1946         If ``False``, get/set the major ticks/labels; if ``True``, the minor\n1947         ticks/labels.\n1948     **kwargs\n1949         `.Text` properties can be used to control the appearance of the labels.\n1950 \n1951     Returns\n1952     -------\n1953     locs\n1954         The list of xtick locations.\n1955     labels\n1956         The list of xlabel `.Text` objects.\n1957 \n1958     Notes\n1959     -----\n1960     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot\n1961     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on\n1962     the current axes.\n1963     Calling this function with arguments is the pyplot equivalent of calling\n1964     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.\n1965 \n1966     Examples\n1967     --------\n1968     >>> locs, labels = xticks()  # Get the current locations and labels.\n1969     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.\n1970     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n1971     >>> xticks([0, 1, 2], ['January', 'February', 'March'],\n1972     ...        rotation=20)  # Set text labels and properties.\n1973     >>> xticks([])  # Disable xticks.\n1974     \"\"\"\n1975     ax = gca()\n1976 \n1977     locs: list[Tick] | np.ndarray\n1978     if ticks is None:\n1979         locs = ax.get_xticks(minor=minor)\n1980         if labels is not None:\n1981             raise TypeError(\"xticks(): Parameter 'labels' can't be set \"\n1982                             \"without setting 'ticks'\")\n1983     else:\n1984         locs = ax.set_xticks(ticks, minor=minor)\n1985 \n1986     labels_out: list[Text] = []\n1987     if labels is None:\n1988         labels_out = ax.get_xticklabels(minor=minor)\n1989         for l in labels_out:\n1990             l._internal_update(kwargs)\n1991     else:\n1992         labels_out = ax.set_xticklabels(labels, minor=minor, **kwargs)\n1993 \n1994     return locs, labels_out\n1995 \n1996 \n1997 def yticks(\n1998     ticks: ArrayLike | None = None,\n1999     labels: Sequence[str] | None = None,\n2000     *,\n2001     minor: bool = False,\n2002     **kwargs\n2003 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:\n2004     \"\"\"\n2005     Get or set the current tick locations and labels of the y-axis.\n2006 \n2007     Pass no arguments to return the current values without modifying them.\n2008 \n2009     Parameters\n2010     ----------\n2011     ticks : array-like, optional\n2012         The list of ytick locations.  Passing an empty list removes all yticks.\n2013     labels : array-like, optional\n2014         The labels to place at the given *ticks* locations.  This argument can\n2015         only be passed if *ticks* is passed as well.\n2016     minor : bool, default: False\n2017         If ``False``, get/set the major ticks/labels; if ``True``, the minor\n2018         ticks/labels.\n2019     **kwargs\n2020         `.Text` properties can be used to control the appearance of the labels.\n2021 \n2022     Returns\n2023     -------\n2024     locs\n2025         The list of ytick locations.\n2026     labels\n2027         The list of ylabel `.Text` objects.\n2028 \n2029     Notes\n2030     -----\n2031     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot\n2032     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on\n2033     the current axes.\n2034     Calling this function with arguments is the pyplot equivalent of calling\n2035     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.\n2036 \n2037     Examples\n2038     --------\n2039     >>> locs, labels = yticks()  # Get the current locations and labels.\n2040     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.\n2041     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n2042     >>> yticks([0, 1, 2], ['January', 'February', 'March'],\n2043     ...        rotation=45)  # Set text labels and properties.\n2044     >>> yticks([])  # Disable yticks.\n2045     \"\"\"\n2046     ax = gca()\n2047 \n2048     locs: list[Tick] | np.ndarray\n2049     if ticks is None:\n2050         locs = ax.get_yticks(minor=minor)\n2051         if labels is not None:\n2052             raise TypeError(\"yticks(): Parameter 'labels' can't be set \"\n2053                             \"without setting 'ticks'\")\n2054     else:\n2055         locs = ax.set_yticks(ticks, minor=minor)\n2056 \n2057     labels_out: list[Text] = []\n2058     if labels is None:\n2059         labels_out = ax.get_yticklabels(minor=minor)\n2060         for l in labels_out:\n2061             l._internal_update(kwargs)\n2062     else:\n2063         labels_out = ax.set_yticklabels(labels, minor=minor, **kwargs)\n2064 \n2065     return locs, labels_out\n2066 \n2067 \n2068 def rgrids(\n2069     radii: ArrayLike | None = None,\n2070     labels: Sequence[str | Text] | None = None,\n2071     angle: float | None = None,\n2072     fmt: str | None = None,\n2073     **kwargs\n2074 ) -> tuple[list[Line2D], list[Text]]:\n2075     \"\"\"\n2076     Get or set the radial gridlines on the current polar plot.\n2077 \n2078     Call signatures::\n2079 \n2080      lines, labels = rgrids()\n2081      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)\n2082 \n2083     When called with no arguments, `.rgrids` simply returns the tuple\n2084     (*lines*, *labels*). When called with arguments, the labels will\n2085     appear at the specified radial distances and angle.\n2086 \n2087     Parameters\n2088     ----------\n2089     radii : tuple with floats\n2090         The radii for the radial gridlines\n2091 \n2092     labels : tuple with strings or None\n2093         The labels to use at each radial gridline. The\n2094         `matplotlib.ticker.ScalarFormatter` will be used if None.\n2095 \n2096     angle : float\n2097         The angular position of the radius labels in degrees.\n2098 \n2099     fmt : str or None\n2100         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n2101         For example '%f'.\n2102 \n2103     Returns\n2104     -------\n2105     lines : list of `.lines.Line2D`\n2106         The radial gridlines.\n2107 \n2108     labels : list of `.text.Text`\n2109         The tick labels.\n2110 \n2111     Other Parameters\n2112     ----------------\n2113     **kwargs\n2114         *kwargs* are optional `.Text` properties for the labels.\n2115 \n2116     See Also\n2117     --------\n2118     .pyplot.thetagrids\n2119     .projections.polar.PolarAxes.set_rgrids\n2120     .Axis.get_gridlines\n2121     .Axis.get_ticklabels\n2122 \n2123     Examples\n2124     --------\n2125     ::\n2126 \n2127       # set the locations of the radial gridlines\n2128       lines, labels = rgrids( (0.25, 0.5, 1.0) )\n2129 \n2130       # set the locations and labels of the radial gridlines\n2131       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))\n2132     \"\"\"\n2133     ax = gca()\n2134     if not isinstance(ax, PolarAxes):\n2135         raise RuntimeError('rgrids only defined for polar axes')\n2136     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:\n2137         lines_out: list[Line2D] = ax.yaxis.get_gridlines()\n2138         labels_out: list[Text] = ax.yaxis.get_ticklabels()\n2139     elif radii is None:\n2140         raise TypeError(\"'radii' cannot be None when other parameters are passed\")\n2141     else:\n2142         lines_out, labels_out = ax.set_rgrids(\n2143             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)\n2144     return lines_out, labels_out\n2145 \n2146 \n2147 def thetagrids(\n2148     angles: ArrayLike | None = None,\n2149     labels: Sequence[str | Text] | None = None,\n2150     fmt: str | None = None,\n2151     **kwargs\n2152 ) -> tuple[list[Line2D], list[Text]]:\n2153     \"\"\"\n2154     Get or set the theta gridlines on the current polar plot.\n2155 \n2156     Call signatures::\n2157 \n2158      lines, labels = thetagrids()\n2159      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)\n2160 \n2161     When called with no arguments, `.thetagrids` simply returns the tuple\n2162     (*lines*, *labels*). When called with arguments, the labels will\n2163     appear at the specified angles.\n2164 \n2165     Parameters\n2166     ----------\n2167     angles : tuple with floats, degrees\n2168         The angles of the theta gridlines.\n2169 \n2170     labels : tuple with strings or None\n2171         The labels to use at each radial gridline. The\n2172         `.projections.polar.ThetaFormatter` will be used if None.\n2173 \n2174     fmt : str or None\n2175         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n2176         For example '%f'. Note that the angle in radians will be used.\n2177 \n2178     Returns\n2179     -------\n2180     lines : list of `.lines.Line2D`\n2181         The theta gridlines.\n2182 \n2183     labels : list of `.text.Text`\n2184         The tick labels.\n2185 \n2186     Other Parameters\n2187     ----------------\n2188     **kwargs\n2189         *kwargs* are optional `.Text` properties for the labels.\n2190 \n2191     See Also\n2192     --------\n2193     .pyplot.rgrids\n2194     .projections.polar.PolarAxes.set_thetagrids\n2195     .Axis.get_gridlines\n2196     .Axis.get_ticklabels\n2197 \n2198     Examples\n2199     --------\n2200     ::\n2201 \n2202       # set the locations of the angular gridlines\n2203       lines, labels = thetagrids(range(45, 360, 90))\n2204 \n2205       # set the locations and labels of the angular gridlines\n2206       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))\n2207     \"\"\"\n2208     ax = gca()\n2209     if not isinstance(ax, PolarAxes):\n2210         raise RuntimeError('thetagrids only defined for polar axes')\n2211     if all(param is None for param in [angles, labels, fmt]) and not kwargs:\n2212         lines_out: list[Line2D] = ax.xaxis.get_ticklines()\n2213         labels_out: list[Text] = ax.xaxis.get_ticklabels()\n2214     elif angles is None:\n2215         raise TypeError(\"'angles' cannot be None when other parameters are passed\")\n2216     else:\n2217         lines_out, labels_out = ax.set_thetagrids(angles,\n2218                                                   labels=labels, fmt=fmt,\n2219                                                   **kwargs)\n2220     return lines_out, labels_out\n2221 \n2222 \n2223 @_api.deprecated(\"3.7\", pending=True)\n2224 def get_plot_commands() -> list[str]:\n2225     \"\"\"\n2226     Get a sorted list of all of the plotting commands.\n2227     \"\"\"\n2228     NON_PLOT_COMMANDS = {\n2229         'connect', 'disconnect', 'get_current_fig_manager', 'ginput',\n2230         'new_figure_manager', 'waitforbuttonpress'}\n2231     return [name for name in _get_pyplot_commands()\n2232             if name not in NON_PLOT_COMMANDS]\n2233 \n2234 \n2235 def _get_pyplot_commands() -> list[str]:\n2236     # This works by searching for all functions in this module and removing\n2237     # a few hard-coded exclusions, as well as all of the colormap-setting\n2238     # functions, and anything marked as private with a preceding underscore.\n2239     exclude = {'colormaps', 'colors', 'get_plot_commands', *colormaps}\n2240     this_module = inspect.getmodule(get_plot_commands)\n2241     return sorted(\n2242         name for name, obj in globals().items()\n2243         if not name.startswith('_') and name not in exclude\n2244            and inspect.isfunction(obj)\n2245            and inspect.getmodule(obj) is this_module)\n2246 \n2247 \n2248 ## Plotting part 1: manually generated functions and wrappers ##\n2249 \n2250 \n2251 @_copy_docstring_and_deprecators(Figure.colorbar)\n2252 def colorbar(\n2253     mappable: ScalarMappable | None = None,\n2254     cax: matplotlib.axes.Axes | None = None,\n2255     ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,\n2256     **kwargs\n2257 ) -> Colorbar:\n2258     if mappable is None:\n2259         mappable = gci()\n2260         if mappable is None:\n2261             raise RuntimeError('No mappable was found to use for colorbar '\n2262                                'creation. First define a mappable such as '\n2263                                'an image (with imshow) or a contour set ('\n2264                                'with contourf).')\n2265     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)\n2266     return ret\n2267 \n2268 \n2269 def clim(vmin: float | None = None, vmax: float | None = None) -> None:\n2270     \"\"\"\n2271     Set the color limits of the current image.\n2272 \n2273     If either *vmin* or *vmax* is None, the image min/max respectively\n2274     will be used for color scaling.\n2275 \n2276     If you want to set the clim of multiple images, use\n2277     `~.ScalarMappable.set_clim` on every image, for example::\n2278 \n2279       for im in gca().get_images():\n2280           im.set_clim(0, 0.5)\n2281 \n2282     \"\"\"\n2283     im = gci()\n2284     if im is None:\n2285         raise RuntimeError('You must first define an image, e.g., with imshow')\n2286 \n2287     im.set_clim(vmin, vmax)\n2288 \n2289 \n2290 # eventually this implementation should move here, use indirection for now to\n2291 # avoid having two copies of the code floating around.\n2292 def get_cmap(\n2293     name: Colormap | str | None = None,\n2294     lut: int | None = None\n2295 ) -> Colormap:\n2296     return cm._get_cmap(name=name, lut=lut)  # type: ignore\n2297 get_cmap.__doc__ = cm._get_cmap.__doc__  # type: ignore\n2298 \n2299 \n2300 def set_cmap(cmap: Colormap | str) -> None:\n2301     \"\"\"\n2302     Set the default colormap, and applies it to the current image if any.\n2303 \n2304     Parameters\n2305     ----------\n2306     cmap : `~matplotlib.colors.Colormap` or str\n2307         A colormap instance or the name of a registered colormap.\n2308 \n2309     See Also\n2310     --------\n2311     colormaps\n2312     matplotlib.cm.register_cmap\n2313     matplotlib.cm.get_cmap\n2314     \"\"\"\n2315     cmap = get_cmap(cmap)\n2316 \n2317     rc('image', cmap=cmap.name)\n2318     im = gci()\n2319 \n2320     if im is not None:\n2321         im.set_cmap(cmap)\n2322 \n2323 \n2324 @_copy_docstring_and_deprecators(matplotlib.image.imread)\n2325 def imread(\n2326         fname: str | pathlib.Path | BinaryIO, format: str | None = None\n2327 ) -> np.ndarray:\n2328     return matplotlib.image.imread(fname, format)\n2329 \n2330 \n2331 @_copy_docstring_and_deprecators(matplotlib.image.imsave)\n2332 def imsave(\n2333     fname: str | os.PathLike | BinaryIO, arr: ArrayLike, **kwargs\n2334 ) -> None:\n2335     matplotlib.image.imsave(fname, arr, **kwargs)\n2336 \n2337 \n2338 def matshow(A: ArrayLike, fignum: None | int = None, **kwargs) -> AxesImage:\n2339     \"\"\"\n2340     Display an array as a matrix in a new figure window.\n2341 \n2342     The origin is set at the upper left hand corner and rows (first\n2343     dimension of the array) are displayed horizontally.  The aspect\n2344     ratio of the figure window is that of the array, unless this would\n2345     make an excessively short or narrow figure.\n2346 \n2347     Tick labels for the xaxis are placed on top.\n2348 \n2349     Parameters\n2350     ----------\n2351     A : 2D array-like\n2352         The matrix to be displayed.\n2353 \n2354     fignum : None or int\n2355         If *None*, create a new figure window with automatic numbering.\n2356 \n2357         If a nonzero integer, draw into the figure with the given number\n2358         (create it if it does not exist).\n2359 \n2360         If 0, use the current axes (or create one if it does not exist).\n2361 \n2362         .. note::\n2363 \n2364            Because of how `.Axes.matshow` tries to set the figure aspect\n2365            ratio to be the one of the array, strange things may happen if you\n2366            reuse an existing figure.\n2367 \n2368     Returns\n2369     -------\n2370     `~matplotlib.image.AxesImage`\n2371 \n2372     Other Parameters\n2373     ----------------\n2374     **kwargs : `~matplotlib.axes.Axes.imshow` arguments\n2375 \n2376     \"\"\"\n2377     A = np.asanyarray(A)\n2378     if fignum == 0:\n2379         ax = gca()\n2380     else:\n2381         # Extract actual aspect ratio of array and make appropriately sized\n2382         # figure.\n2383         fig = figure(fignum, figsize=figaspect(A))\n2384         ax = fig.add_axes((0.15, 0.09, 0.775, 0.775))\n2385     im = ax.matshow(A, **kwargs)\n2386     sci(im)\n2387     return im\n2388 \n2389 \n2390 def polar(*args, **kwargs) -> list[Line2D]:\n2391     \"\"\"\n2392     Make a polar plot.\n2393 \n2394     call signature::\n2395 \n2396       polar(theta, r, **kwargs)\n2397 \n2398     Multiple *theta*, *r* arguments are supported, with format strings, as in\n2399     `plot`.\n2400     \"\"\"\n2401     # If an axis already exists, check if it has a polar projection\n2402     if gcf().get_axes():\n2403         ax = gca()\n2404         if not isinstance(ax, PolarAxes):\n2405             _api.warn_external('Trying to create polar plot on an Axes '\n2406                                'that does not have a polar projection.')\n2407     else:\n2408         ax = axes(projection=\"polar\")\n2409     return ax.plot(*args, **kwargs)\n2410 \n2411 \n2412 # If rcParams['backend_fallback'] is true, and an interactive backend is\n2413 # requested, ignore rcParams['backend'] and force selection of a backend that\n2414 # is compatible with the current running interactive framework.\n2415 if (rcParams[\"backend_fallback\"]\n2416         and rcParams._get_backend_or_none() in (  # type: ignore\n2417             set(rcsetup.interactive_bk) - {'WebAgg', 'nbAgg'})\n2418         and cbook._get_running_interactive_framework()):  # type: ignore\n2419     rcParams._set(\"backend\", rcsetup._auto_backend_sentinel)  # type: ignore\n2420 \n2421 # fmt: on\n2422 \n2423 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############\n2424 \n2425 \n2426 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2427 @_copy_docstring_and_deprecators(Figure.figimage)\n2428 def figimage(\n2429     X: ArrayLike,\n2430     xo: int = 0,\n2431     yo: int = 0,\n2432     alpha: float | None = None,\n2433     norm: str | Normalize | None = None,\n2434     cmap: str | Colormap | None = None,\n2435     vmin: float | None = None,\n2436     vmax: float | None = None,\n2437     origin: Literal[\"upper\", \"lower\"] | None = None,\n2438     resize: bool = False,\n2439     **kwargs,\n2440 ) -> FigureImage:\n2441     return gcf().figimage(\n2442         X,\n2443         xo=xo,\n2444         yo=yo,\n2445         alpha=alpha,\n2446         norm=norm,\n2447         cmap=cmap,\n2448         vmin=vmin,\n2449         vmax=vmax,\n2450         origin=origin,\n2451         resize=resize,\n2452         **kwargs,\n2453     )\n2454 \n2455 \n2456 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2457 @_copy_docstring_and_deprecators(Figure.text)\n2458 def figtext(\n2459     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs\n2460 ) -> Text:\n2461     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)\n2462 \n2463 \n2464 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2465 @_copy_docstring_and_deprecators(Figure.gca)\n2466 def gca() -> Axes:\n2467     return gcf().gca()\n2468 \n2469 \n2470 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2471 @_copy_docstring_and_deprecators(Figure._gci)\n2472 def gci() -> ScalarMappable | None:\n2473     return gcf()._gci()\n2474 \n2475 \n2476 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2477 @_copy_docstring_and_deprecators(Figure.ginput)\n2478 def ginput(\n2479     n: int = 1,\n2480     timeout: float = 30,\n2481     show_clicks: bool = True,\n2482     mouse_add: MouseButton = MouseButton.LEFT,\n2483     mouse_pop: MouseButton = MouseButton.RIGHT,\n2484     mouse_stop: MouseButton = MouseButton.MIDDLE,\n2485 ) -> list[tuple[int, int]]:\n2486     return gcf().ginput(\n2487         n=n,\n2488         timeout=timeout,\n2489         show_clicks=show_clicks,\n2490         mouse_add=mouse_add,\n2491         mouse_pop=mouse_pop,\n2492         mouse_stop=mouse_stop,\n2493     )\n2494 \n2495 \n2496 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2497 @_copy_docstring_and_deprecators(Figure.subplots_adjust)\n2498 def subplots_adjust(\n2499     left: float | None = None,\n2500     bottom: float | None = None,\n2501     right: float | None = None,\n2502     top: float | None = None,\n2503     wspace: float | None = None,\n2504     hspace: float | None = None,\n2505 ) -> None:\n2506     gcf().subplots_adjust(\n2507         left=left, bottom=bottom, right=right, top=top, wspace=wspace, hspace=hspace\n2508     )\n2509 \n2510 \n2511 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2512 @_copy_docstring_and_deprecators(Figure.suptitle)\n2513 def suptitle(t: str, **kwargs) -> Text:\n2514     return gcf().suptitle(t, **kwargs)\n2515 \n2516 \n2517 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2518 @_copy_docstring_and_deprecators(Figure.tight_layout)\n2519 def tight_layout(\n2520     *,\n2521     pad: float = 1.08,\n2522     h_pad: float | None = None,\n2523     w_pad: float | None = None,\n2524     rect: tuple[float, float, float, float] | None = None,\n2525 ) -> None:\n2526     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n2527 \n2528 \n2529 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2530 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)\n2531 def waitforbuttonpress(timeout: float = -1) -> None | bool:\n2532     return gcf().waitforbuttonpress(timeout=timeout)\n2533 \n2534 \n2535 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2536 @_copy_docstring_and_deprecators(Axes.acorr)\n2537 def acorr(\n2538     x: ArrayLike, *, data=None, **kwargs\n2539 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:\n2540     return gca().acorr(x, **({\"data\": data} if data is not None else {}), **kwargs)\n2541 \n2542 \n2543 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2544 @_copy_docstring_and_deprecators(Axes.angle_spectrum)\n2545 def angle_spectrum(\n2546     x: ArrayLike,\n2547     Fs: float | None = None,\n2548     Fc: int | None = None,\n2549     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n2550     pad_to: int | None = None,\n2551     sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n2552     *,\n2553     data=None,\n2554     **kwargs,\n2555 ) -> tuple[np.ndarray, np.ndarray, Line2D]:\n2556     return gca().angle_spectrum(\n2557         x,\n2558         Fs=Fs,\n2559         Fc=Fc,\n2560         window=window,\n2561         pad_to=pad_to,\n2562         sides=sides,\n2563         **({\"data\": data} if data is not None else {}),\n2564         **kwargs,\n2565     )\n2566 \n2567 \n2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2569 @_copy_docstring_and_deprecators(Axes.annotate)\n2570 def annotate(\n2571     text: str,\n2572     xy: tuple[float, float],\n2573     xytext: tuple[float, float] | None = None,\n2574     xycoords: str\n2575     | Artist\n2576     | Transform\n2577     | Callable[[RendererBase], Bbox | Transform]\n2578     | tuple[float, float] = \"data\",\n2579     textcoords: str\n2580     | Artist\n2581     | Transform\n2582     | Callable[[RendererBase], Bbox | Transform]\n2583     | tuple[float, float]\n2584     | None = None,\n2585     arrowprops: dict[str, Any] | None = None,\n2586     annotation_clip: bool | None = None,\n2587     **kwargs,\n2588 ) -> Annotation:\n2589     return gca().annotate(\n2590         text,\n2591         xy,\n2592         xytext=xytext,\n2593         xycoords=xycoords,\n2594         textcoords=textcoords,\n2595         arrowprops=arrowprops,\n2596         annotation_clip=annotation_clip,\n2597         **kwargs,\n2598     )\n2599 \n2600 \n2601 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2602 @_copy_docstring_and_deprecators(Axes.arrow)\n2603 def arrow(x: float, y: float, dx: float, dy: float, **kwargs) -> FancyArrow:\n2604     return gca().arrow(x, y, dx, dy, **kwargs)\n2605 \n2606 \n2607 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2608 @_copy_docstring_and_deprecators(Axes.autoscale)\n2609 def autoscale(\n2610     enable: bool = True,\n2611     axis: Literal[\"both\", \"x\", \"y\"] = \"both\",\n2612     tight: bool | None = None,\n2613 ) -> None:\n2614     gca().autoscale(enable=enable, axis=axis, tight=tight)\n2615 \n2616 \n2617 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2618 @_copy_docstring_and_deprecators(Axes.axhline)\n2619 def axhline(y: float = 0, xmin: float = 0, xmax: float = 1, **kwargs) -> Line2D:\n2620     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)\n2621 \n2622 \n2623 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2624 @_copy_docstring_and_deprecators(Axes.axhspan)\n2625 def axhspan(\n2626     ymin: float, ymax: float, xmin: float = 0, xmax: float = 1, **kwargs\n2627 ) -> Polygon:\n2628     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)\n2629 \n2630 \n2631 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2632 @_copy_docstring_and_deprecators(Axes.axis)\n2633 def axis(\n2634     arg: tuple[float, float, float, float] | bool | str | None = None,\n2635     /,\n2636     *,\n2637     emit: bool = True,\n2638     **kwargs,\n2639 ) -> tuple[float, float, float, float]:\n2640     return gca().axis(arg, emit=emit, **kwargs)\n2641 \n2642 \n2643 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2644 @_copy_docstring_and_deprecators(Axes.axline)\n2645 def axline(\n2646     xy1: tuple[float, float],\n2647     xy2: tuple[float, float] | None = None,\n2648     *,\n2649     slope: float | None = None,\n2650     **kwargs,\n2651 ) -> Line2D:\n2652     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)\n2653 \n2654 \n2655 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2656 @_copy_docstring_and_deprecators(Axes.axvline)\n2657 def axvline(x: float = 0, ymin: float = 0, ymax: float = 1, **kwargs) -> Line2D:\n2658     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)\n2659 \n2660 \n2661 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2662 @_copy_docstring_and_deprecators(Axes.axvspan)\n2663 def axvspan(\n2664     xmin: float, xmax: float, ymin: float = 0, ymax: float = 1, **kwargs\n2665 ) -> Polygon:\n2666     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)\n2667 \n2668 \n2669 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2670 @_copy_docstring_and_deprecators(Axes.bar)\n2671 def bar(\n2672     x: float | ArrayLike,\n2673     height: float | ArrayLike,\n2674     width: float | ArrayLike = 0.8,\n2675     bottom: float | ArrayLike | None = None,\n2676     *,\n2677     align: Literal[\"center\", \"edge\"] = \"center\",\n2678     data=None,\n2679     **kwargs,\n2680 ) -> BarContainer:\n2681     return gca().bar(\n2682         x,\n2683         height,\n2684         width=width,\n2685         bottom=bottom,\n2686         align=align,\n2687         **({\"data\": data} if data is not None else {}),\n2688         **kwargs,\n2689     )\n2690 \n2691 \n2692 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2693 @_copy_docstring_and_deprecators(Axes.barbs)\n2694 def barbs(*args, data=None, **kwargs) -> Barbs:\n2695     return gca().barbs(*args, **({\"data\": data} if data is not None else {}), **kwargs)\n2696 \n2697 \n2698 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2699 @_copy_docstring_and_deprecators(Axes.barh)\n2700 def barh(\n2701     y: float | ArrayLike,\n2702     width: float | ArrayLike,\n2703     height: float | ArrayLike = 0.8,\n2704     left: float | ArrayLike | None = None,\n2705     *,\n2706     align: Literal[\"center\", \"edge\"] = \"center\",\n2707     data=None,\n2708     **kwargs,\n2709 ) -> BarContainer:\n2710     return gca().barh(\n2711         y,\n2712         width,\n2713         height=height,\n2714         left=left,\n2715         align=align,\n2716         **({\"data\": data} if data is not None else {}),\n2717         **kwargs,\n2718     )\n2719 \n2720 \n2721 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2722 @_copy_docstring_and_deprecators(Axes.bar_label)\n2723 def bar_label(\n2724     container: BarContainer,\n2725     labels: ArrayLike | None = None,\n2726     *,\n2727     fmt: str | Callable[[float], str] = \"%g\",\n2728     label_type: Literal[\"center\", \"edge\"] = \"edge\",\n2729     padding: float = 0,\n2730     **kwargs,\n2731 ) -> list[Annotation]:\n2732     return gca().bar_label(\n2733         container,\n2734         labels=labels,\n2735         fmt=fmt,\n2736         label_type=label_type,\n2737         padding=padding,\n2738         **kwargs,\n2739     )\n2740 \n2741 \n2742 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2743 @_copy_docstring_and_deprecators(Axes.boxplot)\n2744 def boxplot(\n2745     x: ArrayLike | Sequence[ArrayLike],\n2746     notch: bool | None = None,\n2747     sym: str | None = None,\n2748     vert: bool | None = None,\n2749     whis: float | tuple[float, float] | None = None,\n2750     positions: ArrayLike | None = None,\n2751     widths: float | ArrayLike | None = None,\n2752     patch_artist: bool | None = None,\n2753     bootstrap: int | None = None,\n2754     usermedians: ArrayLike | None = None,\n2755     conf_intervals: ArrayLike | None = None,\n2756     meanline: bool | None = None,\n2757     showmeans: bool | None = None,\n2758     showcaps: bool | None = None,\n2759     showbox: bool | None = None,\n2760     showfliers: bool | None = None,\n2761     boxprops: dict[str, Any] | None = None,\n2762     labels: Sequence[str] | None = None,\n2763     flierprops: dict[str, Any] | None = None,\n2764     medianprops: dict[str, Any] | None = None,\n2765     meanprops: dict[str, Any] | None = None,\n2766     capprops: dict[str, Any] | None = None,\n2767     whiskerprops: dict[str, Any] | None = None,\n2768     manage_ticks: bool = True,\n2769     autorange: bool = False,\n2770     zorder: float | None = None,\n2771     capwidths: float | ArrayLike | None = None,\n2772     *,\n2773     data=None,\n2774 ) -> dict[str, Any]:\n2775     return gca().boxplot(\n2776         x,\n2777         notch=notch,\n2778         sym=sym,\n2779         vert=vert,\n2780         whis=whis,\n2781         positions=positions,\n2782         widths=widths,\n2783         patch_artist=patch_artist,\n2784         bootstrap=bootstrap,\n2785         usermedians=usermedians,\n2786         conf_intervals=conf_intervals,\n2787         meanline=meanline,\n2788         showmeans=showmeans,\n2789         showcaps=showcaps,\n2790         showbox=showbox,\n2791         showfliers=showfliers,\n2792         boxprops=boxprops,\n2793         labels=labels,\n2794         flierprops=flierprops,\n2795         medianprops=medianprops,\n2796         meanprops=meanprops,\n2797         capprops=capprops,\n2798         whiskerprops=whiskerprops,\n2799         manage_ticks=manage_ticks,\n2800         autorange=autorange,\n2801         zorder=zorder,\n2802         capwidths=capwidths,\n2803         **({\"data\": data} if data is not None else {}),\n2804     )\n2805 \n2806 \n2807 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2808 @_copy_docstring_and_deprecators(Axes.broken_barh)\n2809 def broken_barh(\n2810     xranges: Sequence[tuple[float, float]],\n2811     yrange: tuple[float, float],\n2812     *,\n2813     data=None,\n2814     **kwargs,\n2815 ) -> BrokenBarHCollection:\n2816     return gca().broken_barh(\n2817         xranges, yrange, **({\"data\": data} if data is not None else {}), **kwargs\n2818     )\n2819 \n2820 \n2821 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2822 @_copy_docstring_and_deprecators(Axes.clabel)\n2823 def clabel(CS: ContourSet, levels: ArrayLike | None = None, **kwargs) -> list[Text]:\n2824     return gca().clabel(CS, levels=levels, **kwargs)\n2825 \n2826 \n2827 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2828 @_copy_docstring_and_deprecators(Axes.cohere)\n2829 def cohere(\n2830     x: ArrayLike,\n2831     y: ArrayLike,\n2832     NFFT: int = 256,\n2833     Fs: float = 2,\n2834     Fc: int = 0,\n2835     detrend: Literal[\"none\", \"mean\", \"linear\"]\n2836     | Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,\n2837     window: Callable[[ArrayLike], ArrayLike] | ArrayLike = mlab.window_hanning,\n2838     noverlap: int = 0,\n2839     pad_to: int | None = None,\n2840     sides: Literal[\"default\", \"onesided\", \"twosided\"] = \"default\",\n2841     scale_by_freq: bool | None = None,\n2842     *,\n2843     data=None,\n2844     **kwargs,\n2845 ) -> tuple[np.ndarray, np.ndarray]:\n2846     return gca().cohere(\n2847         x,\n2848         y,\n2849         NFFT=NFFT,\n2850         Fs=Fs,\n2851         Fc=Fc,\n2852         detrend=detrend,\n2853         window=window,\n2854         noverlap=noverlap,\n2855         pad_to=pad_to,\n2856         sides=sides,\n2857         scale_by_freq=scale_by_freq,\n2858         **({\"data\": data} if data is not None else {}),\n2859         **kwargs,\n2860     )\n2861 \n2862 \n2863 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2864 @_copy_docstring_and_deprecators(Axes.contour)\n2865 def contour(*args, data=None, **kwargs) -> QuadContourSet:\n2866     __ret = gca().contour(\n2867         *args, **({\"data\": data} if data is not None else {}), **kwargs\n2868     )\n2869     if __ret._A is not None:  # type: ignore[attr-defined]\n2870         sci(__ret)\n2871     return __ret\n2872 \n2873 \n2874 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2875 @_copy_docstring_and_deprecators(Axes.contourf)\n2876 def contourf(*args, data=None, **kwargs) -> QuadContourSet:\n2877     __ret = gca().contourf(\n2878         *args, **({\"data\": data} if data is not None else {}), **kwargs\n2879     )\n2880     if __ret._A is not None:  # type: ignore[attr-defined]\n2881         sci(__ret)\n2882     return __ret\n2883 \n2884 \n2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2886 @_copy_docstring_and_deprecators(Axes.csd)\n2887 def csd(\n2888     x: ArrayLike,\n2889     y: ArrayLike,\n2890     NFFT: int | None = None,\n2891     Fs: float | None = None,\n2892     Fc: int | None = None,\n2893     detrend: Literal[\"none\", \"mean\", \"linear\"]\n2894     | Callable[[ArrayLike], ArrayLike]\n2895     | None = None,\n2896     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n2897     noverlap: int | None = None,\n2898     pad_to: int | None = None,\n2899     sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n2900     scale_by_freq: bool | None = None,\n2901     return_line: bool | None = None,\n2902     *,\n2903     data=None,\n2904     **kwargs,\n2905 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:\n2906     return gca().csd(\n2907         x,\n2908         y,\n2909         NFFT=NFFT,\n2910         Fs=Fs,\n2911         Fc=Fc,\n2912         detrend=detrend,\n2913         window=window,\n2914         noverlap=noverlap,\n2915         pad_to=pad_to,\n2916         sides=sides,\n2917         scale_by_freq=scale_by_freq,\n2918         return_line=return_line,\n2919         **({\"data\": data} if data is not None else {}),\n2920         **kwargs,\n2921     )\n2922 \n2923 \n2924 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2925 @_copy_docstring_and_deprecators(Axes.ecdf)\n2926 def ecdf(\n2927     x: ArrayLike,\n2928     weights: ArrayLike | None = None,\n2929     *,\n2930     complementary: bool = False,\n2931     orientation: Literal[\"vertical\", \"horizonatal\"] = \"vertical\",\n2932     compress: bool = False,\n2933     data=None,\n2934     **kwargs,\n2935 ) -> Line2D:\n2936     return gca().ecdf(\n2937         x,\n2938         weights=weights,\n2939         complementary=complementary,\n2940         orientation=orientation,\n2941         compress=compress,\n2942         **({\"data\": data} if data is not None else {}),\n2943         **kwargs,\n2944     )\n2945 \n2946 \n2947 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2948 @_copy_docstring_and_deprecators(Axes.errorbar)\n2949 def errorbar(\n2950     x: float | ArrayLike,\n2951     y: float | ArrayLike,\n2952     yerr: float | ArrayLike | None = None,\n2953     xerr: float | ArrayLike | None = None,\n2954     fmt: str = \"\",\n2955     ecolor: ColorType | None = None,\n2956     elinewidth: float | None = None,\n2957     capsize: float | None = None,\n2958     barsabove: bool = False,\n2959     lolims: bool = False,\n2960     uplims: bool = False,\n2961     xlolims: bool = False,\n2962     xuplims: bool = False,\n2963     errorevery: int | tuple[int, int] = 1,\n2964     capthick: float | None = None,\n2965     *,\n2966     data=None,\n2967     **kwargs,\n2968 ) -> ErrorbarContainer:\n2969     return gca().errorbar(\n2970         x,\n2971         y,\n2972         yerr=yerr,\n2973         xerr=xerr,\n2974         fmt=fmt,\n2975         ecolor=ecolor,\n2976         elinewidth=elinewidth,\n2977         capsize=capsize,\n2978         barsabove=barsabove,\n2979         lolims=lolims,\n2980         uplims=uplims,\n2981         xlolims=xlolims,\n2982         xuplims=xuplims,\n2983         errorevery=errorevery,\n2984         capthick=capthick,\n2985         **({\"data\": data} if data is not None else {}),\n2986         **kwargs,\n2987     )\n2988 \n2989 \n2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2991 @_copy_docstring_and_deprecators(Axes.eventplot)\n2992 def eventplot(\n2993     positions: ArrayLike | Sequence[ArrayLike],\n2994     orientation: Literal[\"horizontal\", \"vertical\"] = \"horizontal\",\n2995     lineoffsets: float | Sequence[float] = 1,\n2996     linelengths: float | Sequence[float] = 1,\n2997     linewidths: float | Sequence[float] | None = None,\n2998     colors: ColorType | Sequence[ColorType] | None = None,\n2999     alpha: float | Sequence[float] | None = None,\n3000     linestyles: LineStyleType | Sequence[LineStyleType] = \"solid\",\n3001     *,\n3002     data=None,\n3003     **kwargs,\n3004 ) -> EventCollection:\n3005     return gca().eventplot(\n3006         positions,\n3007         orientation=orientation,\n3008         lineoffsets=lineoffsets,\n3009         linelengths=linelengths,\n3010         linewidths=linewidths,\n3011         colors=colors,\n3012         alpha=alpha,\n3013         linestyles=linestyles,\n3014         **({\"data\": data} if data is not None else {}),\n3015         **kwargs,\n3016     )\n3017 \n3018 \n3019 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3020 @_copy_docstring_and_deprecators(Axes.fill)\n3021 def fill(*args, data=None, **kwargs) -> list[Polygon]:\n3022     return gca().fill(*args, **({\"data\": data} if data is not None else {}), **kwargs)\n3023 \n3024 \n3025 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3026 @_copy_docstring_and_deprecators(Axes.fill_between)\n3027 def fill_between(\n3028     x: ArrayLike,\n3029     y1: ArrayLike | float,\n3030     y2: ArrayLike | float = 0,\n3031     where: Sequence[bool] | None = None,\n3032     interpolate: bool = False,\n3033     step: Literal[\"pre\", \"post\", \"mid\"] | None = None,\n3034     *,\n3035     data=None,\n3036     **kwargs,\n3037 ) -> PolyCollection:\n3038     return gca().fill_between(\n3039         x,\n3040         y1,\n3041         y2=y2,\n3042         where=where,\n3043         interpolate=interpolate,\n3044         step=step,\n3045         **({\"data\": data} if data is not None else {}),\n3046         **kwargs,\n3047     )\n3048 \n3049 \n3050 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3051 @_copy_docstring_and_deprecators(Axes.fill_betweenx)\n3052 def fill_betweenx(\n3053     y: ArrayLike,\n3054     x1: ArrayLike | float,\n3055     x2: ArrayLike | float = 0,\n3056     where: Sequence[bool] | None = None,\n3057     step: Literal[\"pre\", \"post\", \"mid\"] | None = None,\n3058     interpolate: bool = False,\n3059     *,\n3060     data=None,\n3061     **kwargs,\n3062 ) -> PolyCollection:\n3063     return gca().fill_betweenx(\n3064         y,\n3065         x1,\n3066         x2=x2,\n3067         where=where,\n3068         step=step,\n3069         interpolate=interpolate,\n3070         **({\"data\": data} if data is not None else {}),\n3071         **kwargs,\n3072     )\n3073 \n3074 \n3075 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3076 @_copy_docstring_and_deprecators(Axes.grid)\n3077 def grid(\n3078     visible: bool | None = None,\n3079     which: Literal[\"major\", \"minor\", \"both\"] = \"major\",\n3080     axis: Literal[\"both\", \"x\", \"y\"] = \"both\",\n3081     **kwargs,\n3082 ) -> None:\n3083     gca().grid(visible=visible, which=which, axis=axis, **kwargs)\n3084 \n3085 \n3086 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3087 @_copy_docstring_and_deprecators(Axes.hexbin)\n3088 def hexbin(\n3089     x: ArrayLike,\n3090     y: ArrayLike,\n3091     C: ArrayLike | None = None,\n3092     gridsize: int | tuple[int, int] = 100,\n3093     bins: Literal[\"log\"] | int | Sequence[float] | None = None,\n3094     xscale: Literal[\"linear\", \"log\"] = \"linear\",\n3095     yscale: Literal[\"linear\", \"log\"] = \"linear\",\n3096     extent: tuple[float, float, float, float] | None = None,\n3097     cmap: str | Colormap | None = None,\n3098     norm: str | Normalize | None = None,\n3099     vmin: float | None = None,\n3100     vmax: float | None = None,\n3101     alpha: float | None = None,\n3102     linewidths: float | None = None,\n3103     edgecolors: Literal[\"face\", \"none\"] | ColorType = \"face\",\n3104     reduce_C_function: Callable[[np.ndarray | list[float]], float] = np.mean,\n3105     mincnt: int | None = None,\n3106     marginals: bool = False,\n3107     *,\n3108     data=None,\n3109     **kwargs,\n3110 ) -> PolyCollection:\n3111     __ret = gca().hexbin(\n3112         x,\n3113         y,\n3114         C=C,\n3115         gridsize=gridsize,\n3116         bins=bins,\n3117         xscale=xscale,\n3118         yscale=yscale,\n3119         extent=extent,\n3120         cmap=cmap,\n3121         norm=norm,\n3122         vmin=vmin,\n3123         vmax=vmax,\n3124         alpha=alpha,\n3125         linewidths=linewidths,\n3126         edgecolors=edgecolors,\n3127         reduce_C_function=reduce_C_function,\n3128         mincnt=mincnt,\n3129         marginals=marginals,\n3130         **({\"data\": data} if data is not None else {}),\n3131         **kwargs,\n3132     )\n3133     sci(__ret)\n3134     return __ret\n3135 \n3136 \n3137 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3138 @_copy_docstring_and_deprecators(Axes.hist)\n3139 def hist(\n3140     x: ArrayLike | Sequence[ArrayLike],\n3141     bins: int | Sequence[float] | str | None = None,\n3142     range: tuple[float, float] | None = None,\n3143     density: bool = False,\n3144     weights: ArrayLike | None = None,\n3145     cumulative: bool | float = False,\n3146     bottom: ArrayLike | float | None = None,\n3147     histtype: Literal[\"bar\", \"barstacked\", \"step\", \"stepfilled\"] = \"bar\",\n3148     align: Literal[\"left\", \"mid\", \"right\"] = \"mid\",\n3149     orientation: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n3150     rwidth: float | None = None,\n3151     log: bool = False,\n3152     color: ColorType | Sequence[ColorType] | None = None,\n3153     label: str | Sequence[str] | None = None,\n3154     stacked: bool = False,\n3155     *,\n3156     data=None,\n3157     **kwargs,\n3158 ) -> tuple[\n3159     np.ndarray | list[np.ndarray],\n3160     np.ndarray,\n3161     BarContainer | Polygon | list[BarContainer | Polygon],\n3162 ]:\n3163     return gca().hist(\n3164         x,\n3165         bins=bins,\n3166         range=range,\n3167         density=density,\n3168         weights=weights,\n3169         cumulative=cumulative,\n3170         bottom=bottom,\n3171         histtype=histtype,\n3172         align=align,\n3173         orientation=orientation,\n3174         rwidth=rwidth,\n3175         log=log,\n3176         color=color,\n3177         label=label,\n3178         stacked=stacked,\n3179         **({\"data\": data} if data is not None else {}),\n3180         **kwargs,\n3181     )\n3182 \n3183 \n3184 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3185 @_copy_docstring_and_deprecators(Axes.stairs)\n3186 def stairs(\n3187     values: ArrayLike,\n3188     edges: ArrayLike | None = None,\n3189     *,\n3190     orientation: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n3191     baseline: float | ArrayLike | None = 0,\n3192     fill: bool = False,\n3193     data=None,\n3194     **kwargs,\n3195 ) -> StepPatch:\n3196     return gca().stairs(\n3197         values,\n3198         edges=edges,\n3199         orientation=orientation,\n3200         baseline=baseline,\n3201         fill=fill,\n3202         **({\"data\": data} if data is not None else {}),\n3203         **kwargs,\n3204     )\n3205 \n3206 \n3207 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3208 @_copy_docstring_and_deprecators(Axes.hist2d)\n3209 def hist2d(\n3210     x: ArrayLike,\n3211     y: ArrayLike,\n3212     bins: None | int | tuple[int, int] | ArrayLike | tuple[ArrayLike, ArrayLike] = 10,\n3213     range: ArrayLike | None = None,\n3214     density: bool = False,\n3215     weights: ArrayLike | None = None,\n3216     cmin: float | None = None,\n3217     cmax: float | None = None,\n3218     *,\n3219     data=None,\n3220     **kwargs,\n3221 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, QuadMesh]:\n3222     __ret = gca().hist2d(\n3223         x,\n3224         y,\n3225         bins=bins,\n3226         range=range,\n3227         density=density,\n3228         weights=weights,\n3229         cmin=cmin,\n3230         cmax=cmax,\n3231         **({\"data\": data} if data is not None else {}),\n3232         **kwargs,\n3233     )\n3234     sci(__ret[-1])\n3235     return __ret\n3236 \n3237 \n3238 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3239 @_copy_docstring_and_deprecators(Axes.hlines)\n3240 def hlines(\n3241     y: float | ArrayLike,\n3242     xmin: float | ArrayLike,\n3243     xmax: float | ArrayLike,\n3244     colors: ColorType | Sequence[ColorType] | None = None,\n3245     linestyles: LineStyleType = \"solid\",\n3246     label: str = \"\",\n3247     *,\n3248     data=None,\n3249     **kwargs,\n3250 ) -> LineCollection:\n3251     return gca().hlines(\n3252         y,\n3253         xmin,\n3254         xmax,\n3255         colors=colors,\n3256         linestyles=linestyles,\n3257         label=label,\n3258         **({\"data\": data} if data is not None else {}),\n3259         **kwargs,\n3260     )\n3261 \n3262 \n3263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3264 @_copy_docstring_and_deprecators(Axes.imshow)\n3265 def imshow(\n3266     X: ArrayLike | PIL.Image.Image,\n3267     cmap: str | Colormap | None = None,\n3268     norm: str | Normalize | None = None,\n3269     *,\n3270     aspect: Literal[\"equal\", \"auto\"] | float | None = None,\n3271     interpolation: str | None = None,\n3272     alpha: float | ArrayLike | None = None,\n3273     vmin: float | None = None,\n3274     vmax: float | None = None,\n3275     origin: Literal[\"upper\", \"lower\"] | None = None,\n3276     extent: tuple[float, float, float, float] | None = None,\n3277     interpolation_stage: Literal[\"data\", \"rgba\"] | None = None,\n3278     filternorm: bool = True,\n3279     filterrad: float = 4.0,\n3280     resample: bool | None = None,\n3281     url: str | None = None,\n3282     data=None,\n3283     **kwargs,\n3284 ) -> AxesImage:\n3285     __ret = gca().imshow(\n3286         X,\n3287         cmap=cmap,\n3288         norm=norm,\n3289         aspect=aspect,\n3290         interpolation=interpolation,\n3291         alpha=alpha,\n3292         vmin=vmin,\n3293         vmax=vmax,\n3294         origin=origin,\n3295         extent=extent,\n3296         interpolation_stage=interpolation_stage,\n3297         filternorm=filternorm,\n3298         filterrad=filterrad,\n3299         resample=resample,\n3300         url=url,\n3301         **({\"data\": data} if data is not None else {}),\n3302         **kwargs,\n3303     )\n3304     sci(__ret)\n3305     return __ret\n3306 \n3307 \n3308 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3309 @_copy_docstring_and_deprecators(Axes.legend)\n3310 def legend(*args, **kwargs) -> Legend:\n3311     return gca().legend(*args, **kwargs)\n3312 \n3313 \n3314 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3315 @_copy_docstring_and_deprecators(Axes.locator_params)\n3316 def locator_params(\n3317     axis: Literal[\"both\", \"x\", \"y\"] = \"both\", tight: bool | None = None, **kwargs\n3318 ) -> None:\n3319     gca().locator_params(axis=axis, tight=tight, **kwargs)\n3320 \n3321 \n3322 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3323 @_copy_docstring_and_deprecators(Axes.loglog)\n3324 def loglog(*args, **kwargs) -> list[Line2D]:\n3325     return gca().loglog(*args, **kwargs)\n3326 \n3327 \n3328 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3329 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)\n3330 def magnitude_spectrum(\n3331     x: ArrayLike,\n3332     Fs: float | None = None,\n3333     Fc: int | None = None,\n3334     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n3335     pad_to: int | None = None,\n3336     sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n3337     scale: Literal[\"default\", \"linear\", \"dB\"] | None = None,\n3338     *,\n3339     data=None,\n3340     **kwargs,\n3341 ) -> tuple[np.ndarray, np.ndarray, Line2D]:\n3342     return gca().magnitude_spectrum(\n3343         x,\n3344         Fs=Fs,\n3345         Fc=Fc,\n3346         window=window,\n3347         pad_to=pad_to,\n3348         sides=sides,\n3349         scale=scale,\n3350         **({\"data\": data} if data is not None else {}),\n3351         **kwargs,\n3352     )\n3353 \n3354 \n3355 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3356 @_copy_docstring_and_deprecators(Axes.margins)\n3357 def margins(\n3358     *margins: float,\n3359     x: float | None = None,\n3360     y: float | None = None,\n3361     tight: bool | None = True,\n3362 ) -> tuple[float, float] | None:\n3363     return gca().margins(*margins, x=x, y=y, tight=tight)\n3364 \n3365 \n3366 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3367 @_copy_docstring_and_deprecators(Axes.minorticks_off)\n3368 def minorticks_off() -> None:\n3369     gca().minorticks_off()\n3370 \n3371 \n3372 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3373 @_copy_docstring_and_deprecators(Axes.minorticks_on)\n3374 def minorticks_on() -> None:\n3375     gca().minorticks_on()\n3376 \n3377 \n3378 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3379 @_copy_docstring_and_deprecators(Axes.pcolor)\n3380 def pcolor(\n3381     *args: ArrayLike,\n3382     shading: Literal[\"flat\", \"nearest\", \"auto\"] | None = None,\n3383     alpha: float | None = None,\n3384     norm: str | Normalize | None = None,\n3385     cmap: str | Colormap | None = None,\n3386     vmin: float | None = None,\n3387     vmax: float | None = None,\n3388     data=None,\n3389     **kwargs,\n3390 ) -> Collection:\n3391     __ret = gca().pcolor(\n3392         *args,\n3393         shading=shading,\n3394         alpha=alpha,\n3395         norm=norm,\n3396         cmap=cmap,\n3397         vmin=vmin,\n3398         vmax=vmax,\n3399         **({\"data\": data} if data is not None else {}),\n3400         **kwargs,\n3401     )\n3402     sci(__ret)\n3403     return __ret\n3404 \n3405 \n3406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3407 @_copy_docstring_and_deprecators(Axes.pcolormesh)\n3408 def pcolormesh(\n3409     *args: ArrayLike,\n3410     alpha: float | None = None,\n3411     norm: str | Normalize | None = None,\n3412     cmap: str | Colormap | None = None,\n3413     vmin: float | None = None,\n3414     vmax: float | None = None,\n3415     shading: Literal[\"flat\", \"nearest\", \"gouraud\", \"auto\"] | None = None,\n3416     antialiased: bool = False,\n3417     data=None,\n3418     **kwargs,\n3419 ) -> QuadMesh:\n3420     __ret = gca().pcolormesh(\n3421         *args,\n3422         alpha=alpha,\n3423         norm=norm,\n3424         cmap=cmap,\n3425         vmin=vmin,\n3426         vmax=vmax,\n3427         shading=shading,\n3428         antialiased=antialiased,\n3429         **({\"data\": data} if data is not None else {}),\n3430         **kwargs,\n3431     )\n3432     sci(__ret)\n3433     return __ret\n3434 \n3435 \n3436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3437 @_copy_docstring_and_deprecators(Axes.phase_spectrum)\n3438 def phase_spectrum(\n3439     x: ArrayLike,\n3440     Fs: float | None = None,\n3441     Fc: int | None = None,\n3442     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n3443     pad_to: int | None = None,\n3444     sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n3445     *,\n3446     data=None,\n3447     **kwargs,\n3448 ) -> tuple[np.ndarray, np.ndarray, Line2D]:\n3449     return gca().phase_spectrum(\n3450         x,\n3451         Fs=Fs,\n3452         Fc=Fc,\n3453         window=window,\n3454         pad_to=pad_to,\n3455         sides=sides,\n3456         **({\"data\": data} if data is not None else {}),\n3457         **kwargs,\n3458     )\n3459 \n3460 \n3461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3462 @_copy_docstring_and_deprecators(Axes.pie)\n3463 def pie(\n3464     x: ArrayLike,\n3465     explode: ArrayLike | None = None,\n3466     labels: Sequence[str] | None = None,\n3467     colors: ColorType | Sequence[ColorType] | None = None,\n3468     autopct: str | Callable[[float], str] | None = None,\n3469     pctdistance: float = 0.6,\n3470     shadow: bool = False,\n3471     labeldistance: float | None = 1.1,\n3472     startangle: float = 0,\n3473     radius: float = 1,\n3474     counterclock: bool = True,\n3475     wedgeprops: dict[str, Any] | None = None,\n3476     textprops: dict[str, Any] | None = None,\n3477     center: tuple[float, float] = (0, 0),\n3478     frame: bool = False,\n3479     rotatelabels: bool = False,\n3480     *,\n3481     normalize: bool = True,\n3482     hatch: str | Sequence[str] | None = None,\n3483     data=None,\n3484 ) -> tuple[list[Wedge], list[Text]] | tuple[list[Wedge], list[Text], list[Text]]:\n3485     return gca().pie(\n3486         x,\n3487         explode=explode,\n3488         labels=labels,\n3489         colors=colors,\n3490         autopct=autopct,\n3491         pctdistance=pctdistance,\n3492         shadow=shadow,\n3493         labeldistance=labeldistance,\n3494         startangle=startangle,\n3495         radius=radius,\n3496         counterclock=counterclock,\n3497         wedgeprops=wedgeprops,\n3498         textprops=textprops,\n3499         center=center,\n3500         frame=frame,\n3501         rotatelabels=rotatelabels,\n3502         normalize=normalize,\n3503         hatch=hatch,\n3504         **({\"data\": data} if data is not None else {}),\n3505     )\n3506 \n3507 \n3508 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3509 @_copy_docstring_and_deprecators(Axes.plot)\n3510 def plot(\n3511     *args: float | ArrayLike | str,\n3512     scalex: bool = True,\n3513     scaley: bool = True,\n3514     data=None,\n3515     **kwargs,\n3516 ) -> list[Line2D]:\n3517     return gca().plot(\n3518         *args,\n3519         scalex=scalex,\n3520         scaley=scaley,\n3521         **({\"data\": data} if data is not None else {}),\n3522         **kwargs,\n3523     )\n3524 \n3525 \n3526 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3527 @_copy_docstring_and_deprecators(Axes.plot_date)\n3528 def plot_date(\n3529     x: ArrayLike,\n3530     y: ArrayLike,\n3531     fmt: str = \"o\",\n3532     tz: str | datetime.tzinfo | None = None,\n3533     xdate: bool = True,\n3534     ydate: bool = False,\n3535     *,\n3536     data=None,\n3537     **kwargs,\n3538 ) -> list[Line2D]:\n3539     return gca().plot_date(\n3540         x,\n3541         y,\n3542         fmt=fmt,\n3543         tz=tz,\n3544         xdate=xdate,\n3545         ydate=ydate,\n3546         **({\"data\": data} if data is not None else {}),\n3547         **kwargs,\n3548     )\n3549 \n3550 \n3551 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3552 @_copy_docstring_and_deprecators(Axes.psd)\n3553 def psd(\n3554     x: ArrayLike,\n3555     NFFT: int | None = None,\n3556     Fs: float | None = None,\n3557     Fc: int | None = None,\n3558     detrend: Literal[\"none\", \"mean\", \"linear\"]\n3559     | Callable[[ArrayLike], ArrayLike]\n3560     | None = None,\n3561     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n3562     noverlap: int | None = None,\n3563     pad_to: int | None = None,\n3564     sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n3565     scale_by_freq: bool | None = None,\n3566     return_line: bool | None = None,\n3567     *,\n3568     data=None,\n3569     **kwargs,\n3570 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:\n3571     return gca().psd(\n3572         x,\n3573         NFFT=NFFT,\n3574         Fs=Fs,\n3575         Fc=Fc,\n3576         detrend=detrend,\n3577         window=window,\n3578         noverlap=noverlap,\n3579         pad_to=pad_to,\n3580         sides=sides,\n3581         scale_by_freq=scale_by_freq,\n3582         return_line=return_line,\n3583         **({\"data\": data} if data is not None else {}),\n3584         **kwargs,\n3585     )\n3586 \n3587 \n3588 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3589 @_copy_docstring_and_deprecators(Axes.quiver)\n3590 def quiver(*args, data=None, **kwargs) -> Quiver:\n3591     __ret = gca().quiver(\n3592         *args, **({\"data\": data} if data is not None else {}), **kwargs\n3593     )\n3594     sci(__ret)\n3595     return __ret\n3596 \n3597 \n3598 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3599 @_copy_docstring_and_deprecators(Axes.quiverkey)\n3600 def quiverkey(\n3601     Q: Quiver, X: float, Y: float, U: float, label: str, **kwargs\n3602 ) -> QuiverKey:\n3603     return gca().quiverkey(Q, X, Y, U, label, **kwargs)\n3604 \n3605 \n3606 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3607 @_copy_docstring_and_deprecators(Axes.scatter)\n3608 def scatter(\n3609     x: float | ArrayLike,\n3610     y: float | ArrayLike,\n3611     s: float | ArrayLike | None = None,\n3612     c: Sequence[ColorType] | ColorType | None = None,\n3613     marker: MarkerType | None = None,\n3614     cmap: str | Colormap | None = None,\n3615     norm: str | Normalize | None = None,\n3616     vmin: float | None = None,\n3617     vmax: float | None = None,\n3618     alpha: float | None = None,\n3619     linewidths: float | Sequence[float] | None = None,\n3620     *,\n3621     edgecolors: Literal[\"face\", \"none\"] | ColorType | Sequence[ColorType] | None = None,\n3622     plotnonfinite: bool = False,\n3623     data=None,\n3624     **kwargs,\n3625 ) -> PathCollection:\n3626     __ret = gca().scatter(\n3627         x,\n3628         y,\n3629         s=s,\n3630         c=c,\n3631         marker=marker,\n3632         cmap=cmap,\n3633         norm=norm,\n3634         vmin=vmin,\n3635         vmax=vmax,\n3636         alpha=alpha,\n3637         linewidths=linewidths,\n3638         edgecolors=edgecolors,\n3639         plotnonfinite=plotnonfinite,\n3640         **({\"data\": data} if data is not None else {}),\n3641         **kwargs,\n3642     )\n3643     sci(__ret)\n3644     return __ret\n3645 \n3646 \n3647 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3648 @_copy_docstring_and_deprecators(Axes.semilogx)\n3649 def semilogx(*args, **kwargs) -> list[Line2D]:\n3650     return gca().semilogx(*args, **kwargs)\n3651 \n3652 \n3653 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3654 @_copy_docstring_and_deprecators(Axes.semilogy)\n3655 def semilogy(*args, **kwargs) -> list[Line2D]:\n3656     return gca().semilogy(*args, **kwargs)\n3657 \n3658 \n3659 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3660 @_copy_docstring_and_deprecators(Axes.specgram)\n3661 def specgram(\n3662     x: ArrayLike,\n3663     NFFT: int | None = None,\n3664     Fs: float | None = None,\n3665     Fc: int | None = None,\n3666     detrend: Literal[\"none\", \"mean\", \"linear\"]\n3667     | Callable[[ArrayLike], ArrayLike]\n3668     | None = None,\n3669     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,\n3670     noverlap: int | None = None,\n3671     cmap: str | Colormap | None = None,\n3672     xextent: tuple[float, float] | None = None,\n3673     pad_to: int | None = None,\n3674     sides: Literal[\"default\", \"onesided\", \"twosided\"] | None = None,\n3675     scale_by_freq: bool | None = None,\n3676     mode: Literal[\"default\", \"psd\", \"magnitude\", \"angle\", \"phase\"] | None = None,\n3677     scale: Literal[\"default\", \"linear\", \"dB\"] | None = None,\n3678     vmin: float | None = None,\n3679     vmax: float | None = None,\n3680     *,\n3681     data=None,\n3682     **kwargs,\n3683 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, AxesImage]:\n3684     __ret = gca().specgram(\n3685         x,\n3686         NFFT=NFFT,\n3687         Fs=Fs,\n3688         Fc=Fc,\n3689         detrend=detrend,\n3690         window=window,\n3691         noverlap=noverlap,\n3692         cmap=cmap,\n3693         xextent=xextent,\n3694         pad_to=pad_to,\n3695         sides=sides,\n3696         scale_by_freq=scale_by_freq,\n3697         mode=mode,\n3698         scale=scale,\n3699         vmin=vmin,\n3700         vmax=vmax,\n3701         **({\"data\": data} if data is not None else {}),\n3702         **kwargs,\n3703     )\n3704     sci(__ret[-1])\n3705     return __ret\n3706 \n3707 \n3708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3709 @_copy_docstring_and_deprecators(Axes.spy)\n3710 def spy(\n3711     Z: ArrayLike,\n3712     precision: float | Literal[\"present\"] = 0,\n3713     marker: str | None = None,\n3714     markersize: float | None = None,\n3715     aspect: Literal[\"equal\", \"auto\"] | float | None = \"equal\",\n3716     origin: Literal[\"upper\", \"lower\"] = \"upper\",\n3717     **kwargs,\n3718 ) -> AxesImage:\n3719     __ret = gca().spy(\n3720         Z,\n3721         precision=precision,\n3722         marker=marker,\n3723         markersize=markersize,\n3724         aspect=aspect,\n3725         origin=origin,\n3726         **kwargs,\n3727     )\n3728     if isinstance(__ret, cm.ScalarMappable):\n3729         sci(__ret)  # noqa\n3730     return __ret\n3731 \n3732 \n3733 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3734 @_copy_docstring_and_deprecators(Axes.stackplot)\n3735 def stackplot(x, *args, labels=(), colors=None, baseline=\"zero\", data=None, **kwargs):\n3736     return gca().stackplot(\n3737         x,\n3738         *args,\n3739         labels=labels,\n3740         colors=colors,\n3741         baseline=baseline,\n3742         **({\"data\": data} if data is not None else {}),\n3743         **kwargs,\n3744     )\n3745 \n3746 \n3747 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3748 @_copy_docstring_and_deprecators(Axes.stem)\n3749 def stem(\n3750     *args: ArrayLike | str,\n3751     linefmt: str | None = None,\n3752     markerfmt: str | None = None,\n3753     basefmt: str | None = None,\n3754     bottom: float = 0,\n3755     label: str | None = None,\n3756     orientation: Literal[\"vertical\", \"horizontal\"] = \"vertical\",\n3757     data=None,\n3758 ) -> StemContainer:\n3759     return gca().stem(\n3760         *args,\n3761         linefmt=linefmt,\n3762         markerfmt=markerfmt,\n3763         basefmt=basefmt,\n3764         bottom=bottom,\n3765         label=label,\n3766         orientation=orientation,\n3767         **({\"data\": data} if data is not None else {}),\n3768     )\n3769 \n3770 \n3771 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3772 @_copy_docstring_and_deprecators(Axes.step)\n3773 def step(\n3774     x: ArrayLike,\n3775     y: ArrayLike,\n3776     *args,\n3777     where: Literal[\"pre\", \"post\", \"mid\"] = \"pre\",\n3778     data=None,\n3779     **kwargs,\n3780 ) -> list[Line2D]:\n3781     return gca().step(\n3782         x,\n3783         y,\n3784         *args,\n3785         where=where,\n3786         **({\"data\": data} if data is not None else {}),\n3787         **kwargs,\n3788     )\n3789 \n3790 \n3791 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3792 @_copy_docstring_and_deprecators(Axes.streamplot)\n3793 def streamplot(\n3794     x,\n3795     y,\n3796     u,\n3797     v,\n3798     density=1,\n3799     linewidth=None,\n3800     color=None,\n3801     cmap=None,\n3802     norm=None,\n3803     arrowsize=1,\n3804     arrowstyle=\"-|>\",\n3805     minlength=0.1,\n3806     transform=None,\n3807     zorder=None,\n3808     start_points=None,\n3809     maxlength=4.0,\n3810     integration_direction=\"both\",\n3811     broken_streamlines=True,\n3812     *,\n3813     data=None,\n3814 ):\n3815     __ret = gca().streamplot(\n3816         x,\n3817         y,\n3818         u,\n3819         v,\n3820         density=density,\n3821         linewidth=linewidth,\n3822         color=color,\n3823         cmap=cmap,\n3824         norm=norm,\n3825         arrowsize=arrowsize,\n3826         arrowstyle=arrowstyle,\n3827         minlength=minlength,\n3828         transform=transform,\n3829         zorder=zorder,\n3830         start_points=start_points,\n3831         maxlength=maxlength,\n3832         integration_direction=integration_direction,\n3833         broken_streamlines=broken_streamlines,\n3834         **({\"data\": data} if data is not None else {}),\n3835     )\n3836     sci(__ret.lines)\n3837     return __ret\n3838 \n3839 \n3840 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3841 @_copy_docstring_and_deprecators(Axes.table)\n3842 def table(\n3843     cellText=None,\n3844     cellColours=None,\n3845     cellLoc=\"right\",\n3846     colWidths=None,\n3847     rowLabels=None,\n3848     rowColours=None,\n3849     rowLoc=\"left\",\n3850     colLabels=None,\n3851     colColours=None,\n3852     colLoc=\"center\",\n3853     loc=\"bottom\",\n3854     bbox=None,\n3855     edges=\"closed\",\n3856     **kwargs,\n3857 ):\n3858     return gca().table(\n3859         cellText=cellText,\n3860         cellColours=cellColours,\n3861         cellLoc=cellLoc,\n3862         colWidths=colWidths,\n3863         rowLabels=rowLabels,\n3864         rowColours=rowColours,\n3865         rowLoc=rowLoc,\n3866         colLabels=colLabels,\n3867         colColours=colColours,\n3868         colLoc=colLoc,\n3869         loc=loc,\n3870         bbox=bbox,\n3871         edges=edges,\n3872         **kwargs,\n3873     )\n3874 \n3875 \n3876 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3877 @_copy_docstring_and_deprecators(Axes.text)\n3878 def text(\n3879     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs\n3880 ) -> Text:\n3881     return gca().text(x, y, s, fontdict=fontdict, **kwargs)\n3882 \n3883 \n3884 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3885 @_copy_docstring_and_deprecators(Axes.tick_params)\n3886 def tick_params(axis: Literal[\"both\", \"x\", \"y\"] = \"both\", **kwargs) -> None:\n3887     gca().tick_params(axis=axis, **kwargs)\n3888 \n3889 \n3890 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3891 @_copy_docstring_and_deprecators(Axes.ticklabel_format)\n3892 def ticklabel_format(\n3893     *,\n3894     axis: Literal[\"both\", \"x\", \"y\"] = \"both\",\n3895     style: Literal[\"\", \"sci\", \"scientific\", \"plain\"] = \"\",\n3896     scilimits: tuple[int, int] | None = None,\n3897     useOffset: bool | float | None = None,\n3898     useLocale: bool | None = None,\n3899     useMathText: bool | None = None,\n3900 ) -> None:\n3901     gca().ticklabel_format(\n3902         axis=axis,\n3903         style=style,\n3904         scilimits=scilimits,\n3905         useOffset=useOffset,\n3906         useLocale=useLocale,\n3907         useMathText=useMathText,\n3908     )\n3909 \n3910 \n3911 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3912 @_copy_docstring_and_deprecators(Axes.tricontour)\n3913 def tricontour(*args, **kwargs):\n3914     __ret = gca().tricontour(*args, **kwargs)\n3915     if __ret._A is not None:  # type: ignore[attr-defined]\n3916         sci(__ret)\n3917     return __ret\n3918 \n3919 \n3920 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3921 @_copy_docstring_and_deprecators(Axes.tricontourf)\n3922 def tricontourf(*args, **kwargs):\n3923     __ret = gca().tricontourf(*args, **kwargs)\n3924     if __ret._A is not None:  # type: ignore[attr-defined]\n3925         sci(__ret)\n3926     return __ret\n3927 \n3928 \n3929 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3930 @_copy_docstring_and_deprecators(Axes.tripcolor)\n3931 def tripcolor(\n3932     *args,\n3933     alpha=1.0,\n3934     norm=None,\n3935     cmap=None,\n3936     vmin=None,\n3937     vmax=None,\n3938     shading=\"flat\",\n3939     facecolors=None,\n3940     **kwargs,\n3941 ):\n3942     __ret = gca().tripcolor(\n3943         *args,\n3944         alpha=alpha,\n3945         norm=norm,\n3946         cmap=cmap,\n3947         vmin=vmin,\n3948         vmax=vmax,\n3949         shading=shading,\n3950         facecolors=facecolors,\n3951         **kwargs,\n3952     )\n3953     sci(__ret)\n3954     return __ret\n3955 \n3956 \n3957 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3958 @_copy_docstring_and_deprecators(Axes.triplot)\n3959 def triplot(*args, **kwargs):\n3960     return gca().triplot(*args, **kwargs)\n3961 \n3962 \n3963 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3964 @_copy_docstring_and_deprecators(Axes.violinplot)\n3965 def violinplot(\n3966     dataset: ArrayLike | Sequence[ArrayLike],\n3967     positions: ArrayLike | None = None,\n3968     vert: bool = True,\n3969     widths: float | ArrayLike = 0.5,\n3970     showmeans: bool = False,\n3971     showextrema: bool = True,\n3972     showmedians: bool = False,\n3973     quantiles: Sequence[float | Sequence[float]] | None = None,\n3974     points: int = 100,\n3975     bw_method: Literal[\"scott\", \"silverman\"]\n3976     | float\n3977     | Callable[[GaussianKDE], float]\n3978     | None = None,\n3979     *,\n3980     data=None,\n3981 ) -> dict[str, Collection]:\n3982     return gca().violinplot(\n3983         dataset,\n3984         positions=positions,\n3985         vert=vert,\n3986         widths=widths,\n3987         showmeans=showmeans,\n3988         showextrema=showextrema,\n3989         showmedians=showmedians,\n3990         quantiles=quantiles,\n3991         points=points,\n3992         bw_method=bw_method,\n3993         **({\"data\": data} if data is not None else {}),\n3994     )\n3995 \n3996 \n3997 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3998 @_copy_docstring_and_deprecators(Axes.vlines)\n3999 def vlines(\n4000     x: float | ArrayLike,\n4001     ymin: float | ArrayLike,\n4002     ymax: float | ArrayLike,\n4003     colors: ColorType | Sequence[ColorType] | None = None,\n4004     linestyles: LineStyleType = \"solid\",\n4005     label: str = \"\",\n4006     *,\n4007     data=None,\n4008     **kwargs,\n4009 ) -> LineCollection:\n4010     return gca().vlines(\n4011         x,\n4012         ymin,\n4013         ymax,\n4014         colors=colors,\n4015         linestyles=linestyles,\n4016         label=label,\n4017         **({\"data\": data} if data is not None else {}),\n4018         **kwargs,\n4019     )\n4020 \n4021 \n4022 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4023 @_copy_docstring_and_deprecators(Axes.xcorr)\n4024 def xcorr(\n4025     x: ArrayLike,\n4026     y: ArrayLike,\n4027     normed: bool = True,\n4028     detrend: Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,\n4029     usevlines: bool = True,\n4030     maxlags: int = 10,\n4031     *,\n4032     data=None,\n4033     **kwargs,\n4034 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:\n4035     return gca().xcorr(\n4036         x,\n4037         y,\n4038         normed=normed,\n4039         detrend=detrend,\n4040         usevlines=usevlines,\n4041         maxlags=maxlags,\n4042         **({\"data\": data} if data is not None else {}),\n4043         **kwargs,\n4044     )\n4045 \n4046 \n4047 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4048 @_copy_docstring_and_deprecators(Axes._sci)\n4049 def sci(im: ScalarMappable) -> None:\n4050     gca()._sci(im)\n4051 \n4052 \n4053 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4054 @_copy_docstring_and_deprecators(Axes.set_title)\n4055 def title(\n4056     label: str,\n4057     fontdict: dict[str, Any] | None = None,\n4058     loc: Literal[\"left\", \"center\", \"right\"] | None = None,\n4059     pad: float | None = None,\n4060     *,\n4061     y: float | None = None,\n4062     **kwargs,\n4063 ) -> Text:\n4064     return gca().set_title(label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)\n4065 \n4066 \n4067 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4068 @_copy_docstring_and_deprecators(Axes.set_xlabel)\n4069 def xlabel(\n4070     xlabel: str,\n4071     fontdict: dict[str, Any] | None = None,\n4072     labelpad: float | None = None,\n4073     *,\n4074     loc: Literal[\"left\", \"center\", \"right\"] | None = None,\n4075     **kwargs,\n4076 ) -> Text:\n4077     return gca().set_xlabel(\n4078         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs\n4079     )\n4080 \n4081 \n4082 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4083 @_copy_docstring_and_deprecators(Axes.set_ylabel)\n4084 def ylabel(\n4085     ylabel: str,\n4086     fontdict: dict[str, Any] | None = None,\n4087     labelpad: float | None = None,\n4088     *,\n4089     loc: Literal[\"bottom\", \"center\", \"top\"] | None = None,\n4090     **kwargs,\n4091 ) -> Text:\n4092     return gca().set_ylabel(\n4093         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs\n4094     )\n4095 \n4096 \n4097 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4098 @_copy_docstring_and_deprecators(Axes.set_xscale)\n4099 def xscale(value: str | ScaleBase, **kwargs) -> None:\n4100     gca().set_xscale(value, **kwargs)\n4101 \n4102 \n4103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4104 @_copy_docstring_and_deprecators(Axes.set_yscale)\n4105 def yscale(value: str | ScaleBase, **kwargs) -> None:\n4106     gca().set_yscale(value, **kwargs)\n4107 \n4108 \n4109 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4110 def autumn() -> None:\n4111     \"\"\"\n4112     Set the colormap to 'autumn'.\n4113 \n4114     This changes the default colormap as well as the colormap of the current\n4115     image if there is one. See ``help(colormaps)`` for more information.\n4116     \"\"\"\n4117     set_cmap(\"autumn\")\n4118 \n4119 \n4120 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4121 def bone() -> None:\n4122     \"\"\"\n4123     Set the colormap to 'bone'.\n4124 \n4125     This changes the default colormap as well as the colormap of the current\n4126     image if there is one. See ``help(colormaps)`` for more information.\n4127     \"\"\"\n4128     set_cmap(\"bone\")\n4129 \n4130 \n4131 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4132 def cool() -> None:\n4133     \"\"\"\n4134     Set the colormap to 'cool'.\n4135 \n4136     This changes the default colormap as well as the colormap of the current\n4137     image if there is one. See ``help(colormaps)`` for more information.\n4138     \"\"\"\n4139     set_cmap(\"cool\")\n4140 \n4141 \n4142 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4143 def copper() -> None:\n4144     \"\"\"\n4145     Set the colormap to 'copper'.\n4146 \n4147     This changes the default colormap as well as the colormap of the current\n4148     image if there is one. See ``help(colormaps)`` for more information.\n4149     \"\"\"\n4150     set_cmap(\"copper\")\n4151 \n4152 \n4153 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4154 def flag() -> None:\n4155     \"\"\"\n4156     Set the colormap to 'flag'.\n4157 \n4158     This changes the default colormap as well as the colormap of the current\n4159     image if there is one. See ``help(colormaps)`` for more information.\n4160     \"\"\"\n4161     set_cmap(\"flag\")\n4162 \n4163 \n4164 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4165 def gray() -> None:\n4166     \"\"\"\n4167     Set the colormap to 'gray'.\n4168 \n4169     This changes the default colormap as well as the colormap of the current\n4170     image if there is one. See ``help(colormaps)`` for more information.\n4171     \"\"\"\n4172     set_cmap(\"gray\")\n4173 \n4174 \n4175 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4176 def hot() -> None:\n4177     \"\"\"\n4178     Set the colormap to 'hot'.\n4179 \n4180     This changes the default colormap as well as the colormap of the current\n4181     image if there is one. See ``help(colormaps)`` for more information.\n4182     \"\"\"\n4183     set_cmap(\"hot\")\n4184 \n4185 \n4186 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4187 def hsv() -> None:\n4188     \"\"\"\n4189     Set the colormap to 'hsv'.\n4190 \n4191     This changes the default colormap as well as the colormap of the current\n4192     image if there is one. See ``help(colormaps)`` for more information.\n4193     \"\"\"\n4194     set_cmap(\"hsv\")\n4195 \n4196 \n4197 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4198 def jet() -> None:\n4199     \"\"\"\n4200     Set the colormap to 'jet'.\n4201 \n4202     This changes the default colormap as well as the colormap of the current\n4203     image if there is one. See ``help(colormaps)`` for more information.\n4204     \"\"\"\n4205     set_cmap(\"jet\")\n4206 \n4207 \n4208 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4209 def pink() -> None:\n4210     \"\"\"\n4211     Set the colormap to 'pink'.\n4212 \n4213     This changes the default colormap as well as the colormap of the current\n4214     image if there is one. See ``help(colormaps)`` for more information.\n4215     \"\"\"\n4216     set_cmap(\"pink\")\n4217 \n4218 \n4219 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4220 def prism() -> None:\n4221     \"\"\"\n4222     Set the colormap to 'prism'.\n4223 \n4224     This changes the default colormap as well as the colormap of the current\n4225     image if there is one. See ``help(colormaps)`` for more information.\n4226     \"\"\"\n4227     set_cmap(\"prism\")\n4228 \n4229 \n4230 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4231 def spring() -> None:\n4232     \"\"\"\n4233     Set the colormap to 'spring'.\n4234 \n4235     This changes the default colormap as well as the colormap of the current\n4236     image if there is one. See ``help(colormaps)`` for more information.\n4237     \"\"\"\n4238     set_cmap(\"spring\")\n4239 \n4240 \n4241 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4242 def summer() -> None:\n4243     \"\"\"\n4244     Set the colormap to 'summer'.\n4245 \n4246     This changes the default colormap as well as the colormap of the current\n4247     image if there is one. See ``help(colormaps)`` for more information.\n4248     \"\"\"\n4249     set_cmap(\"summer\")\n4250 \n4251 \n4252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4253 def winter() -> None:\n4254     \"\"\"\n4255     Set the colormap to 'winter'.\n4256 \n4257     This changes the default colormap as well as the colormap of the current\n4258     image if there is one. See ``help(colormaps)`` for more information.\n4259     \"\"\"\n4260     set_cmap(\"winter\")\n4261 \n4262 \n4263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4264 def magma() -> None:\n4265     \"\"\"\n4266     Set the colormap to 'magma'.\n4267 \n4268     This changes the default colormap as well as the colormap of the current\n4269     image if there is one. See ``help(colormaps)`` for more information.\n4270     \"\"\"\n4271     set_cmap(\"magma\")\n4272 \n4273 \n4274 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4275 def inferno() -> None:\n4276     \"\"\"\n4277     Set the colormap to 'inferno'.\n4278 \n4279     This changes the default colormap as well as the colormap of the current\n4280     image if there is one. See ``help(colormaps)`` for more information.\n4281     \"\"\"\n4282     set_cmap(\"inferno\")\n4283 \n4284 \n4285 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4286 def plasma() -> None:\n4287     \"\"\"\n4288     Set the colormap to 'plasma'.\n4289 \n4290     This changes the default colormap as well as the colormap of the current\n4291     image if there is one. See ``help(colormaps)`` for more information.\n4292     \"\"\"\n4293     set_cmap(\"plasma\")\n4294 \n4295 \n4296 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4297 def viridis() -> None:\n4298     \"\"\"\n4299     Set the colormap to 'viridis'.\n4300 \n4301     This changes the default colormap as well as the colormap of the current\n4302     image if there is one. See ``help(colormaps)`` for more information.\n4303     \"\"\"\n4304     set_cmap(\"viridis\")\n4305 \n4306 \n4307 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n4308 def nipy_spectral() -> None:\n4309     \"\"\"\n4310     Set the colormap to 'nipy_spectral'.\n4311 \n4312     This changes the default colormap as well as the colormap of the current\n4313     image if there is one. See ``help(colormaps)`` for more information.\n4314     \"\"\"\n4315     set_cmap(\"nipy_spectral\")\n",
        "intended_behavior": "Modify or extend the backend switching functionality to check for any open GUI windows and ensure they remain operational and visible even after switching back to the inline backend. This would likely involve adding a mechanism to remember or manage GUI backend state that can live alongside inline plotting without prematurely disposing of GUI windows."
    },
    {
        "rel_file_path": "lib/matplotlib/backend_bases.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/backend_bases.py",
        "start": 1,
        "end": 3472,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Abstract base classes define the primitives that renderers and\n3 graphics contexts must implement to serve as a Matplotlib backend.\n4 \n5 `RendererBase`\n6     An abstract base class to handle drawing/rendering operations.\n7 \n8 `FigureCanvasBase`\n9     The abstraction layer that separates the `.Figure` from the backend\n10     specific details like a user interface drawing area.\n11 \n12 `GraphicsContextBase`\n13     An abstract base class that provides color, line styles, etc.\n14 \n15 `Event`\n16     The base class for all of the Matplotlib event handling.  Derived classes\n17     such as `KeyEvent` and `MouseEvent` store the meta data like keys and\n18     buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates.\n19 \n20 `ShowBase`\n21     The base class for the ``Show`` class of each interactive backend; the\n22     'show' callable is then set to ``Show.__call__``.\n23 \n24 `ToolContainerBase`\n25     The base class for the Toolbar class of each interactive backend.\n26 \"\"\"\n27 \n28 from collections import namedtuple\n29 from contextlib import ExitStack, contextmanager, nullcontext\n30 from enum import Enum, IntEnum\n31 import functools\n32 import importlib\n33 import inspect\n34 import io\n35 import itertools\n36 import logging\n37 import os\n38 import sys\n39 import time\n40 import weakref\n41 from weakref import WeakKeyDictionary\n42 \n43 import numpy as np\n44 \n45 import matplotlib as mpl\n46 from matplotlib import (\n47     _api, backend_tools as tools, cbook, colors, _docstring, text,\n48     _tight_bbox, transforms, widgets, get_backend, is_interactive, rcParams)\n49 from matplotlib._pylab_helpers import Gcf\n50 from matplotlib.backend_managers import ToolManager\n51 from matplotlib.cbook import _setattr_cm\n52 from matplotlib.layout_engine import ConstrainedLayoutEngine\n53 from matplotlib.path import Path\n54 from matplotlib.texmanager import TexManager\n55 from matplotlib.transforms import Affine2D\n56 from matplotlib._enums import JoinStyle, CapStyle\n57 \n58 \n59 _log = logging.getLogger(__name__)\n60 _default_filetypes = {\n61     'eps': 'Encapsulated Postscript',\n62     'jpg': 'Joint Photographic Experts Group',\n63     'jpeg': 'Joint Photographic Experts Group',\n64     'pdf': 'Portable Document Format',\n65     'pgf': 'PGF code for LaTeX',\n66     'png': 'Portable Network Graphics',\n67     'ps': 'Postscript',\n68     'raw': 'Raw RGBA bitmap',\n69     'rgba': 'Raw RGBA bitmap',\n70     'svg': 'Scalable Vector Graphics',\n71     'svgz': 'Scalable Vector Graphics',\n72     'tif': 'Tagged Image File Format',\n73     'tiff': 'Tagged Image File Format',\n74     'webp': 'WebP Image Format',\n75 }\n76 _default_backends = {\n77     'eps': 'matplotlib.backends.backend_ps',\n78     'jpg': 'matplotlib.backends.backend_agg',\n79     'jpeg': 'matplotlib.backends.backend_agg',\n80     'pdf': 'matplotlib.backends.backend_pdf',\n81     'pgf': 'matplotlib.backends.backend_pgf',\n82     'png': 'matplotlib.backends.backend_agg',\n83     'ps': 'matplotlib.backends.backend_ps',\n84     'raw': 'matplotlib.backends.backend_agg',\n85     'rgba': 'matplotlib.backends.backend_agg',\n86     'svg': 'matplotlib.backends.backend_svg',\n87     'svgz': 'matplotlib.backends.backend_svg',\n88     'tif': 'matplotlib.backends.backend_agg',\n89     'tiff': 'matplotlib.backends.backend_agg',\n90     'webp': 'matplotlib.backends.backend_agg',\n91 }\n92 \n93 \n94 def _safe_pyplot_import():\n95     \"\"\"\n96     Import and return ``pyplot``, correctly setting the backend if one is\n97     already forced.\n98     \"\"\"\n99     try:\n100         import matplotlib.pyplot as plt\n101     except ImportError:  # Likely due to a framework mismatch.\n102         current_framework = cbook._get_running_interactive_framework()\n103         if current_framework is None:\n104             raise  # No, something else went wrong, likely with the install...\n105         backend_mapping = {\n106             'qt': 'qtagg',\n107             'gtk3': 'gtk3agg',\n108             'gtk4': 'gtk4agg',\n109             'wx': 'wxagg',\n110             'tk': 'tkagg',\n111             'macosx': 'macosx',\n112             'headless': 'agg',\n113         }\n114         backend = backend_mapping[current_framework]\n115         rcParams[\"backend\"] = mpl.rcParamsOrig[\"backend\"] = backend\n116         import matplotlib.pyplot as plt  # Now this should succeed.\n117     return plt\n118 \n119 \n120 def register_backend(format, backend, description=None):\n121     \"\"\"\n122     Register a backend for saving to a given file format.\n123 \n124     Parameters\n125     ----------\n126     format : str\n127         File extension\n128     backend : module string or canvas class\n129         Backend for handling file output\n130     description : str, default: \"\"\n131         Description of the file type.\n132     \"\"\"\n133     if description is None:\n134         description = ''\n135     _default_backends[format] = backend\n136     _default_filetypes[format] = description\n137 \n138 \n139 def get_registered_canvas_class(format):\n140     \"\"\"\n141     Return the registered default canvas for given file format.\n142     Handles deferred import of required backend.\n143     \"\"\"\n144     if format not in _default_backends:\n145         return None\n146     backend_class = _default_backends[format]\n147     if isinstance(backend_class, str):\n148         backend_class = importlib.import_module(backend_class).FigureCanvas\n149         _default_backends[format] = backend_class\n150     return backend_class\n151 \n152 \n153 class RendererBase:\n154     \"\"\"\n155     An abstract base class to handle drawing/rendering operations.\n156 \n157     The following methods must be implemented in the backend for full\n158     functionality (though just implementing `draw_path` alone would give a\n159     highly capable backend):\n160 \n161     * `draw_path`\n162     * `draw_image`\n163     * `draw_gouraud_triangles`\n164 \n165     The following methods *should* be implemented in the backend for\n166     optimization reasons:\n167 \n168     * `draw_text`\n169     * `draw_markers`\n170     * `draw_path_collection`\n171     * `draw_quad_mesh`\n172     \"\"\"\n173     def __init__(self):\n174         super().__init__()\n175         self._texmanager = None\n176         self._text2path = text.TextToPath()\n177         self._raster_depth = 0\n178         self._rasterizing = False\n179 \n180     def open_group(self, s, gid=None):\n181         \"\"\"\n182         Open a grouping element with label *s* and *gid* (if set) as id.\n183 \n184         Only used by the SVG renderer.\n185         \"\"\"\n186 \n187     def close_group(self, s):\n188         \"\"\"\n189         Close a grouping element with label *s*.\n190 \n191         Only used by the SVG renderer.\n192         \"\"\"\n193 \n194     def draw_path(self, gc, path, transform, rgbFace=None):\n195         \"\"\"Draw a `~.path.Path` instance using the given affine transform.\"\"\"\n196         raise NotImplementedError\n197 \n198     def draw_markers(self, gc, marker_path, marker_trans, path,\n199                      trans, rgbFace=None):\n200         \"\"\"\n201         Draw a marker at each of *path*'s vertices (excluding control points).\n202 \n203         The base (fallback) implementation makes multiple calls to `draw_path`.\n204         Backends may want to override this method in order to draw the marker\n205         only once and reuse it multiple times.\n206 \n207         Parameters\n208         ----------\n209         gc : `.GraphicsContextBase`\n210             The graphics context.\n211         marker_trans : `~matplotlib.transforms.Transform`\n212             An affine transform applied to the marker.\n213         trans : `~matplotlib.transforms.Transform`\n214             An affine transform applied to the path.\n215         \"\"\"\n216         for vertices, codes in path.iter_segments(trans, simplify=False):\n217             if len(vertices):\n218                 x, y = vertices[-2:]\n219                 self.draw_path(gc, marker_path,\n220                                marker_trans +\n221                                transforms.Affine2D().translate(x, y),\n222                                rgbFace)\n223 \n224     def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n225                              offsets, offset_trans, facecolors, edgecolors,\n226                              linewidths, linestyles, antialiaseds, urls,\n227                              offset_position):\n228         \"\"\"\n229         Draw a collection of *paths*.\n230 \n231         Each path is first transformed by the corresponding entry\n232         in *all_transforms* (a list of (3, 3) matrices) and then by\n233         *master_transform*.  They are then translated by the corresponding\n234         entry in *offsets*, which has been first transformed by *offset_trans*.\n235 \n236         *facecolors*, *edgecolors*, *linewidths*, *linestyles*, and\n237         *antialiased* are lists that set the corresponding properties.\n238 \n239         *offset_position* is unused now, but the argument is kept for\n240         backwards compatibility.\n241 \n242         The base (fallback) implementation makes multiple calls to `draw_path`.\n243         Backends may want to override this in order to render each set of\n244         path data only once, and then reference that path multiple times with\n245         the different offsets, colors, styles etc.  The generator methods\n246         `_iter_collection_raw_paths` and `_iter_collection` are provided to\n247         help with (and standardize) the implementation across backends.  It\n248         is highly recommended to use those generators, so that changes to the\n249         behavior of `draw_path_collection` can be made globally.\n250         \"\"\"\n251         path_ids = self._iter_collection_raw_paths(master_transform,\n252                                                    paths, all_transforms)\n253 \n254         for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n255                 gc, list(path_ids), offsets, offset_trans,\n256                 facecolors, edgecolors, linewidths, linestyles,\n257                 antialiaseds, urls, offset_position):\n258             path, transform = path_id\n259             # Only apply another translation if we have an offset, else we\n260             # reuse the initial transform.\n261             if xo != 0 or yo != 0:\n262                 # The transformation can be used by multiple paths. Since\n263                 # translate is a inplace operation, we need to copy the\n264                 # transformation by .frozen() before applying the translation.\n265                 transform = transform.frozen()\n266                 transform.translate(xo, yo)\n267             self.draw_path(gc0, path, transform, rgbFace)\n268 \n269     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n270                        coordinates, offsets, offsetTrans, facecolors,\n271                        antialiased, edgecolors):\n272         \"\"\"\n273         Draw a quadmesh.\n274 \n275         The base (fallback) implementation converts the quadmesh to paths and\n276         then calls `draw_path_collection`.\n277         \"\"\"\n278 \n279         from matplotlib.collections import QuadMesh\n280         paths = QuadMesh._convert_mesh_to_paths(coordinates)\n281 \n282         if edgecolors is None:\n283             edgecolors = facecolors\n284         linewidths = np.array([gc.get_linewidth()], float)\n285 \n286         return self.draw_path_collection(\n287             gc, master_transform, paths, [], offsets, offsetTrans, facecolors,\n288             edgecolors, linewidths, [], [antialiased], [None], 'screen')\n289 \n290     @_api.deprecated(\"3.7\", alternative=\"draw_gouraud_triangles\")\n291     def draw_gouraud_triangle(self, gc, points, colors, transform):\n292         \"\"\"\n293         Draw a Gouraud-shaded triangle.\n294 \n295         Parameters\n296         ----------\n297         gc : `.GraphicsContextBase`\n298             The graphics context.\n299         points : (3, 2) array-like\n300             Array of (x, y) points for the triangle.\n301         colors : (3, 4) array-like\n302             RGBA colors for each point of the triangle.\n303         transform : `~matplotlib.transforms.Transform`\n304             An affine transform to apply to the points.\n305         \"\"\"\n306         raise NotImplementedError\n307 \n308     def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n309                                transform):\n310         \"\"\"\n311         Draw a series of Gouraud triangles.\n312 \n313         Parameters\n314         ----------\n315         gc : `.GraphicsContextBase`\n316             The graphics context.\n317         triangles_array : (N, 3, 2) array-like\n318             Array of *N* (x, y) points for the triangles.\n319         colors_array : (N, 3, 4) array-like\n320             Array of *N* RGBA colors for each point of the triangles.\n321         transform : `~matplotlib.transforms.Transform`\n322             An affine transform to apply to the points.\n323         \"\"\"\n324         raise NotImplementedError\n325 \n326     def _iter_collection_raw_paths(self, master_transform, paths,\n327                                    all_transforms):\n328         \"\"\"\n329         Helper method (along with `_iter_collection`) to implement\n330         `draw_path_collection` in a memory-efficient manner.\n331 \n332         This method yields all of the base path/transform combinations, given a\n333         master transform, a list of paths and list of transforms.\n334 \n335         The arguments should be exactly what is passed in to\n336         `draw_path_collection`.\n337 \n338         The backend should take each yielded path and transform and create an\n339         object that can be referenced (reused) later.\n340         \"\"\"\n341         Npaths = len(paths)\n342         Ntransforms = len(all_transforms)\n343         N = max(Npaths, Ntransforms)\n344 \n345         if Npaths == 0:\n346             return\n347 \n348         transform = transforms.IdentityTransform()\n349         for i in range(N):\n350             path = paths[i % Npaths]\n351             if Ntransforms:\n352                 transform = Affine2D(all_transforms[i % Ntransforms])\n353             yield path, transform + master_transform\n354 \n355     def _iter_collection_uses_per_path(self, paths, all_transforms,\n356                                        offsets, facecolors, edgecolors):\n357         \"\"\"\n358         Compute how many times each raw path object returned by\n359         `_iter_collection_raw_paths` would be used when calling\n360         `_iter_collection`. This is intended for the backend to decide\n361         on the tradeoff between using the paths in-line and storing\n362         them once and reusing. Rounds up in case the number of uses\n363         is not the same for every path.\n364         \"\"\"\n365         Npaths = len(paths)\n366         if Npaths == 0 or len(facecolors) == len(edgecolors) == 0:\n367             return 0\n368         Npath_ids = max(Npaths, len(all_transforms))\n369         N = max(Npath_ids, len(offsets))\n370         return (N + Npath_ids - 1) // Npath_ids\n371 \n372     def _iter_collection(self, gc, path_ids, offsets, offset_trans, facecolors,\n373                          edgecolors, linewidths, linestyles,\n374                          antialiaseds, urls, offset_position):\n375         \"\"\"\n376         Helper method (along with `_iter_collection_raw_paths`) to implement\n377         `draw_path_collection` in a memory-efficient manner.\n378 \n379         This method yields all of the path, offset and graphics context\n380         combinations to draw the path collection.  The caller should already\n381         have looped over the results of `_iter_collection_raw_paths` to draw\n382         this collection.\n383 \n384         The arguments should be the same as that passed into\n385         `draw_path_collection`, with the exception of *path_ids*, which is a\n386         list of arbitrary objects that the backend will use to reference one of\n387         the paths created in the `_iter_collection_raw_paths` stage.\n388 \n389         Each yielded result is of the form::\n390 \n391            xo, yo, path_id, gc, rgbFace\n392 \n393         where *xo*, *yo* is an offset; *path_id* is one of the elements of\n394         *path_ids*; *gc* is a graphics context and *rgbFace* is a color to\n395         use for filling the path.\n396         \"\"\"\n397         Npaths = len(path_ids)\n398         Noffsets = len(offsets)\n399         N = max(Npaths, Noffsets)\n400         Nfacecolors = len(facecolors)\n401         Nedgecolors = len(edgecolors)\n402         Nlinewidths = len(linewidths)\n403         Nlinestyles = len(linestyles)\n404         Nurls = len(urls)\n405 \n406         if (Nfacecolors == 0 and Nedgecolors == 0) or Npaths == 0:\n407             return\n408 \n409         gc0 = self.new_gc()\n410         gc0.copy_properties(gc)\n411 \n412         def cycle_or_default(seq, default=None):\n413             # Cycle over *seq* if it is not empty; else always yield *default*.\n414             return (itertools.cycle(seq) if len(seq)\n415                     else itertools.repeat(default))\n416 \n417         pathids = cycle_or_default(path_ids)\n418         toffsets = cycle_or_default(offset_trans.transform(offsets), (0, 0))\n419         fcs = cycle_or_default(facecolors)\n420         ecs = cycle_or_default(edgecolors)\n421         lws = cycle_or_default(linewidths)\n422         lss = cycle_or_default(linestyles)\n423         aas = cycle_or_default(antialiaseds)\n424         urls = cycle_or_default(urls)\n425 \n426         if Nedgecolors == 0:\n427             gc0.set_linewidth(0.0)\n428 \n429         for pathid, (xo, yo), fc, ec, lw, ls, aa, url in itertools.islice(\n430                 zip(pathids, toffsets, fcs, ecs, lws, lss, aas, urls), N):\n431             if not (np.isfinite(xo) and np.isfinite(yo)):\n432                 continue\n433             if Nedgecolors:\n434                 if Nlinewidths:\n435                     gc0.set_linewidth(lw)\n436                 if Nlinestyles:\n437                     gc0.set_dashes(*ls)\n438                 if len(ec) == 4 and ec[3] == 0.0:\n439                     gc0.set_linewidth(0)\n440                 else:\n441                     gc0.set_foreground(ec)\n442             if fc is not None and len(fc) == 4 and fc[3] == 0:\n443                 fc = None\n444             gc0.set_antialiased(aa)\n445             if Nurls:\n446                 gc0.set_url(url)\n447             yield xo, yo, pathid, gc0, fc\n448         gc0.restore()\n449 \n450     def get_image_magnification(self):\n451         \"\"\"\n452         Get the factor by which to magnify images passed to `draw_image`.\n453         Allows a backend to have images at a different resolution to other\n454         artists.\n455         \"\"\"\n456         return 1.0\n457 \n458     def draw_image(self, gc, x, y, im, transform=None):\n459         \"\"\"\n460         Draw an RGBA image.\n461 \n462         Parameters\n463         ----------\n464         gc : `.GraphicsContextBase`\n465             A graphics context with clipping information.\n466 \n467         x : scalar\n468             The distance in physical units (i.e., dots or pixels) from the left\n469             hand side of the canvas.\n470 \n471         y : scalar\n472             The distance in physical units (i.e., dots or pixels) from the\n473             bottom side of the canvas.\n474 \n475         im : (N, M, 4) array of `numpy.uint8`\n476             An array of RGBA pixels.\n477 \n478         transform : `~matplotlib.transforms.Affine2DBase`\n479             If and only if the concrete backend is written such that\n480             `option_scale_image` returns ``True``, an affine transformation\n481             (i.e., an `.Affine2DBase`) *may* be passed to `draw_image`.  The\n482             translation vector of the transformation is given in physical units\n483             (i.e., dots or pixels). Note that the transformation does not\n484             override *x* and *y*, and has to be applied *before* translating\n485             the result by *x* and *y* (this can be accomplished by adding *x*\n486             and *y* to the translation vector defined by *transform*).\n487         \"\"\"\n488         raise NotImplementedError\n489 \n490     def option_image_nocomposite(self):\n491         \"\"\"\n492         Return whether image composition by Matplotlib should be skipped.\n493 \n494         Raster backends should usually return False (letting the C-level\n495         rasterizer take care of image composition); vector backends should\n496         usually return ``not rcParams[\"image.composite_image\"]``.\n497         \"\"\"\n498         return False\n499 \n500     def option_scale_image(self):\n501         \"\"\"\n502         Return whether arbitrary affine transformations in `draw_image` are\n503         supported (True for most vector backends).\n504         \"\"\"\n505         return False\n506 \n507     def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n508         \"\"\"\n509         Draw a TeX instance.\n510 \n511         Parameters\n512         ----------\n513         gc : `.GraphicsContextBase`\n514             The graphics context.\n515         x : float\n516             The x location of the text in display coords.\n517         y : float\n518             The y location of the text baseline in display coords.\n519         s : str\n520             The TeX text string.\n521         prop : `~matplotlib.font_manager.FontProperties`\n522             The font properties.\n523         angle : float\n524             The rotation angle in degrees anti-clockwise.\n525         mtext : `~matplotlib.text.Text`\n526             The original text object to be rendered.\n527         \"\"\"\n528         self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")\n529 \n530     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n531         \"\"\"\n532         Draw a text instance.\n533 \n534         Parameters\n535         ----------\n536         gc : `.GraphicsContextBase`\n537             The graphics context.\n538         x : float\n539             The x location of the text in display coords.\n540         y : float\n541             The y location of the text baseline in display coords.\n542         s : str\n543             The text string.\n544         prop : `~matplotlib.font_manager.FontProperties`\n545             The font properties.\n546         angle : float\n547             The rotation angle in degrees anti-clockwise.\n548         ismath : bool or \"TeX\"\n549             If True, use mathtext parser. If \"TeX\", use tex for rendering.\n550         mtext : `~matplotlib.text.Text`\n551             The original text object to be rendered.\n552 \n553         Notes\n554         -----\n555         **Note for backend implementers:**\n556 \n557         When you are trying to determine if you have gotten your bounding box\n558         right (which is what enables the text layout/alignment to work\n559         properly), it helps to change the line in text.py::\n560 \n561             if 0: bbox_artist(self, renderer)\n562 \n563         to if 1, and then the actual bounding box will be plotted along with\n564         your text.\n565         \"\"\"\n566 \n567         self._draw_text_as_path(gc, x, y, s, prop, angle, ismath)\n568 \n569     def _get_text_path_transform(self, x, y, s, prop, angle, ismath):\n570         \"\"\"\n571         Return the text path and transform.\n572 \n573         Parameters\n574         ----------\n575         x : float\n576             The x location of the text in display coords.\n577         y : float\n578             The y location of the text baseline in display coords.\n579         s : str\n580             The text to be converted.\n581         prop : `~matplotlib.font_manager.FontProperties`\n582             The font property.\n583         angle : float\n584             Angle in degrees to render the text at.\n585         ismath : bool or \"TeX\"\n586             If True, use mathtext parser. If \"TeX\", use tex for rendering.\n587         \"\"\"\n588 \n589         text2path = self._text2path\n590         fontsize = self.points_to_pixels(prop.get_size_in_points())\n591         verts, codes = text2path.get_text_path(prop, s, ismath=ismath)\n592 \n593         path = Path(verts, codes)\n594         angle = np.deg2rad(angle)\n595         if self.flipy():\n596             width, height = self.get_canvas_width_height()\n597             transform = (Affine2D()\n598                          .scale(fontsize / text2path.FONT_SCALE)\n599                          .rotate(angle)\n600                          .translate(x, height - y))\n601         else:\n602             transform = (Affine2D()\n603                          .scale(fontsize / text2path.FONT_SCALE)\n604                          .rotate(angle)\n605                          .translate(x, y))\n606 \n607         return path, transform\n608 \n609     def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):\n610         \"\"\"\n611         Draw the text by converting them to paths using `.TextToPath`.\n612 \n613         Parameters\n614         ----------\n615         gc : `.GraphicsContextBase`\n616             The graphics context.\n617         x : float\n618             The x location of the text in display coords.\n619         y : float\n620             The y location of the text baseline in display coords.\n621         s : str\n622             The text to be converted.\n623         prop : `~matplotlib.font_manager.FontProperties`\n624             The font property.\n625         angle : float\n626             Angle in degrees to render the text at.\n627         ismath : bool or \"TeX\"\n628             If True, use mathtext parser. If \"TeX\", use tex for rendering.\n629         \"\"\"\n630         path, transform = self._get_text_path_transform(\n631             x, y, s, prop, angle, ismath)\n632         color = gc.get_rgb()\n633         gc.set_linewidth(0.0)\n634         self.draw_path(gc, path, transform, rgbFace=color)\n635 \n636     def get_text_width_height_descent(self, s, prop, ismath):\n637         \"\"\"\n638         Get the width, height, and descent (offset from the bottom to the baseline), in\n639         display coords, of the string *s* with `.FontProperties` *prop*.\n640 \n641         Whitespace at the start and the end of *s* is included in the reported width.\n642         \"\"\"\n643         fontsize = prop.get_size_in_points()\n644 \n645         if ismath == 'TeX':\n646             # todo: handle properties\n647             return self.get_texmanager().get_text_width_height_descent(\n648                 s, fontsize, renderer=self)\n649 \n650         dpi = self.points_to_pixels(72)\n651         if ismath:\n652             dims = self._text2path.mathtext_parser.parse(s, dpi, prop)\n653             return dims[0:3]  # return width, height, descent\n654 \n655         flags = self._text2path._get_hinting_flag()\n656         font = self._text2path._get_font(prop)\n657         font.set_size(fontsize, dpi)\n658         # the width and height of unrotated string\n659         font.set_text(s, 0.0, flags=flags)\n660         w, h = font.get_width_height()\n661         d = font.get_descent()\n662         w /= 64.0  # convert from subpixels\n663         h /= 64.0\n664         d /= 64.0\n665         return w, h, d\n666 \n667     def flipy(self):\n668         \"\"\"\n669         Return whether y values increase from top to bottom.\n670 \n671         Note that this only affects drawing of texts.\n672         \"\"\"\n673         return True\n674 \n675     def get_canvas_width_height(self):\n676         \"\"\"Return the canvas width and height in display coords.\"\"\"\n677         return 1, 1\n678 \n679     def get_texmanager(self):\n680         \"\"\"Return the `.TexManager` instance.\"\"\"\n681         if self._texmanager is None:\n682             self._texmanager = TexManager()\n683         return self._texmanager\n684 \n685     def new_gc(self):\n686         \"\"\"Return an instance of a `.GraphicsContextBase`.\"\"\"\n687         return GraphicsContextBase()\n688 \n689     def points_to_pixels(self, points):\n690         \"\"\"\n691         Convert points to display units.\n692 \n693         You need to override this function (unless your backend\n694         doesn't have a dpi, e.g., postscript or svg).  Some imaging\n695         systems assume some value for pixels per inch::\n696 \n697             points to pixels = points * pixels_per_inch/72 * dpi/72\n698 \n699         Parameters\n700         ----------\n701         points : float or array-like\n702 \n703         Returns\n704         -------\n705         Points converted to pixels\n706         \"\"\"\n707         return points\n708 \n709     def start_rasterizing(self):\n710         \"\"\"\n711         Switch to the raster renderer.\n712 \n713         Used by `.MixedModeRenderer`.\n714         \"\"\"\n715 \n716     def stop_rasterizing(self):\n717         \"\"\"\n718         Switch back to the vector renderer and draw the contents of the raster\n719         renderer as an image on the vector renderer.\n720 \n721         Used by `.MixedModeRenderer`.\n722         \"\"\"\n723 \n724     def start_filter(self):\n725         \"\"\"\n726         Switch to a temporary renderer for image filtering effects.\n727 \n728         Currently only supported by the agg renderer.\n729         \"\"\"\n730 \n731     def stop_filter(self, filter_func):\n732         \"\"\"\n733         Switch back to the original renderer.  The contents of the temporary\n734         renderer is processed with the *filter_func* and is drawn on the\n735         original renderer as an image.\n736 \n737         Currently only supported by the agg renderer.\n738         \"\"\"\n739 \n740     def _draw_disabled(self):\n741         \"\"\"\n742         Context manager to temporary disable drawing.\n743 \n744         This is used for getting the drawn size of Artists.  This lets us\n745         run the draw process to update any Python state but does not pay the\n746         cost of the draw_XYZ calls on the canvas.\n747         \"\"\"\n748         no_ops = {\n749             meth_name: lambda *args, **kwargs: None\n750             for meth_name in dir(RendererBase)\n751             if (meth_name.startswith(\"draw_\")\n752                 or meth_name in [\"open_group\", \"close_group\"])\n753         }\n754 \n755         return _setattr_cm(self, **no_ops)\n756 \n757 \n758 class GraphicsContextBase:\n759     \"\"\"An abstract base class that provides color, line styles, etc.\"\"\"\n760 \n761     def __init__(self):\n762         self._alpha = 1.0\n763         self._forced_alpha = False  # if True, _alpha overrides A from RGBA\n764         self._antialiased = 1  # use 0, 1 not True, False for extension code\n765         self._capstyle = CapStyle('butt')\n766         self._cliprect = None\n767         self._clippath = None\n768         self._dashes = 0, None\n769         self._joinstyle = JoinStyle('round')\n770         self._linestyle = 'solid'\n771         self._linewidth = 1\n772         self._rgb = (0.0, 0.0, 0.0, 1.0)\n773         self._hatch = None\n774         self._hatch_color = colors.to_rgba(rcParams['hatch.color'])\n775         self._hatch_linewidth = rcParams['hatch.linewidth']\n776         self._url = None\n777         self._gid = None\n778         self._snap = None\n779         self._sketch = None\n780 \n781     def copy_properties(self, gc):\n782         \"\"\"Copy properties from *gc* to self.\"\"\"\n783         self._alpha = gc._alpha\n784         self._forced_alpha = gc._forced_alpha\n785         self._antialiased = gc._antialiased\n786         self._capstyle = gc._capstyle\n787         self._cliprect = gc._cliprect\n788         self._clippath = gc._clippath\n789         self._dashes = gc._dashes\n790         self._joinstyle = gc._joinstyle\n791         self._linestyle = gc._linestyle\n792         self._linewidth = gc._linewidth\n793         self._rgb = gc._rgb\n794         self._hatch = gc._hatch\n795         self._hatch_color = gc._hatch_color\n796         self._hatch_linewidth = gc._hatch_linewidth\n797         self._url = gc._url\n798         self._gid = gc._gid\n799         self._snap = gc._snap\n800         self._sketch = gc._sketch\n801 \n802     def restore(self):\n803         \"\"\"\n804         Restore the graphics context from the stack - needed only\n805         for backends that save graphics contexts on a stack.\n806         \"\"\"\n807 \n808     def get_alpha(self):\n809         \"\"\"\n810         Return the alpha value used for blending - not supported on all\n811         backends.\n812         \"\"\"\n813         return self._alpha\n814 \n815     def get_antialiased(self):\n816         \"\"\"Return whether the object should try to do antialiased rendering.\"\"\"\n817         return self._antialiased\n818 \n819     def get_capstyle(self):\n820         \"\"\"Return the `.CapStyle`.\"\"\"\n821         return self._capstyle.name\n822 \n823     def get_clip_rectangle(self):\n824         \"\"\"\n825         Return the clip rectangle as a `~matplotlib.transforms.Bbox` instance.\n826         \"\"\"\n827         return self._cliprect\n828 \n829     def get_clip_path(self):\n830         \"\"\"\n831         Return the clip path in the form (path, transform), where path\n832         is a `~.path.Path` instance, and transform is\n833         an affine transform to apply to the path before clipping.\n834         \"\"\"\n835         if self._clippath is not None:\n836             tpath, tr = self._clippath.get_transformed_path_and_affine()\n837             if np.all(np.isfinite(tpath.vertices)):\n838                 return tpath, tr\n839             else:\n840                 _log.warning(\"Ill-defined clip_path detected. Returning None.\")\n841                 return None, None\n842         return None, None\n843 \n844     def get_dashes(self):\n845         \"\"\"\n846         Return the dash style as an (offset, dash-list) pair.\n847 \n848         See `.set_dashes` for details.\n849 \n850         Default value is (None, None).\n851         \"\"\"\n852         return self._dashes\n853 \n854     def get_forced_alpha(self):\n855         \"\"\"\n856         Return whether the value given by get_alpha() should be used to\n857         override any other alpha-channel values.\n858         \"\"\"\n859         return self._forced_alpha\n860 \n861     def get_joinstyle(self):\n862         \"\"\"Return the `.JoinStyle`.\"\"\"\n863         return self._joinstyle.name\n864 \n865     def get_linewidth(self):\n866         \"\"\"Return the line width in points.\"\"\"\n867         return self._linewidth\n868 \n869     def get_rgb(self):\n870         \"\"\"Return a tuple of three or four floats from 0-1.\"\"\"\n871         return self._rgb\n872 \n873     def get_url(self):\n874         \"\"\"Return a url if one is set, None otherwise.\"\"\"\n875         return self._url\n876 \n877     def get_gid(self):\n878         \"\"\"Return the object identifier if one is set, None otherwise.\"\"\"\n879         return self._gid\n880 \n881     def get_snap(self):\n882         \"\"\"\n883         Return the snap setting, which can be:\n884 \n885         * True: snap vertices to the nearest pixel center\n886         * False: leave vertices as-is\n887         * None: (auto) If the path contains only rectilinear line segments,\n888           round to the nearest pixel center\n889         \"\"\"\n890         return self._snap\n891 \n892     def set_alpha(self, alpha):\n893         \"\"\"\n894         Set the alpha value used for blending - not supported on all backends.\n895 \n896         If ``alpha=None`` (the default), the alpha components of the\n897         foreground and fill colors will be used to set their respective\n898         transparencies (where applicable); otherwise, ``alpha`` will override\n899         them.\n900         \"\"\"\n901         if alpha is not None:\n902             self._alpha = alpha\n903             self._forced_alpha = True\n904         else:\n905             self._alpha = 1.0\n906             self._forced_alpha = False\n907         self.set_foreground(self._rgb, isRGBA=True)\n908 \n909     def set_antialiased(self, b):\n910         \"\"\"Set whether object should be drawn with antialiased rendering.\"\"\"\n911         # Use ints to make life easier on extension code trying to read the gc.\n912         self._antialiased = int(bool(b))\n913 \n914     @_docstring.interpd\n915     def set_capstyle(self, cs):\n916         \"\"\"\n917         Set how to draw endpoints of lines.\n918 \n919         Parameters\n920         ----------\n921         cs : `.CapStyle` or %(CapStyle)s\n922         \"\"\"\n923         self._capstyle = CapStyle(cs)\n924 \n925     def set_clip_rectangle(self, rectangle):\n926         \"\"\"Set the clip rectangle to a `.Bbox` or None.\"\"\"\n927         self._cliprect = rectangle\n928 \n929     def set_clip_path(self, path):\n930         \"\"\"Set the clip path to a `.TransformedPath` or None.\"\"\"\n931         _api.check_isinstance((transforms.TransformedPath, None), path=path)\n932         self._clippath = path\n933 \n934     def set_dashes(self, dash_offset, dash_list):\n935         \"\"\"\n936         Set the dash style for the gc.\n937 \n938         Parameters\n939         ----------\n940         dash_offset : float\n941             Distance, in points, into the dash pattern at which to\n942             start the pattern. It is usually set to 0.\n943         dash_list : array-like or None\n944             The on-off sequence as points.  None specifies a solid line. All\n945             values must otherwise be non-negative (:math:`\\\\ge 0`).\n946 \n947         Notes\n948         -----\n949         See p. 666 of the PostScript\n950         `Language Reference\n951         <https://www.adobe.com/jp/print/postscript/pdfs/PLRM.pdf>`_\n952         for more info.\n953         \"\"\"\n954         if dash_list is not None:\n955             dl = np.asarray(dash_list)\n956             if np.any(dl < 0.0):\n957                 raise ValueError(\n958                     \"All values in the dash list must be non-negative\")\n959             if dl.size and not np.any(dl > 0.0):\n960                 raise ValueError(\n961                     'At least one value in the dash list must be positive')\n962         self._dashes = dash_offset, dash_list\n963 \n964     def set_foreground(self, fg, isRGBA=False):\n965         \"\"\"\n966         Set the foreground color.\n967 \n968         Parameters\n969         ----------\n970         fg : color\n971         isRGBA : bool\n972             If *fg* is known to be an ``(r, g, b, a)`` tuple, *isRGBA* can be\n973             set to True to improve performance.\n974         \"\"\"\n975         if self._forced_alpha and isRGBA:\n976             self._rgb = fg[:3] + (self._alpha,)\n977         elif self._forced_alpha:\n978             self._rgb = colors.to_rgba(fg, self._alpha)\n979         elif isRGBA:\n980             self._rgb = fg\n981         else:\n982             self._rgb = colors.to_rgba(fg)\n983 \n984     @_docstring.interpd\n985     def set_joinstyle(self, js):\n986         \"\"\"\n987         Set how to draw connections between line segments.\n988 \n989         Parameters\n990         ----------\n991         js : `.JoinStyle` or %(JoinStyle)s\n992         \"\"\"\n993         self._joinstyle = JoinStyle(js)\n994 \n995     def set_linewidth(self, w):\n996         \"\"\"Set the linewidth in points.\"\"\"\n997         self._linewidth = float(w)\n998 \n999     def set_url(self, url):\n1000         \"\"\"Set the url for links in compatible backends.\"\"\"\n1001         self._url = url\n1002 \n1003     def set_gid(self, id):\n1004         \"\"\"Set the id.\"\"\"\n1005         self._gid = id\n1006 \n1007     def set_snap(self, snap):\n1008         \"\"\"\n1009         Set the snap setting which may be:\n1010 \n1011         * True: snap vertices to the nearest pixel center\n1012         * False: leave vertices as-is\n1013         * None: (auto) If the path contains only rectilinear line segments,\n1014           round to the nearest pixel center\n1015         \"\"\"\n1016         self._snap = snap\n1017 \n1018     def set_hatch(self, hatch):\n1019         \"\"\"Set the hatch style (for fills).\"\"\"\n1020         self._hatch = hatch\n1021 \n1022     def get_hatch(self):\n1023         \"\"\"Get the current hatch style.\"\"\"\n1024         return self._hatch\n1025 \n1026     def get_hatch_path(self, density=6.0):\n1027         \"\"\"Return a `.Path` for the current hatch.\"\"\"\n1028         hatch = self.get_hatch()\n1029         if hatch is None:\n1030             return None\n1031         return Path.hatch(hatch, density)\n1032 \n1033     def get_hatch_color(self):\n1034         \"\"\"Get the hatch color.\"\"\"\n1035         return self._hatch_color\n1036 \n1037     def set_hatch_color(self, hatch_color):\n1038         \"\"\"Set the hatch color.\"\"\"\n1039         self._hatch_color = hatch_color\n1040 \n1041     def get_hatch_linewidth(self):\n1042         \"\"\"Get the hatch linewidth.\"\"\"\n1043         return self._hatch_linewidth\n1044 \n1045     def get_sketch_params(self):\n1046         \"\"\"\n1047         Return the sketch parameters for the artist.\n1048 \n1049         Returns\n1050         -------\n1051         tuple or `None`\n1052 \n1053             A 3-tuple with the following elements:\n1054 \n1055             * ``scale``: The amplitude of the wiggle perpendicular to the\n1056               source line.\n1057             * ``length``: The length of the wiggle along the line.\n1058             * ``randomness``: The scale factor by which the length is\n1059               shrunken or expanded.\n1060 \n1061             May return `None` if no sketch parameters were set.\n1062         \"\"\"\n1063         return self._sketch\n1064 \n1065     def set_sketch_params(self, scale=None, length=None, randomness=None):\n1066         \"\"\"\n1067         Set the sketch parameters.\n1068 \n1069         Parameters\n1070         ----------\n1071         scale : float, optional\n1072             The amplitude of the wiggle perpendicular to the source line, in\n1073             pixels.  If scale is `None`, or not provided, no sketch filter will\n1074             be provided.\n1075         length : float, default: 128\n1076             The length of the wiggle along the line, in pixels.\n1077         randomness : float, default: 16\n1078             The scale factor by which the length is shrunken or expanded.\n1079         \"\"\"\n1080         self._sketch = (\n1081             None if scale is None\n1082             else (scale, length or 128., randomness or 16.))\n1083 \n1084 \n1085 class TimerBase:\n1086     \"\"\"\n1087     A base class for providing timer events, useful for things animations.\n1088     Backends need to implement a few specific methods in order to use their\n1089     own timing mechanisms so that the timer events are integrated into their\n1090     event loops.\n1091 \n1092     Subclasses must override the following methods:\n1093 \n1094     - ``_timer_start``: Backend-specific code for starting the timer.\n1095     - ``_timer_stop``: Backend-specific code for stopping the timer.\n1096 \n1097     Subclasses may additionally override the following methods:\n1098 \n1099     - ``_timer_set_single_shot``: Code for setting the timer to single shot\n1100       operating mode, if supported by the timer object.  If not, the `Timer`\n1101       class itself will store the flag and the ``_on_timer`` method should be\n1102       overridden to support such behavior.\n1103 \n1104     - ``_timer_set_interval``: Code for setting the interval on the timer, if\n1105       there is a method for doing so on the timer object.\n1106 \n1107     - ``_on_timer``: The internal function that any timer object should call,\n1108       which will handle the task of running all callbacks that have been set.\n1109     \"\"\"\n1110 \n1111     def __init__(self, interval=None, callbacks=None):\n1112         \"\"\"\n1113         Parameters\n1114         ----------\n1115         interval : int, default: 1000ms\n1116             The time between timer events in milliseconds.  Will be stored as\n1117             ``timer.interval``.\n1118         callbacks : list[tuple[callable, tuple, dict]]\n1119             List of (func, args, kwargs) tuples that will be called upon\n1120             timer events.  This list is accessible as ``timer.callbacks`` and\n1121             can be manipulated directly, or the functions `add_callback` and\n1122             `remove_callback` can be used.\n1123         \"\"\"\n1124         self.callbacks = [] if callbacks is None else callbacks.copy()\n1125         # Set .interval and not ._interval to go through the property setter.\n1126         self.interval = 1000 if interval is None else interval\n1127         self.single_shot = False\n1128 \n1129     def __del__(self):\n1130         \"\"\"Need to stop timer and possibly disconnect timer.\"\"\"\n1131         self._timer_stop()\n1132 \n1133     def start(self, interval=None):\n1134         \"\"\"\n1135         Start the timer object.\n1136 \n1137         Parameters\n1138         ----------\n1139         interval : int, optional\n1140             Timer interval in milliseconds; overrides a previously set interval\n1141             if provided.\n1142         \"\"\"\n1143         if interval is not None:\n1144             self.interval = interval\n1145         self._timer_start()\n1146 \n1147     def stop(self):\n1148         \"\"\"Stop the timer.\"\"\"\n1149         self._timer_stop()\n1150 \n1151     def _timer_start(self):\n1152         pass\n1153 \n1154     def _timer_stop(self):\n1155         pass\n1156 \n1157     @property\n1158     def interval(self):\n1159         \"\"\"The time between timer events, in milliseconds.\"\"\"\n1160         return self._interval\n1161 \n1162     @interval.setter\n1163     def interval(self, interval):\n1164         # Force to int since none of the backends actually support fractional\n1165         # milliseconds, and some error or give warnings.\n1166         # Some backends also fail when interval == 0, so ensure >= 1 msec\n1167         interval = max(int(interval), 1)\n1168         self._interval = interval\n1169         self._timer_set_interval()\n1170 \n1171     @property\n1172     def single_shot(self):\n1173         \"\"\"Whether this timer should stop after a single run.\"\"\"\n1174         return self._single\n1175 \n1176     @single_shot.setter\n1177     def single_shot(self, ss):\n1178         self._single = ss\n1179         self._timer_set_single_shot()\n1180 \n1181     def add_callback(self, func, *args, **kwargs):\n1182         \"\"\"\n1183         Register *func* to be called by timer when the event fires. Any\n1184         additional arguments provided will be passed to *func*.\n1185 \n1186         This function returns *func*, which makes it possible to use it as a\n1187         decorator.\n1188         \"\"\"\n1189         self.callbacks.append((func, args, kwargs))\n1190         return func\n1191 \n1192     def remove_callback(self, func, *args, **kwargs):\n1193         \"\"\"\n1194         Remove *func* from list of callbacks.\n1195 \n1196         *args* and *kwargs* are optional and used to distinguish between copies\n1197         of the same function registered to be called with different arguments.\n1198         This behavior is deprecated.  In the future, ``*args, **kwargs`` won't\n1199         be considered anymore; to keep a specific callback removable by itself,\n1200         pass it to `add_callback` as a `functools.partial` object.\n1201         \"\"\"\n1202         if args or kwargs:\n1203             _api.warn_deprecated(\n1204                 \"3.1\", message=\"In a future version, Timer.remove_callback \"\n1205                 \"will not take *args, **kwargs anymore, but remove all \"\n1206                 \"callbacks where the callable matches; to keep a specific \"\n1207                 \"callback removable by itself, pass it to add_callback as a \"\n1208                 \"functools.partial object.\")\n1209             self.callbacks.remove((func, args, kwargs))\n1210         else:\n1211             funcs = [c[0] for c in self.callbacks]\n1212             if func in funcs:\n1213                 self.callbacks.pop(funcs.index(func))\n1214 \n1215     def _timer_set_interval(self):\n1216         \"\"\"Used to set interval on underlying timer object.\"\"\"\n1217 \n1218     def _timer_set_single_shot(self):\n1219         \"\"\"Used to set single shot on underlying timer object.\"\"\"\n1220 \n1221     def _on_timer(self):\n1222         \"\"\"\n1223         Runs all function that have been registered as callbacks. Functions\n1224         can return False (or 0) if they should not be called any more. If there\n1225         are no callbacks, the timer is automatically stopped.\n1226         \"\"\"\n1227         for func, args, kwargs in self.callbacks:\n1228             ret = func(*args, **kwargs)\n1229             # docstring above explains why we use `if ret == 0` here,\n1230             # instead of `if not ret`.\n1231             # This will also catch `ret == False` as `False == 0`\n1232             # but does not annoy the linters\n1233             # https://docs.python.org/3/library/stdtypes.html#boolean-values\n1234             if ret == 0:\n1235                 self.callbacks.remove((func, args, kwargs))\n1236 \n1237         if len(self.callbacks) == 0:\n1238             self.stop()\n1239 \n1240 \n1241 class Event:\n1242     \"\"\"\n1243     A Matplotlib event.\n1244 \n1245     The following attributes are defined and shown with their default values.\n1246     Subclasses may define additional attributes.\n1247 \n1248     Attributes\n1249     ----------\n1250     name : str\n1251         The event name.\n1252     canvas : `FigureCanvasBase`\n1253         The backend-specific canvas instance generating the event.\n1254     guiEvent\n1255         The GUI event that triggered the Matplotlib event.\n1256     \"\"\"\n1257 \n1258     def __init__(self, name, canvas, guiEvent=None):\n1259         self.name = name\n1260         self.canvas = canvas\n1261         self._guiEvent = guiEvent\n1262         self._guiEvent_deleted = False\n1263 \n1264     def _process(self):\n1265         \"\"\"Process this event on ``self.canvas``, then unset ``guiEvent``.\"\"\"\n1266         self.canvas.callbacks.process(self.name, self)\n1267         self._guiEvent_deleted = True\n1268 \n1269     @property\n1270     def guiEvent(self):\n1271         # After deprecation elapses: remove _guiEvent_deleted; make guiEvent a plain\n1272         # attribute set to None by _process.\n1273         if self._guiEvent_deleted:\n1274             _api.warn_deprecated(\n1275                 \"3.8\", message=\"Accessing guiEvent outside of the original GUI event \"\n1276                 \"handler is unsafe and deprecated since %(since)s; in the future, the \"\n1277                 \"attribute will be set to None after quitting the event handler.  You \"\n1278                 \"may separately record the value of the guiEvent attribute at your own \"\n1279                 \"risk.\")\n1280         return self._guiEvent\n1281 \n1282 \n1283 class DrawEvent(Event):\n1284     \"\"\"\n1285     An event triggered by a draw operation on the canvas.\n1286 \n1287     In most backends, callbacks subscribed to this event will be fired after\n1288     the rendering is complete but before the screen is updated. Any extra\n1289     artists drawn to the canvas's renderer will be reflected without an\n1290     explicit call to ``blit``.\n1291 \n1292     .. warning::\n1293 \n1294        Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may\n1295        not be safe with all backends and may cause infinite recursion.\n1296 \n1297     A DrawEvent has a number of special attributes in addition to those defined\n1298     by the parent `Event` class.\n1299 \n1300     Attributes\n1301     ----------\n1302     renderer : `RendererBase`\n1303         The renderer for the draw event.\n1304     \"\"\"\n1305     def __init__(self, name, canvas, renderer):\n1306         super().__init__(name, canvas)\n1307         self.renderer = renderer\n1308 \n1309 \n1310 class ResizeEvent(Event):\n1311     \"\"\"\n1312     An event triggered by a canvas resize.\n1313 \n1314     A ResizeEvent has a number of special attributes in addition to those\n1315     defined by the parent `Event` class.\n1316 \n1317     Attributes\n1318     ----------\n1319     width : int\n1320         Width of the canvas in pixels.\n1321     height : int\n1322         Height of the canvas in pixels.\n1323     \"\"\"\n1324 \n1325     def __init__(self, name, canvas):\n1326         super().__init__(name, canvas)\n1327         self.width, self.height = canvas.get_width_height()\n1328 \n1329 \n1330 class CloseEvent(Event):\n1331     \"\"\"An event triggered by a figure being closed.\"\"\"\n1332 \n1333 \n1334 class LocationEvent(Event):\n1335     \"\"\"\n1336     An event that has a screen location.\n1337 \n1338     A LocationEvent has a number of special attributes in addition to those\n1339     defined by the parent `Event` class.\n1340 \n1341     Attributes\n1342     ----------\n1343     x, y : int or None\n1344         Event location in pixels from bottom left of canvas.\n1345     inaxes : `~matplotlib.axes.Axes` or None\n1346         The `~.axes.Axes` instance over which the mouse is, if any.\n1347     xdata, ydata : float or None\n1348         Data coordinates of the mouse within *inaxes*, or *None* if the mouse\n1349         is not over an Axes.\n1350     modifiers : frozenset\n1351         The keyboard modifiers currently being pressed (except for KeyEvent).\n1352     \"\"\"\n1353 \n1354     # Fully delete all occurrences of lastevent after deprecation elapses.\n1355     _lastevent = None\n1356     lastevent = _api.deprecated(\"3.8\")(\n1357         _api.classproperty(lambda cls: cls._lastevent))\n1358     _last_axes_ref = None\n1359 \n1360     def __init__(self, name, canvas, x, y, guiEvent=None, *, modifiers=None):\n1361         super().__init__(name, canvas, guiEvent=guiEvent)\n1362         # x position - pixels from left of canvas\n1363         self.x = int(x) if x is not None else x\n1364         # y position - pixels from right of canvas\n1365         self.y = int(y) if y is not None else y\n1366         self.inaxes = None  # the Axes instance the mouse is over\n1367         self.xdata = None   # x coord of mouse in data coords\n1368         self.ydata = None   # y coord of mouse in data coords\n1369         self.modifiers = frozenset(modifiers if modifiers is not None else [])\n1370 \n1371         if x is None or y is None:\n1372             # cannot check if event was in Axes if no (x, y) info\n1373             return\n1374 \n1375         self._set_inaxes(self.canvas.inaxes((x, y))\n1376                          if self.canvas.mouse_grabber is None else\n1377                          self.canvas.mouse_grabber,\n1378                          (x, y))\n1379 \n1380     # Splitting _set_inaxes out is useful for the axes_leave_event handler: it\n1381     # needs to generate synthetic LocationEvents with manually-set inaxes.  In\n1382     # that latter case, xy has already been cast to int so it can directly be\n1383     # read from self.x, self.y; in the normal case, however, it is more\n1384     # accurate to pass the untruncated float x, y values passed to the ctor.\n1385 \n1386     def _set_inaxes(self, inaxes, xy=None):\n1387         self.inaxes = inaxes\n1388         if inaxes is not None:\n1389             try:\n1390                 self.xdata, self.ydata = inaxes.transData.inverted().transform(\n1391                     xy if xy is not None else (self.x, self.y))\n1392             except ValueError:\n1393                 pass\n1394 \n1395 \n1396 class MouseButton(IntEnum):\n1397     LEFT = 1\n1398     MIDDLE = 2\n1399     RIGHT = 3\n1400     BACK = 8\n1401     FORWARD = 9\n1402 \n1403 \n1404 class MouseEvent(LocationEvent):\n1405     \"\"\"\n1406     A mouse event ('button_press_event', 'button_release_event', \\\n1407 'scroll_event', 'motion_notify_event').\n1408 \n1409     A MouseEvent has a number of special attributes in addition to those\n1410     defined by the parent `Event` and `LocationEvent` classes.\n1411 \n1412     Attributes\n1413     ----------\n1414     button : None or `MouseButton` or {'up', 'down'}\n1415         The button pressed. 'up' and 'down' are used for scroll events.\n1416 \n1417         Note that LEFT and RIGHT actually refer to the \"primary\" and\n1418         \"secondary\" buttons, i.e. if the user inverts their left and right\n1419         buttons (\"left-handed setting\") then the LEFT button will be the one\n1420         physically on the right.\n1421 \n1422         If this is unset, *name* is \"scroll_event\", and *step* is nonzero, then\n1423         this will be set to \"up\" or \"down\" depending on the sign of *step*.\n1424 \n1425     key : None or str\n1426         The key pressed when the mouse event triggered, e.g. 'shift'.\n1427         See `KeyEvent`.\n1428 \n1429         .. warning::\n1430            This key is currently obtained from the last 'key_press_event' or\n1431            'key_release_event' that occurred within the canvas.  Thus, if the\n1432            last change of keyboard state occurred while the canvas did not have\n1433            focus, this attribute will be wrong.  On the other hand, the\n1434            ``modifiers`` attribute should always be correct, but it can only\n1435            report on modifier keys.\n1436 \n1437     step : float\n1438         The number of scroll steps (positive for 'up', negative for 'down').\n1439         This applies only to 'scroll_event' and defaults to 0 otherwise.\n1440 \n1441     dblclick : bool\n1442         Whether the event is a double-click. This applies only to\n1443         'button_press_event' and is False otherwise. In particular, it's\n1444         not used in 'button_release_event'.\n1445 \n1446     Examples\n1447     --------\n1448     ::\n1449 \n1450         def on_press(event):\n1451             print('you pressed', event.button, event.xdata, event.ydata)\n1452 \n1453         cid = fig.canvas.mpl_connect('button_press_event', on_press)\n1454     \"\"\"\n1455 \n1456     def __init__(self, name, canvas, x, y, button=None, key=None,\n1457                  step=0, dblclick=False, guiEvent=None, *, modifiers=None):\n1458         super().__init__(\n1459             name, canvas, x, y, guiEvent=guiEvent, modifiers=modifiers)\n1460         if button in MouseButton.__members__.values():\n1461             button = MouseButton(button)\n1462         if name == \"scroll_event\" and button is None:\n1463             if step > 0:\n1464                 button = \"up\"\n1465             elif step < 0:\n1466                 button = \"down\"\n1467         self.button = button\n1468         self.key = key\n1469         self.step = step\n1470         self.dblclick = dblclick\n1471 \n1472     def __str__(self):\n1473         return (f\"{self.name}: \"\n1474                 f\"xy=({self.x}, {self.y}) xydata=({self.xdata}, {self.ydata}) \"\n1475                 f\"button={self.button} dblclick={self.dblclick} \"\n1476                 f\"inaxes={self.inaxes}\")\n1477 \n1478 \n1479 class PickEvent(Event):\n1480     \"\"\"\n1481     A pick event.\n1482 \n1483     This event is fired when the user picks a location on the canvas\n1484     sufficiently close to an artist that has been made pickable with\n1485     `.Artist.set_picker`.\n1486 \n1487     A PickEvent has a number of special attributes in addition to those defined\n1488     by the parent `Event` class.\n1489 \n1490     Attributes\n1491     ----------\n1492     mouseevent : `MouseEvent`\n1493         The mouse event that generated the pick.\n1494     artist : `~matplotlib.artist.Artist`\n1495         The picked artist.  Note that artists are not pickable by default\n1496         (see `.Artist.set_picker`).\n1497     other\n1498         Additional attributes may be present depending on the type of the\n1499         picked object; e.g., a `.Line2D` pick may define different extra\n1500         attributes than a `.PatchCollection` pick.\n1501 \n1502     Examples\n1503     --------\n1504     Bind a function ``on_pick()`` to pick events, that prints the coordinates\n1505     of the picked data point::\n1506 \n1507         ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance\n1508 \n1509         def on_pick(event):\n1510             line = event.artist\n1511             xdata, ydata = line.get_data()\n1512             ind = event.ind\n1513             print(f'on pick line: {xdata[ind]:.3f}, {ydata[ind]:.3f}')\n1514 \n1515         cid = fig.canvas.mpl_connect('pick_event', on_pick)\n1516     \"\"\"\n1517 \n1518     def __init__(self, name, canvas, mouseevent, artist,\n1519                  guiEvent=None, **kwargs):\n1520         if guiEvent is None:\n1521             guiEvent = mouseevent.guiEvent\n1522         super().__init__(name, canvas, guiEvent)\n1523         self.mouseevent = mouseevent\n1524         self.artist = artist\n1525         self.__dict__.update(kwargs)\n1526 \n1527 \n1528 class KeyEvent(LocationEvent):\n1529     \"\"\"\n1530     A key event (key press, key release).\n1531 \n1532     A KeyEvent has a number of special attributes in addition to those defined\n1533     by the parent `Event` and `LocationEvent` classes.\n1534 \n1535     Attributes\n1536     ----------\n1537     key : None or str\n1538         The key(s) pressed. Could be *None*, a single case sensitive Unicode\n1539         character (\"g\", \"G\", \"#\", etc.), a special key (\"control\", \"shift\",\n1540         \"f1\", \"up\", etc.) or a combination of the above (e.g., \"ctrl+alt+g\",\n1541         \"ctrl+alt+G\").\n1542 \n1543     Notes\n1544     -----\n1545     Modifier keys will be prefixed to the pressed key and will be in the order\n1546     \"ctrl\", \"alt\", \"super\". The exception to this rule is when the pressed key\n1547     is itself a modifier key, therefore \"ctrl+alt\" and \"alt+control\" can both\n1548     be valid key values.\n1549 \n1550     Examples\n1551     --------\n1552     ::\n1553 \n1554         def on_key(event):\n1555             print('you pressed', event.key, event.xdata, event.ydata)\n1556 \n1557         cid = fig.canvas.mpl_connect('key_press_event', on_key)\n1558     \"\"\"\n1559 \n1560     def __init__(self, name, canvas, key, x=0, y=0, guiEvent=None):\n1561         super().__init__(name, canvas, x, y, guiEvent=guiEvent)\n1562         self.key = key\n1563 \n1564 \n1565 # Default callback for key events.\n1566 def _key_handler(event):\n1567     # Dead reckoning of key.\n1568     if event.name == \"key_press_event\":\n1569         event.canvas._key = event.key\n1570     elif event.name == \"key_release_event\":\n1571         event.canvas._key = None\n1572 \n1573 \n1574 # Default callback for mouse events.\n1575 def _mouse_handler(event):\n1576     # Dead-reckoning of button and key.\n1577     if event.name == \"button_press_event\":\n1578         event.canvas._button = event.button\n1579     elif event.name == \"button_release_event\":\n1580         event.canvas._button = None\n1581     elif event.name == \"motion_notify_event\" and event.button is None:\n1582         event.button = event.canvas._button\n1583     if event.key is None:\n1584         event.key = event.canvas._key\n1585     # Emit axes_enter/axes_leave.\n1586     if event.name == \"motion_notify_event\":\n1587         last_ref = LocationEvent._last_axes_ref\n1588         last_axes = last_ref() if last_ref else None\n1589         if last_axes != event.inaxes:\n1590             if last_axes is not None:\n1591                 # Create a synthetic LocationEvent for the axes_leave_event.\n1592                 # Its inaxes attribute needs to be manually set (because the\n1593                 # cursor is actually *out* of that axes at that point); this is\n1594                 # done with the internal _set_inaxes method which ensures that\n1595                 # the xdata and ydata attributes are also correct.\n1596                 try:\n1597                     leave_event = LocationEvent(\n1598                         \"axes_leave_event\", last_axes.figure.canvas,\n1599                         event.x, event.y, event.guiEvent,\n1600                         modifiers=event.modifiers)\n1601                     leave_event._set_inaxes(last_axes)\n1602                     last_axes.figure.canvas.callbacks.process(\n1603                         \"axes_leave_event\", leave_event)\n1604                 except Exception:\n1605                     pass  # The last canvas may already have been torn down.\n1606             if event.inaxes is not None:\n1607                 event.canvas.callbacks.process(\"axes_enter_event\", event)\n1608         LocationEvent._last_axes_ref = (\n1609             weakref.ref(event.inaxes) if event.inaxes else None)\n1610         LocationEvent._lastevent = (\n1611             None if event.name == \"figure_leave_event\" else event)\n1612 \n1613 \n1614 def _get_renderer(figure, print_method=None):\n1615     \"\"\"\n1616     Get the renderer that would be used to save a `.Figure`.\n1617 \n1618     If you need a renderer without any active draw methods use\n1619     renderer._draw_disabled to temporary patch them out at your call site.\n1620     \"\"\"\n1621     # This is implemented by triggering a draw, then immediately jumping out of\n1622     # Figure.draw() by raising an exception.\n1623 \n1624     class Done(Exception):\n1625         pass\n1626 \n1627     def _draw(renderer): raise Done(renderer)\n1628 \n1629     with cbook._setattr_cm(figure, draw=_draw), ExitStack() as stack:\n1630         if print_method is None:\n1631             fmt = figure.canvas.get_default_filetype()\n1632             # Even for a canvas' default output type, a canvas switch may be\n1633             # needed, e.g. for FigureCanvasBase.\n1634             print_method = stack.enter_context(\n1635                 figure.canvas._switch_canvas_and_return_print_method(fmt))\n1636         try:\n1637             print_method(io.BytesIO())\n1638         except Done as exc:\n1639             renderer, = exc.args\n1640             return renderer\n1641         else:\n1642             raise RuntimeError(f\"{print_method} did not call Figure.draw, so \"\n1643                                f\"no renderer is available\")\n1644 \n1645 \n1646 def _no_output_draw(figure):\n1647     # _no_output_draw was promoted to the figure level, but\n1648     # keep this here in case someone was calling it...\n1649     figure.draw_without_rendering()\n1650 \n1651 \n1652 def _is_non_interactive_terminal_ipython(ip):\n1653     \"\"\"\n1654     Return whether we are in a terminal IPython, but non interactive.\n1655 \n1656     When in _terminal_ IPython, ip.parent will have and `interact` attribute,\n1657     if this attribute is False we do not setup eventloop integration as the\n1658     user will _not_ interact with IPython. In all other case (ZMQKernel, or is\n1659     interactive), we do.\n1660     \"\"\"\n1661     return (hasattr(ip, 'parent')\n1662             and (ip.parent is not None)\n1663             and getattr(ip.parent, 'interact', None) is False)\n1664 \n1665 \n1666 class FigureCanvasBase:\n1667     \"\"\"\n1668     The canvas the figure renders into.\n1669 \n1670     Attributes\n1671     ----------\n1672     figure : `~matplotlib.figure.Figure`\n1673         A high-level figure instance.\n1674     \"\"\"\n1675 \n1676     # Set to one of {\"qt\", \"gtk3\", \"gtk4\", \"wx\", \"tk\", \"macosx\"} if an\n1677     # interactive framework is required, or None otherwise.\n1678     required_interactive_framework = None\n1679 \n1680     # The manager class instantiated by new_manager.\n1681     # (This is defined as a classproperty because the manager class is\n1682     # currently defined *after* the canvas class, but one could also assign\n1683     # ``FigureCanvasBase.manager_class = FigureManagerBase``\n1684     # after defining both classes.)\n1685     manager_class = _api.classproperty(lambda cls: FigureManagerBase)\n1686 \n1687     events = [\n1688         'resize_event',\n1689         'draw_event',\n1690         'key_press_event',\n1691         'key_release_event',\n1692         'button_press_event',\n1693         'button_release_event',\n1694         'scroll_event',\n1695         'motion_notify_event',\n1696         'pick_event',\n1697         'figure_enter_event',\n1698         'figure_leave_event',\n1699         'axes_enter_event',\n1700         'axes_leave_event',\n1701         'close_event'\n1702     ]\n1703 \n1704     fixed_dpi = None\n1705 \n1706     filetypes = _default_filetypes\n1707 \n1708     @_api.classproperty\n1709     def supports_blit(cls):\n1710         \"\"\"If this Canvas sub-class supports blitting.\"\"\"\n1711         return (hasattr(cls, \"copy_from_bbox\")\n1712                 and hasattr(cls, \"restore_region\"))\n1713 \n1714     def __init__(self, figure=None):\n1715         from matplotlib.figure import Figure\n1716         self._fix_ipython_backend2gui()\n1717         self._is_idle_drawing = True\n1718         self._is_saving = False\n1719         if figure is None:\n1720             figure = Figure()\n1721         figure.set_canvas(self)\n1722         self.figure = figure\n1723         self.manager = None\n1724         self.widgetlock = widgets.LockDraw()\n1725         self._button = None  # the button pressed\n1726         self._key = None  # the key pressed\n1727         self.mouse_grabber = None  # the Axes currently grabbing mouse\n1728         self.toolbar = None  # NavigationToolbar2 will set me\n1729         self._is_idle_drawing = False\n1730         # We don't want to scale up the figure DPI more than once.\n1731         figure._original_dpi = figure.dpi\n1732         self._device_pixel_ratio = 1\n1733         super().__init__()  # Typically the GUI widget init (if any).\n1734 \n1735     callbacks = property(lambda self: self.figure._canvas_callbacks)\n1736     button_pick_id = property(lambda self: self.figure._button_pick_id)\n1737     scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n1738 \n1739     @classmethod\n1740     @functools.cache\n1741     def _fix_ipython_backend2gui(cls):\n1742         # Fix hard-coded module -> toolkit mapping in IPython (used for\n1743         # `ipython --auto`).  This cannot be done at import time due to\n1744         # ordering issues, so we do it when creating a canvas, and should only\n1745         # be done once per class (hence the `cache`).\n1746         if sys.modules.get(\"IPython\") is None:\n1747             return\n1748         import IPython\n1749         ip = IPython.get_ipython()\n1750         if not ip:\n1751             return\n1752         from IPython.core import pylabtools as pt\n1753         if (not hasattr(pt, \"backend2gui\")\n1754                 or not hasattr(ip, \"enable_matplotlib\")):\n1755             # In case we ever move the patch to IPython and remove these APIs,\n1756             # don't break on our side.\n1757             return\n1758         backend2gui_rif = {\n1759             \"qt\": \"qt\",\n1760             \"gtk3\": \"gtk3\",\n1761             \"gtk4\": \"gtk4\",\n1762             \"wx\": \"wx\",\n1763             \"macosx\": \"osx\",\n1764         }.get(cls.required_interactive_framework)\n1765         if backend2gui_rif:\n1766             if _is_non_interactive_terminal_ipython(ip):\n1767                 ip.enable_gui(backend2gui_rif)\n1768 \n1769     @classmethod\n1770     def new_manager(cls, figure, num):\n1771         \"\"\"\n1772         Create a new figure manager for *figure*, using this canvas class.\n1773 \n1774         Notes\n1775         -----\n1776         This method should not be reimplemented in subclasses.  If\n1777         custom manager creation logic is needed, please reimplement\n1778         ``FigureManager.create_with_canvas``.\n1779         \"\"\"\n1780         return cls.manager_class.create_with_canvas(cls, figure, num)\n1781 \n1782     @contextmanager\n1783     def _idle_draw_cntx(self):\n1784         self._is_idle_drawing = True\n1785         try:\n1786             yield\n1787         finally:\n1788             self._is_idle_drawing = False\n1789 \n1790     def is_saving(self):\n1791         \"\"\"\n1792         Return whether the renderer is in the process of saving\n1793         to a file, rather than rendering for an on-screen buffer.\n1794         \"\"\"\n1795         return self._is_saving\n1796 \n1797     def blit(self, bbox=None):\n1798         \"\"\"Blit the canvas in bbox (default entire canvas).\"\"\"\n1799 \n1800     def inaxes(self, xy):\n1801         \"\"\"\n1802         Return the topmost visible `~.axes.Axes` containing the point *xy*.\n1803 \n1804         Parameters\n1805         ----------\n1806         xy : (float, float)\n1807             (x, y) pixel positions from left/bottom of the canvas.\n1808 \n1809         Returns\n1810         -------\n1811         `~matplotlib.axes.Axes` or None\n1812             The topmost visible Axes containing the point, or None if there\n1813             is no Axes at the point.\n1814         \"\"\"\n1815         axes_list = [a for a in self.figure.get_axes()\n1816                      if a.patch.contains_point(xy) and a.get_visible()]\n1817         if axes_list:\n1818             axes = cbook._topmost_artist(axes_list)\n1819         else:\n1820             axes = None\n1821 \n1822         return axes\n1823 \n1824     def grab_mouse(self, ax):\n1825         \"\"\"\n1826         Set the child `~.axes.Axes` which is grabbing the mouse events.\n1827 \n1828         Usually called by the widgets themselves. It is an error to call this\n1829         if the mouse is already grabbed by another Axes.\n1830         \"\"\"\n1831         if self.mouse_grabber not in (None, ax):\n1832             raise RuntimeError(\"Another Axes already grabs mouse input\")\n1833         self.mouse_grabber = ax\n1834 \n1835     def release_mouse(self, ax):\n1836         \"\"\"\n1837         Release the mouse grab held by the `~.axes.Axes` *ax*.\n1838 \n1839         Usually called by the widgets. It is ok to call this even if *ax*\n1840         doesn't have the mouse grab currently.\n1841         \"\"\"\n1842         if self.mouse_grabber is ax:\n1843             self.mouse_grabber = None\n1844 \n1845     def set_cursor(self, cursor):\n1846         \"\"\"\n1847         Set the current cursor.\n1848 \n1849         This may have no effect if the backend does not display anything.\n1850 \n1851         If required by the backend, this method should trigger an update in\n1852         the backend event loop after the cursor is set, as this method may be\n1853         called e.g. before a long-running task during which the GUI is not\n1854         updated.\n1855 \n1856         Parameters\n1857         ----------\n1858         cursor : `.Cursors`\n1859             The cursor to display over the canvas. Note: some backends may\n1860             change the cursor for the entire window.\n1861         \"\"\"\n1862 \n1863     def draw(self, *args, **kwargs):\n1864         \"\"\"\n1865         Render the `.Figure`.\n1866 \n1867         This method must walk the artist tree, even if no output is produced,\n1868         because it triggers deferred work that users may want to access\n1869         before saving output to disk. For example computing limits,\n1870         auto-limits, and tick values.\n1871         \"\"\"\n1872 \n1873     def draw_idle(self, *args, **kwargs):\n1874         \"\"\"\n1875         Request a widget redraw once control returns to the GUI event loop.\n1876 \n1877         Even if multiple calls to `draw_idle` occur before control returns\n1878         to the GUI event loop, the figure will only be rendered once.\n1879 \n1880         Notes\n1881         -----\n1882         Backends may choose to override the method and implement their own\n1883         strategy to prevent multiple renderings.\n1884 \n1885         \"\"\"\n1886         if not self._is_idle_drawing:\n1887             with self._idle_draw_cntx():\n1888                 self.draw(*args, **kwargs)\n1889 \n1890     @property\n1891     def device_pixel_ratio(self):\n1892         \"\"\"\n1893         The ratio of physical to logical pixels used for the canvas on screen.\n1894 \n1895         By default, this is 1, meaning physical and logical pixels are the same\n1896         size. Subclasses that support High DPI screens may set this property to\n1897         indicate that said ratio is different. All Matplotlib interaction,\n1898         unless working directly with the canvas, remains in logical pixels.\n1899 \n1900         \"\"\"\n1901         return self._device_pixel_ratio\n1902 \n1903     def _set_device_pixel_ratio(self, ratio):\n1904         \"\"\"\n1905         Set the ratio of physical to logical pixels used for the canvas.\n1906 \n1907         Subclasses that support High DPI screens can set this property to\n1908         indicate that said ratio is different. The canvas itself will be\n1909         created at the physical size, while the client side will use the\n1910         logical size. Thus the DPI of the Figure will change to be scaled by\n1911         this ratio. Implementations that support High DPI screens should use\n1912         physical pixels for events so that transforms back to Axes space are\n1913         correct.\n1914 \n1915         By default, this is 1, meaning physical and logical pixels are the same\n1916         size.\n1917 \n1918         Parameters\n1919         ----------\n1920         ratio : float\n1921             The ratio of logical to physical pixels used for the canvas.\n1922 \n1923         Returns\n1924         -------\n1925         bool\n1926             Whether the ratio has changed. Backends may interpret this as a\n1927             signal to resize the window, repaint the canvas, or change any\n1928             other relevant properties.\n1929         \"\"\"\n1930         if self._device_pixel_ratio == ratio:\n1931             return False\n1932         # In cases with mixed resolution displays, we need to be careful if the\n1933         # device pixel ratio changes - in this case we need to resize the\n1934         # canvas accordingly. Some backends provide events that indicate a\n1935         # change in DPI, but those that don't will update this before drawing.\n1936         dpi = ratio * self.figure._original_dpi\n1937         self.figure._set_dpi(dpi, forward=False)\n1938         self._device_pixel_ratio = ratio\n1939         return True\n1940 \n1941     def get_width_height(self, *, physical=False):\n1942         \"\"\"\n1943         Return the figure width and height in integral points or pixels.\n1944 \n1945         When the figure is used on High DPI screens (and the backend supports\n1946         it), the truncation to integers occurs after scaling by the device\n1947         pixel ratio.\n1948 \n1949         Parameters\n1950         ----------\n1951         physical : bool, default: False\n1952             Whether to return true physical pixels or logical pixels. Physical\n1953             pixels may be used by backends that support HiDPI, but still\n1954             configure the canvas using its actual size.\n1955 \n1956         Returns\n1957         -------\n1958         width, height : int\n1959             The size of the figure, in points or pixels, depending on the\n1960             backend.\n1961         \"\"\"\n1962         return tuple(int(size / (1 if physical else self.device_pixel_ratio))\n1963                      for size in self.figure.bbox.max)\n1964 \n1965     @classmethod\n1966     def get_supported_filetypes(cls):\n1967         \"\"\"Return dict of savefig file formats supported by this backend.\"\"\"\n1968         return cls.filetypes\n1969 \n1970     @classmethod\n1971     def get_supported_filetypes_grouped(cls):\n1972         \"\"\"\n1973         Return a dict of savefig file formats supported by this backend,\n1974         where the keys are a file type name, such as 'Joint Photographic\n1975         Experts Group', and the values are a list of filename extensions used\n1976         for that filetype, such as ['jpg', 'jpeg'].\n1977         \"\"\"\n1978         groupings = {}\n1979         for ext, name in cls.filetypes.items():\n1980             groupings.setdefault(name, []).append(ext)\n1981             groupings[name].sort()\n1982         return groupings\n1983 \n1984     @contextmanager\n1985     def _switch_canvas_and_return_print_method(self, fmt, backend=None):\n1986         \"\"\"\n1987         Context manager temporarily setting the canvas for saving the figure::\n1988 \n1989             with canvas._switch_canvas_and_return_print_method(fmt, backend) \\\\\n1990                     as print_method:\n1991                 # ``print_method`` is a suitable ``print_{fmt}`` method, and\n1992                 # the figure's canvas is temporarily switched to the method's\n1993                 # canvas within the with... block.  ``print_method`` is also\n1994                 # wrapped to suppress extra kwargs passed by ``print_figure``.\n1995 \n1996         Parameters\n1997         ----------\n1998         fmt : str\n1999             If *backend* is None, then determine a suitable canvas class for\n2000             saving to format *fmt* -- either the current canvas class, if it\n2001             supports *fmt*, or whatever `get_registered_canvas_class` returns;\n2002             switch the figure canvas to that canvas class.\n2003         backend : str or None, default: None\n2004             If not None, switch the figure canvas to the ``FigureCanvas`` class\n2005             of the given backend.\n2006         \"\"\"\n2007         canvas = None\n2008         if backend is not None:\n2009             # Return a specific canvas class, if requested.\n2010             canvas_class = (\n2011                 importlib.import_module(cbook._backend_module_name(backend))\n2012                 .FigureCanvas)\n2013             if not hasattr(canvas_class, f\"print_{fmt}\"):\n2014                 raise ValueError(\n2015                     f\"The {backend!r} backend does not support {fmt} output\")\n2016             canvas = canvas_class(self.figure)\n2017         elif hasattr(self, f\"print_{fmt}\"):\n2018             # Return the current canvas if it supports the requested format.\n2019             canvas = self\n2020         else:\n2021             # Return a default canvas for the requested format, if it exists.\n2022             canvas_class = get_registered_canvas_class(fmt)\n2023             if canvas_class is None:\n2024                 raise ValueError(\n2025                     \"Format {!r} is not supported (supported formats: {})\".format(\n2026                         fmt, \", \".join(sorted(self.get_supported_filetypes()))))\n2027             canvas = canvas_class(self.figure)\n2028         canvas._is_saving = self._is_saving\n2029         meth = getattr(canvas, f\"print_{fmt}\")\n2030         mod = (meth.func.__module__\n2031                if hasattr(meth, \"func\")  # partialmethod, e.g. backend_wx.\n2032                else meth.__module__)\n2033         if mod.startswith((\"matplotlib.\", \"mpl_toolkits.\")):\n2034             optional_kws = {  # Passed by print_figure for other renderers.\n2035                 \"dpi\", \"facecolor\", \"edgecolor\", \"orientation\",\n2036                 \"bbox_inches_restore\"}\n2037             skip = optional_kws - {*inspect.signature(meth).parameters}\n2038             print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\n2039                 *args, **{k: v for k, v in kwargs.items() if k not in skip}))\n2040         else:  # Let third-parties do as they see fit.\n2041             print_method = meth\n2042         try:\n2043             yield print_method\n2044         finally:\n2045             self.figure.canvas = self\n2046 \n2047     def print_figure(\n2048             self, filename, dpi=None, facecolor=None, edgecolor=None,\n2049             orientation='portrait', format=None, *,\n2050             bbox_inches=None, pad_inches=None, bbox_extra_artists=None,\n2051             backend=None, **kwargs):\n2052         \"\"\"\n2053         Render the figure to hardcopy. Set the figure patch face and edge\n2054         colors.  This is useful because some of the GUIs have a gray figure\n2055         face color background and you'll probably want to override this on\n2056         hardcopy.\n2057 \n2058         Parameters\n2059         ----------\n2060         filename : str or path-like or file-like\n2061             The file where the figure is saved.\n2062 \n2063         dpi : float, default: :rc:`savefig.dpi`\n2064             The dots per inch to save the figure in.\n2065 \n2066         facecolor : color or 'auto', default: :rc:`savefig.facecolor`\n2067             The facecolor of the figure.  If 'auto', use the current figure\n2068             facecolor.\n2069 \n2070         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`\n2071             The edgecolor of the figure.  If 'auto', use the current figure\n2072             edgecolor.\n2073 \n2074         orientation : {'landscape', 'portrait'}, default: 'portrait'\n2075             Only currently applies to PostScript printing.\n2076 \n2077         format : str, optional\n2078             Force a specific file format. If not given, the format is inferred\n2079             from the *filename* extension, and if that fails from\n2080             :rc:`savefig.format`.\n2081 \n2082         bbox_inches : 'tight' or `.Bbox`, default: :rc:`savefig.bbox`\n2083             Bounding box in inches: only the given portion of the figure is\n2084             saved.  If 'tight', try to figure out the tight bbox of the figure.\n2085 \n2086         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`\n2087             Amount of padding in inches around the figure when bbox_inches is\n2088             'tight'. If 'layout' use the padding from the constrained or\n2089             compressed layout engine; ignored if one of those engines is not in\n2090             use.\n2091 \n2092         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n2093             A list of extra artists that will be considered when the\n2094             tight bbox is calculated.\n2095 \n2096         backend : str, optional\n2097             Use a non-default backend to render the file, e.g. to render a\n2098             png file with the \"cairo\" backend rather than the default \"agg\",\n2099             or a pdf file with the \"pgf\" backend rather than the default\n2100             \"pdf\".  Note that the default backend is normally sufficient.  See\n2101             :ref:`the-builtin-backends` for a list of valid backends for each\n2102             file format.  Custom backends can be referenced as \"module://...\".\n2103         \"\"\"\n2104         if format is None:\n2105             # get format from filename, or from backend's default filetype\n2106             if isinstance(filename, os.PathLike):\n2107                 filename = os.fspath(filename)\n2108             if isinstance(filename, str):\n2109                 format = os.path.splitext(filename)[1][1:]\n2110             if format is None or format == '':\n2111                 format = self.get_default_filetype()\n2112                 if isinstance(filename, str):\n2113                     filename = filename.rstrip('.') + '.' + format\n2114         format = format.lower()\n2115 \n2116         if dpi is None:\n2117             dpi = rcParams['savefig.dpi']\n2118         if dpi == 'figure':\n2119             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)\n2120 \n2121         # Remove the figure manager, if any, to avoid resizing the GUI widget.\n2122         with cbook._setattr_cm(self, manager=None), \\\n2123              self._switch_canvas_and_return_print_method(format, backend) \\\n2124                  as print_method, \\\n2125              cbook._setattr_cm(self.figure, dpi=dpi), \\\n2126              cbook._setattr_cm(self.figure.canvas, _device_pixel_ratio=1), \\\n2127              cbook._setattr_cm(self.figure.canvas, _is_saving=True), \\\n2128              ExitStack() as stack:\n2129 \n2130             for prop in [\"facecolor\", \"edgecolor\"]:\n2131                 color = locals()[prop]\n2132                 if color is None:\n2133                     color = rcParams[f\"savefig.{prop}\"]\n2134                 if not cbook._str_equal(color, \"auto\"):\n2135                     stack.enter_context(self.figure._cm_set(**{prop: color}))\n2136 \n2137             if bbox_inches is None:\n2138                 bbox_inches = rcParams['savefig.bbox']\n2139 \n2140             layout_engine = self.figure.get_layout_engine()\n2141             if layout_engine is not None or bbox_inches == \"tight\":\n2142                 # we need to trigger a draw before printing to make sure\n2143                 # CL works.  \"tight\" also needs a draw to get the right\n2144                 # locations:\n2145                 renderer = _get_renderer(\n2146                     self.figure,\n2147                     functools.partial(\n2148                         print_method, orientation=orientation)\n2149                 )\n2150                 # we do this instead of `self.figure.draw_without_rendering`\n2151                 # so that we can inject the orientation\n2152                 with getattr(renderer, \"_draw_disabled\", nullcontext)():\n2153                     self.figure.draw(renderer)\n2154             if bbox_inches:\n2155                 if bbox_inches == \"tight\":\n2156                     bbox_inches = self.figure.get_tightbbox(\n2157                         renderer, bbox_extra_artists=bbox_extra_artists)\n2158                     if (isinstance(layout_engine, ConstrainedLayoutEngine) and\n2159                             pad_inches == \"layout\"):\n2160                         h_pad = layout_engine.get()[\"h_pad\"]\n2161                         w_pad = layout_engine.get()[\"w_pad\"]\n2162                     else:\n2163                         if pad_inches in [None, \"layout\"]:\n2164                             pad_inches = rcParams['savefig.pad_inches']\n2165                         h_pad = w_pad = pad_inches\n2166                     bbox_inches = bbox_inches.padded(w_pad, h_pad)\n2167 \n2168                 # call adjust_bbox to save only the given area\n2169                 restore_bbox = _tight_bbox.adjust_bbox(\n2170                     self.figure, bbox_inches, self.figure.canvas.fixed_dpi)\n2171 \n2172                 _bbox_inches_restore = (bbox_inches, restore_bbox)\n2173             else:\n2174                 _bbox_inches_restore = None\n2175 \n2176             # we have already done layout above, so turn it off:\n2177             stack.enter_context(self.figure._cm_set(layout_engine='none'))\n2178             try:\n2179                 # _get_renderer may change the figure dpi (as vector formats\n2180                 # force the figure dpi to 72), so we need to set it again here.\n2181                 with cbook._setattr_cm(self.figure, dpi=dpi):\n2182                     result = print_method(\n2183                         filename,\n2184                         facecolor=facecolor,\n2185                         edgecolor=edgecolor,\n2186                         orientation=orientation,\n2187                         bbox_inches_restore=_bbox_inches_restore,\n2188                         **kwargs)\n2189             finally:\n2190                 if bbox_inches and restore_bbox:\n2191                     restore_bbox()\n2192 \n2193             return result\n2194 \n2195     @classmethod\n2196     def get_default_filetype(cls):\n2197         \"\"\"\n2198         Return the default savefig file format as specified in\n2199         :rc:`savefig.format`.\n2200 \n2201         The returned string does not include a period. This method is\n2202         overridden in backends that only support a single file type.\n2203         \"\"\"\n2204         return rcParams['savefig.format']\n2205 \n2206     def get_default_filename(self):\n2207         \"\"\"\n2208         Return a string, which includes extension, suitable for use as\n2209         a default filename.\n2210         \"\"\"\n2211         basename = (self.manager.get_window_title() if self.manager is not None\n2212                     else '')\n2213         basename = (basename or 'image').replace(' ', '_')\n2214         filetype = self.get_default_filetype()\n2215         filename = basename + '.' + filetype\n2216         return filename\n2217 \n2218     @_api.deprecated(\"3.8\")\n2219     def switch_backends(self, FigureCanvasClass):\n2220         \"\"\"\n2221         Instantiate an instance of FigureCanvasClass\n2222 \n2223         This is used for backend switching, e.g., to instantiate a\n2224         FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is\n2225         not done, so any changes to one of the instances (e.g., setting\n2226         figure size or line props), will be reflected in the other\n2227         \"\"\"\n2228         newCanvas = FigureCanvasClass(self.figure)\n2229         newCanvas._is_saving = self._is_saving\n2230         return newCanvas\n2231 \n2232     def mpl_connect(self, s, func):\n2233         \"\"\"\n2234         Bind function *func* to event *s*.\n2235 \n2236         Parameters\n2237         ----------\n2238         s : str\n2239             One of the following events ids:\n2240 \n2241             - 'button_press_event'\n2242             - 'button_release_event'\n2243             - 'draw_event'\n2244             - 'key_press_event'\n2245             - 'key_release_event'\n2246             - 'motion_notify_event'\n2247             - 'pick_event'\n2248             - 'resize_event'\n2249             - 'scroll_event'\n2250             - 'figure_enter_event',\n2251             - 'figure_leave_event',\n2252             - 'axes_enter_event',\n2253             - 'axes_leave_event'\n2254             - 'close_event'.\n2255 \n2256         func : callable\n2257             The callback function to be executed, which must have the\n2258             signature::\n2259 \n2260                 def func(event: Event) -> Any\n2261 \n2262             For the location events (button and key press/release), if the\n2263             mouse is over the Axes, the ``inaxes`` attribute of the event will\n2264             be set to the `~matplotlib.axes.Axes` the event occurs is over, and\n2265             additionally, the variables ``xdata`` and ``ydata`` attributes will\n2266             be set to the mouse location in data coordinates.  See `.KeyEvent`\n2267             and `.MouseEvent` for more info.\n2268 \n2269             .. note::\n2270 \n2271                 If func is a method, this only stores a weak reference to the\n2272                 method. Thus, the figure does not influence the lifetime of\n2273                 the associated object. Usually, you want to make sure that the\n2274                 object is kept alive throughout the lifetime of the figure by\n2275                 holding a reference to it.\n2276 \n2277         Returns\n2278         -------\n2279         cid\n2280             A connection id that can be used with\n2281             `.FigureCanvasBase.mpl_disconnect`.\n2282 \n2283         Examples\n2284         --------\n2285         ::\n2286 \n2287             def on_press(event):\n2288                 print('you pressed', event.button, event.xdata, event.ydata)\n2289 \n2290             cid = canvas.mpl_connect('button_press_event', on_press)\n2291         \"\"\"\n2292 \n2293         return self.callbacks.connect(s, func)\n2294 \n2295     def mpl_disconnect(self, cid):\n2296         \"\"\"\n2297         Disconnect the callback with id *cid*.\n2298 \n2299         Examples\n2300         --------\n2301         ::\n2302 \n2303             cid = canvas.mpl_connect('button_press_event', on_press)\n2304             # ... later\n2305             canvas.mpl_disconnect(cid)\n2306         \"\"\"\n2307         self.callbacks.disconnect(cid)\n2308 \n2309     # Internal subclasses can override _timer_cls instead of new_timer, though\n2310     # this is not a public API for third-party subclasses.\n2311     _timer_cls = TimerBase\n2312 \n2313     def new_timer(self, interval=None, callbacks=None):\n2314         \"\"\"\n2315         Create a new backend-specific subclass of `.Timer`.\n2316 \n2317         This is useful for getting periodic events through the backend's native\n2318         event loop.  Implemented only for backends with GUIs.\n2319 \n2320         Parameters\n2321         ----------\n2322         interval : int\n2323             Timer interval in milliseconds.\n2324 \n2325         callbacks : list[tuple[callable, tuple, dict]]\n2326             Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``\n2327             will be executed by the timer every *interval*.\n2328 \n2329             Callbacks which return ``False`` or ``0`` will be removed from the\n2330             timer.\n2331 \n2332         Examples\n2333         --------\n2334         >>> timer = fig.canvas.new_timer(callbacks=[(f1, (1,), {'a': 3})])\n2335         \"\"\"\n2336         return self._timer_cls(interval=interval, callbacks=callbacks)\n2337 \n2338     def flush_events(self):\n2339         \"\"\"\n2340         Flush the GUI events for the figure.\n2341 \n2342         Interactive backends need to reimplement this method.\n2343         \"\"\"\n2344 \n2345     def start_event_loop(self, timeout=0):\n2346         \"\"\"\n2347         Start a blocking event loop.\n2348 \n2349         Such an event loop is used by interactive functions, such as\n2350         `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for\n2351         events.\n2352 \n2353         The event loop blocks until a callback function triggers\n2354         `stop_event_loop`, or *timeout* is reached.\n2355 \n2356         If *timeout* is 0 or negative, never timeout.\n2357 \n2358         Only interactive backends need to reimplement this method and it relies\n2359         on `flush_events` being properly implemented.\n2360 \n2361         Interactive backends should implement this in a more native way.\n2362         \"\"\"\n2363         if timeout <= 0:\n2364             timeout = np.inf\n2365         timestep = 0.01\n2366         counter = 0\n2367         self._looping = True\n2368         while self._looping and counter * timestep < timeout:\n2369             self.flush_events()\n2370             time.sleep(timestep)\n2371             counter += 1\n2372 \n2373     def stop_event_loop(self):\n2374         \"\"\"\n2375         Stop the current blocking event loop.\n2376 \n2377         Interactive backends need to reimplement this to match\n2378         `start_event_loop`\n2379         \"\"\"\n2380         self._looping = False\n2381 \n2382 \n2383 def key_press_handler(event, canvas=None, toolbar=None):\n2384     \"\"\"\n2385     Implement the default Matplotlib key bindings for the canvas and toolbar\n2386     described at :ref:`key-event-handling`.\n2387 \n2388     Parameters\n2389     ----------\n2390     event : `KeyEvent`\n2391         A key press/release event.\n2392     canvas : `FigureCanvasBase`, default: ``event.canvas``\n2393         The backend-specific canvas instance.  This parameter is kept for\n2394         back-compatibility, but, if set, should always be equal to\n2395         ``event.canvas``.\n2396     toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``\n2397         The navigation cursor toolbar.  This parameter is kept for\n2398         back-compatibility, but, if set, should always be equal to\n2399         ``event.canvas.toolbar``.\n2400     \"\"\"\n2401     # these bindings happen whether you are over an Axes or not\n2402 \n2403     if event.key is None:\n2404         return\n2405     if canvas is None:\n2406         canvas = event.canvas\n2407     if toolbar is None:\n2408         toolbar = canvas.toolbar\n2409 \n2410     # Load key-mappings from rcParams.\n2411     fullscreen_keys = rcParams['keymap.fullscreen']\n2412     home_keys = rcParams['keymap.home']\n2413     back_keys = rcParams['keymap.back']\n2414     forward_keys = rcParams['keymap.forward']\n2415     pan_keys = rcParams['keymap.pan']\n2416     zoom_keys = rcParams['keymap.zoom']\n2417     save_keys = rcParams['keymap.save']\n2418     quit_keys = rcParams['keymap.quit']\n2419     quit_all_keys = rcParams['keymap.quit_all']\n2420     grid_keys = rcParams['keymap.grid']\n2421     grid_minor_keys = rcParams['keymap.grid_minor']\n2422     toggle_yscale_keys = rcParams['keymap.yscale']\n2423     toggle_xscale_keys = rcParams['keymap.xscale']\n2424 \n2425     # toggle fullscreen mode ('f', 'ctrl + f')\n2426     if event.key in fullscreen_keys:\n2427         try:\n2428             canvas.manager.full_screen_toggle()\n2429         except AttributeError:\n2430             pass\n2431 \n2432     # quit the figure (default key 'ctrl+w')\n2433     if event.key in quit_keys:\n2434         Gcf.destroy_fig(canvas.figure)\n2435     if event.key in quit_all_keys:\n2436         Gcf.destroy_all()\n2437 \n2438     if toolbar is not None:\n2439         # home or reset mnemonic  (default key 'h', 'home' and 'r')\n2440         if event.key in home_keys:\n2441             toolbar.home()\n2442         # forward / backward keys to enable left handed quick navigation\n2443         # (default key for backward: 'left', 'backspace' and 'c')\n2444         elif event.key in back_keys:\n2445             toolbar.back()\n2446         # (default key for forward: 'right' and 'v')\n2447         elif event.key in forward_keys:\n2448             toolbar.forward()\n2449         # pan mnemonic (default key 'p')\n2450         elif event.key in pan_keys:\n2451             toolbar.pan()\n2452             toolbar._update_cursor(event)\n2453         # zoom mnemonic (default key 'o')\n2454         elif event.key in zoom_keys:\n2455             toolbar.zoom()\n2456             toolbar._update_cursor(event)\n2457         # saving current figure (default key 's')\n2458         elif event.key in save_keys:\n2459             toolbar.save_figure()\n2460 \n2461     if event.inaxes is None:\n2462         return\n2463 \n2464     # these bindings require the mouse to be over an Axes to trigger\n2465     def _get_uniform_gridstate(ticks):\n2466         # Return True/False if all grid lines are on or off, None if they are\n2467         # not all in the same state.\n2468         if all(tick.gridline.get_visible() for tick in ticks):\n2469             return True\n2470         elif not any(tick.gridline.get_visible() for tick in ticks):\n2471             return False\n2472         else:\n2473             return None\n2474 \n2475     ax = event.inaxes\n2476     # toggle major grids in current Axes (default key 'g')\n2477     # Both here and below (for 'G'), we do nothing if *any* grid (major or\n2478     # minor, x or y) is not in a uniform state, to avoid messing up user\n2479     # customization.\n2480     if (event.key in grid_keys\n2481             # Exclude minor grids not in a uniform state.\n2482             and None not in [_get_uniform_gridstate(ax.xaxis.minorTicks),\n2483                              _get_uniform_gridstate(ax.yaxis.minorTicks)]):\n2484         x_state = _get_uniform_gridstate(ax.xaxis.majorTicks)\n2485         y_state = _get_uniform_gridstate(ax.yaxis.majorTicks)\n2486         cycle = [(False, False), (True, False), (True, True), (False, True)]\n2487         try:\n2488             x_state, y_state = (\n2489                 cycle[(cycle.index((x_state, y_state)) + 1) % len(cycle)])\n2490         except ValueError:\n2491             # Exclude major grids not in a uniform state.\n2492             pass\n2493         else:\n2494             # If turning major grids off, also turn minor grids off.\n2495             ax.grid(x_state, which=\"major\" if x_state else \"both\", axis=\"x\")\n2496             ax.grid(y_state, which=\"major\" if y_state else \"both\", axis=\"y\")\n2497             canvas.draw_idle()\n2498     # toggle major and minor grids in current Axes (default key 'G')\n2499     if (event.key in grid_minor_keys\n2500             # Exclude major grids not in a uniform state.\n2501             and None not in [_get_uniform_gridstate(ax.xaxis.majorTicks),\n2502                              _get_uniform_gridstate(ax.yaxis.majorTicks)]):\n2503         x_state = _get_uniform_gridstate(ax.xaxis.minorTicks)\n2504         y_state = _get_uniform_gridstate(ax.yaxis.minorTicks)\n2505         cycle = [(False, False), (True, False), (True, True), (False, True)]\n2506         try:\n2507             x_state, y_state = (\n2508                 cycle[(cycle.index((x_state, y_state)) + 1) % len(cycle)])\n2509         except ValueError:\n2510             # Exclude minor grids not in a uniform state.\n2511             pass\n2512         else:\n2513             ax.grid(x_state, which=\"both\", axis=\"x\")\n2514             ax.grid(y_state, which=\"both\", axis=\"y\")\n2515             canvas.draw_idle()\n2516     # toggle scaling of y-axes between 'log and 'linear' (default key 'l')\n2517     elif event.key in toggle_yscale_keys:\n2518         scale = ax.get_yscale()\n2519         if scale == 'log':\n2520             ax.set_yscale('linear')\n2521             ax.figure.canvas.draw_idle()\n2522         elif scale == 'linear':\n2523             try:\n2524                 ax.set_yscale('log')\n2525             except ValueError as exc:\n2526                 _log.warning(str(exc))\n2527                 ax.set_yscale('linear')\n2528             ax.figure.canvas.draw_idle()\n2529     # toggle scaling of x-axes between 'log and 'linear' (default key 'k')\n2530     elif event.key in toggle_xscale_keys:\n2531         scalex = ax.get_xscale()\n2532         if scalex == 'log':\n2533             ax.set_xscale('linear')\n2534             ax.figure.canvas.draw_idle()\n2535         elif scalex == 'linear':\n2536             try:\n2537                 ax.set_xscale('log')\n2538             except ValueError as exc:\n2539                 _log.warning(str(exc))\n2540                 ax.set_xscale('linear')\n2541             ax.figure.canvas.draw_idle()\n2542 \n2543 \n2544 def button_press_handler(event, canvas=None, toolbar=None):\n2545     \"\"\"\n2546     The default Matplotlib button actions for extra mouse buttons.\n2547 \n2548     Parameters are as for `key_press_handler`, except that *event* is a\n2549     `MouseEvent`.\n2550     \"\"\"\n2551     if canvas is None:\n2552         canvas = event.canvas\n2553     if toolbar is None:\n2554         toolbar = canvas.toolbar\n2555     if toolbar is not None:\n2556         button_name = str(MouseButton(event.button))\n2557         if button_name in rcParams['keymap.back']:\n2558             toolbar.back()\n2559         elif button_name in rcParams['keymap.forward']:\n2560             toolbar.forward()\n2561 \n2562 \n2563 class NonGuiException(Exception):\n2564     \"\"\"Raised when trying show a figure in a non-GUI backend.\"\"\"\n2565     pass\n2566 \n2567 \n2568 class FigureManagerBase:\n2569     \"\"\"\n2570     A backend-independent abstraction of a figure container and controller.\n2571 \n2572     The figure manager is used by pyplot to interact with the window in a\n2573     backend-independent way. It's an adapter for the real (GUI) framework that\n2574     represents the visual figure on screen.\n2575 \n2576     GUI backends define from this class to translate common operations such\n2577     as *show* or *resize* to the GUI-specific code. Non-GUI backends do not\n2578     support these operations an can just use the base class.\n2579 \n2580     This following basic operations are accessible:\n2581 \n2582     **Window operations**\n2583 \n2584     - `~.FigureManagerBase.show`\n2585     - `~.FigureManagerBase.destroy`\n2586     - `~.FigureManagerBase.full_screen_toggle`\n2587     - `~.FigureManagerBase.resize`\n2588     - `~.FigureManagerBase.get_window_title`\n2589     - `~.FigureManagerBase.set_window_title`\n2590 \n2591     **Key and mouse button press handling**\n2592 \n2593     The figure manager sets up default key and mouse button press handling by\n2594     hooking up the `.key_press_handler` to the matplotlib event system. This\n2595     ensures the same shortcuts and mouse actions across backends.\n2596 \n2597     **Other operations**\n2598 \n2599     Subclasses will have additional attributes and functions to access\n2600     additional functionality. This is of course backend-specific. For example,\n2601     most GUI backends have ``window`` and ``toolbar`` attributes that give\n2602     access to the native GUI widgets of the respective framework.\n2603 \n2604     Attributes\n2605     ----------\n2606     canvas : `FigureCanvasBase`\n2607         The backend-specific canvas instance.\n2608 \n2609     num : int or str\n2610         The figure number.\n2611 \n2612     key_press_handler_id : int\n2613         The default key handler cid, when using the toolmanager.\n2614         To disable the default key press handling use::\n2615 \n2616             figure.canvas.mpl_disconnect(\n2617                 figure.canvas.manager.key_press_handler_id)\n2618 \n2619     button_press_handler_id : int\n2620         The default mouse button handler cid, when using the toolmanager.\n2621         To disable the default button press handling use::\n2622 \n2623             figure.canvas.mpl_disconnect(\n2624                 figure.canvas.manager.button_press_handler_id)\n2625     \"\"\"\n2626 \n2627     _toolbar2_class = None\n2628     _toolmanager_toolbar_class = None\n2629 \n2630     def __init__(self, canvas, num):\n2631         self.canvas = canvas\n2632         canvas.manager = self  # store a pointer to parent\n2633         self.num = num\n2634         self.set_window_title(f\"Figure {num:d}\")\n2635 \n2636         self.key_press_handler_id = None\n2637         self.button_press_handler_id = None\n2638         if rcParams['toolbar'] != 'toolmanager':\n2639             self.key_press_handler_id = self.canvas.mpl_connect(\n2640                 'key_press_event', key_press_handler)\n2641             self.button_press_handler_id = self.canvas.mpl_connect(\n2642                 'button_press_event', button_press_handler)\n2643 \n2644         self.toolmanager = (ToolManager(canvas.figure)\n2645                             if mpl.rcParams['toolbar'] == 'toolmanager'\n2646                             else None)\n2647         if (mpl.rcParams[\"toolbar\"] == \"toolbar2\"\n2648                 and self._toolbar2_class):\n2649             self.toolbar = self._toolbar2_class(self.canvas)\n2650         elif (mpl.rcParams[\"toolbar\"] == \"toolmanager\"\n2651                 and self._toolmanager_toolbar_class):\n2652             self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)\n2653         else:\n2654             self.toolbar = None\n2655 \n2656         if self.toolmanager:\n2657             tools.add_tools_to_manager(self.toolmanager)\n2658             if self.toolbar:\n2659                 tools.add_tools_to_container(self.toolbar)\n2660 \n2661         @self.canvas.figure.add_axobserver\n2662         def notify_axes_change(fig):\n2663             # Called whenever the current Axes is changed.\n2664             if self.toolmanager is None and self.toolbar is not None:\n2665                 self.toolbar.update()\n2666 \n2667     @classmethod\n2668     def create_with_canvas(cls, canvas_class, figure, num):\n2669         \"\"\"\n2670         Create a manager for a given *figure* using a specific *canvas_class*.\n2671 \n2672         Backends should override this method if they have specific needs for\n2673         setting up the canvas or the manager.\n2674         \"\"\"\n2675         return cls(canvas_class(figure), num)\n2676 \n2677     @classmethod\n2678     def start_main_loop(cls):\n2679         \"\"\"\n2680         Start the main event loop.\n2681 \n2682         This method is called by `.FigureManagerBase.pyplot_show`, which is the\n2683         implementation of `.pyplot.show`.  To customize the behavior of\n2684         `.pyplot.show`, interactive backends should usually override\n2685         `~.FigureManagerBase.start_main_loop`; if more customized logic is\n2686         necessary, `~.FigureManagerBase.pyplot_show` can also be overridden.\n2687         \"\"\"\n2688 \n2689     @classmethod\n2690     def pyplot_show(cls, *, block=None):\n2691         \"\"\"\n2692         Show all figures.  This method is the implementation of `.pyplot.show`.\n2693 \n2694         To customize the behavior of `.pyplot.show`, interactive backends\n2695         should usually override `~.FigureManagerBase.start_main_loop`; if more\n2696         customized logic is necessary, `~.FigureManagerBase.pyplot_show` can\n2697         also be overridden.\n2698 \n2699         Parameters\n2700         ----------\n2701         block : bool, optional\n2702             Whether to block by calling ``start_main_loop``.  The default,\n2703             None, means to block if we are neither in IPython's ``%pylab`` mode\n2704             nor in ``interactive`` mode.\n2705         \"\"\"\n2706         managers = Gcf.get_all_fig_managers()\n2707         if not managers:\n2708             return\n2709         for manager in managers:\n2710             try:\n2711                 manager.show()  # Emits a warning for non-interactive backend.\n2712             except NonGuiException as exc:\n2713                 _api.warn_external(str(exc))\n2714         if block is None:\n2715             # Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython\n2716             # (>= 0.10) tacks a _needmain attribute onto pyplot.show (always\n2717             # set to False).\n2718             pyplot_show = getattr(sys.modules.get(\"matplotlib.pyplot\"), \"show\", None)\n2719             ipython_pylab = hasattr(pyplot_show, \"_needmain\")\n2720             block = not ipython_pylab and not is_interactive()\n2721         if block:\n2722             cls.start_main_loop()\n2723 \n2724     def show(self):\n2725         \"\"\"\n2726         For GUI backends, show the figure window and redraw.\n2727         For non-GUI backends, raise an exception, unless running headless (i.e.\n2728         on Linux with an unset DISPLAY); this exception is converted to a\n2729         warning in `.Figure.show`.\n2730         \"\"\"\n2731         # This should be overridden in GUI backends.\n2732         if sys.platform == \"linux\" and not os.environ.get(\"DISPLAY\"):\n2733             # We cannot check _get_running_interactive_framework() ==\n2734             # \"headless\" because that would also suppress the warning when\n2735             # $DISPLAY exists but is invalid, which is more likely an error and\n2736             # thus warrants a warning.\n2737             return\n2738         raise NonGuiException(\n2739             f\"Matplotlib is currently using {get_backend()}, which is a \"\n2740             f\"non-GUI backend, so cannot show the figure.\")\n2741 \n2742     def destroy(self):\n2743         pass\n2744 \n2745     def full_screen_toggle(self):\n2746         pass\n2747 \n2748     def resize(self, w, h):\n2749         \"\"\"For GUI backends, resize the window (in physical pixels).\"\"\"\n2750 \n2751     def get_window_title(self):\n2752         \"\"\"\n2753         Return the title text of the window containing the figure, or None\n2754         if there is no window (e.g., a PS backend).\n2755         \"\"\"\n2756         return 'image'\n2757 \n2758     def set_window_title(self, title):\n2759         \"\"\"\n2760         Set the title text of the window containing the figure.\n2761 \n2762         This has no effect for non-GUI (e.g., PS) backends.\n2763         \"\"\"\n2764 \n2765 \n2766 cursors = tools.cursors\n2767 \n2768 \n2769 class _Mode(str, Enum):\n2770     NONE = \"\"\n2771     PAN = \"pan/zoom\"\n2772     ZOOM = \"zoom rect\"\n2773 \n2774     def __str__(self):\n2775         return self.value\n2776 \n2777     @property\n2778     def _navigate_mode(self):\n2779         return self.name if self is not _Mode.NONE else None\n2780 \n2781 \n2782 class NavigationToolbar2:\n2783     \"\"\"\n2784     Base class for the navigation cursor, version 2.\n2785 \n2786     Backends must implement a canvas that handles connections for\n2787     'button_press_event' and 'button_release_event'.  See\n2788     :meth:`FigureCanvasBase.mpl_connect` for more information.\n2789 \n2790     They must also define\n2791 \n2792     :meth:`save_figure`\n2793         Save the current figure.\n2794 \n2795     :meth:`draw_rubberband` (optional)\n2796         Draw the zoom to rect \"rubberband\" rectangle.\n2797 \n2798     :meth:`set_message` (optional)\n2799         Display message.\n2800 \n2801     :meth:`set_history_buttons` (optional)\n2802         You can change the history back / forward buttons to indicate disabled / enabled\n2803         state.\n2804 \n2805     and override ``__init__`` to set up the toolbar -- without forgetting to\n2806     call the base-class init.  Typically, ``__init__`` needs to set up toolbar\n2807     buttons connected to the `home`, `back`, `forward`, `pan`, `zoom`, and\n2808     `save_figure` methods and using standard icons in the \"images\" subdirectory\n2809     of the data path.\n2810 \n2811     That's it, we'll do the rest!\n2812     \"\"\"\n2813 \n2814     # list of toolitems to add to the toolbar, format is:\n2815     # (\n2816     #   text, # the text of the button (often not visible to users)\n2817     #   tooltip_text, # the tooltip shown on hover (where possible)\n2818     #   image_file, # name of the image for the button (without the extension)\n2819     #   name_of_method, # name of the method in NavigationToolbar2 to call\n2820     # )\n2821     toolitems = (\n2822         ('Home', 'Reset original view', 'home', 'home'),\n2823         ('Back', 'Back to previous view', 'back', 'back'),\n2824         ('Forward', 'Forward to next view', 'forward', 'forward'),\n2825         (None, None, None, None),\n2826         ('Pan',\n2827          'Left button pans, Right button zooms\\n'\n2828          'x/y fixes axis, CTRL fixes aspect',\n2829          'move', 'pan'),\n2830         ('Zoom', 'Zoom to rectangle\\nx/y fixes axis', 'zoom_to_rect', 'zoom'),\n2831         ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'),\n2832         (None, None, None, None),\n2833         ('Save', 'Save the figure', 'filesave', 'save_figure'),\n2834       )\n2835 \n2836     def __init__(self, canvas):\n2837         self.canvas = canvas\n2838         canvas.toolbar = self\n2839         self._nav_stack = cbook._Stack()\n2840         # This cursor will be set after the initial draw.\n2841         self._last_cursor = tools.Cursors.POINTER\n2842 \n2843         self._id_press = self.canvas.mpl_connect(\n2844             'button_press_event', self._zoom_pan_handler)\n2845         self._id_release = self.canvas.mpl_connect(\n2846             'button_release_event', self._zoom_pan_handler)\n2847         self._id_drag = self.canvas.mpl_connect(\n2848             'motion_notify_event', self.mouse_move)\n2849         self._pan_info = None\n2850         self._zoom_info = None\n2851 \n2852         self.mode = _Mode.NONE  # a mode string for the status bar\n2853         self.set_history_buttons()\n2854 \n2855     def set_message(self, s):\n2856         \"\"\"Display a message on toolbar or in status bar.\"\"\"\n2857 \n2858     def draw_rubberband(self, event, x0, y0, x1, y1):\n2859         \"\"\"\n2860         Draw a rectangle rubberband to indicate zoom limits.\n2861 \n2862         Note that it is not guaranteed that ``x0 <= x1`` and ``y0 <= y1``.\n2863         \"\"\"\n2864 \n2865     def remove_rubberband(self):\n2866         \"\"\"Remove the rubberband.\"\"\"\n2867 \n2868     def home(self, *args):\n2869         \"\"\"\n2870         Restore the original view.\n2871 \n2872         For convenience of being directly connected as a GUI callback, which\n2873         often get passed additional parameters, this method accepts arbitrary\n2874         parameters, but does not use them.\n2875         \"\"\"\n2876         self._nav_stack.home()\n2877         self.set_history_buttons()\n2878         self._update_view()\n2879 \n2880     def back(self, *args):\n2881         \"\"\"\n2882         Move back up the view lim stack.\n2883 \n2884         For convenience of being directly connected as a GUI callback, which\n2885         often get passed additional parameters, this method accepts arbitrary\n2886         parameters, but does not use them.\n2887         \"\"\"\n2888         self._nav_stack.back()\n2889         self.set_history_buttons()\n2890         self._update_view()\n2891 \n2892     def forward(self, *args):\n2893         \"\"\"\n2894         Move forward in the view lim stack.\n2895 \n2896         For convenience of being directly connected as a GUI callback, which\n2897         often get passed additional parameters, this method accepts arbitrary\n2898         parameters, but does not use them.\n2899         \"\"\"\n2900         self._nav_stack.forward()\n2901         self.set_history_buttons()\n2902         self._update_view()\n2903 \n2904     def _update_cursor(self, event):\n2905         \"\"\"\n2906         Update the cursor after a mouse move event or a tool (de)activation.\n2907         \"\"\"\n2908         if self.mode and event.inaxes and event.inaxes.get_navigate():\n2909             if (self.mode == _Mode.ZOOM\n2910                     and self._last_cursor != tools.Cursors.SELECT_REGION):\n2911                 self.canvas.set_cursor(tools.Cursors.SELECT_REGION)\n2912                 self._last_cursor = tools.Cursors.SELECT_REGION\n2913             elif (self.mode == _Mode.PAN\n2914                   and self._last_cursor != tools.Cursors.MOVE):\n2915                 self.canvas.set_cursor(tools.Cursors.MOVE)\n2916                 self._last_cursor = tools.Cursors.MOVE\n2917         elif self._last_cursor != tools.Cursors.POINTER:\n2918             self.canvas.set_cursor(tools.Cursors.POINTER)\n2919             self._last_cursor = tools.Cursors.POINTER\n2920 \n2921     @contextmanager\n2922     def _wait_cursor_for_draw_cm(self):\n2923         \"\"\"\n2924         Set the cursor to a wait cursor when drawing the canvas.\n2925 \n2926         In order to avoid constantly changing the cursor when the canvas\n2927         changes frequently, do nothing if this context was triggered during the\n2928         last second.  (Optimally we'd prefer only setting the wait cursor if\n2929         the *current* draw takes too long, but the current draw blocks the GUI\n2930         thread).\n2931         \"\"\"\n2932         self._draw_time, last_draw_time = (\n2933             time.time(), getattr(self, \"_draw_time\", -np.inf))\n2934         if self._draw_time - last_draw_time > 1:\n2935             try:\n2936                 self.canvas.set_cursor(tools.Cursors.WAIT)\n2937                 yield\n2938             finally:\n2939                 self.canvas.set_cursor(self._last_cursor)\n2940         else:\n2941             yield\n2942 \n2943     @staticmethod\n2944     def _mouse_event_to_message(event):\n2945         if event.inaxes and event.inaxes.get_navigate():\n2946             try:\n2947                 s = event.inaxes.format_coord(event.xdata, event.ydata)\n2948             except (ValueError, OverflowError):\n2949                 pass\n2950             else:\n2951                 s = s.rstrip()\n2952                 artists = [a for a in event.inaxes._mouseover_set\n2953                            if a.contains(event)[0] and a.get_visible()]\n2954                 if artists:\n2955                     a = cbook._topmost_artist(artists)\n2956                     if a is not event.inaxes.patch:\n2957                         data = a.get_cursor_data(event)\n2958                         if data is not None:\n2959                             data_str = a.format_cursor_data(data).rstrip()\n2960                             if data_str:\n2961                                 s = s + '\\n' + data_str\n2962                 return s\n2963         return \"\"\n2964 \n2965     def mouse_move(self, event):\n2966         self._update_cursor(event)\n2967         self.set_message(self._mouse_event_to_message(event))\n2968 \n2969     def _zoom_pan_handler(self, event):\n2970         if self.mode == _Mode.PAN:\n2971             if event.name == \"button_press_event\":\n2972                 self.press_pan(event)\n2973             elif event.name == \"button_release_event\":\n2974                 self.release_pan(event)\n2975         if self.mode == _Mode.ZOOM:\n2976             if event.name == \"button_press_event\":\n2977                 self.press_zoom(event)\n2978             elif event.name == \"button_release_event\":\n2979                 self.release_zoom(event)\n2980 \n2981     def pan(self, *args):\n2982         \"\"\"\n2983         Toggle the pan/zoom tool.\n2984 \n2985         Pan with left button, zoom with right.\n2986         \"\"\"\n2987         if not self.canvas.widgetlock.available(self):\n2988             self.set_message(\"pan unavailable\")\n2989             return\n2990         if self.mode == _Mode.PAN:\n2991             self.mode = _Mode.NONE\n2992             self.canvas.widgetlock.release(self)\n2993         else:\n2994             self.mode = _Mode.PAN\n2995             self.canvas.widgetlock(self)\n2996         for a in self.canvas.figure.get_axes():\n2997             a.set_navigate_mode(self.mode._navigate_mode)\n2998 \n2999     _PanInfo = namedtuple(\"_PanInfo\", \"button axes cid\")\n3000 \n3001     def press_pan(self, event):\n3002         \"\"\"Callback for mouse button press in pan/zoom mode.\"\"\"\n3003         if (event.button not in [MouseButton.LEFT, MouseButton.RIGHT]\n3004                 or event.x is None or event.y is None):\n3005             return\n3006         axes = [a for a in self.canvas.figure.get_axes()\n3007                 if a.in_axes(event) and a.get_navigate() and a.can_pan()]\n3008         if not axes:\n3009             return\n3010         if self._nav_stack() is None:\n3011             self.push_current()  # set the home button to this view\n3012         for ax in axes:\n3013             ax.start_pan(event.x, event.y, event.button)\n3014         self.canvas.mpl_disconnect(self._id_drag)\n3015         id_drag = self.canvas.mpl_connect(\"motion_notify_event\", self.drag_pan)\n3016         self._pan_info = self._PanInfo(\n3017             button=event.button, axes=axes, cid=id_drag)\n3018 \n3019     def drag_pan(self, event):\n3020         \"\"\"Callback for dragging in pan/zoom mode.\"\"\"\n3021         for ax in self._pan_info.axes:\n3022             # Using the recorded button at the press is safer than the current\n3023             # button, as multiple buttons can get pressed during motion.\n3024             ax.drag_pan(self._pan_info.button, event.key, event.x, event.y)\n3025         self.canvas.draw_idle()\n3026 \n3027     def release_pan(self, event):\n3028         \"\"\"Callback for mouse button release in pan/zoom mode.\"\"\"\n3029         if self._pan_info is None:\n3030             return\n3031         self.canvas.mpl_disconnect(self._pan_info.cid)\n3032         self._id_drag = self.canvas.mpl_connect(\n3033             'motion_notify_event', self.mouse_move)\n3034         for ax in self._pan_info.axes:\n3035             ax.end_pan()\n3036         self.canvas.draw_idle()\n3037         self._pan_info = None\n3038         self.push_current()\n3039 \n3040     def zoom(self, *args):\n3041         if not self.canvas.widgetlock.available(self):\n3042             self.set_message(\"zoom unavailable\")\n3043             return\n3044         \"\"\"Toggle zoom to rect mode.\"\"\"\n3045         if self.mode == _Mode.ZOOM:\n3046             self.mode = _Mode.NONE\n3047             self.canvas.widgetlock.release(self)\n3048         else:\n3049             self.mode = _Mode.ZOOM\n3050             self.canvas.widgetlock(self)\n3051         for a in self.canvas.figure.get_axes():\n3052             a.set_navigate_mode(self.mode._navigate_mode)\n3053 \n3054     _ZoomInfo = namedtuple(\"_ZoomInfo\", \"direction start_xy axes cid cbar\")\n3055 \n3056     def press_zoom(self, event):\n3057         \"\"\"Callback for mouse button press in zoom to rect mode.\"\"\"\n3058         if (event.button not in [MouseButton.LEFT, MouseButton.RIGHT]\n3059                 or event.x is None or event.y is None):\n3060             return\n3061         axes = [a for a in self.canvas.figure.get_axes()\n3062                 if a.in_axes(event) and a.get_navigate() and a.can_zoom()]\n3063         if not axes:\n3064             return\n3065         if self._nav_stack() is None:\n3066             self.push_current()  # set the home button to this view\n3067         id_zoom = self.canvas.mpl_connect(\n3068             \"motion_notify_event\", self.drag_zoom)\n3069         # A colorbar is one-dimensional, so we extend the zoom rectangle out\n3070         # to the edge of the Axes bbox in the other dimension. To do that we\n3071         # store the orientation of the colorbar for later.\n3072         if hasattr(axes[0], \"_colorbar\"):\n3073             cbar = axes[0]._colorbar.orientation\n3074         else:\n3075             cbar = None\n3076         self._zoom_info = self._ZoomInfo(\n3077             direction=\"in\" if event.button == 1 else \"out\",\n3078             start_xy=(event.x, event.y), axes=axes, cid=id_zoom, cbar=cbar)\n3079 \n3080     def drag_zoom(self, event):\n3081         \"\"\"Callback for dragging in zoom mode.\"\"\"\n3082         start_xy = self._zoom_info.start_xy\n3083         ax = self._zoom_info.axes[0]\n3084         (x1, y1), (x2, y2) = np.clip(\n3085             [start_xy, [event.x, event.y]], ax.bbox.min, ax.bbox.max)\n3086         key = event.key\n3087         # Force the key on colorbars to extend the short-axis bbox\n3088         if self._zoom_info.cbar == \"horizontal\":\n3089             key = \"x\"\n3090         elif self._zoom_info.cbar == \"vertical\":\n3091             key = \"y\"\n3092         if key == \"x\":\n3093             y1, y2 = ax.bbox.intervaly\n3094         elif key == \"y\":\n3095             x1, x2 = ax.bbox.intervalx\n3096 \n3097         self.draw_rubberband(event, x1, y1, x2, y2)\n3098 \n3099     def release_zoom(self, event):\n3100         \"\"\"Callback for mouse button release in zoom to rect mode.\"\"\"\n3101         if self._zoom_info is None:\n3102             return\n3103 \n3104         # We don't check the event button here, so that zooms can be cancelled\n3105         # by (pressing and) releasing another mouse button.\n3106         self.canvas.mpl_disconnect(self._zoom_info.cid)\n3107         self.remove_rubberband()\n3108 \n3109         start_x, start_y = self._zoom_info.start_xy\n3110         key = event.key\n3111         # Force the key on colorbars to ignore the zoom-cancel on the\n3112         # short-axis side\n3113         if self._zoom_info.cbar == \"horizontal\":\n3114             key = \"x\"\n3115         elif self._zoom_info.cbar == \"vertical\":\n3116             key = \"y\"\n3117         # Ignore single clicks: 5 pixels is a threshold that allows the user to\n3118         # \"cancel\" a zoom action by zooming by less than 5 pixels.\n3119         if ((abs(event.x - start_x) < 5 and key != \"y\") or\n3120                 (abs(event.y - start_y) < 5 and key != \"x\")):\n3121             self.canvas.draw_idle()\n3122             self._zoom_info = None\n3123             return\n3124 \n3125         for i, ax in enumerate(self._zoom_info.axes):\n3126             # Detect whether this Axes is twinned with an earlier Axes in the\n3127             # list of zoomed Axes, to avoid double zooming.\n3128             twinx = any(ax.get_shared_x_axes().joined(ax, prev)\n3129                         for prev in self._zoom_info.axes[:i])\n3130             twiny = any(ax.get_shared_y_axes().joined(ax, prev)\n3131                         for prev in self._zoom_info.axes[:i])\n3132             ax._set_view_from_bbox(\n3133                 (start_x, start_y, event.x, event.y),\n3134                 self._zoom_info.direction, key, twinx, twiny)\n3135 \n3136         self.canvas.draw_idle()\n3137         self._zoom_info = None\n3138         self.push_current()\n3139 \n3140     def push_current(self):\n3141         \"\"\"Push the current view limits and position onto the stack.\"\"\"\n3142         self._nav_stack.push(\n3143             WeakKeyDictionary(\n3144                 {ax: (ax._get_view(),\n3145                       # Store both the original and modified positions.\n3146                       (ax.get_position(True).frozen(),\n3147                        ax.get_position().frozen()))\n3148                  for ax in self.canvas.figure.axes}))\n3149         self.set_history_buttons()\n3150 \n3151     def _update_view(self):\n3152         \"\"\"\n3153         Update the viewlim and position from the view and position stack for\n3154         each Axes.\n3155         \"\"\"\n3156         nav_info = self._nav_stack()\n3157         if nav_info is None:\n3158             return\n3159         # Retrieve all items at once to avoid any risk of GC deleting an Axes\n3160         # while in the middle of the loop below.\n3161         items = list(nav_info.items())\n3162         for ax, (view, (pos_orig, pos_active)) in items:\n3163             ax._set_view(view)\n3164             # Restore both the original and modified positions\n3165             ax._set_position(pos_orig, 'original')\n3166             ax._set_position(pos_active, 'active')\n3167         self.canvas.draw_idle()\n3168 \n3169     def configure_subplots(self, *args):\n3170         if hasattr(self, \"subplot_tool\"):\n3171             self.subplot_tool.figure.canvas.manager.show()\n3172             return\n3173         # This import needs to happen here due to circular imports.\n3174         from matplotlib.figure import Figure\n3175         with mpl.rc_context({\"toolbar\": \"none\"}):  # No navbar for the toolfig.\n3176             manager = type(self.canvas).new_manager(Figure(figsize=(6, 3)), -1)\n3177         manager.set_window_title(\"Subplot configuration tool\")\n3178         tool_fig = manager.canvas.figure\n3179         tool_fig.subplots_adjust(top=0.9)\n3180         self.subplot_tool = widgets.SubplotTool(self.canvas.figure, tool_fig)\n3181         cid = self.canvas.mpl_connect(\n3182             \"close_event\", lambda e: manager.destroy())\n3183 \n3184         def on_tool_fig_close(e):\n3185             self.canvas.mpl_disconnect(cid)\n3186             del self.subplot_tool\n3187 \n3188         tool_fig.canvas.mpl_connect(\"close_event\", on_tool_fig_close)\n3189         manager.show()\n3190         return self.subplot_tool\n3191 \n3192     def save_figure(self, *args):\n3193         \"\"\"Save the current figure.\"\"\"\n3194         raise NotImplementedError\n3195 \n3196     def update(self):\n3197         \"\"\"Reset the Axes stack.\"\"\"\n3198         self._nav_stack.clear()\n3199         self.set_history_buttons()\n3200 \n3201     def set_history_buttons(self):\n3202         \"\"\"Enable or disable the back/forward button.\"\"\"\n3203 \n3204 \n3205 class ToolContainerBase:\n3206     \"\"\"\n3207     Base class for all tool containers, e.g. toolbars.\n3208 \n3209     Attributes\n3210     ----------\n3211     toolmanager : `.ToolManager`\n3212         The tools with which this `ToolContainer` wants to communicate.\n3213     \"\"\"\n3214 \n3215     _icon_extension = '.png'\n3216     \"\"\"\n3217     Toolcontainer button icon image format extension\n3218 \n3219     **String**: Image extension\n3220     \"\"\"\n3221 \n3222     def __init__(self, toolmanager):\n3223         self.toolmanager = toolmanager\n3224         toolmanager.toolmanager_connect(\n3225             'tool_message_event',\n3226             lambda event: self.set_message(event.message))\n3227         toolmanager.toolmanager_connect(\n3228             'tool_removed_event',\n3229             lambda event: self.remove_toolitem(event.tool.name))\n3230 \n3231     def _tool_toggled_cbk(self, event):\n3232         \"\"\"\n3233         Capture the 'tool_trigger_[name]'\n3234 \n3235         This only gets used for toggled tools.\n3236         \"\"\"\n3237         self.toggle_toolitem(event.tool.name, event.tool.toggled)\n3238 \n3239     def add_tool(self, tool, group, position=-1):\n3240         \"\"\"\n3241         Add a tool to this container.\n3242 \n3243         Parameters\n3244         ----------\n3245         tool : tool_like\n3246             The tool to add, see `.ToolManager.get_tool`.\n3247         group : str\n3248             The name of the group to add this tool to.\n3249         position : int, default: -1\n3250             The position within the group to place this tool.\n3251         \"\"\"\n3252         tool = self.toolmanager.get_tool(tool)\n3253         image = self._get_image_filename(tool.image)\n3254         toggle = getattr(tool, 'toggled', None) is not None\n3255         self.add_toolitem(tool.name, group, position,\n3256                           image, tool.description, toggle)\n3257         if toggle:\n3258             self.toolmanager.toolmanager_connect('tool_trigger_%s' % tool.name,\n3259                                                  self._tool_toggled_cbk)\n3260             # If initially toggled\n3261             if tool.toggled:\n3262                 self.toggle_toolitem(tool.name, True)\n3263 \n3264     def _get_image_filename(self, image):\n3265         \"\"\"Find the image based on its name.\"\"\"\n3266         if not image:\n3267             return None\n3268 \n3269         basedir = cbook._get_data_path(\"images\")\n3270         for fname in [\n3271             image,\n3272             image + self._icon_extension,\n3273             str(basedir / image),\n3274             str(basedir / (image + self._icon_extension)),\n3275         ]:\n3276             if os.path.isfile(fname):\n3277                 return fname\n3278 \n3279     def trigger_tool(self, name):\n3280         \"\"\"\n3281         Trigger the tool.\n3282 \n3283         Parameters\n3284         ----------\n3285         name : str\n3286             Name (id) of the tool triggered from within the container.\n3287         \"\"\"\n3288         self.toolmanager.trigger_tool(name, sender=self)\n3289 \n3290     def add_toolitem(self, name, group, position, image, description, toggle):\n3291         \"\"\"\n3292         Add a toolitem to the container.\n3293 \n3294         This method must be implemented per backend.\n3295 \n3296         The callback associated with the button click event,\n3297         must be *exactly* ``self.trigger_tool(name)``.\n3298 \n3299         Parameters\n3300         ----------\n3301         name : str\n3302             Name of the tool to add, this gets used as the tool's ID and as the\n3303             default label of the buttons.\n3304         group : str\n3305             Name of the group that this tool belongs to.\n3306         position : int\n3307             Position of the tool within its group, if -1 it goes at the end.\n3308         image : str\n3309             Filename of the image for the button or `None`.\n3310         description : str\n3311             Description of the tool, used for the tooltips.\n3312         toggle : bool\n3313             * `True` : The button is a toggle (change the pressed/unpressed\n3314               state between consecutive clicks).\n3315             * `False` : The button is a normal button (returns to unpressed\n3316               state after release).\n3317         \"\"\"\n3318         raise NotImplementedError\n3319 \n3320     def toggle_toolitem(self, name, toggled):\n3321         \"\"\"\n3322         Toggle the toolitem without firing event.\n3323 \n3324         Parameters\n3325         ----------\n3326         name : str\n3327             Id of the tool to toggle.\n3328         toggled : bool\n3329             Whether to set this tool as toggled or not.\n3330         \"\"\"\n3331         raise NotImplementedError\n3332 \n3333     def remove_toolitem(self, name):\n3334         \"\"\"\n3335         Remove a toolitem from the `ToolContainer`.\n3336 \n3337         This method must get implemented per backend.\n3338 \n3339         Called when `.ToolManager` emits a `tool_removed_event`.\n3340 \n3341         Parameters\n3342         ----------\n3343         name : str\n3344             Name of the tool to remove.\n3345         \"\"\"\n3346         raise NotImplementedError\n3347 \n3348     def set_message(self, s):\n3349         \"\"\"\n3350         Display a message on the toolbar.\n3351 \n3352         Parameters\n3353         ----------\n3354         s : str\n3355             Message text.\n3356         \"\"\"\n3357         raise NotImplementedError\n3358 \n3359 \n3360 class _Backend:\n3361     # A backend can be defined by using the following pattern:\n3362     #\n3363     # @_Backend.export\n3364     # class FooBackend(_Backend):\n3365     #     # override the attributes and methods documented below.\n3366 \n3367     # `backend_version` may be overridden by the subclass.\n3368     backend_version = \"unknown\"\n3369 \n3370     # The `FigureCanvas` class must be defined.\n3371     FigureCanvas = None\n3372 \n3373     # For interactive backends, the `FigureManager` class must be overridden.\n3374     FigureManager = FigureManagerBase\n3375 \n3376     # For interactive backends, `mainloop` should be a function taking no\n3377     # argument and starting the backend main loop.  It should be left as None\n3378     # for non-interactive backends.\n3379     mainloop = None\n3380 \n3381     # The following methods will be automatically defined and exported, but\n3382     # can be overridden.\n3383 \n3384     @classmethod\n3385     def new_figure_manager(cls, num, *args, **kwargs):\n3386         \"\"\"Create a new figure manager instance.\"\"\"\n3387         # This import needs to happen here due to circular imports.\n3388         from matplotlib.figure import Figure\n3389         fig_cls = kwargs.pop('FigureClass', Figure)\n3390         fig = fig_cls(*args, **kwargs)\n3391         return cls.new_figure_manager_given_figure(num, fig)\n3392 \n3393     @classmethod\n3394     def new_figure_manager_given_figure(cls, num, figure):\n3395         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n3396         return cls.FigureCanvas.new_manager(figure, num)\n3397 \n3398     @classmethod\n3399     def draw_if_interactive(cls):\n3400         manager_class = cls.FigureCanvas.manager_class\n3401         # Interactive backends reimplement start_main_loop or pyplot_show.\n3402         backend_is_interactive = (\n3403             manager_class.start_main_loop != FigureManagerBase.start_main_loop\n3404             or manager_class.pyplot_show != FigureManagerBase.pyplot_show)\n3405         if backend_is_interactive and is_interactive():\n3406             manager = Gcf.get_active()\n3407             if manager:\n3408                 manager.canvas.draw_idle()\n3409 \n3410     @classmethod\n3411     def show(cls, *, block=None):\n3412         \"\"\"\n3413         Show all figures.\n3414 \n3415         `show` blocks by calling `mainloop` if *block* is ``True``, or if it\n3416         is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in\n3417         `interactive` mode.\n3418         \"\"\"\n3419         managers = Gcf.get_all_fig_managers()\n3420         if not managers:\n3421             return\n3422         for manager in managers:\n3423             try:\n3424                 manager.show()  # Emits a warning for non-interactive backend.\n3425             except NonGuiException as exc:\n3426                 _api.warn_external(str(exc))\n3427         if cls.mainloop is None:\n3428             return\n3429         if block is None:\n3430             # Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython\n3431             # (>= 0.10) tacks a _needmain attribute onto pyplot.show (always\n3432             # set to False).\n3433             pyplot_show = getattr(sys.modules.get(\"matplotlib.pyplot\"), \"show\", None)\n3434             ipython_pylab = hasattr(pyplot_show, \"_needmain\")\n3435             block = not ipython_pylab and not is_interactive()\n3436         if block:\n3437             cls.mainloop()\n3438 \n3439     # This method is the one actually exporting the required methods.\n3440 \n3441     @staticmethod\n3442     def export(cls):\n3443         for name in [\n3444                 \"backend_version\",\n3445                 \"FigureCanvas\",\n3446                 \"FigureManager\",\n3447                 \"new_figure_manager\",\n3448                 \"new_figure_manager_given_figure\",\n3449                 \"draw_if_interactive\",\n3450                 \"show\",\n3451         ]:\n3452             setattr(sys.modules[cls.__module__], name, getattr(cls, name))\n3453 \n3454         # For back-compatibility, generate a shim `Show` class.\n3455 \n3456         class Show(ShowBase):\n3457             def mainloop(self):\n3458                 return cls.mainloop()\n3459 \n3460         setattr(sys.modules[cls.__module__], \"Show\", Show)\n3461         return cls\n3462 \n3463 \n3464 class ShowBase(_Backend):\n3465     \"\"\"\n3466     Simple base class to generate a ``show()`` function in backends.\n3467 \n3468     Subclass must override ``mainloop()`` method.\n3469     \"\"\"\n3470 \n3471     def __call__(self, block=None):\n3472         return self.show(block=block)\n",
        "intended_behavior": "Introduce or adjust the existing context manager to allow for a temporary backend switch that does not close GUI windows upon exiting the context. This could include implementing a preservation state for GUI windows or delaying any close calls on figures created within a GUI context until the notebook session ends or the user explicitly closes them."
    }
]