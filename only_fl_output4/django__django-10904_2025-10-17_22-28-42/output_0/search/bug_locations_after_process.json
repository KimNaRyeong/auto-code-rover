[
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 42,
        "end": 74,
        "class_name": "EmailBackend",
        "method_name": "open",
        "code": "42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n",
        "intended_behavior": "Replace `except (smtplib.SMTPException, socket.error):` with `except OSError:` to simplify the exception handling. This change accounts for the fact that `SMTPException` is now a subclass of `OSError`, and `socket.error` is an alias for `OSError`. The method's functionality should remain unchanged, continuing to handle exceptions that occur during the establishment of an SMTP connection in a fail-silently or raise-error manner, depending on the configuration."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 59,
        "end": 63,
        "class_name": "EmailBackend",
        "method_name": "open",
        "code": "59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n",
        "intended_behavior": "Replace `except (smtplib.SMTPException, socket.error):` with `except OSError:` to simplify the exception handling. This change accounts for the fact that `SMTPException` is now a subclass of `OSError`, and `socket.error` is an alias for `OSError`. The method's functionality should remain unchanged, continuing to handle exceptions that occur during the establishment of an SMTP connection in a fail-silently or raise-error manner, depending on the configuration."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 13,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(ConsoleEmailBackend):\n14     def __init__(self, *args, file_path=None, **kwargs):\n15         self._fname = None\n16         if file_path is not None:\n17             self.file_path = file_path\n18         else:\n19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)\n20         # Make sure self.file_path is a string.\n21         if not isinstance(self.file_path, str):\n22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)\n23         self.file_path = os.path.abspath(self.file_path)\n24         # Make sure that self.file_path is a directory if it exists.\n25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):\n26             raise ImproperlyConfigured(\n27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path\n28             )\n29         # Try to create it, if it not exists.\n30         elif not os.path.exists(self.file_path):\n31             try:\n32                 os.makedirs(self.file_path)\n33             except OSError as err:\n34                 raise ImproperlyConfigured(\n35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)\n36                 )\n37         # Make sure that self.file_path is writable.\n38         if not os.access(self.file_path, os.W_OK):\n39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)\n40         # Finally, call super().\n41         # Since we're using the console-based backend as a base,\n42         # force the stream to be None, so we don't default to stdout\n43         kwargs['stream'] = None\n44         super().__init__(*args, **kwargs)\n45 \n46     def write_message(self, message):\n47         self.stream.write(message.message().as_bytes() + b'\\n')\n48         self.stream.write(b'-' * 79)\n49         self.stream.write(b'\\n')\n50 \n51     def _get_filename(self):\n52         \"\"\"Return a unique file name.\"\"\"\n53         if self._fname is None:\n54             timestamp = datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n55             fname = \"%s-%s.log\" % (timestamp, abs(id(self)))\n56             self._fname = os.path.join(self.file_path, fname)\n57         return self._fname\n58 \n59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n64 \n65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 76,
        "end": 93,
        "class_name": "EmailBackend",
        "method_name": "close",
        "code": "76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n",
        "intended_behavior": "Simplify the `except smtplib.SMTPException:` block to `except OSError:`. This modification maintains the method's purpose, which is to close the SMTP connection gracefully, handling any exceptions that may arise during the closure without altering the response in case of errors, based on the `fail_silently` attribute."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 65,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": "close",
        "code": "65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "Simplify the `except smtplib.SMTPException:` block to `except OSError:`. This modification maintains the method's purpose, which is to close the SMTP connection gracefully, handling any exceptions that may arise during the closure without altering the response in case of errors, based on the `fail_silently` attribute."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 13,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(ConsoleEmailBackend):\n14     def __init__(self, *args, file_path=None, **kwargs):\n15         self._fname = None\n16         if file_path is not None:\n17             self.file_path = file_path\n18         else:\n19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)\n20         # Make sure self.file_path is a string.\n21         if not isinstance(self.file_path, str):\n22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)\n23         self.file_path = os.path.abspath(self.file_path)\n24         # Make sure that self.file_path is a directory if it exists.\n25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):\n26             raise ImproperlyConfigured(\n27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path\n28             )\n29         # Try to create it, if it not exists.\n30         elif not os.path.exists(self.file_path):\n31             try:\n32                 os.makedirs(self.file_path)\n33             except OSError as err:\n34                 raise ImproperlyConfigured(\n35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)\n36                 )\n37         # Make sure that self.file_path is writable.\n38         if not os.access(self.file_path, os.W_OK):\n39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)\n40         # Finally, call super().\n41         # Since we're using the console-based backend as a base,\n42         # force the stream to be None, so we don't default to stdout\n43         kwargs['stream'] = None\n44         super().__init__(*args, **kwargs)\n45 \n46     def write_message(self, message):\n47         self.stream.write(message.message().as_bytes() + b'\\n')\n48         self.stream.write(b'-' * 79)\n49         self.stream.write(b'\\n')\n50 \n51     def _get_filename(self):\n52         \"\"\"Return a unique file name.\"\"\"\n53         if self._fname is None:\n54             timestamp = datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n55             fname = \"%s-%s.log\" % (timestamp, abs(id(self)))\n56             self._fname = os.path.join(self.file_path, fname)\n57         return self._fname\n58 \n59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n64 \n65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 117,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": "_send",
        "code": "117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "Update the exception handling from `except smtplib.SMTPException:` to `except OSError:`. This keeps the error handling during email dispatching through SMTP intact, ensuring that connection and sending errors are appropriately managed without changing the external behavior of failing silently or raising errors based on configuration."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]