2025-10-18 08:10:54.545 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 08:11:06.561 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=159, output_tokens=12, cost=0.001950
2025-10-18 08:11:06.562 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 08:11:06.566 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:11:11.850 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=468, output_tokens=166, cost=0.009660
2025-10-18 08:11:11.857 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:11:15.365 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=520, output_tokens=44, cost=0.006520
2025-10-18 08:11:15.367 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("log{\\left")': old result is ['log{\\\\left'], new result  is ['log{\\left']
2025-10-18 08:11:15.368 | DEBUG    | Extracted a valid json.
2025-10-18 08:11:15.368 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"latex\")",
        "search_code(\"latex(ln\")",
        "search_code(\"log{\\left\")"
    ],
    "bug_locations": []
}
2025-10-18 08:11:15.401 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("log{\\left")': old result is ['log{\\\\left'], new result  is ['log{\\left']
2025-10-18 08:11:15.438 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 08:11:15.438 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 08:11:29.264 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2705, output_tokens=611, cost=0.045380
2025-10-18 08:11:29.270 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:11:30.509 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3532, output_tokens=12, cost=0.035680
2025-10-18 08:11:30.511 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:11:32.005 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=366, output_tokens=22, cost=0.004320
2025-10-18 08:11:32.007 | DEBUG    | Extracted a valid json.
2025-10-18 08:11:32.007 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"LatexPrinter\")"],
    "bug_locations": []
}
2025-10-18 08:11:32.082 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 08:11:32.083 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 08:11:51.196 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6671, output_tokens=520, cost=0.082310
2025-10-18 08:11:51.207 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:11:55.473 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7407, output_tokens=148, cost=0.078510
2025-10-18 08:11:55.475 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:12:00.826 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=502, output_tokens=153, cost=0.009610
2025-10-18 08:12:00.827 | DEBUG    | Extracted a valid json.
2025-10-18 08:12:00.828 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "sympy/printing/latex.py", "class": "LatexPrinter", "method": "_print_Function", "intended_behavior": "This method should include specific handling for the `ln` function to ensure that it is converted to `\\ln` in the LaTeX representation, not as `log`. The modification should check if the function being printed is the natural logarithm `ln` and, if so, output the LaTeX code specifically as `\\ln{...}` with the correct arguments enclosed. This handling should be added in a way that does not interfere with the rendering of other functions, thus preserving the existing functionality of the code for all other mathematical expressions."}]
}
2025-10-18 08:12:00.837 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Function</method>
<code>
708     def _print_Function(self, expr, exp=None):
709         r'''
710         Render functions to LaTeX, handling functions that LaTeX knows about
711         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
712         For single-letter function names, render them as regular LaTeX math
713         symbols. For multi-letter function names that LaTeX does not know
714         about, (e.g., Li, sech) use \operatorname{} so that the function name
715         is rendered in Roman font and LaTeX handles spacing properly.
716 
717         expr is the expression involving the function
718         exp is an exponent
719         '''
720         func = expr.func.__name__
721         if hasattr(self, '_print_' + func) and \
722             not isinstance(expr.func, UndefinedFunction):
723             return getattr(self, '_print_' + func)(expr, exp)
724         else:
725             args = [ str(self._print(arg)) for arg in expr.args ]
726             # How inverse trig functions should be displayed, formats are:
727             # abbreviated: asin, full: arcsin, power: sin^-1
728             inv_trig_style = self._settings['inv_trig_style']
729             # If we are dealing with a power-style inverse trig function
730             inv_trig_power_case = False
731             # If it is applicable to fold the argument brackets
732             can_fold_brackets = self._settings['fold_func_brackets'] and \
733                 len(args) == 1 and \
734                 not self._needs_function_brackets(expr.args[0])
735 
736             inv_trig_table = ["asin", "acos", "atan", "acot"]
737 
738             # If the function is an inverse trig function, handle the style
739             if func in inv_trig_table:
740                 if inv_trig_style == "abbreviated":
741                     func = func
742                 elif inv_trig_style == "full":
743                     func = "arc" + func[1:]
744                 elif inv_trig_style == "power":
745                     func = func[1:]
746                     inv_trig_power_case = True
747 
748                     # Can never fold brackets if we're raised to a power
749                     if exp is not None:
750                         can_fold_brackets = False
751 
752             if inv_trig_power_case:
753                 if func in accepted_latex_functions:
754                     name = r"\%s^{-1}" % func
755                 else:
756                     name = r"\operatorname{%s}^{-1}" % func
757             elif exp is not None:
758                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
759             else:
760                 name = self._hprint_Function(func)
761 
762             if can_fold_brackets:
763                 if func in accepted_latex_functions:
764                     # Wrap argument safely to avoid parse-time conflicts
765                     # with the function name itself
766                     name += r" {%s}"
767                 else:
768                     name += r"%s"
769             else:
770                 name += r"{\left (%s \right )}"
771 
772             if inv_trig_power_case and exp is not None:
773                 name += r"^{%s}" % exp
774 
775             return name % ",".join(args)

</code><intended_behavior>This method should include specific handling for the `ln` function to ensure that it is converted to `\ln` in the LaTeX representation, not as `log`. The modification should check if the function being printed is the natural logarithm `ln` and, if so, output the LaTeX code specifically as `\ln{...}` with the correct arguments enclosed. This handling should be added in a way that does not interfere with the rendering of other functions, thus preserving the existing functionality of the code for all other mathematical expressions.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": 2,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137     }
138 
139     def __init__(self, settings=None):
140         Printer.__init__(self, settings)
141 
142         if 'mode' in self._settings:
143             valid_modes = ['inline', 'plain', 'equation',
144                            'equation*']
145             if self._settings['mode'] not in valid_modes:
146                 raise ValueError("'mode' must be one of 'inline', 'plain', "
147                     "'equation' or 'equation*'")
148 
149         if self._settings['fold_short_frac'] is None and \
150                 self._settings['mode'] == 'inline':
151             self._settings['fold_short_frac'] = True
152 
153         mul_symbol_table = {
154             None: r" ",
155             "ldot": r" \,.\, ",
156             "dot": r" \cdot ",
157             "times": r" \times "
158         }
159         try:
160             self._settings['mul_symbol_latex'] = \
161                 mul_symbol_table[self._settings['mul_symbol']]
162         except KeyError:
163             self._settings['mul_symbol_latex'] = \
164                 self._settings['mul_symbol']
165         try:
166             self._settings['mul_symbol_latex_numbers'] = \
167                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
168         except KeyError:
169             if (self._settings['mul_symbol'].strip() in
170                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
171                 self._settings['mul_symbol_latex_numbers'] = \
172                     mul_symbol_table['dot']
173             else:
174                 self._settings['mul_symbol_latex_numbers'] = \
175                     self._settings['mul_symbol']
176 
177         self._delim_dict = {'(': ')', '[': ']'}
178 
179     def parenthesize(self, item, level, strict=False):
180         prec_val = precedence_traditional(item)
181         if (prec_val < level) or ((not strict) and prec_val <= level):
182             return r"\left(%s\right)" % self._print(item)
183         else:
184             return self._print(item)
185 
186     def doprint(self, expr):
187         tex = Printer.doprint(self, expr)
188 
189         if self._settings['mode'] == 'plain':
190             return tex
191         elif self._settings['mode'] == 'inline':
192             return r"$%s$" % tex
193         elif self._settings['itex']:
194             return r"$$%s$$" % tex
195         else:
196             env_str = self._settings['mode']
197             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
198 
199     def _needs_brackets(self, expr):
200         """
201         Returns True if the expression needs to be wrapped in brackets when
202         printed, False otherwise. For example: a + b => True; a => False;
203         10 => False; -10 => True.
204         """
205         return not ((expr.is_Integer and expr.is_nonnegative)
206                     or (expr.is_Atom and (expr is not S.NegativeOne
207                                           and expr.is_Rational is False)))
208 
209     def _needs_function_brackets(self, expr):
210         """
211         Returns True if the expression needs to be wrapped in brackets when
212         passed as an argument to a function, False otherwise. This is a more
213         liberal version of _needs_brackets, in that many expressions which need
214         to be wrapped in brackets when added/subtracted/raised to a power do
215         not need them when passed to a function. Such an example is a*b.
216         """
217         if not self._needs_brackets(expr):
218             return False
219         else:
220             # Muls of the form a*b*c... can be folded
221             if expr.is_Mul and not self._mul_is_clean(expr):
222                 return True
223             # Pows which don't need brackets can be folded
224             elif expr.is_Pow and not self._pow_is_clean(expr):
225                 return True
226             # Add and Function always need brackets
227             elif expr.is_Add or expr.is_Function:
228                 return True
229             else:
230                 return False
231 
232     def _needs_mul_brackets(self, expr, first=False, last=False):
233         """
234         Returns True if the expression needs to be wrapped in brackets when
235         printed as part of a Mul, False otherwise. This is True for Add,
236         but also for some container objects that would not need brackets
237         when appearing last in a Mul, e.g. an Integral. ``last=True``
238         specifies that this expr is the last to appear in a Mul.
239         ``first=True`` specifies that this expr is the first to appear in a Mul.
240         """
241         from sympy import Integral, Piecewise, Product, Sum
242 
243         if expr.is_Mul:
244             if not first and _coeff_isneg(expr):
245                 return True
246         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
247             return True
248         elif expr.is_Relational:
249             return True
250         if expr.is_Piecewise:
251             return True
252         if any([expr.has(x) for x in (Mod,)]):
253             return True
254         if (not last and
255             any([expr.has(x) for x in (Integral, Product, Sum)])):
256             return True
257 
258         return False
259 
260 
261     def _needs_add_brackets(self, expr):
262         """
263         Returns True if the expression needs to be wrapped in brackets when
264         printed as part of an Add, False otherwise.  This is False for most
265         things.
266         """
267         if expr.is_Relational:
268             return True
269         if any([expr.has(x) for x in (Mod,)]):
270             return True
271         if expr.is_Add:
272             return True
273         return False
274 
275 
276     def _mul_is_clean(self, expr):
277         for arg in expr.args:
278             if arg.is_Function:
279                 return False
280         return True
281 
282     def _pow_is_clean(self, expr):
283         return not self._needs_brackets(expr.base)
284 
285     def _do_exponent(self, expr, exp):
286         if exp is not None:
287             return r"\left(%s\right)^{%s}" % (expr, exp)
288         else:
289             return expr
290 
291     def _print_bool(self, e):
292         return r"\mathrm{%s}" % e
293 
294     _print_BooleanTrue = _print_bool
295     _print_BooleanFalse = _print_bool
296 
297     def _print_NoneType(self, e):
298         return r"\mathrm{%s}" % e
299 
300 
301     def _print_Add(self, expr, order=None):
302         if self.order == 'none':
303             terms = list(expr.args)
304         else:
305             terms = self._as_ordered_terms(expr, order=order)
306 
307         tex = ""
308         for i, term in enumerate(terms):
309             if i == 0:
310                 pass
311             elif _coeff_isneg(term):
312                 tex += " - "
313                 term = -term
314             else:
315                 tex += " + "
316             term_tex = self._print(term)
317             if self._needs_add_brackets(term):
318                 term_tex = r"\left(%s\right)" % term_tex
319             tex += term_tex
320 
321         return tex
322 
323     def _print_Cycle(self, expr):
324         from sympy.combinatorics.permutations import Permutation
325         if expr.size == 0:
326             return r"\left( \right)"
327         expr = Permutation(expr)
328         expr_perm = expr.cyclic_form
329         siz = expr.size
330         if expr.array_form[-1] == siz - 1:
331             expr_perm = expr_perm + [[siz - 1]]
332         term_tex = ''
333         for i in expr_perm:
334             term_tex += str(i).replace(',', r"\;")
335         term_tex = term_tex.replace('[', r"\left( ")
336         term_tex = term_tex.replace(']', r"\right)")
337         return term_tex
338 
339     _print_Permutation = _print_Cycle
340 
341     def _print_Float(self, expr):
342         # Based off of that in StrPrinter
343         dps = prec_to_dps(expr._prec)
344         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
345 
346         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
347         # thus we use the number separator
348         separator = self._settings['mul_symbol_latex_numbers']
349 
350         if 'e' in str_real:
351             (mant, exp) = str_real.split('e')
352 
353             if exp[0] == '+':
354                 exp = exp[1:]
355 
356             return r"%s%s10^{%s}" % (mant, separator, exp)
357         elif str_real == "+inf":
358             return r"\infty"
359         elif str_real == "-inf":
360             return r"- \infty"
361         else:
362             return str_real
363 
364     def _print_Cross(self, expr):
365         vec1 = expr._expr1
366         vec2 = expr._expr2
367         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
368                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
369 
370     def _print_Curl(self, expr):
371         vec = expr._expr
372         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
373 
374     def _print_Divergence(self, expr):
375         vec = expr._expr
376         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
377 
378     def _print_Dot(self, expr):
379         vec1 = expr._expr1
380         vec2 = expr._expr2
381         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
382                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
383 
384     def _print_Gradient(self, expr):
385         func = expr._expr
386         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
387 
388     def _print_Mul(self, expr):
389         from sympy.core.power import Pow
390         include_parens = False
391         if _coeff_isneg(expr):
392             expr = -expr
393             tex = "- "
394             if expr.is_Add:
395                 tex += "("
396                 include_parens = True
397         else:
398             tex = ""
399 
400         from sympy.simplify import fraction
401         numer, denom = fraction(expr, exact=True)
402         separator = self._settings['mul_symbol_latex']
403         numbersep = self._settings['mul_symbol_latex_numbers']
404 
405         def convert(expr):
406             if not expr.is_Mul:
407                 return str(self._print(expr))
408             else:
409                 _tex = last_term_tex = ""
410 
411                 if self.order not in ('old', 'none'):
412                     args = expr.as_ordered_factors()
413                 else:
414                     args = expr.args
415 
416                 for i, term in enumerate(args):
417                     term_tex = self._print(term)
418 
419                     if self._needs_mul_brackets(term, first=(i == 0),
420                                                 last=(i == len(args) - 1)):
421                         term_tex = r"\left(%s\right)" % term_tex
422 
423                     if _between_two_numbers_p[0].search(last_term_tex) and \
424                             _between_two_numbers_p[1].match(term_tex):
425                         # between two numbers
426                         _tex += numbersep
427                     elif _tex:
428                         _tex += separator
429 
430                     _tex += term_tex
431                     last_term_tex = term_tex
432                 return _tex
433 
434         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
435             # use the original expression here, since fraction() may have
436             # altered it when producing numer and denom
437             tex += convert(expr)
438 
439         else:
440             snumer = convert(numer)
441             sdenom = convert(denom)
442             ldenom = len(sdenom.split())
443             ratio = self._settings['long_frac_ratio']
444             if self._settings['fold_short_frac'] \
445                     and ldenom <= 2 and not "^" in sdenom:
446                 # handle short fractions
447                 if self._needs_mul_brackets(numer, last=False):
448                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
449                 else:
450                     tex += r"%s / %s" % (snumer, sdenom)
451             elif len(snumer.split()) > ratio*ldenom:
452                 # handle long fractions
453                 if self._needs_mul_brackets(numer, last=True):
454                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
455                         % (sdenom, separator, snumer)
456                 elif numer.is_Mul:
457                     # split a long numerator
458                     a = S.One
459                     b = S.One
460                     for x in numer.args:
461                         if self._needs_mul_brackets(x, last=False) or \
462                                 len(convert(a*x).split()) > ratio*ldenom or \
463                                 (b.is_commutative is x.is_commutative is False):
464                             b *= x
465                         else:
466                             a *= x
467                     if self._needs_mul_brackets(b, last=True):
468                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
469                             % (convert(a), sdenom, separator, convert(b))
470                     else:
471                         tex += r"\frac{%s}{%s}%s%s" \
472                             % (convert(a), sdenom, separator, convert(b))
473                 else:
474                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
475             else:
476                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
477 
478         if include_parens:
479             tex += ")"
480         return tex
481 
482     def _print_Pow(self, expr):
483         # Treat x**Rational(1,n) as special case
484         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
485             base = self._print(expr.base)
486             expq = expr.exp.q
487 
488             if expq == 2:
489                 tex = r"\sqrt{%s}" % base
490             elif self._settings['itex']:
491                 tex = r"\root{%d}{%s}" % (expq, base)
492             else:
493                 tex = r"\sqrt[%d]{%s}" % (expq, base)
494 
495             if expr.exp.is_negative:
496                 return r"\frac{1}{%s}" % tex
497             else:
498                 return tex
499         elif self._settings['fold_frac_powers'] \
500             and expr.exp.is_Rational \
501                 and expr.exp.q != 1:
502             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
503             #fixes issue #12886, adds parentheses before superscripts raised to powers
504             if '^' in base and expr.base.is_Symbol:
505                 base = r"\left(%s\right)" % base
506             if expr.base.is_Function:
507                 return self._print(expr.base, "%s/%s" % (p, q))
508             return r"%s^{%s/%s}" % (base, p, q)
509         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
510             # Things like 1/x
511             return self._print_Mul(expr)
512         else:
513             if expr.base.is_Function:
514                 return self._print(expr.base, self._print(expr.exp))
515             else:
516                 if expr.is_commutative and expr.exp == -1:
517                     #solves issue 4129
518                     #As Mul always simplify 1/x to x**-1
519                     #The objective is achieved with this hack
520                     #first we get the latex for -1 * expr,
521                     #which is a Mul expression
522                     tex = self._print(S.NegativeOne * expr).strip()
523                     #the result comes with a minus and a space, so we remove
524                     if tex[:1] == "-":
525                         return tex[1:].strip()
526                 tex = r"%s^{%s}"
527                 #fixes issue #12886, adds parentheses before superscripts raised to powers
528                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
529                 if '^' in base and expr.base.is_Symbol:
530                     base = r"\left(%s\right)" % base
531                 exp = self._print(expr.exp)
532 
533                 return tex % (base, exp)
534 
535     def _print_UnevaluatedExpr(self, expr):
536         return self._print(expr.args[0])
537 
538     def _print_Sum(self, expr):
539         if len(expr.limits) == 1:
540             tex = r"\sum_{%s=%s}^{%s} " % \
541                 tuple([ self._print(i) for i in expr.limits[0] ])
542         else:
543             def _format_ineq(l):
544                 return r"%s \leq %s \leq %s" % \
545                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
546 
547             tex = r"\sum_{\substack{%s}} " % \
548                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
549 
550         if isinstance(expr.function, Add):
551             tex += r"\left(%s\right)" % self._print(expr.function)
552         else:
553             tex += self._print(expr.function)
554 
555         return tex
556 
557     def _print_Product(self, expr):
558         if len(expr.limits) == 1:
559             tex = r"\prod_{%s=%s}^{%s} " % \
560                 tuple([ self._print(i) for i in expr.limits[0] ])
561         else:
562             def _format_ineq(l):
563                 return r"%s \leq %s \leq %s" % \
564                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
565 
566             tex = r"\prod_{\substack{%s}} " % \
567                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
568 
569         if isinstance(expr.function, Add):
570             tex += r"\left(%s\right)" % self._print(expr.function)
571         else:
572             tex += self._print(expr.function)
573 
574         return tex
575 
576     def _print_BasisDependent(self, expr):
577         from sympy.vector import Vector
578 
579         o1 = []
580         if expr == expr.zero:
581             return expr.zero._latex_form
582         if isinstance(expr, Vector):
583             items = expr.separate().items()
584         else:
585             items = [(0, expr)]
586 
587         for system, vect in items:
588             inneritems = list(vect.components.items())
589             inneritems.sort(key = lambda x:x[0].__str__())
590             for k, v in inneritems:
591                 if v == 1:
592                     o1.append(' + ' + k._latex_form)
593                 elif v == -1:
594                     o1.append(' - ' + k._latex_form)
595                 else:
596                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
597                     o1.append(' + ' + arg_str + k._latex_form)
598 
599         outstr = (''.join(o1))
600         if outstr[1] != '-':
601             outstr = outstr[3:]
602         else:
603             outstr = outstr[1:]
604         return outstr
605 
606     def _print_Indexed(self, expr):
607         tex = self._print(expr.base)+'_{%s}' % ','.join(
608             map(self._print, expr.indices))
609         return tex
610 
611     def _print_IndexedBase(self, expr):
612         return self._print(expr.label)
613 
614     def _print_Derivative(self, expr):
615         if requires_partial(expr):
616             diff_symbol = r'\partial'
617         else:
618             diff_symbol = r'd'
619 
620         tex = ""
621         dim = 0
622         for x, num in reversed(expr.variable_count):
623             dim += num
624             if num == 1:
625                 tex += r"%s %s" % (diff_symbol, self._print(x))
626             else:
627                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
628 
629         if dim == 1:
630             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
631         else:
632             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
633 
634         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
635 
636     def _print_Subs(self, subs):
637         expr, old, new = subs.args
638         latex_expr = self._print(expr)
639         latex_old = (self._print(e) for e in old)
640         latex_new = (self._print(e) for e in new)
641         latex_subs = r'\\ '.join(
642             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
643         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
644 
645     def _print_Integral(self, expr):
646         tex, symbols = "", []
647 
648         # Only up to \iiiint exists
649         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
650             # Use len(expr.limits)-1 so that syntax highlighters don't think
651             # \" is an escaped quote
652             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
653             symbols = [r"\, d%s" % self._print(symbol[0])
654                        for symbol in expr.limits]
655 
656         else:
657             for lim in reversed(expr.limits):
658                 symbol = lim[0]
659                 tex += r"\int"
660 
661                 if len(lim) > 1:
662                     if self._settings['mode'] in ['equation', 'equation*'] \
663                             and not self._settings['itex']:
664                         tex += r"\limits"
665 
666                     if len(lim) == 3:
667                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
668                                                self._print(lim[2]))
669                     if len(lim) == 2:
670                         tex += "^{%s}" % (self._print(lim[1]))
671 
672                 symbols.insert(0, r"\, d%s" % self._print(symbol))
673 
674         return r"%s %s%s" % (tex,
675             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
676 
677     def _print_Limit(self, expr):
678         e, z, z0, dir = expr.args
679 
680         tex = r"\lim_{%s \to " % self._print(z)
681         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
682             tex += r"%s}" % self._print(z0)
683         else:
684             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
685 
686         if isinstance(e, AssocOp):
687             return r"%s\left(%s\right)" % (tex, self._print(e))
688         else:
689             return r"%s %s" % (tex, self._print(e))
690 
691     def _hprint_Function(self, func):
692         r'''
693         Logic to decide how to render a function to latex
694           - if it is a recognized latex name, use the appropriate latex command
695           - if it is a single letter, just use that letter
696           - if it is a longer name, then put \operatorname{} around it and be
697             mindful of undercores in the name
698         '''
699         func = self._deal_with_super_sub(func)
700         if func in accepted_latex_functions:
701             name = r"\%s" % func
702         elif len(func) == 1 or func.startswith('\\'):
703             name = func
704         else:
705             name = r"\operatorname{%s}" % func
706         return name
707 
708     def _print_Function(self, expr, exp=None):
709         r'''
710         Render functions to LaTeX, handling functions that LaTeX knows about
711         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
712         For single-letter function names, render them as regular LaTeX math
713         symbols. For multi-letter function names that LaTeX does not know
714         about, (e.g., Li, sech) use \operatorname{} so that the function name
715         is rendered in Roman font and LaTeX handles spacing properly.
716 
717         expr is the expression involving the function
718         exp is an exponent
719         '''
720         func = expr.func.__name__
721         if hasattr(self, '_print_' + func) and \
722             not isinstance(expr.func, UndefinedFunction):
723             return getattr(self, '_print_' + func)(expr, exp)
724         else:
725             args = [ str(self._print(arg)) for arg in expr.args ]
726             # How inverse trig functions should be displayed, formats are:
727             # abbreviated: asin, full: arcsin, power: sin^-1
728             inv_trig_style = self._settings['inv_trig_style']
729             # If we are dealing with a power-style inverse trig function
730             inv_trig_power_case = False
731             # If it is applicable to fold the argument brackets
732             can_fold_brackets = self._settings['fold_func_brackets'] and \
733                 len(args) == 1 and \
734                 not self._needs_function_brackets(expr.args[0])
735 
736             inv_trig_table = ["asin", "acos", "atan", "acot"]
737 
738             # If the function is an inverse trig function, handle the style
739             if func in inv_trig_table:
740                 if inv_trig_style == "abbreviated":
741                     func = func
742                 elif inv_trig_style == "full":
743                     func = "arc" + func[1:]
744                 elif inv_trig_style == "power":
745                     func = func[1:]
746                     inv_trig_power_case = True
747 
748                     # Can never fold brackets if we're raised to a power
749                     if exp is not None:
750                         can_fold_brackets = False
751 
752             if inv_trig_power_case:
753                 if func in accepted_latex_functions:
754                     name = r"\%s^{-1}" % func
755                 else:
756                     name = r"\operatorname{%s}^{-1}" % func
757             elif exp is not None:
758                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
759             else:
760                 name = self._hprint_Function(func)
761 
762             if can_fold_brackets:
763                 if func in accepted_latex_functions:
764                     # Wrap argument safely to avoid parse-time conflicts
765                     # with the function name itself
766                     name += r" {%s}"
767                 else:
768                     name += r"%s"
769             else:
770                 name += r"{\left (%s \right )}"
771 
772             if inv_trig_power_case and exp is not None:
773                 name += r"^{%s}" % exp
774 
775             return name % ",".join(args)
776 
777     def _print_UndefinedFunction(self, expr):
778         return self._hprint_Function(str(expr))
779 
780     @property
781     def _special_function_classes(self):
782         from sympy.functions.special.tensor_functions import KroneckerDelta
783         from sympy.functions.special.gamma_functions import gamma, lowergamma
784         from sympy.functions.special.beta_functions import beta
785         from sympy.functions.special.delta_functions import DiracDelta
786         from sympy.functions.special.error_functions import Chi
787         return {KroneckerDelta: r'\delta',
788                 gamma:  r'\Gamma',
789                 lowergamma: r'\gamma',
790                 beta: r'\operatorname{B}',
791                 DiracDelta: r'\delta',
792                 Chi: r'\operatorname{Chi}'}
793 
794     def _print_FunctionClass(self, expr):
795         for cls in self._special_function_classes:
796             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
797                 return self._special_function_classes[cls]
798         return self._hprint_Function(str(expr))
799 
800     def _print_Lambda(self, expr):
801         symbols, expr = expr.args
802 
803         if len(symbols) == 1:
804             symbols = self._print(symbols[0])
805         else:
806             symbols = self._print(tuple(symbols))
807 
808         args = (symbols, self._print(expr))
809         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
810 
811         return tex
812 
813     def _print_Min(self, expr, exp=None):
814         args = sorted(expr.args, key=default_sort_key)
815         texargs = [r"%s" % self._print(symbol) for symbol in args]
816         tex = r"\min\left(%s\right)" % ", ".join(texargs)
817 
818         if exp is not None:
819             return r"%s^{%s}" % (tex, exp)
820         else:
821             return tex
822 
823     def _print_Max(self, expr, exp=None):
824         args = sorted(expr.args, key=default_sort_key)
825         texargs = [r"%s" % self._print(symbol) for symbol in args]
826         tex = r"\max\left(%s\right)" % ", ".join(texargs)
827 
828         if exp is not None:
829             return r"%s^{%s}" % (tex, exp)
830         else:
831             return tex
832 
833     def _print_floor(self, expr, exp=None):
834         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
835 
836         if exp is not None:
837             return r"%s^{%s}" % (tex, exp)
838         else:
839             return tex
840 
841     def _print_ceiling(self, expr, exp=None):
842         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
843 
844         if exp is not None:
845             return r"%s^{%s}" % (tex, exp)
846         else:
847             return tex
848 
849     def _print_Abs(self, expr, exp=None):
850         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
851 
852         if exp is not None:
853             return r"%s^{%s}" % (tex, exp)
854         else:
855             return tex
856     _print_Determinant = _print_Abs
857 
858     def _print_re(self, expr, exp=None):
859         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
860 
861         return self._do_exponent(tex, exp)
862 
863     def _print_im(self, expr, exp=None):
864         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
865 
866         return self._do_exponent(tex, exp)
867 
868     def _print_Not(self, e):
869         from sympy import Equivalent, Implies
870         if isinstance(e.args[0], Equivalent):
871             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
872         if isinstance(e.args[0], Implies):
873             return self._print_Implies(e.args[0], r"\not\Rightarrow")
874         if (e.args[0].is_Boolean):
875             return r"\neg (%s)" % self._print(e.args[0])
876         else:
877             return r"\neg %s" % self._print(e.args[0])
878 
879     def _print_LogOp(self, args, char):
880         arg = args[0]
881         if arg.is_Boolean and not arg.is_Not:
882             tex = r"\left(%s\right)" % self._print(arg)
883         else:
884             tex = r"%s" % self._print(arg)
885 
886         for arg in args[1:]:
887             if arg.is_Boolean and not arg.is_Not:
888                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
889             else:
890                 tex += r" %s %s" % (char, self._print(arg))
891 
892         return tex
893 
894     def _print_And(self, e):
895         args = sorted(e.args, key=default_sort_key)
896         return self._print_LogOp(args, r"\wedge")
897 
898     def _print_Or(self, e):
899         args = sorted(e.args, key=default_sort_key)
900         return self._print_LogOp(args, r"\vee")
901 
902     def _print_Xor(self, e):
903         args = sorted(e.args, key=default_sort_key)
904         return self._print_LogOp(args, r"\veebar")
905 
906     def _print_Implies(self, e, altchar=None):
907         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
908 
909     def _print_Equivalent(self, e, altchar=None):
910         args = sorted(e.args, key=default_sort_key)
911         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
912 
913     def _print_conjugate(self, expr, exp=None):
914         tex = r"\overline{%s}" % self._print(expr.args[0])
915 
916         if exp is not None:
917             return r"%s^{%s}" % (tex, exp)
918         else:
919             return tex
920 
921     def _print_polar_lift(self, expr, exp=None):
922         func = r"\operatorname{polar\_lift}"
923         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
924 
925         if exp is not None:
926             return r"%s^{%s}%s" % (func, exp, arg)
927         else:
928             return r"%s%s" % (func, arg)
929 
930     def _print_ExpBase(self, expr, exp=None):
931         # TODO should exp_polar be printed differently?
932         #      what about exp_polar(0), exp_polar(1)?
933         tex = r"e^{%s}" % self._print(expr.args[0])
934         return self._do_exponent(tex, exp)
935 
936     def _print_elliptic_k(self, expr, exp=None):
937         tex = r"\left(%s\right)" % self._print(expr.args[0])
938         if exp is not None:
939             return r"K^{%s}%s" % (exp, tex)
940         else:
941             return r"K%s" % tex
942 
943     def _print_elliptic_f(self, expr, exp=None):
944         tex = r"\left(%s\middle| %s\right)" % \
945             (self._print(expr.args[0]), self._print(expr.args[1]))
946         if exp is not None:
947             return r"F^{%s}%s" % (exp, tex)
948         else:
949             return r"F%s" % tex
950 
951     def _print_elliptic_e(self, expr, exp=None):
952         if len(expr.args) == 2:
953             tex = r"\left(%s\middle| %s\right)" % \
954                 (self._print(expr.args[0]), self._print(expr.args[1]))
955         else:
956             tex = r"\left(%s\right)" % self._print(expr.args[0])
957         if exp is not None:
958             return r"E^{%s}%s" % (exp, tex)
959         else:
960             return r"E%s" % tex
961 
962     def _print_elliptic_pi(self, expr, exp=None):
963         if len(expr.args) == 3:
964             tex = r"\left(%s; %s\middle| %s\right)" % \
965                 (self._print(expr.args[0]), self._print(expr.args[1]), \
966                  self._print(expr.args[2]))
967         else:
968             tex = r"\left(%s\middle| %s\right)" % \
969                 (self._print(expr.args[0]), self._print(expr.args[1]))
970         if exp is not None:
971             return r"\Pi^{%s}%s" % (exp, tex)
972         else:
973             return r"\Pi%s" % tex
974 
975     def _print_beta(self, expr, exp=None):
976         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
977                                         self._print(expr.args[1]))
978 
979         if exp is not None:
980             return r"\operatorname{B}^{%s}%s" % (exp, tex)
981         else:
982             return r"\operatorname{B}%s" % tex
983 
984     def _print_gamma(self, expr, exp=None):
985         tex = r"\left(%s\right)" % self._print(expr.args[0])
986 
987         if exp is not None:
988             return r"\Gamma^{%s}%s" % (exp, tex)
989         else:
990             return r"\Gamma%s" % tex
991 
992     def _print_uppergamma(self, expr, exp=None):
993         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
994                                         self._print(expr.args[1]))
995 
996         if exp is not None:
997             return r"\Gamma^{%s}%s" % (exp, tex)
998         else:
999             return r"\Gamma%s" % tex
1000 
1001     def _print_lowergamma(self, expr, exp=None):
1002         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1003                                         self._print(expr.args[1]))
1004 
1005         if exp is not None:
1006             return r"\gamma^{%s}%s" % (exp, tex)
1007         else:
1008             return r"\gamma%s" % tex
1009 
1010     def _print_Chi(self, expr, exp=None):
1011         tex = r"\left(%s\right)" % self._print(expr.args[0])
1012 
1013         if exp is not None:
1014             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1015         else:
1016             return r"\operatorname{Chi}%s" % tex
1017 
1018     def _print_expint(self, expr, exp=None):
1019         tex = r"\left(%s\right)" % self._print(expr.args[1])
1020         nu = self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1024         else:
1025             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1026 
1027     def _print_fresnels(self, expr, exp=None):
1028         tex = r"\left(%s\right)" % self._print(expr.args[0])
1029 
1030         if exp is not None:
1031             return r"S^{%s}%s" % (exp, tex)
1032         else:
1033             return r"S%s" % tex
1034 
1035     def _print_fresnelc(self, expr, exp=None):
1036         tex = r"\left(%s\right)" % self._print(expr.args[0])
1037 
1038         if exp is not None:
1039             return r"C^{%s}%s" % (exp, tex)
1040         else:
1041             return r"C%s" % tex
1042 
1043     def _print_subfactorial(self, expr, exp=None):
1044         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1045 
1046         if exp is not None:
1047             return r"%s^{%s}" % (tex, exp)
1048         else:
1049             return tex
1050 
1051     def _print_factorial(self, expr, exp=None):
1052         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1053 
1054         if exp is not None:
1055             return r"%s^{%s}" % (tex, exp)
1056         else:
1057             return tex
1058 
1059     def _print_factorial2(self, expr, exp=None):
1060         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1061 
1062         if exp is not None:
1063             return r"%s^{%s}" % (tex, exp)
1064         else:
1065             return tex
1066 
1067     def _print_binomial(self, expr, exp=None):
1068         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1069                                      self._print(expr.args[1]))
1070 
1071         if exp is not None:
1072             return r"%s^{%s}" % (tex, exp)
1073         else:
1074             return tex
1075 
1076     def _print_RisingFactorial(self, expr, exp=None):
1077         n, k = expr.args
1078         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1079 
1080         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1081 
1082         return self._do_exponent(tex, exp)
1083 
1084     def _print_FallingFactorial(self, expr, exp=None):
1085         n, k = expr.args
1086         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1087 
1088         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1089 
1090         return self._do_exponent(tex, exp)
1091 
1092     def _hprint_BesselBase(self, expr, exp, sym):
1093         tex = r"%s" % (sym)
1094 
1095         need_exp = False
1096         if exp is not None:
1097             if tex.find('^') == -1:
1098                 tex = r"%s^{%s}" % (tex, self._print(exp))
1099             else:
1100                 need_exp = True
1101 
1102         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1103                                            self._print(expr.argument))
1104 
1105         if need_exp:
1106             tex = self._do_exponent(tex, exp)
1107         return tex
1108 
1109     def _hprint_vec(self, vec):
1110         if len(vec) == 0:
1111             return ""
1112         s = ""
1113         for i in vec[:-1]:
1114             s += "%s, " % self._print(i)
1115         s += self._print(vec[-1])
1116         return s
1117 
1118     def _print_besselj(self, expr, exp=None):
1119         return self._hprint_BesselBase(expr, exp, 'J')
1120 
1121     def _print_besseli(self, expr, exp=None):
1122         return self._hprint_BesselBase(expr, exp, 'I')
1123 
1124     def _print_besselk(self, expr, exp=None):
1125         return self._hprint_BesselBase(expr, exp, 'K')
1126 
1127     def _print_bessely(self, expr, exp=None):
1128         return self._hprint_BesselBase(expr, exp, 'Y')
1129 
1130     def _print_yn(self, expr, exp=None):
1131         return self._hprint_BesselBase(expr, exp, 'y')
1132 
1133     def _print_jn(self, expr, exp=None):
1134         return self._hprint_BesselBase(expr, exp, 'j')
1135 
1136     def _print_hankel1(self, expr, exp=None):
1137         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1138 
1139     def _print_hankel2(self, expr, exp=None):
1140         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1141 
1142     def _print_hn1(self, expr, exp=None):
1143         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1144 
1145     def _print_hn2(self, expr, exp=None):
1146         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1147 
1148     def _hprint_airy(self, expr, exp=None, notation=""):
1149         tex = r"\left(%s\right)" % self._print(expr.args[0])
1150 
1151         if exp is not None:
1152             return r"%s^{%s}%s" % (notation, exp, tex)
1153         else:
1154             return r"%s%s" % (notation, tex)
1155 
1156     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1157         tex = r"\left(%s\right)" % self._print(expr.args[0])
1158 
1159         if exp is not None:
1160             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1161         else:
1162             return r"%s^\prime%s" % (notation, tex)
1163 
1164     def _print_airyai(self, expr, exp=None):
1165         return self._hprint_airy(expr, exp, 'Ai')
1166 
1167     def _print_airybi(self, expr, exp=None):
1168         return self._hprint_airy(expr, exp, 'Bi')
1169 
1170     def _print_airyaiprime(self, expr, exp=None):
1171         return self._hprint_airy_prime(expr, exp, 'Ai')
1172 
1173     def _print_airybiprime(self, expr, exp=None):
1174         return self._hprint_airy_prime(expr, exp, 'Bi')
1175 
1176     def _print_hyper(self, expr, exp=None):
1177         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1178               r"\middle| {%s} \right)}" % \
1179             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1180               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1181               self._print(expr.argument))
1182 
1183         if exp is not None:
1184             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1185         return tex
1186 
1187     def _print_meijerg(self, expr, exp=None):
1188         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1189               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1190             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1191               self._print(len(expr.bm)), self._print(len(expr.an)),
1192               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1193               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1194               self._print(expr.argument))
1195 
1196         if exp is not None:
1197             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1198         return tex
1199 
1200     def _print_dirichlet_eta(self, expr, exp=None):
1201         tex = r"\left(%s\right)" % self._print(expr.args[0])
1202         if exp is not None:
1203             return r"\eta^{%s}%s" % (self._print(exp), tex)
1204         return r"\eta%s" % tex
1205 
1206     def _print_zeta(self, expr, exp=None):
1207         if len(expr.args) == 2:
1208             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1209         else:
1210             tex = r"\left(%s\right)" % self._print(expr.args[0])
1211         if exp is not None:
1212             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1213         return r"\zeta%s" % tex
1214 
1215     def _print_lerchphi(self, expr, exp=None):
1216         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1217         if exp is None:
1218             return r"\Phi%s" % tex
1219         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1220 
1221     def _print_polylog(self, expr, exp=None):
1222         s, z = map(self._print, expr.args)
1223         tex = r"\left(%s\right)" % z
1224         if exp is None:
1225             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1226         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1227 
1228     def _print_jacobi(self, expr, exp=None):
1229         n, a, b, x = map(self._print, expr.args)
1230         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1231         if exp is not None:
1232             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1233         return tex
1234 
1235     def _print_gegenbauer(self, expr, exp=None):
1236         n, a, x = map(self._print, expr.args)
1237         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1238         if exp is not None:
1239             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1240         return tex
1241 
1242     def _print_chebyshevt(self, expr, exp=None):
1243         n, x = map(self._print, expr.args)
1244         tex = r"T_{%s}\left(%s\right)" % (n, x)
1245         if exp is not None:
1246             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1247         return tex
1248 
1249     def _print_chebyshevu(self, expr, exp=None):
1250         n, x = map(self._print, expr.args)
1251         tex = r"U_{%s}\left(%s\right)" % (n, x)
1252         if exp is not None:
1253             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1254         return tex
1255 
1256     def _print_legendre(self, expr, exp=None):
1257         n, x = map(self._print, expr.args)
1258         tex = r"P_{%s}\left(%s\right)" % (n, x)
1259         if exp is not None:
1260             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1261         return tex
1262 
1263     def _print_assoc_legendre(self, expr, exp=None):
1264         n, a, x = map(self._print, expr.args)
1265         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1266         if exp is not None:
1267             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1268         return tex
1269 
1270     def _print_hermite(self, expr, exp=None):
1271         n, x = map(self._print, expr.args)
1272         tex = r"H_{%s}\left(%s\right)" % (n, x)
1273         if exp is not None:
1274             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1275         return tex
1276 
1277     def _print_laguerre(self, expr, exp=None):
1278         n, x = map(self._print, expr.args)
1279         tex = r"L_{%s}\left(%s\right)" % (n, x)
1280         if exp is not None:
1281             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1282         return tex
1283 
1284     def _print_assoc_laguerre(self, expr, exp=None):
1285         n, a, x = map(self._print, expr.args)
1286         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1287         if exp is not None:
1288             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1289         return tex
1290 
1291     def _print_Ynm(self, expr, exp=None):
1292         n, m, theta, phi = map(self._print, expr.args)
1293         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1294         if exp is not None:
1295             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1296         return tex
1297 
1298     def _print_Znm(self, expr, exp=None):
1299         n, m, theta, phi = map(self._print, expr.args)
1300         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1301         if exp is not None:
1302             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1303         return tex
1304 
1305     def _print_Rational(self, expr):
1306         if expr.q != 1:
1307             sign = ""
1308             p = expr.p
1309             if expr.p < 0:
1310                 sign = "- "
1311                 p = -p
1312             if self._settings['fold_short_frac']:
1313                 return r"%s%d / %d" % (sign, p, expr.q)
1314             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1315         else:
1316             return self._print(expr.p)
1317 
1318     def _print_Order(self, expr):
1319         s = self._print(expr.expr)
1320         if expr.point and any(p != S.Zero for p in expr.point) or \
1321            len(expr.variables) > 1:
1322             s += '; '
1323             if len(expr.variables) > 1:
1324                 s += self._print(expr.variables)
1325             elif len(expr.variables):
1326                 s += self._print(expr.variables[0])
1327             s += r'\rightarrow '
1328             if len(expr.point) > 1:
1329                 s += self._print(expr.point)
1330             else:
1331                 s += self._print(expr.point[0])
1332         return r"\mathcal{O}\left(%s\right)" % s
1333 
1334     def _print_Symbol(self, expr):
1335         if expr in self._settings['symbol_names']:
1336             return self._settings['symbol_names'][expr]
1337 
1338         return self._deal_with_super_sub(expr.name) if \
1339             '\\' not in expr.name else expr.name
1340 
1341     _print_RandomSymbol = _print_Symbol
1342     _print_MatrixSymbol = _print_Symbol
1343 
1344     def _deal_with_super_sub(self, string):
1345         if '{' in string:
1346             return string
1347 
1348         name, supers, subs = split_super_sub(string)
1349 
1350         name = translate(name)
1351         supers = [translate(sup) for sup in supers]
1352         subs = [translate(sub) for sub in subs]
1353 
1354         # glue all items together:
1355         if len(supers) > 0:
1356             name += "^{%s}" % " ".join(supers)
1357         if len(subs) > 0:
1358             name += "_{%s}" % " ".join(subs)
1359 
1360         return name
1361 
1362     def _print_Relational(self, expr):
1363         if self._settings['itex']:
1364             gt = r"\gt"
1365             lt = r"\lt"
1366         else:
1367             gt = ">"
1368             lt = "<"
1369 
1370         charmap = {
1371             "==": "=",
1372             ">": gt,
1373             "<": lt,
1374             ">=": r"\geq",
1375             "<=": r"\leq",
1376             "!=": r"\neq",
1377         }
1378 
1379         return "%s %s %s" % (self._print(expr.lhs),
1380             charmap[expr.rel_op], self._print(expr.rhs))
1381 
1382     def _print_Piecewise(self, expr):
1383         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1384                    for e, c in expr.args[:-1]]
1385         if expr.args[-1].cond == true:
1386             ecpairs.append(r"%s & \text{otherwise}" %
1387                            self._print(expr.args[-1].expr))
1388         else:
1389             ecpairs.append(r"%s & \text{for}\: %s" %
1390                            (self._print(expr.args[-1].expr),
1391                             self._print(expr.args[-1].cond)))
1392         tex = r"\begin{cases} %s \end{cases}"
1393         return tex % r" \\".join(ecpairs)
1394 
1395     def _print_MatrixBase(self, expr):
1396         lines = []
1397 
1398         for line in range(expr.rows):  # horrible, should be 'rows'
1399             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1400 
1401         mat_str = self._settings['mat_str']
1402         if mat_str is None:
1403             if self._settings['mode'] == 'inline':
1404                 mat_str = 'smallmatrix'
1405             else:
1406                 if (expr.cols <= 10) is True:
1407                     mat_str = 'matrix'
1408                 else:
1409                     mat_str = 'array'
1410 
1411         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1412         out_str = out_str.replace('%MATSTR%', mat_str)
1413         if mat_str == 'array':
1414             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1415         if self._settings['mat_delim']:
1416             left_delim = self._settings['mat_delim']
1417             right_delim = self._delim_dict[left_delim]
1418             out_str = r'\left' + left_delim + out_str + \
1419                       r'\right' + right_delim
1420         return out_str % r"\\".join(lines)
1421     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1422                            = _print_Matrix \
1423                            = _print_MatrixBase
1424 
1425     def _print_MatrixElement(self, expr):
1426         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1427             + '_{%s, %s}' % (expr.i, expr.j)
1428 
1429     def _print_MatrixSlice(self, expr):
1430         def latexslice(x):
1431             x = list(x)
1432             if x[2] == 1:
1433                 del x[2]
1434             if x[1] == x[0] + 1:
1435                 del x[1]
1436             if x[0] == 0:
1437                 x[0] = ''
1438             return ':'.join(map(self._print, x))
1439         return (self._print(expr.parent) + r'\left[' +
1440                 latexslice(expr.rowslice) + ', ' +
1441                 latexslice(expr.colslice) + r'\right]')
1442 
1443     def _print_BlockMatrix(self, expr):
1444         return self._print(expr.blocks)
1445 
1446     def _print_Transpose(self, expr):
1447         mat = expr.arg
1448         from sympy.matrices import MatrixSymbol
1449         if not isinstance(mat, MatrixSymbol):
1450             return r"\left(%s\right)^T" % self._print(mat)
1451         else:
1452             return "%s^T" % self._print(mat)
1453 
1454     def _print_Adjoint(self, expr):
1455         mat = expr.arg
1456         from sympy.matrices import MatrixSymbol
1457         if not isinstance(mat, MatrixSymbol):
1458             return r"\left(%s\right)^\dagger" % self._print(mat)
1459         else:
1460             return r"%s^\dagger" % self._print(mat)
1461 
1462     def _print_MatAdd(self, expr):
1463         terms = list(expr.args)
1464         tex = " + ".join(map(self._print, terms))
1465         return tex
1466 
1467     def _print_MatMul(self, expr):
1468         from sympy import Add, MatAdd, HadamardProduct
1469 
1470         def parens(x):
1471             if isinstance(x, (Add, MatAdd, HadamardProduct)):
1472                 return r"\left(%s\right)" % self._print(x)
1473             return self._print(x)
1474         return ' '.join(map(parens, expr.args))
1475 
1476     def _print_Mod(self, expr, exp=None):
1477         if exp is not None:
1478             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1479                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1480         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1481                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1482 
1483     def _print_HadamardProduct(self, expr):
1484         from sympy import Add, MatAdd, MatMul
1485 
1486         def parens(x):
1487             if isinstance(x, (Add, MatAdd, MatMul)):
1488                 return r"\left(%s\right)" % self._print(x)
1489             return self._print(x)
1490         return r' \circ '.join(map(parens, expr.args))
1491 
1492     def _print_MatPow(self, expr):
1493         base, exp = expr.base, expr.exp
1494         from sympy.matrices import MatrixSymbol
1495         if not isinstance(base, MatrixSymbol):
1496             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1497         else:
1498             return "%s^{%s}" % (self._print(base), self._print(exp))
1499 
1500     def _print_ZeroMatrix(self, Z):
1501         return r"\mathbb{0}"
1502 
1503     def _print_Identity(self, I):
1504         return r"\mathbb{I}"
1505 
1506     def _print_NDimArray(self, expr):
1507 
1508         if expr.rank() == 0:
1509             return self._print(expr[()])
1510 
1511         mat_str = self._settings['mat_str']
1512         if mat_str is None:
1513             if self._settings['mode'] == 'inline':
1514                 mat_str = 'smallmatrix'
1515             else:
1516                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1517                     mat_str = 'matrix'
1518                 else:
1519                     mat_str = 'array'
1520         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1521         block_str = block_str.replace('%MATSTR%', mat_str)
1522         if self._settings['mat_delim']:
1523             left_delim = self._settings['mat_delim']
1524             right_delim = self._delim_dict[left_delim]
1525             block_str = r'\left' + left_delim + block_str + \
1526                       r'\right' + right_delim
1527 
1528         if expr.rank() == 0:
1529             return block_str % ""
1530 
1531         level_str = [[]] + [[] for i in range(expr.rank())]
1532         shape_ranges = [list(range(i)) for i in expr.shape]
1533         for outer_i in itertools.product(*shape_ranges):
1534             level_str[-1].append(self._print(expr[outer_i]))
1535             even = True
1536             for back_outer_i in range(expr.rank()-1, -1, -1):
1537                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1538                     break
1539                 if even:
1540                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1541                 else:
1542                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1543                     if len(level_str[back_outer_i+1]) == 1:
1544                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1545                 even = not even
1546                 level_str[back_outer_i+1] = []
1547 
1548         out_str = level_str[0][0]
1549 
1550         if expr.rank() % 2 == 1:
1551             out_str = block_str % out_str
1552 
1553         return out_str
1554 
1555     _print_ImmutableDenseNDimArray = _print_NDimArray
1556     _print_ImmutableSparseNDimArray = _print_NDimArray
1557     _print_MutableDenseNDimArray = _print_NDimArray
1558     _print_MutableSparseNDimArray = _print_NDimArray
1559 
1560     def _print_tuple(self, expr):
1561         return r"\left ( %s\right )" % \
1562             r", \quad ".join([ self._print(i) for i in expr ])
1563 
1564     def _print_TensorProduct(self, expr):
1565         elements = [self._print(a) for a in expr.args]
1566         return r' \otimes '.join(elements)
1567 
1568     def _print_WedgeProduct(self, expr):
1569         elements = [self._print(a) for a in expr.args]
1570         return r' \wedge '.join(elements)
1571 
1572     def _print_Tuple(self, expr):
1573         return self._print_tuple(expr)
1574 
1575     def _print_list(self, expr):
1576         return r"\left [ %s\right ]" % \
1577             r", \quad ".join([ self._print(i) for i in expr ])
1578 
1579     def _print_dict(self, d):
1580         keys = sorted(d.keys(), key=default_sort_key)
1581         items = []
1582 
1583         for key in keys:
1584             val = d[key]
1585             items.append("%s : %s" % (self._print(key), self._print(val)))
1586 
1587         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1588 
1589     def _print_Dict(self, expr):
1590         return self._print_dict(expr)
1591 
1592     def _print_DiracDelta(self, expr, exp=None):
1593         if len(expr.args) == 1 or expr.args[1] == 0:
1594             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1595         else:
1596             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1597                 self._print(expr.args[1]), self._print(expr.args[0]))
1598         if exp:
1599             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1600         return tex
1601 
1602     def _print_SingularityFunction(self, expr):
1603         shift = self._print(expr.args[0] - expr.args[1])
1604         power = self._print(expr.args[2])
1605         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1606         return tex
1607 
1608     def _print_Heaviside(self, expr, exp=None):
1609         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1610         if exp:
1611             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1612         return tex
1613 
1614     def _print_KroneckerDelta(self, expr, exp=None):
1615         i = self._print(expr.args[0])
1616         j = self._print(expr.args[1])
1617         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1618             tex = r'\delta_{%s %s}' % (i, j)
1619         else:
1620             tex = r'\delta_{%s, %s}' % (i, j)
1621         if exp:
1622             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1623         return tex
1624 
1625     def _print_LeviCivita(self, expr, exp=None):
1626         indices = map(self._print, expr.args)
1627         if all(x.is_Atom for x in expr.args):
1628             tex = r'\varepsilon_{%s}' % " ".join(indices)
1629         else:
1630             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1631         if exp:
1632             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1633         return tex
1634 
1635     def _print_ProductSet(self, p):
1636         if len(p.sets) > 1 and not has_variety(p.sets):
1637             return self._print(p.sets[0]) + "^%d" % len(p.sets)
1638         else:
1639             return r" \times ".join(self._print(set) for set in p.sets)
1640 
1641     def _print_RandomDomain(self, d):
1642         if hasattr(d, 'as_boolean'):
1643             return 'Domain: ' + self._print(d.as_boolean())
1644         elif hasattr(d, 'set'):
1645             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1646                     self._print(d.set))
1647         elif hasattr(d, 'symbols'):
1648             return 'Domain on ' + self._print(d.symbols)
1649         else:
1650             return self._print(None)
1651 
1652     def _print_FiniteSet(self, s):
1653         items = sorted(s.args, key=default_sort_key)
1654         return self._print_set(items)
1655 
1656     def _print_set(self, s):
1657         items = sorted(s, key=default_sort_key)
1658         items = ", ".join(map(self._print, items))
1659         return r"\left\{%s\right\}" % items
1660 
1661     _print_frozenset = _print_set
1662 
1663     def _print_Range(self, s):
1664         dots = r'\ldots'
1665 
1666         if s.start.is_infinite:
1667             printset = s.start, dots, s[-1] - s.step, s[-1]
1668         elif s.stop.is_infinite or len(s) > 4:
1669             it = iter(s)
1670             printset = next(it), next(it), dots, s[-1]
1671         else:
1672             printset = tuple(s)
1673 
1674         return (r"\left\{"
1675               + r", ".join(self._print(el) for el in printset)
1676               + r"\right\}")
1677 
1678     def _print_SeqFormula(self, s):
1679         if s.start is S.NegativeInfinity:
1680             stop = s.stop
1681             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1682                 s.coeff(stop - 1), s.coeff(stop))
1683         elif s.stop is S.Infinity or s.length > 4:
1684             printset = s[:4]
1685             printset.append(r'\ldots')
1686         else:
1687             printset = tuple(s)
1688 
1689         return (r"\left["
1690               + r", ".join(self._print(el) for el in printset)
1691               + r"\right]")
1692 
1693     _print_SeqPer = _print_SeqFormula
1694     _print_SeqAdd = _print_SeqFormula
1695     _print_SeqMul = _print_SeqFormula
1696 
1697     def _print_Interval(self, i):
1698         if i.start == i.end:
1699             return r"\left\{%s\right\}" % self._print(i.start)
1700 
1701         else:
1702             if i.left_open:
1703                 left = '('
1704             else:
1705                 left = '['
1706 
1707             if i.right_open:
1708                 right = ')'
1709             else:
1710                 right = ']'
1711 
1712             return r"\left%s%s, %s\right%s" % \
1713                    (left, self._print(i.start), self._print(i.end), right)
1714 
1715     def _print_AccumulationBounds(self, i):
1716         return r"\langle %s, %s\rangle" % \
1717                 (self._print(i.min), self._print(i.max))
1718 
1719     def _print_Union(self, u):
1720         return r" \cup ".join([self._print(i) for i in u.args])
1721 
1722     def _print_Complement(self, u):
1723         return r" \setminus ".join([self._print(i) for i in u.args])
1724 
1725     def _print_Intersection(self, u):
1726         return r" \cap ".join([self._print(i) for i in u.args])
1727 
1728     def _print_SymmetricDifference(self, u):
1729         return r" \triangle ".join([self._print(i) for i in u.args])
1730 
1731     def _print_EmptySet(self, e):
1732         return r"\emptyset"
1733 
1734     def _print_Naturals(self, n):
1735         return r"\mathbb{N}"
1736 
1737     def _print_Naturals0(self, n):
1738         return r"\mathbb{N}_0"
1739 
1740     def _print_Integers(self, i):
1741         return r"\mathbb{Z}"
1742 
1743     def _print_Reals(self, i):
1744         return r"\mathbb{R}"
1745 
1746     def _print_Complexes(self, i):
1747         return r"\mathbb{C}"
1748 
1749     def _print_ImageSet(self, s):
1750         sets = s.args[1:]
1751         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1752             for var, setv in zip(s.lamda.variables, sets)]
1753         return r"\left\{%s\; |\; %s\right\}" % (
1754             self._print(s.lamda.expr),
1755             ', '.join(varsets))
1756 
1757     def _print_ConditionSet(self, s):
1758         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1759         return r"\left\{%s\; |\; %s \in %s \wedge %s \right\}" % (
1760             vars_print,
1761             vars_print,
1762             self._print(s.base_set),
1763             self._print(s.condition.as_expr()))
1764 
1765     def _print_ComplexRegion(self, s):
1766         vars_print = ', '.join([self._print(var) for var in s.variables])
1767         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1768             self._print(s.expr),
1769             vars_print,
1770             self._print(s.sets))
1771 
1772     def _print_Contains(self, e):
1773         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1774 
1775     def _print_FourierSeries(self, s):
1776         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1777 
1778     def _print_FormalPowerSeries(self, s):
1779         return self._print_Add(s.infinite)
1780 
1781     def _print_FiniteField(self, expr):
1782         return r"\mathbb{F}_{%s}" % expr.mod
1783 
1784     def _print_IntegerRing(self, expr):
1785         return r"\mathbb{Z}"
1786 
1787     def _print_RationalField(self, expr):
1788         return r"\mathbb{Q}"
1789 
1790     def _print_RealField(self, expr):
1791         return r"\mathbb{R}"
1792 
1793     def _print_ComplexField(self, expr):
1794         return r"\mathbb{C}"
1795 
1796     def _print_PolynomialRing(self, expr):
1797         domain = self._print(expr.domain)
1798         symbols = ", ".join(map(self._print, expr.symbols))
1799         return r"%s\left[%s\right]" % (domain, symbols)
1800 
1801     def _print_FractionField(self, expr):
1802         domain = self._print(expr.domain)
1803         symbols = ", ".join(map(self._print, expr.symbols))
1804         return r"%s\left(%s\right)" % (domain, symbols)
1805 
1806     def _print_PolynomialRingBase(self, expr):
1807         domain = self._print(expr.domain)
1808         symbols = ", ".join(map(self._print, expr.symbols))
1809         inv = ""
1810         if not expr.is_Poly:
1811             inv = r"S_<^{-1}"
1812         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1813 
1814     def _print_Poly(self, poly):
1815         cls = poly.__class__.__name__
1816         expr = self._print(poly.as_expr())
1817         gens = list(map(self._print, poly.gens))
1818         domain = "domain=%s" % self._print(poly.get_domain())
1819 
1820         args = ", ".join([expr] + gens + [domain])
1821         if cls in accepted_latex_functions:
1822             tex = r"\%s {\left (%s \right )}" % (cls, args)
1823         else:
1824             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1825 
1826         return tex
1827 
1828     def _print_ComplexRootOf(self, root):
1829         cls = root.__class__.__name__
1830         if cls == "ComplexRootOf":
1831             cls = "CRootOf"
1832         expr = self._print(root.expr)
1833         index = root.index
1834         if cls in accepted_latex_functions:
1835             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1836         else:
1837             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1838 
1839     def _print_RootSum(self, expr):
1840         cls = expr.__class__.__name__
1841         args = [self._print(expr.expr)]
1842 
1843         if expr.fun is not S.IdentityFunction:
1844             args.append(self._print(expr.fun))
1845 
1846         if cls in accepted_latex_functions:
1847             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1848         else:
1849             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1850 
1851     def _print_PolyElement(self, poly):
1852         mul_symbol = self._settings['mul_symbol_latex']
1853         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1854 
1855     def _print_FracElement(self, frac):
1856         if frac.denom == 1:
1857             return self._print(frac.numer)
1858         else:
1859             numer = self._print(frac.numer)
1860             denom = self._print(frac.denom)
1861             return r"\frac{%s}{%s}" % (numer, denom)
1862 
1863     def _print_euler(self, expr, exp=None):
1864         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
1865         tex = r"E_{%s}" % self._print(m)
1866         if exp is not None:
1867             tex = r"%s^{%s}" % (tex, self._print(exp))
1868         if x is not None:
1869             tex = r"%s\left(%s\right)" % (tex, self._print(x))
1870         return tex
1871 
1872     def _print_catalan(self, expr, exp=None):
1873         tex = r"C_{%s}" % self._print(expr.args[0])
1874         if exp is not None:
1875             tex = r"%s^{%s}" % (tex, self._print(exp))
1876         return tex
1877 
1878     def _print_MellinTransform(self, expr):
1879         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1880 
1881     def _print_InverseMellinTransform(self, expr):
1882         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1883 
1884     def _print_LaplaceTransform(self, expr):
1885         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1886 
1887     def _print_InverseLaplaceTransform(self, expr):
1888         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1889 
1890     def _print_FourierTransform(self, expr):
1891         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1892 
1893     def _print_InverseFourierTransform(self, expr):
1894         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1895 
1896     def _print_SineTransform(self, expr):
1897         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1898 
1899     def _print_InverseSineTransform(self, expr):
1900         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1901 
1902     def _print_CosineTransform(self, expr):
1903         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1904 
1905     def _print_InverseCosineTransform(self, expr):
1906         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1907 
1908     def _print_DMP(self, p):
1909         try:
1910             if p.ring is not None:
1911                 # TODO incorporate order
1912                 return self._print(p.ring.to_sympy(p))
1913         except SympifyError:
1914             pass
1915         return self._print(repr(p))
1916 
1917     def _print_DMF(self, p):
1918         return self._print_DMP(p)
1919 
1920     def _print_Object(self, object):
1921         return self._print(Symbol(object.name))
1922 
1923     def _print_Morphism(self, morphism):
1924         domain = self._print(morphism.domain)
1925         codomain = self._print(morphism.codomain)
1926         return "%s\\rightarrow %s" % (domain, codomain)
1927 
1928     def _print_NamedMorphism(self, morphism):
1929         pretty_name = self._print(Symbol(morphism.name))
1930         pretty_morphism = self._print_Morphism(morphism)
1931         return "%s:%s" % (pretty_name, pretty_morphism)
1932 
1933     def _print_IdentityMorphism(self, morphism):
1934         from sympy.categories import NamedMorphism
1935         return self._print_NamedMorphism(NamedMorphism(
1936             morphism.domain, morphism.codomain, "id"))
1937 
1938     def _print_CompositeMorphism(self, morphism):
1939         # All components of the morphism have names and it is thus
1940         # possible to build the name of the composite.
1941         component_names_list = [self._print(Symbol(component.name)) for
1942                                 component in morphism.components]
1943         component_names_list.reverse()
1944         component_names = "\\circ ".join(component_names_list) + ":"
1945 
1946         pretty_morphism = self._print_Morphism(morphism)
1947         return component_names + pretty_morphism
1948 
1949     def _print_Category(self, morphism):
1950         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
1951 
1952     def _print_Diagram(self, diagram):
1953         if not diagram.premises:
1954             # This is an empty diagram.
1955             return self._print(S.EmptySet)
1956 
1957         latex_result = self._print(diagram.premises)
1958         if diagram.conclusions:
1959             latex_result += "\\Longrightarrow %s" % \
1960                             self._print(diagram.conclusions)
1961 
1962         return latex_result
1963 
1964     def _print_DiagramGrid(self, grid):
1965         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
1966 
1967         for i in range(grid.height):
1968             for j in range(grid.width):
1969                 if grid[i, j]:
1970                     latex_result += latex(grid[i, j])
1971                 latex_result += " "
1972                 if j != grid.width - 1:
1973                     latex_result += "& "
1974 
1975             if i != grid.height - 1:
1976                 latex_result += "\\\\"
1977             latex_result += "\n"
1978 
1979         latex_result += "\\end{array}\n"
1980         return latex_result
1981 
1982     def _print_FreeModule(self, M):
1983         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
1984 
1985     def _print_FreeModuleElement(self, m):
1986         # Print as row vector for convenience, for now.
1987         return r"\left[ %s \right]" % ",".join(
1988             '{' + self._print(x) + '}' for x in m)
1989 
1990     def _print_SubModule(self, m):
1991         return r"\left< %s \right>" % ",".join(
1992             '{' + self._print(x) + '}' for x in m.gens)
1993 
1994     def _print_ModuleImplementedIdeal(self, m):
1995         return r"\left< %s \right>" % ",".join(
1996             '{' + self._print(x) + '}' for [x] in m._module.gens)
1997 
1998     def _print_Quaternion(self, expr):
1999         # TODO: This expression is potentially confusing,
2000         # shall we print it as `Quaternion( ... )`?
2001         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2002         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2003         return " + ".join(a)
2004 
2005     def _print_QuotientRing(self, R):
2006         # TODO nicer fractions for few generators...
2007         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2008 
2009     def _print_QuotientRingElement(self, x):
2010         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2011 
2012     def _print_QuotientModuleElement(self, m):
2013         return r"{%s} + {%s}" % (self._print(m.data),
2014                                  self._print(m.module.killed_module))
2015 
2016     def _print_QuotientModule(self, M):
2017         # TODO nicer fractions for few generators...
2018         return r"\frac{%s}{%s}" % (self._print(M.base),
2019                                    self._print(M.killed_module))
2020 
2021     def _print_MatrixHomomorphism(self, h):
2022         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2023             self._print(h.domain), self._print(h.codomain))
2024 
2025     def _print_BaseScalarField(self, field):
2026         string = field._coord_sys._names[field._index]
2027         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2028 
2029     def _print_BaseVectorField(self, field):
2030         string = field._coord_sys._names[field._index]
2031         return r'\partial_{%s}' % self._print(Symbol(string))
2032 
2033     def _print_Differential(self, diff):
2034         field = diff._form_field
2035         if hasattr(field, '_coord_sys'):
2036             string = field._coord_sys._names[field._index]
2037             return r'\mathrm{d}%s' % self._print(Symbol(string))
2038         else:
2039             return 'd(%s)' % self._print(field)
2040             string = self._print(field)
2041             return r'\mathrm{d}\left(%s\right)' % string
2042 
2043     def _print_Tr(self, p):
2044         #Todo: Handle indices
2045         contents = self._print(p.args[0])
2046         return r'\mbox{Tr}\left(%s\right)' % (contents)
2047 
2048     def _print_totient(self, expr, exp=None):
2049         if exp is not None:
2050             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2051                     self._print(exp))
2052         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2053 
2054     def _print_reduced_totient(self, expr, exp=None):
2055         if exp is not None:
2056             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2057                     self._print(exp))
2058         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2059 
2060     def _print_divisor_sigma(self, expr, exp=None):
2061         if len(expr.args) == 2:
2062             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2063                                                 (expr.args[1], expr.args[0])))
2064         else:
2065             tex = r"\left(%s\right)" % self._print(expr.args[0])
2066         if exp is not None:
2067             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2068         return r"\sigma%s" % tex
2069 
2070     def _print_udivisor_sigma(self, expr, exp=None):
2071         if len(expr.args) == 2:
2072             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2073                                                 (expr.args[1], expr.args[0])))
2074         else:
2075             tex = r"\left(%s\right)" % self._print(expr.args[0])
2076         if exp is not None:
2077             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2078         return r"\sigma^*%s" % tex
2079 
2080     def _print_primenu(self, expr, exp=None):
2081         if exp is not None:
2082             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2083                     self._print(exp))
2084         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2085 
2086     def _print_primeomega(self, expr, exp=None):
2087         if exp is not None:
2088             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2089                     self._print(exp))
2090         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 08:12:00.837 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Function</method>
<code>
708     def _print_Function(self, expr, exp=None):
709         r'''
710         Render functions to LaTeX, handling functions that LaTeX knows about
711         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
712         For single-letter function names, render them as regular LaTeX math
713         symbols. For multi-letter function names that LaTeX does not know
714         about, (e.g., Li, sech) use \operatorname{} so that the function name
715         is rendered in Roman font and LaTeX handles spacing properly.
716 
717         expr is the expression involving the function
718         exp is an exponent
719         '''
720         func = expr.func.__name__
721         if hasattr(self, '_print_' + func) and \
722             not isinstance(expr.func, UndefinedFunction):
723             return getattr(self, '_print_' + func)(expr, exp)
724         else:
725             args = [ str(self._print(arg)) for arg in expr.args ]
726             # How inverse trig functions should be displayed, formats are:
727             # abbreviated: asin, full: arcsin, power: sin^-1
728             inv_trig_style = self._settings['inv_trig_style']
729             # If we are dealing with a power-style inverse trig function
730             inv_trig_power_case = False
731             # If it is applicable to fold the argument brackets
732             can_fold_brackets = self._settings['fold_func_brackets'] and \
733                 len(args) == 1 and \
734                 not self._needs_function_brackets(expr.args[0])
735 
736             inv_trig_table = ["asin", "acos", "atan", "acot"]
737 
738             # If the function is an inverse trig function, handle the style
739             if func in inv_trig_table:
740                 if inv_trig_style == "abbreviated":
741                     func = func
742                 elif inv_trig_style == "full":
743                     func = "arc" + func[1:]
744                 elif inv_trig_style == "power":
745                     func = func[1:]
746                     inv_trig_power_case = True
747 
748                     # Can never fold brackets if we're raised to a power
749                     if exp is not None:
750                         can_fold_brackets = False
751 
752             if inv_trig_power_case:
753                 if func in accepted_latex_functions:
754                     name = r"\%s^{-1}" % func
755                 else:
756                     name = r"\operatorname{%s}^{-1}" % func
757             elif exp is not None:
758                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
759             else:
760                 name = self._hprint_Function(func)
761 
762             if can_fold_brackets:
763                 if func in accepted_latex_functions:
764                     # Wrap argument safely to avoid parse-time conflicts
765                     # with the function name itself
766                     name += r" {%s}"
767                 else:
768                     name += r"%s"
769             else:
770                 name += r"{\left (%s \right )}"
771 
772             if inv_trig_power_case and exp is not None:
773                 name += r"^{%s}" % exp
774 
775             return name % ",".join(args)

</code><intended_behavior>This method should include specific handling for the `ln` function to ensure that it is converted to `\ln` in the LaTeX representation, not as `log`. The modification should check if the function being printed is the natural logarithm `ln` and, if so, output the LaTeX code specifically as `\ln{...}` with the correct arguments enclosed. This handling should be added in a way that does not interfere with the rendering of other functions, thus preserving the existing functionality of the code for all other mathematical expressions.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": 2,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137     }
138 
139     def __init__(self, settings=None):
140         Printer.__init__(self, settings)
141 
142         if 'mode' in self._settings:
143             valid_modes = ['inline', 'plain', 'equation',
144                            'equation*']
145             if self._settings['mode'] not in valid_modes:
146                 raise ValueError("'mode' must be one of 'inline', 'plain', "
147                     "'equation' or 'equation*'")
148 
149         if self._settings['fold_short_frac'] is None and \
150                 self._settings['mode'] == 'inline':
151             self._settings['fold_short_frac'] = True
152 
153         mul_symbol_table = {
154             None: r" ",
155             "ldot": r" \,.\, ",
156             "dot": r" \cdot ",
157             "times": r" \times "
158         }
159         try:
160             self._settings['mul_symbol_latex'] = \
161                 mul_symbol_table[self._settings['mul_symbol']]
162         except KeyError:
163             self._settings['mul_symbol_latex'] = \
164                 self._settings['mul_symbol']
165         try:
166             self._settings['mul_symbol_latex_numbers'] = \
167                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
168         except KeyError:
169             if (self._settings['mul_symbol'].strip() in
170                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
171                 self._settings['mul_symbol_latex_numbers'] = \
172                     mul_symbol_table['dot']
173             else:
174                 self._settings['mul_symbol_latex_numbers'] = \
175                     self._settings['mul_symbol']
176 
177         self._delim_dict = {'(': ')', '[': ']'}
178 
179     def parenthesize(self, item, level, strict=False):
180         prec_val = precedence_traditional(item)
181         if (prec_val < level) or ((not strict) and prec_val <= level):
182             return r"\left(%s\right)" % self._print(item)
183         else:
184             return self._print(item)
185 
186     def doprint(self, expr):
187         tex = Printer.doprint(self, expr)
188 
189         if self._settings['mode'] == 'plain':
190             return tex
191         elif self._settings['mode'] == 'inline':
192             return r"$%s$" % tex
193         elif self._settings['itex']:
194             return r"$$%s$$" % tex
195         else:
196             env_str = self._settings['mode']
197             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
198 
199     def _needs_brackets(self, expr):
200         """
201         Returns True if the expression needs to be wrapped in brackets when
202         printed, False otherwise. For example: a + b => True; a => False;
203         10 => False; -10 => True.
204         """
205         return not ((expr.is_Integer and expr.is_nonnegative)
206                     or (expr.is_Atom and (expr is not S.NegativeOne
207                                           and expr.is_Rational is False)))
208 
209     def _needs_function_brackets(self, expr):
210         """
211         Returns True if the expression needs to be wrapped in brackets when
212         passed as an argument to a function, False otherwise. This is a more
213         liberal version of _needs_brackets, in that many expressions which need
214         to be wrapped in brackets when added/subtracted/raised to a power do
215         not need them when passed to a function. Such an example is a*b.
216         """
217         if not self._needs_brackets(expr):
218             return False
219         else:
220             # Muls of the form a*b*c... can be folded
221             if expr.is_Mul and not self._mul_is_clean(expr):
222                 return True
223             # Pows which don't need brackets can be folded
224             elif expr.is_Pow and not self._pow_is_clean(expr):
225                 return True
226             # Add and Function always need brackets
227             elif expr.is_Add or expr.is_Function:
228                 return True
229             else:
230                 return False
231 
232     def _needs_mul_brackets(self, expr, first=False, last=False):
233         """
234         Returns True if the expression needs to be wrapped in brackets when
235         printed as part of a Mul, False otherwise. This is True for Add,
236         but also for some container objects that would not need brackets
237         when appearing last in a Mul, e.g. an Integral. ``last=True``
238         specifies that this expr is the last to appear in a Mul.
239         ``first=True`` specifies that this expr is the first to appear in a Mul.
240         """
241         from sympy import Integral, Piecewise, Product, Sum
242 
243         if expr.is_Mul:
244             if not first and _coeff_isneg(expr):
245                 return True
246         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
247             return True
248         elif expr.is_Relational:
249             return True
250         if expr.is_Piecewise:
251             return True
252         if any([expr.has(x) for x in (Mod,)]):
253             return True
254         if (not last and
255             any([expr.has(x) for x in (Integral, Product, Sum)])):
256             return True
257 
258         return False
259 
260 
261     def _needs_add_brackets(self, expr):
262         """
263         Returns True if the expression needs to be wrapped in brackets when
264         printed as part of an Add, False otherwise.  This is False for most
265         things.
266         """
267         if expr.is_Relational:
268             return True
269         if any([expr.has(x) for x in (Mod,)]):
270             return True
271         if expr.is_Add:
272             return True
273         return False
274 
275 
276     def _mul_is_clean(self, expr):
277         for arg in expr.args:
278             if arg.is_Function:
279                 return False
280         return True
281 
282     def _pow_is_clean(self, expr):
283         return not self._needs_brackets(expr.base)
284 
285     def _do_exponent(self, expr, exp):
286         if exp is not None:
287             return r"\left(%s\right)^{%s}" % (expr, exp)
288         else:
289             return expr
290 
291     def _print_bool(self, e):
292         return r"\mathrm{%s}" % e
293 
294     _print_BooleanTrue = _print_bool
295     _print_BooleanFalse = _print_bool
296 
297     def _print_NoneType(self, e):
298         return r"\mathrm{%s}" % e
299 
300 
301     def _print_Add(self, expr, order=None):
302         if self.order == 'none':
303             terms = list(expr.args)
304         else:
305             terms = self._as_ordered_terms(expr, order=order)
306 
307         tex = ""
308         for i, term in enumerate(terms):
309             if i == 0:
310                 pass
311             elif _coeff_isneg(term):
312                 tex += " - "
313                 term = -term
314             else:
315                 tex += " + "
316             term_tex = self._print(term)
317             if self._needs_add_brackets(term):
318                 term_tex = r"\left(%s\right)" % term_tex
319             tex += term_tex
320 
321         return tex
322 
323     def _print_Cycle(self, expr):
324         from sympy.combinatorics.permutations import Permutation
325         if expr.size == 0:
326             return r"\left( \right)"
327         expr = Permutation(expr)
328         expr_perm = expr.cyclic_form
329         siz = expr.size
330         if expr.array_form[-1] == siz - 1:
331             expr_perm = expr_perm + [[siz - 1]]
332         term_tex = ''
333         for i in expr_perm:
334             term_tex += str(i).replace(',', r"\;")
335         term_tex = term_tex.replace('[', r"\left( ")
336         term_tex = term_tex.replace(']', r"\right)")
337         return term_tex
338 
339     _print_Permutation = _print_Cycle
340 
341     def _print_Float(self, expr):
342         # Based off of that in StrPrinter
343         dps = prec_to_dps(expr._prec)
344         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
345 
346         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
347         # thus we use the number separator
348         separator = self._settings['mul_symbol_latex_numbers']
349 
350         if 'e' in str_real:
351             (mant, exp) = str_real.split('e')
352 
353             if exp[0] == '+':
354                 exp = exp[1:]
355 
356             return r"%s%s10^{%s}" % (mant, separator, exp)
357         elif str_real == "+inf":
358             return r"\infty"
359         elif str_real == "-inf":
360             return r"- \infty"
361         else:
362             return str_real
363 
364     def _print_Cross(self, expr):
365         vec1 = expr._expr1
366         vec2 = expr._expr2
367         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
368                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
369 
370     def _print_Curl(self, expr):
371         vec = expr._expr
372         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
373 
374     def _print_Divergence(self, expr):
375         vec = expr._expr
376         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
377 
378     def _print_Dot(self, expr):
379         vec1 = expr._expr1
380         vec2 = expr._expr2
381         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
382                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
383 
384     def _print_Gradient(self, expr):
385         func = expr._expr
386         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
387 
388     def _print_Mul(self, expr):
389         from sympy.core.power import Pow
390         include_parens = False
391         if _coeff_isneg(expr):
392             expr = -expr
393             tex = "- "
394             if expr.is_Add:
395                 tex += "("
396                 include_parens = True
397         else:
398             tex = ""
399 
400         from sympy.simplify import fraction
401         numer, denom = fraction(expr, exact=True)
402         separator = self._settings['mul_symbol_latex']
403         numbersep = self._settings['mul_symbol_latex_numbers']
404 
405         def convert(expr):
406             if not expr.is_Mul:
407                 return str(self._print(expr))
408             else:
409                 _tex = last_term_tex = ""
410 
411                 if self.order not in ('old', 'none'):
412                     args = expr.as_ordered_factors()
413                 else:
414                     args = expr.args
415 
416                 for i, term in enumerate(args):
417                     term_tex = self._print(term)
418 
419                     if self._needs_mul_brackets(term, first=(i == 0),
420                                                 last=(i == len(args) - 1)):
421                         term_tex = r"\left(%s\right)" % term_tex
422 
423                     if _between_two_numbers_p[0].search(last_term_tex) and \
424                             _between_two_numbers_p[1].match(term_tex):
425                         # between two numbers
426                         _tex += numbersep
427                     elif _tex:
428                         _tex += separator
429 
430                     _tex += term_tex
431                     last_term_tex = term_tex
432                 return _tex
433 
434         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
435             # use the original expression here, since fraction() may have
436             # altered it when producing numer and denom
437             tex += convert(expr)
438 
439         else:
440             snumer = convert(numer)
441             sdenom = convert(denom)
442             ldenom = len(sdenom.split())
443             ratio = self._settings['long_frac_ratio']
444             if self._settings['fold_short_frac'] \
445                     and ldenom <= 2 and not "^" in sdenom:
446                 # handle short fractions
447                 if self._needs_mul_brackets(numer, last=False):
448                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
449                 else:
450                     tex += r"%s / %s" % (snumer, sdenom)
451             elif len(snumer.split()) > ratio*ldenom:
452                 # handle long fractions
453                 if self._needs_mul_brackets(numer, last=True):
454                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
455                         % (sdenom, separator, snumer)
456                 elif numer.is_Mul:
457                     # split a long numerator
458                     a = S.One
459                     b = S.One
460                     for x in numer.args:
461                         if self._needs_mul_brackets(x, last=False) or \
462                                 len(convert(a*x).split()) > ratio*ldenom or \
463                                 (b.is_commutative is x.is_commutative is False):
464                             b *= x
465                         else:
466                             a *= x
467                     if self._needs_mul_brackets(b, last=True):
468                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
469                             % (convert(a), sdenom, separator, convert(b))
470                     else:
471                         tex += r"\frac{%s}{%s}%s%s" \
472                             % (convert(a), sdenom, separator, convert(b))
473                 else:
474                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
475             else:
476                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
477 
478         if include_parens:
479             tex += ")"
480         return tex
481 
482     def _print_Pow(self, expr):
483         # Treat x**Rational(1,n) as special case
484         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
485             base = self._print(expr.base)
486             expq = expr.exp.q
487 
488             if expq == 2:
489                 tex = r"\sqrt{%s}" % base
490             elif self._settings['itex']:
491                 tex = r"\root{%d}{%s}" % (expq, base)
492             else:
493                 tex = r"\sqrt[%d]{%s}" % (expq, base)
494 
495             if expr.exp.is_negative:
496                 return r"\frac{1}{%s}" % tex
497             else:
498                 return tex
499         elif self._settings['fold_frac_powers'] \
500             and expr.exp.is_Rational \
501                 and expr.exp.q != 1:
502             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
503             #fixes issue #12886, adds parentheses before superscripts raised to powers
504             if '^' in base and expr.base.is_Symbol:
505                 base = r"\left(%s\right)" % base
506             if expr.base.is_Function:
507                 return self._print(expr.base, "%s/%s" % (p, q))
508             return r"%s^{%s/%s}" % (base, p, q)
509         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
510             # Things like 1/x
511             return self._print_Mul(expr)
512         else:
513             if expr.base.is_Function:
514                 return self._print(expr.base, self._print(expr.exp))
515             else:
516                 if expr.is_commutative and expr.exp == -1:
517                     #solves issue 4129
518                     #As Mul always simplify 1/x to x**-1
519                     #The objective is achieved with this hack
520                     #first we get the latex for -1 * expr,
521                     #which is a Mul expression
522                     tex = self._print(S.NegativeOne * expr).strip()
523                     #the result comes with a minus and a space, so we remove
524                     if tex[:1] == "-":
525                         return tex[1:].strip()
526                 tex = r"%s^{%s}"
527                 #fixes issue #12886, adds parentheses before superscripts raised to powers
528                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
529                 if '^' in base and expr.base.is_Symbol:
530                     base = r"\left(%s\right)" % base
531                 exp = self._print(expr.exp)
532 
533                 return tex % (base, exp)
534 
535     def _print_UnevaluatedExpr(self, expr):
536         return self._print(expr.args[0])
537 
538     def _print_Sum(self, expr):
539         if len(expr.limits) == 1:
540             tex = r"\sum_{%s=%s}^{%s} " % \
541                 tuple([ self._print(i) for i in expr.limits[0] ])
542         else:
543             def _format_ineq(l):
544                 return r"%s \leq %s \leq %s" % \
545                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
546 
547             tex = r"\sum_{\substack{%s}} " % \
548                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
549 
550         if isinstance(expr.function, Add):
551             tex += r"\left(%s\right)" % self._print(expr.function)
552         else:
553             tex += self._print(expr.function)
554 
555         return tex
556 
557     def _print_Product(self, expr):
558         if len(expr.limits) == 1:
559             tex = r"\prod_{%s=%s}^{%s} " % \
560                 tuple([ self._print(i) for i in expr.limits[0] ])
561         else:
562             def _format_ineq(l):
563                 return r"%s \leq %s \leq %s" % \
564                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
565 
566             tex = r"\prod_{\substack{%s}} " % \
567                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
568 
569         if isinstance(expr.function, Add):
570             tex += r"\left(%s\right)" % self._print(expr.function)
571         else:
572             tex += self._print(expr.function)
573 
574         return tex
575 
576     def _print_BasisDependent(self, expr):
577         from sympy.vector import Vector
578 
579         o1 = []
580         if expr == expr.zero:
581             return expr.zero._latex_form
582         if isinstance(expr, Vector):
583             items = expr.separate().items()
584         else:
585             items = [(0, expr)]
586 
587         for system, vect in items:
588             inneritems = list(vect.components.items())
589             inneritems.sort(key = lambda x:x[0].__str__())
590             for k, v in inneritems:
591                 if v == 1:
592                     o1.append(' + ' + k._latex_form)
593                 elif v == -1:
594                     o1.append(' - ' + k._latex_form)
595                 else:
596                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
597                     o1.append(' + ' + arg_str + k._latex_form)
598 
599         outstr = (''.join(o1))
600         if outstr[1] != '-':
601             outstr = outstr[3:]
602         else:
603             outstr = outstr[1:]
604         return outstr
605 
606     def _print_Indexed(self, expr):
607         tex = self._print(expr.base)+'_{%s}' % ','.join(
608             map(self._print, expr.indices))
609         return tex
610 
611     def _print_IndexedBase(self, expr):
612         return self._print(expr.label)
613 
614     def _print_Derivative(self, expr):
615         if requires_partial(expr):
616             diff_symbol = r'\partial'
617         else:
618             diff_symbol = r'd'
619 
620         tex = ""
621         dim = 0
622         for x, num in reversed(expr.variable_count):
623             dim += num
624             if num == 1:
625                 tex += r"%s %s" % (diff_symbol, self._print(x))
626             else:
627                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
628 
629         if dim == 1:
630             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
631         else:
632             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
633 
634         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
635 
636     def _print_Subs(self, subs):
637         expr, old, new = subs.args
638         latex_expr = self._print(expr)
639         latex_old = (self._print(e) for e in old)
640         latex_new = (self._print(e) for e in new)
641         latex_subs = r'\\ '.join(
642             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
643         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
644 
645     def _print_Integral(self, expr):
646         tex, symbols = "", []
647 
648         # Only up to \iiiint exists
649         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
650             # Use len(expr.limits)-1 so that syntax highlighters don't think
651             # \" is an escaped quote
652             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
653             symbols = [r"\, d%s" % self._print(symbol[0])
654                        for symbol in expr.limits]
655 
656         else:
657             for lim in reversed(expr.limits):
658                 symbol = lim[0]
659                 tex += r"\int"
660 
661                 if len(lim) > 1:
662                     if self._settings['mode'] in ['equation', 'equation*'] \
663                             and not self._settings['itex']:
664                         tex += r"\limits"
665 
666                     if len(lim) == 3:
667                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
668                                                self._print(lim[2]))
669                     if len(lim) == 2:
670                         tex += "^{%s}" % (self._print(lim[1]))
671 
672                 symbols.insert(0, r"\, d%s" % self._print(symbol))
673 
674         return r"%s %s%s" % (tex,
675             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
676 
677     def _print_Limit(self, expr):
678         e, z, z0, dir = expr.args
679 
680         tex = r"\lim_{%s \to " % self._print(z)
681         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
682             tex += r"%s}" % self._print(z0)
683         else:
684             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
685 
686         if isinstance(e, AssocOp):
687             return r"%s\left(%s\right)" % (tex, self._print(e))
688         else:
689             return r"%s %s" % (tex, self._print(e))
690 
691     def _hprint_Function(self, func):
692         r'''
693         Logic to decide how to render a function to latex
694           - if it is a recognized latex name, use the appropriate latex command
695           - if it is a single letter, just use that letter
696           - if it is a longer name, then put \operatorname{} around it and be
697             mindful of undercores in the name
698         '''
699         func = self._deal_with_super_sub(func)
700         if func in accepted_latex_functions:
701             name = r"\%s" % func
702         elif len(func) == 1 or func.startswith('\\'):
703             name = func
704         else:
705             name = r"\operatorname{%s}" % func
706         return name
707 
708     def _print_Function(self, expr, exp=None):
709         r'''
710         Render functions to LaTeX, handling functions that LaTeX knows about
711         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
712         For single-letter function names, render them as regular LaTeX math
713         symbols. For multi-letter function names that LaTeX does not know
714         about, (e.g., Li, sech) use \operatorname{} so that the function name
715         is rendered in Roman font and LaTeX handles spacing properly.
716 
717         expr is the expression involving the function
718         exp is an exponent
719         '''
720         func = expr.func.__name__
721         if hasattr(self, '_print_' + func) and \
722             not isinstance(expr.func, UndefinedFunction):
723             return getattr(self, '_print_' + func)(expr, exp)
724         else:
725             args = [ str(self._print(arg)) for arg in expr.args ]
726             # How inverse trig functions should be displayed, formats are:
727             # abbreviated: asin, full: arcsin, power: sin^-1
728             inv_trig_style = self._settings['inv_trig_style']
729             # If we are dealing with a power-style inverse trig function
730             inv_trig_power_case = False
731             # If it is applicable to fold the argument brackets
732             can_fold_brackets = self._settings['fold_func_brackets'] and \
733                 len(args) == 1 and \
734                 not self._needs_function_brackets(expr.args[0])
735 
736             inv_trig_table = ["asin", "acos", "atan", "acot"]
737 
738             # If the function is an inverse trig function, handle the style
739             if func in inv_trig_table:
740                 if inv_trig_style == "abbreviated":
741                     func = func
742                 elif inv_trig_style == "full":
743                     func = "arc" + func[1:]
744                 elif inv_trig_style == "power":
745                     func = func[1:]
746                     inv_trig_power_case = True
747 
748                     # Can never fold brackets if we're raised to a power
749                     if exp is not None:
750                         can_fold_brackets = False
751 
752             if inv_trig_power_case:
753                 if func in accepted_latex_functions:
754                     name = r"\%s^{-1}" % func
755                 else:
756                     name = r"\operatorname{%s}^{-1}" % func
757             elif exp is not None:
758                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
759             else:
760                 name = self._hprint_Function(func)
761 
762             if can_fold_brackets:
763                 if func in accepted_latex_functions:
764                     # Wrap argument safely to avoid parse-time conflicts
765                     # with the function name itself
766                     name += r" {%s}"
767                 else:
768                     name += r"%s"
769             else:
770                 name += r"{\left (%s \right )}"
771 
772             if inv_trig_power_case and exp is not None:
773                 name += r"^{%s}" % exp
774 
775             return name % ",".join(args)
776 
777     def _print_UndefinedFunction(self, expr):
778         return self._hprint_Function(str(expr))
779 
780     @property
781     def _special_function_classes(self):
782         from sympy.functions.special.tensor_functions import KroneckerDelta
783         from sympy.functions.special.gamma_functions import gamma, lowergamma
784         from sympy.functions.special.beta_functions import beta
785         from sympy.functions.special.delta_functions import DiracDelta
786         from sympy.functions.special.error_functions import Chi
787         return {KroneckerDelta: r'\delta',
788                 gamma:  r'\Gamma',
789                 lowergamma: r'\gamma',
790                 beta: r'\operatorname{B}',
791                 DiracDelta: r'\delta',
792                 Chi: r'\operatorname{Chi}'}
793 
794     def _print_FunctionClass(self, expr):
795         for cls in self._special_function_classes:
796             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
797                 return self._special_function_classes[cls]
798         return self._hprint_Function(str(expr))
799 
800     def _print_Lambda(self, expr):
801         symbols, expr = expr.args
802 
803         if len(symbols) == 1:
804             symbols = self._print(symbols[0])
805         else:
806             symbols = self._print(tuple(symbols))
807 
808         args = (symbols, self._print(expr))
809         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
810 
811         return tex
812 
813     def _print_Min(self, expr, exp=None):
814         args = sorted(expr.args, key=default_sort_key)
815         texargs = [r"%s" % self._print(symbol) for symbol in args]
816         tex = r"\min\left(%s\right)" % ", ".join(texargs)
817 
818         if exp is not None:
819             return r"%s^{%s}" % (tex, exp)
820         else:
821             return tex
822 
823     def _print_Max(self, expr, exp=None):
824         args = sorted(expr.args, key=default_sort_key)
825         texargs = [r"%s" % self._print(symbol) for symbol in args]
826         tex = r"\max\left(%s\right)" % ", ".join(texargs)
827 
828         if exp is not None:
829             return r"%s^{%s}" % (tex, exp)
830         else:
831             return tex
832 
833     def _print_floor(self, expr, exp=None):
834         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
835 
836         if exp is not None:
837             return r"%s^{%s}" % (tex, exp)
838         else:
839             return tex
840 
841     def _print_ceiling(self, expr, exp=None):
842         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
843 
844         if exp is not None:
845             return r"%s^{%s}" % (tex, exp)
846         else:
847             return tex
848 
849     def _print_Abs(self, expr, exp=None):
850         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
851 
852         if exp is not None:
853             return r"%s^{%s}" % (tex, exp)
854         else:
855             return tex
856     _print_Determinant = _print_Abs
857 
858     def _print_re(self, expr, exp=None):
859         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
860 
861         return self._do_exponent(tex, exp)
862 
863     def _print_im(self, expr, exp=None):
864         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
865 
866         return self._do_exponent(tex, exp)
867 
868     def _print_Not(self, e):
869         from sympy import Equivalent, Implies
870         if isinstance(e.args[0], Equivalent):
871             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
872         if isinstance(e.args[0], Implies):
873             return self._print_Implies(e.args[0], r"\not\Rightarrow")
874         if (e.args[0].is_Boolean):
875             return r"\neg (%s)" % self._print(e.args[0])
876         else:
877             return r"\neg %s" % self._print(e.args[0])
878 
879     def _print_LogOp(self, args, char):
880         arg = args[0]
881         if arg.is_Boolean and not arg.is_Not:
882             tex = r"\left(%s\right)" % self._print(arg)
883         else:
884             tex = r"%s" % self._print(arg)
885 
886         for arg in args[1:]:
887             if arg.is_Boolean and not arg.is_Not:
888                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
889             else:
890                 tex += r" %s %s" % (char, self._print(arg))
891 
892         return tex
893 
894     def _print_And(self, e):
895         args = sorted(e.args, key=default_sort_key)
896         return self._print_LogOp(args, r"\wedge")
897 
898     def _print_Or(self, e):
899         args = sorted(e.args, key=default_sort_key)
900         return self._print_LogOp(args, r"\vee")
901 
902     def _print_Xor(self, e):
903         args = sorted(e.args, key=default_sort_key)
904         return self._print_LogOp(args, r"\veebar")
905 
906     def _print_Implies(self, e, altchar=None):
907         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
908 
909     def _print_Equivalent(self, e, altchar=None):
910         args = sorted(e.args, key=default_sort_key)
911         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
912 
913     def _print_conjugate(self, expr, exp=None):
914         tex = r"\overline{%s}" % self._print(expr.args[0])
915 
916         if exp is not None:
917             return r"%s^{%s}" % (tex, exp)
918         else:
919             return tex
920 
921     def _print_polar_lift(self, expr, exp=None):
922         func = r"\operatorname{polar\_lift}"
923         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
924 
925         if exp is not None:
926             return r"%s^{%s}%s" % (func, exp, arg)
927         else:
928             return r"%s%s" % (func, arg)
929 
930     def _print_ExpBase(self, expr, exp=None):
931         # TODO should exp_polar be printed differently?
932         #      what about exp_polar(0), exp_polar(1)?
933         tex = r"e^{%s}" % self._print(expr.args[0])
934         return self._do_exponent(tex, exp)
935 
936     def _print_elliptic_k(self, expr, exp=None):
937         tex = r"\left(%s\right)" % self._print(expr.args[0])
938         if exp is not None:
939             return r"K^{%s}%s" % (exp, tex)
940         else:
941             return r"K%s" % tex
942 
943     def _print_elliptic_f(self, expr, exp=None):
944         tex = r"\left(%s\middle| %s\right)" % \
945             (self._print(expr.args[0]), self._print(expr.args[1]))
946         if exp is not None:
947             return r"F^{%s}%s" % (exp, tex)
948         else:
949             return r"F%s" % tex
950 
951     def _print_elliptic_e(self, expr, exp=None):
952         if len(expr.args) == 2:
953             tex = r"\left(%s\middle| %s\right)" % \
954                 (self._print(expr.args[0]), self._print(expr.args[1]))
955         else:
956             tex = r"\left(%s\right)" % self._print(expr.args[0])
957         if exp is not None:
958             return r"E^{%s}%s" % (exp, tex)
959         else:
960             return r"E%s" % tex
961 
962     def _print_elliptic_pi(self, expr, exp=None):
963         if len(expr.args) == 3:
964             tex = r"\left(%s; %s\middle| %s\right)" % \
965                 (self._print(expr.args[0]), self._print(expr.args[1]), \
966                  self._print(expr.args[2]))
967         else:
968             tex = r"\left(%s\middle| %s\right)" % \
969                 (self._print(expr.args[0]), self._print(expr.args[1]))
970         if exp is not None:
971             return r"\Pi^{%s}%s" % (exp, tex)
972         else:
973             return r"\Pi%s" % tex
974 
975     def _print_beta(self, expr, exp=None):
976         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
977                                         self._print(expr.args[1]))
978 
979         if exp is not None:
980             return r"\operatorname{B}^{%s}%s" % (exp, tex)
981         else:
982             return r"\operatorname{B}%s" % tex
983 
984     def _print_gamma(self, expr, exp=None):
985         tex = r"\left(%s\right)" % self._print(expr.args[0])
986 
987         if exp is not None:
988             return r"\Gamma^{%s}%s" % (exp, tex)
989         else:
990             return r"\Gamma%s" % tex
991 
992     def _print_uppergamma(self, expr, exp=None):
993         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
994                                         self._print(expr.args[1]))
995 
996         if exp is not None:
997             return r"\Gamma^{%s}%s" % (exp, tex)
998         else:
999             return r"\Gamma%s" % tex
1000 
1001     def _print_lowergamma(self, expr, exp=None):
1002         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1003                                         self._print(expr.args[1]))
1004 
1005         if exp is not None:
1006             return r"\gamma^{%s}%s" % (exp, tex)
1007         else:
1008             return r"\gamma%s" % tex
1009 
1010     def _print_Chi(self, expr, exp=None):
1011         tex = r"\left(%s\right)" % self._print(expr.args[0])
1012 
1013         if exp is not None:
1014             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1015         else:
1016             return r"\operatorname{Chi}%s" % tex
1017 
1018     def _print_expint(self, expr, exp=None):
1019         tex = r"\left(%s\right)" % self._print(expr.args[1])
1020         nu = self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1024         else:
1025             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1026 
1027     def _print_fresnels(self, expr, exp=None):
1028         tex = r"\left(%s\right)" % self._print(expr.args[0])
1029 
1030         if exp is not None:
1031             return r"S^{%s}%s" % (exp, tex)
1032         else:
1033             return r"S%s" % tex
1034 
1035     def _print_fresnelc(self, expr, exp=None):
1036         tex = r"\left(%s\right)" % self._print(expr.args[0])
1037 
1038         if exp is not None:
1039             return r"C^{%s}%s" % (exp, tex)
1040         else:
1041             return r"C%s" % tex
1042 
1043     def _print_subfactorial(self, expr, exp=None):
1044         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1045 
1046         if exp is not None:
1047             return r"%s^{%s}" % (tex, exp)
1048         else:
1049             return tex
1050 
1051     def _print_factorial(self, expr, exp=None):
1052         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1053 
1054         if exp is not None:
1055             return r"%s^{%s}" % (tex, exp)
1056         else:
1057             return tex
1058 
1059     def _print_factorial2(self, expr, exp=None):
1060         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1061 
1062         if exp is not None:
1063             return r"%s^{%s}" % (tex, exp)
1064         else:
1065             return tex
1066 
1067     def _print_binomial(self, expr, exp=None):
1068         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1069                                      self._print(expr.args[1]))
1070 
1071         if exp is not None:
1072             return r"%s^{%s}" % (tex, exp)
1073         else:
1074             return tex
1075 
1076     def _print_RisingFactorial(self, expr, exp=None):
1077         n, k = expr.args
1078         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1079 
1080         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1081 
1082         return self._do_exponent(tex, exp)
1083 
1084     def _print_FallingFactorial(self, expr, exp=None):
1085         n, k = expr.args
1086         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1087 
1088         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1089 
1090         return self._do_exponent(tex, exp)
1091 
1092     def _hprint_BesselBase(self, expr, exp, sym):
1093         tex = r"%s" % (sym)
1094 
1095         need_exp = False
1096         if exp is not None:
1097             if tex.find('^') == -1:
1098                 tex = r"%s^{%s}" % (tex, self._print(exp))
1099             else:
1100                 need_exp = True
1101 
1102         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1103                                            self._print(expr.argument))
1104 
1105         if need_exp:
1106             tex = self._do_exponent(tex, exp)
1107         return tex
1108 
1109     def _hprint_vec(self, vec):
1110         if len(vec) == 0:
1111             return ""
1112         s = ""
1113         for i in vec[:-1]:
1114             s += "%s, " % self._print(i)
1115         s += self._print(vec[-1])
1116         return s
1117 
1118     def _print_besselj(self, expr, exp=None):
1119         return self._hprint_BesselBase(expr, exp, 'J')
1120 
1121     def _print_besseli(self, expr, exp=None):
1122         return self._hprint_BesselBase(expr, exp, 'I')
1123 
1124     def _print_besselk(self, expr, exp=None):
1125         return self._hprint_BesselBase(expr, exp, 'K')
1126 
1127     def _print_bessely(self, expr, exp=None):
1128         return self._hprint_BesselBase(expr, exp, 'Y')
1129 
1130     def _print_yn(self, expr, exp=None):
1131         return self._hprint_BesselBase(expr, exp, 'y')
1132 
1133     def _print_jn(self, expr, exp=None):
1134         return self._hprint_BesselBase(expr, exp, 'j')
1135 
1136     def _print_hankel1(self, expr, exp=None):
1137         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1138 
1139     def _print_hankel2(self, expr, exp=None):
1140         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1141 
1142     def _print_hn1(self, expr, exp=None):
1143         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1144 
1145     def _print_hn2(self, expr, exp=None):
1146         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1147 
1148     def _hprint_airy(self, expr, exp=None, notation=""):
1149         tex = r"\left(%s\right)" % self._print(expr.args[0])
1150 
1151         if exp is not None:
1152             return r"%s^{%s}%s" % (notation, exp, tex)
1153         else:
1154             return r"%s%s" % (notation, tex)
1155 
1156     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1157         tex = r"\left(%s\right)" % self._print(expr.args[0])
1158 
1159         if exp is not None:
1160             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1161         else:
1162             return r"%s^\prime%s" % (notation, tex)
1163 
1164     def _print_airyai(self, expr, exp=None):
1165         return self._hprint_airy(expr, exp, 'Ai')
1166 
1167     def _print_airybi(self, expr, exp=None):
1168         return self._hprint_airy(expr, exp, 'Bi')
1169 
1170     def _print_airyaiprime(self, expr, exp=None):
1171         return self._hprint_airy_prime(expr, exp, 'Ai')
1172 
1173     def _print_airybiprime(self, expr, exp=None):
1174         return self._hprint_airy_prime(expr, exp, 'Bi')
1175 
1176     def _print_hyper(self, expr, exp=None):
1177         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1178               r"\middle| {%s} \right)}" % \
1179             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1180               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1181               self._print(expr.argument))
1182 
1183         if exp is not None:
1184             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1185         return tex
1186 
1187     def _print_meijerg(self, expr, exp=None):
1188         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1189               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1190             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1191               self._print(len(expr.bm)), self._print(len(expr.an)),
1192               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1193               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1194               self._print(expr.argument))
1195 
1196         if exp is not None:
1197             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1198         return tex
1199 
1200     def _print_dirichlet_eta(self, expr, exp=None):
1201         tex = r"\left(%s\right)" % self._print(expr.args[0])
1202         if exp is not None:
1203             return r"\eta^{%s}%s" % (self._print(exp), tex)
1204         return r"\eta%s" % tex
1205 
1206     def _print_zeta(self, expr, exp=None):
1207         if len(expr.args) == 2:
1208             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1209         else:
1210             tex = r"\left(%s\right)" % self._print(expr.args[0])
1211         if exp is not None:
1212             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1213         return r"\zeta%s" % tex
1214 
1215     def _print_lerchphi(self, expr, exp=None):
1216         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1217         if exp is None:
1218             return r"\Phi%s" % tex
1219         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1220 
1221     def _print_polylog(self, expr, exp=None):
1222         s, z = map(self._print, expr.args)
1223         tex = r"\left(%s\right)" % z
1224         if exp is None:
1225             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1226         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1227 
1228     def _print_jacobi(self, expr, exp=None):
1229         n, a, b, x = map(self._print, expr.args)
1230         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1231         if exp is not None:
1232             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1233         return tex
1234 
1235     def _print_gegenbauer(self, expr, exp=None):
1236         n, a, x = map(self._print, expr.args)
1237         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1238         if exp is not None:
1239             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1240         return tex
1241 
1242     def _print_chebyshevt(self, expr, exp=None):
1243         n, x = map(self._print, expr.args)
1244         tex = r"T_{%s}\left(%s\right)" % (n, x)
1245         if exp is not None:
1246             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1247         return tex
1248 
1249     def _print_chebyshevu(self, expr, exp=None):
1250         n, x = map(self._print, expr.args)
1251         tex = r"U_{%s}\left(%s\right)" % (n, x)
1252         if exp is not None:
1253             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1254         return tex
1255 
1256     def _print_legendre(self, expr, exp=None):
1257         n, x = map(self._print, expr.args)
1258         tex = r"P_{%s}\left(%s\right)" % (n, x)
1259         if exp is not None:
1260             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1261         return tex
1262 
1263     def _print_assoc_legendre(self, expr, exp=None):
1264         n, a, x = map(self._print, expr.args)
1265         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1266         if exp is not None:
1267             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1268         return tex
1269 
1270     def _print_hermite(self, expr, exp=None):
1271         n, x = map(self._print, expr.args)
1272         tex = r"H_{%s}\left(%s\right)" % (n, x)
1273         if exp is not None:
1274             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1275         return tex
1276 
1277     def _print_laguerre(self, expr, exp=None):
1278         n, x = map(self._print, expr.args)
1279         tex = r"L_{%s}\left(%s\right)" % (n, x)
1280         if exp is not None:
1281             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1282         return tex
1283 
1284     def _print_assoc_laguerre(self, expr, exp=None):
1285         n, a, x = map(self._print, expr.args)
1286         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1287         if exp is not None:
1288             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1289         return tex
1290 
1291     def _print_Ynm(self, expr, exp=None):
1292         n, m, theta, phi = map(self._print, expr.args)
1293         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1294         if exp is not None:
1295             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1296         return tex
1297 
1298     def _print_Znm(self, expr, exp=None):
1299         n, m, theta, phi = map(self._print, expr.args)
1300         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1301         if exp is not None:
1302             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1303         return tex
1304 
1305     def _print_Rational(self, expr):
1306         if expr.q != 1:
1307             sign = ""
1308             p = expr.p
1309             if expr.p < 0:
1310                 sign = "- "
1311                 p = -p
1312             if self._settings['fold_short_frac']:
1313                 return r"%s%d / %d" % (sign, p, expr.q)
1314             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1315         else:
1316             return self._print(expr.p)
1317 
1318     def _print_Order(self, expr):
1319         s = self._print(expr.expr)
1320         if expr.point and any(p != S.Zero for p in expr.point) or \
1321            len(expr.variables) > 1:
1322             s += '; '
1323             if len(expr.variables) > 1:
1324                 s += self._print(expr.variables)
1325             elif len(expr.variables):
1326                 s += self._print(expr.variables[0])
1327             s += r'\rightarrow '
1328             if len(expr.point) > 1:
1329                 s += self._print(expr.point)
1330             else:
1331                 s += self._print(expr.point[0])
1332         return r"\mathcal{O}\left(%s\right)" % s
1333 
1334     def _print_Symbol(self, expr):
1335         if expr in self._settings['symbol_names']:
1336             return self._settings['symbol_names'][expr]
1337 
1338         return self._deal_with_super_sub(expr.name) if \
1339             '\\' not in expr.name else expr.name
1340 
1341     _print_RandomSymbol = _print_Symbol
1342     _print_MatrixSymbol = _print_Symbol
1343 
1344     def _deal_with_super_sub(self, string):
1345         if '{' in string:
1346             return string
1347 
1348         name, supers, subs = split_super_sub(string)
1349 
1350         name = translate(name)
1351         supers = [translate(sup) for sup in supers]
1352         subs = [translate(sub) for sub in subs]
1353 
1354         # glue all items together:
1355         if len(supers) > 0:
1356             name += "^{%s}" % " ".join(supers)
1357         if len(subs) > 0:
1358             name += "_{%s}" % " ".join(subs)
1359 
1360         return name
1361 
1362     def _print_Relational(self, expr):
1363         if self._settings['itex']:
1364             gt = r"\gt"
1365             lt = r"\lt"
1366         else:
1367             gt = ">"
1368             lt = "<"
1369 
1370         charmap = {
1371             "==": "=",
1372             ">": gt,
1373             "<": lt,
1374             ">=": r"\geq",
1375             "<=": r"\leq",
1376             "!=": r"\neq",
1377         }
1378 
1379         return "%s %s %s" % (self._print(expr.lhs),
1380             charmap[expr.rel_op], self._print(expr.rhs))
1381 
1382     def _print_Piecewise(self, expr):
1383         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1384                    for e, c in expr.args[:-1]]
1385         if expr.args[-1].cond == true:
1386             ecpairs.append(r"%s & \text{otherwise}" %
1387                            self._print(expr.args[-1].expr))
1388         else:
1389             ecpairs.append(r"%s & \text{for}\: %s" %
1390                            (self._print(expr.args[-1].expr),
1391                             self._print(expr.args[-1].cond)))
1392         tex = r"\begin{cases} %s \end{cases}"
1393         return tex % r" \\".join(ecpairs)
1394 
1395     def _print_MatrixBase(self, expr):
1396         lines = []
1397 
1398         for line in range(expr.rows):  # horrible, should be 'rows'
1399             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1400 
1401         mat_str = self._settings['mat_str']
1402         if mat_str is None:
1403             if self._settings['mode'] == 'inline':
1404                 mat_str = 'smallmatrix'
1405             else:
1406                 if (expr.cols <= 10) is True:
1407                     mat_str = 'matrix'
1408                 else:
1409                     mat_str = 'array'
1410 
1411         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1412         out_str = out_str.replace('%MATSTR%', mat_str)
1413         if mat_str == 'array':
1414             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1415         if self._settings['mat_delim']:
1416             left_delim = self._settings['mat_delim']
1417             right_delim = self._delim_dict[left_delim]
1418             out_str = r'\left' + left_delim + out_str + \
1419                       r'\right' + right_delim
1420         return out_str % r"\\".join(lines)
1421     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1422                            = _print_Matrix \
1423                            = _print_MatrixBase
1424 
1425     def _print_MatrixElement(self, expr):
1426         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1427             + '_{%s, %s}' % (expr.i, expr.j)
1428 
1429     def _print_MatrixSlice(self, expr):
1430         def latexslice(x):
1431             x = list(x)
1432             if x[2] == 1:
1433                 del x[2]
1434             if x[1] == x[0] + 1:
1435                 del x[1]
1436             if x[0] == 0:
1437                 x[0] = ''
1438             return ':'.join(map(self._print, x))
1439         return (self._print(expr.parent) + r'\left[' +
1440                 latexslice(expr.rowslice) + ', ' +
1441                 latexslice(expr.colslice) + r'\right]')
1442 
1443     def _print_BlockMatrix(self, expr):
1444         return self._print(expr.blocks)
1445 
1446     def _print_Transpose(self, expr):
1447         mat = expr.arg
1448         from sympy.matrices import MatrixSymbol
1449         if not isinstance(mat, MatrixSymbol):
1450             return r"\left(%s\right)^T" % self._print(mat)
1451         else:
1452             return "%s^T" % self._print(mat)
1453 
1454     def _print_Adjoint(self, expr):
1455         mat = expr.arg
1456         from sympy.matrices import MatrixSymbol
1457         if not isinstance(mat, MatrixSymbol):
1458             return r"\left(%s\right)^\dagger" % self._print(mat)
1459         else:
1460             return r"%s^\dagger" % self._print(mat)
1461 
1462     def _print_MatAdd(self, expr):
1463         terms = list(expr.args)
1464         tex = " + ".join(map(self._print, terms))
1465         return tex
1466 
1467     def _print_MatMul(self, expr):
1468         from sympy import Add, MatAdd, HadamardProduct
1469 
1470         def parens(x):
1471             if isinstance(x, (Add, MatAdd, HadamardProduct)):
1472                 return r"\left(%s\right)" % self._print(x)
1473             return self._print(x)
1474         return ' '.join(map(parens, expr.args))
1475 
1476     def _print_Mod(self, expr, exp=None):
1477         if exp is not None:
1478             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1479                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1480         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1481                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1482 
1483     def _print_HadamardProduct(self, expr):
1484         from sympy import Add, MatAdd, MatMul
1485 
1486         def parens(x):
1487             if isinstance(x, (Add, MatAdd, MatMul)):
1488                 return r"\left(%s\right)" % self._print(x)
1489             return self._print(x)
1490         return r' \circ '.join(map(parens, expr.args))
1491 
1492     def _print_MatPow(self, expr):
1493         base, exp = expr.base, expr.exp
1494         from sympy.matrices import MatrixSymbol
1495         if not isinstance(base, MatrixSymbol):
1496             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1497         else:
1498             return "%s^{%s}" % (self._print(base), self._print(exp))
1499 
1500     def _print_ZeroMatrix(self, Z):
1501         return r"\mathbb{0}"
1502 
1503     def _print_Identity(self, I):
1504         return r"\mathbb{I}"
1505 
1506     def _print_NDimArray(self, expr):
1507 
1508         if expr.rank() == 0:
1509             return self._print(expr[()])
1510 
1511         mat_str = self._settings['mat_str']
1512         if mat_str is None:
1513             if self._settings['mode'] == 'inline':
1514                 mat_str = 'smallmatrix'
1515             else:
1516                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1517                     mat_str = 'matrix'
1518                 else:
1519                     mat_str = 'array'
1520         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1521         block_str = block_str.replace('%MATSTR%', mat_str)
1522         if self._settings['mat_delim']:
1523             left_delim = self._settings['mat_delim']
1524             right_delim = self._delim_dict[left_delim]
1525             block_str = r'\left' + left_delim + block_str + \
1526                       r'\right' + right_delim
1527 
1528         if expr.rank() == 0:
1529             return block_str % ""
1530 
1531         level_str = [[]] + [[] for i in range(expr.rank())]
1532         shape_ranges = [list(range(i)) for i in expr.shape]
1533         for outer_i in itertools.product(*shape_ranges):
1534             level_str[-1].append(self._print(expr[outer_i]))
1535             even = True
1536             for back_outer_i in range(expr.rank()-1, -1, -1):
1537                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1538                     break
1539                 if even:
1540                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1541                 else:
1542                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1543                     if len(level_str[back_outer_i+1]) == 1:
1544                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1545                 even = not even
1546                 level_str[back_outer_i+1] = []
1547 
1548         out_str = level_str[0][0]
1549 
1550         if expr.rank() % 2 == 1:
1551             out_str = block_str % out_str
1552 
1553         return out_str
1554 
1555     _print_ImmutableDenseNDimArray = _print_NDimArray
1556     _print_ImmutableSparseNDimArray = _print_NDimArray
1557     _print_MutableDenseNDimArray = _print_NDimArray
1558     _print_MutableSparseNDimArray = _print_NDimArray
1559 
1560     def _print_tuple(self, expr):
1561         return r"\left ( %s\right )" % \
1562             r", \quad ".join([ self._print(i) for i in expr ])
1563 
1564     def _print_TensorProduct(self, expr):
1565         elements = [self._print(a) for a in expr.args]
1566         return r' \otimes '.join(elements)
1567 
1568     def _print_WedgeProduct(self, expr):
1569         elements = [self._print(a) for a in expr.args]
1570         return r' \wedge '.join(elements)
1571 
1572     def _print_Tuple(self, expr):
1573         return self._print_tuple(expr)
1574 
1575     def _print_list(self, expr):
1576         return r"\left [ %s\right ]" % \
1577             r", \quad ".join([ self._print(i) for i in expr ])
1578 
1579     def _print_dict(self, d):
1580         keys = sorted(d.keys(), key=default_sort_key)
1581         items = []
1582 
1583         for key in keys:
1584             val = d[key]
1585             items.append("%s : %s" % (self._print(key), self._print(val)))
1586 
1587         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1588 
1589     def _print_Dict(self, expr):
1590         return self._print_dict(expr)
1591 
1592     def _print_DiracDelta(self, expr, exp=None):
1593         if len(expr.args) == 1 or expr.args[1] == 0:
1594             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1595         else:
1596             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1597                 self._print(expr.args[1]), self._print(expr.args[0]))
1598         if exp:
1599             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1600         return tex
1601 
1602     def _print_SingularityFunction(self, expr):
1603         shift = self._print(expr.args[0] - expr.args[1])
1604         power = self._print(expr.args[2])
1605         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1606         return tex
1607 
1608     def _print_Heaviside(self, expr, exp=None):
1609         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1610         if exp:
1611             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1612         return tex
1613 
1614     def _print_KroneckerDelta(self, expr, exp=None):
1615         i = self._print(expr.args[0])
1616         j = self._print(expr.args[1])
1617         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1618             tex = r'\delta_{%s %s}' % (i, j)
1619         else:
1620             tex = r'\delta_{%s, %s}' % (i, j)
1621         if exp:
1622             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1623         return tex
1624 
1625     def _print_LeviCivita(self, expr, exp=None):
1626         indices = map(self._print, expr.args)
1627         if all(x.is_Atom for x in expr.args):
1628             tex = r'\varepsilon_{%s}' % " ".join(indices)
1629         else:
1630             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1631         if exp:
1632             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1633         return tex
1634 
1635     def _print_ProductSet(self, p):
1636         if len(p.sets) > 1 and not has_variety(p.sets):
1637             return self._print(p.sets[0]) + "^%d" % len(p.sets)
1638         else:
1639             return r" \times ".join(self._print(set) for set in p.sets)
1640 
1641     def _print_RandomDomain(self, d):
1642         if hasattr(d, 'as_boolean'):
1643             return 'Domain: ' + self._print(d.as_boolean())
1644         elif hasattr(d, 'set'):
1645             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1646                     self._print(d.set))
1647         elif hasattr(d, 'symbols'):
1648             return 'Domain on ' + self._print(d.symbols)
1649         else:
1650             return self._print(None)
1651 
1652     def _print_FiniteSet(self, s):
1653         items = sorted(s.args, key=default_sort_key)
1654         return self._print_set(items)
1655 
1656     def _print_set(self, s):
1657         items = sorted(s, key=default_sort_key)
1658         items = ", ".join(map(self._print, items))
1659         return r"\left\{%s\right\}" % items
1660 
1661     _print_frozenset = _print_set
1662 
1663     def _print_Range(self, s):
1664         dots = r'\ldots'
1665 
1666         if s.start.is_infinite:
1667             printset = s.start, dots, s[-1] - s.step, s[-1]
1668         elif s.stop.is_infinite or len(s) > 4:
1669             it = iter(s)
1670             printset = next(it), next(it), dots, s[-1]
1671         else:
1672             printset = tuple(s)
1673 
1674         return (r"\left\{"
1675               + r", ".join(self._print(el) for el in printset)
1676               + r"\right\}")
1677 
1678     def _print_SeqFormula(self, s):
1679         if s.start is S.NegativeInfinity:
1680             stop = s.stop
1681             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1682                 s.coeff(stop - 1), s.coeff(stop))
1683         elif s.stop is S.Infinity or s.length > 4:
1684             printset = s[:4]
1685             printset.append(r'\ldots')
1686         else:
1687             printset = tuple(s)
1688 
1689         return (r"\left["
1690               + r", ".join(self._print(el) for el in printset)
1691               + r"\right]")
1692 
1693     _print_SeqPer = _print_SeqFormula
1694     _print_SeqAdd = _print_SeqFormula
1695     _print_SeqMul = _print_SeqFormula
1696 
1697     def _print_Interval(self, i):
1698         if i.start == i.end:
1699             return r"\left\{%s\right\}" % self._print(i.start)
1700 
1701         else:
1702             if i.left_open:
1703                 left = '('
1704             else:
1705                 left = '['
1706 
1707             if i.right_open:
1708                 right = ')'
1709             else:
1710                 right = ']'
1711 
1712             return r"\left%s%s, %s\right%s" % \
1713                    (left, self._print(i.start), self._print(i.end), right)
1714 
1715     def _print_AccumulationBounds(self, i):
1716         return r"\langle %s, %s\rangle" % \
1717                 (self._print(i.min), self._print(i.max))
1718 
1719     def _print_Union(self, u):
1720         return r" \cup ".join([self._print(i) for i in u.args])
1721 
1722     def _print_Complement(self, u):
1723         return r" \setminus ".join([self._print(i) for i in u.args])
1724 
1725     def _print_Intersection(self, u):
1726         return r" \cap ".join([self._print(i) for i in u.args])
1727 
1728     def _print_SymmetricDifference(self, u):
1729         return r" \triangle ".join([self._print(i) for i in u.args])
1730 
1731     def _print_EmptySet(self, e):
1732         return r"\emptyset"
1733 
1734     def _print_Naturals(self, n):
1735         return r"\mathbb{N}"
1736 
1737     def _print_Naturals0(self, n):
1738         return r"\mathbb{N}_0"
1739 
1740     def _print_Integers(self, i):
1741         return r"\mathbb{Z}"
1742 
1743     def _print_Reals(self, i):
1744         return r"\mathbb{R}"
1745 
1746     def _print_Complexes(self, i):
1747         return r"\mathbb{C}"
1748 
1749     def _print_ImageSet(self, s):
1750         sets = s.args[1:]
1751         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1752             for var, setv in zip(s.lamda.variables, sets)]
1753         return r"\left\{%s\; |\; %s\right\}" % (
1754             self._print(s.lamda.expr),
1755             ', '.join(varsets))
1756 
1757     def _print_ConditionSet(self, s):
1758         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1759         return r"\left\{%s\; |\; %s \in %s \wedge %s \right\}" % (
1760             vars_print,
1761             vars_print,
1762             self._print(s.base_set),
1763             self._print(s.condition.as_expr()))
1764 
1765     def _print_ComplexRegion(self, s):
1766         vars_print = ', '.join([self._print(var) for var in s.variables])
1767         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1768             self._print(s.expr),
1769             vars_print,
1770             self._print(s.sets))
1771 
1772     def _print_Contains(self, e):
1773         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1774 
1775     def _print_FourierSeries(self, s):
1776         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1777 
1778     def _print_FormalPowerSeries(self, s):
1779         return self._print_Add(s.infinite)
1780 
1781     def _print_FiniteField(self, expr):
1782         return r"\mathbb{F}_{%s}" % expr.mod
1783 
1784     def _print_IntegerRing(self, expr):
1785         return r"\mathbb{Z}"
1786 
1787     def _print_RationalField(self, expr):
1788         return r"\mathbb{Q}"
1789 
1790     def _print_RealField(self, expr):
1791         return r"\mathbb{R}"
1792 
1793     def _print_ComplexField(self, expr):
1794         return r"\mathbb{C}"
1795 
1796     def _print_PolynomialRing(self, expr):
1797         domain = self._print(expr.domain)
1798         symbols = ", ".join(map(self._print, expr.symbols))
1799         return r"%s\left[%s\right]" % (domain, symbols)
1800 
1801     def _print_FractionField(self, expr):
1802         domain = self._print(expr.domain)
1803         symbols = ", ".join(map(self._print, expr.symbols))
1804         return r"%s\left(%s\right)" % (domain, symbols)
1805 
1806     def _print_PolynomialRingBase(self, expr):
1807         domain = self._print(expr.domain)
1808         symbols = ", ".join(map(self._print, expr.symbols))
1809         inv = ""
1810         if not expr.is_Poly:
1811             inv = r"S_<^{-1}"
1812         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1813 
1814     def _print_Poly(self, poly):
1815         cls = poly.__class__.__name__
1816         expr = self._print(poly.as_expr())
1817         gens = list(map(self._print, poly.gens))
1818         domain = "domain=%s" % self._print(poly.get_domain())
1819 
1820         args = ", ".join([expr] + gens + [domain])
1821         if cls in accepted_latex_functions:
1822             tex = r"\%s {\left (%s \right )}" % (cls, args)
1823         else:
1824             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1825 
1826         return tex
1827 
1828     def _print_ComplexRootOf(self, root):
1829         cls = root.__class__.__name__
1830         if cls == "ComplexRootOf":
1831             cls = "CRootOf"
1832         expr = self._print(root.expr)
1833         index = root.index
1834         if cls in accepted_latex_functions:
1835             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1836         else:
1837             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1838 
1839     def _print_RootSum(self, expr):
1840         cls = expr.__class__.__name__
1841         args = [self._print(expr.expr)]
1842 
1843         if expr.fun is not S.IdentityFunction:
1844             args.append(self._print(expr.fun))
1845 
1846         if cls in accepted_latex_functions:
1847             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1848         else:
1849             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1850 
1851     def _print_PolyElement(self, poly):
1852         mul_symbol = self._settings['mul_symbol_latex']
1853         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1854 
1855     def _print_FracElement(self, frac):
1856         if frac.denom == 1:
1857             return self._print(frac.numer)
1858         else:
1859             numer = self._print(frac.numer)
1860             denom = self._print(frac.denom)
1861             return r"\frac{%s}{%s}" % (numer, denom)
1862 
1863     def _print_euler(self, expr, exp=None):
1864         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
1865         tex = r"E_{%s}" % self._print(m)
1866         if exp is not None:
1867             tex = r"%s^{%s}" % (tex, self._print(exp))
1868         if x is not None:
1869             tex = r"%s\left(%s\right)" % (tex, self._print(x))
1870         return tex
1871 
1872     def _print_catalan(self, expr, exp=None):
1873         tex = r"C_{%s}" % self._print(expr.args[0])
1874         if exp is not None:
1875             tex = r"%s^{%s}" % (tex, self._print(exp))
1876         return tex
1877 
1878     def _print_MellinTransform(self, expr):
1879         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1880 
1881     def _print_InverseMellinTransform(self, expr):
1882         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1883 
1884     def _print_LaplaceTransform(self, expr):
1885         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1886 
1887     def _print_InverseLaplaceTransform(self, expr):
1888         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1889 
1890     def _print_FourierTransform(self, expr):
1891         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1892 
1893     def _print_InverseFourierTransform(self, expr):
1894         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1895 
1896     def _print_SineTransform(self, expr):
1897         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1898 
1899     def _print_InverseSineTransform(self, expr):
1900         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1901 
1902     def _print_CosineTransform(self, expr):
1903         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1904 
1905     def _print_InverseCosineTransform(self, expr):
1906         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1907 
1908     def _print_DMP(self, p):
1909         try:
1910             if p.ring is not None:
1911                 # TODO incorporate order
1912                 return self._print(p.ring.to_sympy(p))
1913         except SympifyError:
1914             pass
1915         return self._print(repr(p))
1916 
1917     def _print_DMF(self, p):
1918         return self._print_DMP(p)
1919 
1920     def _print_Object(self, object):
1921         return self._print(Symbol(object.name))
1922 
1923     def _print_Morphism(self, morphism):
1924         domain = self._print(morphism.domain)
1925         codomain = self._print(morphism.codomain)
1926         return "%s\\rightarrow %s" % (domain, codomain)
1927 
1928     def _print_NamedMorphism(self, morphism):
1929         pretty_name = self._print(Symbol(morphism.name))
1930         pretty_morphism = self._print_Morphism(morphism)
1931         return "%s:%s" % (pretty_name, pretty_morphism)
1932 
1933     def _print_IdentityMorphism(self, morphism):
1934         from sympy.categories import NamedMorphism
1935         return self._print_NamedMorphism(NamedMorphism(
1936             morphism.domain, morphism.codomain, "id"))
1937 
1938     def _print_CompositeMorphism(self, morphism):
1939         # All components of the morphism have names and it is thus
1940         # possible to build the name of the composite.
1941         component_names_list = [self._print(Symbol(component.name)) for
1942                                 component in morphism.components]
1943         component_names_list.reverse()
1944         component_names = "\\circ ".join(component_names_list) + ":"
1945 
1946         pretty_morphism = self._print_Morphism(morphism)
1947         return component_names + pretty_morphism
1948 
1949     def _print_Category(self, morphism):
1950         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
1951 
1952     def _print_Diagram(self, diagram):
1953         if not diagram.premises:
1954             # This is an empty diagram.
1955             return self._print(S.EmptySet)
1956 
1957         latex_result = self._print(diagram.premises)
1958         if diagram.conclusions:
1959             latex_result += "\\Longrightarrow %s" % \
1960                             self._print(diagram.conclusions)
1961 
1962         return latex_result
1963 
1964     def _print_DiagramGrid(self, grid):
1965         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
1966 
1967         for i in range(grid.height):
1968             for j in range(grid.width):
1969                 if grid[i, j]:
1970                     latex_result += latex(grid[i, j])
1971                 latex_result += " "
1972                 if j != grid.width - 1:
1973                     latex_result += "& "
1974 
1975             if i != grid.height - 1:
1976                 latex_result += "\\\\"
1977             latex_result += "\n"
1978 
1979         latex_result += "\\end{array}\n"
1980         return latex_result
1981 
1982     def _print_FreeModule(self, M):
1983         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
1984 
1985     def _print_FreeModuleElement(self, m):
1986         # Print as row vector for convenience, for now.
1987         return r"\left[ %s \right]" % ",".join(
1988             '{' + self._print(x) + '}' for x in m)
1989 
1990     def _print_SubModule(self, m):
1991         return r"\left< %s \right>" % ",".join(
1992             '{' + self._print(x) + '}' for x in m.gens)
1993 
1994     def _print_ModuleImplementedIdeal(self, m):
1995         return r"\left< %s \right>" % ",".join(
1996             '{' + self._print(x) + '}' for [x] in m._module.gens)
1997 
1998     def _print_Quaternion(self, expr):
1999         # TODO: This expression is potentially confusing,
2000         # shall we print it as `Quaternion( ... )`?
2001         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2002         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2003         return " + ".join(a)
2004 
2005     def _print_QuotientRing(self, R):
2006         # TODO nicer fractions for few generators...
2007         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2008 
2009     def _print_QuotientRingElement(self, x):
2010         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2011 
2012     def _print_QuotientModuleElement(self, m):
2013         return r"{%s} + {%s}" % (self._print(m.data),
2014                                  self._print(m.module.killed_module))
2015 
2016     def _print_QuotientModule(self, M):
2017         # TODO nicer fractions for few generators...
2018         return r"\frac{%s}{%s}" % (self._print(M.base),
2019                                    self._print(M.killed_module))
2020 
2021     def _print_MatrixHomomorphism(self, h):
2022         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2023             self._print(h.domain), self._print(h.codomain))
2024 
2025     def _print_BaseScalarField(self, field):
2026         string = field._coord_sys._names[field._index]
2027         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2028 
2029     def _print_BaseVectorField(self, field):
2030         string = field._coord_sys._names[field._index]
2031         return r'\partial_{%s}' % self._print(Symbol(string))
2032 
2033     def _print_Differential(self, diff):
2034         field = diff._form_field
2035         if hasattr(field, '_coord_sys'):
2036             string = field._coord_sys._names[field._index]
2037             return r'\mathrm{d}%s' % self._print(Symbol(string))
2038         else:
2039             return 'd(%s)' % self._print(field)
2040             string = self._print(field)
2041             return r'\mathrm{d}\left(%s\right)' % string
2042 
2043     def _print_Tr(self, p):
2044         #Todo: Handle indices
2045         contents = self._print(p.args[0])
2046         return r'\mbox{Tr}\left(%s\right)' % (contents)
2047 
2048     def _print_totient(self, expr, exp=None):
2049         if exp is not None:
2050             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2051                     self._print(exp))
2052         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2053 
2054     def _print_reduced_totient(self, expr, exp=None):
2055         if exp is not None:
2056             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2057                     self._print(exp))
2058         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2059 
2060     def _print_divisor_sigma(self, expr, exp=None):
2061         if len(expr.args) == 2:
2062             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2063                                                 (expr.args[1], expr.args[0])))
2064         else:
2065             tex = r"\left(%s\right)" % self._print(expr.args[0])
2066         if exp is not None:
2067             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2068         return r"\sigma%s" % tex
2069 
2070     def _print_udivisor_sigma(self, expr, exp=None):
2071         if len(expr.args) == 2:
2072             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2073                                                 (expr.args[1], expr.args[0])))
2074         else:
2075             tex = r"\left(%s\right)" % self._print(expr.args[0])
2076         if exp is not None:
2077             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2078         return r"\sigma^*%s" % tex
2079 
2080     def _print_primenu(self, expr, exp=None):
2081         if exp is not None:
2082             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2083                     self._print(exp))
2084         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2085 
2086     def _print_primeomega(self, expr, exp=None):
2087         if exp is not None:
2088             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2089                     self._print(exp))
2090         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 08:12:00.838 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 08:12:00.838 | INFO     | Search-only: skipping patch selection
2025-10-18 08:12:00.920 | INFO     | Task sympy__sympy-14180 completed successfully.
2025-10-18 08:12:00.921 | INFO     | No patch generated. You can try running ACR again.
