2025-10-18 07:57:49.631 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 07:58:01.087 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=328, output_tokens=12, cost=0.003640
2025-10-18 07:58:09.910 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=508, output_tokens=418, cost=0.017620
2025-10-18 07:58:11.209 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:58:15.975 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=217, cost=0.012840
2025-10-18 07:58:15.983 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:58:20.125 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=571, output_tokens=69, cost=0.007780
2025-10-18 07:58:20.126 | DEBUG    | Extracted a valid json.
2025-10-18 07:58:20.127 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Matrix\")",
        "search_method_in_class(\"eigenvals\", \"Matrix\")",
        "search_method_in_class(\"charpoly\", \"Matrix\")",
        "search_method(\"solve\")",
        "search_method(\"roots\")"
    ],
    "bug_locations": []
}
2025-10-18 07:58:20.134 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 07:58:20.135 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 07:58:35.694 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1313, output_tokens=691, cost=0.033860
2025-10-18 07:58:35.709 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:58:46.861 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2220, output_tokens=474, cost=0.036420
2025-10-18 07:58:46.870 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:58:52.729 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=828, output_tokens=221, cost=0.014910
2025-10-18 07:58:52.730 | DEBUG    | Extracted a valid json.
2025-10-18 07:58:52.731 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/matrices/eigen.py",
            "class": "Matrix",
            "method": "eigenvals",
            "intended_behavior": "The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions."
        },
        {
            "file": "sympy/polys/polyroots.py",
            "class": "",
            "method": "",
            "intended_behavior": "The roots function should ensure that it can find roots of symbolic characteristic polynomials derived from matrices with symbolic entries more reliably. This could include enhancements in the algorithm to handle complex symbolic expressions or leveraging additional symbolic solving capabilities of SymPy that might not currently be utilized to their full potential."
        }
    ]
}
2025-10-18 07:58:52.739 | DEBUG    | Bug location extracted successfully: [<file>sympy/matrices/matrices.py</file>
<class>None</class>
<method>eigenvals</method>
<code>
1094     def eigenvals(self, error_when_incomplete=True, **flags):
1095         """Return eigenvalues using the Berkowitz agorithm to compute
1096         the characteristic polynomial.
1097 
1098         Parameters
1099         ==========
1100 
1101         error_when_incomplete : bool
1102             Raise an error when not all eigenvalues are computed. This is
1103             caused by ``roots`` not returning a full list of eigenvalues.
1104 
1105         Since the roots routine doesn't always work well with Floats,
1106         they will be replaced with Rationals before calling that
1107         routine. If this is not desired, set flag ``rational`` to False.
1108         """
1109         mat = self
1110         if not mat:
1111             return {}
1112         if flags.pop('rational', True):
1113             if any(v.has(Float) for v in mat):
1114                 mat = mat.applyfunc(lambda x: nsimplify(x, rational=True))
1115 
1116         flags.pop('simplify', None)  # pop unsupported flag
1117         eigs = roots(mat.charpoly(x=Dummy('x')), **flags)
1118 
1119         # make sure the algebraic multiplicty sums to the
1120         # size of the matrix
1121         if error_when_incomplete and sum(m for m in eigs.values()) != self.cols:
1122             raise MatrixError("Could not compute eigenvalues for {}".format(self))
1123 
1124         return eigs

</code><intended_behavior>The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions.</intended_behavior>, <file>sympy/matrices/matrices.py</file>
<class>MatrixEigen</class>
<method>eigenvals</method>
<code>
1094     def eigenvals(self, error_when_incomplete=True, **flags):
1095         """Return eigenvalues using the Berkowitz agorithm to compute
1096         the characteristic polynomial.
1097 
1098         Parameters
1099         ==========
1100 
1101         error_when_incomplete : bool
1102             Raise an error when not all eigenvalues are computed. This is
1103             caused by ``roots`` not returning a full list of eigenvalues.
1104 
1105         Since the roots routine doesn't always work well with Floats,
1106         they will be replaced with Rationals before calling that
1107         routine. If this is not desired, set flag ``rational`` to False.
1108         """
1109         mat = self
1110         if not mat:
1111             return {}
1112         if flags.pop('rational', True):
1113             if any(v.has(Float) for v in mat):
1114                 mat = mat.applyfunc(lambda x: nsimplify(x, rational=True))
1115 
1116         flags.pop('simplify', None)  # pop unsupported flag
1117         eigs = roots(mat.charpoly(x=Dummy('x')), **flags)
1118 
1119         # make sure the algebraic multiplicty sums to the
1120         # size of the matrix
1121         if error_when_incomplete and sum(m for m in eigs.values()) != self.cols:
1122             raise MatrixError("Could not compute eigenvalues for {}".format(self))
1123 
1124         return eigs

</code><intended_behavior>The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions.</intended_behavior>, <file>sympy/polys/polyroots.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Algorithms for computing symbolic roots of polynomials. """
2 
3 from __future__ import print_function, division
4 
5 import math
6 
7 from sympy.core.symbol import Dummy, Symbol, symbols
8 from sympy.core import S, I, pi
9 from sympy.core.compatibility import ordered
10 from sympy.core.mul import expand_2arg, Mul
11 from sympy.core.power import Pow
12 from sympy.core.relational import Eq
13 from sympy.core.sympify import sympify
14 from sympy.core.numbers import Rational, igcd, comp
15 from sympy.core.exprtools import factor_terms
16 from sympy.core.logic import fuzzy_not
17 
18 from sympy.ntheory import divisors, isprime, nextprime
19 from sympy.functions import exp, sqrt, im, cos, acos, Piecewise
20 from sympy.functions.elementary.miscellaneous import root
21 
22 from sympy.polys.polytools import Poly, cancel, factor, gcd_list, discriminant
23 from sympy.polys.specialpolys import cyclotomic_poly
24 from sympy.polys.polyerrors import (PolynomialError, GeneratorsNeeded,
25     DomainError)
26 from sympy.polys.polyquinticconst import PolyQuintic
27 from sympy.polys.rationaltools import together
28 
29 from sympy.simplify import simplify, powsimp
30 from sympy.utilities import public
31 
32 from sympy.core.compatibility import reduce, range
33 
34 
35 def roots_linear(f):
36     """Returns a list of roots of a linear polynomial."""
37     r = -f.nth(0)/f.nth(1)
38     dom = f.get_domain()
39 
40     if not dom.is_Numerical:
41         if dom.is_Composite:
42             r = factor(r)
43         else:
44             r = simplify(r)
45 
46     return [r]
47 
48 
49 def roots_quadratic(f):
50     """Returns a list of roots of a quadratic polynomial. If the domain is ZZ
51     then the roots will be sorted with negatives coming before positives.
52     The ordering will be the same for any numerical coefficients as long as
53     the assumptions tested are correct, otherwise the ordering will not be
54     sorted (but will be canonical).
55     """
56 
57     a, b, c = f.all_coeffs()
58     dom = f.get_domain()
59 
60     def _sqrt(d):
61         # remove squares from square root since both will be represented
62         # in the results; a similar thing is happening in roots() but
63         # must be duplicated here because not all quadratics are binomials
64         co = []
65         other = []
66         for di in Mul.make_args(d):
67             if di.is_Pow and di.exp.is_Integer and di.exp % 2 == 0:
68                 co.append(Pow(di.base, di.exp//2))
69             else:
70                 other.append(di)
71         if co:
72             d = Mul(*other)
73             co = Mul(*co)
74             return co*sqrt(d)
75         return sqrt(d)
76 
77     def _simplify(expr):
78         if dom.is_Composite:
79             return factor(expr)
80         else:
81             return simplify(expr)
82 
83     if c is S.Zero:
84         r0, r1 = S.Zero, -b/a
85 
86         if not dom.is_Numerical:
87             r1 = _simplify(r1)
88         elif r1.is_negative:
89             r0, r1 = r1, r0
90     elif b is S.Zero:
91         r = -c/a
92         if not dom.is_Numerical:
93             r = _simplify(r)
94 
95         R = _sqrt(r)
96         r0 = -R
97         r1 = R
98     else:
99         d = b**2 - 4*a*c
100         A = 2*a
101         B = -b/A
102 
103         if not dom.is_Numerical:
104             d = _simplify(d)
105             B = _simplify(B)
106 
107         D = factor_terms(_sqrt(d)/A)
108         r0 = B - D
109         r1 = B + D
110         if a.is_negative:
111             r0, r1 = r1, r0
112         elif not dom.is_Numerical:
113             r0, r1 = [expand_2arg(i) for i in (r0, r1)]
114 
115     return [r0, r1]
116 
117 
118 def roots_cubic(f, trig=False):
119     """Returns a list of roots of a cubic polynomial.
120 
121     References
122     ==========
123     [1] https://en.wikipedia.org/wiki/Cubic_function, General formula for roots,
124     (accessed November 17, 2014).
125     """
126     if trig:
127         a, b, c, d = f.all_coeffs()
128         p = (3*a*c - b**2)/3/a**2
129         q = (2*b**3 - 9*a*b*c + 27*a**2*d)/(27*a**3)
130         D = 18*a*b*c*d - 4*b**3*d + b**2*c**2 - 4*a*c**3 - 27*a**2*d**2
131         if (D > 0) == True:
132             rv = []
133             for k in range(3):
134                 rv.append(2*sqrt(-p/3)*cos(acos(3*q/2/p*sqrt(-3/p))/3 - k*2*pi/3))
135             return [i - b/3/a for i in rv]
136 
137     _, a, b, c = f.monic().all_coeffs()
138 
139     if c is S.Zero:
140         x1, x2 = roots([1, a, b], multiple=True)
141         return [x1, S.Zero, x2]
142 
143     p = b - a**2/3
144     q = c - a*b/3 + 2*a**3/27
145 
146     pon3 = p/3
147     aon3 = a/3
148 
149     u1 = None
150     if p is S.Zero:
151         if q is S.Zero:
152             return [-aon3]*3
153         if q.is_real:
154             if q.is_positive:
155                 u1 = -root(q, 3)
156             elif q.is_negative:
157                 u1 = root(-q, 3)
158     elif q is S.Zero:
159         y1, y2 = roots([1, 0, p], multiple=True)
160         return [tmp - aon3 for tmp in [y1, S.Zero, y2]]
161     elif q.is_real and q.is_negative:
162         u1 = -root(-q/2 + sqrt(q**2/4 + pon3**3), 3)
163 
164     coeff = I*sqrt(3)/2
165     if u1 is None:
166         u1 = S(1)
167         u2 = -S.Half + coeff
168         u3 = -S.Half - coeff
169         a, b, c, d = S(1), a, b, c
170         D0 = b**2 - 3*a*c
171         D1 = 2*b**3 - 9*a*b*c + 27*a**2*d
172         C = root((D1 + sqrt(D1**2 - 4*D0**3))/2, 3)
173         return [-(b + uk*C + D0/C/uk)/3/a for uk in [u1, u2, u3]]
174 
175     u2 = u1*(-S.Half + coeff)
176     u3 = u1*(-S.Half - coeff)
177 
178     if p is S.Zero:
179         return [u1 - aon3, u2 - aon3, u3 - aon3]
180 
181     soln = [
182         -u1 + pon3/u1 - aon3,
183         -u2 + pon3/u2 - aon3,
184         -u3 + pon3/u3 - aon3
185     ]
186 
187     return soln
188 
189 def _roots_quartic_euler(p, q, r, a):
190     """
191     Descartes-Euler solution of the quartic equation
192 
193     Parameters
194     ==========
195 
196     p, q, r: coefficients of ``x**4 + p*x**2 + q*x + r``
197     a: shift of the roots
198 
199     Notes
200     =====
201 
202     This is a helper function for ``roots_quartic``.
203 
204     Look for solutions of the form ::
205 
206       ``x1 = sqrt(R) - sqrt(A + B*sqrt(R))``
207       ``x2 = -sqrt(R) - sqrt(A - B*sqrt(R))``
208       ``x3 = -sqrt(R) + sqrt(A - B*sqrt(R))``
209       ``x4 = sqrt(R) + sqrt(A + B*sqrt(R))``
210 
211     To satisfy the quartic equation one must have
212     ``p = -2*(R + A); q = -4*B*R; r = (R - A)**2 - B**2*R``
213     so that ``R`` must satisfy the Descartes-Euler resolvent equation
214     ``64*R**3 + 32*p*R**2 + (4*p**2 - 16*r)*R - q**2 = 0``
215 
216     If the resolvent does not have a rational solution, return None;
217     in that case it is likely that the Ferrari method gives a simpler
218     solution.
219 
220     Examples
221     ========
222 
223     >>> from sympy import S
224     >>> from sympy.polys.polyroots import _roots_quartic_euler
225     >>> p, q, r = -S(64)/5, -S(512)/125, -S(1024)/3125
226     >>> _roots_quartic_euler(p, q, r, S(0))[0]
227     -sqrt(32*sqrt(5)/125 + 16/5) + 4*sqrt(5)/5
228     """
229     # solve the resolvent equation
230     x = Symbol('x')
231     eq = 64*x**3 + 32*p*x**2 + (4*p**2 - 16*r)*x - q**2
232     xsols = list(roots(Poly(eq, x), cubics=False).keys())
233     xsols = [sol for sol in xsols if sol.is_rational]
234     if not xsols:
235         return None
236     R = max(xsols)
237     c1 = sqrt(R)
238     B = -q*c1/(4*R)
239     A = -R - p/2
240     c2 = sqrt(A + B)
241     c3 = sqrt(A - B)
242     return [c1 - c2 - a, -c1 - c3 - a, -c1 + c3 - a, c1 + c2 - a]
243 
244 
245 def roots_quartic(f):
246     r"""
247     Returns a list of roots of a quartic polynomial.
248 
249     There are many references for solving quartic expressions available [1-5].
250     This reviewer has found that many of them require one to select from among
251     2 or more possible sets of solutions and that some solutions work when one
252     is searching for real roots but don't work when searching for complex roots
253     (though this is not always stated clearly). The following routine has been
254     tested and found to be correct for 0, 2 or 4 complex roots.
255 
256     The quasisymmetric case solution [6] looks for quartics that have the form
257     `x**4 + A*x**3 + B*x**2 + C*x + D = 0` where `(C/A)**2 = D`.
258 
259     Although no general solution that is always applicable for all
260     coefficients is known to this reviewer, certain conditions are tested
261     to determine the simplest 4 expressions that can be returned:
262 
263       1) `f = c + a*(a**2/8 - b/2) == 0`
264       2) `g = d - a*(a*(3*a**2/256 - b/16) + c/4) = 0`
265       3) if `f != 0` and `g != 0` and `p = -d + a*c/4 - b**2/12` then
266         a) `p == 0`
267         b) `p != 0`
268 
269     Examples
270     ========
271 
272         >>> from sympy import Poly, symbols, I
273         >>> from sympy.polys.polyroots import roots_quartic
274 
275         >>> r = roots_quartic(Poly('x**4-6*x**3+17*x**2-26*x+20'))
276 
277         >>> # 4 complex roots: 1+-I*sqrt(3), 2+-I
278         >>> sorted(str(tmp.evalf(n=2)) for tmp in r)
279         ['1.0 + 1.7*I', '1.0 - 1.7*I', '2.0 + 1.0*I', '2.0 - 1.0*I']
280 
281     References
282     ==========
283 
284     1. http://mathforum.org/dr.math/faq/faq.cubic.equations.html
285     2. http://en.wikipedia.org/wiki/Quartic_function#Summary_of_Ferrari.27s_method
286     3. http://planetmath.org/encyclopedia/GaloisTheoreticDerivationOfTheQuarticFormula.html
287     4. http://staff.bath.ac.uk/masjhd/JHD-CA.pdf
288     5. http://www.albmath.org/files/Math_5713.pdf
289     6. http://www.statemaster.com/encyclopedia/Quartic-equation
290     7. eqworld.ipmnet.ru/en/solutions/ae/ae0108.pdf
291     """
292     _, a, b, c, d = f.monic().all_coeffs()
293 
294     if not d:
295         return [S.Zero] + roots([1, a, b, c], multiple=True)
296     elif (c/a)**2 == d:
297         x, m = f.gen, c/a
298 
299         g = Poly(x**2 + a*x + b - 2*m, x)
300 
301         z1, z2 = roots_quadratic(g)
302 
303         h1 = Poly(x**2 - z1*x + m, x)
304         h2 = Poly(x**2 - z2*x + m, x)
305 
306         r1 = roots_quadratic(h1)
307         r2 = roots_quadratic(h2)
308 
309         return r1 + r2
310     else:
311         a2 = a**2
312         e = b - 3*a2/8
313         f = c + a*(a2/8 - b/2)
314         g = d - a*(a*(3*a2/256 - b/16) + c/4)
315         aon4 = a/4
316 
317         if f is S.Zero:
318             y1, y2 = [sqrt(tmp) for tmp in
319                       roots([1, e, g], multiple=True)]
320             return [tmp - aon4 for tmp in [-y1, -y2, y1, y2]]
321         if g is S.Zero:
322             y = [S.Zero] + roots([1, 0, e, f], multiple=True)
323             return [tmp - aon4 for tmp in y]
324         else:
325             # Descartes-Euler method, see [7]
326             sols = _roots_quartic_euler(e, f, g, aon4)
327             if sols:
328                 return sols
329             # Ferrari method, see [1, 2]
330             a2 = a**2
331             e = b - 3*a2/8
332             f = c + a*(a2/8 - b/2)
333             g = d - a*(a*(3*a2/256 - b/16) + c/4)
334             p = -e**2/12 - g
335             q = -e**3/108 + e*g/3 - f**2/8
336             TH = Rational(1, 3)
337 
338             def _ans(y):
339                 w = sqrt(e + 2*y)
340                 arg1 = 3*e + 2*y
341                 arg2 = 2*f/w
342                 ans = []
343                 for s in [-1, 1]:
344                     root = sqrt(-(arg1 + s*arg2))
345                     for t in [-1, 1]:
346                         ans.append((s*w - t*root)/2 - aon4)
347                 return ans
348 
349             # p == 0 case
350             y1 = -5*e/6 - q**TH
351             if p.is_zero:
352                 return _ans(y1)
353 
354             # if p != 0 then u below is not 0
355             root = sqrt(q**2/4 + p**3/27)
356             r = -q/2 + root  # or -q/2 - root
357             u = r**TH  # primary root of solve(x**3 - r, x)
358             y2 = -5*e/6 + u - p/u/3
359             if fuzzy_not(p.is_zero):
360                 return _ans(y2)
361 
362             # sort it out once they know the values of the coefficients
363             return [Piecewise((a1, Eq(p, 0)), (a2, True))
364                 for a1, a2 in zip(_ans(y1), _ans(y2))]
365 
366 
367 def roots_binomial(f):
368     """Returns a list of roots of a binomial polynomial. If the domain is ZZ
369     then the roots will be sorted with negatives coming before positives.
370     The ordering will be the same for any numerical coefficients as long as
371     the assumptions tested are correct, otherwise the ordering will not be
372     sorted (but will be canonical).
373     """
374     n = f.degree()
375 
376     a, b = f.nth(n), f.nth(0)
377     base = -cancel(b/a)
378     alpha = root(base, n)
379 
380     if alpha.is_number:
381         alpha = alpha.expand(complex=True)
382 
383     # define some parameters that will allow us to order the roots.
384     # If the domain is ZZ this is guaranteed to return roots sorted
385     # with reals before non-real roots and non-real sorted according
386     # to real part and imaginary part, e.g. -1, 1, -1 + I, 2 - I
387     neg = base.is_negative
388     even = n % 2 == 0
389     if neg:
390         if even == True and (base + 1).is_positive:
391             big = True
392         else:
393             big = False
394 
395     # get the indices in the right order so the computed
396     # roots will be sorted when the domain is ZZ
397     ks = []
398     imax = n//2
399     if even:
400         ks.append(imax)
401         imax -= 1
402     if not neg:
403         ks.append(0)
404     for i in range(imax, 0, -1):
405         if neg:
406             ks.extend([i, -i])
407         else:
408             ks.extend([-i, i])
409     if neg:
410         ks.append(0)
411         if big:
412             for i in range(0, len(ks), 2):
413                 pair = ks[i: i + 2]
414                 pair = list(reversed(pair))
415 
416     # compute the roots
417     roots, d = [], 2*I*pi/n
418     for k in ks:
419         zeta = exp(k*d).expand(complex=True)
420         roots.append((alpha*zeta).expand(power_base=False))
421 
422     return roots
423 
424 
425 def _inv_totient_estimate(m):
426     """
427     Find ``(L, U)`` such that ``L <= phi^-1(m) <= U``.
428 
429     Examples
430     ========
431 
432     >>> from sympy.polys.polyroots import _inv_totient_estimate
433 
434     >>> _inv_totient_estimate(192)
435     (192, 840)
436     >>> _inv_totient_estimate(400)
437     (400, 1750)
438 
439     """
440     primes = [ d + 1 for d in divisors(m) if isprime(d + 1) ]
441 
442     a, b = 1, 1
443 
444     for p in primes:
445         a *= p
446         b *= p - 1
447 
448     L = m
449     U = int(math.ceil(m*(float(a)/b)))
450 
451     P = p = 2
452     primes = []
453 
454     while P <= U:
455         p = nextprime(p)
456         primes.append(p)
457         P *= p
458 
459     P //= p
460     b = 1
461 
462     for p in primes[:-1]:
463         b *= p - 1
464 
465     U = int(math.ceil(m*(float(P)/b)))
466 
467     return L, U
468 
469 
470 def roots_cyclotomic(f, factor=False):
471     """Compute roots of cyclotomic polynomials. """
472     L, U = _inv_totient_estimate(f.degree())
473 
474     for n in range(L, U + 1):
475         g = cyclotomic_poly(n, f.gen, polys=True)
476 
477         if f == g:
478             break
479     else:  # pragma: no cover
480         raise RuntimeError("failed to find index of a cyclotomic polynomial")
481 
482     roots = []
483 
484     if not factor:
485         # get the indices in the right order so the computed
486         # roots will be sorted
487         h = n//2
488         ks = [i for i in range(1, n + 1) if igcd(i, n) == 1]
489         ks.sort(key=lambda x: (x, -1) if x <= h else (abs(x - n), 1))
490         d = 2*I*pi/n
491         for k in reversed(ks):
492             roots.append(exp(k*d).expand(complex=True))
493     else:
494         g = Poly(f, extension=root(-1, n))
495 
496         for h, _ in ordered(g.factor_list()[1]):
497             roots.append(-h.TC())
498 
499     return roots
500 
501 
502 def roots_quintic(f):
503     """
504     Calulate exact roots of a solvable quintic
505     """
506     result = []
507     coeff_5, coeff_4, p, q, r, s = f.all_coeffs()
508 
509     # Eqn must be of the form x^5 + px^3 + qx^2 + rx + s
510     if coeff_4:
511         return result
512 
513     if coeff_5 != 1:
514         l = [p/coeff_5, q/coeff_5, r/coeff_5, s/coeff_5]
515         if not all(coeff.is_Rational for coeff in l):
516             return result
517         f = Poly(f/coeff_5)
518     quintic = PolyQuintic(f)
519 
520     # Eqn standardized. Algo for solving starts here
521     if not f.is_irreducible:
522         return result
523 
524     f20 = quintic.f20
525     # Check if f20 has linear factors over domain Z
526     if f20.is_irreducible:
527         return result
528 
529     # Now, we know that f is solvable
530     for _factor in f20.factor_list()[1]:
531         if _factor[0].is_linear:
532             theta = _factor[0].root(0)
533             break
534     d = discriminant(f)
535     delta = sqrt(d)
536     # zeta = a fifth root of unity
537     zeta1, zeta2, zeta3, zeta4 = quintic.zeta
538     T = quintic.T(theta, d)
539     tol = S(1e-10)
540     alpha = T[1] + T[2]*delta
541     alpha_bar = T[1] - T[2]*delta
542     beta = T[3] + T[4]*delta
543     beta_bar = T[3] - T[4]*delta
544 
545     disc = alpha**2 - 4*beta
546     disc_bar = alpha_bar**2 - 4*beta_bar
547 
548     l0 = quintic.l0(theta)
549 
550     l1 = _quintic_simplify((-alpha + sqrt(disc)) / S(2))
551     l4 = _quintic_simplify((-alpha - sqrt(disc)) / S(2))
552 
553     l2 = _quintic_simplify((-alpha_bar + sqrt(disc_bar)) / S(2))
554     l3 = _quintic_simplify((-alpha_bar - sqrt(disc_bar)) / S(2))
555 
556     order = quintic.order(theta, d)
557     test = (order*delta.n()) - ( (l1.n() - l4.n())*(l2.n() - l3.n()) )
558     # Comparing floats
559     if not comp(test, 0, tol):
560         l2, l3 = l3, l2
561 
562     # Now we have correct order of l's
563     R1 = l0 + l1*zeta1 + l2*zeta2 + l3*zeta3 + l4*zeta4
564     R2 = l0 + l3*zeta1 + l1*zeta2 + l4*zeta3 + l2*zeta4
565     R3 = l0 + l2*zeta1 + l4*zeta2 + l1*zeta3 + l3*zeta4
566     R4 = l0 + l4*zeta1 + l3*zeta2 + l2*zeta3 + l1*zeta4
567 
568     Res = [None, [None]*5, [None]*5, [None]*5, [None]*5]
569     Res_n = [None, [None]*5, [None]*5, [None]*5, [None]*5]
570     sol = Symbol('sol')
571 
572     # Simplifying improves performace a lot for exact expressions
573     R1 = _quintic_simplify(R1)
574     R2 = _quintic_simplify(R2)
575     R3 = _quintic_simplify(R3)
576     R4 = _quintic_simplify(R4)
577 
578     # Solve imported here. Causing problems if imported as 'solve'
579     # and hence the changed name
580     from sympy.solvers.solvers import solve as _solve
581     a, b = symbols('a b', cls=Dummy)
582     _sol = _solve( sol**5 - a - I*b, sol)
583     for i in range(5):
584         _sol[i] = factor(_sol[i])
585     R1 = R1.as_real_imag()
586     R2 = R2.as_real_imag()
587     R3 = R3.as_real_imag()
588     R4 = R4.as_real_imag()
589 
590     for i, root in enumerate(_sol):
591         Res[1][i] = _quintic_simplify(root.subs({ a: R1[0], b: R1[1] }))
592         Res[2][i] = _quintic_simplify(root.subs({ a: R2[0], b: R2[1] }))
593         Res[3][i] = _quintic_simplify(root.subs({ a: R3[0], b: R3[1] }))
594         Res[4][i] = _quintic_simplify(root.subs({ a: R4[0], b: R4[1] }))
595 
596     for i in range(1, 5):
597         for j in range(5):
598             Res_n[i][j] = Res[i][j].n()
599             Res[i][j] = _quintic_simplify(Res[i][j])
600     r1 = Res[1][0]
601     r1_n = Res_n[1][0]
602 
603     for i in range(5):
604         if comp(im(r1_n*Res_n[4][i]), 0, tol):
605             r4 = Res[4][i]
606             break
607 
608     u, v = quintic.uv(theta, d)
609     sqrt5 = math.sqrt(5)
610 
611     # Now we have various Res values. Each will be a list of five
612     # values. We have to pick one r value from those five for each Res
613     u, v = quintic.uv(theta, d)
614     testplus = (u + v*delta*sqrt(5)).n()
615     testminus = (u - v*delta*sqrt(5)).n()
616 
617     # Evaluated numbers suffixed with _n
618     # We will use evaluated numbers for calculation. Much faster.
619     r4_n = r4.n()
620     r2 = r3 = None
621 
622     for i in range(5):
623         r2temp_n = Res_n[2][i]
624         for j in range(5):
625             # Again storing away the exact number and using
626             # evaluated numbers in computations
627             r3temp_n = Res_n[3][j]
628             if (comp((r1_n*r2temp_n**2 + r4_n*r3temp_n**2 - testplus).n(), 0, tol) and
629                 comp((r3temp_n*r1_n**2 + r2temp_n*r4_n**2 - testminus).n(), 0, tol)):
630                 r2 = Res[2][i]
631                 r3 = Res[3][j]
632                 break
633         if r2:
634             break
635 
636     # Now, we have r's so we can get roots
637     x1 = (r1 + r2 + r3 + r4)/5
638     x2 = (r1*zeta4 + r2*zeta3 + r3*zeta2 + r4*zeta1)/5
639     x3 = (r1*zeta3 + r2*zeta1 + r3*zeta4 + r4*zeta2)/5
640     x4 = (r1*zeta2 + r2*zeta4 + r3*zeta1 + r4*zeta3)/5
641     x5 = (r1*zeta1 + r2*zeta2 + r3*zeta3 + r4*zeta4)/5
642     result = [x1, x2, x3, x4, x5]
643 
644     # Now check if solutions are distinct
645 
646     saw = set()
647     for r in result:
648         r = r.n(2)
649         if r in saw:
650             # Roots were identical. Abort, return []
651             # and fall back to usual solve
652             return []
653         saw.add(r)
654     return result
655 
656 
657 def _quintic_simplify(expr):
658     expr = powsimp(expr)
659     expr = cancel(expr)
660     return together(expr)
661 
662 
663 def _integer_basis(poly):
664     """Compute coefficient basis for a polynomial over integers.
665 
666     Returns the integer ``div`` such that substituting ``x = div*y``
667     ``p(x) = m*q(y)`` where the coefficients of ``q`` are smaller
668     than those of ``p``.
669 
670     For example ``x**5 + 512*x + 1024 = 0``
671     with ``div = 4`` becomes ``y**5 + 2*y + 1 = 0``
672 
673     Returns the integer ``div`` or ``None`` if there is no possible scaling.
674 
675     Examples
676     ========
677 
678     >>> from sympy.polys import Poly
679     >>> from sympy.abc import x
680     >>> from sympy.polys.polyroots import _integer_basis
681     >>> p = Poly(x**5 + 512*x + 1024, x, domain='ZZ')
682     >>> _integer_basis(p)
683     4
684     """
685     monoms, coeffs = list(zip(*poly.terms()))
686 
687     monoms, = list(zip(*monoms))
688     coeffs = list(map(abs, coeffs))
689 
690     if coeffs[0] < coeffs[-1]:
691         coeffs = list(reversed(coeffs))
692         n = monoms[0]
693         monoms = [n - i for i in reversed(monoms)]
694     else:
695         return None
696 
697     monoms = monoms[:-1]
698     coeffs = coeffs[:-1]
699 
700     divs = reversed(divisors(gcd_list(coeffs))[1:])
701 
702     try:
703         div = next(divs)
704     except StopIteration:
705         return None
706 
707     while True:
708         for monom, coeff in zip(monoms, coeffs):
709             if coeff % div**monom != 0:
710                 try:
711                     div = next(divs)
712                 except StopIteration:
713                     return None
714                 else:
715                     break
716         else:
717             return div
718 
719 
720 def preprocess_roots(poly):
721     """Try to get rid of symbolic coefficients from ``poly``. """
722     coeff = S.One
723 
724     try:
725         _, poly = poly.clear_denoms(convert=True)
726     except DomainError:
727         return coeff, poly
728 
729     poly = poly.primitive()[1]
730     poly = poly.retract()
731 
732     # TODO: This is fragile. Figure out how to make this independent of construct_domain().
733     if poly.get_domain().is_Poly and all(c.is_term for c in poly.rep.coeffs()):
734         poly = poly.inject()
735 
736         strips = list(zip(*poly.monoms()))
737         gens = list(poly.gens[1:])
738 
739         base, strips = strips[0], strips[1:]
740 
741         for gen, strip in zip(list(gens), strips):
742             reverse = False
743 
744             if strip[0] < strip[-1]:
745                 strip = reversed(strip)
746                 reverse = True
747 
748             ratio = None
749 
750             for a, b in zip(base, strip):
751                 if not a and not b:
752                     continue
753                 elif not a or not b:
754                     break
755                 elif b % a != 0:
756                     break
757                 else:
758                     _ratio = b // a
759 
760                     if ratio is None:
761                         ratio = _ratio
762                     elif ratio != _ratio:
763                         break
764             else:
765                 if reverse:
766                     ratio = -ratio
767 
768                 poly = poly.eval(gen, 1)
769                 coeff *= gen**(-ratio)
770                 gens.remove(gen)
771 
772         if gens:
773             poly = poly.eject(*gens)
774 
775     if poly.is_univariate and poly.get_domain().is_ZZ:
776         basis = _integer_basis(poly)
777 
778         if basis is not None:
779             n = poly.degree()
780 
781             def func(k, coeff):
782                 return coeff//basis**(n - k[0])
783 
784             poly = poly.termwise(func)
785             coeff *= basis
786 
787     return coeff, poly
788 
789 
790 @public
791 def roots(f, *gens, **flags):
792     """
793     Computes symbolic roots of a univariate polynomial.
794 
795     Given a univariate polynomial f with symbolic coefficients (or
796     a list of the polynomial's coefficients), returns a dictionary
797     with its roots and their multiplicities.
798 
799     Only roots expressible via radicals will be returned.  To get
800     a complete set of roots use RootOf class or numerical methods
801     instead. By default cubic and quartic formulas are used in
802     the algorithm. To disable them because of unreadable output
803     set ``cubics=False`` or ``quartics=False`` respectively. If cubic
804     roots are real but are expressed in terms of complex numbers
805     (casus irreducibilis [1]) the ``trig`` flag can be set to True to
806     have the solutions returned in terms of cosine and inverse cosine
807     functions.
808 
809     To get roots from a specific domain set the ``filter`` flag with
810     one of the following specifiers: Z, Q, R, I, C. By default all
811     roots are returned (this is equivalent to setting ``filter='C'``).
812 
813     By default a dictionary is returned giving a compact result in
814     case of multiple roots.  However to get a list containing all
815     those roots set the ``multiple`` flag to True; the list will
816     have identical roots appearing next to each other in the result.
817     (For a given Poly, the all_roots method will give the roots in
818     sorted numerical order.)
819 
820     Examples
821     ========
822 
823     >>> from sympy import Poly, roots
824     >>> from sympy.abc import x, y
825 
826     >>> roots(x**2 - 1, x)
827     {-1: 1, 1: 1}
828 
829     >>> p = Poly(x**2-1, x)
830     >>> roots(p)
831     {-1: 1, 1: 1}
832 
833     >>> p = Poly(x**2-y, x, y)
834 
835     >>> roots(Poly(p, x))
836     {-sqrt(y): 1, sqrt(y): 1}
837 
838     >>> roots(x**2 - y, x)
839     {-sqrt(y): 1, sqrt(y): 1}
840 
841     >>> roots([1, 0, -1])
842     {-1: 1, 1: 1}
843 
844 
845     References
846     ==========
847 
848     1. http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
849 
850     """
851     from sympy.polys.polytools import to_rational_coeffs
852     flags = dict(flags)
853 
854     auto = flags.pop('auto', True)
855     cubics = flags.pop('cubics', True)
856     trig = flags.pop('trig', False)
857     quartics = flags.pop('quartics', True)
858     quintics = flags.pop('quintics', False)
859     multiple = flags.pop('multiple', False)
860     filter = flags.pop('filter', None)
861     predicate = flags.pop('predicate', None)
862 
863     if isinstance(f, list):
864         if gens:
865             raise ValueError('redundant generators given')
866 
867         x = Dummy('x')
868 
869         poly, i = {}, len(f) - 1
870 
871         for coeff in f:
872             poly[i], i = sympify(coeff), i - 1
873 
874         f = Poly(poly, x, field=True)
875     else:
876         try:
877             f = Poly(f, *gens, **flags)
878             if f.length == 2 and f.degree() != 1:
879                 # check for foo**n factors in the constant
880                 n = f.degree()
881                 npow_bases = []
882                 expr = f.as_expr()
883                 con = expr.as_independent(*gens)[0]
884                 for p in Mul.make_args(con):
885                     if p.is_Pow and not p.exp % n:
886                         npow_bases.append(p.base**(p.exp/n))
887                     else:
888                         other.append(p)
889                     if npow_bases:
890                         b = Mul(*npow_bases)
891                         B = Dummy()
892                         d = roots(Poly(expr - con + B**n*Mul(*others), *gens,
893                             **flags), *gens, **flags)
894                         rv = {}
895                         for k, v in d.items():
896                             rv[k.subs(B, b)] = v
897                         return rv
898 
899         except GeneratorsNeeded:
900             if multiple:
901                 return []
902             else:
903                 return {}
904 
905         if f.is_multivariate:
906             raise PolynomialError('multivariate polynomials are not supported')
907 
908     def _update_dict(result, root, k):
909         if root in result:
910             result[root] += k
911         else:
912             result[root] = k
913 
914     def _try_decompose(f):
915         """Find roots using functional decomposition. """
916         factors, roots = f.decompose(), []
917 
918         for root in _try_heuristics(factors[0]):
919             roots.append(root)
920 
921         for factor in factors[1:]:
922             previous, roots = list(roots), []
923 
924             for root in previous:
925                 g = factor - Poly(root, f.gen)
926 
927                 for root in _try_heuristics(g):
928                     roots.append(root)
929 
930         return roots
931 
932     def _try_heuristics(f):
933         """Find roots using formulas and some tricks. """
934         if f.is_ground:
935             return []
936         if f.is_monomial:
937             return [S(0)]*f.degree()
938 
939         if f.length() == 2:
940             if f.degree() == 1:
941                 return list(map(cancel, roots_linear(f)))
942             else:
943                 return roots_binomial(f)
944 
945         result = []
946 
947         for i in [-1, 1]:
948             if not f.eval(i):
949                 f = f.quo(Poly(f.gen - i, f.gen))
950                 result.append(i)
951                 break
952 
953         n = f.degree()
954 
955         if n == 1:
956             result += list(map(cancel, roots_linear(f)))
957         elif n == 2:
958             result += list(map(cancel, roots_quadratic(f)))
959         elif f.is_cyclotomic:
960             result += roots_cyclotomic(f)
961         elif n == 3 and cubics:
962             result += roots_cubic(f, trig=trig)
963         elif n == 4 and quartics:
964             result += roots_quartic(f)
965         elif n == 5 and quintics:
966             result += roots_quintic(f)
967 
968         return result
969 
970     (k,), f = f.terms_gcd()
971 
972     if not k:
973         zeros = {}
974     else:
975         zeros = {S(0): k}
976 
977     coeff, f = preprocess_roots(f)
978 
979     if auto and f.get_domain().is_Ring:
980         f = f.to_field()
981 
982     rescale_x = None
983     translate_x = None
984 
985     result = {}
986 
987     if not f.is_ground:
988         if not f.get_domain().is_Exact:
989             for r in f.nroots():
990                 _update_dict(result, r, 1)
991         elif f.degree() == 1:
992             result[roots_linear(f)[0]] = 1
993         elif f.length() == 2:
994             roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial
995             for r in roots_fun(f):
996                 _update_dict(result, r, 1)
997         else:
998             _, factors = Poly(f.as_expr()).factor_list()
999             if len(factors) == 1 and f.degree() == 2:
1000                 for r in roots_quadratic(f):
1001                     _update_dict(result, r, 1)
1002             else:
1003                 if len(factors) == 1 and factors[0][1] == 1:
1004                     if f.get_domain().is_EX:
1005                         res = to_rational_coeffs(f)
1006                         if res:
1007                             if res[0] is None:
1008                                 translate_x, f = res[2:]
1009                             else:
1010                                 rescale_x, f = res[1], res[-1]
1011                             result = roots(f)
1012                             if not result:
1013                                 for root in _try_decompose(f):
1014                                     _update_dict(result, root, 1)
1015                     else:
1016                         for root in _try_decompose(f):
1017                             _update_dict(result, root, 1)
1018                 else:
1019                     for factor, k in factors:
1020                         for r in _try_heuristics(Poly(factor, f.gen, field=True)):
1021                             _update_dict(result, r, k)
1022 
1023     if coeff is not S.One:
1024         _result, result, = result, {}
1025 
1026         for root, k in _result.items():
1027             result[coeff*root] = k
1028 
1029     result.update(zeros)
1030 
1031     if filter not in [None, 'C']:
1032         handlers = {
1033             'Z': lambda r: r.is_Integer,
1034             'Q': lambda r: r.is_Rational,
1035             'R': lambda r: r.is_real,
1036             'I': lambda r: r.is_imaginary,
1037         }
1038 
1039         try:
1040             query = handlers[filter]
1041         except KeyError:
1042             raise ValueError("Invalid filter: %s" % filter)
1043 
1044         for zero in dict(result).keys():
1045             if not query(zero):
1046                 del result[zero]
1047 
1048     if predicate is not None:
1049         for zero in dict(result).keys():
1050             if not predicate(zero):
1051                 del result[zero]
1052     if rescale_x:
1053         result1 = {}
1054         for k, v in result.items():
1055             result1[k*rescale_x] = v
1056         result = result1
1057     if translate_x:
1058         result1 = {}
1059         for k, v in result.items():
1060             result1[k + translate_x] = v
1061         result = result1
1062 
1063     if not multiple:
1064         return result
1065     else:
1066         zeros = []
1067 
1068         for zero in ordered(result):
1069             zeros.extend([zero]*result[zero])
1070 
1071         return zeros
1072 
1073 
1074 def root_factors(f, *gens, **args):
1075     """
1076     Returns all factors of a univariate polynomial.
1077 
1078     Examples
1079     ========
1080 
1081     >>> from sympy.abc import x, y
1082     >>> from sympy.polys.polyroots import root_factors
1083 
1084     >>> root_factors(x**2 - y, x)
1085     [x - sqrt(y), x + sqrt(y)]
1086 
1087     """
1088     args = dict(args)
1089     filter = args.pop('filter', None)
1090 
1091     F = Poly(f, *gens, **args)
1092 
1093     if not F.is_Poly:
1094         return [f]
1095 
1096     if F.is_multivariate:
1097         raise ValueError('multivariate polynomials are not supported')
1098 
1099     x = F.gens[0]
1100 
1101     zeros = roots(F, filter=filter)
1102 
1103     if not zeros:
1104         factors = [F]
1105     else:
1106         factors, N = [], 0
1107 
1108         for r, n in ordered(zeros.items()):
1109             factors, N = factors + [Poly(x - r, x)]*n, N + n
1110 
1111         if N < F.degree():
1112             G = reduce(lambda p, q: p*q, factors)
1113             factors.append(F.quo(G))
1114 
1115     if not isinstance(f, Poly):
1116         factors = [ f.as_expr() for f in factors ]
1117 
1118     return factors

</code><intended_behavior>The roots function should ensure that it can find roots of symbolic characteristic polynomials derived from matrices with symbolic entries more reliably. This could include enhancements in the algorithm to handle complex symbolic expressions or leveraging additional symbolic solving capabilities of SymPy that might not currently be utilized to their full potential.</intended_behavior>]
2025-10-18 07:58:52.740 | INFO     | Search completed. Bug locations: [<file>sympy/matrices/matrices.py</file>
<class>None</class>
<method>eigenvals</method>
<code>
1094     def eigenvals(self, error_when_incomplete=True, **flags):
1095         """Return eigenvalues using the Berkowitz agorithm to compute
1096         the characteristic polynomial.
1097 
1098         Parameters
1099         ==========
1100 
1101         error_when_incomplete : bool
1102             Raise an error when not all eigenvalues are computed. This is
1103             caused by ``roots`` not returning a full list of eigenvalues.
1104 
1105         Since the roots routine doesn't always work well with Floats,
1106         they will be replaced with Rationals before calling that
1107         routine. If this is not desired, set flag ``rational`` to False.
1108         """
1109         mat = self
1110         if not mat:
1111             return {}
1112         if flags.pop('rational', True):
1113             if any(v.has(Float) for v in mat):
1114                 mat = mat.applyfunc(lambda x: nsimplify(x, rational=True))
1115 
1116         flags.pop('simplify', None)  # pop unsupported flag
1117         eigs = roots(mat.charpoly(x=Dummy('x')), **flags)
1118 
1119         # make sure the algebraic multiplicty sums to the
1120         # size of the matrix
1121         if error_when_incomplete and sum(m for m in eigs.values()) != self.cols:
1122             raise MatrixError("Could not compute eigenvalues for {}".format(self))
1123 
1124         return eigs

</code><intended_behavior>The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions.</intended_behavior>, <file>sympy/matrices/matrices.py</file>
<class>MatrixEigen</class>
<method>eigenvals</method>
<code>
1094     def eigenvals(self, error_when_incomplete=True, **flags):
1095         """Return eigenvalues using the Berkowitz agorithm to compute
1096         the characteristic polynomial.
1097 
1098         Parameters
1099         ==========
1100 
1101         error_when_incomplete : bool
1102             Raise an error when not all eigenvalues are computed. This is
1103             caused by ``roots`` not returning a full list of eigenvalues.
1104 
1105         Since the roots routine doesn't always work well with Floats,
1106         they will be replaced with Rationals before calling that
1107         routine. If this is not desired, set flag ``rational`` to False.
1108         """
1109         mat = self
1110         if not mat:
1111             return {}
1112         if flags.pop('rational', True):
1113             if any(v.has(Float) for v in mat):
1114                 mat = mat.applyfunc(lambda x: nsimplify(x, rational=True))
1115 
1116         flags.pop('simplify', None)  # pop unsupported flag
1117         eigs = roots(mat.charpoly(x=Dummy('x')), **flags)
1118 
1119         # make sure the algebraic multiplicty sums to the
1120         # size of the matrix
1121         if error_when_incomplete and sum(m for m in eigs.values()) != self.cols:
1122             raise MatrixError("Could not compute eigenvalues for {}".format(self))
1123 
1124         return eigs

</code><intended_behavior>The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions.</intended_behavior>, <file>sympy/polys/polyroots.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Algorithms for computing symbolic roots of polynomials. """
2 
3 from __future__ import print_function, division
4 
5 import math
6 
7 from sympy.core.symbol import Dummy, Symbol, symbols
8 from sympy.core import S, I, pi
9 from sympy.core.compatibility import ordered
10 from sympy.core.mul import expand_2arg, Mul
11 from sympy.core.power import Pow
12 from sympy.core.relational import Eq
13 from sympy.core.sympify import sympify
14 from sympy.core.numbers import Rational, igcd, comp
15 from sympy.core.exprtools import factor_terms
16 from sympy.core.logic import fuzzy_not
17 
18 from sympy.ntheory import divisors, isprime, nextprime
19 from sympy.functions import exp, sqrt, im, cos, acos, Piecewise
20 from sympy.functions.elementary.miscellaneous import root
21 
22 from sympy.polys.polytools import Poly, cancel, factor, gcd_list, discriminant
23 from sympy.polys.specialpolys import cyclotomic_poly
24 from sympy.polys.polyerrors import (PolynomialError, GeneratorsNeeded,
25     DomainError)
26 from sympy.polys.polyquinticconst import PolyQuintic
27 from sympy.polys.rationaltools import together
28 
29 from sympy.simplify import simplify, powsimp
30 from sympy.utilities import public
31 
32 from sympy.core.compatibility import reduce, range
33 
34 
35 def roots_linear(f):
36     """Returns a list of roots of a linear polynomial."""
37     r = -f.nth(0)/f.nth(1)
38     dom = f.get_domain()
39 
40     if not dom.is_Numerical:
41         if dom.is_Composite:
42             r = factor(r)
43         else:
44             r = simplify(r)
45 
46     return [r]
47 
48 
49 def roots_quadratic(f):
50     """Returns a list of roots of a quadratic polynomial. If the domain is ZZ
51     then the roots will be sorted with negatives coming before positives.
52     The ordering will be the same for any numerical coefficients as long as
53     the assumptions tested are correct, otherwise the ordering will not be
54     sorted (but will be canonical).
55     """
56 
57     a, b, c = f.all_coeffs()
58     dom = f.get_domain()
59 
60     def _sqrt(d):
61         # remove squares from square root since both will be represented
62         # in the results; a similar thing is happening in roots() but
63         # must be duplicated here because not all quadratics are binomials
64         co = []
65         other = []
66         for di in Mul.make_args(d):
67             if di.is_Pow and di.exp.is_Integer and di.exp % 2 == 0:
68                 co.append(Pow(di.base, di.exp//2))
69             else:
70                 other.append(di)
71         if co:
72             d = Mul(*other)
73             co = Mul(*co)
74             return co*sqrt(d)
75         return sqrt(d)
76 
77     def _simplify(expr):
78         if dom.is_Composite:
79             return factor(expr)
80         else:
81             return simplify(expr)
82 
83     if c is S.Zero:
84         r0, r1 = S.Zero, -b/a
85 
86         if not dom.is_Numerical:
87             r1 = _simplify(r1)
88         elif r1.is_negative:
89             r0, r1 = r1, r0
90     elif b is S.Zero:
91         r = -c/a
92         if not dom.is_Numerical:
93             r = _simplify(r)
94 
95         R = _sqrt(r)
96         r0 = -R
97         r1 = R
98     else:
99         d = b**2 - 4*a*c
100         A = 2*a
101         B = -b/A
102 
103         if not dom.is_Numerical:
104             d = _simplify(d)
105             B = _simplify(B)
106 
107         D = factor_terms(_sqrt(d)/A)
108         r0 = B - D
109         r1 = B + D
110         if a.is_negative:
111             r0, r1 = r1, r0
112         elif not dom.is_Numerical:
113             r0, r1 = [expand_2arg(i) for i in (r0, r1)]
114 
115     return [r0, r1]
116 
117 
118 def roots_cubic(f, trig=False):
119     """Returns a list of roots of a cubic polynomial.
120 
121     References
122     ==========
123     [1] https://en.wikipedia.org/wiki/Cubic_function, General formula for roots,
124     (accessed November 17, 2014).
125     """
126     if trig:
127         a, b, c, d = f.all_coeffs()
128         p = (3*a*c - b**2)/3/a**2
129         q = (2*b**3 - 9*a*b*c + 27*a**2*d)/(27*a**3)
130         D = 18*a*b*c*d - 4*b**3*d + b**2*c**2 - 4*a*c**3 - 27*a**2*d**2
131         if (D > 0) == True:
132             rv = []
133             for k in range(3):
134                 rv.append(2*sqrt(-p/3)*cos(acos(3*q/2/p*sqrt(-3/p))/3 - k*2*pi/3))
135             return [i - b/3/a for i in rv]
136 
137     _, a, b, c = f.monic().all_coeffs()
138 
139     if c is S.Zero:
140         x1, x2 = roots([1, a, b], multiple=True)
141         return [x1, S.Zero, x2]
142 
143     p = b - a**2/3
144     q = c - a*b/3 + 2*a**3/27
145 
146     pon3 = p/3
147     aon3 = a/3
148 
149     u1 = None
150     if p is S.Zero:
151         if q is S.Zero:
152             return [-aon3]*3
153         if q.is_real:
154             if q.is_positive:
155                 u1 = -root(q, 3)
156             elif q.is_negative:
157                 u1 = root(-q, 3)
158     elif q is S.Zero:
159         y1, y2 = roots([1, 0, p], multiple=True)
160         return [tmp - aon3 for tmp in [y1, S.Zero, y2]]
161     elif q.is_real and q.is_negative:
162         u1 = -root(-q/2 + sqrt(q**2/4 + pon3**3), 3)
163 
164     coeff = I*sqrt(3)/2
165     if u1 is None:
166         u1 = S(1)
167         u2 = -S.Half + coeff
168         u3 = -S.Half - coeff
169         a, b, c, d = S(1), a, b, c
170         D0 = b**2 - 3*a*c
171         D1 = 2*b**3 - 9*a*b*c + 27*a**2*d
172         C = root((D1 + sqrt(D1**2 - 4*D0**3))/2, 3)
173         return [-(b + uk*C + D0/C/uk)/3/a for uk in [u1, u2, u3]]
174 
175     u2 = u1*(-S.Half + coeff)
176     u3 = u1*(-S.Half - coeff)
177 
178     if p is S.Zero:
179         return [u1 - aon3, u2 - aon3, u3 - aon3]
180 
181     soln = [
182         -u1 + pon3/u1 - aon3,
183         -u2 + pon3/u2 - aon3,
184         -u3 + pon3/u3 - aon3
185     ]
186 
187     return soln
188 
189 def _roots_quartic_euler(p, q, r, a):
190     """
191     Descartes-Euler solution of the quartic equation
192 
193     Parameters
194     ==========
195 
196     p, q, r: coefficients of ``x**4 + p*x**2 + q*x + r``
197     a: shift of the roots
198 
199     Notes
200     =====
201 
202     This is a helper function for ``roots_quartic``.
203 
204     Look for solutions of the form ::
205 
206       ``x1 = sqrt(R) - sqrt(A + B*sqrt(R))``
207       ``x2 = -sqrt(R) - sqrt(A - B*sqrt(R))``
208       ``x3 = -sqrt(R) + sqrt(A - B*sqrt(R))``
209       ``x4 = sqrt(R) + sqrt(A + B*sqrt(R))``
210 
211     To satisfy the quartic equation one must have
212     ``p = -2*(R + A); q = -4*B*R; r = (R - A)**2 - B**2*R``
213     so that ``R`` must satisfy the Descartes-Euler resolvent equation
214     ``64*R**3 + 32*p*R**2 + (4*p**2 - 16*r)*R - q**2 = 0``
215 
216     If the resolvent does not have a rational solution, return None;
217     in that case it is likely that the Ferrari method gives a simpler
218     solution.
219 
220     Examples
221     ========
222 
223     >>> from sympy import S
224     >>> from sympy.polys.polyroots import _roots_quartic_euler
225     >>> p, q, r = -S(64)/5, -S(512)/125, -S(1024)/3125
226     >>> _roots_quartic_euler(p, q, r, S(0))[0]
227     -sqrt(32*sqrt(5)/125 + 16/5) + 4*sqrt(5)/5
228     """
229     # solve the resolvent equation
230     x = Symbol('x')
231     eq = 64*x**3 + 32*p*x**2 + (4*p**2 - 16*r)*x - q**2
232     xsols = list(roots(Poly(eq, x), cubics=False).keys())
233     xsols = [sol for sol in xsols if sol.is_rational]
234     if not xsols:
235         return None
236     R = max(xsols)
237     c1 = sqrt(R)
238     B = -q*c1/(4*R)
239     A = -R - p/2
240     c2 = sqrt(A + B)
241     c3 = sqrt(A - B)
242     return [c1 - c2 - a, -c1 - c3 - a, -c1 + c3 - a, c1 + c2 - a]
243 
244 
245 def roots_quartic(f):
246     r"""
247     Returns a list of roots of a quartic polynomial.
248 
249     There are many references for solving quartic expressions available [1-5].
250     This reviewer has found that many of them require one to select from among
251     2 or more possible sets of solutions and that some solutions work when one
252     is searching for real roots but don't work when searching for complex roots
253     (though this is not always stated clearly). The following routine has been
254     tested and found to be correct for 0, 2 or 4 complex roots.
255 
256     The quasisymmetric case solution [6] looks for quartics that have the form
257     `x**4 + A*x**3 + B*x**2 + C*x + D = 0` where `(C/A)**2 = D`.
258 
259     Although no general solution that is always applicable for all
260     coefficients is known to this reviewer, certain conditions are tested
261     to determine the simplest 4 expressions that can be returned:
262 
263       1) `f = c + a*(a**2/8 - b/2) == 0`
264       2) `g = d - a*(a*(3*a**2/256 - b/16) + c/4) = 0`
265       3) if `f != 0` and `g != 0` and `p = -d + a*c/4 - b**2/12` then
266         a) `p == 0`
267         b) `p != 0`
268 
269     Examples
270     ========
271 
272         >>> from sympy import Poly, symbols, I
273         >>> from sympy.polys.polyroots import roots_quartic
274 
275         >>> r = roots_quartic(Poly('x**4-6*x**3+17*x**2-26*x+20'))
276 
277         >>> # 4 complex roots: 1+-I*sqrt(3), 2+-I
278         >>> sorted(str(tmp.evalf(n=2)) for tmp in r)
279         ['1.0 + 1.7*I', '1.0 - 1.7*I', '2.0 + 1.0*I', '2.0 - 1.0*I']
280 
281     References
282     ==========
283 
284     1. http://mathforum.org/dr.math/faq/faq.cubic.equations.html
285     2. http://en.wikipedia.org/wiki/Quartic_function#Summary_of_Ferrari.27s_method
286     3. http://planetmath.org/encyclopedia/GaloisTheoreticDerivationOfTheQuarticFormula.html
287     4. http://staff.bath.ac.uk/masjhd/JHD-CA.pdf
288     5. http://www.albmath.org/files/Math_5713.pdf
289     6. http://www.statemaster.com/encyclopedia/Quartic-equation
290     7. eqworld.ipmnet.ru/en/solutions/ae/ae0108.pdf
291     """
292     _, a, b, c, d = f.monic().all_coeffs()
293 
294     if not d:
295         return [S.Zero] + roots([1, a, b, c], multiple=True)
296     elif (c/a)**2 == d:
297         x, m = f.gen, c/a
298 
299         g = Poly(x**2 + a*x + b - 2*m, x)
300 
301         z1, z2 = roots_quadratic(g)
302 
303         h1 = Poly(x**2 - z1*x + m, x)
304         h2 = Poly(x**2 - z2*x + m, x)
305 
306         r1 = roots_quadratic(h1)
307         r2 = roots_quadratic(h2)
308 
309         return r1 + r2
310     else:
311         a2 = a**2
312         e = b - 3*a2/8
313         f = c + a*(a2/8 - b/2)
314         g = d - a*(a*(3*a2/256 - b/16) + c/4)
315         aon4 = a/4
316 
317         if f is S.Zero:
318             y1, y2 = [sqrt(tmp) for tmp in
319                       roots([1, e, g], multiple=True)]
320             return [tmp - aon4 for tmp in [-y1, -y2, y1, y2]]
321         if g is S.Zero:
322             y = [S.Zero] + roots([1, 0, e, f], multiple=True)
323             return [tmp - aon4 for tmp in y]
324         else:
325             # Descartes-Euler method, see [7]
326             sols = _roots_quartic_euler(e, f, g, aon4)
327             if sols:
328                 return sols
329             # Ferrari method, see [1, 2]
330             a2 = a**2
331             e = b - 3*a2/8
332             f = c + a*(a2/8 - b/2)
333             g = d - a*(a*(3*a2/256 - b/16) + c/4)
334             p = -e**2/12 - g
335             q = -e**3/108 + e*g/3 - f**2/8
336             TH = Rational(1, 3)
337 
338             def _ans(y):
339                 w = sqrt(e + 2*y)
340                 arg1 = 3*e + 2*y
341                 arg2 = 2*f/w
342                 ans = []
343                 for s in [-1, 1]:
344                     root = sqrt(-(arg1 + s*arg2))
345                     for t in [-1, 1]:
346                         ans.append((s*w - t*root)/2 - aon4)
347                 return ans
348 
349             # p == 0 case
350             y1 = -5*e/6 - q**TH
351             if p.is_zero:
352                 return _ans(y1)
353 
354             # if p != 0 then u below is not 0
355             root = sqrt(q**2/4 + p**3/27)
356             r = -q/2 + root  # or -q/2 - root
357             u = r**TH  # primary root of solve(x**3 - r, x)
358             y2 = -5*e/6 + u - p/u/3
359             if fuzzy_not(p.is_zero):
360                 return _ans(y2)
361 
362             # sort it out once they know the values of the coefficients
363             return [Piecewise((a1, Eq(p, 0)), (a2, True))
364                 for a1, a2 in zip(_ans(y1), _ans(y2))]
365 
366 
367 def roots_binomial(f):
368     """Returns a list of roots of a binomial polynomial. If the domain is ZZ
369     then the roots will be sorted with negatives coming before positives.
370     The ordering will be the same for any numerical coefficients as long as
371     the assumptions tested are correct, otherwise the ordering will not be
372     sorted (but will be canonical).
373     """
374     n = f.degree()
375 
376     a, b = f.nth(n), f.nth(0)
377     base = -cancel(b/a)
378     alpha = root(base, n)
379 
380     if alpha.is_number:
381         alpha = alpha.expand(complex=True)
382 
383     # define some parameters that will allow us to order the roots.
384     # If the domain is ZZ this is guaranteed to return roots sorted
385     # with reals before non-real roots and non-real sorted according
386     # to real part and imaginary part, e.g. -1, 1, -1 + I, 2 - I
387     neg = base.is_negative
388     even = n % 2 == 0
389     if neg:
390         if even == True and (base + 1).is_positive:
391             big = True
392         else:
393             big = False
394 
395     # get the indices in the right order so the computed
396     # roots will be sorted when the domain is ZZ
397     ks = []
398     imax = n//2
399     if even:
400         ks.append(imax)
401         imax -= 1
402     if not neg:
403         ks.append(0)
404     for i in range(imax, 0, -1):
405         if neg:
406             ks.extend([i, -i])
407         else:
408             ks.extend([-i, i])
409     if neg:
410         ks.append(0)
411         if big:
412             for i in range(0, len(ks), 2):
413                 pair = ks[i: i + 2]
414                 pair = list(reversed(pair))
415 
416     # compute the roots
417     roots, d = [], 2*I*pi/n
418     for k in ks:
419         zeta = exp(k*d).expand(complex=True)
420         roots.append((alpha*zeta).expand(power_base=False))
421 
422     return roots
423 
424 
425 def _inv_totient_estimate(m):
426     """
427     Find ``(L, U)`` such that ``L <= phi^-1(m) <= U``.
428 
429     Examples
430     ========
431 
432     >>> from sympy.polys.polyroots import _inv_totient_estimate
433 
434     >>> _inv_totient_estimate(192)
435     (192, 840)
436     >>> _inv_totient_estimate(400)
437     (400, 1750)
438 
439     """
440     primes = [ d + 1 for d in divisors(m) if isprime(d + 1) ]
441 
442     a, b = 1, 1
443 
444     for p in primes:
445         a *= p
446         b *= p - 1
447 
448     L = m
449     U = int(math.ceil(m*(float(a)/b)))
450 
451     P = p = 2
452     primes = []
453 
454     while P <= U:
455         p = nextprime(p)
456         primes.append(p)
457         P *= p
458 
459     P //= p
460     b = 1
461 
462     for p in primes[:-1]:
463         b *= p - 1
464 
465     U = int(math.ceil(m*(float(P)/b)))
466 
467     return L, U
468 
469 
470 def roots_cyclotomic(f, factor=False):
471     """Compute roots of cyclotomic polynomials. """
472     L, U = _inv_totient_estimate(f.degree())
473 
474     for n in range(L, U + 1):
475         g = cyclotomic_poly(n, f.gen, polys=True)
476 
477         if f == g:
478             break
479     else:  # pragma: no cover
480         raise RuntimeError("failed to find index of a cyclotomic polynomial")
481 
482     roots = []
483 
484     if not factor:
485         # get the indices in the right order so the computed
486         # roots will be sorted
487         h = n//2
488         ks = [i for i in range(1, n + 1) if igcd(i, n) == 1]
489         ks.sort(key=lambda x: (x, -1) if x <= h else (abs(x - n), 1))
490         d = 2*I*pi/n
491         for k in reversed(ks):
492             roots.append(exp(k*d).expand(complex=True))
493     else:
494         g = Poly(f, extension=root(-1, n))
495 
496         for h, _ in ordered(g.factor_list()[1]):
497             roots.append(-h.TC())
498 
499     return roots
500 
501 
502 def roots_quintic(f):
503     """
504     Calulate exact roots of a solvable quintic
505     """
506     result = []
507     coeff_5, coeff_4, p, q, r, s = f.all_coeffs()
508 
509     # Eqn must be of the form x^5 + px^3 + qx^2 + rx + s
510     if coeff_4:
511         return result
512 
513     if coeff_5 != 1:
514         l = [p/coeff_5, q/coeff_5, r/coeff_5, s/coeff_5]
515         if not all(coeff.is_Rational for coeff in l):
516             return result
517         f = Poly(f/coeff_5)
518     quintic = PolyQuintic(f)
519 
520     # Eqn standardized. Algo for solving starts here
521     if not f.is_irreducible:
522         return result
523 
524     f20 = quintic.f20
525     # Check if f20 has linear factors over domain Z
526     if f20.is_irreducible:
527         return result
528 
529     # Now, we know that f is solvable
530     for _factor in f20.factor_list()[1]:
531         if _factor[0].is_linear:
532             theta = _factor[0].root(0)
533             break
534     d = discriminant(f)
535     delta = sqrt(d)
536     # zeta = a fifth root of unity
537     zeta1, zeta2, zeta3, zeta4 = quintic.zeta
538     T = quintic.T(theta, d)
539     tol = S(1e-10)
540     alpha = T[1] + T[2]*delta
541     alpha_bar = T[1] - T[2]*delta
542     beta = T[3] + T[4]*delta
543     beta_bar = T[3] - T[4]*delta
544 
545     disc = alpha**2 - 4*beta
546     disc_bar = alpha_bar**2 - 4*beta_bar
547 
548     l0 = quintic.l0(theta)
549 
550     l1 = _quintic_simplify((-alpha + sqrt(disc)) / S(2))
551     l4 = _quintic_simplify((-alpha - sqrt(disc)) / S(2))
552 
553     l2 = _quintic_simplify((-alpha_bar + sqrt(disc_bar)) / S(2))
554     l3 = _quintic_simplify((-alpha_bar - sqrt(disc_bar)) / S(2))
555 
556     order = quintic.order(theta, d)
557     test = (order*delta.n()) - ( (l1.n() - l4.n())*(l2.n() - l3.n()) )
558     # Comparing floats
559     if not comp(test, 0, tol):
560         l2, l3 = l3, l2
561 
562     # Now we have correct order of l's
563     R1 = l0 + l1*zeta1 + l2*zeta2 + l3*zeta3 + l4*zeta4
564     R2 = l0 + l3*zeta1 + l1*zeta2 + l4*zeta3 + l2*zeta4
565     R3 = l0 + l2*zeta1 + l4*zeta2 + l1*zeta3 + l3*zeta4
566     R4 = l0 + l4*zeta1 + l3*zeta2 + l2*zeta3 + l1*zeta4
567 
568     Res = [None, [None]*5, [None]*5, [None]*5, [None]*5]
569     Res_n = [None, [None]*5, [None]*5, [None]*5, [None]*5]
570     sol = Symbol('sol')
571 
572     # Simplifying improves performace a lot for exact expressions
573     R1 = _quintic_simplify(R1)
574     R2 = _quintic_simplify(R2)
575     R3 = _quintic_simplify(R3)
576     R4 = _quintic_simplify(R4)
577 
578     # Solve imported here. Causing problems if imported as 'solve'
579     # and hence the changed name
580     from sympy.solvers.solvers import solve as _solve
581     a, b = symbols('a b', cls=Dummy)
582     _sol = _solve( sol**5 - a - I*b, sol)
583     for i in range(5):
584         _sol[i] = factor(_sol[i])
585     R1 = R1.as_real_imag()
586     R2 = R2.as_real_imag()
587     R3 = R3.as_real_imag()
588     R4 = R4.as_real_imag()
589 
590     for i, root in enumerate(_sol):
591         Res[1][i] = _quintic_simplify(root.subs({ a: R1[0], b: R1[1] }))
592         Res[2][i] = _quintic_simplify(root.subs({ a: R2[0], b: R2[1] }))
593         Res[3][i] = _quintic_simplify(root.subs({ a: R3[0], b: R3[1] }))
594         Res[4][i] = _quintic_simplify(root.subs({ a: R4[0], b: R4[1] }))
595 
596     for i in range(1, 5):
597         for j in range(5):
598             Res_n[i][j] = Res[i][j].n()
599             Res[i][j] = _quintic_simplify(Res[i][j])
600     r1 = Res[1][0]
601     r1_n = Res_n[1][0]
602 
603     for i in range(5):
604         if comp(im(r1_n*Res_n[4][i]), 0, tol):
605             r4 = Res[4][i]
606             break
607 
608     u, v = quintic.uv(theta, d)
609     sqrt5 = math.sqrt(5)
610 
611     # Now we have various Res values. Each will be a list of five
612     # values. We have to pick one r value from those five for each Res
613     u, v = quintic.uv(theta, d)
614     testplus = (u + v*delta*sqrt(5)).n()
615     testminus = (u - v*delta*sqrt(5)).n()
616 
617     # Evaluated numbers suffixed with _n
618     # We will use evaluated numbers for calculation. Much faster.
619     r4_n = r4.n()
620     r2 = r3 = None
621 
622     for i in range(5):
623         r2temp_n = Res_n[2][i]
624         for j in range(5):
625             # Again storing away the exact number and using
626             # evaluated numbers in computations
627             r3temp_n = Res_n[3][j]
628             if (comp((r1_n*r2temp_n**2 + r4_n*r3temp_n**2 - testplus).n(), 0, tol) and
629                 comp((r3temp_n*r1_n**2 + r2temp_n*r4_n**2 - testminus).n(), 0, tol)):
630                 r2 = Res[2][i]
631                 r3 = Res[3][j]
632                 break
633         if r2:
634             break
635 
636     # Now, we have r's so we can get roots
637     x1 = (r1 + r2 + r3 + r4)/5
638     x2 = (r1*zeta4 + r2*zeta3 + r3*zeta2 + r4*zeta1)/5
639     x3 = (r1*zeta3 + r2*zeta1 + r3*zeta4 + r4*zeta2)/5
640     x4 = (r1*zeta2 + r2*zeta4 + r3*zeta1 + r4*zeta3)/5
641     x5 = (r1*zeta1 + r2*zeta2 + r3*zeta3 + r4*zeta4)/5
642     result = [x1, x2, x3, x4, x5]
643 
644     # Now check if solutions are distinct
645 
646     saw = set()
647     for r in result:
648         r = r.n(2)
649         if r in saw:
650             # Roots were identical. Abort, return []
651             # and fall back to usual solve
652             return []
653         saw.add(r)
654     return result
655 
656 
657 def _quintic_simplify(expr):
658     expr = powsimp(expr)
659     expr = cancel(expr)
660     return together(expr)
661 
662 
663 def _integer_basis(poly):
664     """Compute coefficient basis for a polynomial over integers.
665 
666     Returns the integer ``div`` such that substituting ``x = div*y``
667     ``p(x) = m*q(y)`` where the coefficients of ``q`` are smaller
668     than those of ``p``.
669 
670     For example ``x**5 + 512*x + 1024 = 0``
671     with ``div = 4`` becomes ``y**5 + 2*y + 1 = 0``
672 
673     Returns the integer ``div`` or ``None`` if there is no possible scaling.
674 
675     Examples
676     ========
677 
678     >>> from sympy.polys import Poly
679     >>> from sympy.abc import x
680     >>> from sympy.polys.polyroots import _integer_basis
681     >>> p = Poly(x**5 + 512*x + 1024, x, domain='ZZ')
682     >>> _integer_basis(p)
683     4
684     """
685     monoms, coeffs = list(zip(*poly.terms()))
686 
687     monoms, = list(zip(*monoms))
688     coeffs = list(map(abs, coeffs))
689 
690     if coeffs[0] < coeffs[-1]:
691         coeffs = list(reversed(coeffs))
692         n = monoms[0]
693         monoms = [n - i for i in reversed(monoms)]
694     else:
695         return None
696 
697     monoms = monoms[:-1]
698     coeffs = coeffs[:-1]
699 
700     divs = reversed(divisors(gcd_list(coeffs))[1:])
701 
702     try:
703         div = next(divs)
704     except StopIteration:
705         return None
706 
707     while True:
708         for monom, coeff in zip(monoms, coeffs):
709             if coeff % div**monom != 0:
710                 try:
711                     div = next(divs)
712                 except StopIteration:
713                     return None
714                 else:
715                     break
716         else:
717             return div
718 
719 
720 def preprocess_roots(poly):
721     """Try to get rid of symbolic coefficients from ``poly``. """
722     coeff = S.One
723 
724     try:
725         _, poly = poly.clear_denoms(convert=True)
726     except DomainError:
727         return coeff, poly
728 
729     poly = poly.primitive()[1]
730     poly = poly.retract()
731 
732     # TODO: This is fragile. Figure out how to make this independent of construct_domain().
733     if poly.get_domain().is_Poly and all(c.is_term for c in poly.rep.coeffs()):
734         poly = poly.inject()
735 
736         strips = list(zip(*poly.monoms()))
737         gens = list(poly.gens[1:])
738 
739         base, strips = strips[0], strips[1:]
740 
741         for gen, strip in zip(list(gens), strips):
742             reverse = False
743 
744             if strip[0] < strip[-1]:
745                 strip = reversed(strip)
746                 reverse = True
747 
748             ratio = None
749 
750             for a, b in zip(base, strip):
751                 if not a and not b:
752                     continue
753                 elif not a or not b:
754                     break
755                 elif b % a != 0:
756                     break
757                 else:
758                     _ratio = b // a
759 
760                     if ratio is None:
761                         ratio = _ratio
762                     elif ratio != _ratio:
763                         break
764             else:
765                 if reverse:
766                     ratio = -ratio
767 
768                 poly = poly.eval(gen, 1)
769                 coeff *= gen**(-ratio)
770                 gens.remove(gen)
771 
772         if gens:
773             poly = poly.eject(*gens)
774 
775     if poly.is_univariate and poly.get_domain().is_ZZ:
776         basis = _integer_basis(poly)
777 
778         if basis is not None:
779             n = poly.degree()
780 
781             def func(k, coeff):
782                 return coeff//basis**(n - k[0])
783 
784             poly = poly.termwise(func)
785             coeff *= basis
786 
787     return coeff, poly
788 
789 
790 @public
791 def roots(f, *gens, **flags):
792     """
793     Computes symbolic roots of a univariate polynomial.
794 
795     Given a univariate polynomial f with symbolic coefficients (or
796     a list of the polynomial's coefficients), returns a dictionary
797     with its roots and their multiplicities.
798 
799     Only roots expressible via radicals will be returned.  To get
800     a complete set of roots use RootOf class or numerical methods
801     instead. By default cubic and quartic formulas are used in
802     the algorithm. To disable them because of unreadable output
803     set ``cubics=False`` or ``quartics=False`` respectively. If cubic
804     roots are real but are expressed in terms of complex numbers
805     (casus irreducibilis [1]) the ``trig`` flag can be set to True to
806     have the solutions returned in terms of cosine and inverse cosine
807     functions.
808 
809     To get roots from a specific domain set the ``filter`` flag with
810     one of the following specifiers: Z, Q, R, I, C. By default all
811     roots are returned (this is equivalent to setting ``filter='C'``).
812 
813     By default a dictionary is returned giving a compact result in
814     case of multiple roots.  However to get a list containing all
815     those roots set the ``multiple`` flag to True; the list will
816     have identical roots appearing next to each other in the result.
817     (For a given Poly, the all_roots method will give the roots in
818     sorted numerical order.)
819 
820     Examples
821     ========
822 
823     >>> from sympy import Poly, roots
824     >>> from sympy.abc import x, y
825 
826     >>> roots(x**2 - 1, x)
827     {-1: 1, 1: 1}
828 
829     >>> p = Poly(x**2-1, x)
830     >>> roots(p)
831     {-1: 1, 1: 1}
832 
833     >>> p = Poly(x**2-y, x, y)
834 
835     >>> roots(Poly(p, x))
836     {-sqrt(y): 1, sqrt(y): 1}
837 
838     >>> roots(x**2 - y, x)
839     {-sqrt(y): 1, sqrt(y): 1}
840 
841     >>> roots([1, 0, -1])
842     {-1: 1, 1: 1}
843 
844 
845     References
846     ==========
847 
848     1. http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
849 
850     """
851     from sympy.polys.polytools import to_rational_coeffs
852     flags = dict(flags)
853 
854     auto = flags.pop('auto', True)
855     cubics = flags.pop('cubics', True)
856     trig = flags.pop('trig', False)
857     quartics = flags.pop('quartics', True)
858     quintics = flags.pop('quintics', False)
859     multiple = flags.pop('multiple', False)
860     filter = flags.pop('filter', None)
861     predicate = flags.pop('predicate', None)
862 
863     if isinstance(f, list):
864         if gens:
865             raise ValueError('redundant generators given')
866 
867         x = Dummy('x')
868 
869         poly, i = {}, len(f) - 1
870 
871         for coeff in f:
872             poly[i], i = sympify(coeff), i - 1
873 
874         f = Poly(poly, x, field=True)
875     else:
876         try:
877             f = Poly(f, *gens, **flags)
878             if f.length == 2 and f.degree() != 1:
879                 # check for foo**n factors in the constant
880                 n = f.degree()
881                 npow_bases = []
882                 expr = f.as_expr()
883                 con = expr.as_independent(*gens)[0]
884                 for p in Mul.make_args(con):
885                     if p.is_Pow and not p.exp % n:
886                         npow_bases.append(p.base**(p.exp/n))
887                     else:
888                         other.append(p)
889                     if npow_bases:
890                         b = Mul(*npow_bases)
891                         B = Dummy()
892                         d = roots(Poly(expr - con + B**n*Mul(*others), *gens,
893                             **flags), *gens, **flags)
894                         rv = {}
895                         for k, v in d.items():
896                             rv[k.subs(B, b)] = v
897                         return rv
898 
899         except GeneratorsNeeded:
900             if multiple:
901                 return []
902             else:
903                 return {}
904 
905         if f.is_multivariate:
906             raise PolynomialError('multivariate polynomials are not supported')
907 
908     def _update_dict(result, root, k):
909         if root in result:
910             result[root] += k
911         else:
912             result[root] = k
913 
914     def _try_decompose(f):
915         """Find roots using functional decomposition. """
916         factors, roots = f.decompose(), []
917 
918         for root in _try_heuristics(factors[0]):
919             roots.append(root)
920 
921         for factor in factors[1:]:
922             previous, roots = list(roots), []
923 
924             for root in previous:
925                 g = factor - Poly(root, f.gen)
926 
927                 for root in _try_heuristics(g):
928                     roots.append(root)
929 
930         return roots
931 
932     def _try_heuristics(f):
933         """Find roots using formulas and some tricks. """
934         if f.is_ground:
935             return []
936         if f.is_monomial:
937             return [S(0)]*f.degree()
938 
939         if f.length() == 2:
940             if f.degree() == 1:
941                 return list(map(cancel, roots_linear(f)))
942             else:
943                 return roots_binomial(f)
944 
945         result = []
946 
947         for i in [-1, 1]:
948             if not f.eval(i):
949                 f = f.quo(Poly(f.gen - i, f.gen))
950                 result.append(i)
951                 break
952 
953         n = f.degree()
954 
955         if n == 1:
956             result += list(map(cancel, roots_linear(f)))
957         elif n == 2:
958             result += list(map(cancel, roots_quadratic(f)))
959         elif f.is_cyclotomic:
960             result += roots_cyclotomic(f)
961         elif n == 3 and cubics:
962             result += roots_cubic(f, trig=trig)
963         elif n == 4 and quartics:
964             result += roots_quartic(f)
965         elif n == 5 and quintics:
966             result += roots_quintic(f)
967 
968         return result
969 
970     (k,), f = f.terms_gcd()
971 
972     if not k:
973         zeros = {}
974     else:
975         zeros = {S(0): k}
976 
977     coeff, f = preprocess_roots(f)
978 
979     if auto and f.get_domain().is_Ring:
980         f = f.to_field()
981 
982     rescale_x = None
983     translate_x = None
984 
985     result = {}
986 
987     if not f.is_ground:
988         if not f.get_domain().is_Exact:
989             for r in f.nroots():
990                 _update_dict(result, r, 1)
991         elif f.degree() == 1:
992             result[roots_linear(f)[0]] = 1
993         elif f.length() == 2:
994             roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial
995             for r in roots_fun(f):
996                 _update_dict(result, r, 1)
997         else:
998             _, factors = Poly(f.as_expr()).factor_list()
999             if len(factors) == 1 and f.degree() == 2:
1000                 for r in roots_quadratic(f):
1001                     _update_dict(result, r, 1)
1002             else:
1003                 if len(factors) == 1 and factors[0][1] == 1:
1004                     if f.get_domain().is_EX:
1005                         res = to_rational_coeffs(f)
1006                         if res:
1007                             if res[0] is None:
1008                                 translate_x, f = res[2:]
1009                             else:
1010                                 rescale_x, f = res[1], res[-1]
1011                             result = roots(f)
1012                             if not result:
1013                                 for root in _try_decompose(f):
1014                                     _update_dict(result, root, 1)
1015                     else:
1016                         for root in _try_decompose(f):
1017                             _update_dict(result, root, 1)
1018                 else:
1019                     for factor, k in factors:
1020                         for r in _try_heuristics(Poly(factor, f.gen, field=True)):
1021                             _update_dict(result, r, k)
1022 
1023     if coeff is not S.One:
1024         _result, result, = result, {}
1025 
1026         for root, k in _result.items():
1027             result[coeff*root] = k
1028 
1029     result.update(zeros)
1030 
1031     if filter not in [None, 'C']:
1032         handlers = {
1033             'Z': lambda r: r.is_Integer,
1034             'Q': lambda r: r.is_Rational,
1035             'R': lambda r: r.is_real,
1036             'I': lambda r: r.is_imaginary,
1037         }
1038 
1039         try:
1040             query = handlers[filter]
1041         except KeyError:
1042             raise ValueError("Invalid filter: %s" % filter)
1043 
1044         for zero in dict(result).keys():
1045             if not query(zero):
1046                 del result[zero]
1047 
1048     if predicate is not None:
1049         for zero in dict(result).keys():
1050             if not predicate(zero):
1051                 del result[zero]
1052     if rescale_x:
1053         result1 = {}
1054         for k, v in result.items():
1055             result1[k*rescale_x] = v
1056         result = result1
1057     if translate_x:
1058         result1 = {}
1059         for k, v in result.items():
1060             result1[k + translate_x] = v
1061         result = result1
1062 
1063     if not multiple:
1064         return result
1065     else:
1066         zeros = []
1067 
1068         for zero in ordered(result):
1069             zeros.extend([zero]*result[zero])
1070 
1071         return zeros
1072 
1073 
1074 def root_factors(f, *gens, **args):
1075     """
1076     Returns all factors of a univariate polynomial.
1077 
1078     Examples
1079     ========
1080 
1081     >>> from sympy.abc import x, y
1082     >>> from sympy.polys.polyroots import root_factors
1083 
1084     >>> root_factors(x**2 - y, x)
1085     [x - sqrt(y), x + sqrt(y)]
1086 
1087     """
1088     args = dict(args)
1089     filter = args.pop('filter', None)
1090 
1091     F = Poly(f, *gens, **args)
1092 
1093     if not F.is_Poly:
1094         return [f]
1095 
1096     if F.is_multivariate:
1097         raise ValueError('multivariate polynomials are not supported')
1098 
1099     x = F.gens[0]
1100 
1101     zeros = roots(F, filter=filter)
1102 
1103     if not zeros:
1104         factors = [F]
1105     else:
1106         factors, N = [], 0
1107 
1108         for r, n in ordered(zeros.items()):
1109             factors, N = factors + [Poly(x - r, x)]*n, N + n
1110 
1111         if N < F.degree():
1112             G = reduce(lambda p, q: p*q, factors)
1113             factors.append(F.quo(G))
1114 
1115     if not isinstance(f, Poly):
1116         factors = [ f.as_expr() for f in factors ]
1117 
1118     return factors

</code><intended_behavior>The roots function should ensure that it can find roots of symbolic characteristic polynomials derived from matrices with symbolic entries more reliably. This could include enhancements in the algorithm to handle complex symbolic expressions or leveraging additional symbolic solving capabilities of SymPy that might not currently be utilized to their full potential.</intended_behavior>]
2025-10-18 07:58:52.740 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 07:58:52.740 | INFO     | Search-only: skipping patch selection
2025-10-18 07:58:52.819 | INFO     | Task sympy__sympy-13369 completed successfully.
2025-10-18 07:58:52.820 | INFO     | No patch generated. You can try running ACR again.
