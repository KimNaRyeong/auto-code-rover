[
    {
        "rel_file_path": "sympy/matrices/matrices.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/matrices/matrices.py",
        "start": 1094,
        "end": 1124,
        "class_name": null,
        "method_name": "eigenvals",
        "code": "1094     def eigenvals(self, error_when_incomplete=True, **flags):\n1095         \"\"\"Return eigenvalues using the Berkowitz agorithm to compute\n1096         the characteristic polynomial.\n1097 \n1098         Parameters\n1099         ==========\n1100 \n1101         error_when_incomplete : bool\n1102             Raise an error when not all eigenvalues are computed. This is\n1103             caused by ``roots`` not returning a full list of eigenvalues.\n1104 \n1105         Since the roots routine doesn't always work well with Floats,\n1106         they will be replaced with Rationals before calling that\n1107         routine. If this is not desired, set flag ``rational`` to False.\n1108         \"\"\"\n1109         mat = self\n1110         if not mat:\n1111             return {}\n1112         if flags.pop('rational', True):\n1113             if any(v.has(Float) for v in mat):\n1114                 mat = mat.applyfunc(lambda x: nsimplify(x, rational=True))\n1115 \n1116         flags.pop('simplify', None)  # pop unsupported flag\n1117         eigs = roots(mat.charpoly(x=Dummy('x')), **flags)\n1118 \n1119         # make sure the algebraic multiplicty sums to the\n1120         # size of the matrix\n1121         if error_when_incomplete and sum(m for m in eigs.values()) != self.cols:\n1122             raise MatrixError(\"Could not compute eigenvalues for {}\".format(self))\n1123 \n1124         return eigs\n",
        "intended_behavior": "The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions."
    },
    {
        "rel_file_path": "sympy/matrices/matrices.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/matrices/matrices.py",
        "start": 1094,
        "end": 1124,
        "class_name": "MatrixEigen",
        "method_name": "eigenvals",
        "code": "1094     def eigenvals(self, error_when_incomplete=True, **flags):\n1095         \"\"\"Return eigenvalues using the Berkowitz agorithm to compute\n1096         the characteristic polynomial.\n1097 \n1098         Parameters\n1099         ==========\n1100 \n1101         error_when_incomplete : bool\n1102             Raise an error when not all eigenvalues are computed. This is\n1103             caused by ``roots`` not returning a full list of eigenvalues.\n1104 \n1105         Since the roots routine doesn't always work well with Floats,\n1106         they will be replaced with Rationals before calling that\n1107         routine. If this is not desired, set flag ``rational`` to False.\n1108         \"\"\"\n1109         mat = self\n1110         if not mat:\n1111             return {}\n1112         if flags.pop('rational', True):\n1113             if any(v.has(Float) for v in mat):\n1114                 mat = mat.applyfunc(lambda x: nsimplify(x, rational=True))\n1115 \n1116         flags.pop('simplify', None)  # pop unsupported flag\n1117         eigs = roots(mat.charpoly(x=Dummy('x')), **flags)\n1118 \n1119         # make sure the algebraic multiplicty sums to the\n1120         # size of the matrix\n1121         if error_when_incomplete and sum(m for m in eigs.values()) != self.cols:\n1122             raise MatrixError(\"Could not compute eigenvalues for {}\".format(self))\n1123 \n1124         return eigs\n",
        "intended_behavior": "The eigenvals method should be capable of handling matrices with symbolic entries more robustly, ensuring that it can compute eigenvalues even when the characteristic polynomial cannot be solved using its default approaches. This may involve enhancing its internal mechanisms to fallback on numerical or approximate methods when exact symbolic computation fails, or improving the symbolic computation capabilities to handle a wider range of symbolic expressions."
    },
    {
        "rel_file_path": "sympy/polys/polyroots.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/polys/polyroots.py",
        "start": 1,
        "end": 1118,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Algorithms for computing symbolic roots of polynomials. \"\"\"\n2 \n3 from __future__ import print_function, division\n4 \n5 import math\n6 \n7 from sympy.core.symbol import Dummy, Symbol, symbols\n8 from sympy.core import S, I, pi\n9 from sympy.core.compatibility import ordered\n10 from sympy.core.mul import expand_2arg, Mul\n11 from sympy.core.power import Pow\n12 from sympy.core.relational import Eq\n13 from sympy.core.sympify import sympify\n14 from sympy.core.numbers import Rational, igcd, comp\n15 from sympy.core.exprtools import factor_terms\n16 from sympy.core.logic import fuzzy_not\n17 \n18 from sympy.ntheory import divisors, isprime, nextprime\n19 from sympy.functions import exp, sqrt, im, cos, acos, Piecewise\n20 from sympy.functions.elementary.miscellaneous import root\n21 \n22 from sympy.polys.polytools import Poly, cancel, factor, gcd_list, discriminant\n23 from sympy.polys.specialpolys import cyclotomic_poly\n24 from sympy.polys.polyerrors import (PolynomialError, GeneratorsNeeded,\n25     DomainError)\n26 from sympy.polys.polyquinticconst import PolyQuintic\n27 from sympy.polys.rationaltools import together\n28 \n29 from sympy.simplify import simplify, powsimp\n30 from sympy.utilities import public\n31 \n32 from sympy.core.compatibility import reduce, range\n33 \n34 \n35 def roots_linear(f):\n36     \"\"\"Returns a list of roots of a linear polynomial.\"\"\"\n37     r = -f.nth(0)/f.nth(1)\n38     dom = f.get_domain()\n39 \n40     if not dom.is_Numerical:\n41         if dom.is_Composite:\n42             r = factor(r)\n43         else:\n44             r = simplify(r)\n45 \n46     return [r]\n47 \n48 \n49 def roots_quadratic(f):\n50     \"\"\"Returns a list of roots of a quadratic polynomial. If the domain is ZZ\n51     then the roots will be sorted with negatives coming before positives.\n52     The ordering will be the same for any numerical coefficients as long as\n53     the assumptions tested are correct, otherwise the ordering will not be\n54     sorted (but will be canonical).\n55     \"\"\"\n56 \n57     a, b, c = f.all_coeffs()\n58     dom = f.get_domain()\n59 \n60     def _sqrt(d):\n61         # remove squares from square root since both will be represented\n62         # in the results; a similar thing is happening in roots() but\n63         # must be duplicated here because not all quadratics are binomials\n64         co = []\n65         other = []\n66         for di in Mul.make_args(d):\n67             if di.is_Pow and di.exp.is_Integer and di.exp % 2 == 0:\n68                 co.append(Pow(di.base, di.exp//2))\n69             else:\n70                 other.append(di)\n71         if co:\n72             d = Mul(*other)\n73             co = Mul(*co)\n74             return co*sqrt(d)\n75         return sqrt(d)\n76 \n77     def _simplify(expr):\n78         if dom.is_Composite:\n79             return factor(expr)\n80         else:\n81             return simplify(expr)\n82 \n83     if c is S.Zero:\n84         r0, r1 = S.Zero, -b/a\n85 \n86         if not dom.is_Numerical:\n87             r1 = _simplify(r1)\n88         elif r1.is_negative:\n89             r0, r1 = r1, r0\n90     elif b is S.Zero:\n91         r = -c/a\n92         if not dom.is_Numerical:\n93             r = _simplify(r)\n94 \n95         R = _sqrt(r)\n96         r0 = -R\n97         r1 = R\n98     else:\n99         d = b**2 - 4*a*c\n100         A = 2*a\n101         B = -b/A\n102 \n103         if not dom.is_Numerical:\n104             d = _simplify(d)\n105             B = _simplify(B)\n106 \n107         D = factor_terms(_sqrt(d)/A)\n108         r0 = B - D\n109         r1 = B + D\n110         if a.is_negative:\n111             r0, r1 = r1, r0\n112         elif not dom.is_Numerical:\n113             r0, r1 = [expand_2arg(i) for i in (r0, r1)]\n114 \n115     return [r0, r1]\n116 \n117 \n118 def roots_cubic(f, trig=False):\n119     \"\"\"Returns a list of roots of a cubic polynomial.\n120 \n121     References\n122     ==========\n123     [1] https://en.wikipedia.org/wiki/Cubic_function, General formula for roots,\n124     (accessed November 17, 2014).\n125     \"\"\"\n126     if trig:\n127         a, b, c, d = f.all_coeffs()\n128         p = (3*a*c - b**2)/3/a**2\n129         q = (2*b**3 - 9*a*b*c + 27*a**2*d)/(27*a**3)\n130         D = 18*a*b*c*d - 4*b**3*d + b**2*c**2 - 4*a*c**3 - 27*a**2*d**2\n131         if (D > 0) == True:\n132             rv = []\n133             for k in range(3):\n134                 rv.append(2*sqrt(-p/3)*cos(acos(3*q/2/p*sqrt(-3/p))/3 - k*2*pi/3))\n135             return [i - b/3/a for i in rv]\n136 \n137     _, a, b, c = f.monic().all_coeffs()\n138 \n139     if c is S.Zero:\n140         x1, x2 = roots([1, a, b], multiple=True)\n141         return [x1, S.Zero, x2]\n142 \n143     p = b - a**2/3\n144     q = c - a*b/3 + 2*a**3/27\n145 \n146     pon3 = p/3\n147     aon3 = a/3\n148 \n149     u1 = None\n150     if p is S.Zero:\n151         if q is S.Zero:\n152             return [-aon3]*3\n153         if q.is_real:\n154             if q.is_positive:\n155                 u1 = -root(q, 3)\n156             elif q.is_negative:\n157                 u1 = root(-q, 3)\n158     elif q is S.Zero:\n159         y1, y2 = roots([1, 0, p], multiple=True)\n160         return [tmp - aon3 for tmp in [y1, S.Zero, y2]]\n161     elif q.is_real and q.is_negative:\n162         u1 = -root(-q/2 + sqrt(q**2/4 + pon3**3), 3)\n163 \n164     coeff = I*sqrt(3)/2\n165     if u1 is None:\n166         u1 = S(1)\n167         u2 = -S.Half + coeff\n168         u3 = -S.Half - coeff\n169         a, b, c, d = S(1), a, b, c\n170         D0 = b**2 - 3*a*c\n171         D1 = 2*b**3 - 9*a*b*c + 27*a**2*d\n172         C = root((D1 + sqrt(D1**2 - 4*D0**3))/2, 3)\n173         return [-(b + uk*C + D0/C/uk)/3/a for uk in [u1, u2, u3]]\n174 \n175     u2 = u1*(-S.Half + coeff)\n176     u3 = u1*(-S.Half - coeff)\n177 \n178     if p is S.Zero:\n179         return [u1 - aon3, u2 - aon3, u3 - aon3]\n180 \n181     soln = [\n182         -u1 + pon3/u1 - aon3,\n183         -u2 + pon3/u2 - aon3,\n184         -u3 + pon3/u3 - aon3\n185     ]\n186 \n187     return soln\n188 \n189 def _roots_quartic_euler(p, q, r, a):\n190     \"\"\"\n191     Descartes-Euler solution of the quartic equation\n192 \n193     Parameters\n194     ==========\n195 \n196     p, q, r: coefficients of ``x**4 + p*x**2 + q*x + r``\n197     a: shift of the roots\n198 \n199     Notes\n200     =====\n201 \n202     This is a helper function for ``roots_quartic``.\n203 \n204     Look for solutions of the form ::\n205 \n206       ``x1 = sqrt(R) - sqrt(A + B*sqrt(R))``\n207       ``x2 = -sqrt(R) - sqrt(A - B*sqrt(R))``\n208       ``x3 = -sqrt(R) + sqrt(A - B*sqrt(R))``\n209       ``x4 = sqrt(R) + sqrt(A + B*sqrt(R))``\n210 \n211     To satisfy the quartic equation one must have\n212     ``p = -2*(R + A); q = -4*B*R; r = (R - A)**2 - B**2*R``\n213     so that ``R`` must satisfy the Descartes-Euler resolvent equation\n214     ``64*R**3 + 32*p*R**2 + (4*p**2 - 16*r)*R - q**2 = 0``\n215 \n216     If the resolvent does not have a rational solution, return None;\n217     in that case it is likely that the Ferrari method gives a simpler\n218     solution.\n219 \n220     Examples\n221     ========\n222 \n223     >>> from sympy import S\n224     >>> from sympy.polys.polyroots import _roots_quartic_euler\n225     >>> p, q, r = -S(64)/5, -S(512)/125, -S(1024)/3125\n226     >>> _roots_quartic_euler(p, q, r, S(0))[0]\n227     -sqrt(32*sqrt(5)/125 + 16/5) + 4*sqrt(5)/5\n228     \"\"\"\n229     # solve the resolvent equation\n230     x = Symbol('x')\n231     eq = 64*x**3 + 32*p*x**2 + (4*p**2 - 16*r)*x - q**2\n232     xsols = list(roots(Poly(eq, x), cubics=False).keys())\n233     xsols = [sol for sol in xsols if sol.is_rational]\n234     if not xsols:\n235         return None\n236     R = max(xsols)\n237     c1 = sqrt(R)\n238     B = -q*c1/(4*R)\n239     A = -R - p/2\n240     c2 = sqrt(A + B)\n241     c3 = sqrt(A - B)\n242     return [c1 - c2 - a, -c1 - c3 - a, -c1 + c3 - a, c1 + c2 - a]\n243 \n244 \n245 def roots_quartic(f):\n246     r\"\"\"\n247     Returns a list of roots of a quartic polynomial.\n248 \n249     There are many references for solving quartic expressions available [1-5].\n250     This reviewer has found that many of them require one to select from among\n251     2 or more possible sets of solutions and that some solutions work when one\n252     is searching for real roots but don't work when searching for complex roots\n253     (though this is not always stated clearly). The following routine has been\n254     tested and found to be correct for 0, 2 or 4 complex roots.\n255 \n256     The quasisymmetric case solution [6] looks for quartics that have the form\n257     `x**4 + A*x**3 + B*x**2 + C*x + D = 0` where `(C/A)**2 = D`.\n258 \n259     Although no general solution that is always applicable for all\n260     coefficients is known to this reviewer, certain conditions are tested\n261     to determine the simplest 4 expressions that can be returned:\n262 \n263       1) `f = c + a*(a**2/8 - b/2) == 0`\n264       2) `g = d - a*(a*(3*a**2/256 - b/16) + c/4) = 0`\n265       3) if `f != 0` and `g != 0` and `p = -d + a*c/4 - b**2/12` then\n266         a) `p == 0`\n267         b) `p != 0`\n268 \n269     Examples\n270     ========\n271 \n272         >>> from sympy import Poly, symbols, I\n273         >>> from sympy.polys.polyroots import roots_quartic\n274 \n275         >>> r = roots_quartic(Poly('x**4-6*x**3+17*x**2-26*x+20'))\n276 \n277         >>> # 4 complex roots: 1+-I*sqrt(3), 2+-I\n278         >>> sorted(str(tmp.evalf(n=2)) for tmp in r)\n279         ['1.0 + 1.7*I', '1.0 - 1.7*I', '2.0 + 1.0*I', '2.0 - 1.0*I']\n280 \n281     References\n282     ==========\n283 \n284     1. http://mathforum.org/dr.math/faq/faq.cubic.equations.html\n285     2. http://en.wikipedia.org/wiki/Quartic_function#Summary_of_Ferrari.27s_method\n286     3. http://planetmath.org/encyclopedia/GaloisTheoreticDerivationOfTheQuarticFormula.html\n287     4. http://staff.bath.ac.uk/masjhd/JHD-CA.pdf\n288     5. http://www.albmath.org/files/Math_5713.pdf\n289     6. http://www.statemaster.com/encyclopedia/Quartic-equation\n290     7. eqworld.ipmnet.ru/en/solutions/ae/ae0108.pdf\n291     \"\"\"\n292     _, a, b, c, d = f.monic().all_coeffs()\n293 \n294     if not d:\n295         return [S.Zero] + roots([1, a, b, c], multiple=True)\n296     elif (c/a)**2 == d:\n297         x, m = f.gen, c/a\n298 \n299         g = Poly(x**2 + a*x + b - 2*m, x)\n300 \n301         z1, z2 = roots_quadratic(g)\n302 \n303         h1 = Poly(x**2 - z1*x + m, x)\n304         h2 = Poly(x**2 - z2*x + m, x)\n305 \n306         r1 = roots_quadratic(h1)\n307         r2 = roots_quadratic(h2)\n308 \n309         return r1 + r2\n310     else:\n311         a2 = a**2\n312         e = b - 3*a2/8\n313         f = c + a*(a2/8 - b/2)\n314         g = d - a*(a*(3*a2/256 - b/16) + c/4)\n315         aon4 = a/4\n316 \n317         if f is S.Zero:\n318             y1, y2 = [sqrt(tmp) for tmp in\n319                       roots([1, e, g], multiple=True)]\n320             return [tmp - aon4 for tmp in [-y1, -y2, y1, y2]]\n321         if g is S.Zero:\n322             y = [S.Zero] + roots([1, 0, e, f], multiple=True)\n323             return [tmp - aon4 for tmp in y]\n324         else:\n325             # Descartes-Euler method, see [7]\n326             sols = _roots_quartic_euler(e, f, g, aon4)\n327             if sols:\n328                 return sols\n329             # Ferrari method, see [1, 2]\n330             a2 = a**2\n331             e = b - 3*a2/8\n332             f = c + a*(a2/8 - b/2)\n333             g = d - a*(a*(3*a2/256 - b/16) + c/4)\n334             p = -e**2/12 - g\n335             q = -e**3/108 + e*g/3 - f**2/8\n336             TH = Rational(1, 3)\n337 \n338             def _ans(y):\n339                 w = sqrt(e + 2*y)\n340                 arg1 = 3*e + 2*y\n341                 arg2 = 2*f/w\n342                 ans = []\n343                 for s in [-1, 1]:\n344                     root = sqrt(-(arg1 + s*arg2))\n345                     for t in [-1, 1]:\n346                         ans.append((s*w - t*root)/2 - aon4)\n347                 return ans\n348 \n349             # p == 0 case\n350             y1 = -5*e/6 - q**TH\n351             if p.is_zero:\n352                 return _ans(y1)\n353 \n354             # if p != 0 then u below is not 0\n355             root = sqrt(q**2/4 + p**3/27)\n356             r = -q/2 + root  # or -q/2 - root\n357             u = r**TH  # primary root of solve(x**3 - r, x)\n358             y2 = -5*e/6 + u - p/u/3\n359             if fuzzy_not(p.is_zero):\n360                 return _ans(y2)\n361 \n362             # sort it out once they know the values of the coefficients\n363             return [Piecewise((a1, Eq(p, 0)), (a2, True))\n364                 for a1, a2 in zip(_ans(y1), _ans(y2))]\n365 \n366 \n367 def roots_binomial(f):\n368     \"\"\"Returns a list of roots of a binomial polynomial. If the domain is ZZ\n369     then the roots will be sorted with negatives coming before positives.\n370     The ordering will be the same for any numerical coefficients as long as\n371     the assumptions tested are correct, otherwise the ordering will not be\n372     sorted (but will be canonical).\n373     \"\"\"\n374     n = f.degree()\n375 \n376     a, b = f.nth(n), f.nth(0)\n377     base = -cancel(b/a)\n378     alpha = root(base, n)\n379 \n380     if alpha.is_number:\n381         alpha = alpha.expand(complex=True)\n382 \n383     # define some parameters that will allow us to order the roots.\n384     # If the domain is ZZ this is guaranteed to return roots sorted\n385     # with reals before non-real roots and non-real sorted according\n386     # to real part and imaginary part, e.g. -1, 1, -1 + I, 2 - I\n387     neg = base.is_negative\n388     even = n % 2 == 0\n389     if neg:\n390         if even == True and (base + 1).is_positive:\n391             big = True\n392         else:\n393             big = False\n394 \n395     # get the indices in the right order so the computed\n396     # roots will be sorted when the domain is ZZ\n397     ks = []\n398     imax = n//2\n399     if even:\n400         ks.append(imax)\n401         imax -= 1\n402     if not neg:\n403         ks.append(0)\n404     for i in range(imax, 0, -1):\n405         if neg:\n406             ks.extend([i, -i])\n407         else:\n408             ks.extend([-i, i])\n409     if neg:\n410         ks.append(0)\n411         if big:\n412             for i in range(0, len(ks), 2):\n413                 pair = ks[i: i + 2]\n414                 pair = list(reversed(pair))\n415 \n416     # compute the roots\n417     roots, d = [], 2*I*pi/n\n418     for k in ks:\n419         zeta = exp(k*d).expand(complex=True)\n420         roots.append((alpha*zeta).expand(power_base=False))\n421 \n422     return roots\n423 \n424 \n425 def _inv_totient_estimate(m):\n426     \"\"\"\n427     Find ``(L, U)`` such that ``L <= phi^-1(m) <= U``.\n428 \n429     Examples\n430     ========\n431 \n432     >>> from sympy.polys.polyroots import _inv_totient_estimate\n433 \n434     >>> _inv_totient_estimate(192)\n435     (192, 840)\n436     >>> _inv_totient_estimate(400)\n437     (400, 1750)\n438 \n439     \"\"\"\n440     primes = [ d + 1 for d in divisors(m) if isprime(d + 1) ]\n441 \n442     a, b = 1, 1\n443 \n444     for p in primes:\n445         a *= p\n446         b *= p - 1\n447 \n448     L = m\n449     U = int(math.ceil(m*(float(a)/b)))\n450 \n451     P = p = 2\n452     primes = []\n453 \n454     while P <= U:\n455         p = nextprime(p)\n456         primes.append(p)\n457         P *= p\n458 \n459     P //= p\n460     b = 1\n461 \n462     for p in primes[:-1]:\n463         b *= p - 1\n464 \n465     U = int(math.ceil(m*(float(P)/b)))\n466 \n467     return L, U\n468 \n469 \n470 def roots_cyclotomic(f, factor=False):\n471     \"\"\"Compute roots of cyclotomic polynomials. \"\"\"\n472     L, U = _inv_totient_estimate(f.degree())\n473 \n474     for n in range(L, U + 1):\n475         g = cyclotomic_poly(n, f.gen, polys=True)\n476 \n477         if f == g:\n478             break\n479     else:  # pragma: no cover\n480         raise RuntimeError(\"failed to find index of a cyclotomic polynomial\")\n481 \n482     roots = []\n483 \n484     if not factor:\n485         # get the indices in the right order so the computed\n486         # roots will be sorted\n487         h = n//2\n488         ks = [i for i in range(1, n + 1) if igcd(i, n) == 1]\n489         ks.sort(key=lambda x: (x, -1) if x <= h else (abs(x - n), 1))\n490         d = 2*I*pi/n\n491         for k in reversed(ks):\n492             roots.append(exp(k*d).expand(complex=True))\n493     else:\n494         g = Poly(f, extension=root(-1, n))\n495 \n496         for h, _ in ordered(g.factor_list()[1]):\n497             roots.append(-h.TC())\n498 \n499     return roots\n500 \n501 \n502 def roots_quintic(f):\n503     \"\"\"\n504     Calulate exact roots of a solvable quintic\n505     \"\"\"\n506     result = []\n507     coeff_5, coeff_4, p, q, r, s = f.all_coeffs()\n508 \n509     # Eqn must be of the form x^5 + px^3 + qx^2 + rx + s\n510     if coeff_4:\n511         return result\n512 \n513     if coeff_5 != 1:\n514         l = [p/coeff_5, q/coeff_5, r/coeff_5, s/coeff_5]\n515         if not all(coeff.is_Rational for coeff in l):\n516             return result\n517         f = Poly(f/coeff_5)\n518     quintic = PolyQuintic(f)\n519 \n520     # Eqn standardized. Algo for solving starts here\n521     if not f.is_irreducible:\n522         return result\n523 \n524     f20 = quintic.f20\n525     # Check if f20 has linear factors over domain Z\n526     if f20.is_irreducible:\n527         return result\n528 \n529     # Now, we know that f is solvable\n530     for _factor in f20.factor_list()[1]:\n531         if _factor[0].is_linear:\n532             theta = _factor[0].root(0)\n533             break\n534     d = discriminant(f)\n535     delta = sqrt(d)\n536     # zeta = a fifth root of unity\n537     zeta1, zeta2, zeta3, zeta4 = quintic.zeta\n538     T = quintic.T(theta, d)\n539     tol = S(1e-10)\n540     alpha = T[1] + T[2]*delta\n541     alpha_bar = T[1] - T[2]*delta\n542     beta = T[3] + T[4]*delta\n543     beta_bar = T[3] - T[4]*delta\n544 \n545     disc = alpha**2 - 4*beta\n546     disc_bar = alpha_bar**2 - 4*beta_bar\n547 \n548     l0 = quintic.l0(theta)\n549 \n550     l1 = _quintic_simplify((-alpha + sqrt(disc)) / S(2))\n551     l4 = _quintic_simplify((-alpha - sqrt(disc)) / S(2))\n552 \n553     l2 = _quintic_simplify((-alpha_bar + sqrt(disc_bar)) / S(2))\n554     l3 = _quintic_simplify((-alpha_bar - sqrt(disc_bar)) / S(2))\n555 \n556     order = quintic.order(theta, d)\n557     test = (order*delta.n()) - ( (l1.n() - l4.n())*(l2.n() - l3.n()) )\n558     # Comparing floats\n559     if not comp(test, 0, tol):\n560         l2, l3 = l3, l2\n561 \n562     # Now we have correct order of l's\n563     R1 = l0 + l1*zeta1 + l2*zeta2 + l3*zeta3 + l4*zeta4\n564     R2 = l0 + l3*zeta1 + l1*zeta2 + l4*zeta3 + l2*zeta4\n565     R3 = l0 + l2*zeta1 + l4*zeta2 + l1*zeta3 + l3*zeta4\n566     R4 = l0 + l4*zeta1 + l3*zeta2 + l2*zeta3 + l1*zeta4\n567 \n568     Res = [None, [None]*5, [None]*5, [None]*5, [None]*5]\n569     Res_n = [None, [None]*5, [None]*5, [None]*5, [None]*5]\n570     sol = Symbol('sol')\n571 \n572     # Simplifying improves performace a lot for exact expressions\n573     R1 = _quintic_simplify(R1)\n574     R2 = _quintic_simplify(R2)\n575     R3 = _quintic_simplify(R3)\n576     R4 = _quintic_simplify(R4)\n577 \n578     # Solve imported here. Causing problems if imported as 'solve'\n579     # and hence the changed name\n580     from sympy.solvers.solvers import solve as _solve\n581     a, b = symbols('a b', cls=Dummy)\n582     _sol = _solve( sol**5 - a - I*b, sol)\n583     for i in range(5):\n584         _sol[i] = factor(_sol[i])\n585     R1 = R1.as_real_imag()\n586     R2 = R2.as_real_imag()\n587     R3 = R3.as_real_imag()\n588     R4 = R4.as_real_imag()\n589 \n590     for i, root in enumerate(_sol):\n591         Res[1][i] = _quintic_simplify(root.subs({ a: R1[0], b: R1[1] }))\n592         Res[2][i] = _quintic_simplify(root.subs({ a: R2[0], b: R2[1] }))\n593         Res[3][i] = _quintic_simplify(root.subs({ a: R3[0], b: R3[1] }))\n594         Res[4][i] = _quintic_simplify(root.subs({ a: R4[0], b: R4[1] }))\n595 \n596     for i in range(1, 5):\n597         for j in range(5):\n598             Res_n[i][j] = Res[i][j].n()\n599             Res[i][j] = _quintic_simplify(Res[i][j])\n600     r1 = Res[1][0]\n601     r1_n = Res_n[1][0]\n602 \n603     for i in range(5):\n604         if comp(im(r1_n*Res_n[4][i]), 0, tol):\n605             r4 = Res[4][i]\n606             break\n607 \n608     u, v = quintic.uv(theta, d)\n609     sqrt5 = math.sqrt(5)\n610 \n611     # Now we have various Res values. Each will be a list of five\n612     # values. We have to pick one r value from those five for each Res\n613     u, v = quintic.uv(theta, d)\n614     testplus = (u + v*delta*sqrt(5)).n()\n615     testminus = (u - v*delta*sqrt(5)).n()\n616 \n617     # Evaluated numbers suffixed with _n\n618     # We will use evaluated numbers for calculation. Much faster.\n619     r4_n = r4.n()\n620     r2 = r3 = None\n621 \n622     for i in range(5):\n623         r2temp_n = Res_n[2][i]\n624         for j in range(5):\n625             # Again storing away the exact number and using\n626             # evaluated numbers in computations\n627             r3temp_n = Res_n[3][j]\n628             if (comp((r1_n*r2temp_n**2 + r4_n*r3temp_n**2 - testplus).n(), 0, tol) and\n629                 comp((r3temp_n*r1_n**2 + r2temp_n*r4_n**2 - testminus).n(), 0, tol)):\n630                 r2 = Res[2][i]\n631                 r3 = Res[3][j]\n632                 break\n633         if r2:\n634             break\n635 \n636     # Now, we have r's so we can get roots\n637     x1 = (r1 + r2 + r3 + r4)/5\n638     x2 = (r1*zeta4 + r2*zeta3 + r3*zeta2 + r4*zeta1)/5\n639     x3 = (r1*zeta3 + r2*zeta1 + r3*zeta4 + r4*zeta2)/5\n640     x4 = (r1*zeta2 + r2*zeta4 + r3*zeta1 + r4*zeta3)/5\n641     x5 = (r1*zeta1 + r2*zeta2 + r3*zeta3 + r4*zeta4)/5\n642     result = [x1, x2, x3, x4, x5]\n643 \n644     # Now check if solutions are distinct\n645 \n646     saw = set()\n647     for r in result:\n648         r = r.n(2)\n649         if r in saw:\n650             # Roots were identical. Abort, return []\n651             # and fall back to usual solve\n652             return []\n653         saw.add(r)\n654     return result\n655 \n656 \n657 def _quintic_simplify(expr):\n658     expr = powsimp(expr)\n659     expr = cancel(expr)\n660     return together(expr)\n661 \n662 \n663 def _integer_basis(poly):\n664     \"\"\"Compute coefficient basis for a polynomial over integers.\n665 \n666     Returns the integer ``div`` such that substituting ``x = div*y``\n667     ``p(x) = m*q(y)`` where the coefficients of ``q`` are smaller\n668     than those of ``p``.\n669 \n670     For example ``x**5 + 512*x + 1024 = 0``\n671     with ``div = 4`` becomes ``y**5 + 2*y + 1 = 0``\n672 \n673     Returns the integer ``div`` or ``None`` if there is no possible scaling.\n674 \n675     Examples\n676     ========\n677 \n678     >>> from sympy.polys import Poly\n679     >>> from sympy.abc import x\n680     >>> from sympy.polys.polyroots import _integer_basis\n681     >>> p = Poly(x**5 + 512*x + 1024, x, domain='ZZ')\n682     >>> _integer_basis(p)\n683     4\n684     \"\"\"\n685     monoms, coeffs = list(zip(*poly.terms()))\n686 \n687     monoms, = list(zip(*monoms))\n688     coeffs = list(map(abs, coeffs))\n689 \n690     if coeffs[0] < coeffs[-1]:\n691         coeffs = list(reversed(coeffs))\n692         n = monoms[0]\n693         monoms = [n - i for i in reversed(monoms)]\n694     else:\n695         return None\n696 \n697     monoms = monoms[:-1]\n698     coeffs = coeffs[:-1]\n699 \n700     divs = reversed(divisors(gcd_list(coeffs))[1:])\n701 \n702     try:\n703         div = next(divs)\n704     except StopIteration:\n705         return None\n706 \n707     while True:\n708         for monom, coeff in zip(monoms, coeffs):\n709             if coeff % div**monom != 0:\n710                 try:\n711                     div = next(divs)\n712                 except StopIteration:\n713                     return None\n714                 else:\n715                     break\n716         else:\n717             return div\n718 \n719 \n720 def preprocess_roots(poly):\n721     \"\"\"Try to get rid of symbolic coefficients from ``poly``. \"\"\"\n722     coeff = S.One\n723 \n724     try:\n725         _, poly = poly.clear_denoms(convert=True)\n726     except DomainError:\n727         return coeff, poly\n728 \n729     poly = poly.primitive()[1]\n730     poly = poly.retract()\n731 \n732     # TODO: This is fragile. Figure out how to make this independent of construct_domain().\n733     if poly.get_domain().is_Poly and all(c.is_term for c in poly.rep.coeffs()):\n734         poly = poly.inject()\n735 \n736         strips = list(zip(*poly.monoms()))\n737         gens = list(poly.gens[1:])\n738 \n739         base, strips = strips[0], strips[1:]\n740 \n741         for gen, strip in zip(list(gens), strips):\n742             reverse = False\n743 \n744             if strip[0] < strip[-1]:\n745                 strip = reversed(strip)\n746                 reverse = True\n747 \n748             ratio = None\n749 \n750             for a, b in zip(base, strip):\n751                 if not a and not b:\n752                     continue\n753                 elif not a or not b:\n754                     break\n755                 elif b % a != 0:\n756                     break\n757                 else:\n758                     _ratio = b // a\n759 \n760                     if ratio is None:\n761                         ratio = _ratio\n762                     elif ratio != _ratio:\n763                         break\n764             else:\n765                 if reverse:\n766                     ratio = -ratio\n767 \n768                 poly = poly.eval(gen, 1)\n769                 coeff *= gen**(-ratio)\n770                 gens.remove(gen)\n771 \n772         if gens:\n773             poly = poly.eject(*gens)\n774 \n775     if poly.is_univariate and poly.get_domain().is_ZZ:\n776         basis = _integer_basis(poly)\n777 \n778         if basis is not None:\n779             n = poly.degree()\n780 \n781             def func(k, coeff):\n782                 return coeff//basis**(n - k[0])\n783 \n784             poly = poly.termwise(func)\n785             coeff *= basis\n786 \n787     return coeff, poly\n788 \n789 \n790 @public\n791 def roots(f, *gens, **flags):\n792     \"\"\"\n793     Computes symbolic roots of a univariate polynomial.\n794 \n795     Given a univariate polynomial f with symbolic coefficients (or\n796     a list of the polynomial's coefficients), returns a dictionary\n797     with its roots and their multiplicities.\n798 \n799     Only roots expressible via radicals will be returned.  To get\n800     a complete set of roots use RootOf class or numerical methods\n801     instead. By default cubic and quartic formulas are used in\n802     the algorithm. To disable them because of unreadable output\n803     set ``cubics=False`` or ``quartics=False`` respectively. If cubic\n804     roots are real but are expressed in terms of complex numbers\n805     (casus irreducibilis [1]) the ``trig`` flag can be set to True to\n806     have the solutions returned in terms of cosine and inverse cosine\n807     functions.\n808 \n809     To get roots from a specific domain set the ``filter`` flag with\n810     one of the following specifiers: Z, Q, R, I, C. By default all\n811     roots are returned (this is equivalent to setting ``filter='C'``).\n812 \n813     By default a dictionary is returned giving a compact result in\n814     case of multiple roots.  However to get a list containing all\n815     those roots set the ``multiple`` flag to True; the list will\n816     have identical roots appearing next to each other in the result.\n817     (For a given Poly, the all_roots method will give the roots in\n818     sorted numerical order.)\n819 \n820     Examples\n821     ========\n822 \n823     >>> from sympy import Poly, roots\n824     >>> from sympy.abc import x, y\n825 \n826     >>> roots(x**2 - 1, x)\n827     {-1: 1, 1: 1}\n828 \n829     >>> p = Poly(x**2-1, x)\n830     >>> roots(p)\n831     {-1: 1, 1: 1}\n832 \n833     >>> p = Poly(x**2-y, x, y)\n834 \n835     >>> roots(Poly(p, x))\n836     {-sqrt(y): 1, sqrt(y): 1}\n837 \n838     >>> roots(x**2 - y, x)\n839     {-sqrt(y): 1, sqrt(y): 1}\n840 \n841     >>> roots([1, 0, -1])\n842     {-1: 1, 1: 1}\n843 \n844 \n845     References\n846     ==========\n847 \n848     1. http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method\n849 \n850     \"\"\"\n851     from sympy.polys.polytools import to_rational_coeffs\n852     flags = dict(flags)\n853 \n854     auto = flags.pop('auto', True)\n855     cubics = flags.pop('cubics', True)\n856     trig = flags.pop('trig', False)\n857     quartics = flags.pop('quartics', True)\n858     quintics = flags.pop('quintics', False)\n859     multiple = flags.pop('multiple', False)\n860     filter = flags.pop('filter', None)\n861     predicate = flags.pop('predicate', None)\n862 \n863     if isinstance(f, list):\n864         if gens:\n865             raise ValueError('redundant generators given')\n866 \n867         x = Dummy('x')\n868 \n869         poly, i = {}, len(f) - 1\n870 \n871         for coeff in f:\n872             poly[i], i = sympify(coeff), i - 1\n873 \n874         f = Poly(poly, x, field=True)\n875     else:\n876         try:\n877             f = Poly(f, *gens, **flags)\n878             if f.length == 2 and f.degree() != 1:\n879                 # check for foo**n factors in the constant\n880                 n = f.degree()\n881                 npow_bases = []\n882                 expr = f.as_expr()\n883                 con = expr.as_independent(*gens)[0]\n884                 for p in Mul.make_args(con):\n885                     if p.is_Pow and not p.exp % n:\n886                         npow_bases.append(p.base**(p.exp/n))\n887                     else:\n888                         other.append(p)\n889                     if npow_bases:\n890                         b = Mul(*npow_bases)\n891                         B = Dummy()\n892                         d = roots(Poly(expr - con + B**n*Mul(*others), *gens,\n893                             **flags), *gens, **flags)\n894                         rv = {}\n895                         for k, v in d.items():\n896                             rv[k.subs(B, b)] = v\n897                         return rv\n898 \n899         except GeneratorsNeeded:\n900             if multiple:\n901                 return []\n902             else:\n903                 return {}\n904 \n905         if f.is_multivariate:\n906             raise PolynomialError('multivariate polynomials are not supported')\n907 \n908     def _update_dict(result, root, k):\n909         if root in result:\n910             result[root] += k\n911         else:\n912             result[root] = k\n913 \n914     def _try_decompose(f):\n915         \"\"\"Find roots using functional decomposition. \"\"\"\n916         factors, roots = f.decompose(), []\n917 \n918         for root in _try_heuristics(factors[0]):\n919             roots.append(root)\n920 \n921         for factor in factors[1:]:\n922             previous, roots = list(roots), []\n923 \n924             for root in previous:\n925                 g = factor - Poly(root, f.gen)\n926 \n927                 for root in _try_heuristics(g):\n928                     roots.append(root)\n929 \n930         return roots\n931 \n932     def _try_heuristics(f):\n933         \"\"\"Find roots using formulas and some tricks. \"\"\"\n934         if f.is_ground:\n935             return []\n936         if f.is_monomial:\n937             return [S(0)]*f.degree()\n938 \n939         if f.length() == 2:\n940             if f.degree() == 1:\n941                 return list(map(cancel, roots_linear(f)))\n942             else:\n943                 return roots_binomial(f)\n944 \n945         result = []\n946 \n947         for i in [-1, 1]:\n948             if not f.eval(i):\n949                 f = f.quo(Poly(f.gen - i, f.gen))\n950                 result.append(i)\n951                 break\n952 \n953         n = f.degree()\n954 \n955         if n == 1:\n956             result += list(map(cancel, roots_linear(f)))\n957         elif n == 2:\n958             result += list(map(cancel, roots_quadratic(f)))\n959         elif f.is_cyclotomic:\n960             result += roots_cyclotomic(f)\n961         elif n == 3 and cubics:\n962             result += roots_cubic(f, trig=trig)\n963         elif n == 4 and quartics:\n964             result += roots_quartic(f)\n965         elif n == 5 and quintics:\n966             result += roots_quintic(f)\n967 \n968         return result\n969 \n970     (k,), f = f.terms_gcd()\n971 \n972     if not k:\n973         zeros = {}\n974     else:\n975         zeros = {S(0): k}\n976 \n977     coeff, f = preprocess_roots(f)\n978 \n979     if auto and f.get_domain().is_Ring:\n980         f = f.to_field()\n981 \n982     rescale_x = None\n983     translate_x = None\n984 \n985     result = {}\n986 \n987     if not f.is_ground:\n988         if not f.get_domain().is_Exact:\n989             for r in f.nroots():\n990                 _update_dict(result, r, 1)\n991         elif f.degree() == 1:\n992             result[roots_linear(f)[0]] = 1\n993         elif f.length() == 2:\n994             roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial\n995             for r in roots_fun(f):\n996                 _update_dict(result, r, 1)\n997         else:\n998             _, factors = Poly(f.as_expr()).factor_list()\n999             if len(factors) == 1 and f.degree() == 2:\n1000                 for r in roots_quadratic(f):\n1001                     _update_dict(result, r, 1)\n1002             else:\n1003                 if len(factors) == 1 and factors[0][1] == 1:\n1004                     if f.get_domain().is_EX:\n1005                         res = to_rational_coeffs(f)\n1006                         if res:\n1007                             if res[0] is None:\n1008                                 translate_x, f = res[2:]\n1009                             else:\n1010                                 rescale_x, f = res[1], res[-1]\n1011                             result = roots(f)\n1012                             if not result:\n1013                                 for root in _try_decompose(f):\n1014                                     _update_dict(result, root, 1)\n1015                     else:\n1016                         for root in _try_decompose(f):\n1017                             _update_dict(result, root, 1)\n1018                 else:\n1019                     for factor, k in factors:\n1020                         for r in _try_heuristics(Poly(factor, f.gen, field=True)):\n1021                             _update_dict(result, r, k)\n1022 \n1023     if coeff is not S.One:\n1024         _result, result, = result, {}\n1025 \n1026         for root, k in _result.items():\n1027             result[coeff*root] = k\n1028 \n1029     result.update(zeros)\n1030 \n1031     if filter not in [None, 'C']:\n1032         handlers = {\n1033             'Z': lambda r: r.is_Integer,\n1034             'Q': lambda r: r.is_Rational,\n1035             'R': lambda r: r.is_real,\n1036             'I': lambda r: r.is_imaginary,\n1037         }\n1038 \n1039         try:\n1040             query = handlers[filter]\n1041         except KeyError:\n1042             raise ValueError(\"Invalid filter: %s\" % filter)\n1043 \n1044         for zero in dict(result).keys():\n1045             if not query(zero):\n1046                 del result[zero]\n1047 \n1048     if predicate is not None:\n1049         for zero in dict(result).keys():\n1050             if not predicate(zero):\n1051                 del result[zero]\n1052     if rescale_x:\n1053         result1 = {}\n1054         for k, v in result.items():\n1055             result1[k*rescale_x] = v\n1056         result = result1\n1057     if translate_x:\n1058         result1 = {}\n1059         for k, v in result.items():\n1060             result1[k + translate_x] = v\n1061         result = result1\n1062 \n1063     if not multiple:\n1064         return result\n1065     else:\n1066         zeros = []\n1067 \n1068         for zero in ordered(result):\n1069             zeros.extend([zero]*result[zero])\n1070 \n1071         return zeros\n1072 \n1073 \n1074 def root_factors(f, *gens, **args):\n1075     \"\"\"\n1076     Returns all factors of a univariate polynomial.\n1077 \n1078     Examples\n1079     ========\n1080 \n1081     >>> from sympy.abc import x, y\n1082     >>> from sympy.polys.polyroots import root_factors\n1083 \n1084     >>> root_factors(x**2 - y, x)\n1085     [x - sqrt(y), x + sqrt(y)]\n1086 \n1087     \"\"\"\n1088     args = dict(args)\n1089     filter = args.pop('filter', None)\n1090 \n1091     F = Poly(f, *gens, **args)\n1092 \n1093     if not F.is_Poly:\n1094         return [f]\n1095 \n1096     if F.is_multivariate:\n1097         raise ValueError('multivariate polynomials are not supported')\n1098 \n1099     x = F.gens[0]\n1100 \n1101     zeros = roots(F, filter=filter)\n1102 \n1103     if not zeros:\n1104         factors = [F]\n1105     else:\n1106         factors, N = [], 0\n1107 \n1108         for r, n in ordered(zeros.items()):\n1109             factors, N = factors + [Poly(x - r, x)]*n, N + n\n1110 \n1111         if N < F.degree():\n1112             G = reduce(lambda p, q: p*q, factors)\n1113             factors.append(F.quo(G))\n1114 \n1115     if not isinstance(f, Poly):\n1116         factors = [ f.as_expr() for f in factors ]\n1117 \n1118     return factors\n",
        "intended_behavior": "The roots function should ensure that it can find roots of symbolic characteristic polynomials derived from matrices with symbolic entries more reliably. This could include enhancements in the algorithm to handle complex symbolic expressions or leveraging additional symbolic solving capabilities of SymPy that might not currently be utilized to their full potential."
    }
]