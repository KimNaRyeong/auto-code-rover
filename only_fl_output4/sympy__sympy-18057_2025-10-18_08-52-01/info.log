2025-10-18 08:52:01.533 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 08:52:11.395 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=576, output_tokens=13, cost=0.006150
2025-10-18 08:52:21.776 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=756, output_tokens=475, cost=0.021810
2025-10-18 08:52:23.535 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:52:33.981 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=867, output_tokens=492, cost=0.023430
2025-10-18 08:52:33.991 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:52:36.837 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=846, output_tokens=56, cost=0.010140
2025-10-18 08:52:36.838 | DEBUG    | Extracted a valid json.
2025-10-18 08:52:36.838 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class('__eq__', 'Symbol')",
        "search_method('sympify')",
        "search_method('parse_expr')",
        "search_method('eval_expr')"
    ],
    "bug_locations": []
}
2025-10-18 08:52:36.930 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 08:52:36.931 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 08:52:57.091 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5930, output_tokens=905, cost=0.086450
2025-10-18 08:52:57.108 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:53:10.130 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7051, output_tokens=544, cost=0.086830
2025-10-18 08:53:10.141 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:53:19.398 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=898, output_tokens=476, cost=0.023260
2025-10-18 08:53:19.399 | DEBUG    | Extracted a valid json.
2025-10-18 08:53:19.399 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/sympify.py",
            "function": "sympify",
            "intended_behavior": "Modify `sympify` to avoid executing `eval` on strings that are not verified to be safe SymPy expressions. This might involve additional checks or validations to ensure the string representation of an object can be safely converted into a SymPy expression. If a string does not meet these criteria, it should not be evaluated. Instead, `sympify` could either handle the input conservatively as an error or attempt non-evaluative parsing strategies that do not involve `eval`. For cases where `eval` remains necessary, implementing a sandboxed environment or using a safer evaluation strategy (e.g., AST parsing without execution) could mitigate risks. These changes aim to preserve the functionality of allowing flexible inputs to `sympify` while ensuring security and reliability."
        },
        {
            "file": "sympy/parsing/sympy_parser.py",
            "function": "parse_expr",
            "intended_behavior": "`parse_expr` should be adapted to include safety checks or robust parsing strategies that prevent the execution of potentially dangerous or unintended code. This includes validating input strings and potentially sanitizing inputs to remove or handle known dangerous patterns before parsing and evaluation. Moreover, `parse_expr` should handle cases where the `eval_expr` function is called, ensuring that any code passed to `eval_expr` has been verified as safe. In scenarios where evaluation could lead to unsafe behavior, `parse_expr` could fall back to error handling mechanisms that avoid execution while still providing useful feedback to the user."
        },
        {
            "file": "sympy/parsing/sympy_parser.py",
            "function": "eval_expr",
            "intended_behavior": "Within `eval_expr`, introduce additional safeguards against executing unverified code. This may include verifying the contents of the `code` parameter against a set of allowed operations and structures before allowing `eval` to execute. Additionally, implementing a more restricted execution context for `eval` can limit potential damage from malicious or unintended code execution. This context could limit the available namespaces and restrict execution capabilities to purely mathematical evaluations, thus reducing risk."
        }
    ]
}
2025-10-18 08:53:19.409 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/sympify.py</file>
<class>None</class>
<method>None</method>
<code>
1 """sympify -- convert objects SymPy internal format"""
2 
3 from __future__ import print_function, division
4 
5 from inspect import getmro
6 
7 from .core import all_classes as sympy_classes
8 from .compatibility import iterable, string_types, range
9 from .evaluate import global_evaluate
10 
11 
12 class SympifyError(ValueError):
13     def __init__(self, expr, base_exc=None):
14         self.expr = expr
15         self.base_exc = base_exc
16 
17     def __str__(self):
18         if self.base_exc is None:
19             return "SympifyError: %r" % (self.expr,)
20 
21         return ("Sympify of expression '%s' failed, because of exception being "
22             "raised:\n%s: %s" % (self.expr, self.base_exc.__class__.__name__,
23             str(self.base_exc)))
24 
25 converter = {}  # See sympify docstring.
26 
27 class CantSympify(object):
28     """
29     Mix in this trait to a class to disallow sympification of its instances.
30 
31     Examples
32     ========
33 
34     >>> from sympy.core.sympify import sympify, CantSympify
35 
36     >>> class Something(dict):
37     ...     pass
38     ...
39     >>> sympify(Something())
40     {}
41 
42     >>> class Something(dict, CantSympify):
43     ...     pass
44     ...
45     >>> sympify(Something())
46     Traceback (most recent call last):
47     ...
48     SympifyError: SympifyError: {}
49 
50     """
51     pass
52 
53 
54 def _convert_numpy_types(a, **sympify_args):
55     """
56     Converts a numpy datatype input to an appropriate SymPy type.
57     """
58     import numpy as np
59     if not isinstance(a, np.floating):
60         if np.iscomplex(a):
61             return converter[complex](a.item())
62         else:
63             return sympify(a.item(), **sympify_args)
64     else:
65         try:
66             from sympy.core.numbers import Float
67             prec = np.finfo(a).nmant + 1
68             # E.g. double precision means prec=53 but nmant=52
69             # Leading bit of mantissa is always 1, so is not stored
70             a = str(list(np.reshape(np.asarray(a),
71                                     (1, np.size(a)))[0]))[1:-1]
72             return Float(a, precision=prec)
73         except NotImplementedError:
74             raise SympifyError('Translation for numpy float : %s '
75                                'is not implemented' % a)
76 
77 
78 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,
79         evaluate=None):
80     """Converts an arbitrary expression to a type that can be used inside SymPy.
81 
82     For example, it will convert Python ints into instances of sympy.Integer,
83     floats into instances of sympy.Float, etc. It is also able to coerce symbolic
84     expressions which inherit from Basic. This can be useful in cooperation
85     with SAGE.
86 
87     It currently accepts as arguments:
88        - any object defined in SymPy
89        - standard numeric python types: int, long, float, Decimal
90        - strings (like "0.09" or "2e-19")
91        - booleans, including ``None`` (will leave ``None`` unchanged)
92        - dict, lists, sets or tuples containing any of the above
93 
94     .. warning::
95         Note that this function uses ``eval``, and thus shouldn't be used on
96         unsanitized input.
97 
98     If the argument is already a type that SymPy understands, it will do
99     nothing but return that value. This can be used at the beginning of a
100     function to ensure you are working with the correct type.
101 
102     >>> from sympy import sympify
103 
104     >>> sympify(2).is_integer
105     True
106     >>> sympify(2).is_real
107     True
108 
109     >>> sympify(2.0).is_real
110     True
111     >>> sympify("2.0").is_real
112     True
113     >>> sympify("2e-45").is_real
114     True
115 
116     If the expression could not be converted, a SympifyError is raised.
117 
118     >>> sympify("x***2")
119     Traceback (most recent call last):
120     ...
121     SympifyError: SympifyError: "could not parse u'x***2'"
122 
123     Locals
124     ------
125 
126     The sympification happens with access to everything that is loaded
127     by ``from sympy import *``; anything used in a string that is not
128     defined by that import will be converted to a symbol. In the following,
129     the ``bitcount`` function is treated as a symbol and the ``O`` is
130     interpreted as the Order object (used with series) and it raises
131     an error when used improperly:
132 
133     >>> s = 'bitcount(42)'
134     >>> sympify(s)
135     bitcount(42)
136     >>> sympify("O(x)")
137     O(x)
138     >>> sympify("O + 1")
139     Traceback (most recent call last):
140     ...
141     TypeError: unbound method...
142 
143     In order to have ``bitcount`` be recognized it can be imported into a
144     namespace dictionary and passed as locals:
145 
146     >>> from sympy.core.compatibility import exec_
147     >>> ns = {}
148     >>> exec_('from sympy.core.evalf import bitcount', ns)
149     >>> sympify(s, locals=ns)
150     6
151 
152     In order to have the ``O`` interpreted as a Symbol, identify it as such
153     in the namespace dictionary. This can be done in a variety of ways; all
154     three of the following are possibilities:
155 
156     >>> from sympy import Symbol
157     >>> ns["O"] = Symbol("O")  # method 1
158     >>> exec_('from sympy.abc import O', ns)  # method 2
159     >>> ns.update(dict(O=Symbol("O")))  # method 3
160     >>> sympify("O + 1", locals=ns)
161     O + 1
162 
163     If you want *all* single-letter and Greek-letter variables to be symbols
164     then you can use the clashing-symbols dictionaries that have been defined
165     there as private variables: _clash1 (single-letter variables), _clash2
166     (the multi-letter Greek names) or _clash (both single and multi-letter
167     names that are defined in abc).
168 
169     >>> from sympy.abc import _clash1
170     >>> _clash1
171     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}
172     >>> sympify('I & Q', _clash1)
173     I & Q
174 
175     Strict
176     ------
177 
178     If the option ``strict`` is set to ``True``, only the types for which an
179     explicit conversion has been defined are converted. In the other
180     cases, a SympifyError is raised.
181 
182     >>> print(sympify(None))
183     None
184     >>> sympify(None, strict=True)
185     Traceback (most recent call last):
186     ...
187     SympifyError: SympifyError: None
188 
189     Evaluation
190     ----------
191 
192     If the option ``evaluate`` is set to ``False``, then arithmetic and
193     operators will be converted into their SymPy equivalents and the
194     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
195     be denested first. This is done via an AST transformation that replaces
196     operators with their SymPy equivalents, so if an operand redefines any
197     of those operations, the redefined operators will not be used.
198 
199     >>> sympify('2**2 / 3 + 5')
200     19/3
201     >>> sympify('2**2 / 3 + 5', evaluate=False)
202     2**2/3 + 5
203 
204     Extending
205     ---------
206 
207     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
208     just define a ``_sympy_`` method to your class. You can do that even to
209     classes that you do not own by subclassing or adding the method at runtime.
210 
211     >>> from sympy import Matrix
212     >>> class MyList1(object):
213     ...     def __iter__(self):
214     ...         yield 1
215     ...         yield 2
216     ...         return
217     ...     def __getitem__(self, i): return list(self)[i]
218     ...     def _sympy_(self): return Matrix(self)
219     >>> sympify(MyList1())
220     Matrix([
221     [1],
222     [2]])
223 
224     If you do not have control over the class definition you could also use the
225     ``converter`` global dictionary. The key is the class and the value is a
226     function that takes a single argument and returns the desired SymPy
227     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.
228 
229     >>> class MyList2(object):   # XXX Do not do this if you control the class!
230     ...     def __iter__(self):  #     Use _sympy_!
231     ...         yield 1
232     ...         yield 2
233     ...         return
234     ...     def __getitem__(self, i): return list(self)[i]
235     >>> from sympy.core.sympify import converter
236     >>> converter[MyList2] = lambda x: Matrix(x)
237     >>> sympify(MyList2())
238     Matrix([
239     [1],
240     [2]])
241 
242     Notes
243     =====
244 
245     The keywords ``rational`` and ``convert_xor`` are only used
246     when the input is a string.
247 
248     Sometimes autosimplification during sympification results in expressions
249     that are very different in structure than what was entered. Until such
250     autosimplification is no longer done, the ``kernS`` function might be of
251     some use. In the example below you can see how an expression reduces to
252     -1 by autosimplification, but does not do so when ``kernS`` is used.
253 
254     >>> from sympy.core.sympify import kernS
255     >>> from sympy.abc import x
256     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
257     -1
258     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
259     >>> sympify(s)
260     -1
261     >>> kernS(s)
262     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
263 
264     """
265     is_sympy = getattr(a, '__sympy__', None)
266     if is_sympy is not None:
267         return a
268 
269     if isinstance(a, CantSympify):
270         raise SympifyError(a)
271     cls = getattr(a, "__class__", None)
272     if cls is None:
273         cls = type(a)  # Probably an old-style class
274     conv = converter.get(cls, None)
275     if conv is not None:
276         return conv(a)
277 
278     for superclass in getmro(cls):
279         try:
280             return converter[superclass](a)
281         except KeyError:
282             continue
283 
284     if cls is type(None):
285         if strict:
286             raise SympifyError(a)
287         else:
288             return a
289 
290     if evaluate is None:
291         if global_evaluate[0] is False:
292             evaluate = global_evaluate[0]
293         else:
294             evaluate = True
295 
296     # Support for basic numpy datatypes
297     # Note that this check exists to avoid importing NumPy when not necessary
298     if type(a).__module__ == 'numpy':
299         import numpy as np
300         if np.isscalar(a):
301             return _convert_numpy_types(a, locals=locals,
302                 convert_xor=convert_xor, strict=strict, rational=rational,
303                 evaluate=evaluate)
304 
305     _sympy_ = getattr(a, "_sympy_", None)
306     if _sympy_ is not None:
307         try:
308             return a._sympy_()
309         # XXX: Catches AttributeError: 'SympyConverter' object has no
310         # attribute 'tuple'
311         # This is probably a bug somewhere but for now we catch it here.
312         except AttributeError:
313             pass
314 
315     if not strict:
316         # Put numpy array conversion _before_ float/int, see
317         # <https://github.com/sympy/sympy/issues/13924>.
318         flat = getattr(a, "flat", None)
319         if flat is not None:
320             shape = getattr(a, "shape", None)
321             if shape is not None:
322                 from ..tensor.array import Array
323                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays
324 
325     if not isinstance(a, string_types):
326         for coerce in (float, int):
327             try:
328                 coerced = coerce(a)
329             except (TypeError, ValueError):
330                 continue
331             # XXX: AttributeError only needed here for Py2
332             except AttributeError:
333                 continue
334             try:
335                 return sympify(coerced)
336             except SympifyError:
337                 continue
338 
339     if strict:
340         raise SympifyError(a)
341 
342     if iterable(a):
343         try:
344             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
345                 rational=rational) for x in a])
346         except TypeError:
347             # Not all iterables are rebuildable with their type.
348             pass
349     if isinstance(a, dict):
350         try:
351             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
352                 rational=rational) for x in a.items()])
353         except TypeError:
354             # Not all iterables are rebuildable with their type.
355             pass
356 
357     # At this point we were given an arbitrary expression
358     # which does not inherit from Basic and doesn't implement
359     # _sympy_ (which is a canonical and robust way to convert
360     # anything to SymPy expression).
361     #
362     # As a last chance, we try to take "a"'s normal form via unicode()
363     # and try to parse it. If it fails, then we have no luck and
364     # return an exception
365     try:
366         from .compatibility import unicode
367         a = unicode(a)
368     except Exception as exc:
369         raise SympifyError(a, exc)
370 
371     from sympy.parsing.sympy_parser import (parse_expr, TokenError,
372                                             standard_transformations)
373     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
374     from sympy.parsing.sympy_parser import rationalize as t_rationalize
375 
376     transformations = standard_transformations
377 
378     if rational:
379         transformations += (t_rationalize,)
380     if convert_xor:
381         transformations += (t_convert_xor,)
382 
383     try:
384         a = a.replace('\n', '')
385         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
386     except (TokenError, SyntaxError) as exc:
387         raise SympifyError('could not parse %r' % a, exc)
388 
389     return expr
390 
391 
392 def _sympify(a):
393     """
394     Short version of sympify for internal usage for __add__ and __eq__ methods
395     where it is ok to allow some things (like Python integers and floats) in
396     the expression. This excludes things (like strings) that are unwise to
397     allow into such an expression.
398 
399     >>> from sympy import Integer
400     >>> Integer(1) == 1
401     True
402 
403     >>> Integer(1) == '1'
404     False
405 
406     >>> from sympy.abc import x
407     >>> x + 1
408     x + 1
409 
410     >>> x + '1'
411     Traceback (most recent call last):
412     ...
413     TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'
414 
415     see: sympify
416 
417     """
418     return sympify(a, strict=True)
419 
420 
421 def kernS(s):
422     """Use a hack to try keep autosimplification from distributing a
423     a number into an Add; this modification doesn't
424     prevent the 2-arg Mul from becoming an Add, however.
425 
426     Examples
427     ========
428 
429     >>> from sympy.core.sympify import kernS
430     >>> from sympy.abc import x, y, z
431 
432     The 2-arg Mul distributes a number (or minus sign) across the terms
433     of an expression, but kernS will prevent that:
434 
435     >>> 2*(x + y), -(x + 1)
436     (2*x + 2*y, -x - 1)
437     >>> kernS('2*(x + y)')
438     2*(x + y)
439     >>> kernS('-(x + 1)')
440     -(x + 1)
441 
442     If use of the hack fails, the un-hacked string will be passed to sympify...
443     and you get what you get.
444 
445     XXX This hack should not be necessary once issue 4596 has been resolved.
446     """
447     import string
448     from random import choice
449     from sympy.core.symbol import Symbol
450     hit = False
451     quoted = '"' in s or "'" in s
452     if '(' in s and not quoted:
453         if s.count('(') != s.count(")"):
454             raise SympifyError('unmatched left parenthesis')
455 
456         # strip all space from s
457         s = ''.join(s.split())
458         olds = s
459         # now use space to represent a symbol that
460         # will
461         # step 1. turn potential 2-arg Muls into 3-arg versions
462         # 1a. *( -> * *(
463         s = s.replace('*(', '* *(')
464         # 1b. close up exponentials
465         s = s.replace('** *', '**')
466         # 2. handle the implied multiplication of a negated
467         # parenthesized expression in two steps
468         # 2a:  -(...)  -->  -( *(...)
469         target = '-( *('
470         s = s.replace('-(', target)
471         # 2b: double the matching closing parenthesis
472         # -( *(...)  -->  -( *(...))
473         i = nest = 0
474         assert target.endswith('(')  # assumption below
475         while True:
476             j = s.find(target, i)
477             if j == -1:
478                 break
479             j += len(target) - 1
480             for j in range(j, len(s)):
481                 if s[j] == "(":
482                     nest += 1
483                 elif s[j] == ")":
484                     nest -= 1
485                 if nest == 0:
486                     break
487             s = s[:j] + ")" + s[j:]
488             i = j + 2  # the first char after 2nd )
489         if ' ' in s:
490             # get a unique kern
491             kern = '_'
492             while kern in s:
493                 kern += choice(string.ascii_letters + string.digits)
494             s = s.replace(' ', kern)
495         hit = kern in s
496 
497     for i in range(2):
498         try:
499             expr = sympify(s)
500             break
501         except:  # the kern might cause unknown errors, so use bare except
502             if hit:
503                 s = olds  # maybe it didn't like the kern; use un-kerned s
504                 hit = False
505                 continue
506             expr = sympify(s)  # let original error raise
507 
508     if not hit:
509         return expr
510 
511     rep = {Symbol(kern): 1}
512     def _clear(expr):
513         if isinstance(expr, (list, tuple, set)):
514             return type(expr)([_clear(e) for e in expr])
515         if hasattr(expr, 'subs'):
516             return expr.subs(rep, hack2=True)
517         return expr
518     expr = _clear(expr)
519     # hope that kern is not there anymore
520     return expr

</code><intended_behavior>Modify `sympify` to avoid executing `eval` on strings that are not verified to be safe SymPy expressions. This might involve additional checks or validations to ensure the string representation of an object can be safely converted into a SymPy expression. If a string does not meet these criteria, it should not be evaluated. Instead, `sympify` could either handle the input conservatively as an error or attempt non-evaluative parsing strategies that do not involve `eval`. For cases where `eval` remains necessary, implementing a sandboxed environment or using a safer evaluation strategy (e.g., AST parsing without execution) could mitigate risks. These changes aim to preserve the functionality of allowing flexible inputs to `sympify` while ensuring security and reliability.</intended_behavior>, <file>sympy/parsing/sympy_parser.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Transform a string with Python-like source code into SymPy expression. """
2 
3 from __future__ import print_function, division
4 
5 from tokenize import (generate_tokens, untokenize, TokenError,
6     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)
7 
8 from keyword import iskeyword
9 
10 import ast
11 import unicodedata
12 
13 from sympy.core.compatibility import exec_, StringIO, iterable
14 from sympy.core.basic import Basic
15 from sympy.core import Symbol
16 from sympy.core.function import arity
17 from sympy.utilities.misc import filldedent, func_name
18 
19 
20 
21 def _token_splittable(token):
22     """
23     Predicate for whether a token name can be split into multiple tokens.
24 
25     A token is splittable if it does not contain an underscore character and
26     it is not the name of a Greek letter. This is used to implicitly convert
27     expressions like 'xyz' into 'x*y*z'.
28     """
29     if '_' in token:
30         return False
31     else:
32         try:
33             return not unicodedata.lookup('GREEK SMALL LETTER ' + token)
34         except KeyError:
35             pass
36     if len(token) > 1:
37         return True
38     return False
39 
40 
41 def _token_callable(token, local_dict, global_dict, nextToken=None):
42     """
43     Predicate for whether a token name represents a callable function.
44 
45     Essentially wraps ``callable``, but looks up the token name in the
46     locals and globals.
47     """
48     func = local_dict.get(token[1])
49     if not func:
50         func = global_dict.get(token[1])
51     return callable(func) and not isinstance(func, Symbol)
52 
53 
54 def _add_factorial_tokens(name, result):
55     if result == [] or result[-1][1] == '(':
56         raise TokenError()
57 
58     beginning = [(NAME, name), (OP, '(')]
59     end = [(OP, ')')]
60 
61     diff = 0
62     length = len(result)
63 
64     for index, token in enumerate(result[::-1]):
65         toknum, tokval = token
66         i = length - index - 1
67 
68         if tokval == ')':
69             diff += 1
70         elif tokval == '(':
71             diff -= 1
72 
73         if diff == 0:
74             if i - 1 >= 0 and result[i - 1][0] == NAME:
75                 return result[:i - 1] + beginning + result[i - 1:] + end
76             else:
77                 return result[:i] + beginning + result[i:] + end
78 
79     return result
80 
81 
82 class AppliedFunction(object):
83     """
84     A group of tokens representing a function and its arguments.
85 
86     `exponent` is for handling the shorthand sin^2, ln^2, etc.
87     """
88     def __init__(self, function, args, exponent=None):
89         if exponent is None:
90             exponent = []
91         self.function = function
92         self.args = args
93         self.exponent = exponent
94         self.items = ['function', 'args', 'exponent']
95 
96     def expand(self):
97         """Return a list of tokens representing the function"""
98         result = []
99         result.append(self.function)
100         result.extend(self.args)
101         return result
102 
103     def __getitem__(self, index):
104         return getattr(self, self.items[index])
105 
106     def __repr__(self):
107         return "AppliedFunction(%s, %s, %s)" % (self.function, self.args,
108                                                 self.exponent)
109 
110 
111 class ParenthesisGroup(list):
112     """List of tokens representing an expression in parentheses."""
113     pass
114 
115 
116 def _flatten(result):
117     result2 = []
118     for tok in result:
119         if isinstance(tok, AppliedFunction):
120             result2.extend(tok.expand())
121         else:
122             result2.append(tok)
123     return result2
124 
125 
126 def _group_parentheses(recursor):
127     def _inner(tokens, local_dict, global_dict):
128         """Group tokens between parentheses with ParenthesisGroup.
129 
130         Also processes those tokens recursively.
131 
132         """
133         result = []
134         stacks = []
135         stacklevel = 0
136         for token in tokens:
137             if token[0] == OP:
138                 if token[1] == '(':
139                     stacks.append(ParenthesisGroup([]))
140                     stacklevel += 1
141                 elif token[1] == ')':
142                     stacks[-1].append(token)
143                     stack = stacks.pop()
144 
145                     if len(stacks) > 0:
146                         # We don't recurse here since the upper-level stack
147                         # would reprocess these tokens
148                         stacks[-1].extend(stack)
149                     else:
150                         # Recurse here to handle nested parentheses
151                         # Strip off the outer parentheses to avoid an infinite loop
152                         inner = stack[1:-1]
153                         inner = recursor(inner,
154                                          local_dict,
155                                          global_dict)
156                         parenGroup = [stack[0]] + inner + [stack[-1]]
157                         result.append(ParenthesisGroup(parenGroup))
158                     stacklevel -= 1
159                     continue
160             if stacklevel:
161                 stacks[-1].append(token)
162             else:
163                 result.append(token)
164         if stacklevel:
165             raise TokenError("Mismatched parentheses")
166         return result
167     return _inner
168 
169 
170 def _apply_functions(tokens, local_dict, global_dict):
171     """Convert a NAME token + ParenthesisGroup into an AppliedFunction.
172 
173     Note that ParenthesisGroups, if not applied to any function, are
174     converted back into lists of tokens.
175 
176     """
177     result = []
178     symbol = None
179     for tok in tokens:
180         if tok[0] == NAME:
181             symbol = tok
182             result.append(tok)
183         elif isinstance(tok, ParenthesisGroup):
184             if symbol and _token_callable(symbol, local_dict, global_dict):
185                 result[-1] = AppliedFunction(symbol, tok)
186                 symbol = None
187             else:
188                 result.extend(tok)
189         else:
190             symbol = None
191             result.append(tok)
192     return result
193 
194 
195 def _implicit_multiplication(tokens, local_dict, global_dict):
196     """Implicitly adds '*' tokens.
197 
198     Cases:
199 
200     - Two AppliedFunctions next to each other ("sin(x)cos(x)")
201 
202     - AppliedFunction next to an open parenthesis ("sin x (cos x + 1)")
203 
204     - A close parenthesis next to an AppliedFunction ("(x+2)sin x")\
205 
206     - A close parenthesis next to an open parenthesis ("(x+2)(x+3)")
207 
208     - AppliedFunction next to an implicitly applied function ("sin(x)cos x")
209 
210     """
211     result = []
212     for tok, nextTok in zip(tokens, tokens[1:]):
213         result.append(tok)
214         if (isinstance(tok, AppliedFunction) and
215               isinstance(nextTok, AppliedFunction)):
216             result.append((OP, '*'))
217         elif (isinstance(tok, AppliedFunction) and
218               nextTok[0] == OP and nextTok[1] == '('):
219             # Applied function followed by an open parenthesis
220             if tok.function[1] == "Function":
221                 result[-1].function = (result[-1].function[0], 'Symbol')
222             result.append((OP, '*'))
223         elif (tok[0] == OP and tok[1] == ')' and
224               isinstance(nextTok, AppliedFunction)):
225             # Close parenthesis followed by an applied function
226             result.append((OP, '*'))
227         elif (tok[0] == OP and tok[1] == ')' and
228               nextTok[0] == NAME):
229             # Close parenthesis followed by an implicitly applied function
230             result.append((OP, '*'))
231         elif (tok[0] == nextTok[0] == OP
232               and tok[1] == ')' and nextTok[1] == '('):
233             # Close parenthesis followed by an open parenthesis
234             result.append((OP, '*'))
235         elif (isinstance(tok, AppliedFunction) and nextTok[0] == NAME):
236             # Applied function followed by implicitly applied function
237             result.append((OP, '*'))
238         elif (tok[0] == NAME and
239               not _token_callable(tok, local_dict, global_dict) and
240               nextTok[0] == OP and nextTok[1] == '('):
241             # Constant followed by parenthesis
242             result.append((OP, '*'))
243         elif (tok[0] == NAME and
244               not _token_callable(tok, local_dict, global_dict) and
245               nextTok[0] == NAME and
246               not _token_callable(nextTok, local_dict, global_dict)):
247             # Constant followed by constant
248             result.append((OP, '*'))
249         elif (tok[0] == NAME and
250               not _token_callable(tok, local_dict, global_dict) and
251               (isinstance(nextTok, AppliedFunction) or nextTok[0] == NAME)):
252             # Constant followed by (implicitly applied) function
253             result.append((OP, '*'))
254     if tokens:
255         result.append(tokens[-1])
256     return result
257 
258 
259 def _implicit_application(tokens, local_dict, global_dict):
260     """Adds parentheses as needed after functions."""
261     result = []
262     appendParen = 0  # number of closing parentheses to add
263     skip = 0  # number of tokens to delay before adding a ')' (to
264               # capture **, ^, etc.)
265     exponentSkip = False  # skipping tokens before inserting parentheses to
266                           # work with function exponentiation
267     for tok, nextTok in zip(tokens, tokens[1:]):
268         result.append(tok)
269         if (tok[0] == NAME and nextTok[0] not in [OP, ENDMARKER, NEWLINE]):
270             if _token_callable(tok, local_dict, global_dict, nextTok):
271                 result.append((OP, '('))
272                 appendParen += 1
273         # name followed by exponent - function exponentiation
274         elif (tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**'):
275             if _token_callable(tok, local_dict, global_dict):
276                 exponentSkip = True
277         elif exponentSkip:
278             # if the last token added was an applied function (i.e. the
279             # power of the function exponent) OR a multiplication (as
280             # implicit multiplication would have added an extraneous
281             # multiplication)
282             if (isinstance(tok, AppliedFunction)
283                 or (tok[0] == OP and tok[1] == '*')):
284                 # don't add anything if the next token is a multiplication
285                 # or if there's already a parenthesis (if parenthesis, still
286                 # stop skipping tokens)
287                 if not (nextTok[0] == OP and nextTok[1] == '*'):
288                     if not(nextTok[0] == OP and nextTok[1] == '('):
289                         result.append((OP, '('))
290                         appendParen += 1
291                     exponentSkip = False
292         elif appendParen:
293             if nextTok[0] == OP and nextTok[1] in ('^', '**', '*'):
294                 skip = 1
295                 continue
296             if skip:
297                 skip -= 1
298                 continue
299             result.append((OP, ')'))
300             appendParen -= 1
301 
302     if tokens:
303         result.append(tokens[-1])
304 
305     if appendParen:
306         result.extend([(OP, ')')] * appendParen)
307     return result
308 
309 
310 def function_exponentiation(tokens, local_dict, global_dict):
311     """Allows functions to be exponentiated, e.g. ``cos**2(x)``.
312 
313     Examples
314     ========
315 
316     >>> from sympy.parsing.sympy_parser import (parse_expr,
317     ... standard_transformations, function_exponentiation)
318     >>> transformations = standard_transformations + (function_exponentiation,)
319     >>> parse_expr('sin**4(x)', transformations=transformations)
320     sin(x)**4
321     """
322     result = []
323     exponent = []
324     consuming_exponent = False
325     level = 0
326     for tok, nextTok in zip(tokens, tokens[1:]):
327         if tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**':
328             if _token_callable(tok, local_dict, global_dict):
329                 consuming_exponent = True
330         elif consuming_exponent:
331             if tok[0] == NAME and tok[1] == 'Function':
332                 tok = (NAME, 'Symbol')
333             exponent.append(tok)
334 
335             # only want to stop after hitting )
336             if tok[0] == nextTok[0] == OP and tok[1] == ')' and nextTok[1] == '(':
337                 consuming_exponent = False
338             # if implicit multiplication was used, we may have )*( instead
339             if tok[0] == nextTok[0] == OP and tok[1] == '*' and nextTok[1] == '(':
340                 consuming_exponent = False
341                 del exponent[-1]
342             continue
343         elif exponent and not consuming_exponent:
344             if tok[0] == OP:
345                 if tok[1] == '(':
346                     level += 1
347                 elif tok[1] == ')':
348                     level -= 1
349             if level == 0:
350                 result.append(tok)
351                 result.extend(exponent)
352                 exponent = []
353                 continue
354         result.append(tok)
355     if tokens:
356         result.append(tokens[-1])
357     if exponent:
358         result.extend(exponent)
359     return result
360 
361 
362 def split_symbols_custom(predicate):
363     """Creates a transformation that splits symbol names.
364 
365     ``predicate`` should return True if the symbol name is to be split.
366 
367     For instance, to retain the default behavior but avoid splitting certain
368     symbol names, a predicate like this would work:
369 
370 
371     >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,
372     ... standard_transformations, implicit_multiplication,
373     ... split_symbols_custom)
374     >>> def can_split(symbol):
375     ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):
376     ...             return _token_splittable(symbol)
377     ...     return False
378     ...
379     >>> transformation = split_symbols_custom(can_split)
380     >>> parse_expr('unsplittable', transformations=standard_transformations +
381     ... (transformation, implicit_multiplication))
382     unsplittable
383     """
384     def _split_symbols(tokens, local_dict, global_dict):
385         result = []
386         split = False
387         split_previous=False
388 
389         for tok in tokens:
390             if split_previous:
391                 # throw out closing parenthesis of Symbol that was split
392                 split_previous=False
393                 continue
394             split_previous=False
395 
396             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:
397                 split = True
398 
399             elif split and tok[0] == NAME:
400                 symbol = tok[1][1:-1]
401 
402                 if predicate(symbol):
403                     tok_type = result[-2][1]  # Symbol or Function
404                     del result[-2:]  # Get rid of the call to Symbol
405 
406                     i = 0
407                     while i < len(symbol):
408                         char = symbol[i]
409                         if char in local_dict or char in global_dict:
410                             result.extend([(NAME, "%s" % char)])
411                         elif char.isdigit():
412                             char = [char]
413                             for i in range(i + 1, len(symbol)):
414                                 if not symbol[i].isdigit():
415                                   i -= 1
416                                   break
417                                 char.append(symbol[i])
418                             char = ''.join(char)
419                             result.extend([(NAME, 'Number'), (OP, '('),
420                                            (NAME, "'%s'" % char), (OP, ')')])
421                         else:
422                             use = tok_type if i == len(symbol) else 'Symbol'
423                             result.extend([(NAME, use), (OP, '('),
424                                            (NAME, "'%s'" % char), (OP, ')')])
425                         i += 1
426 
427                     # Set split_previous=True so will skip
428                     # the closing parenthesis of the original Symbol
429                     split = False
430                     split_previous = True
431                     continue
432 
433                 else:
434                     split = False
435 
436             result.append(tok)
437 
438         return result
439 
440     return _split_symbols
441 
442 
443 #: Splits symbol names for implicit multiplication.
444 #:
445 #: Intended to let expressions like ``xyz`` be parsed as ``x*y*z``. Does not
446 #: split Greek character names, so ``theta`` will *not* become
447 #: ``t*h*e*t*a``. Generally this should be used with
448 #: ``implicit_multiplication``.
449 split_symbols = split_symbols_custom(_token_splittable)
450 
451 
452 def implicit_multiplication(result, local_dict, global_dict):
453     """Makes the multiplication operator optional in most cases.
454 
455     Use this before :func:`implicit_application`, otherwise expressions like
456     ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.
457 
458     Examples
459     ========
460 
461     >>> from sympy.parsing.sympy_parser import (parse_expr,
462     ... standard_transformations, implicit_multiplication)
463     >>> transformations = standard_transformations + (implicit_multiplication,)
464     >>> parse_expr('3 x y', transformations=transformations)
465     3*x*y
466     """
467     # These are interdependent steps, so we don't expose them separately
468     for step in (_group_parentheses(implicit_multiplication),
469                  _apply_functions,
470                  _implicit_multiplication):
471         result = step(result, local_dict, global_dict)
472 
473     result = _flatten(result)
474     return result
475 
476 
477 def implicit_application(result, local_dict, global_dict):
478     """Makes parentheses optional in some cases for function calls.
479 
480     Use this after :func:`implicit_multiplication`, otherwise expressions
481     like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than
482     ``sin(2*x)``.
483 
484     Examples
485     ========
486 
487     >>> from sympy.parsing.sympy_parser import (parse_expr,
488     ... standard_transformations, implicit_application)
489     >>> transformations = standard_transformations + (implicit_application,)
490     >>> parse_expr('cot z + csc z', transformations=transformations)
491     cot(z) + csc(z)
492     """
493     for step in (_group_parentheses(implicit_application),
494                  _apply_functions,
495                  _implicit_application,):
496         result = step(result, local_dict, global_dict)
497 
498     result = _flatten(result)
499     return result
500 
501 
502 def implicit_multiplication_application(result, local_dict, global_dict):
503     """Allows a slightly relaxed syntax.
504 
505     - Parentheses for single-argument method calls are optional.
506 
507     - Multiplication is implicit.
508 
509     - Symbol names can be split (i.e. spaces are not needed between
510       symbols).
511 
512     - Functions can be exponentiated.
513 
514     Examples
515     ========
516 
517     >>> from sympy.parsing.sympy_parser import (parse_expr,
518     ... standard_transformations, implicit_multiplication_application)
519     >>> parse_expr("10sin**2 x**2 + 3xyz + tan theta",
520     ... transformations=(standard_transformations +
521     ... (implicit_multiplication_application,)))
522     3*x*y*z + 10*sin(x**2)**2 + tan(theta)
523 
524     """
525     for step in (split_symbols, implicit_multiplication,
526                  implicit_application, function_exponentiation):
527         result = step(result, local_dict, global_dict)
528 
529     return result
530 
531 
532 def auto_symbol(tokens, local_dict, global_dict):
533     """Inserts calls to ``Symbol``/``Function`` for undefined variables."""
534     result = []
535     prevTok = (None, None)
536 
537     tokens.append((None, None))  # so zip traverses all tokens
538     for tok, nextTok in zip(tokens, tokens[1:]):
539         tokNum, tokVal = tok
540         nextTokNum, nextTokVal = nextTok
541         if tokNum == NAME:
542             name = tokVal
543 
544             if (name in ['True', 'False', 'None']
545                 or iskeyword(name)
546                 # Don't convert attribute access
547                 or (prevTok[0] == OP and prevTok[1] == '.')
548                 # Don't convert keyword arguments
549                 or (prevTok[0] == OP and prevTok[1] in ('(', ',')
550                     and nextTokNum == OP and nextTokVal == '=')):
551                 result.append((NAME, name))
552                 continue
553             elif name in local_dict:
554                 if isinstance(local_dict[name], Symbol) and nextTokVal == '(':
555                     result.extend([(NAME, 'Function'),
556                                    (OP, '('),
557                                    (NAME, repr(str(local_dict[name]))),
558                                    (OP, ')')])
559                 else:
560                     result.append((NAME, name))
561                 continue
562             elif name in global_dict:
563                 obj = global_dict[name]
564                 if isinstance(obj, (Basic, type)) or callable(obj):
565                     result.append((NAME, name))
566                     continue
567 
568             result.extend([
569                 (NAME, 'Symbol' if nextTokVal != '(' else 'Function'),
570                 (OP, '('),
571                 (NAME, repr(str(name))),
572                 (OP, ')'),
573             ])
574         else:
575             result.append((tokNum, tokVal))
576 
577         prevTok = (tokNum, tokVal)
578 
579     return result
580 
581 
582 def lambda_notation(tokens, local_dict, global_dict):
583     """Substitutes "lambda" with its Sympy equivalent Lambda().
584     However, the conversion doesn't take place if only "lambda"
585     is passed because that is a syntax error.
586 
587     """
588     result = []
589     flag = False
590     toknum, tokval = tokens[0]
591     tokLen = len(tokens)
592 
593     if toknum == NAME and tokval == 'lambda':
594         if tokLen == 2 or tokLen == 3 and tokens[1][0] == NEWLINE:
595             # In Python 3.6.7+, inputs without a newline get NEWLINE added to
596             # the tokens
597             result.extend(tokens)
598         elif tokLen > 2:
599             result.extend([
600                 (NAME, 'Lambda'),
601                 (OP, '('),
602                 (OP, '('),
603                 (OP, ')'),
604                 (OP, ')'),
605             ])
606             for tokNum, tokVal in tokens[1:]:
607                 if tokNum == OP and tokVal == ':':
608                     tokVal = ','
609                     flag = True
610                 if not flag and tokNum == OP and tokVal in ['*', '**']:
611                     raise TokenError("Starred arguments in lambda not supported")
612                 if flag:
613                     result.insert(-1, (tokNum, tokVal))
614                 else:
615                     result.insert(-2, (tokNum, tokVal))
616     else:
617         result.extend(tokens)
618 
619     return result
620 
621 
622 def factorial_notation(tokens, local_dict, global_dict):
623     """Allows standard notation for factorial."""
624     result = []
625     nfactorial = 0
626     for toknum, tokval in tokens:
627         if toknum == ERRORTOKEN:
628             op = tokval
629             if op == '!':
630                 nfactorial += 1
631             else:
632                 nfactorial = 0
633                 result.append((OP, op))
634         else:
635             if nfactorial == 1:
636                 result = _add_factorial_tokens('factorial', result)
637             elif nfactorial == 2:
638                 result = _add_factorial_tokens('factorial2', result)
639             elif nfactorial > 2:
640                 raise TokenError
641             nfactorial = 0
642             result.append((toknum, tokval))
643     return result
644 
645 
646 def convert_xor(tokens, local_dict, global_dict):
647     """Treats XOR, ``^``, as exponentiation, ``**``."""
648     result = []
649     for toknum, tokval in tokens:
650         if toknum == OP:
651             if tokval == '^':
652                 result.append((OP, '**'))
653             else:
654                 result.append((toknum, tokval))
655         else:
656             result.append((toknum, tokval))
657 
658     return result
659 
660 
661 def repeated_decimals(tokens, local_dict, global_dict):
662     """
663     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)
664 
665     Run this before auto_number.
666 
667     """
668     result = []
669 
670     def is_digit(s):
671         return all(i in '0123456789_' for i in s)
672 
673     # num will running match any DECIMAL [ INTEGER ]
674     num = []
675     for toknum, tokval in tokens:
676         if toknum == NUMBER:
677             if (not num and '.' in tokval and 'e' not in tokval.lower() and
678                 'j' not in tokval.lower()):
679                 num.append((toknum, tokval))
680             elif is_digit(tokval)and  len(num) == 2:
681                 num.append((toknum, tokval))
682             elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):
683                 # Python 2 tokenizes 00123 as '00', '123'
684                 # Python 3 tokenizes 01289 as '012', '89'
685                 num.append((toknum, tokval))
686             else:
687                 num = []
688         elif toknum == OP:
689             if tokval == '[' and len(num) == 1:
690                 num.append((OP, tokval))
691             elif tokval == ']' and len(num) >= 3:
692                 num.append((OP, tokval))
693             elif tokval == '.' and not num:
694                 # handle .[1]
695                 num.append((NUMBER, '0.'))
696             else:
697                 num = []
698         else:
699             num = []
700 
701         result.append((toknum, tokval))
702 
703         if num and num[-1][1] == ']':
704             # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,
705             # and d/e = repetend
706             result = result[:-len(num)]
707             pre, post = num[0][1].split('.')
708             repetend = num[2][1]
709             if len(num) == 5:
710                 repetend += num[3][1]
711 
712             pre = pre.replace('_', '')
713             post = post.replace('_', '')
714             repetend = repetend.replace('_', '')
715 
716             zeros = '0'*len(post)
717             post, repetends = [w.lstrip('0') for w in [post, repetend]]
718                                         # or else interpreted as octal
719 
720             a = pre or '0'
721             b, c = post or '0', '1' + zeros
722             d, e = repetends, ('9'*len(repetend)) + zeros
723 
724             seq = [
725                 (OP, '('),
726                     (NAME, 'Integer'),
727                     (OP, '('),
728                         (NUMBER, a),
729                     (OP, ')'),
730                     (OP, '+'),
731                     (NAME, 'Rational'),
732                     (OP, '('),
733                         (NUMBER, b),
734                         (OP, ','),
735                         (NUMBER, c),
736                     (OP, ')'),
737                     (OP, '+'),
738                     (NAME, 'Rational'),
739                     (OP, '('),
740                         (NUMBER, d),
741                         (OP, ','),
742                         (NUMBER, e),
743                     (OP, ')'),
744                 (OP, ')'),
745             ]
746             result.extend(seq)
747             num = []
748 
749     return result
750 
751 
752 def auto_number(tokens, local_dict, global_dict):
753     """
754     Converts numeric literals to use SymPy equivalents.
755 
756     Complex numbers use ``I``, integer literals use ``Integer``, and float
757     literals use ``Float``.
758 
759     """
760     result = []
761 
762     for toknum, tokval in tokens:
763         if toknum == NUMBER:
764             number = tokval
765             postfix = []
766 
767             if number.endswith('j') or number.endswith('J'):
768                 number = number[:-1]
769                 postfix = [(OP, '*'), (NAME, 'I')]
770 
771             if '.' in number or (('e' in number or 'E' in number) and
772                     not (number.startswith('0x') or number.startswith('0X'))):
773                 seq = [(NAME, 'Float'), (OP, '('),
774                     (NUMBER, repr(str(number))), (OP, ')')]
775             else:
776                 seq = [(NAME, 'Integer'), (OP, '('), (
777                     NUMBER, number), (OP, ')')]
778 
779             result.extend(seq + postfix)
780         else:
781             result.append((toknum, tokval))
782 
783     return result
784 
785 
786 def rationalize(tokens, local_dict, global_dict):
787     """Converts floats into ``Rational``. Run AFTER ``auto_number``."""
788     result = []
789     passed_float = False
790     for toknum, tokval in tokens:
791         if toknum == NAME:
792             if tokval == 'Float':
793                 passed_float = True
794                 tokval = 'Rational'
795             result.append((toknum, tokval))
796         elif passed_float == True and toknum == NUMBER:
797             passed_float = False
798             result.append((STRING, tokval))
799         else:
800             result.append((toknum, tokval))
801 
802     return result
803 
804 
805 def _transform_equals_sign(tokens, local_dict, global_dict):
806     """Transforms the equals sign ``=`` to instances of Eq.
807 
808     This is a helper function for `convert_equals_signs`.
809     Works with expressions containing one equals sign and no
810     nesting. Expressions like `(1=2)=False` won't work with this
811     and should be used with `convert_equals_signs`.
812 
813     Examples: 1=2     to Eq(1,2)
814               1*2=x   to Eq(1*2, x)
815 
816     This does not deal with function arguments yet.
817 
818     """
819     result = []
820     if (OP, "=") in tokens:
821         result.append((NAME, "Eq"))
822         result.append((OP, "("))
823         for index, token in enumerate(tokens):
824             if token == (OP, "="):
825                 result.append((OP, ","))
826                 continue
827             result.append(token)
828         result.append((OP, ")"))
829     else:
830         result = tokens
831     return result
832 
833 
834 def convert_equals_signs(result, local_dict, global_dict):
835     """ Transforms all the equals signs ``=`` to instances of Eq.
836 
837     Parses the equals signs in the expression and replaces them with
838     appropriate Eq instances.Also works with nested equals signs.
839 
840     Does not yet play well with function arguments.
841     For example, the expression `(x=y)` is ambiguous and can be interpreted
842     as x being an argument to a function and `convert_equals_signs` won't
843     work for this.
844 
845     See also
846     ========
847     convert_equality_operators
848 
849     Examples
850     ========
851 
852     >>> from sympy.parsing.sympy_parser import (parse_expr,
853     ... standard_transformations, convert_equals_signs)
854     >>> parse_expr("1*2=x", transformations=(
855     ... standard_transformations + (convert_equals_signs,)))
856     Eq(2, x)
857     >>> parse_expr("(1*2=x)=False", transformations=(
858     ... standard_transformations + (convert_equals_signs,)))
859     Eq(Eq(2, x), False)
860 
861     """
862     for step in (_group_parentheses(convert_equals_signs),
863                   _apply_functions,
864                   _transform_equals_sign):
865         result = step(result, local_dict, global_dict)
866 
867     result = _flatten(result)
868     return result
869 
870 
871 #: Standard transformations for :func:`parse_expr`.
872 #: Inserts calls to :class:`~.Symbol`, :class:`~.Integer`, and other SymPy
873 #: datatypes and allows the use of standard factorial notation (e.g. ``x!``).
874 standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,
875     factorial_notation)
876 
877 
878 def stringify_expr(s, local_dict, global_dict, transformations):
879     """
880     Converts the string ``s`` to Python code, in ``local_dict``
881 
882     Generally, ``parse_expr`` should be used.
883     """
884 
885     tokens = []
886     input_code = StringIO(s.strip())
887     for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):
888         tokens.append((toknum, tokval))
889 
890     for transform in transformations:
891         tokens = transform(tokens, local_dict, global_dict)
892 
893     return untokenize(tokens)
894 
895 
896 def eval_expr(code, local_dict, global_dict):
897     """
898     Evaluate Python code generated by ``stringify_expr``.
899 
900     Generally, ``parse_expr`` should be used.
901     """
902     expr = eval(
903         code, global_dict, local_dict)  # take local objects in preference
904 
905     return expr
906 
907 
908 def parse_expr(s, local_dict=None, transformations=standard_transformations,
909                global_dict=None, evaluate=True):
910     """Converts the string ``s`` to a SymPy expression, in ``local_dict``
911 
912     Parameters
913     ==========
914 
915     s : str
916         The string to parse.
917 
918     local_dict : dict, optional
919         A dictionary of local variables to use when parsing.
920 
921     global_dict : dict, optional
922         A dictionary of global variables. By default, this is initialized
923         with ``from sympy import *``; provide this parameter to override
924         this behavior (for instance, to parse ``"Q & S"``).
925 
926     transformations : tuple, optional
927         A tuple of transformation functions used to modify the tokens of the
928         parsed expression before evaluation. The default transformations
929         convert numeric literals into their SymPy equivalents, convert
930         undefined variables into SymPy symbols, and allow the use of standard
931         mathematical factorial notation (e.g. ``x!``).
932 
933     evaluate : bool, optional
934         When False, the order of the arguments will remain as they were in the
935         string and automatic simplification that would normally occur is
936         suppressed. (see examples)
937 
938     Examples
939     ========
940 
941     >>> from sympy.parsing.sympy_parser import parse_expr
942     >>> parse_expr("1/2")
943     1/2
944     >>> type(_)
945     <class 'sympy.core.numbers.Half'>
946     >>> from sympy.parsing.sympy_parser import standard_transformations,\\
947     ... implicit_multiplication_application
948     >>> transformations = (standard_transformations +
949     ...     (implicit_multiplication_application,))
950     >>> parse_expr("2x", transformations=transformations)
951     2*x
952 
953     When evaluate=False, some automatic simplifications will not occur:
954 
955     >>> parse_expr("2**3"), parse_expr("2**3", evaluate=False)
956     (8, 2**3)
957 
958     In addition the order of the arguments will not be made canonical.
959     This feature allows one to tell exactly how the expression was entered:
960 
961     >>> a = parse_expr('1 + x', evaluate=False)
962     >>> b = parse_expr('x + 1', evaluate=0)
963     >>> a == b
964     False
965     >>> a.args
966     (1, x)
967     >>> b.args
968     (x, 1)
969 
970     See Also
971     ========
972 
973     stringify_expr, eval_expr, standard_transformations,
974     implicit_multiplication_application
975 
976     """
977 
978     if local_dict is None:
979         local_dict = {}
980     elif not isinstance(local_dict, dict):
981         raise TypeError('expecting local_dict to be a dict')
982 
983     if global_dict is None:
984         global_dict = {}
985         exec_('from sympy import *', global_dict)
986     elif not isinstance(global_dict, dict):
987         raise TypeError('expecting global_dict to be a dict')
988 
989     transformations = transformations or ()
990     if transformations:
991         if not iterable(transformations):
992             raise TypeError(
993                 '`transformations` should be a list of functions.')
994         for _ in transformations:
995             if not callable(_):
996                 raise TypeError(filldedent('''
997                     expected a function in `transformations`,
998                     not %s''' % func_name(_)))
999             if arity(_) != 3:
1000                 raise TypeError(filldedent('''
1001                     a transformation should be function that
1002                     takes 3 arguments'''))
1003     code = stringify_expr(s, local_dict, global_dict, transformations)
1004 
1005     if not evaluate:
1006         code = compile(evaluateFalse(code), '<string>', 'eval')
1007 
1008     return eval_expr(code, local_dict, global_dict)
1009 
1010 
1011 def evaluateFalse(s):
1012     """
1013     Replaces operators with the SymPy equivalent and sets evaluate=False.
1014     """
1015     node = ast.parse(s)
1016     node = EvaluateFalseTransformer().visit(node)
1017     # node is a Module, we want an Expression
1018     node = ast.Expression(node.body[0].value)
1019 
1020     return ast.fix_missing_locations(node)
1021 
1022 
1023 class EvaluateFalseTransformer(ast.NodeTransformer):
1024     operators = {
1025         ast.Add: 'Add',
1026         ast.Mult: 'Mul',
1027         ast.Pow: 'Pow',
1028         ast.Sub: 'Add',
1029         ast.Div: 'Mul',
1030         ast.BitOr: 'Or',
1031         ast.BitAnd: 'And',
1032         ast.BitXor: 'Not',
1033     }
1034 
1035     def flatten(self, args, func):
1036         result = []
1037         for arg in args:
1038             if isinstance(arg, ast.Call):
1039                 arg_func = arg.func
1040                 if isinstance(arg_func, ast.Call):
1041                     arg_func = arg_func.func
1042                 if arg_func.id == func:
1043                     result.extend(self.flatten(arg.args, func))
1044                 else:
1045                     result.append(arg)
1046             else:
1047                 result.append(arg)
1048         return result
1049 
1050     def visit_BinOp(self, node):
1051         if node.op.__class__ in self.operators:
1052             sympy_class = self.operators[node.op.__class__]
1053             right = self.visit(node.right)
1054             left = self.visit(node.left)
1055             if isinstance(node.left, ast.UnaryOp) and (isinstance(node.right, ast.UnaryOp) == 0) and sympy_class in ('Mul',):
1056                 left, right = right, left
1057             if isinstance(node.op, ast.Sub):
1058                 right = ast.Call(
1059                     func=ast.Name(id='Mul', ctx=ast.Load()),
1060                     args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(1)), right],
1061                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1062                     starargs=None,
1063                     kwargs=None
1064                 )
1065             if isinstance(node.op, ast.Div):
1066                 if isinstance(node.left, ast.UnaryOp):
1067                     if isinstance(node.right,ast.UnaryOp):
1068                         left, right = right, left
1069                     left = ast.Call(
1070                     func=ast.Name(id='Pow', ctx=ast.Load()),
1071                     args=[left, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1072                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1073                     starargs=None,
1074                     kwargs=None
1075                 )
1076                 else:
1077                     right = ast.Call(
1078                     func=ast.Name(id='Pow', ctx=ast.Load()),
1079                     args=[right, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1080                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1081                     starargs=None,
1082                     kwargs=None
1083                 )
1084 
1085             new_node = ast.Call(
1086                 func=ast.Name(id=sympy_class, ctx=ast.Load()),
1087                 args=[left, right],
1088                 keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1089                 starargs=None,
1090                 kwargs=None
1091             )
1092 
1093             if sympy_class in ('Add', 'Mul'):
1094                 # Denest Add or Mul as appropriate
1095                 new_node.args = self.flatten(new_node.args, sympy_class)
1096 
1097             return new_node
1098         return node

</code><intended_behavior>`parse_expr` should be adapted to include safety checks or robust parsing strategies that prevent the execution of potentially dangerous or unintended code. This includes validating input strings and potentially sanitizing inputs to remove or handle known dangerous patterns before parsing and evaluation. Moreover, `parse_expr` should handle cases where the `eval_expr` function is called, ensuring that any code passed to `eval_expr` has been verified as safe. In scenarios where evaluation could lead to unsafe behavior, `parse_expr` could fall back to error handling mechanisms that avoid execution while still providing useful feedback to the user.</intended_behavior>, <file>sympy/parsing/sympy_parser.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Transform a string with Python-like source code into SymPy expression. """
2 
3 from __future__ import print_function, division
4 
5 from tokenize import (generate_tokens, untokenize, TokenError,
6     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)
7 
8 from keyword import iskeyword
9 
10 import ast
11 import unicodedata
12 
13 from sympy.core.compatibility import exec_, StringIO, iterable
14 from sympy.core.basic import Basic
15 from sympy.core import Symbol
16 from sympy.core.function import arity
17 from sympy.utilities.misc import filldedent, func_name
18 
19 
20 
21 def _token_splittable(token):
22     """
23     Predicate for whether a token name can be split into multiple tokens.
24 
25     A token is splittable if it does not contain an underscore character and
26     it is not the name of a Greek letter. This is used to implicitly convert
27     expressions like 'xyz' into 'x*y*z'.
28     """
29     if '_' in token:
30         return False
31     else:
32         try:
33             return not unicodedata.lookup('GREEK SMALL LETTER ' + token)
34         except KeyError:
35             pass
36     if len(token) > 1:
37         return True
38     return False
39 
40 
41 def _token_callable(token, local_dict, global_dict, nextToken=None):
42     """
43     Predicate for whether a token name represents a callable function.
44 
45     Essentially wraps ``callable``, but looks up the token name in the
46     locals and globals.
47     """
48     func = local_dict.get(token[1])
49     if not func:
50         func = global_dict.get(token[1])
51     return callable(func) and not isinstance(func, Symbol)
52 
53 
54 def _add_factorial_tokens(name, result):
55     if result == [] or result[-1][1] == '(':
56         raise TokenError()
57 
58     beginning = [(NAME, name), (OP, '(')]
59     end = [(OP, ')')]
60 
61     diff = 0
62     length = len(result)
63 
64     for index, token in enumerate(result[::-1]):
65         toknum, tokval = token
66         i = length - index - 1
67 
68         if tokval == ')':
69             diff += 1
70         elif tokval == '(':
71             diff -= 1
72 
73         if diff == 0:
74             if i - 1 >= 0 and result[i - 1][0] == NAME:
75                 return result[:i - 1] + beginning + result[i - 1:] + end
76             else:
77                 return result[:i] + beginning + result[i:] + end
78 
79     return result
80 
81 
82 class AppliedFunction(object):
83     """
84     A group of tokens representing a function and its arguments.
85 
86     `exponent` is for handling the shorthand sin^2, ln^2, etc.
87     """
88     def __init__(self, function, args, exponent=None):
89         if exponent is None:
90             exponent = []
91         self.function = function
92         self.args = args
93         self.exponent = exponent
94         self.items = ['function', 'args', 'exponent']
95 
96     def expand(self):
97         """Return a list of tokens representing the function"""
98         result = []
99         result.append(self.function)
100         result.extend(self.args)
101         return result
102 
103     def __getitem__(self, index):
104         return getattr(self, self.items[index])
105 
106     def __repr__(self):
107         return "AppliedFunction(%s, %s, %s)" % (self.function, self.args,
108                                                 self.exponent)
109 
110 
111 class ParenthesisGroup(list):
112     """List of tokens representing an expression in parentheses."""
113     pass
114 
115 
116 def _flatten(result):
117     result2 = []
118     for tok in result:
119         if isinstance(tok, AppliedFunction):
120             result2.extend(tok.expand())
121         else:
122             result2.append(tok)
123     return result2
124 
125 
126 def _group_parentheses(recursor):
127     def _inner(tokens, local_dict, global_dict):
128         """Group tokens between parentheses with ParenthesisGroup.
129 
130         Also processes those tokens recursively.
131 
132         """
133         result = []
134         stacks = []
135         stacklevel = 0
136         for token in tokens:
137             if token[0] == OP:
138                 if token[1] == '(':
139                     stacks.append(ParenthesisGroup([]))
140                     stacklevel += 1
141                 elif token[1] == ')':
142                     stacks[-1].append(token)
143                     stack = stacks.pop()
144 
145                     if len(stacks) > 0:
146                         # We don't recurse here since the upper-level stack
147                         # would reprocess these tokens
148                         stacks[-1].extend(stack)
149                     else:
150                         # Recurse here to handle nested parentheses
151                         # Strip off the outer parentheses to avoid an infinite loop
152                         inner = stack[1:-1]
153                         inner = recursor(inner,
154                                          local_dict,
155                                          global_dict)
156                         parenGroup = [stack[0]] + inner + [stack[-1]]
157                         result.append(ParenthesisGroup(parenGroup))
158                     stacklevel -= 1
159                     continue
160             if stacklevel:
161                 stacks[-1].append(token)
162             else:
163                 result.append(token)
164         if stacklevel:
165             raise TokenError("Mismatched parentheses")
166         return result
167     return _inner
168 
169 
170 def _apply_functions(tokens, local_dict, global_dict):
171     """Convert a NAME token + ParenthesisGroup into an AppliedFunction.
172 
173     Note that ParenthesisGroups, if not applied to any function, are
174     converted back into lists of tokens.
175 
176     """
177     result = []
178     symbol = None
179     for tok in tokens:
180         if tok[0] == NAME:
181             symbol = tok
182             result.append(tok)
183         elif isinstance(tok, ParenthesisGroup):
184             if symbol and _token_callable(symbol, local_dict, global_dict):
185                 result[-1] = AppliedFunction(symbol, tok)
186                 symbol = None
187             else:
188                 result.extend(tok)
189         else:
190             symbol = None
191             result.append(tok)
192     return result
193 
194 
195 def _implicit_multiplication(tokens, local_dict, global_dict):
196     """Implicitly adds '*' tokens.
197 
198     Cases:
199 
200     - Two AppliedFunctions next to each other ("sin(x)cos(x)")
201 
202     - AppliedFunction next to an open parenthesis ("sin x (cos x + 1)")
203 
204     - A close parenthesis next to an AppliedFunction ("(x+2)sin x")\
205 
206     - A close parenthesis next to an open parenthesis ("(x+2)(x+3)")
207 
208     - AppliedFunction next to an implicitly applied function ("sin(x)cos x")
209 
210     """
211     result = []
212     for tok, nextTok in zip(tokens, tokens[1:]):
213         result.append(tok)
214         if (isinstance(tok, AppliedFunction) and
215               isinstance(nextTok, AppliedFunction)):
216             result.append((OP, '*'))
217         elif (isinstance(tok, AppliedFunction) and
218               nextTok[0] == OP and nextTok[1] == '('):
219             # Applied function followed by an open parenthesis
220             if tok.function[1] == "Function":
221                 result[-1].function = (result[-1].function[0], 'Symbol')
222             result.append((OP, '*'))
223         elif (tok[0] == OP and tok[1] == ')' and
224               isinstance(nextTok, AppliedFunction)):
225             # Close parenthesis followed by an applied function
226             result.append((OP, '*'))
227         elif (tok[0] == OP and tok[1] == ')' and
228               nextTok[0] == NAME):
229             # Close parenthesis followed by an implicitly applied function
230             result.append((OP, '*'))
231         elif (tok[0] == nextTok[0] == OP
232               and tok[1] == ')' and nextTok[1] == '('):
233             # Close parenthesis followed by an open parenthesis
234             result.append((OP, '*'))
235         elif (isinstance(tok, AppliedFunction) and nextTok[0] == NAME):
236             # Applied function followed by implicitly applied function
237             result.append((OP, '*'))
238         elif (tok[0] == NAME and
239               not _token_callable(tok, local_dict, global_dict) and
240               nextTok[0] == OP and nextTok[1] == '('):
241             # Constant followed by parenthesis
242             result.append((OP, '*'))
243         elif (tok[0] == NAME and
244               not _token_callable(tok, local_dict, global_dict) and
245               nextTok[0] == NAME and
246               not _token_callable(nextTok, local_dict, global_dict)):
247             # Constant followed by constant
248             result.append((OP, '*'))
249         elif (tok[0] == NAME and
250               not _token_callable(tok, local_dict, global_dict) and
251               (isinstance(nextTok, AppliedFunction) or nextTok[0] == NAME)):
252             # Constant followed by (implicitly applied) function
253             result.append((OP, '*'))
254     if tokens:
255         result.append(tokens[-1])
256     return result
257 
258 
259 def _implicit_application(tokens, local_dict, global_dict):
260     """Adds parentheses as needed after functions."""
261     result = []
262     appendParen = 0  # number of closing parentheses to add
263     skip = 0  # number of tokens to delay before adding a ')' (to
264               # capture **, ^, etc.)
265     exponentSkip = False  # skipping tokens before inserting parentheses to
266                           # work with function exponentiation
267     for tok, nextTok in zip(tokens, tokens[1:]):
268         result.append(tok)
269         if (tok[0] == NAME and nextTok[0] not in [OP, ENDMARKER, NEWLINE]):
270             if _token_callable(tok, local_dict, global_dict, nextTok):
271                 result.append((OP, '('))
272                 appendParen += 1
273         # name followed by exponent - function exponentiation
274         elif (tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**'):
275             if _token_callable(tok, local_dict, global_dict):
276                 exponentSkip = True
277         elif exponentSkip:
278             # if the last token added was an applied function (i.e. the
279             # power of the function exponent) OR a multiplication (as
280             # implicit multiplication would have added an extraneous
281             # multiplication)
282             if (isinstance(tok, AppliedFunction)
283                 or (tok[0] == OP and tok[1] == '*')):
284                 # don't add anything if the next token is a multiplication
285                 # or if there's already a parenthesis (if parenthesis, still
286                 # stop skipping tokens)
287                 if not (nextTok[0] == OP and nextTok[1] == '*'):
288                     if not(nextTok[0] == OP and nextTok[1] == '('):
289                         result.append((OP, '('))
290                         appendParen += 1
291                     exponentSkip = False
292         elif appendParen:
293             if nextTok[0] == OP and nextTok[1] in ('^', '**', '*'):
294                 skip = 1
295                 continue
296             if skip:
297                 skip -= 1
298                 continue
299             result.append((OP, ')'))
300             appendParen -= 1
301 
302     if tokens:
303         result.append(tokens[-1])
304 
305     if appendParen:
306         result.extend([(OP, ')')] * appendParen)
307     return result
308 
309 
310 def function_exponentiation(tokens, local_dict, global_dict):
311     """Allows functions to be exponentiated, e.g. ``cos**2(x)``.
312 
313     Examples
314     ========
315 
316     >>> from sympy.parsing.sympy_parser import (parse_expr,
317     ... standard_transformations, function_exponentiation)
318     >>> transformations = standard_transformations + (function_exponentiation,)
319     >>> parse_expr('sin**4(x)', transformations=transformations)
320     sin(x)**4
321     """
322     result = []
323     exponent = []
324     consuming_exponent = False
325     level = 0
326     for tok, nextTok in zip(tokens, tokens[1:]):
327         if tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**':
328             if _token_callable(tok, local_dict, global_dict):
329                 consuming_exponent = True
330         elif consuming_exponent:
331             if tok[0] == NAME and tok[1] == 'Function':
332                 tok = (NAME, 'Symbol')
333             exponent.append(tok)
334 
335             # only want to stop after hitting )
336             if tok[0] == nextTok[0] == OP and tok[1] == ')' and nextTok[1] == '(':
337                 consuming_exponent = False
338             # if implicit multiplication was used, we may have )*( instead
339             if tok[0] == nextTok[0] == OP and tok[1] == '*' and nextTok[1] == '(':
340                 consuming_exponent = False
341                 del exponent[-1]
342             continue
343         elif exponent and not consuming_exponent:
344             if tok[0] == OP:
345                 if tok[1] == '(':
346                     level += 1
347                 elif tok[1] == ')':
348                     level -= 1
349             if level == 0:
350                 result.append(tok)
351                 result.extend(exponent)
352                 exponent = []
353                 continue
354         result.append(tok)
355     if tokens:
356         result.append(tokens[-1])
357     if exponent:
358         result.extend(exponent)
359     return result
360 
361 
362 def split_symbols_custom(predicate):
363     """Creates a transformation that splits symbol names.
364 
365     ``predicate`` should return True if the symbol name is to be split.
366 
367     For instance, to retain the default behavior but avoid splitting certain
368     symbol names, a predicate like this would work:
369 
370 
371     >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,
372     ... standard_transformations, implicit_multiplication,
373     ... split_symbols_custom)
374     >>> def can_split(symbol):
375     ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):
376     ...             return _token_splittable(symbol)
377     ...     return False
378     ...
379     >>> transformation = split_symbols_custom(can_split)
380     >>> parse_expr('unsplittable', transformations=standard_transformations +
381     ... (transformation, implicit_multiplication))
382     unsplittable
383     """
384     def _split_symbols(tokens, local_dict, global_dict):
385         result = []
386         split = False
387         split_previous=False
388 
389         for tok in tokens:
390             if split_previous:
391                 # throw out closing parenthesis of Symbol that was split
392                 split_previous=False
393                 continue
394             split_previous=False
395 
396             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:
397                 split = True
398 
399             elif split and tok[0] == NAME:
400                 symbol = tok[1][1:-1]
401 
402                 if predicate(symbol):
403                     tok_type = result[-2][1]  # Symbol or Function
404                     del result[-2:]  # Get rid of the call to Symbol
405 
406                     i = 0
407                     while i < len(symbol):
408                         char = symbol[i]
409                         if char in local_dict or char in global_dict:
410                             result.extend([(NAME, "%s" % char)])
411                         elif char.isdigit():
412                             char = [char]
413                             for i in range(i + 1, len(symbol)):
414                                 if not symbol[i].isdigit():
415                                   i -= 1
416                                   break
417                                 char.append(symbol[i])
418                             char = ''.join(char)
419                             result.extend([(NAME, 'Number'), (OP, '('),
420                                            (NAME, "'%s'" % char), (OP, ')')])
421                         else:
422                             use = tok_type if i == len(symbol) else 'Symbol'
423                             result.extend([(NAME, use), (OP, '('),
424                                            (NAME, "'%s'" % char), (OP, ')')])
425                         i += 1
426 
427                     # Set split_previous=True so will skip
428                     # the closing parenthesis of the original Symbol
429                     split = False
430                     split_previous = True
431                     continue
432 
433                 else:
434                     split = False
435 
436             result.append(tok)
437 
438         return result
439 
440     return _split_symbols
441 
442 
443 #: Splits symbol names for implicit multiplication.
444 #:
445 #: Intended to let expressions like ``xyz`` be parsed as ``x*y*z``. Does not
446 #: split Greek character names, so ``theta`` will *not* become
447 #: ``t*h*e*t*a``. Generally this should be used with
448 #: ``implicit_multiplication``.
449 split_symbols = split_symbols_custom(_token_splittable)
450 
451 
452 def implicit_multiplication(result, local_dict, global_dict):
453     """Makes the multiplication operator optional in most cases.
454 
455     Use this before :func:`implicit_application`, otherwise expressions like
456     ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.
457 
458     Examples
459     ========
460 
461     >>> from sympy.parsing.sympy_parser import (parse_expr,
462     ... standard_transformations, implicit_multiplication)
463     >>> transformations = standard_transformations + (implicit_multiplication,)
464     >>> parse_expr('3 x y', transformations=transformations)
465     3*x*y
466     """
467     # These are interdependent steps, so we don't expose them separately
468     for step in (_group_parentheses(implicit_multiplication),
469                  _apply_functions,
470                  _implicit_multiplication):
471         result = step(result, local_dict, global_dict)
472 
473     result = _flatten(result)
474     return result
475 
476 
477 def implicit_application(result, local_dict, global_dict):
478     """Makes parentheses optional in some cases for function calls.
479 
480     Use this after :func:`implicit_multiplication`, otherwise expressions
481     like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than
482     ``sin(2*x)``.
483 
484     Examples
485     ========
486 
487     >>> from sympy.parsing.sympy_parser import (parse_expr,
488     ... standard_transformations, implicit_application)
489     >>> transformations = standard_transformations + (implicit_application,)
490     >>> parse_expr('cot z + csc z', transformations=transformations)
491     cot(z) + csc(z)
492     """
493     for step in (_group_parentheses(implicit_application),
494                  _apply_functions,
495                  _implicit_application,):
496         result = step(result, local_dict, global_dict)
497 
498     result = _flatten(result)
499     return result
500 
501 
502 def implicit_multiplication_application(result, local_dict, global_dict):
503     """Allows a slightly relaxed syntax.
504 
505     - Parentheses for single-argument method calls are optional.
506 
507     - Multiplication is implicit.
508 
509     - Symbol names can be split (i.e. spaces are not needed between
510       symbols).
511 
512     - Functions can be exponentiated.
513 
514     Examples
515     ========
516 
517     >>> from sympy.parsing.sympy_parser import (parse_expr,
518     ... standard_transformations, implicit_multiplication_application)
519     >>> parse_expr("10sin**2 x**2 + 3xyz + tan theta",
520     ... transformations=(standard_transformations +
521     ... (implicit_multiplication_application,)))
522     3*x*y*z + 10*sin(x**2)**2 + tan(theta)
523 
524     """
525     for step in (split_symbols, implicit_multiplication,
526                  implicit_application, function_exponentiation):
527         result = step(result, local_dict, global_dict)
528 
529     return result
530 
531 
532 def auto_symbol(tokens, local_dict, global_dict):
533     """Inserts calls to ``Symbol``/``Function`` for undefined variables."""
534     result = []
535     prevTok = (None, None)
536 
537     tokens.append((None, None))  # so zip traverses all tokens
538     for tok, nextTok in zip(tokens, tokens[1:]):
539         tokNum, tokVal = tok
540         nextTokNum, nextTokVal = nextTok
541         if tokNum == NAME:
542             name = tokVal
543 
544             if (name in ['True', 'False', 'None']
545                 or iskeyword(name)
546                 # Don't convert attribute access
547                 or (prevTok[0] == OP and prevTok[1] == '.')
548                 # Don't convert keyword arguments
549                 or (prevTok[0] == OP and prevTok[1] in ('(', ',')
550                     and nextTokNum == OP and nextTokVal == '=')):
551                 result.append((NAME, name))
552                 continue
553             elif name in local_dict:
554                 if isinstance(local_dict[name], Symbol) and nextTokVal == '(':
555                     result.extend([(NAME, 'Function'),
556                                    (OP, '('),
557                                    (NAME, repr(str(local_dict[name]))),
558                                    (OP, ')')])
559                 else:
560                     result.append((NAME, name))
561                 continue
562             elif name in global_dict:
563                 obj = global_dict[name]
564                 if isinstance(obj, (Basic, type)) or callable(obj):
565                     result.append((NAME, name))
566                     continue
567 
568             result.extend([
569                 (NAME, 'Symbol' if nextTokVal != '(' else 'Function'),
570                 (OP, '('),
571                 (NAME, repr(str(name))),
572                 (OP, ')'),
573             ])
574         else:
575             result.append((tokNum, tokVal))
576 
577         prevTok = (tokNum, tokVal)
578 
579     return result
580 
581 
582 def lambda_notation(tokens, local_dict, global_dict):
583     """Substitutes "lambda" with its Sympy equivalent Lambda().
584     However, the conversion doesn't take place if only "lambda"
585     is passed because that is a syntax error.
586 
587     """
588     result = []
589     flag = False
590     toknum, tokval = tokens[0]
591     tokLen = len(tokens)
592 
593     if toknum == NAME and tokval == 'lambda':
594         if tokLen == 2 or tokLen == 3 and tokens[1][0] == NEWLINE:
595             # In Python 3.6.7+, inputs without a newline get NEWLINE added to
596             # the tokens
597             result.extend(tokens)
598         elif tokLen > 2:
599             result.extend([
600                 (NAME, 'Lambda'),
601                 (OP, '('),
602                 (OP, '('),
603                 (OP, ')'),
604                 (OP, ')'),
605             ])
606             for tokNum, tokVal in tokens[1:]:
607                 if tokNum == OP and tokVal == ':':
608                     tokVal = ','
609                     flag = True
610                 if not flag and tokNum == OP and tokVal in ['*', '**']:
611                     raise TokenError("Starred arguments in lambda not supported")
612                 if flag:
613                     result.insert(-1, (tokNum, tokVal))
614                 else:
615                     result.insert(-2, (tokNum, tokVal))
616     else:
617         result.extend(tokens)
618 
619     return result
620 
621 
622 def factorial_notation(tokens, local_dict, global_dict):
623     """Allows standard notation for factorial."""
624     result = []
625     nfactorial = 0
626     for toknum, tokval in tokens:
627         if toknum == ERRORTOKEN:
628             op = tokval
629             if op == '!':
630                 nfactorial += 1
631             else:
632                 nfactorial = 0
633                 result.append((OP, op))
634         else:
635             if nfactorial == 1:
636                 result = _add_factorial_tokens('factorial', result)
637             elif nfactorial == 2:
638                 result = _add_factorial_tokens('factorial2', result)
639             elif nfactorial > 2:
640                 raise TokenError
641             nfactorial = 0
642             result.append((toknum, tokval))
643     return result
644 
645 
646 def convert_xor(tokens, local_dict, global_dict):
647     """Treats XOR, ``^``, as exponentiation, ``**``."""
648     result = []
649     for toknum, tokval in tokens:
650         if toknum == OP:
651             if tokval == '^':
652                 result.append((OP, '**'))
653             else:
654                 result.append((toknum, tokval))
655         else:
656             result.append((toknum, tokval))
657 
658     return result
659 
660 
661 def repeated_decimals(tokens, local_dict, global_dict):
662     """
663     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)
664 
665     Run this before auto_number.
666 
667     """
668     result = []
669 
670     def is_digit(s):
671         return all(i in '0123456789_' for i in s)
672 
673     # num will running match any DECIMAL [ INTEGER ]
674     num = []
675     for toknum, tokval in tokens:
676         if toknum == NUMBER:
677             if (not num and '.' in tokval and 'e' not in tokval.lower() and
678                 'j' not in tokval.lower()):
679                 num.append((toknum, tokval))
680             elif is_digit(tokval)and  len(num) == 2:
681                 num.append((toknum, tokval))
682             elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):
683                 # Python 2 tokenizes 00123 as '00', '123'
684                 # Python 3 tokenizes 01289 as '012', '89'
685                 num.append((toknum, tokval))
686             else:
687                 num = []
688         elif toknum == OP:
689             if tokval == '[' and len(num) == 1:
690                 num.append((OP, tokval))
691             elif tokval == ']' and len(num) >= 3:
692                 num.append((OP, tokval))
693             elif tokval == '.' and not num:
694                 # handle .[1]
695                 num.append((NUMBER, '0.'))
696             else:
697                 num = []
698         else:
699             num = []
700 
701         result.append((toknum, tokval))
702 
703         if num and num[-1][1] == ']':
704             # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,
705             # and d/e = repetend
706             result = result[:-len(num)]
707             pre, post = num[0][1].split('.')
708             repetend = num[2][1]
709             if len(num) == 5:
710                 repetend += num[3][1]
711 
712             pre = pre.replace('_', '')
713             post = post.replace('_', '')
714             repetend = repetend.replace('_', '')
715 
716             zeros = '0'*len(post)
717             post, repetends = [w.lstrip('0') for w in [post, repetend]]
718                                         # or else interpreted as octal
719 
720             a = pre or '0'
721             b, c = post or '0', '1' + zeros
722             d, e = repetends, ('9'*len(repetend)) + zeros
723 
724             seq = [
725                 (OP, '('),
726                     (NAME, 'Integer'),
727                     (OP, '('),
728                         (NUMBER, a),
729                     (OP, ')'),
730                     (OP, '+'),
731                     (NAME, 'Rational'),
732                     (OP, '('),
733                         (NUMBER, b),
734                         (OP, ','),
735                         (NUMBER, c),
736                     (OP, ')'),
737                     (OP, '+'),
738                     (NAME, 'Rational'),
739                     (OP, '('),
740                         (NUMBER, d),
741                         (OP, ','),
742                         (NUMBER, e),
743                     (OP, ')'),
744                 (OP, ')'),
745             ]
746             result.extend(seq)
747             num = []
748 
749     return result
750 
751 
752 def auto_number(tokens, local_dict, global_dict):
753     """
754     Converts numeric literals to use SymPy equivalents.
755 
756     Complex numbers use ``I``, integer literals use ``Integer``, and float
757     literals use ``Float``.
758 
759     """
760     result = []
761 
762     for toknum, tokval in tokens:
763         if toknum == NUMBER:
764             number = tokval
765             postfix = []
766 
767             if number.endswith('j') or number.endswith('J'):
768                 number = number[:-1]
769                 postfix = [(OP, '*'), (NAME, 'I')]
770 
771             if '.' in number or (('e' in number or 'E' in number) and
772                     not (number.startswith('0x') or number.startswith('0X'))):
773                 seq = [(NAME, 'Float'), (OP, '('),
774                     (NUMBER, repr(str(number))), (OP, ')')]
775             else:
776                 seq = [(NAME, 'Integer'), (OP, '('), (
777                     NUMBER, number), (OP, ')')]
778 
779             result.extend(seq + postfix)
780         else:
781             result.append((toknum, tokval))
782 
783     return result
784 
785 
786 def rationalize(tokens, local_dict, global_dict):
787     """Converts floats into ``Rational``. Run AFTER ``auto_number``."""
788     result = []
789     passed_float = False
790     for toknum, tokval in tokens:
791         if toknum == NAME:
792             if tokval == 'Float':
793                 passed_float = True
794                 tokval = 'Rational'
795             result.append((toknum, tokval))
796         elif passed_float == True and toknum == NUMBER:
797             passed_float = False
798             result.append((STRING, tokval))
799         else:
800             result.append((toknum, tokval))
801 
802     return result
803 
804 
805 def _transform_equals_sign(tokens, local_dict, global_dict):
806     """Transforms the equals sign ``=`` to instances of Eq.
807 
808     This is a helper function for `convert_equals_signs`.
809     Works with expressions containing one equals sign and no
810     nesting. Expressions like `(1=2)=False` won't work with this
811     and should be used with `convert_equals_signs`.
812 
813     Examples: 1=2     to Eq(1,2)
814               1*2=x   to Eq(1*2, x)
815 
816     This does not deal with function arguments yet.
817 
818     """
819     result = []
820     if (OP, "=") in tokens:
821         result.append((NAME, "Eq"))
822         result.append((OP, "("))
823         for index, token in enumerate(tokens):
824             if token == (OP, "="):
825                 result.append((OP, ","))
826                 continue
827             result.append(token)
828         result.append((OP, ")"))
829     else:
830         result = tokens
831     return result
832 
833 
834 def convert_equals_signs(result, local_dict, global_dict):
835     """ Transforms all the equals signs ``=`` to instances of Eq.
836 
837     Parses the equals signs in the expression and replaces them with
838     appropriate Eq instances.Also works with nested equals signs.
839 
840     Does not yet play well with function arguments.
841     For example, the expression `(x=y)` is ambiguous and can be interpreted
842     as x being an argument to a function and `convert_equals_signs` won't
843     work for this.
844 
845     See also
846     ========
847     convert_equality_operators
848 
849     Examples
850     ========
851 
852     >>> from sympy.parsing.sympy_parser import (parse_expr,
853     ... standard_transformations, convert_equals_signs)
854     >>> parse_expr("1*2=x", transformations=(
855     ... standard_transformations + (convert_equals_signs,)))
856     Eq(2, x)
857     >>> parse_expr("(1*2=x)=False", transformations=(
858     ... standard_transformations + (convert_equals_signs,)))
859     Eq(Eq(2, x), False)
860 
861     """
862     for step in (_group_parentheses(convert_equals_signs),
863                   _apply_functions,
864                   _transform_equals_sign):
865         result = step(result, local_dict, global_dict)
866 
867     result = _flatten(result)
868     return result
869 
870 
871 #: Standard transformations for :func:`parse_expr`.
872 #: Inserts calls to :class:`~.Symbol`, :class:`~.Integer`, and other SymPy
873 #: datatypes and allows the use of standard factorial notation (e.g. ``x!``).
874 standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,
875     factorial_notation)
876 
877 
878 def stringify_expr(s, local_dict, global_dict, transformations):
879     """
880     Converts the string ``s`` to Python code, in ``local_dict``
881 
882     Generally, ``parse_expr`` should be used.
883     """
884 
885     tokens = []
886     input_code = StringIO(s.strip())
887     for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):
888         tokens.append((toknum, tokval))
889 
890     for transform in transformations:
891         tokens = transform(tokens, local_dict, global_dict)
892 
893     return untokenize(tokens)
894 
895 
896 def eval_expr(code, local_dict, global_dict):
897     """
898     Evaluate Python code generated by ``stringify_expr``.
899 
900     Generally, ``parse_expr`` should be used.
901     """
902     expr = eval(
903         code, global_dict, local_dict)  # take local objects in preference
904 
905     return expr
906 
907 
908 def parse_expr(s, local_dict=None, transformations=standard_transformations,
909                global_dict=None, evaluate=True):
910     """Converts the string ``s`` to a SymPy expression, in ``local_dict``
911 
912     Parameters
913     ==========
914 
915     s : str
916         The string to parse.
917 
918     local_dict : dict, optional
919         A dictionary of local variables to use when parsing.
920 
921     global_dict : dict, optional
922         A dictionary of global variables. By default, this is initialized
923         with ``from sympy import *``; provide this parameter to override
924         this behavior (for instance, to parse ``"Q & S"``).
925 
926     transformations : tuple, optional
927         A tuple of transformation functions used to modify the tokens of the
928         parsed expression before evaluation. The default transformations
929         convert numeric literals into their SymPy equivalents, convert
930         undefined variables into SymPy symbols, and allow the use of standard
931         mathematical factorial notation (e.g. ``x!``).
932 
933     evaluate : bool, optional
934         When False, the order of the arguments will remain as they were in the
935         string and automatic simplification that would normally occur is
936         suppressed. (see examples)
937 
938     Examples
939     ========
940 
941     >>> from sympy.parsing.sympy_parser import parse_expr
942     >>> parse_expr("1/2")
943     1/2
944     >>> type(_)
945     <class 'sympy.core.numbers.Half'>
946     >>> from sympy.parsing.sympy_parser import standard_transformations,\\
947     ... implicit_multiplication_application
948     >>> transformations = (standard_transformations +
949     ...     (implicit_multiplication_application,))
950     >>> parse_expr("2x", transformations=transformations)
951     2*x
952 
953     When evaluate=False, some automatic simplifications will not occur:
954 
955     >>> parse_expr("2**3"), parse_expr("2**3", evaluate=False)
956     (8, 2**3)
957 
958     In addition the order of the arguments will not be made canonical.
959     This feature allows one to tell exactly how the expression was entered:
960 
961     >>> a = parse_expr('1 + x', evaluate=False)
962     >>> b = parse_expr('x + 1', evaluate=0)
963     >>> a == b
964     False
965     >>> a.args
966     (1, x)
967     >>> b.args
968     (x, 1)
969 
970     See Also
971     ========
972 
973     stringify_expr, eval_expr, standard_transformations,
974     implicit_multiplication_application
975 
976     """
977 
978     if local_dict is None:
979         local_dict = {}
980     elif not isinstance(local_dict, dict):
981         raise TypeError('expecting local_dict to be a dict')
982 
983     if global_dict is None:
984         global_dict = {}
985         exec_('from sympy import *', global_dict)
986     elif not isinstance(global_dict, dict):
987         raise TypeError('expecting global_dict to be a dict')
988 
989     transformations = transformations or ()
990     if transformations:
991         if not iterable(transformations):
992             raise TypeError(
993                 '`transformations` should be a list of functions.')
994         for _ in transformations:
995             if not callable(_):
996                 raise TypeError(filldedent('''
997                     expected a function in `transformations`,
998                     not %s''' % func_name(_)))
999             if arity(_) != 3:
1000                 raise TypeError(filldedent('''
1001                     a transformation should be function that
1002                     takes 3 arguments'''))
1003     code = stringify_expr(s, local_dict, global_dict, transformations)
1004 
1005     if not evaluate:
1006         code = compile(evaluateFalse(code), '<string>', 'eval')
1007 
1008     return eval_expr(code, local_dict, global_dict)
1009 
1010 
1011 def evaluateFalse(s):
1012     """
1013     Replaces operators with the SymPy equivalent and sets evaluate=False.
1014     """
1015     node = ast.parse(s)
1016     node = EvaluateFalseTransformer().visit(node)
1017     # node is a Module, we want an Expression
1018     node = ast.Expression(node.body[0].value)
1019 
1020     return ast.fix_missing_locations(node)
1021 
1022 
1023 class EvaluateFalseTransformer(ast.NodeTransformer):
1024     operators = {
1025         ast.Add: 'Add',
1026         ast.Mult: 'Mul',
1027         ast.Pow: 'Pow',
1028         ast.Sub: 'Add',
1029         ast.Div: 'Mul',
1030         ast.BitOr: 'Or',
1031         ast.BitAnd: 'And',
1032         ast.BitXor: 'Not',
1033     }
1034 
1035     def flatten(self, args, func):
1036         result = []
1037         for arg in args:
1038             if isinstance(arg, ast.Call):
1039                 arg_func = arg.func
1040                 if isinstance(arg_func, ast.Call):
1041                     arg_func = arg_func.func
1042                 if arg_func.id == func:
1043                     result.extend(self.flatten(arg.args, func))
1044                 else:
1045                     result.append(arg)
1046             else:
1047                 result.append(arg)
1048         return result
1049 
1050     def visit_BinOp(self, node):
1051         if node.op.__class__ in self.operators:
1052             sympy_class = self.operators[node.op.__class__]
1053             right = self.visit(node.right)
1054             left = self.visit(node.left)
1055             if isinstance(node.left, ast.UnaryOp) and (isinstance(node.right, ast.UnaryOp) == 0) and sympy_class in ('Mul',):
1056                 left, right = right, left
1057             if isinstance(node.op, ast.Sub):
1058                 right = ast.Call(
1059                     func=ast.Name(id='Mul', ctx=ast.Load()),
1060                     args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(1)), right],
1061                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1062                     starargs=None,
1063                     kwargs=None
1064                 )
1065             if isinstance(node.op, ast.Div):
1066                 if isinstance(node.left, ast.UnaryOp):
1067                     if isinstance(node.right,ast.UnaryOp):
1068                         left, right = right, left
1069                     left = ast.Call(
1070                     func=ast.Name(id='Pow', ctx=ast.Load()),
1071                     args=[left, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1072                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1073                     starargs=None,
1074                     kwargs=None
1075                 )
1076                 else:
1077                     right = ast.Call(
1078                     func=ast.Name(id='Pow', ctx=ast.Load()),
1079                     args=[right, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1080                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1081                     starargs=None,
1082                     kwargs=None
1083                 )
1084 
1085             new_node = ast.Call(
1086                 func=ast.Name(id=sympy_class, ctx=ast.Load()),
1087                 args=[left, right],
1088                 keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1089                 starargs=None,
1090                 kwargs=None
1091             )
1092 
1093             if sympy_class in ('Add', 'Mul'):
1094                 # Denest Add or Mul as appropriate
1095                 new_node.args = self.flatten(new_node.args, sympy_class)
1096 
1097             return new_node
1098         return node

</code><intended_behavior>Within `eval_expr`, introduce additional safeguards against executing unverified code. This may include verifying the contents of the `code` parameter against a set of allowed operations and structures before allowing `eval` to execute. Additionally, implementing a more restricted execution context for `eval` can limit potential damage from malicious or unintended code execution. This context could limit the available namespaces and restrict execution capabilities to purely mathematical evaluations, thus reducing risk.</intended_behavior>]
2025-10-18 08:53:19.410 | INFO     | Search completed. Bug locations: [<file>sympy/core/sympify.py</file>
<class>None</class>
<method>None</method>
<code>
1 """sympify -- convert objects SymPy internal format"""
2 
3 from __future__ import print_function, division
4 
5 from inspect import getmro
6 
7 from .core import all_classes as sympy_classes
8 from .compatibility import iterable, string_types, range
9 from .evaluate import global_evaluate
10 
11 
12 class SympifyError(ValueError):
13     def __init__(self, expr, base_exc=None):
14         self.expr = expr
15         self.base_exc = base_exc
16 
17     def __str__(self):
18         if self.base_exc is None:
19             return "SympifyError: %r" % (self.expr,)
20 
21         return ("Sympify of expression '%s' failed, because of exception being "
22             "raised:\n%s: %s" % (self.expr, self.base_exc.__class__.__name__,
23             str(self.base_exc)))
24 
25 converter = {}  # See sympify docstring.
26 
27 class CantSympify(object):
28     """
29     Mix in this trait to a class to disallow sympification of its instances.
30 
31     Examples
32     ========
33 
34     >>> from sympy.core.sympify import sympify, CantSympify
35 
36     >>> class Something(dict):
37     ...     pass
38     ...
39     >>> sympify(Something())
40     {}
41 
42     >>> class Something(dict, CantSympify):
43     ...     pass
44     ...
45     >>> sympify(Something())
46     Traceback (most recent call last):
47     ...
48     SympifyError: SympifyError: {}
49 
50     """
51     pass
52 
53 
54 def _convert_numpy_types(a, **sympify_args):
55     """
56     Converts a numpy datatype input to an appropriate SymPy type.
57     """
58     import numpy as np
59     if not isinstance(a, np.floating):
60         if np.iscomplex(a):
61             return converter[complex](a.item())
62         else:
63             return sympify(a.item(), **sympify_args)
64     else:
65         try:
66             from sympy.core.numbers import Float
67             prec = np.finfo(a).nmant + 1
68             # E.g. double precision means prec=53 but nmant=52
69             # Leading bit of mantissa is always 1, so is not stored
70             a = str(list(np.reshape(np.asarray(a),
71                                     (1, np.size(a)))[0]))[1:-1]
72             return Float(a, precision=prec)
73         except NotImplementedError:
74             raise SympifyError('Translation for numpy float : %s '
75                                'is not implemented' % a)
76 
77 
78 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,
79         evaluate=None):
80     """Converts an arbitrary expression to a type that can be used inside SymPy.
81 
82     For example, it will convert Python ints into instances of sympy.Integer,
83     floats into instances of sympy.Float, etc. It is also able to coerce symbolic
84     expressions which inherit from Basic. This can be useful in cooperation
85     with SAGE.
86 
87     It currently accepts as arguments:
88        - any object defined in SymPy
89        - standard numeric python types: int, long, float, Decimal
90        - strings (like "0.09" or "2e-19")
91        - booleans, including ``None`` (will leave ``None`` unchanged)
92        - dict, lists, sets or tuples containing any of the above
93 
94     .. warning::
95         Note that this function uses ``eval``, and thus shouldn't be used on
96         unsanitized input.
97 
98     If the argument is already a type that SymPy understands, it will do
99     nothing but return that value. This can be used at the beginning of a
100     function to ensure you are working with the correct type.
101 
102     >>> from sympy import sympify
103 
104     >>> sympify(2).is_integer
105     True
106     >>> sympify(2).is_real
107     True
108 
109     >>> sympify(2.0).is_real
110     True
111     >>> sympify("2.0").is_real
112     True
113     >>> sympify("2e-45").is_real
114     True
115 
116     If the expression could not be converted, a SympifyError is raised.
117 
118     >>> sympify("x***2")
119     Traceback (most recent call last):
120     ...
121     SympifyError: SympifyError: "could not parse u'x***2'"
122 
123     Locals
124     ------
125 
126     The sympification happens with access to everything that is loaded
127     by ``from sympy import *``; anything used in a string that is not
128     defined by that import will be converted to a symbol. In the following,
129     the ``bitcount`` function is treated as a symbol and the ``O`` is
130     interpreted as the Order object (used with series) and it raises
131     an error when used improperly:
132 
133     >>> s = 'bitcount(42)'
134     >>> sympify(s)
135     bitcount(42)
136     >>> sympify("O(x)")
137     O(x)
138     >>> sympify("O + 1")
139     Traceback (most recent call last):
140     ...
141     TypeError: unbound method...
142 
143     In order to have ``bitcount`` be recognized it can be imported into a
144     namespace dictionary and passed as locals:
145 
146     >>> from sympy.core.compatibility import exec_
147     >>> ns = {}
148     >>> exec_('from sympy.core.evalf import bitcount', ns)
149     >>> sympify(s, locals=ns)
150     6
151 
152     In order to have the ``O`` interpreted as a Symbol, identify it as such
153     in the namespace dictionary. This can be done in a variety of ways; all
154     three of the following are possibilities:
155 
156     >>> from sympy import Symbol
157     >>> ns["O"] = Symbol("O")  # method 1
158     >>> exec_('from sympy.abc import O', ns)  # method 2
159     >>> ns.update(dict(O=Symbol("O")))  # method 3
160     >>> sympify("O + 1", locals=ns)
161     O + 1
162 
163     If you want *all* single-letter and Greek-letter variables to be symbols
164     then you can use the clashing-symbols dictionaries that have been defined
165     there as private variables: _clash1 (single-letter variables), _clash2
166     (the multi-letter Greek names) or _clash (both single and multi-letter
167     names that are defined in abc).
168 
169     >>> from sympy.abc import _clash1
170     >>> _clash1
171     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}
172     >>> sympify('I & Q', _clash1)
173     I & Q
174 
175     Strict
176     ------
177 
178     If the option ``strict`` is set to ``True``, only the types for which an
179     explicit conversion has been defined are converted. In the other
180     cases, a SympifyError is raised.
181 
182     >>> print(sympify(None))
183     None
184     >>> sympify(None, strict=True)
185     Traceback (most recent call last):
186     ...
187     SympifyError: SympifyError: None
188 
189     Evaluation
190     ----------
191 
192     If the option ``evaluate`` is set to ``False``, then arithmetic and
193     operators will be converted into their SymPy equivalents and the
194     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
195     be denested first. This is done via an AST transformation that replaces
196     operators with their SymPy equivalents, so if an operand redefines any
197     of those operations, the redefined operators will not be used.
198 
199     >>> sympify('2**2 / 3 + 5')
200     19/3
201     >>> sympify('2**2 / 3 + 5', evaluate=False)
202     2**2/3 + 5
203 
204     Extending
205     ---------
206 
207     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
208     just define a ``_sympy_`` method to your class. You can do that even to
209     classes that you do not own by subclassing or adding the method at runtime.
210 
211     >>> from sympy import Matrix
212     >>> class MyList1(object):
213     ...     def __iter__(self):
214     ...         yield 1
215     ...         yield 2
216     ...         return
217     ...     def __getitem__(self, i): return list(self)[i]
218     ...     def _sympy_(self): return Matrix(self)
219     >>> sympify(MyList1())
220     Matrix([
221     [1],
222     [2]])
223 
224     If you do not have control over the class definition you could also use the
225     ``converter`` global dictionary. The key is the class and the value is a
226     function that takes a single argument and returns the desired SymPy
227     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.
228 
229     >>> class MyList2(object):   # XXX Do not do this if you control the class!
230     ...     def __iter__(self):  #     Use _sympy_!
231     ...         yield 1
232     ...         yield 2
233     ...         return
234     ...     def __getitem__(self, i): return list(self)[i]
235     >>> from sympy.core.sympify import converter
236     >>> converter[MyList2] = lambda x: Matrix(x)
237     >>> sympify(MyList2())
238     Matrix([
239     [1],
240     [2]])
241 
242     Notes
243     =====
244 
245     The keywords ``rational`` and ``convert_xor`` are only used
246     when the input is a string.
247 
248     Sometimes autosimplification during sympification results in expressions
249     that are very different in structure than what was entered. Until such
250     autosimplification is no longer done, the ``kernS`` function might be of
251     some use. In the example below you can see how an expression reduces to
252     -1 by autosimplification, but does not do so when ``kernS`` is used.
253 
254     >>> from sympy.core.sympify import kernS
255     >>> from sympy.abc import x
256     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
257     -1
258     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
259     >>> sympify(s)
260     -1
261     >>> kernS(s)
262     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
263 
264     """
265     is_sympy = getattr(a, '__sympy__', None)
266     if is_sympy is not None:
267         return a
268 
269     if isinstance(a, CantSympify):
270         raise SympifyError(a)
271     cls = getattr(a, "__class__", None)
272     if cls is None:
273         cls = type(a)  # Probably an old-style class
274     conv = converter.get(cls, None)
275     if conv is not None:
276         return conv(a)
277 
278     for superclass in getmro(cls):
279         try:
280             return converter[superclass](a)
281         except KeyError:
282             continue
283 
284     if cls is type(None):
285         if strict:
286             raise SympifyError(a)
287         else:
288             return a
289 
290     if evaluate is None:
291         if global_evaluate[0] is False:
292             evaluate = global_evaluate[0]
293         else:
294             evaluate = True
295 
296     # Support for basic numpy datatypes
297     # Note that this check exists to avoid importing NumPy when not necessary
298     if type(a).__module__ == 'numpy':
299         import numpy as np
300         if np.isscalar(a):
301             return _convert_numpy_types(a, locals=locals,
302                 convert_xor=convert_xor, strict=strict, rational=rational,
303                 evaluate=evaluate)
304 
305     _sympy_ = getattr(a, "_sympy_", None)
306     if _sympy_ is not None:
307         try:
308             return a._sympy_()
309         # XXX: Catches AttributeError: 'SympyConverter' object has no
310         # attribute 'tuple'
311         # This is probably a bug somewhere but for now we catch it here.
312         except AttributeError:
313             pass
314 
315     if not strict:
316         # Put numpy array conversion _before_ float/int, see
317         # <https://github.com/sympy/sympy/issues/13924>.
318         flat = getattr(a, "flat", None)
319         if flat is not None:
320             shape = getattr(a, "shape", None)
321             if shape is not None:
322                 from ..tensor.array import Array
323                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays
324 
325     if not isinstance(a, string_types):
326         for coerce in (float, int):
327             try:
328                 coerced = coerce(a)
329             except (TypeError, ValueError):
330                 continue
331             # XXX: AttributeError only needed here for Py2
332             except AttributeError:
333                 continue
334             try:
335                 return sympify(coerced)
336             except SympifyError:
337                 continue
338 
339     if strict:
340         raise SympifyError(a)
341 
342     if iterable(a):
343         try:
344             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
345                 rational=rational) for x in a])
346         except TypeError:
347             # Not all iterables are rebuildable with their type.
348             pass
349     if isinstance(a, dict):
350         try:
351             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
352                 rational=rational) for x in a.items()])
353         except TypeError:
354             # Not all iterables are rebuildable with their type.
355             pass
356 
357     # At this point we were given an arbitrary expression
358     # which does not inherit from Basic and doesn't implement
359     # _sympy_ (which is a canonical and robust way to convert
360     # anything to SymPy expression).
361     #
362     # As a last chance, we try to take "a"'s normal form via unicode()
363     # and try to parse it. If it fails, then we have no luck and
364     # return an exception
365     try:
366         from .compatibility import unicode
367         a = unicode(a)
368     except Exception as exc:
369         raise SympifyError(a, exc)
370 
371     from sympy.parsing.sympy_parser import (parse_expr, TokenError,
372                                             standard_transformations)
373     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
374     from sympy.parsing.sympy_parser import rationalize as t_rationalize
375 
376     transformations = standard_transformations
377 
378     if rational:
379         transformations += (t_rationalize,)
380     if convert_xor:
381         transformations += (t_convert_xor,)
382 
383     try:
384         a = a.replace('\n', '')
385         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
386     except (TokenError, SyntaxError) as exc:
387         raise SympifyError('could not parse %r' % a, exc)
388 
389     return expr
390 
391 
392 def _sympify(a):
393     """
394     Short version of sympify for internal usage for __add__ and __eq__ methods
395     where it is ok to allow some things (like Python integers and floats) in
396     the expression. This excludes things (like strings) that are unwise to
397     allow into such an expression.
398 
399     >>> from sympy import Integer
400     >>> Integer(1) == 1
401     True
402 
403     >>> Integer(1) == '1'
404     False
405 
406     >>> from sympy.abc import x
407     >>> x + 1
408     x + 1
409 
410     >>> x + '1'
411     Traceback (most recent call last):
412     ...
413     TypeError: unsupported operand type(s) for +: 'Symbol' and 'str'
414 
415     see: sympify
416 
417     """
418     return sympify(a, strict=True)
419 
420 
421 def kernS(s):
422     """Use a hack to try keep autosimplification from distributing a
423     a number into an Add; this modification doesn't
424     prevent the 2-arg Mul from becoming an Add, however.
425 
426     Examples
427     ========
428 
429     >>> from sympy.core.sympify import kernS
430     >>> from sympy.abc import x, y, z
431 
432     The 2-arg Mul distributes a number (or minus sign) across the terms
433     of an expression, but kernS will prevent that:
434 
435     >>> 2*(x + y), -(x + 1)
436     (2*x + 2*y, -x - 1)
437     >>> kernS('2*(x + y)')
438     2*(x + y)
439     >>> kernS('-(x + 1)')
440     -(x + 1)
441 
442     If use of the hack fails, the un-hacked string will be passed to sympify...
443     and you get what you get.
444 
445     XXX This hack should not be necessary once issue 4596 has been resolved.
446     """
447     import string
448     from random import choice
449     from sympy.core.symbol import Symbol
450     hit = False
451     quoted = '"' in s or "'" in s
452     if '(' in s and not quoted:
453         if s.count('(') != s.count(")"):
454             raise SympifyError('unmatched left parenthesis')
455 
456         # strip all space from s
457         s = ''.join(s.split())
458         olds = s
459         # now use space to represent a symbol that
460         # will
461         # step 1. turn potential 2-arg Muls into 3-arg versions
462         # 1a. *( -> * *(
463         s = s.replace('*(', '* *(')
464         # 1b. close up exponentials
465         s = s.replace('** *', '**')
466         # 2. handle the implied multiplication of a negated
467         # parenthesized expression in two steps
468         # 2a:  -(...)  -->  -( *(...)
469         target = '-( *('
470         s = s.replace('-(', target)
471         # 2b: double the matching closing parenthesis
472         # -( *(...)  -->  -( *(...))
473         i = nest = 0
474         assert target.endswith('(')  # assumption below
475         while True:
476             j = s.find(target, i)
477             if j == -1:
478                 break
479             j += len(target) - 1
480             for j in range(j, len(s)):
481                 if s[j] == "(":
482                     nest += 1
483                 elif s[j] == ")":
484                     nest -= 1
485                 if nest == 0:
486                     break
487             s = s[:j] + ")" + s[j:]
488             i = j + 2  # the first char after 2nd )
489         if ' ' in s:
490             # get a unique kern
491             kern = '_'
492             while kern in s:
493                 kern += choice(string.ascii_letters + string.digits)
494             s = s.replace(' ', kern)
495         hit = kern in s
496 
497     for i in range(2):
498         try:
499             expr = sympify(s)
500             break
501         except:  # the kern might cause unknown errors, so use bare except
502             if hit:
503                 s = olds  # maybe it didn't like the kern; use un-kerned s
504                 hit = False
505                 continue
506             expr = sympify(s)  # let original error raise
507 
508     if not hit:
509         return expr
510 
511     rep = {Symbol(kern): 1}
512     def _clear(expr):
513         if isinstance(expr, (list, tuple, set)):
514             return type(expr)([_clear(e) for e in expr])
515         if hasattr(expr, 'subs'):
516             return expr.subs(rep, hack2=True)
517         return expr
518     expr = _clear(expr)
519     # hope that kern is not there anymore
520     return expr

</code><intended_behavior>Modify `sympify` to avoid executing `eval` on strings that are not verified to be safe SymPy expressions. This might involve additional checks or validations to ensure the string representation of an object can be safely converted into a SymPy expression. If a string does not meet these criteria, it should not be evaluated. Instead, `sympify` could either handle the input conservatively as an error or attempt non-evaluative parsing strategies that do not involve `eval`. For cases where `eval` remains necessary, implementing a sandboxed environment or using a safer evaluation strategy (e.g., AST parsing without execution) could mitigate risks. These changes aim to preserve the functionality of allowing flexible inputs to `sympify` while ensuring security and reliability.</intended_behavior>, <file>sympy/parsing/sympy_parser.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Transform a string with Python-like source code into SymPy expression. """
2 
3 from __future__ import print_function, division
4 
5 from tokenize import (generate_tokens, untokenize, TokenError,
6     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)
7 
8 from keyword import iskeyword
9 
10 import ast
11 import unicodedata
12 
13 from sympy.core.compatibility import exec_, StringIO, iterable
14 from sympy.core.basic import Basic
15 from sympy.core import Symbol
16 from sympy.core.function import arity
17 from sympy.utilities.misc import filldedent, func_name
18 
19 
20 
21 def _token_splittable(token):
22     """
23     Predicate for whether a token name can be split into multiple tokens.
24 
25     A token is splittable if it does not contain an underscore character and
26     it is not the name of a Greek letter. This is used to implicitly convert
27     expressions like 'xyz' into 'x*y*z'.
28     """
29     if '_' in token:
30         return False
31     else:
32         try:
33             return not unicodedata.lookup('GREEK SMALL LETTER ' + token)
34         except KeyError:
35             pass
36     if len(token) > 1:
37         return True
38     return False
39 
40 
41 def _token_callable(token, local_dict, global_dict, nextToken=None):
42     """
43     Predicate for whether a token name represents a callable function.
44 
45     Essentially wraps ``callable``, but looks up the token name in the
46     locals and globals.
47     """
48     func = local_dict.get(token[1])
49     if not func:
50         func = global_dict.get(token[1])
51     return callable(func) and not isinstance(func, Symbol)
52 
53 
54 def _add_factorial_tokens(name, result):
55     if result == [] or result[-1][1] == '(':
56         raise TokenError()
57 
58     beginning = [(NAME, name), (OP, '(')]
59     end = [(OP, ')')]
60 
61     diff = 0
62     length = len(result)
63 
64     for index, token in enumerate(result[::-1]):
65         toknum, tokval = token
66         i = length - index - 1
67 
68         if tokval == ')':
69             diff += 1
70         elif tokval == '(':
71             diff -= 1
72 
73         if diff == 0:
74             if i - 1 >= 0 and result[i - 1][0] == NAME:
75                 return result[:i - 1] + beginning + result[i - 1:] + end
76             else:
77                 return result[:i] + beginning + result[i:] + end
78 
79     return result
80 
81 
82 class AppliedFunction(object):
83     """
84     A group of tokens representing a function and its arguments.
85 
86     `exponent` is for handling the shorthand sin^2, ln^2, etc.
87     """
88     def __init__(self, function, args, exponent=None):
89         if exponent is None:
90             exponent = []
91         self.function = function
92         self.args = args
93         self.exponent = exponent
94         self.items = ['function', 'args', 'exponent']
95 
96     def expand(self):
97         """Return a list of tokens representing the function"""
98         result = []
99         result.append(self.function)
100         result.extend(self.args)
101         return result
102 
103     def __getitem__(self, index):
104         return getattr(self, self.items[index])
105 
106     def __repr__(self):
107         return "AppliedFunction(%s, %s, %s)" % (self.function, self.args,
108                                                 self.exponent)
109 
110 
111 class ParenthesisGroup(list):
112     """List of tokens representing an expression in parentheses."""
113     pass
114 
115 
116 def _flatten(result):
117     result2 = []
118     for tok in result:
119         if isinstance(tok, AppliedFunction):
120             result2.extend(tok.expand())
121         else:
122             result2.append(tok)
123     return result2
124 
125 
126 def _group_parentheses(recursor):
127     def _inner(tokens, local_dict, global_dict):
128         """Group tokens between parentheses with ParenthesisGroup.
129 
130         Also processes those tokens recursively.
131 
132         """
133         result = []
134         stacks = []
135         stacklevel = 0
136         for token in tokens:
137             if token[0] == OP:
138                 if token[1] == '(':
139                     stacks.append(ParenthesisGroup([]))
140                     stacklevel += 1
141                 elif token[1] == ')':
142                     stacks[-1].append(token)
143                     stack = stacks.pop()
144 
145                     if len(stacks) > 0:
146                         # We don't recurse here since the upper-level stack
147                         # would reprocess these tokens
148                         stacks[-1].extend(stack)
149                     else:
150                         # Recurse here to handle nested parentheses
151                         # Strip off the outer parentheses to avoid an infinite loop
152                         inner = stack[1:-1]
153                         inner = recursor(inner,
154                                          local_dict,
155                                          global_dict)
156                         parenGroup = [stack[0]] + inner + [stack[-1]]
157                         result.append(ParenthesisGroup(parenGroup))
158                     stacklevel -= 1
159                     continue
160             if stacklevel:
161                 stacks[-1].append(token)
162             else:
163                 result.append(token)
164         if stacklevel:
165             raise TokenError("Mismatched parentheses")
166         return result
167     return _inner
168 
169 
170 def _apply_functions(tokens, local_dict, global_dict):
171     """Convert a NAME token + ParenthesisGroup into an AppliedFunction.
172 
173     Note that ParenthesisGroups, if not applied to any function, are
174     converted back into lists of tokens.
175 
176     """
177     result = []
178     symbol = None
179     for tok in tokens:
180         if tok[0] == NAME:
181             symbol = tok
182             result.append(tok)
183         elif isinstance(tok, ParenthesisGroup):
184             if symbol and _token_callable(symbol, local_dict, global_dict):
185                 result[-1] = AppliedFunction(symbol, tok)
186                 symbol = None
187             else:
188                 result.extend(tok)
189         else:
190             symbol = None
191             result.append(tok)
192     return result
193 
194 
195 def _implicit_multiplication(tokens, local_dict, global_dict):
196     """Implicitly adds '*' tokens.
197 
198     Cases:
199 
200     - Two AppliedFunctions next to each other ("sin(x)cos(x)")
201 
202     - AppliedFunction next to an open parenthesis ("sin x (cos x + 1)")
203 
204     - A close parenthesis next to an AppliedFunction ("(x+2)sin x")\
205 
206     - A close parenthesis next to an open parenthesis ("(x+2)(x+3)")
207 
208     - AppliedFunction next to an implicitly applied function ("sin(x)cos x")
209 
210     """
211     result = []
212     for tok, nextTok in zip(tokens, tokens[1:]):
213         result.append(tok)
214         if (isinstance(tok, AppliedFunction) and
215               isinstance(nextTok, AppliedFunction)):
216             result.append((OP, '*'))
217         elif (isinstance(tok, AppliedFunction) and
218               nextTok[0] == OP and nextTok[1] == '('):
219             # Applied function followed by an open parenthesis
220             if tok.function[1] == "Function":
221                 result[-1].function = (result[-1].function[0], 'Symbol')
222             result.append((OP, '*'))
223         elif (tok[0] == OP and tok[1] == ')' and
224               isinstance(nextTok, AppliedFunction)):
225             # Close parenthesis followed by an applied function
226             result.append((OP, '*'))
227         elif (tok[0] == OP and tok[1] == ')' and
228               nextTok[0] == NAME):
229             # Close parenthesis followed by an implicitly applied function
230             result.append((OP, '*'))
231         elif (tok[0] == nextTok[0] == OP
232               and tok[1] == ')' and nextTok[1] == '('):
233             # Close parenthesis followed by an open parenthesis
234             result.append((OP, '*'))
235         elif (isinstance(tok, AppliedFunction) and nextTok[0] == NAME):
236             # Applied function followed by implicitly applied function
237             result.append((OP, '*'))
238         elif (tok[0] == NAME and
239               not _token_callable(tok, local_dict, global_dict) and
240               nextTok[0] == OP and nextTok[1] == '('):
241             # Constant followed by parenthesis
242             result.append((OP, '*'))
243         elif (tok[0] == NAME and
244               not _token_callable(tok, local_dict, global_dict) and
245               nextTok[0] == NAME and
246               not _token_callable(nextTok, local_dict, global_dict)):
247             # Constant followed by constant
248             result.append((OP, '*'))
249         elif (tok[0] == NAME and
250               not _token_callable(tok, local_dict, global_dict) and
251               (isinstance(nextTok, AppliedFunction) or nextTok[0] == NAME)):
252             # Constant followed by (implicitly applied) function
253             result.append((OP, '*'))
254     if tokens:
255         result.append(tokens[-1])
256     return result
257 
258 
259 def _implicit_application(tokens, local_dict, global_dict):
260     """Adds parentheses as needed after functions."""
261     result = []
262     appendParen = 0  # number of closing parentheses to add
263     skip = 0  # number of tokens to delay before adding a ')' (to
264               # capture **, ^, etc.)
265     exponentSkip = False  # skipping tokens before inserting parentheses to
266                           # work with function exponentiation
267     for tok, nextTok in zip(tokens, tokens[1:]):
268         result.append(tok)
269         if (tok[0] == NAME and nextTok[0] not in [OP, ENDMARKER, NEWLINE]):
270             if _token_callable(tok, local_dict, global_dict, nextTok):
271                 result.append((OP, '('))
272                 appendParen += 1
273         # name followed by exponent - function exponentiation
274         elif (tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**'):
275             if _token_callable(tok, local_dict, global_dict):
276                 exponentSkip = True
277         elif exponentSkip:
278             # if the last token added was an applied function (i.e. the
279             # power of the function exponent) OR a multiplication (as
280             # implicit multiplication would have added an extraneous
281             # multiplication)
282             if (isinstance(tok, AppliedFunction)
283                 or (tok[0] == OP and tok[1] == '*')):
284                 # don't add anything if the next token is a multiplication
285                 # or if there's already a parenthesis (if parenthesis, still
286                 # stop skipping tokens)
287                 if not (nextTok[0] == OP and nextTok[1] == '*'):
288                     if not(nextTok[0] == OP and nextTok[1] == '('):
289                         result.append((OP, '('))
290                         appendParen += 1
291                     exponentSkip = False
292         elif appendParen:
293             if nextTok[0] == OP and nextTok[1] in ('^', '**', '*'):
294                 skip = 1
295                 continue
296             if skip:
297                 skip -= 1
298                 continue
299             result.append((OP, ')'))
300             appendParen -= 1
301 
302     if tokens:
303         result.append(tokens[-1])
304 
305     if appendParen:
306         result.extend([(OP, ')')] * appendParen)
307     return result
308 
309 
310 def function_exponentiation(tokens, local_dict, global_dict):
311     """Allows functions to be exponentiated, e.g. ``cos**2(x)``.
312 
313     Examples
314     ========
315 
316     >>> from sympy.parsing.sympy_parser import (parse_expr,
317     ... standard_transformations, function_exponentiation)
318     >>> transformations = standard_transformations + (function_exponentiation,)
319     >>> parse_expr('sin**4(x)', transformations=transformations)
320     sin(x)**4
321     """
322     result = []
323     exponent = []
324     consuming_exponent = False
325     level = 0
326     for tok, nextTok in zip(tokens, tokens[1:]):
327         if tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**':
328             if _token_callable(tok, local_dict, global_dict):
329                 consuming_exponent = True
330         elif consuming_exponent:
331             if tok[0] == NAME and tok[1] == 'Function':
332                 tok = (NAME, 'Symbol')
333             exponent.append(tok)
334 
335             # only want to stop after hitting )
336             if tok[0] == nextTok[0] == OP and tok[1] == ')' and nextTok[1] == '(':
337                 consuming_exponent = False
338             # if implicit multiplication was used, we may have )*( instead
339             if tok[0] == nextTok[0] == OP and tok[1] == '*' and nextTok[1] == '(':
340                 consuming_exponent = False
341                 del exponent[-1]
342             continue
343         elif exponent and not consuming_exponent:
344             if tok[0] == OP:
345                 if tok[1] == '(':
346                     level += 1
347                 elif tok[1] == ')':
348                     level -= 1
349             if level == 0:
350                 result.append(tok)
351                 result.extend(exponent)
352                 exponent = []
353                 continue
354         result.append(tok)
355     if tokens:
356         result.append(tokens[-1])
357     if exponent:
358         result.extend(exponent)
359     return result
360 
361 
362 def split_symbols_custom(predicate):
363     """Creates a transformation that splits symbol names.
364 
365     ``predicate`` should return True if the symbol name is to be split.
366 
367     For instance, to retain the default behavior but avoid splitting certain
368     symbol names, a predicate like this would work:
369 
370 
371     >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,
372     ... standard_transformations, implicit_multiplication,
373     ... split_symbols_custom)
374     >>> def can_split(symbol):
375     ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):
376     ...             return _token_splittable(symbol)
377     ...     return False
378     ...
379     >>> transformation = split_symbols_custom(can_split)
380     >>> parse_expr('unsplittable', transformations=standard_transformations +
381     ... (transformation, implicit_multiplication))
382     unsplittable
383     """
384     def _split_symbols(tokens, local_dict, global_dict):
385         result = []
386         split = False
387         split_previous=False
388 
389         for tok in tokens:
390             if split_previous:
391                 # throw out closing parenthesis of Symbol that was split
392                 split_previous=False
393                 continue
394             split_previous=False
395 
396             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:
397                 split = True
398 
399             elif split and tok[0] == NAME:
400                 symbol = tok[1][1:-1]
401 
402                 if predicate(symbol):
403                     tok_type = result[-2][1]  # Symbol or Function
404                     del result[-2:]  # Get rid of the call to Symbol
405 
406                     i = 0
407                     while i < len(symbol):
408                         char = symbol[i]
409                         if char in local_dict or char in global_dict:
410                             result.extend([(NAME, "%s" % char)])
411                         elif char.isdigit():
412                             char = [char]
413                             for i in range(i + 1, len(symbol)):
414                                 if not symbol[i].isdigit():
415                                   i -= 1
416                                   break
417                                 char.append(symbol[i])
418                             char = ''.join(char)
419                             result.extend([(NAME, 'Number'), (OP, '('),
420                                            (NAME, "'%s'" % char), (OP, ')')])
421                         else:
422                             use = tok_type if i == len(symbol) else 'Symbol'
423                             result.extend([(NAME, use), (OP, '('),
424                                            (NAME, "'%s'" % char), (OP, ')')])
425                         i += 1
426 
427                     # Set split_previous=True so will skip
428                     # the closing parenthesis of the original Symbol
429                     split = False
430                     split_previous = True
431                     continue
432 
433                 else:
434                     split = False
435 
436             result.append(tok)
437 
438         return result
439 
440     return _split_symbols
441 
442 
443 #: Splits symbol names for implicit multiplication.
444 #:
445 #: Intended to let expressions like ``xyz`` be parsed as ``x*y*z``. Does not
446 #: split Greek character names, so ``theta`` will *not* become
447 #: ``t*h*e*t*a``. Generally this should be used with
448 #: ``implicit_multiplication``.
449 split_symbols = split_symbols_custom(_token_splittable)
450 
451 
452 def implicit_multiplication(result, local_dict, global_dict):
453     """Makes the multiplication operator optional in most cases.
454 
455     Use this before :func:`implicit_application`, otherwise expressions like
456     ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.
457 
458     Examples
459     ========
460 
461     >>> from sympy.parsing.sympy_parser import (parse_expr,
462     ... standard_transformations, implicit_multiplication)
463     >>> transformations = standard_transformations + (implicit_multiplication,)
464     >>> parse_expr('3 x y', transformations=transformations)
465     3*x*y
466     """
467     # These are interdependent steps, so we don't expose them separately
468     for step in (_group_parentheses(implicit_multiplication),
469                  _apply_functions,
470                  _implicit_multiplication):
471         result = step(result, local_dict, global_dict)
472 
473     result = _flatten(result)
474     return result
475 
476 
477 def implicit_application(result, local_dict, global_dict):
478     """Makes parentheses optional in some cases for function calls.
479 
480     Use this after :func:`implicit_multiplication`, otherwise expressions
481     like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than
482     ``sin(2*x)``.
483 
484     Examples
485     ========
486 
487     >>> from sympy.parsing.sympy_parser import (parse_expr,
488     ... standard_transformations, implicit_application)
489     >>> transformations = standard_transformations + (implicit_application,)
490     >>> parse_expr('cot z + csc z', transformations=transformations)
491     cot(z) + csc(z)
492     """
493     for step in (_group_parentheses(implicit_application),
494                  _apply_functions,
495                  _implicit_application,):
496         result = step(result, local_dict, global_dict)
497 
498     result = _flatten(result)
499     return result
500 
501 
502 def implicit_multiplication_application(result, local_dict, global_dict):
503     """Allows a slightly relaxed syntax.
504 
505     - Parentheses for single-argument method calls are optional.
506 
507     - Multiplication is implicit.
508 
509     - Symbol names can be split (i.e. spaces are not needed between
510       symbols).
511 
512     - Functions can be exponentiated.
513 
514     Examples
515     ========
516 
517     >>> from sympy.parsing.sympy_parser import (parse_expr,
518     ... standard_transformations, implicit_multiplication_application)
519     >>> parse_expr("10sin**2 x**2 + 3xyz + tan theta",
520     ... transformations=(standard_transformations +
521     ... (implicit_multiplication_application,)))
522     3*x*y*z + 10*sin(x**2)**2 + tan(theta)
523 
524     """
525     for step in (split_symbols, implicit_multiplication,
526                  implicit_application, function_exponentiation):
527         result = step(result, local_dict, global_dict)
528 
529     return result
530 
531 
532 def auto_symbol(tokens, local_dict, global_dict):
533     """Inserts calls to ``Symbol``/``Function`` for undefined variables."""
534     result = []
535     prevTok = (None, None)
536 
537     tokens.append((None, None))  # so zip traverses all tokens
538     for tok, nextTok in zip(tokens, tokens[1:]):
539         tokNum, tokVal = tok
540         nextTokNum, nextTokVal = nextTok
541         if tokNum == NAME:
542             name = tokVal
543 
544             if (name in ['True', 'False', 'None']
545                 or iskeyword(name)
546                 # Don't convert attribute access
547                 or (prevTok[0] == OP and prevTok[1] == '.')
548                 # Don't convert keyword arguments
549                 or (prevTok[0] == OP and prevTok[1] in ('(', ',')
550                     and nextTokNum == OP and nextTokVal == '=')):
551                 result.append((NAME, name))
552                 continue
553             elif name in local_dict:
554                 if isinstance(local_dict[name], Symbol) and nextTokVal == '(':
555                     result.extend([(NAME, 'Function'),
556                                    (OP, '('),
557                                    (NAME, repr(str(local_dict[name]))),
558                                    (OP, ')')])
559                 else:
560                     result.append((NAME, name))
561                 continue
562             elif name in global_dict:
563                 obj = global_dict[name]
564                 if isinstance(obj, (Basic, type)) or callable(obj):
565                     result.append((NAME, name))
566                     continue
567 
568             result.extend([
569                 (NAME, 'Symbol' if nextTokVal != '(' else 'Function'),
570                 (OP, '('),
571                 (NAME, repr(str(name))),
572                 (OP, ')'),
573             ])
574         else:
575             result.append((tokNum, tokVal))
576 
577         prevTok = (tokNum, tokVal)
578 
579     return result
580 
581 
582 def lambda_notation(tokens, local_dict, global_dict):
583     """Substitutes "lambda" with its Sympy equivalent Lambda().
584     However, the conversion doesn't take place if only "lambda"
585     is passed because that is a syntax error.
586 
587     """
588     result = []
589     flag = False
590     toknum, tokval = tokens[0]
591     tokLen = len(tokens)
592 
593     if toknum == NAME and tokval == 'lambda':
594         if tokLen == 2 or tokLen == 3 and tokens[1][0] == NEWLINE:
595             # In Python 3.6.7+, inputs without a newline get NEWLINE added to
596             # the tokens
597             result.extend(tokens)
598         elif tokLen > 2:
599             result.extend([
600                 (NAME, 'Lambda'),
601                 (OP, '('),
602                 (OP, '('),
603                 (OP, ')'),
604                 (OP, ')'),
605             ])
606             for tokNum, tokVal in tokens[1:]:
607                 if tokNum == OP and tokVal == ':':
608                     tokVal = ','
609                     flag = True
610                 if not flag and tokNum == OP and tokVal in ['*', '**']:
611                     raise TokenError("Starred arguments in lambda not supported")
612                 if flag:
613                     result.insert(-1, (tokNum, tokVal))
614                 else:
615                     result.insert(-2, (tokNum, tokVal))
616     else:
617         result.extend(tokens)
618 
619     return result
620 
621 
622 def factorial_notation(tokens, local_dict, global_dict):
623     """Allows standard notation for factorial."""
624     result = []
625     nfactorial = 0
626     for toknum, tokval in tokens:
627         if toknum == ERRORTOKEN:
628             op = tokval
629             if op == '!':
630                 nfactorial += 1
631             else:
632                 nfactorial = 0
633                 result.append((OP, op))
634         else:
635             if nfactorial == 1:
636                 result = _add_factorial_tokens('factorial', result)
637             elif nfactorial == 2:
638                 result = _add_factorial_tokens('factorial2', result)
639             elif nfactorial > 2:
640                 raise TokenError
641             nfactorial = 0
642             result.append((toknum, tokval))
643     return result
644 
645 
646 def convert_xor(tokens, local_dict, global_dict):
647     """Treats XOR, ``^``, as exponentiation, ``**``."""
648     result = []
649     for toknum, tokval in tokens:
650         if toknum == OP:
651             if tokval == '^':
652                 result.append((OP, '**'))
653             else:
654                 result.append((toknum, tokval))
655         else:
656             result.append((toknum, tokval))
657 
658     return result
659 
660 
661 def repeated_decimals(tokens, local_dict, global_dict):
662     """
663     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)
664 
665     Run this before auto_number.
666 
667     """
668     result = []
669 
670     def is_digit(s):
671         return all(i in '0123456789_' for i in s)
672 
673     # num will running match any DECIMAL [ INTEGER ]
674     num = []
675     for toknum, tokval in tokens:
676         if toknum == NUMBER:
677             if (not num and '.' in tokval and 'e' not in tokval.lower() and
678                 'j' not in tokval.lower()):
679                 num.append((toknum, tokval))
680             elif is_digit(tokval)and  len(num) == 2:
681                 num.append((toknum, tokval))
682             elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):
683                 # Python 2 tokenizes 00123 as '00', '123'
684                 # Python 3 tokenizes 01289 as '012', '89'
685                 num.append((toknum, tokval))
686             else:
687                 num = []
688         elif toknum == OP:
689             if tokval == '[' and len(num) == 1:
690                 num.append((OP, tokval))
691             elif tokval == ']' and len(num) >= 3:
692                 num.append((OP, tokval))
693             elif tokval == '.' and not num:
694                 # handle .[1]
695                 num.append((NUMBER, '0.'))
696             else:
697                 num = []
698         else:
699             num = []
700 
701         result.append((toknum, tokval))
702 
703         if num and num[-1][1] == ']':
704             # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,
705             # and d/e = repetend
706             result = result[:-len(num)]
707             pre, post = num[0][1].split('.')
708             repetend = num[2][1]
709             if len(num) == 5:
710                 repetend += num[3][1]
711 
712             pre = pre.replace('_', '')
713             post = post.replace('_', '')
714             repetend = repetend.replace('_', '')
715 
716             zeros = '0'*len(post)
717             post, repetends = [w.lstrip('0') for w in [post, repetend]]
718                                         # or else interpreted as octal
719 
720             a = pre or '0'
721             b, c = post or '0', '1' + zeros
722             d, e = repetends, ('9'*len(repetend)) + zeros
723 
724             seq = [
725                 (OP, '('),
726                     (NAME, 'Integer'),
727                     (OP, '('),
728                         (NUMBER, a),
729                     (OP, ')'),
730                     (OP, '+'),
731                     (NAME, 'Rational'),
732                     (OP, '('),
733                         (NUMBER, b),
734                         (OP, ','),
735                         (NUMBER, c),
736                     (OP, ')'),
737                     (OP, '+'),
738                     (NAME, 'Rational'),
739                     (OP, '('),
740                         (NUMBER, d),
741                         (OP, ','),
742                         (NUMBER, e),
743                     (OP, ')'),
744                 (OP, ')'),
745             ]
746             result.extend(seq)
747             num = []
748 
749     return result
750 
751 
752 def auto_number(tokens, local_dict, global_dict):
753     """
754     Converts numeric literals to use SymPy equivalents.
755 
756     Complex numbers use ``I``, integer literals use ``Integer``, and float
757     literals use ``Float``.
758 
759     """
760     result = []
761 
762     for toknum, tokval in tokens:
763         if toknum == NUMBER:
764             number = tokval
765             postfix = []
766 
767             if number.endswith('j') or number.endswith('J'):
768                 number = number[:-1]
769                 postfix = [(OP, '*'), (NAME, 'I')]
770 
771             if '.' in number or (('e' in number or 'E' in number) and
772                     not (number.startswith('0x') or number.startswith('0X'))):
773                 seq = [(NAME, 'Float'), (OP, '('),
774                     (NUMBER, repr(str(number))), (OP, ')')]
775             else:
776                 seq = [(NAME, 'Integer'), (OP, '('), (
777                     NUMBER, number), (OP, ')')]
778 
779             result.extend(seq + postfix)
780         else:
781             result.append((toknum, tokval))
782 
783     return result
784 
785 
786 def rationalize(tokens, local_dict, global_dict):
787     """Converts floats into ``Rational``. Run AFTER ``auto_number``."""
788     result = []
789     passed_float = False
790     for toknum, tokval in tokens:
791         if toknum == NAME:
792             if tokval == 'Float':
793                 passed_float = True
794                 tokval = 'Rational'
795             result.append((toknum, tokval))
796         elif passed_float == True and toknum == NUMBER:
797             passed_float = False
798             result.append((STRING, tokval))
799         else:
800             result.append((toknum, tokval))
801 
802     return result
803 
804 
805 def _transform_equals_sign(tokens, local_dict, global_dict):
806     """Transforms the equals sign ``=`` to instances of Eq.
807 
808     This is a helper function for `convert_equals_signs`.
809     Works with expressions containing one equals sign and no
810     nesting. Expressions like `(1=2)=False` won't work with this
811     and should be used with `convert_equals_signs`.
812 
813     Examples: 1=2     to Eq(1,2)
814               1*2=x   to Eq(1*2, x)
815 
816     This does not deal with function arguments yet.
817 
818     """
819     result = []
820     if (OP, "=") in tokens:
821         result.append((NAME, "Eq"))
822         result.append((OP, "("))
823         for index, token in enumerate(tokens):
824             if token == (OP, "="):
825                 result.append((OP, ","))
826                 continue
827             result.append(token)
828         result.append((OP, ")"))
829     else:
830         result = tokens
831     return result
832 
833 
834 def convert_equals_signs(result, local_dict, global_dict):
835     """ Transforms all the equals signs ``=`` to instances of Eq.
836 
837     Parses the equals signs in the expression and replaces them with
838     appropriate Eq instances.Also works with nested equals signs.
839 
840     Does not yet play well with function arguments.
841     For example, the expression `(x=y)` is ambiguous and can be interpreted
842     as x being an argument to a function and `convert_equals_signs` won't
843     work for this.
844 
845     See also
846     ========
847     convert_equality_operators
848 
849     Examples
850     ========
851 
852     >>> from sympy.parsing.sympy_parser import (parse_expr,
853     ... standard_transformations, convert_equals_signs)
854     >>> parse_expr("1*2=x", transformations=(
855     ... standard_transformations + (convert_equals_signs,)))
856     Eq(2, x)
857     >>> parse_expr("(1*2=x)=False", transformations=(
858     ... standard_transformations + (convert_equals_signs,)))
859     Eq(Eq(2, x), False)
860 
861     """
862     for step in (_group_parentheses(convert_equals_signs),
863                   _apply_functions,
864                   _transform_equals_sign):
865         result = step(result, local_dict, global_dict)
866 
867     result = _flatten(result)
868     return result
869 
870 
871 #: Standard transformations for :func:`parse_expr`.
872 #: Inserts calls to :class:`~.Symbol`, :class:`~.Integer`, and other SymPy
873 #: datatypes and allows the use of standard factorial notation (e.g. ``x!``).
874 standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,
875     factorial_notation)
876 
877 
878 def stringify_expr(s, local_dict, global_dict, transformations):
879     """
880     Converts the string ``s`` to Python code, in ``local_dict``
881 
882     Generally, ``parse_expr`` should be used.
883     """
884 
885     tokens = []
886     input_code = StringIO(s.strip())
887     for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):
888         tokens.append((toknum, tokval))
889 
890     for transform in transformations:
891         tokens = transform(tokens, local_dict, global_dict)
892 
893     return untokenize(tokens)
894 
895 
896 def eval_expr(code, local_dict, global_dict):
897     """
898     Evaluate Python code generated by ``stringify_expr``.
899 
900     Generally, ``parse_expr`` should be used.
901     """
902     expr = eval(
903         code, global_dict, local_dict)  # take local objects in preference
904 
905     return expr
906 
907 
908 def parse_expr(s, local_dict=None, transformations=standard_transformations,
909                global_dict=None, evaluate=True):
910     """Converts the string ``s`` to a SymPy expression, in ``local_dict``
911 
912     Parameters
913     ==========
914 
915     s : str
916         The string to parse.
917 
918     local_dict : dict, optional
919         A dictionary of local variables to use when parsing.
920 
921     global_dict : dict, optional
922         A dictionary of global variables. By default, this is initialized
923         with ``from sympy import *``; provide this parameter to override
924         this behavior (for instance, to parse ``"Q & S"``).
925 
926     transformations : tuple, optional
927         A tuple of transformation functions used to modify the tokens of the
928         parsed expression before evaluation. The default transformations
929         convert numeric literals into their SymPy equivalents, convert
930         undefined variables into SymPy symbols, and allow the use of standard
931         mathematical factorial notation (e.g. ``x!``).
932 
933     evaluate : bool, optional
934         When False, the order of the arguments will remain as they were in the
935         string and automatic simplification that would normally occur is
936         suppressed. (see examples)
937 
938     Examples
939     ========
940 
941     >>> from sympy.parsing.sympy_parser import parse_expr
942     >>> parse_expr("1/2")
943     1/2
944     >>> type(_)
945     <class 'sympy.core.numbers.Half'>
946     >>> from sympy.parsing.sympy_parser import standard_transformations,\\
947     ... implicit_multiplication_application
948     >>> transformations = (standard_transformations +
949     ...     (implicit_multiplication_application,))
950     >>> parse_expr("2x", transformations=transformations)
951     2*x
952 
953     When evaluate=False, some automatic simplifications will not occur:
954 
955     >>> parse_expr("2**3"), parse_expr("2**3", evaluate=False)
956     (8, 2**3)
957 
958     In addition the order of the arguments will not be made canonical.
959     This feature allows one to tell exactly how the expression was entered:
960 
961     >>> a = parse_expr('1 + x', evaluate=False)
962     >>> b = parse_expr('x + 1', evaluate=0)
963     >>> a == b
964     False
965     >>> a.args
966     (1, x)
967     >>> b.args
968     (x, 1)
969 
970     See Also
971     ========
972 
973     stringify_expr, eval_expr, standard_transformations,
974     implicit_multiplication_application
975 
976     """
977 
978     if local_dict is None:
979         local_dict = {}
980     elif not isinstance(local_dict, dict):
981         raise TypeError('expecting local_dict to be a dict')
982 
983     if global_dict is None:
984         global_dict = {}
985         exec_('from sympy import *', global_dict)
986     elif not isinstance(global_dict, dict):
987         raise TypeError('expecting global_dict to be a dict')
988 
989     transformations = transformations or ()
990     if transformations:
991         if not iterable(transformations):
992             raise TypeError(
993                 '`transformations` should be a list of functions.')
994         for _ in transformations:
995             if not callable(_):
996                 raise TypeError(filldedent('''
997                     expected a function in `transformations`,
998                     not %s''' % func_name(_)))
999             if arity(_) != 3:
1000                 raise TypeError(filldedent('''
1001                     a transformation should be function that
1002                     takes 3 arguments'''))
1003     code = stringify_expr(s, local_dict, global_dict, transformations)
1004 
1005     if not evaluate:
1006         code = compile(evaluateFalse(code), '<string>', 'eval')
1007 
1008     return eval_expr(code, local_dict, global_dict)
1009 
1010 
1011 def evaluateFalse(s):
1012     """
1013     Replaces operators with the SymPy equivalent and sets evaluate=False.
1014     """
1015     node = ast.parse(s)
1016     node = EvaluateFalseTransformer().visit(node)
1017     # node is a Module, we want an Expression
1018     node = ast.Expression(node.body[0].value)
1019 
1020     return ast.fix_missing_locations(node)
1021 
1022 
1023 class EvaluateFalseTransformer(ast.NodeTransformer):
1024     operators = {
1025         ast.Add: 'Add',
1026         ast.Mult: 'Mul',
1027         ast.Pow: 'Pow',
1028         ast.Sub: 'Add',
1029         ast.Div: 'Mul',
1030         ast.BitOr: 'Or',
1031         ast.BitAnd: 'And',
1032         ast.BitXor: 'Not',
1033     }
1034 
1035     def flatten(self, args, func):
1036         result = []
1037         for arg in args:
1038             if isinstance(arg, ast.Call):
1039                 arg_func = arg.func
1040                 if isinstance(arg_func, ast.Call):
1041                     arg_func = arg_func.func
1042                 if arg_func.id == func:
1043                     result.extend(self.flatten(arg.args, func))
1044                 else:
1045                     result.append(arg)
1046             else:
1047                 result.append(arg)
1048         return result
1049 
1050     def visit_BinOp(self, node):
1051         if node.op.__class__ in self.operators:
1052             sympy_class = self.operators[node.op.__class__]
1053             right = self.visit(node.right)
1054             left = self.visit(node.left)
1055             if isinstance(node.left, ast.UnaryOp) and (isinstance(node.right, ast.UnaryOp) == 0) and sympy_class in ('Mul',):
1056                 left, right = right, left
1057             if isinstance(node.op, ast.Sub):
1058                 right = ast.Call(
1059                     func=ast.Name(id='Mul', ctx=ast.Load()),
1060                     args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(1)), right],
1061                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1062                     starargs=None,
1063                     kwargs=None
1064                 )
1065             if isinstance(node.op, ast.Div):
1066                 if isinstance(node.left, ast.UnaryOp):
1067                     if isinstance(node.right,ast.UnaryOp):
1068                         left, right = right, left
1069                     left = ast.Call(
1070                     func=ast.Name(id='Pow', ctx=ast.Load()),
1071                     args=[left, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1072                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1073                     starargs=None,
1074                     kwargs=None
1075                 )
1076                 else:
1077                     right = ast.Call(
1078                     func=ast.Name(id='Pow', ctx=ast.Load()),
1079                     args=[right, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1080                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1081                     starargs=None,
1082                     kwargs=None
1083                 )
1084 
1085             new_node = ast.Call(
1086                 func=ast.Name(id=sympy_class, ctx=ast.Load()),
1087                 args=[left, right],
1088                 keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1089                 starargs=None,
1090                 kwargs=None
1091             )
1092 
1093             if sympy_class in ('Add', 'Mul'):
1094                 # Denest Add or Mul as appropriate
1095                 new_node.args = self.flatten(new_node.args, sympy_class)
1096 
1097             return new_node
1098         return node

</code><intended_behavior>`parse_expr` should be adapted to include safety checks or robust parsing strategies that prevent the execution of potentially dangerous or unintended code. This includes validating input strings and potentially sanitizing inputs to remove or handle known dangerous patterns before parsing and evaluation. Moreover, `parse_expr` should handle cases where the `eval_expr` function is called, ensuring that any code passed to `eval_expr` has been verified as safe. In scenarios where evaluation could lead to unsafe behavior, `parse_expr` could fall back to error handling mechanisms that avoid execution while still providing useful feedback to the user.</intended_behavior>, <file>sympy/parsing/sympy_parser.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Transform a string with Python-like source code into SymPy expression. """
2 
3 from __future__ import print_function, division
4 
5 from tokenize import (generate_tokens, untokenize, TokenError,
6     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)
7 
8 from keyword import iskeyword
9 
10 import ast
11 import unicodedata
12 
13 from sympy.core.compatibility import exec_, StringIO, iterable
14 from sympy.core.basic import Basic
15 from sympy.core import Symbol
16 from sympy.core.function import arity
17 from sympy.utilities.misc import filldedent, func_name
18 
19 
20 
21 def _token_splittable(token):
22     """
23     Predicate for whether a token name can be split into multiple tokens.
24 
25     A token is splittable if it does not contain an underscore character and
26     it is not the name of a Greek letter. This is used to implicitly convert
27     expressions like 'xyz' into 'x*y*z'.
28     """
29     if '_' in token:
30         return False
31     else:
32         try:
33             return not unicodedata.lookup('GREEK SMALL LETTER ' + token)
34         except KeyError:
35             pass
36     if len(token) > 1:
37         return True
38     return False
39 
40 
41 def _token_callable(token, local_dict, global_dict, nextToken=None):
42     """
43     Predicate for whether a token name represents a callable function.
44 
45     Essentially wraps ``callable``, but looks up the token name in the
46     locals and globals.
47     """
48     func = local_dict.get(token[1])
49     if not func:
50         func = global_dict.get(token[1])
51     return callable(func) and not isinstance(func, Symbol)
52 
53 
54 def _add_factorial_tokens(name, result):
55     if result == [] or result[-1][1] == '(':
56         raise TokenError()
57 
58     beginning = [(NAME, name), (OP, '(')]
59     end = [(OP, ')')]
60 
61     diff = 0
62     length = len(result)
63 
64     for index, token in enumerate(result[::-1]):
65         toknum, tokval = token
66         i = length - index - 1
67 
68         if tokval == ')':
69             diff += 1
70         elif tokval == '(':
71             diff -= 1
72 
73         if diff == 0:
74             if i - 1 >= 0 and result[i - 1][0] == NAME:
75                 return result[:i - 1] + beginning + result[i - 1:] + end
76             else:
77                 return result[:i] + beginning + result[i:] + end
78 
79     return result
80 
81 
82 class AppliedFunction(object):
83     """
84     A group of tokens representing a function and its arguments.
85 
86     `exponent` is for handling the shorthand sin^2, ln^2, etc.
87     """
88     def __init__(self, function, args, exponent=None):
89         if exponent is None:
90             exponent = []
91         self.function = function
92         self.args = args
93         self.exponent = exponent
94         self.items = ['function', 'args', 'exponent']
95 
96     def expand(self):
97         """Return a list of tokens representing the function"""
98         result = []
99         result.append(self.function)
100         result.extend(self.args)
101         return result
102 
103     def __getitem__(self, index):
104         return getattr(self, self.items[index])
105 
106     def __repr__(self):
107         return "AppliedFunction(%s, %s, %s)" % (self.function, self.args,
108                                                 self.exponent)
109 
110 
111 class ParenthesisGroup(list):
112     """List of tokens representing an expression in parentheses."""
113     pass
114 
115 
116 def _flatten(result):
117     result2 = []
118     for tok in result:
119         if isinstance(tok, AppliedFunction):
120             result2.extend(tok.expand())
121         else:
122             result2.append(tok)
123     return result2
124 
125 
126 def _group_parentheses(recursor):
127     def _inner(tokens, local_dict, global_dict):
128         """Group tokens between parentheses with ParenthesisGroup.
129 
130         Also processes those tokens recursively.
131 
132         """
133         result = []
134         stacks = []
135         stacklevel = 0
136         for token in tokens:
137             if token[0] == OP:
138                 if token[1] == '(':
139                     stacks.append(ParenthesisGroup([]))
140                     stacklevel += 1
141                 elif token[1] == ')':
142                     stacks[-1].append(token)
143                     stack = stacks.pop()
144 
145                     if len(stacks) > 0:
146                         # We don't recurse here since the upper-level stack
147                         # would reprocess these tokens
148                         stacks[-1].extend(stack)
149                     else:
150                         # Recurse here to handle nested parentheses
151                         # Strip off the outer parentheses to avoid an infinite loop
152                         inner = stack[1:-1]
153                         inner = recursor(inner,
154                                          local_dict,
155                                          global_dict)
156                         parenGroup = [stack[0]] + inner + [stack[-1]]
157                         result.append(ParenthesisGroup(parenGroup))
158                     stacklevel -= 1
159                     continue
160             if stacklevel:
161                 stacks[-1].append(token)
162             else:
163                 result.append(token)
164         if stacklevel:
165             raise TokenError("Mismatched parentheses")
166         return result
167     return _inner
168 
169 
170 def _apply_functions(tokens, local_dict, global_dict):
171     """Convert a NAME token + ParenthesisGroup into an AppliedFunction.
172 
173     Note that ParenthesisGroups, if not applied to any function, are
174     converted back into lists of tokens.
175 
176     """
177     result = []
178     symbol = None
179     for tok in tokens:
180         if tok[0] == NAME:
181             symbol = tok
182             result.append(tok)
183         elif isinstance(tok, ParenthesisGroup):
184             if symbol and _token_callable(symbol, local_dict, global_dict):
185                 result[-1] = AppliedFunction(symbol, tok)
186                 symbol = None
187             else:
188                 result.extend(tok)
189         else:
190             symbol = None
191             result.append(tok)
192     return result
193 
194 
195 def _implicit_multiplication(tokens, local_dict, global_dict):
196     """Implicitly adds '*' tokens.
197 
198     Cases:
199 
200     - Two AppliedFunctions next to each other ("sin(x)cos(x)")
201 
202     - AppliedFunction next to an open parenthesis ("sin x (cos x + 1)")
203 
204     - A close parenthesis next to an AppliedFunction ("(x+2)sin x")\
205 
206     - A close parenthesis next to an open parenthesis ("(x+2)(x+3)")
207 
208     - AppliedFunction next to an implicitly applied function ("sin(x)cos x")
209 
210     """
211     result = []
212     for tok, nextTok in zip(tokens, tokens[1:]):
213         result.append(tok)
214         if (isinstance(tok, AppliedFunction) and
215               isinstance(nextTok, AppliedFunction)):
216             result.append((OP, '*'))
217         elif (isinstance(tok, AppliedFunction) and
218               nextTok[0] == OP and nextTok[1] == '('):
219             # Applied function followed by an open parenthesis
220             if tok.function[1] == "Function":
221                 result[-1].function = (result[-1].function[0], 'Symbol')
222             result.append((OP, '*'))
223         elif (tok[0] == OP and tok[1] == ')' and
224               isinstance(nextTok, AppliedFunction)):
225             # Close parenthesis followed by an applied function
226             result.append((OP, '*'))
227         elif (tok[0] == OP and tok[1] == ')' and
228               nextTok[0] == NAME):
229             # Close parenthesis followed by an implicitly applied function
230             result.append((OP, '*'))
231         elif (tok[0] == nextTok[0] == OP
232               and tok[1] == ')' and nextTok[1] == '('):
233             # Close parenthesis followed by an open parenthesis
234             result.append((OP, '*'))
235         elif (isinstance(tok, AppliedFunction) and nextTok[0] == NAME):
236             # Applied function followed by implicitly applied function
237             result.append((OP, '*'))
238         elif (tok[0] == NAME and
239               not _token_callable(tok, local_dict, global_dict) and
240               nextTok[0] == OP and nextTok[1] == '('):
241             # Constant followed by parenthesis
242             result.append((OP, '*'))
243         elif (tok[0] == NAME and
244               not _token_callable(tok, local_dict, global_dict) and
245               nextTok[0] == NAME and
246               not _token_callable(nextTok, local_dict, global_dict)):
247             # Constant followed by constant
248             result.append((OP, '*'))
249         elif (tok[0] == NAME and
250               not _token_callable(tok, local_dict, global_dict) and
251               (isinstance(nextTok, AppliedFunction) or nextTok[0] == NAME)):
252             # Constant followed by (implicitly applied) function
253             result.append((OP, '*'))
254     if tokens:
255         result.append(tokens[-1])
256     return result
257 
258 
259 def _implicit_application(tokens, local_dict, global_dict):
260     """Adds parentheses as needed after functions."""
261     result = []
262     appendParen = 0  # number of closing parentheses to add
263     skip = 0  # number of tokens to delay before adding a ')' (to
264               # capture **, ^, etc.)
265     exponentSkip = False  # skipping tokens before inserting parentheses to
266                           # work with function exponentiation
267     for tok, nextTok in zip(tokens, tokens[1:]):
268         result.append(tok)
269         if (tok[0] == NAME and nextTok[0] not in [OP, ENDMARKER, NEWLINE]):
270             if _token_callable(tok, local_dict, global_dict, nextTok):
271                 result.append((OP, '('))
272                 appendParen += 1
273         # name followed by exponent - function exponentiation
274         elif (tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**'):
275             if _token_callable(tok, local_dict, global_dict):
276                 exponentSkip = True
277         elif exponentSkip:
278             # if the last token added was an applied function (i.e. the
279             # power of the function exponent) OR a multiplication (as
280             # implicit multiplication would have added an extraneous
281             # multiplication)
282             if (isinstance(tok, AppliedFunction)
283                 or (tok[0] == OP and tok[1] == '*')):
284                 # don't add anything if the next token is a multiplication
285                 # or if there's already a parenthesis (if parenthesis, still
286                 # stop skipping tokens)
287                 if not (nextTok[0] == OP and nextTok[1] == '*'):
288                     if not(nextTok[0] == OP and nextTok[1] == '('):
289                         result.append((OP, '('))
290                         appendParen += 1
291                     exponentSkip = False
292         elif appendParen:
293             if nextTok[0] == OP and nextTok[1] in ('^', '**', '*'):
294                 skip = 1
295                 continue
296             if skip:
297                 skip -= 1
298                 continue
299             result.append((OP, ')'))
300             appendParen -= 1
301 
302     if tokens:
303         result.append(tokens[-1])
304 
305     if appendParen:
306         result.extend([(OP, ')')] * appendParen)
307     return result
308 
309 
310 def function_exponentiation(tokens, local_dict, global_dict):
311     """Allows functions to be exponentiated, e.g. ``cos**2(x)``.
312 
313     Examples
314     ========
315 
316     >>> from sympy.parsing.sympy_parser import (parse_expr,
317     ... standard_transformations, function_exponentiation)
318     >>> transformations = standard_transformations + (function_exponentiation,)
319     >>> parse_expr('sin**4(x)', transformations=transformations)
320     sin(x)**4
321     """
322     result = []
323     exponent = []
324     consuming_exponent = False
325     level = 0
326     for tok, nextTok in zip(tokens, tokens[1:]):
327         if tok[0] == NAME and nextTok[0] == OP and nextTok[1] == '**':
328             if _token_callable(tok, local_dict, global_dict):
329                 consuming_exponent = True
330         elif consuming_exponent:
331             if tok[0] == NAME and tok[1] == 'Function':
332                 tok = (NAME, 'Symbol')
333             exponent.append(tok)
334 
335             # only want to stop after hitting )
336             if tok[0] == nextTok[0] == OP and tok[1] == ')' and nextTok[1] == '(':
337                 consuming_exponent = False
338             # if implicit multiplication was used, we may have )*( instead
339             if tok[0] == nextTok[0] == OP and tok[1] == '*' and nextTok[1] == '(':
340                 consuming_exponent = False
341                 del exponent[-1]
342             continue
343         elif exponent and not consuming_exponent:
344             if tok[0] == OP:
345                 if tok[1] == '(':
346                     level += 1
347                 elif tok[1] == ')':
348                     level -= 1
349             if level == 0:
350                 result.append(tok)
351                 result.extend(exponent)
352                 exponent = []
353                 continue
354         result.append(tok)
355     if tokens:
356         result.append(tokens[-1])
357     if exponent:
358         result.extend(exponent)
359     return result
360 
361 
362 def split_symbols_custom(predicate):
363     """Creates a transformation that splits symbol names.
364 
365     ``predicate`` should return True if the symbol name is to be split.
366 
367     For instance, to retain the default behavior but avoid splitting certain
368     symbol names, a predicate like this would work:
369 
370 
371     >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,
372     ... standard_transformations, implicit_multiplication,
373     ... split_symbols_custom)
374     >>> def can_split(symbol):
375     ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):
376     ...             return _token_splittable(symbol)
377     ...     return False
378     ...
379     >>> transformation = split_symbols_custom(can_split)
380     >>> parse_expr('unsplittable', transformations=standard_transformations +
381     ... (transformation, implicit_multiplication))
382     unsplittable
383     """
384     def _split_symbols(tokens, local_dict, global_dict):
385         result = []
386         split = False
387         split_previous=False
388 
389         for tok in tokens:
390             if split_previous:
391                 # throw out closing parenthesis of Symbol that was split
392                 split_previous=False
393                 continue
394             split_previous=False
395 
396             if tok[0] == NAME and tok[1] in ['Symbol', 'Function']:
397                 split = True
398 
399             elif split and tok[0] == NAME:
400                 symbol = tok[1][1:-1]
401 
402                 if predicate(symbol):
403                     tok_type = result[-2][1]  # Symbol or Function
404                     del result[-2:]  # Get rid of the call to Symbol
405 
406                     i = 0
407                     while i < len(symbol):
408                         char = symbol[i]
409                         if char in local_dict or char in global_dict:
410                             result.extend([(NAME, "%s" % char)])
411                         elif char.isdigit():
412                             char = [char]
413                             for i in range(i + 1, len(symbol)):
414                                 if not symbol[i].isdigit():
415                                   i -= 1
416                                   break
417                                 char.append(symbol[i])
418                             char = ''.join(char)
419                             result.extend([(NAME, 'Number'), (OP, '('),
420                                            (NAME, "'%s'" % char), (OP, ')')])
421                         else:
422                             use = tok_type if i == len(symbol) else 'Symbol'
423                             result.extend([(NAME, use), (OP, '('),
424                                            (NAME, "'%s'" % char), (OP, ')')])
425                         i += 1
426 
427                     # Set split_previous=True so will skip
428                     # the closing parenthesis of the original Symbol
429                     split = False
430                     split_previous = True
431                     continue
432 
433                 else:
434                     split = False
435 
436             result.append(tok)
437 
438         return result
439 
440     return _split_symbols
441 
442 
443 #: Splits symbol names for implicit multiplication.
444 #:
445 #: Intended to let expressions like ``xyz`` be parsed as ``x*y*z``. Does not
446 #: split Greek character names, so ``theta`` will *not* become
447 #: ``t*h*e*t*a``. Generally this should be used with
448 #: ``implicit_multiplication``.
449 split_symbols = split_symbols_custom(_token_splittable)
450 
451 
452 def implicit_multiplication(result, local_dict, global_dict):
453     """Makes the multiplication operator optional in most cases.
454 
455     Use this before :func:`implicit_application`, otherwise expressions like
456     ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.
457 
458     Examples
459     ========
460 
461     >>> from sympy.parsing.sympy_parser import (parse_expr,
462     ... standard_transformations, implicit_multiplication)
463     >>> transformations = standard_transformations + (implicit_multiplication,)
464     >>> parse_expr('3 x y', transformations=transformations)
465     3*x*y
466     """
467     # These are interdependent steps, so we don't expose them separately
468     for step in (_group_parentheses(implicit_multiplication),
469                  _apply_functions,
470                  _implicit_multiplication):
471         result = step(result, local_dict, global_dict)
472 
473     result = _flatten(result)
474     return result
475 
476 
477 def implicit_application(result, local_dict, global_dict):
478     """Makes parentheses optional in some cases for function calls.
479 
480     Use this after :func:`implicit_multiplication`, otherwise expressions
481     like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than
482     ``sin(2*x)``.
483 
484     Examples
485     ========
486 
487     >>> from sympy.parsing.sympy_parser import (parse_expr,
488     ... standard_transformations, implicit_application)
489     >>> transformations = standard_transformations + (implicit_application,)
490     >>> parse_expr('cot z + csc z', transformations=transformations)
491     cot(z) + csc(z)
492     """
493     for step in (_group_parentheses(implicit_application),
494                  _apply_functions,
495                  _implicit_application,):
496         result = step(result, local_dict, global_dict)
497 
498     result = _flatten(result)
499     return result
500 
501 
502 def implicit_multiplication_application(result, local_dict, global_dict):
503     """Allows a slightly relaxed syntax.
504 
505     - Parentheses for single-argument method calls are optional.
506 
507     - Multiplication is implicit.
508 
509     - Symbol names can be split (i.e. spaces are not needed between
510       symbols).
511 
512     - Functions can be exponentiated.
513 
514     Examples
515     ========
516 
517     >>> from sympy.parsing.sympy_parser import (parse_expr,
518     ... standard_transformations, implicit_multiplication_application)
519     >>> parse_expr("10sin**2 x**2 + 3xyz + tan theta",
520     ... transformations=(standard_transformations +
521     ... (implicit_multiplication_application,)))
522     3*x*y*z + 10*sin(x**2)**2 + tan(theta)
523 
524     """
525     for step in (split_symbols, implicit_multiplication,
526                  implicit_application, function_exponentiation):
527         result = step(result, local_dict, global_dict)
528 
529     return result
530 
531 
532 def auto_symbol(tokens, local_dict, global_dict):
533     """Inserts calls to ``Symbol``/``Function`` for undefined variables."""
534     result = []
535     prevTok = (None, None)
536 
537     tokens.append((None, None))  # so zip traverses all tokens
538     for tok, nextTok in zip(tokens, tokens[1:]):
539         tokNum, tokVal = tok
540         nextTokNum, nextTokVal = nextTok
541         if tokNum == NAME:
542             name = tokVal
543 
544             if (name in ['True', 'False', 'None']
545                 or iskeyword(name)
546                 # Don't convert attribute access
547                 or (prevTok[0] == OP and prevTok[1] == '.')
548                 # Don't convert keyword arguments
549                 or (prevTok[0] == OP and prevTok[1] in ('(', ',')
550                     and nextTokNum == OP and nextTokVal == '=')):
551                 result.append((NAME, name))
552                 continue
553             elif name in local_dict:
554                 if isinstance(local_dict[name], Symbol) and nextTokVal == '(':
555                     result.extend([(NAME, 'Function'),
556                                    (OP, '('),
557                                    (NAME, repr(str(local_dict[name]))),
558                                    (OP, ')')])
559                 else:
560                     result.append((NAME, name))
561                 continue
562             elif name in global_dict:
563                 obj = global_dict[name]
564                 if isinstance(obj, (Basic, type)) or callable(obj):
565                     result.append((NAME, name))
566                     continue
567 
568             result.extend([
569                 (NAME, 'Symbol' if nextTokVal != '(' else 'Function'),
570                 (OP, '('),
571                 (NAME, repr(str(name))),
572                 (OP, ')'),
573             ])
574         else:
575             result.append((tokNum, tokVal))
576 
577         prevTok = (tokNum, tokVal)
578 
579     return result
580 
581 
582 def lambda_notation(tokens, local_dict, global_dict):
583     """Substitutes "lambda" with its Sympy equivalent Lambda().
584     However, the conversion doesn't take place if only "lambda"
585     is passed because that is a syntax error.
586 
587     """
588     result = []
589     flag = False
590     toknum, tokval = tokens[0]
591     tokLen = len(tokens)
592 
593     if toknum == NAME and tokval == 'lambda':
594         if tokLen == 2 or tokLen == 3 and tokens[1][0] == NEWLINE:
595             # In Python 3.6.7+, inputs without a newline get NEWLINE added to
596             # the tokens
597             result.extend(tokens)
598         elif tokLen > 2:
599             result.extend([
600                 (NAME, 'Lambda'),
601                 (OP, '('),
602                 (OP, '('),
603                 (OP, ')'),
604                 (OP, ')'),
605             ])
606             for tokNum, tokVal in tokens[1:]:
607                 if tokNum == OP and tokVal == ':':
608                     tokVal = ','
609                     flag = True
610                 if not flag and tokNum == OP and tokVal in ['*', '**']:
611                     raise TokenError("Starred arguments in lambda not supported")
612                 if flag:
613                     result.insert(-1, (tokNum, tokVal))
614                 else:
615                     result.insert(-2, (tokNum, tokVal))
616     else:
617         result.extend(tokens)
618 
619     return result
620 
621 
622 def factorial_notation(tokens, local_dict, global_dict):
623     """Allows standard notation for factorial."""
624     result = []
625     nfactorial = 0
626     for toknum, tokval in tokens:
627         if toknum == ERRORTOKEN:
628             op = tokval
629             if op == '!':
630                 nfactorial += 1
631             else:
632                 nfactorial = 0
633                 result.append((OP, op))
634         else:
635             if nfactorial == 1:
636                 result = _add_factorial_tokens('factorial', result)
637             elif nfactorial == 2:
638                 result = _add_factorial_tokens('factorial2', result)
639             elif nfactorial > 2:
640                 raise TokenError
641             nfactorial = 0
642             result.append((toknum, tokval))
643     return result
644 
645 
646 def convert_xor(tokens, local_dict, global_dict):
647     """Treats XOR, ``^``, as exponentiation, ``**``."""
648     result = []
649     for toknum, tokval in tokens:
650         if toknum == OP:
651             if tokval == '^':
652                 result.append((OP, '**'))
653             else:
654                 result.append((toknum, tokval))
655         else:
656             result.append((toknum, tokval))
657 
658     return result
659 
660 
661 def repeated_decimals(tokens, local_dict, global_dict):
662     """
663     Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)
664 
665     Run this before auto_number.
666 
667     """
668     result = []
669 
670     def is_digit(s):
671         return all(i in '0123456789_' for i in s)
672 
673     # num will running match any DECIMAL [ INTEGER ]
674     num = []
675     for toknum, tokval in tokens:
676         if toknum == NUMBER:
677             if (not num and '.' in tokval and 'e' not in tokval.lower() and
678                 'j' not in tokval.lower()):
679                 num.append((toknum, tokval))
680             elif is_digit(tokval)and  len(num) == 2:
681                 num.append((toknum, tokval))
682             elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):
683                 # Python 2 tokenizes 00123 as '00', '123'
684                 # Python 3 tokenizes 01289 as '012', '89'
685                 num.append((toknum, tokval))
686             else:
687                 num = []
688         elif toknum == OP:
689             if tokval == '[' and len(num) == 1:
690                 num.append((OP, tokval))
691             elif tokval == ']' and len(num) >= 3:
692                 num.append((OP, tokval))
693             elif tokval == '.' and not num:
694                 # handle .[1]
695                 num.append((NUMBER, '0.'))
696             else:
697                 num = []
698         else:
699             num = []
700 
701         result.append((toknum, tokval))
702 
703         if num and num[-1][1] == ']':
704             # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,
705             # and d/e = repetend
706             result = result[:-len(num)]
707             pre, post = num[0][1].split('.')
708             repetend = num[2][1]
709             if len(num) == 5:
710                 repetend += num[3][1]
711 
712             pre = pre.replace('_', '')
713             post = post.replace('_', '')
714             repetend = repetend.replace('_', '')
715 
716             zeros = '0'*len(post)
717             post, repetends = [w.lstrip('0') for w in [post, repetend]]
718                                         # or else interpreted as octal
719 
720             a = pre or '0'
721             b, c = post or '0', '1' + zeros
722             d, e = repetends, ('9'*len(repetend)) + zeros
723 
724             seq = [
725                 (OP, '('),
726                     (NAME, 'Integer'),
727                     (OP, '('),
728                         (NUMBER, a),
729                     (OP, ')'),
730                     (OP, '+'),
731                     (NAME, 'Rational'),
732                     (OP, '('),
733                         (NUMBER, b),
734                         (OP, ','),
735                         (NUMBER, c),
736                     (OP, ')'),
737                     (OP, '+'),
738                     (NAME, 'Rational'),
739                     (OP, '('),
740                         (NUMBER, d),
741                         (OP, ','),
742                         (NUMBER, e),
743                     (OP, ')'),
744                 (OP, ')'),
745             ]
746             result.extend(seq)
747             num = []
748 
749     return result
750 
751 
752 def auto_number(tokens, local_dict, global_dict):
753     """
754     Converts numeric literals to use SymPy equivalents.
755 
756     Complex numbers use ``I``, integer literals use ``Integer``, and float
757     literals use ``Float``.
758 
759     """
760     result = []
761 
762     for toknum, tokval in tokens:
763         if toknum == NUMBER:
764             number = tokval
765             postfix = []
766 
767             if number.endswith('j') or number.endswith('J'):
768                 number = number[:-1]
769                 postfix = [(OP, '*'), (NAME, 'I')]
770 
771             if '.' in number or (('e' in number or 'E' in number) and
772                     not (number.startswith('0x') or number.startswith('0X'))):
773                 seq = [(NAME, 'Float'), (OP, '('),
774                     (NUMBER, repr(str(number))), (OP, ')')]
775             else:
776                 seq = [(NAME, 'Integer'), (OP, '('), (
777                     NUMBER, number), (OP, ')')]
778 
779             result.extend(seq + postfix)
780         else:
781             result.append((toknum, tokval))
782 
783     return result
784 
785 
786 def rationalize(tokens, local_dict, global_dict):
787     """Converts floats into ``Rational``. Run AFTER ``auto_number``."""
788     result = []
789     passed_float = False
790     for toknum, tokval in tokens:
791         if toknum == NAME:
792             if tokval == 'Float':
793                 passed_float = True
794                 tokval = 'Rational'
795             result.append((toknum, tokval))
796         elif passed_float == True and toknum == NUMBER:
797             passed_float = False
798             result.append((STRING, tokval))
799         else:
800             result.append((toknum, tokval))
801 
802     return result
803 
804 
805 def _transform_equals_sign(tokens, local_dict, global_dict):
806     """Transforms the equals sign ``=`` to instances of Eq.
807 
808     This is a helper function for `convert_equals_signs`.
809     Works with expressions containing one equals sign and no
810     nesting. Expressions like `(1=2)=False` won't work with this
811     and should be used with `convert_equals_signs`.
812 
813     Examples: 1=2     to Eq(1,2)
814               1*2=x   to Eq(1*2, x)
815 
816     This does not deal with function arguments yet.
817 
818     """
819     result = []
820     if (OP, "=") in tokens:
821         result.append((NAME, "Eq"))
822         result.append((OP, "("))
823         for index, token in enumerate(tokens):
824             if token == (OP, "="):
825                 result.append((OP, ","))
826                 continue
827             result.append(token)
828         result.append((OP, ")"))
829     else:
830         result = tokens
831     return result
832 
833 
834 def convert_equals_signs(result, local_dict, global_dict):
835     """ Transforms all the equals signs ``=`` to instances of Eq.
836 
837     Parses the equals signs in the expression and replaces them with
838     appropriate Eq instances.Also works with nested equals signs.
839 
840     Does not yet play well with function arguments.
841     For example, the expression `(x=y)` is ambiguous and can be interpreted
842     as x being an argument to a function and `convert_equals_signs` won't
843     work for this.
844 
845     See also
846     ========
847     convert_equality_operators
848 
849     Examples
850     ========
851 
852     >>> from sympy.parsing.sympy_parser import (parse_expr,
853     ... standard_transformations, convert_equals_signs)
854     >>> parse_expr("1*2=x", transformations=(
855     ... standard_transformations + (convert_equals_signs,)))
856     Eq(2, x)
857     >>> parse_expr("(1*2=x)=False", transformations=(
858     ... standard_transformations + (convert_equals_signs,)))
859     Eq(Eq(2, x), False)
860 
861     """
862     for step in (_group_parentheses(convert_equals_signs),
863                   _apply_functions,
864                   _transform_equals_sign):
865         result = step(result, local_dict, global_dict)
866 
867     result = _flatten(result)
868     return result
869 
870 
871 #: Standard transformations for :func:`parse_expr`.
872 #: Inserts calls to :class:`~.Symbol`, :class:`~.Integer`, and other SymPy
873 #: datatypes and allows the use of standard factorial notation (e.g. ``x!``).
874 standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,
875     factorial_notation)
876 
877 
878 def stringify_expr(s, local_dict, global_dict, transformations):
879     """
880     Converts the string ``s`` to Python code, in ``local_dict``
881 
882     Generally, ``parse_expr`` should be used.
883     """
884 
885     tokens = []
886     input_code = StringIO(s.strip())
887     for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):
888         tokens.append((toknum, tokval))
889 
890     for transform in transformations:
891         tokens = transform(tokens, local_dict, global_dict)
892 
893     return untokenize(tokens)
894 
895 
896 def eval_expr(code, local_dict, global_dict):
897     """
898     Evaluate Python code generated by ``stringify_expr``.
899 
900     Generally, ``parse_expr`` should be used.
901     """
902     expr = eval(
903         code, global_dict, local_dict)  # take local objects in preference
904 
905     return expr
906 
907 
908 def parse_expr(s, local_dict=None, transformations=standard_transformations,
909                global_dict=None, evaluate=True):
910     """Converts the string ``s`` to a SymPy expression, in ``local_dict``
911 
912     Parameters
913     ==========
914 
915     s : str
916         The string to parse.
917 
918     local_dict : dict, optional
919         A dictionary of local variables to use when parsing.
920 
921     global_dict : dict, optional
922         A dictionary of global variables. By default, this is initialized
923         with ``from sympy import *``; provide this parameter to override
924         this behavior (for instance, to parse ``"Q & S"``).
925 
926     transformations : tuple, optional
927         A tuple of transformation functions used to modify the tokens of the
928         parsed expression before evaluation. The default transformations
929         convert numeric literals into their SymPy equivalents, convert
930         undefined variables into SymPy symbols, and allow the use of standard
931         mathematical factorial notation (e.g. ``x!``).
932 
933     evaluate : bool, optional
934         When False, the order of the arguments will remain as they were in the
935         string and automatic simplification that would normally occur is
936         suppressed. (see examples)
937 
938     Examples
939     ========
940 
941     >>> from sympy.parsing.sympy_parser import parse_expr
942     >>> parse_expr("1/2")
943     1/2
944     >>> type(_)
945     <class 'sympy.core.numbers.Half'>
946     >>> from sympy.parsing.sympy_parser import standard_transformations,\\
947     ... implicit_multiplication_application
948     >>> transformations = (standard_transformations +
949     ...     (implicit_multiplication_application,))
950     >>> parse_expr("2x", transformations=transformations)
951     2*x
952 
953     When evaluate=False, some automatic simplifications will not occur:
954 
955     >>> parse_expr("2**3"), parse_expr("2**3", evaluate=False)
956     (8, 2**3)
957 
958     In addition the order of the arguments will not be made canonical.
959     This feature allows one to tell exactly how the expression was entered:
960 
961     >>> a = parse_expr('1 + x', evaluate=False)
962     >>> b = parse_expr('x + 1', evaluate=0)
963     >>> a == b
964     False
965     >>> a.args
966     (1, x)
967     >>> b.args
968     (x, 1)
969 
970     See Also
971     ========
972 
973     stringify_expr, eval_expr, standard_transformations,
974     implicit_multiplication_application
975 
976     """
977 
978     if local_dict is None:
979         local_dict = {}
980     elif not isinstance(local_dict, dict):
981         raise TypeError('expecting local_dict to be a dict')
982 
983     if global_dict is None:
984         global_dict = {}
985         exec_('from sympy import *', global_dict)
986     elif not isinstance(global_dict, dict):
987         raise TypeError('expecting global_dict to be a dict')
988 
989     transformations = transformations or ()
990     if transformations:
991         if not iterable(transformations):
992             raise TypeError(
993                 '`transformations` should be a list of functions.')
994         for _ in transformations:
995             if not callable(_):
996                 raise TypeError(filldedent('''
997                     expected a function in `transformations`,
998                     not %s''' % func_name(_)))
999             if arity(_) != 3:
1000                 raise TypeError(filldedent('''
1001                     a transformation should be function that
1002                     takes 3 arguments'''))
1003     code = stringify_expr(s, local_dict, global_dict, transformations)
1004 
1005     if not evaluate:
1006         code = compile(evaluateFalse(code), '<string>', 'eval')
1007 
1008     return eval_expr(code, local_dict, global_dict)
1009 
1010 
1011 def evaluateFalse(s):
1012     """
1013     Replaces operators with the SymPy equivalent and sets evaluate=False.
1014     """
1015     node = ast.parse(s)
1016     node = EvaluateFalseTransformer().visit(node)
1017     # node is a Module, we want an Expression
1018     node = ast.Expression(node.body[0].value)
1019 
1020     return ast.fix_missing_locations(node)
1021 
1022 
1023 class EvaluateFalseTransformer(ast.NodeTransformer):
1024     operators = {
1025         ast.Add: 'Add',
1026         ast.Mult: 'Mul',
1027         ast.Pow: 'Pow',
1028         ast.Sub: 'Add',
1029         ast.Div: 'Mul',
1030         ast.BitOr: 'Or',
1031         ast.BitAnd: 'And',
1032         ast.BitXor: 'Not',
1033     }
1034 
1035     def flatten(self, args, func):
1036         result = []
1037         for arg in args:
1038             if isinstance(arg, ast.Call):
1039                 arg_func = arg.func
1040                 if isinstance(arg_func, ast.Call):
1041                     arg_func = arg_func.func
1042                 if arg_func.id == func:
1043                     result.extend(self.flatten(arg.args, func))
1044                 else:
1045                     result.append(arg)
1046             else:
1047                 result.append(arg)
1048         return result
1049 
1050     def visit_BinOp(self, node):
1051         if node.op.__class__ in self.operators:
1052             sympy_class = self.operators[node.op.__class__]
1053             right = self.visit(node.right)
1054             left = self.visit(node.left)
1055             if isinstance(node.left, ast.UnaryOp) and (isinstance(node.right, ast.UnaryOp) == 0) and sympy_class in ('Mul',):
1056                 left, right = right, left
1057             if isinstance(node.op, ast.Sub):
1058                 right = ast.Call(
1059                     func=ast.Name(id='Mul', ctx=ast.Load()),
1060                     args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(1)), right],
1061                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1062                     starargs=None,
1063                     kwargs=None
1064                 )
1065             if isinstance(node.op, ast.Div):
1066                 if isinstance(node.left, ast.UnaryOp):
1067                     if isinstance(node.right,ast.UnaryOp):
1068                         left, right = right, left
1069                     left = ast.Call(
1070                     func=ast.Name(id='Pow', ctx=ast.Load()),
1071                     args=[left, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1072                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1073                     starargs=None,
1074                     kwargs=None
1075                 )
1076                 else:
1077                     right = ast.Call(
1078                     func=ast.Name(id='Pow', ctx=ast.Load()),
1079                     args=[right, ast.UnaryOp(op=ast.USub(), operand=ast.Num(1))],
1080                     keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1081                     starargs=None,
1082                     kwargs=None
1083                 )
1084 
1085             new_node = ast.Call(
1086                 func=ast.Name(id=sympy_class, ctx=ast.Load()),
1087                 args=[left, right],
1088                 keywords=[ast.keyword(arg='evaluate', value=ast.Name(id='False', ctx=ast.Load()))],
1089                 starargs=None,
1090                 kwargs=None
1091             )
1092 
1093             if sympy_class in ('Add', 'Mul'):
1094                 # Denest Add or Mul as appropriate
1095                 new_node.args = self.flatten(new_node.args, sympy_class)
1096 
1097             return new_node
1098         return node

</code><intended_behavior>Within `eval_expr`, introduce additional safeguards against executing unverified code. This may include verifying the contents of the `code` parameter against a set of allowed operations and structures before allowing `eval` to execute. Additionally, implementing a more restricted execution context for `eval` can limit potential damage from malicious or unintended code execution. This context could limit the available namespaces and restrict execution capabilities to purely mathematical evaluations, thus reducing risk.</intended_behavior>]
2025-10-18 08:53:19.410 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 08:53:19.410 | INFO     | Search-only: skipping patch selection
2025-10-18 08:53:19.602 | INFO     | Task sympy__sympy-18057 completed successfully.
2025-10-18 08:53:19.603 | INFO     | No patch generated. You can try running ACR again.
