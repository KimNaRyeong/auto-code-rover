2025-10-17 23:31:27.915 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 23:31:32.491 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=146, output_tokens=12, cost=0.001820
2025-10-17 23:31:32.492 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 23:31:32.495 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:31:40.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=455, output_tokens=244, cost=0.011870
2025-10-17 23:31:40.205 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:31:43.650 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=598, output_tokens=53, cost=0.007570
2025-10-17 23:31:43.652 | DEBUG    | Extracted a valid json.
2025-10-17 23:31:43.652 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"FormSet\")",
        "search_method_in_class(\"default_error_messages\", \"FormSet\")",
        "search_code(\"FormSet(error_messages=\")"
    ],
    "bug_locations": []
}
2025-10-17 23:31:43.688 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 23:31:43.688 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 23:31:52.931 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=882, output_tokens=463, cost=0.022710
2025-10-17 23:31:52.942 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 23:32:03.827 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1561, output_tokens=543, cost=0.031900
2025-10-17 23:32:03.837 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 23:32:08.380 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=897, output_tokens=174, cost=0.014190
2025-10-17 23:32:08.381 | DEBUG    | Extracted a valid json.
2025-10-17 23:32:08.381 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/forms/formsets.py",
            "class": "FormSet",
            "method": "",
            "intended_behavior": "Ensure the FormSet class contains a default_error_messages attribute that aggregates error messages, including those for too few and too many forms. Modify the __init__ method or relevant method handling instantiation to allow passing of error_messages as an argument which would override the default ones."
        },
        {
            "file": "django/forms/models.py",
            "class": "",
            "method": "inlineformset_factory",
            "intended_behavior": "Ensure inlineformset_factory or related factory functions can pass error_messages down to FormSet instances they create, accepting error_messages and correctly forwarding them to the FormSet constructor."
        }
    ]
}
2025-10-17 23:32:08.384 | DEBUG    | Bug location extracted successfully: [<file>django/forms/formsets.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.core.exceptions import ValidationError
2 from django.forms import Form
3 from django.forms.fields import BooleanField, IntegerField
4 from django.forms.renderers import get_default_renderer
5 from django.forms.utils import ErrorList, RenderableFormMixin
6 from django.forms.widgets import CheckboxInput, HiddenInput, NumberInput
7 from django.utils.functional import cached_property
8 from django.utils.translation import gettext_lazy as _
9 from django.utils.translation import ngettext
10 
11 __all__ = ("BaseFormSet", "formset_factory", "all_valid")
12 
13 # special field names
14 TOTAL_FORM_COUNT = "TOTAL_FORMS"
15 INITIAL_FORM_COUNT = "INITIAL_FORMS"
16 MIN_NUM_FORM_COUNT = "MIN_NUM_FORMS"
17 MAX_NUM_FORM_COUNT = "MAX_NUM_FORMS"
18 ORDERING_FIELD_NAME = "ORDER"
19 DELETION_FIELD_NAME = "DELETE"
20 
21 # default minimum number of forms in a formset
22 DEFAULT_MIN_NUM = 0
23 
24 # default maximum number of forms in a formset, to prevent memory exhaustion
25 DEFAULT_MAX_NUM = 1000
26 
27 
28 class ManagementForm(Form):
29     """
30     Keep track of how many form instances are displayed on the page. If adding
31     new forms via JavaScript, you should increment the count field of this form
32     as well.
33     """
34 
35     TOTAL_FORMS = IntegerField(widget=HiddenInput)
36     INITIAL_FORMS = IntegerField(widget=HiddenInput)
37     # MIN_NUM_FORM_COUNT and MAX_NUM_FORM_COUNT are output with the rest of the
38     # management form, but only for the convenience of client-side code. The
39     # POST value of them returned from the client is not checked.
40     MIN_NUM_FORMS = IntegerField(required=False, widget=HiddenInput)
41     MAX_NUM_FORMS = IntegerField(required=False, widget=HiddenInput)
42 
43     def clean(self):
44         cleaned_data = super().clean()
45         # When the management form is invalid, we don't know how many forms
46         # were submitted.
47         cleaned_data.setdefault(TOTAL_FORM_COUNT, 0)
48         cleaned_data.setdefault(INITIAL_FORM_COUNT, 0)
49         return cleaned_data
50 
51 
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}
527 
528 
529 def formset_factory(
530     form,
531     formset=BaseFormSet,
532     extra=1,
533     can_order=False,
534     can_delete=False,
535     max_num=None,
536     validate_max=False,
537     min_num=None,
538     validate_min=False,
539     absolute_max=None,
540     can_delete_extra=True,
541     renderer=None,
542 ):
543     """Return a FormSet for the given form class."""
544     if min_num is None:
545         min_num = DEFAULT_MIN_NUM
546     if max_num is None:
547         max_num = DEFAULT_MAX_NUM
548     # absolute_max is a hard limit on forms instantiated, to prevent
549     # memory-exhaustion attacks. Default to max_num + DEFAULT_MAX_NUM
550     # (which is 2 * DEFAULT_MAX_NUM if max_num is None in the first place).
551     if absolute_max is None:
552         absolute_max = max_num + DEFAULT_MAX_NUM
553     if max_num > absolute_max:
554         raise ValueError("'absolute_max' must be greater or equal to 'max_num'.")
555     attrs = {
556         "form": form,
557         "extra": extra,
558         "can_order": can_order,
559         "can_delete": can_delete,
560         "can_delete_extra": can_delete_extra,
561         "min_num": min_num,
562         "max_num": max_num,
563         "absolute_max": absolute_max,
564         "validate_min": validate_min,
565         "validate_max": validate_max,
566         "renderer": renderer or get_default_renderer(),
567     }
568     return type(form.__name__ + "FormSet", (formset,), attrs)
569 
570 
571 def all_valid(formsets):
572     """Validate every formset and return True if all are valid."""
573     # List comprehension ensures is_valid() is called for all formsets.
574     return all([formset.is_valid() for formset in formsets])

</code><intended_behavior>Ensure the FormSet class contains a default_error_messages attribute that aggregates error messages, including those for too few and too many forms. Modify the __init__ method or relevant method handling instantiation to allow passing of error_messages as an argument which would override the default ones.</intended_behavior>, <file>django/forms/models.py</file>
<class>None</class>
<method>inlineformset_factory</method>
<code>
1266 def inlineformset_factory(
1267     parent_model,
1268     model,
1269     form=ModelForm,
1270     formset=BaseInlineFormSet,
1271     fk_name=None,
1272     fields=None,
1273     exclude=None,
1274     extra=3,
1275     can_order=False,
1276     can_delete=True,
1277     max_num=None,
1278     formfield_callback=None,
1279     widgets=None,
1280     validate_max=False,
1281     localized_fields=None,
1282     labels=None,
1283     help_texts=None,
1284     error_messages=None,
1285     min_num=None,
1286     validate_min=False,
1287     field_classes=None,
1288     absolute_max=None,
1289     can_delete_extra=True,
1290     renderer=None,
1291     edit_only=False,
1292 ):
1293     """
1294     Return an ``InlineFormSet`` for the given kwargs.
1295 
1296     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
1297     to ``parent_model``.
1298     """
1299     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
1300     # enforce a max_num=1 when the foreign key to the parent model is unique.
1301     if fk.unique:
1302         max_num = 1
1303     kwargs = {
1304         "form": form,
1305         "formfield_callback": formfield_callback,
1306         "formset": formset,
1307         "extra": extra,
1308         "can_delete": can_delete,
1309         "can_order": can_order,
1310         "fields": fields,
1311         "exclude": exclude,
1312         "min_num": min_num,
1313         "max_num": max_num,
1314         "widgets": widgets,
1315         "validate_min": validate_min,
1316         "validate_max": validate_max,
1317         "localized_fields": localized_fields,
1318         "labels": labels,
1319         "help_texts": help_texts,
1320         "error_messages": error_messages,
1321         "field_classes": field_classes,
1322         "absolute_max": absolute_max,
1323         "can_delete_extra": can_delete_extra,
1324         "renderer": renderer,
1325         "edit_only": edit_only,
1326     }
1327     FormSet = modelformset_factory(model, **kwargs)
1328     FormSet.fk = fk
1329     return FormSet

</code><intended_behavior>Ensure inlineformset_factory or related factory functions can pass error_messages down to FormSet instances they create, accepting error_messages and correctly forwarding them to the FormSet constructor.</intended_behavior>]
2025-10-17 23:32:08.384 | INFO     | Search completed. Bug locations: [<file>django/forms/formsets.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.core.exceptions import ValidationError
2 from django.forms import Form
3 from django.forms.fields import BooleanField, IntegerField
4 from django.forms.renderers import get_default_renderer
5 from django.forms.utils import ErrorList, RenderableFormMixin
6 from django.forms.widgets import CheckboxInput, HiddenInput, NumberInput
7 from django.utils.functional import cached_property
8 from django.utils.translation import gettext_lazy as _
9 from django.utils.translation import ngettext
10 
11 __all__ = ("BaseFormSet", "formset_factory", "all_valid")
12 
13 # special field names
14 TOTAL_FORM_COUNT = "TOTAL_FORMS"
15 INITIAL_FORM_COUNT = "INITIAL_FORMS"
16 MIN_NUM_FORM_COUNT = "MIN_NUM_FORMS"
17 MAX_NUM_FORM_COUNT = "MAX_NUM_FORMS"
18 ORDERING_FIELD_NAME = "ORDER"
19 DELETION_FIELD_NAME = "DELETE"
20 
21 # default minimum number of forms in a formset
22 DEFAULT_MIN_NUM = 0
23 
24 # default maximum number of forms in a formset, to prevent memory exhaustion
25 DEFAULT_MAX_NUM = 1000
26 
27 
28 class ManagementForm(Form):
29     """
30     Keep track of how many form instances are displayed on the page. If adding
31     new forms via JavaScript, you should increment the count field of this form
32     as well.
33     """
34 
35     TOTAL_FORMS = IntegerField(widget=HiddenInput)
36     INITIAL_FORMS = IntegerField(widget=HiddenInput)
37     # MIN_NUM_FORM_COUNT and MAX_NUM_FORM_COUNT are output with the rest of the
38     # management form, but only for the convenience of client-side code. The
39     # POST value of them returned from the client is not checked.
40     MIN_NUM_FORMS = IntegerField(required=False, widget=HiddenInput)
41     MAX_NUM_FORMS = IntegerField(required=False, widget=HiddenInput)
42 
43     def clean(self):
44         cleaned_data = super().clean()
45         # When the management form is invalid, we don't know how many forms
46         # were submitted.
47         cleaned_data.setdefault(TOTAL_FORM_COUNT, 0)
48         cleaned_data.setdefault(INITIAL_FORM_COUNT, 0)
49         return cleaned_data
50 
51 
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}
527 
528 
529 def formset_factory(
530     form,
531     formset=BaseFormSet,
532     extra=1,
533     can_order=False,
534     can_delete=False,
535     max_num=None,
536     validate_max=False,
537     min_num=None,
538     validate_min=False,
539     absolute_max=None,
540     can_delete_extra=True,
541     renderer=None,
542 ):
543     """Return a FormSet for the given form class."""
544     if min_num is None:
545         min_num = DEFAULT_MIN_NUM
546     if max_num is None:
547         max_num = DEFAULT_MAX_NUM
548     # absolute_max is a hard limit on forms instantiated, to prevent
549     # memory-exhaustion attacks. Default to max_num + DEFAULT_MAX_NUM
550     # (which is 2 * DEFAULT_MAX_NUM if max_num is None in the first place).
551     if absolute_max is None:
552         absolute_max = max_num + DEFAULT_MAX_NUM
553     if max_num > absolute_max:
554         raise ValueError("'absolute_max' must be greater or equal to 'max_num'.")
555     attrs = {
556         "form": form,
557         "extra": extra,
558         "can_order": can_order,
559         "can_delete": can_delete,
560         "can_delete_extra": can_delete_extra,
561         "min_num": min_num,
562         "max_num": max_num,
563         "absolute_max": absolute_max,
564         "validate_min": validate_min,
565         "validate_max": validate_max,
566         "renderer": renderer or get_default_renderer(),
567     }
568     return type(form.__name__ + "FormSet", (formset,), attrs)
569 
570 
571 def all_valid(formsets):
572     """Validate every formset and return True if all are valid."""
573     # List comprehension ensures is_valid() is called for all formsets.
574     return all([formset.is_valid() for formset in formsets])

</code><intended_behavior>Ensure the FormSet class contains a default_error_messages attribute that aggregates error messages, including those for too few and too many forms. Modify the __init__ method or relevant method handling instantiation to allow passing of error_messages as an argument which would override the default ones.</intended_behavior>, <file>django/forms/models.py</file>
<class>None</class>
<method>inlineformset_factory</method>
<code>
1266 def inlineformset_factory(
1267     parent_model,
1268     model,
1269     form=ModelForm,
1270     formset=BaseInlineFormSet,
1271     fk_name=None,
1272     fields=None,
1273     exclude=None,
1274     extra=3,
1275     can_order=False,
1276     can_delete=True,
1277     max_num=None,
1278     formfield_callback=None,
1279     widgets=None,
1280     validate_max=False,
1281     localized_fields=None,
1282     labels=None,
1283     help_texts=None,
1284     error_messages=None,
1285     min_num=None,
1286     validate_min=False,
1287     field_classes=None,
1288     absolute_max=None,
1289     can_delete_extra=True,
1290     renderer=None,
1291     edit_only=False,
1292 ):
1293     """
1294     Return an ``InlineFormSet`` for the given kwargs.
1295 
1296     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
1297     to ``parent_model``.
1298     """
1299     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
1300     # enforce a max_num=1 when the foreign key to the parent model is unique.
1301     if fk.unique:
1302         max_num = 1
1303     kwargs = {
1304         "form": form,
1305         "formfield_callback": formfield_callback,
1306         "formset": formset,
1307         "extra": extra,
1308         "can_delete": can_delete,
1309         "can_order": can_order,
1310         "fields": fields,
1311         "exclude": exclude,
1312         "min_num": min_num,
1313         "max_num": max_num,
1314         "widgets": widgets,
1315         "validate_min": validate_min,
1316         "validate_max": validate_max,
1317         "localized_fields": localized_fields,
1318         "labels": labels,
1319         "help_texts": help_texts,
1320         "error_messages": error_messages,
1321         "field_classes": field_classes,
1322         "absolute_max": absolute_max,
1323         "can_delete_extra": can_delete_extra,
1324         "renderer": renderer,
1325         "edit_only": edit_only,
1326     }
1327     FormSet = modelformset_factory(model, **kwargs)
1328     FormSet.fk = fk
1329     return FormSet

</code><intended_behavior>Ensure inlineformset_factory or related factory functions can pass error_messages down to FormSet instances they create, accepting error_messages and correctly forwarding them to the FormSet constructor.</intended_behavior>]
2025-10-17 23:32:08.385 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 23:32:08.385 | INFO     | Search-only: skipping patch selection
2025-10-17 23:32:08.535 | INFO     | Task django__django-15671 completed successfully.
2025-10-17 23:32:08.535 | INFO     | No patch generated. You can try running ACR again.
