[
    {
        "rel_file_path": "astropy/coordinates/angles.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/coordinates/angles.py",
        "start": 576,
        "end": 601,
        "class_name": "Latitude",
        "method_name": "_validate_angles",
        "code": "576     def _validate_angles(self, angles=None):\n577         \"\"\"Check that angles are between -90 and 90 degrees.\n578         If not given, the check is done on the object itself\"\"\"\n579         # Convert the lower and upper bounds to the \"native\" unit of\n580         # this angle.  This limits multiplication to two values,\n581         # rather than the N values in `self.value`.  Also, the\n582         # comparison is performed on raw arrays, rather than Quantity\n583         # objects, for speed.\n584         if angles is None:\n585             angles = self\n586 \n587         if angles.unit is u.deg:\n588             limit = 90\n589         elif angles.unit is u.rad:\n590             limit = 0.5 * np.pi\n591         else:\n592             limit = u.degree.to(angles.unit, 90.0)\n593 \n594         # This invalid catch block can be removed when the minimum numpy\n595         # version is >= 1.19 (NUMPY_LT_1_19)\n596         with np.errstate(invalid='ignore'):\n597             invalid_angles = (np.any(angles.value < -limit) or\n598                               np.any(angles.value > limit))\n599         if invalid_angles:\n600             raise ValueError('Latitude angle(s) must be within -90 deg <= angle <= 90 deg, '\n601                              'got {}'.format(angles.to(u.degree)))\n",
        "intended_behavior": "The `_validate_angles` method should ensure angle validation accounts for floating-point precision differences. Specifically, it can incorporate a tolerance threshold when comparing angle values against the -90 and +90 degree bounds. This tolerance should be small enough to not meaningfully affect astronomical calculations but large enough to accommodate the slight inaccuracies introduced by floating-point arithmetic, especially in `float32` representations.\n\nThe modification should ensure that:\n- The comparison `np.any(angles.value < -limit)` and `np.any(angles.value > limit)` incorporates a comparison with a tolerance. For instance, using `numpy.isclose` with a suitable tolerance parameter for checking equality within bounds, or adjusting the `limit` to consider the floating-point representation error margin.\n- This adjustment preserves the method's original functionality for all valid inputs while allowing for the minor inaccuracies inherent in floating-point arithmetic. This means the method will continue to correctly invalidate genuinely out-of-bound values while accepting values that are nominally outside the bounds due to the precision limitations of their data types.\n\nImplementing these changes requires a careful consideration of the precision to ensure the balance between validation strictness and tolerance for floating-point inaccuracy, keeping in mind the diverse use cases of the `astropy` library in the astronomical community."
    },
    {
        "rel_file_path": "astropy/coordinates/angles.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/coordinates/angles.py",
        "start": 522,
        "end": 615,
        "class_name": "Latitude",
        "method_name": null,
        "code": "522 class Latitude(Angle):\n523     \"\"\"\n524     Latitude-like angle(s) which must be in the range -90 to +90 deg.\n525 \n526     A Latitude object is distinguished from a pure\n527     :class:`~astropy.coordinates.Angle` by virtue of being constrained\n528     so that::\n529 \n530       -90.0 * u.deg <= angle(s) <= +90.0 * u.deg\n531 \n532     Any attempt to set a value outside that range will result in a\n533     `ValueError`.\n534 \n535     The input angle(s) can be specified either as an array, list,\n536     scalar, tuple (see below), string,\n537     :class:`~astropy.units.Quantity` or another\n538     :class:`~astropy.coordinates.Angle`.\n539 \n540     The input parser is flexible and supports all of the input formats\n541     supported by :class:`~astropy.coordinates.Angle`.\n542 \n543     Parameters\n544     ----------\n545     angle : array, list, scalar, `~astropy.units.Quantity`, `~astropy.coordinates.Angle`\n546         The angle value(s). If a tuple, will be interpreted as ``(h, m, s)``\n547         or ``(d, m, s)`` depending on ``unit``. If a string, it will be\n548         interpreted following the rules described for\n549         :class:`~astropy.coordinates.Angle`.\n550 \n551         If ``angle`` is a sequence or array of strings, the resulting\n552         values will be in the given ``unit``, or if `None` is provided,\n553         the unit will be taken from the first given value.\n554 \n555     unit : unit-like, optional\n556         The unit of the value specified for the angle.  This may be\n557         any string that `~astropy.units.Unit` understands, but it is\n558         better to give an actual unit object.  Must be an angular\n559         unit.\n560 \n561     Raises\n562     ------\n563     `~astropy.units.UnitsError`\n564         If a unit is not provided or it is not an angular unit.\n565     `TypeError`\n566         If the angle parameter is an instance of :class:`~astropy.coordinates.Longitude`.\n567     \"\"\"\n568     def __new__(cls, angle, unit=None, **kwargs):\n569         # Forbid creating a Lat from a Long.\n570         if isinstance(angle, Longitude):\n571             raise TypeError(\"A Latitude angle cannot be created from a Longitude angle\")\n572         self = super().__new__(cls, angle, unit=unit, **kwargs)\n573         self._validate_angles()\n574         return self\n575 \n576     def _validate_angles(self, angles=None):\n577         \"\"\"Check that angles are between -90 and 90 degrees.\n578         If not given, the check is done on the object itself\"\"\"\n579         # Convert the lower and upper bounds to the \"native\" unit of\n580         # this angle.  This limits multiplication to two values,\n581         # rather than the N values in `self.value`.  Also, the\n582         # comparison is performed on raw arrays, rather than Quantity\n583         # objects, for speed.\n584         if angles is None:\n585             angles = self\n586 \n587         if angles.unit is u.deg:\n588             limit = 90\n589         elif angles.unit is u.rad:\n590             limit = 0.5 * np.pi\n591         else:\n592             limit = u.degree.to(angles.unit, 90.0)\n593 \n594         # This invalid catch block can be removed when the minimum numpy\n595         # version is >= 1.19 (NUMPY_LT_1_19)\n596         with np.errstate(invalid='ignore'):\n597             invalid_angles = (np.any(angles.value < -limit) or\n598                               np.any(angles.value > limit))\n599         if invalid_angles:\n600             raise ValueError('Latitude angle(s) must be within -90 deg <= angle <= 90 deg, '\n601                              'got {}'.format(angles.to(u.degree)))\n602 \n603     def __setitem__(self, item, value):\n604         # Forbid assigning a Long to a Lat.\n605         if isinstance(value, Longitude):\n606             raise TypeError(\"A Longitude angle cannot be assigned to a Latitude angle\")\n607         # first check bounds\n608         if value is not np.ma.masked:\n609             self._validate_angles(value)\n610         super().__setitem__(item, value)\n611 \n612     # Any calculation should drop to Angle\n613     def __array_ufunc__(self, *args, **kwargs):\n614         results = super().__array_ufunc__(*args, **kwargs)\n615         return _no_angle_subclass(results)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]