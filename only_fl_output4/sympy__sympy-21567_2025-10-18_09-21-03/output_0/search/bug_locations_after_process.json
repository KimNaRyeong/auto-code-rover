[
    {
        "rel_file_path": "sympy/core/function.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/core/function.py",
        "start": 2524,
        "end": 2853,
        "class_name": null,
        "method_name": "expand",
        "code": "2524 def expand(e, deep=True, modulus=None, power_base=True, power_exp=True,\n2525         mul=True, log=True, multinomial=True, basic=True, **hints):\n2526     r\"\"\"\n2527     Expand an expression using methods given as hints.\n2528 \n2529     Explanation\n2530     ===========\n2531 \n2532     Hints evaluated unless explicitly set to False are:  ``basic``, ``log``,\n2533     ``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following\n2534     hints are supported but not applied unless set to True:  ``complex``,\n2535     ``func``, and ``trig``.  In addition, the following meta-hints are\n2536     supported by some or all of the other hints:  ``frac``, ``numer``,\n2537     ``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all\n2538     hints.  Additionally, subclasses of Expr may define their own hints or\n2539     meta-hints.\n2540 \n2541     The ``basic`` hint is used for any special rewriting of an object that\n2542     should be done automatically (along with the other hints like ``mul``)\n2543     when expand is called. This is a catch-all hint to handle any sort of\n2544     expansion that may not be described by the existing hint names. To use\n2545     this hint an object should override the ``_eval_expand_basic`` method.\n2546     Objects may also define their own expand methods, which are not run by\n2547     default.  See the API section below.\n2548 \n2549     If ``deep`` is set to ``True`` (the default), things like arguments of\n2550     functions are recursively expanded.  Use ``deep=False`` to only expand on\n2551     the top level.\n2552 \n2553     If the ``force`` hint is used, assumptions about variables will be ignored\n2554     in making the expansion.\n2555 \n2556     Hints\n2557     =====\n2558 \n2559     These hints are run by default\n2560 \n2561     mul\n2562     ---\n2563 \n2564     Distributes multiplication over addition:\n2565 \n2566     >>> from sympy import cos, exp, sin\n2567     >>> from sympy.abc import x, y, z\n2568     >>> (y*(x + z)).expand(mul=True)\n2569     x*y + y*z\n2570 \n2571     multinomial\n2572     -----------\n2573 \n2574     Expand (x + y + ...)**n where n is a positive integer.\n2575 \n2576     >>> ((x + y + z)**2).expand(multinomial=True)\n2577     x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n2578 \n2579     power_exp\n2580     ---------\n2581 \n2582     Expand addition in exponents into multiplied bases.\n2583 \n2584     >>> exp(x + y).expand(power_exp=True)\n2585     exp(x)*exp(y)\n2586     >>> (2**(x + y)).expand(power_exp=True)\n2587     2**x*2**y\n2588 \n2589     power_base\n2590     ----------\n2591 \n2592     Split powers of multiplied bases.\n2593 \n2594     This only happens by default if assumptions allow, or if the\n2595     ``force`` meta-hint is used:\n2596 \n2597     >>> ((x*y)**z).expand(power_base=True)\n2598     (x*y)**z\n2599     >>> ((x*y)**z).expand(power_base=True, force=True)\n2600     x**z*y**z\n2601     >>> ((2*y)**z).expand(power_base=True)\n2602     2**z*y**z\n2603 \n2604     Note that in some cases where this expansion always holds, SymPy performs\n2605     it automatically:\n2606 \n2607     >>> (x*y)**2\n2608     x**2*y**2\n2609 \n2610     log\n2611     ---\n2612 \n2613     Pull out power of an argument as a coefficient and split logs products\n2614     into sums of logs.\n2615 \n2616     Note that these only work if the arguments of the log function have the\n2617     proper assumptions--the arguments must be positive and the exponents must\n2618     be real--or else the ``force`` hint must be True:\n2619 \n2620     >>> from sympy import log, symbols\n2621     >>> log(x**2*y).expand(log=True)\n2622     log(x**2*y)\n2623     >>> log(x**2*y).expand(log=True, force=True)\n2624     2*log(x) + log(y)\n2625     >>> x, y = symbols('x,y', positive=True)\n2626     >>> log(x**2*y).expand(log=True)\n2627     2*log(x) + log(y)\n2628 \n2629     basic\n2630     -----\n2631 \n2632     This hint is intended primarily as a way for custom subclasses to enable\n2633     expansion by default.\n2634 \n2635     These hints are not run by default:\n2636 \n2637     complex\n2638     -------\n2639 \n2640     Split an expression into real and imaginary parts.\n2641 \n2642     >>> x, y = symbols('x,y')\n2643     >>> (x + y).expand(complex=True)\n2644     re(x) + re(y) + I*im(x) + I*im(y)\n2645     >>> cos(x).expand(complex=True)\n2646     -I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x))\n2647 \n2648     Note that this is just a wrapper around ``as_real_imag()``.  Most objects\n2649     that wish to redefine ``_eval_expand_complex()`` should consider\n2650     redefining ``as_real_imag()`` instead.\n2651 \n2652     func\n2653     ----\n2654 \n2655     Expand other functions.\n2656 \n2657     >>> from sympy import gamma\n2658     >>> gamma(x + 1).expand(func=True)\n2659     x*gamma(x)\n2660 \n2661     trig\n2662     ----\n2663 \n2664     Do trigonometric expansions.\n2665 \n2666     >>> cos(x + y).expand(trig=True)\n2667     -sin(x)*sin(y) + cos(x)*cos(y)\n2668     >>> sin(2*x).expand(trig=True)\n2669     2*sin(x)*cos(x)\n2670 \n2671     Note that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)``\n2672     and ``cos(x)`` are not unique, due to the identity `\\sin^2(x) + \\cos^2(x)\n2673     = 1`.  The current implementation uses the form obtained from Chebyshev\n2674     polynomials, but this may change.  See `this MathWorld article\n2675     <http://mathworld.wolfram.com/Multiple-AngleFormulas.html>`_ for more\n2676     information.\n2677 \n2678     Notes\n2679     =====\n2680 \n2681     - You can shut off unwanted methods::\n2682 \n2683         >>> (exp(x + y)*(x + y)).expand()\n2684         x*exp(x)*exp(y) + y*exp(x)*exp(y)\n2685         >>> (exp(x + y)*(x + y)).expand(power_exp=False)\n2686         x*exp(x + y) + y*exp(x + y)\n2687         >>> (exp(x + y)*(x + y)).expand(mul=False)\n2688         (x + y)*exp(x)*exp(y)\n2689 \n2690     - Use deep=False to only expand on the top level::\n2691 \n2692         >>> exp(x + exp(x + y)).expand()\n2693         exp(x)*exp(exp(x)*exp(y))\n2694         >>> exp(x + exp(x + y)).expand(deep=False)\n2695         exp(x)*exp(exp(x + y))\n2696 \n2697     - Hints are applied in an arbitrary, but consistent order (in the current\n2698       implementation, they are applied in alphabetical order, except\n2699       multinomial comes before mul, but this may change).  Because of this,\n2700       some hints may prevent expansion by other hints if they are applied\n2701       first. For example, ``mul`` may distribute multiplications and prevent\n2702       ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is\n2703       applied before ``multinomial`, the expression might not be fully\n2704       distributed. The solution is to use the various ``expand_hint`` helper\n2705       functions or to use ``hint=False`` to this function to finely control\n2706       which hints are applied. Here are some examples::\n2707 \n2708         >>> from sympy import expand, expand_mul, expand_power_base\n2709         >>> x, y, z = symbols('x,y,z', positive=True)\n2710 \n2711         >>> expand(log(x*(y + z)))\n2712         log(x) + log(y + z)\n2713 \n2714       Here, we see that ``log`` was applied before ``mul``.  To get the mul\n2715       expanded form, either of the following will work::\n2716 \n2717         >>> expand_mul(log(x*(y + z)))\n2718         log(x*y + x*z)\n2719         >>> expand(log(x*(y + z)), log=False)\n2720         log(x*y + x*z)\n2721 \n2722       A similar thing can happen with the ``power_base`` hint::\n2723 \n2724         >>> expand((x*(y + z))**x)\n2725         (x*y + x*z)**x\n2726 \n2727       To get the ``power_base`` expanded form, either of the following will\n2728       work::\n2729 \n2730         >>> expand((x*(y + z))**x, mul=False)\n2731         x**x*(y + z)**x\n2732         >>> expand_power_base((x*(y + z))**x)\n2733         x**x*(y + z)**x\n2734 \n2735         >>> expand((x + y)*y/x)\n2736         y + y**2/x\n2737 \n2738       The parts of a rational expression can be targeted::\n2739 \n2740         >>> expand((x + y)*y/x/(x + 1), frac=True)\n2741         (x*y + y**2)/(x**2 + x)\n2742         >>> expand((x + y)*y/x/(x + 1), numer=True)\n2743         (x*y + y**2)/(x*(x + 1))\n2744         >>> expand((x + y)*y/x/(x + 1), denom=True)\n2745         y*(x + y)/(x**2 + x)\n2746 \n2747     - The ``modulus`` meta-hint can be used to reduce the coefficients of an\n2748       expression post-expansion::\n2749 \n2750         >>> expand((3*x + 1)**2)\n2751         9*x**2 + 6*x + 1\n2752         >>> expand((3*x + 1)**2, modulus=5)\n2753         4*x**2 + x + 1\n2754 \n2755     - Either ``expand()`` the function or ``.expand()`` the method can be\n2756       used.  Both are equivalent::\n2757 \n2758         >>> expand((x + 1)**2)\n2759         x**2 + 2*x + 1\n2760         >>> ((x + 1)**2).expand()\n2761         x**2 + 2*x + 1\n2762 \n2763     API\n2764     ===\n2765 \n2766     Objects can define their own expand hints by defining\n2767     ``_eval_expand_hint()``.  The function should take the form::\n2768 \n2769         def _eval_expand_hint(self, **hints):\n2770             # Only apply the method to the top-level expression\n2771             ...\n2772 \n2773     See also the example below.  Objects should define ``_eval_expand_hint()``\n2774     methods only if ``hint`` applies to that specific object.  The generic\n2775     ``_eval_expand_hint()`` method defined in Expr will handle the no-op case.\n2776 \n2777     Each hint should be responsible for expanding that hint only.\n2778     Furthermore, the expansion should be applied to the top-level expression\n2779     only.  ``expand()`` takes care of the recursion that happens when\n2780     ``deep=True``.\n2781 \n2782     You should only call ``_eval_expand_hint()`` methods directly if you are\n2783     100% sure that the object has the method, as otherwise you are liable to\n2784     get unexpected ``AttributeError``s.  Note, again, that you do not need to\n2785     recursively apply the hint to args of your object: this is handled\n2786     automatically by ``expand()``.  ``_eval_expand_hint()`` should\n2787     generally not be used at all outside of an ``_eval_expand_hint()`` method.\n2788     If you want to apply a specific expansion from within another method, use\n2789     the public ``expand()`` function, method, or ``expand_hint()`` functions.\n2790 \n2791     In order for expand to work, objects must be rebuildable by their args,\n2792     i.e., ``obj.func(*obj.args) == obj`` must hold.\n2793 \n2794     Expand methods are passed ``**hints`` so that expand hints may use\n2795     'metahints'--hints that control how different expand methods are applied.\n2796     For example, the ``force=True`` hint described above that causes\n2797     ``expand(log=True)`` to ignore assumptions is such a metahint.  The\n2798     ``deep`` meta-hint is handled exclusively by ``expand()`` and is not\n2799     passed to ``_eval_expand_hint()`` methods.\n2800 \n2801     Note that expansion hints should generally be methods that perform some\n2802     kind of 'expansion'.  For hints that simply rewrite an expression, use the\n2803     .rewrite() API.\n2804 \n2805     Examples\n2806     ========\n2807 \n2808     >>> from sympy import Expr, sympify\n2809     >>> class MyClass(Expr):\n2810     ...     def __new__(cls, *args):\n2811     ...         args = sympify(args)\n2812     ...         return Expr.__new__(cls, *args)\n2813     ...\n2814     ...     def _eval_expand_double(self, *, force=False, **hints):\n2815     ...         '''\n2816     ...         Doubles the args of MyClass.\n2817     ...\n2818     ...         If there more than four args, doubling is not performed,\n2819     ...         unless force=True is also used (False by default).\n2820     ...         '''\n2821     ...         if not force and len(self.args) > 4:\n2822     ...             return self\n2823     ...         return self.func(*(self.args + self.args))\n2824     ...\n2825     >>> a = MyClass(1, 2, MyClass(3, 4))\n2826     >>> a\n2827     MyClass(1, 2, MyClass(3, 4))\n2828     >>> a.expand(double=True)\n2829     MyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))\n2830     >>> a.expand(double=True, deep=False)\n2831     MyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4))\n2832 \n2833     >>> b = MyClass(1, 2, 3, 4, 5)\n2834     >>> b.expand(double=True)\n2835     MyClass(1, 2, 3, 4, 5)\n2836     >>> b.expand(double=True, force=True)\n2837     MyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n2838 \n2839     See Also\n2840     ========\n2841 \n2842     expand_log, expand_mul, expand_multinomial, expand_complex, expand_trig,\n2843     expand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand\n2844 \n2845     \"\"\"\n2846     # don't modify this; modify the Expr.expand method\n2847     hints['power_base'] = power_base\n2848     hints['power_exp'] = power_exp\n2849     hints['mul'] = mul\n2850     hints['log'] = log\n2851     hints['multinomial'] = multinomial\n2852     hints['basic'] = basic\n2853     return sympify(e).expand(deep=deep, modulus=modulus, **hints)\n",
        "intended_behavior": "The `expand` method should correctly identify and expand hyperbolic functions `csch` and `sech` when given the `trig=True` hint. This includes recognizing these functions for expansion, implementing correct expansion rules, and preserving existing functionality."
    }
]