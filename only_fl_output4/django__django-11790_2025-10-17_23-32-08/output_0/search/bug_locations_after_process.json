[
    {
        "rel_file_path": "django/contrib/auth/forms.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/forms.py",
        "start": 183,
        "end": 196,
        "class_name": "AuthenticationForm",
        "method_name": "__init__",
        "code": "183     def __init__(self, request=None, *args, **kwargs):\n184         \"\"\"\n185         The 'request' parameter is set for custom auth use by subclasses.\n186         The form data comes in via the standard 'data' kwarg.\n187         \"\"\"\n188         self.request = request\n189         self.user_cache = None\n190         super().__init__(*args, **kwargs)\n191 \n192         # Set the max length and label for the \"username\" field.\n193         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n194         self.fields['username'].max_length = self.username_field.max_length or 254\n195         if self.fields['username'].label is None:\n196             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n",
        "intended_behavior": "The `__init__` method, specifically where it configures attributes for the `username` field, should be amended to ensure that the `maxlength` HTML attribute is set based on the `max_length` of the username field. This will involve adjusting the creation or modification of the `username` field's widget attributes within this method: After line 192, where the `max_length` and `label` for the \"username\" field are set, additional code should be included to ensure the `maxlength` attribute is also reflected in the HTML. This can be achieved by updating or extending the `attrs` dictionary for the `username` field's widget. The intended code adjustment should ensure that: 1. The `maxlength` attribute in the `attrs` dictionary of the `username` field's widget (`forms.TextInput`) is set to the same value as the field's `max_length` property. 2. This adjustment preserves existing functionality, such as respecting the autofocus attribute already set, and does not interfere with other field properties or form-wide behavior. The intended modification ensures client-side validation for the username input length, matching the backend validation already performed by Django forms. This approach maintains usability and accessibility standards by providing immediate feedback to users before form submission."
    },
    {
        "rel_file_path": "django/contrib/auth/forms.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/forms.py",
        "start": 163,
        "end": 236,
        "class_name": "AuthenticationForm",
        "method_name": null,
        "code": "163 class AuthenticationForm(forms.Form):\n164     \"\"\"\n165     Base class for authenticating users. Extend this to get a form that accepts\n166     username/password logins.\n167     \"\"\"\n168     username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))\n169     password = forms.CharField(\n170         label=_(\"Password\"),\n171         strip=False,\n172         widget=forms.PasswordInput(attrs={'autocomplete': 'current-password'}),\n173     )\n174 \n175     error_messages = {\n176         'invalid_login': _(\n177             \"Please enter a correct %(username)s and password. Note that both \"\n178             \"fields may be case-sensitive.\"\n179         ),\n180         'inactive': _(\"This account is inactive.\"),\n181     }\n182 \n183     def __init__(self, request=None, *args, **kwargs):\n184         \"\"\"\n185         The 'request' parameter is set for custom auth use by subclasses.\n186         The form data comes in via the standard 'data' kwarg.\n187         \"\"\"\n188         self.request = request\n189         self.user_cache = None\n190         super().__init__(*args, **kwargs)\n191 \n192         # Set the max length and label for the \"username\" field.\n193         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n194         self.fields['username'].max_length = self.username_field.max_length or 254\n195         if self.fields['username'].label is None:\n196             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n197 \n198     def clean(self):\n199         username = self.cleaned_data.get('username')\n200         password = self.cleaned_data.get('password')\n201 \n202         if username is not None and password:\n203             self.user_cache = authenticate(self.request, username=username, password=password)\n204             if self.user_cache is None:\n205                 raise self.get_invalid_login_error()\n206             else:\n207                 self.confirm_login_allowed(self.user_cache)\n208 \n209         return self.cleaned_data\n210 \n211     def confirm_login_allowed(self, user):\n212         \"\"\"\n213         Controls whether the given User may log in. This is a policy setting,\n214         independent of end-user authentication. This default behavior is to\n215         allow login by active users, and reject login by inactive users.\n216 \n217         If the given user cannot log in, this method should raise a\n218         ``forms.ValidationError``.\n219 \n220         If the given user may log in, this method should return None.\n221         \"\"\"\n222         if not user.is_active:\n223             raise forms.ValidationError(\n224                 self.error_messages['inactive'],\n225                 code='inactive',\n226             )\n227 \n228     def get_user(self):\n229         return self.user_cache\n230 \n231     def get_invalid_login_error(self):\n232         return forms.ValidationError(\n233             self.error_messages['invalid_login'],\n234             code='invalid_login',\n235             params={'username': self.username_field.verbose_name},\n236         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]