[
    {
        "rel_file_path": "django/db/migrations/autodetector.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/autodetector.py",
        "start": 1,
        "end": 1316,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import re\n3 from itertools import chain\n4 \n5 from django.conf import settings\n6 from django.db import models\n7 from django.db.migrations import operations\n8 from django.db.migrations.migration import Migration\n9 from django.db.migrations.operations.models import AlterModelOptions\n10 from django.db.migrations.optimizer import MigrationOptimizer\n11 from django.db.migrations.questioner import MigrationQuestioner\n12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject\n13 from django.utils.topological_sort import stable_topological_sort\n14 \n15 \n16 class MigrationAutodetector:\n17     \"\"\"\n18     Take a pair of ProjectStates and compare them to see what the first would\n19     need doing to make it match the second (the second usually being the\n20     project's current state).\n21 \n22     Note that this naturally operates on entire projects at a time,\n23     as it's likely that changes interact (for example, you can't\n24     add a ForeignKey without having a migration to add the table it\n25     depends on first). A user interface may offer single-app usage\n26     if it wishes, with the caveat that it may not always be possible.\n27     \"\"\"\n28 \n29     def __init__(self, from_state, to_state, questioner=None):\n30         self.from_state = from_state\n31         self.to_state = to_state\n32         self.questioner = questioner or MigrationQuestioner()\n33         self.existing_apps = {app for app, model in from_state.models}\n34 \n35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n36         \"\"\"\n37         Main entry point to produce a list of applicable changes.\n38         Take a graph to base names on and an optional set of apps\n39         to try and restrict to (restriction is not guaranteed)\n40         \"\"\"\n41         changes = self._detect_changes(convert_apps, graph)\n42         changes = self.arrange_for_graph(changes, graph, migration_name)\n43         if trim_to_apps:\n44             changes = self._trim_to_apps(changes, trim_to_apps)\n45         return changes\n46 \n47     def deep_deconstruct(self, obj):\n48         \"\"\"\n49         Recursive deconstruction for a field and its arguments.\n50         Used for full comparison for rename/alter; sometimes a single-level\n51         deconstruction will not compare correctly.\n52         \"\"\"\n53         if isinstance(obj, list):\n54             return [self.deep_deconstruct(value) for value in obj]\n55         elif isinstance(obj, tuple):\n56             return tuple(self.deep_deconstruct(value) for value in obj)\n57         elif isinstance(obj, dict):\n58             return {\n59                 key: self.deep_deconstruct(value)\n60                 for key, value in obj.items()\n61             }\n62         elif isinstance(obj, functools.partial):\n63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))\n64         elif isinstance(obj, COMPILED_REGEX_TYPE):\n65             return RegexObject(obj)\n66         elif isinstance(obj, type):\n67             # If this is a type that implements 'deconstruct' as an instance method,\n68             # avoid treating this as being deconstructible itself - see #22951\n69             return obj\n70         elif hasattr(obj, 'deconstruct'):\n71             deconstructed = obj.deconstruct()\n72             if isinstance(obj, models.Field):\n73                 # we have a field which also returns a name\n74                 deconstructed = deconstructed[1:]\n75             path, args, kwargs = deconstructed\n76             return (\n77                 path,\n78                 [self.deep_deconstruct(value) for value in args],\n79                 {\n80                     key: self.deep_deconstruct(value)\n81                     for key, value in kwargs.items()\n82                 },\n83             )\n84         else:\n85             return obj\n86 \n87     def only_relation_agnostic_fields(self, fields):\n88         \"\"\"\n89         Return a definition of the fields that ignores field names and\n90         what related fields actually relate to. Used for detecting renames (as\n91         the related fields change during renames).\n92         \"\"\"\n93         fields_def = []\n94         for name, field in sorted(fields.items()):\n95             deconstruction = self.deep_deconstruct(field)\n96             if field.remote_field and field.remote_field.model:\n97                 del deconstruction[2]['to']\n98             fields_def.append(deconstruction)\n99         return fields_def\n100 \n101     def _detect_changes(self, convert_apps=None, graph=None):\n102         \"\"\"\n103         Return a dict of migration plans which will achieve the\n104         change from from_state to to_state. The dict has app labels\n105         as keys and a list of migrations as values.\n106 \n107         The resulting migrations aren't specially named, but the names\n108         do matter for dependencies inside the set.\n109 \n110         convert_apps is the list of apps to convert to use migrations\n111         (i.e. to make initial migrations for, in the usual case)\n112 \n113         graph is an optional argument that, if provided, can help improve\n114         dependency generation and avoid potential circular dependencies.\n115         \"\"\"\n116         # The first phase is generating all the operations for each app\n117         # and gathering them into a big per-app list.\n118         # Then go through that list, order it, and split into migrations to\n119         # resolve dependencies caused by M2Ms and FKs.\n120         self.generated_operations = {}\n121         self.altered_indexes = {}\n122         self.altered_constraints = {}\n123 \n124         # Prepare some old/new state and model lists, separating\n125         # proxy models and ignoring unmigrated apps.\n126         self.old_apps = self.from_state.concrete_apps\n127         self.new_apps = self.to_state.apps\n128         self.old_model_keys = set()\n129         self.old_proxy_keys = set()\n130         self.old_unmanaged_keys = set()\n131         self.new_model_keys = set()\n132         self.new_proxy_keys = set()\n133         self.new_unmanaged_keys = set()\n134         for al, mn in self.from_state.models:\n135             model = self.old_apps.get_model(al, mn)\n136             if not model._meta.managed:\n137                 self.old_unmanaged_keys.add((al, mn))\n138             elif al not in self.from_state.real_apps:\n139                 if model._meta.proxy:\n140                     self.old_proxy_keys.add((al, mn))\n141                 else:\n142                     self.old_model_keys.add((al, mn))\n143 \n144         for al, mn in self.to_state.models:\n145             model = self.new_apps.get_model(al, mn)\n146             if not model._meta.managed:\n147                 self.new_unmanaged_keys.add((al, mn))\n148             elif (\n149                 al not in self.from_state.real_apps or\n150                 (convert_apps and al in convert_apps)\n151             ):\n152                 if model._meta.proxy:\n153                     self.new_proxy_keys.add((al, mn))\n154                 else:\n155                     self.new_model_keys.add((al, mn))\n156 \n157         # Renames have to come first\n158         self.generate_renamed_models()\n159 \n160         # Prepare lists of fields and generate through model map\n161         self._prepare_field_lists()\n162         self._generate_through_model_map()\n163 \n164         # Generate non-rename model operations\n165         self.generate_deleted_models()\n166         self.generate_created_models()\n167         self.generate_deleted_proxies()\n168         self.generate_created_proxies()\n169         self.generate_altered_options()\n170         self.generate_altered_managers()\n171 \n172         # Create the altered indexes and store them in self.altered_indexes.\n173         # This avoids the same computation in generate_removed_indexes()\n174         # and generate_added_indexes().\n175         self.create_altered_indexes()\n176         self.create_altered_constraints()\n177         # Generate index removal operations before field is removed\n178         self.generate_removed_constraints()\n179         self.generate_removed_indexes()\n180         # Generate field operations\n181         self.generate_renamed_fields()\n182         self.generate_removed_fields()\n183         self.generate_added_fields()\n184         self.generate_altered_fields()\n185         self.generate_altered_order_with_respect_to()\n186         self.generate_altered_unique_together()\n187         self.generate_altered_index_together()\n188         self.generate_added_indexes()\n189         self.generate_added_constraints()\n190         self.generate_altered_db_table()\n191 \n192         self._sort_migrations()\n193         self._build_migration_list(graph)\n194         self._optimize_migrations()\n195 \n196         return self.migrations\n197 \n198     def _prepare_field_lists(self):\n199         \"\"\"\n200         Prepare field lists and a list of the fields that used through models\n201         in the old state so dependencies can be made from the through model\n202         deletion to the field that uses it.\n203         \"\"\"\n204         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n207         self.through_users = {}\n208         self.old_field_keys = {\n209             (app_label, model_name, field_name)\n210             for app_label, model_name in self.kept_model_keys\n211             for field_name in self.from_state.models[\n212                 app_label,\n213                 self.renamed_models.get((app_label, model_name), model_name)\n214             ].fields\n215         }\n216         self.new_field_keys = {\n217             (app_label, model_name, field_name)\n218             for app_label, model_name in self.kept_model_keys\n219             for field_name in self.to_state.models[app_label, model_name].fields\n220         }\n221 \n222     def _generate_through_model_map(self):\n223         \"\"\"Through model map generation.\"\"\"\n224         for app_label, model_name in sorted(self.old_model_keys):\n225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n226             old_model_state = self.from_state.models[app_label, old_model_name]\n227             for field_name in old_model_state.fields:\n228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)\n229                 if (hasattr(old_field, \"remote_field\") and getattr(old_field.remote_field, \"through\", None) and\n230                         not old_field.remote_field.through._meta.auto_created):\n231                     through_key = (\n232                         old_field.remote_field.through._meta.app_label,\n233                         old_field.remote_field.through._meta.model_name,\n234                     )\n235                     self.through_users[through_key] = (app_label, old_model_name, field_name)\n236 \n237     @staticmethod\n238     def _resolve_dependency(dependency):\n239         \"\"\"\n240         Return the resolved dependency and a boolean denoting whether or not\n241         it was swappable.\n242         \"\"\"\n243         if dependency[0] != '__setting__':\n244             return dependency, False\n245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')\n246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True\n247 \n248     def _build_migration_list(self, graph=None):\n249         \"\"\"\n250         Chop the lists of operations up into migrations with dependencies on\n251         each other. Do this by going through an app's list of operations until\n252         one is found that has an outgoing dependency that isn't in another\n253         app's migration yet (hasn't been chopped off its list). Then chop off\n254         the operations before it into a migration and move onto the next app.\n255         If the loops completes without doing anything, there's a circular\n256         dependency (which _should_ be impossible as the operations are\n257         all split at this point so they can't depend and be depended on).\n258         \"\"\"\n259         self.migrations = {}\n260         num_ops = sum(len(x) for x in self.generated_operations.values())\n261         chop_mode = False\n262         while num_ops:\n263             # On every iteration, we step through all the apps and see if there\n264             # is a completed set of operations.\n265             # If we find that a subset of the operations are complete we can\n266             # try to chop it off from the rest and continue, but we only\n267             # do this if we've already been through the list once before\n268             # without any chopping and nothing has changed.\n269             for app_label in sorted(self.generated_operations):\n270                 chopped = []\n271                 dependencies = set()\n272                 for operation in list(self.generated_operations[app_label]):\n273                     deps_satisfied = True\n274                     operation_dependencies = set()\n275                     for dep in operation._auto_deps:\n276                         # Temporarily resolve the swappable dependency to\n277                         # prevent circular references. While keeping the\n278                         # dependency checks on the resolved model, add the\n279                         # swappable dependencies.\n280                         original_dep = dep\n281                         dep, is_swappable_dep = self._resolve_dependency(dep)\n282                         if dep[0] != app_label:\n283                             # External app dependency. See if it's not yet\n284                             # satisfied.\n285                             for other_operation in self.generated_operations.get(dep[0], []):\n286                                 if self.check_dependency(other_operation, dep):\n287                                     deps_satisfied = False\n288                                     break\n289                             if not deps_satisfied:\n290                                 break\n291                             else:\n292                                 if is_swappable_dep:\n293                                     operation_dependencies.add((original_dep[0], original_dep[1]))\n294                                 elif dep[0] in self.migrations:\n295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))\n296                                 else:\n297                                     # If we can't find the other app, we add a first/last dependency,\n298                                     # but only if we've already been through once and checked everything\n299                                     if chop_mode:\n300                                         # If the app already exists, we add a dependency on the last migration,\n301                                         # as we don't know which migration contains the target field.\n302                                         # If it's not yet migrated or has no migrations, we use __first__\n303                                         if graph and graph.leaf_nodes(dep[0]):\n304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])\n305                                         else:\n306                                             operation_dependencies.add((dep[0], \"__first__\"))\n307                                     else:\n308                                         deps_satisfied = False\n309                     if deps_satisfied:\n310                         chopped.append(operation)\n311                         dependencies.update(operation_dependencies)\n312                         del self.generated_operations[app_label][0]\n313                     else:\n314                         break\n315                 # Make a migration! Well, only if there's stuff to put in it\n316                 if dependencies or chopped:\n317                     if not self.generated_operations[app_label] or chop_mode:\n318                         subclass = type(\"Migration\", (Migration,), {\"operations\": [], \"dependencies\": []})\n319                         instance = subclass(\"auto_%i\" % (len(self.migrations.get(app_label, [])) + 1), app_label)\n320                         instance.dependencies = list(dependencies)\n321                         instance.operations = chopped\n322                         instance.initial = app_label not in self.existing_apps\n323                         self.migrations.setdefault(app_label, []).append(instance)\n324                         chop_mode = False\n325                     else:\n326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]\n327             new_num_ops = sum(len(x) for x in self.generated_operations.values())\n328             if new_num_ops == num_ops:\n329                 if not chop_mode:\n330                     chop_mode = True\n331                 else:\n332                     raise ValueError(\"Cannot resolve operation dependencies: %r\" % self.generated_operations)\n333             num_ops = new_num_ops\n334 \n335     def _sort_migrations(self):\n336         \"\"\"\n337         Reorder to make things possible. Reordering may be needed so FKs work\n338         nicely inside the same app.\n339         \"\"\"\n340         for app_label, ops in sorted(self.generated_operations.items()):\n341             # construct a dependency graph for intra-app dependencies\n342             dependency_graph = {op: set() for op in ops}\n343             for op in ops:\n344                 for dep in op._auto_deps:\n345                     # Resolve intra-app dependencies to handle circular\n346                     # references involving a swappable model.\n347                     dep = self._resolve_dependency(dep)[0]\n348                     if dep[0] == app_label:\n349                         for op2 in ops:\n350                             if self.check_dependency(op2, dep):\n351                                 dependency_graph[op].add(op2)\n352 \n353             # we use a stable sort for deterministic tests & general behavior\n354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n355 \n356     def _optimize_migrations(self):\n357         # Add in internal dependencies among the migrations\n358         for app_label, migrations in self.migrations.items():\n359             for m1, m2 in zip(migrations, migrations[1:]):\n360                 m2.dependencies.append((app_label, m1.name))\n361 \n362         # De-dupe dependencies\n363         for migrations in self.migrations.values():\n364             for migration in migrations:\n365                 migration.dependencies = list(set(migration.dependencies))\n366 \n367         # Optimize migrations\n368         for app_label, migrations in self.migrations.items():\n369             for migration in migrations:\n370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)\n371 \n372     def check_dependency(self, operation, dependency):\n373         \"\"\"\n374         Return True if the given operation depends on the given dependency,\n375         False otherwise.\n376         \"\"\"\n377         # Created model\n378         if dependency[2] is None and dependency[3] is True:\n379             return (\n380                 isinstance(operation, operations.CreateModel) and\n381                 operation.name_lower == dependency[1].lower()\n382             )\n383         # Created field\n384         elif dependency[2] is not None and dependency[3] is True:\n385             return (\n386                 (\n387                     isinstance(operation, operations.CreateModel) and\n388                     operation.name_lower == dependency[1].lower() and\n389                     any(dependency[2] == x for x, y in operation.fields)\n390                 ) or\n391                 (\n392                     isinstance(operation, operations.AddField) and\n393                     operation.model_name_lower == dependency[1].lower() and\n394                     operation.name_lower == dependency[2].lower()\n395                 )\n396             )\n397         # Removed field\n398         elif dependency[2] is not None and dependency[3] is False:\n399             return (\n400                 isinstance(operation, operations.RemoveField) and\n401                 operation.model_name_lower == dependency[1].lower() and\n402                 operation.name_lower == dependency[2].lower()\n403             )\n404         # Removed model\n405         elif dependency[2] is None and dependency[3] is False:\n406             return (\n407                 isinstance(operation, operations.DeleteModel) and\n408                 operation.name_lower == dependency[1].lower()\n409             )\n410         # Field being altered\n411         elif dependency[2] is not None and dependency[3] == \"alter\":\n412             return (\n413                 isinstance(operation, operations.AlterField) and\n414                 operation.model_name_lower == dependency[1].lower() and\n415                 operation.name_lower == dependency[2].lower()\n416             )\n417         # order_with_respect_to being unset for a field\n418         elif dependency[2] is not None and dependency[3] == \"order_wrt_unset\":\n419             return (\n420                 isinstance(operation, operations.AlterOrderWithRespectTo) and\n421                 operation.name_lower == dependency[1].lower() and\n422                 (operation.order_with_respect_to or \"\").lower() != dependency[2].lower()\n423             )\n424         # Field is removed and part of an index/unique_together\n425         elif dependency[2] is not None and dependency[3] == \"foo_together_change\":\n426             return (\n427                 isinstance(operation, (operations.AlterUniqueTogether,\n428                                        operations.AlterIndexTogether)) and\n429                 operation.name_lower == dependency[1].lower()\n430             )\n431         # Unknown dependency. Raise an error.\n432         else:\n433             raise ValueError(\"Can't handle dependency %r\" % (dependency,))\n434 \n435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)\n437         operation._auto_deps = dependencies or []\n438         if beginning:\n439             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n440         else:\n441             self.generated_operations.setdefault(app_label, []).append(operation)\n442 \n443     def swappable_first_key(self, item):\n444         \"\"\"\n445         Place potential swappable models first in lists of created models (only\n446         real way to solve #22783).\n447         \"\"\"\n448         try:\n449             model = self.new_apps.get_model(item[0], item[1])\n450             base_names = [base.__name__ for base in model.__bases__]\n451             string_version = \"%s.%s\" % (item[0], item[1])\n452             if (\n453                 model._meta.swappable or\n454                 \"AbstractUser\" in base_names or\n455                 \"AbstractBaseUser\" in base_names or\n456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()\n457             ):\n458                 return (\"___\" + item[0], \"___\" + item[1])\n459         except LookupError:\n460             pass\n461         return item\n462 \n463     def generate_renamed_models(self):\n464         \"\"\"\n465         Find any renamed models, generate the operations for them, and remove\n466         the old entry from the model lists. Must be run before other\n467         model-level generation.\n468         \"\"\"\n469         self.renamed_models = {}\n470         self.renamed_models_rel = {}\n471         added_models = self.new_model_keys - self.old_model_keys\n472         for app_label, model_name in sorted(added_models):\n473             model_state = self.to_state.models[app_label, model_name]\n474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n475 \n476             removed_models = self.old_model_keys - self.new_model_keys\n477             for rem_app_label, rem_model_name in removed_models:\n478                 if rem_app_label == app_label:\n479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]\n480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)\n481                     if model_fields_def == rem_model_fields_def:\n482                         if self.questioner.ask_rename_model(rem_model_state, model_state):\n483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n484                             dependencies = []\n485                             for field in model_opts.get_fields():\n486                                 if field.is_relation:\n487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))\n488                             self.add_operation(\n489                                 app_label,\n490                                 operations.RenameModel(\n491                                     old_name=rem_model_state.name,\n492                                     new_name=model_state.name,\n493                                 ),\n494                                 dependencies=dependencies,\n495                             )\n496                             self.renamed_models[app_label, model_name] = rem_model_name\n497                             renamed_models_rel_key = '%s.%s' % (\n498                                 rem_model_state.app_label,\n499                                 rem_model_state.name_lower,\n500                             )\n501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (\n502                                 model_state.app_label,\n503                                 model_state.name_lower,\n504                             )\n505                             self.old_model_keys.remove((rem_app_label, rem_model_name))\n506                             self.old_model_keys.add((app_label, model_name))\n507                             break\n508 \n509     def generate_created_models(self):\n510         \"\"\"\n511         Find all new models (both managed and unmanaged) and make create\n512         operations for them as well as separate operations to create any\n513         foreign key or M2M relationships (these are optimized later, if\n514         possible).\n515 \n516         Defer any model options that refer to collections of fields that might\n517         be deferred (e.g. unique_together, index_together).\n518         \"\"\"\n519         old_keys = self.old_model_keys | self.old_unmanaged_keys\n520         added_models = self.new_model_keys - old_keys\n521         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n522         all_added_models = chain(\n523             sorted(added_models, key=self.swappable_first_key, reverse=True),\n524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)\n525         )\n526         for app_label, model_name in all_added_models:\n527             model_state = self.to_state.models[app_label, model_name]\n528             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n529             # Gather related fields\n530             related_fields = {}\n531             primary_key_rel = None\n532             for field in model_opts.local_fields:\n533                 if field.remote_field:\n534                     if field.remote_field.model:\n535                         if field.primary_key:\n536                             primary_key_rel = field.remote_field.model\n537                         elif not field.remote_field.parent_link:\n538                             related_fields[field.name] = field\n539                     # through will be none on M2Ms on swapped-out models;\n540                     # we can treat lack of through as auto_created=True, though.\n541                     if (getattr(field.remote_field, \"through\", None) and\n542                             not field.remote_field.through._meta.auto_created):\n543                         related_fields[field.name] = field\n544             for field in model_opts.local_many_to_many:\n545                 if field.remote_field.model:\n546                     related_fields[field.name] = field\n547                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n548                     related_fields[field.name] = field\n549             # Are there indexes/unique|index_together to defer?\n550             indexes = model_state.options.pop('indexes')\n551             constraints = model_state.options.pop('constraints')\n552             unique_together = model_state.options.pop('unique_together', None)\n553             index_together = model_state.options.pop('index_together', None)\n554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)\n555             # Depend on the deletion of any possible proxy version of us\n556             dependencies = [\n557                 (app_label, model_name, None, False),\n558             ]\n559             # Depend on all bases\n560             for base in model_state.bases:\n561                 if isinstance(base, str) and \".\" in base:\n562                     base_app_label, base_name = base.split(\".\", 1)\n563                     dependencies.append((base_app_label, base_name, None, True))\n564                     # Depend on the removal of base fields if the new model has\n565                     # a field with the same name.\n566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))\n567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))\n568                     if old_base_model_state and new_base_model_state:\n569                         removed_base_fields = set(old_base_model_state.fields).difference(\n570                             new_base_model_state.fields,\n571                         ).intersection(model_state.fields)\n572                         for removed_base_field in removed_base_fields:\n573                             dependencies.append((base_app_label, base_name, removed_base_field, False))\n574             # Depend on the other end of the primary key if it's a relation\n575             if primary_key_rel:\n576                 dependencies.append((\n577                     primary_key_rel._meta.app_label,\n578                     primary_key_rel._meta.object_name,\n579                     None,\n580                     True\n581                 ))\n582             # Generate creation operation\n583             self.add_operation(\n584                 app_label,\n585                 operations.CreateModel(\n586                     name=model_state.name,\n587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],\n588                     options=model_state.options,\n589                     bases=model_state.bases,\n590                     managers=model_state.managers,\n591                 ),\n592                 dependencies=dependencies,\n593                 beginning=True,\n594             )\n595 \n596             # Don't add operations which modify the database for unmanaged models\n597             if not model_opts.managed:\n598                 continue\n599 \n600             # Generate operations for each related field\n601             for name, field in sorted(related_fields.items()):\n602                 dependencies = self._get_dependencies_for_foreign_key(field)\n603                 # Depend on our own model being created\n604                 dependencies.append((app_label, model_name, None, True))\n605                 # Make operation\n606                 self.add_operation(\n607                     app_label,\n608                     operations.AddField(\n609                         model_name=model_name,\n610                         name=name,\n611                         field=field,\n612                     ),\n613                     dependencies=list(set(dependencies)),\n614                 )\n615             # Generate other opns\n616             if order_with_respect_to:\n617                 self.add_operation(\n618                     app_label,\n619                     operations.AlterOrderWithRespectTo(\n620                         name=model_name,\n621                         order_with_respect_to=order_with_respect_to,\n622                     ),\n623                     dependencies=[\n624                         (app_label, model_name, order_with_respect_to, True),\n625                         (app_label, model_name, None, True),\n626                     ]\n627                 )\n628             related_dependencies = [\n629                 (app_label, model_name, name, True)\n630                 for name in sorted(related_fields)\n631             ]\n632             related_dependencies.append((app_label, model_name, None, True))\n633             for index in indexes:\n634                 self.add_operation(\n635                     app_label,\n636                     operations.AddIndex(\n637                         model_name=model_name,\n638                         index=index,\n639                     ),\n640                     dependencies=related_dependencies,\n641                 )\n642             for constraint in constraints:\n643                 self.add_operation(\n644                     app_label,\n645                     operations.AddConstraint(\n646                         model_name=model_name,\n647                         constraint=constraint,\n648                     ),\n649                     dependencies=related_dependencies,\n650                 )\n651             if unique_together:\n652                 self.add_operation(\n653                     app_label,\n654                     operations.AlterUniqueTogether(\n655                         name=model_name,\n656                         unique_together=unique_together,\n657                     ),\n658                     dependencies=related_dependencies\n659                 )\n660             if index_together:\n661                 self.add_operation(\n662                     app_label,\n663                     operations.AlterIndexTogether(\n664                         name=model_name,\n665                         index_together=index_together,\n666                     ),\n667                     dependencies=related_dependencies\n668                 )\n669             # Fix relationships if the model changed from a proxy model to a\n670             # concrete model.\n671             if (app_label, model_name) in self.old_proxy_keys:\n672                 for related_object in model_opts.related_objects:\n673                     self.add_operation(\n674                         related_object.related_model._meta.app_label,\n675                         operations.AlterField(\n676                             model_name=related_object.related_model._meta.object_name,\n677                             name=related_object.field.name,\n678                             field=related_object.field,\n679                         ),\n680                         dependencies=[(app_label, model_name, None, True)],\n681                     )\n682 \n683     def generate_created_proxies(self):\n684         \"\"\"\n685         Make CreateModel statements for proxy models. Use the same statements\n686         as that way there's less code duplication, but for proxy models it's\n687         safe to skip all the pointless field stuff and chuck out an operation.\n688         \"\"\"\n689         added = self.new_proxy_keys - self.old_proxy_keys\n690         for app_label, model_name in sorted(added):\n691             model_state = self.to_state.models[app_label, model_name]\n692             assert model_state.options.get(\"proxy\")\n693             # Depend on the deletion of any possible non-proxy version of us\n694             dependencies = [\n695                 (app_label, model_name, None, False),\n696             ]\n697             # Depend on all bases\n698             for base in model_state.bases:\n699                 if isinstance(base, str) and \".\" in base:\n700                     base_app_label, base_name = base.split(\".\", 1)\n701                     dependencies.append((base_app_label, base_name, None, True))\n702             # Generate creation operation\n703             self.add_operation(\n704                 app_label,\n705                 operations.CreateModel(\n706                     name=model_state.name,\n707                     fields=[],\n708                     options=model_state.options,\n709                     bases=model_state.bases,\n710                     managers=model_state.managers,\n711                 ),\n712                 # Depend on the deletion of any possible non-proxy version of us\n713                 dependencies=dependencies,\n714             )\n715 \n716     def generate_deleted_models(self):\n717         \"\"\"\n718         Find all deleted models (managed and unmanaged) and make delete\n719         operations for them as well as separate operations to delete any\n720         foreign key or M2M relationships (these are optimized later, if\n721         possible).\n722 \n723         Also bring forward removal of any model options that refer to\n724         collections of fields - the inverse of generate_created_models().\n725         \"\"\"\n726         new_keys = self.new_model_keys | self.new_unmanaged_keys\n727         deleted_models = self.old_model_keys - new_keys\n728         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys\n729         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))\n730         for app_label, model_name in all_deleted_models:\n731             model_state = self.from_state.models[app_label, model_name]\n732             model = self.old_apps.get_model(app_label, model_name)\n733             # Gather related fields\n734             related_fields = {}\n735             for field in model._meta.local_fields:\n736                 if field.remote_field:\n737                     if field.remote_field.model:\n738                         related_fields[field.name] = field\n739                     # through will be none on M2Ms on swapped-out models;\n740                     # we can treat lack of through as auto_created=True, though.\n741                     if (getattr(field.remote_field, \"through\", None) and\n742                             not field.remote_field.through._meta.auto_created):\n743                         related_fields[field.name] = field\n744             for field in model._meta.local_many_to_many:\n745                 if field.remote_field.model:\n746                     related_fields[field.name] = field\n747                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n748                     related_fields[field.name] = field\n749             # Generate option removal first\n750             unique_together = model_state.options.pop('unique_together', None)\n751             index_together = model_state.options.pop('index_together', None)\n752             if unique_together:\n753                 self.add_operation(\n754                     app_label,\n755                     operations.AlterUniqueTogether(\n756                         name=model_name,\n757                         unique_together=None,\n758                     )\n759                 )\n760             if index_together:\n761                 self.add_operation(\n762                     app_label,\n763                     operations.AlterIndexTogether(\n764                         name=model_name,\n765                         index_together=None,\n766                     )\n767                 )\n768             # Then remove each related field\n769             for name in sorted(related_fields):\n770                 self.add_operation(\n771                     app_label,\n772                     operations.RemoveField(\n773                         model_name=model_name,\n774                         name=name,\n775                     )\n776                 )\n777             # Finally, remove the model.\n778             # This depends on both the removal/alteration of all incoming fields\n779             # and the removal of all its own related fields, and if it's\n780             # a through model the field that references it.\n781             dependencies = []\n782             for related_object in model._meta.related_objects:\n783                 related_object_app_label = related_object.related_model._meta.app_label\n784                 object_name = related_object.related_model._meta.object_name\n785                 field_name = related_object.field.name\n786                 dependencies.append((related_object_app_label, object_name, field_name, False))\n787                 if not related_object.many_to_many:\n788                     dependencies.append((related_object_app_label, object_name, field_name, \"alter\"))\n789 \n790             for name in sorted(related_fields):\n791                 dependencies.append((app_label, model_name, name, False))\n792             # We're referenced in another field's through=\n793             through_user = self.through_users.get((app_label, model_state.name_lower))\n794             if through_user:\n795                 dependencies.append((through_user[0], through_user[1], through_user[2], False))\n796             # Finally, make the operation, deduping any dependencies\n797             self.add_operation(\n798                 app_label,\n799                 operations.DeleteModel(\n800                     name=model_state.name,\n801                 ),\n802                 dependencies=list(set(dependencies)),\n803             )\n804 \n805     def generate_deleted_proxies(self):\n806         \"\"\"Make DeleteModel options for proxy models.\"\"\"\n807         deleted = self.old_proxy_keys - self.new_proxy_keys\n808         for app_label, model_name in sorted(deleted):\n809             model_state = self.from_state.models[app_label, model_name]\n810             assert model_state.options.get(\"proxy\")\n811             self.add_operation(\n812                 app_label,\n813                 operations.DeleteModel(\n814                     name=model_state.name,\n815                 ),\n816             )\n817 \n818     def generate_renamed_fields(self):\n819         \"\"\"Work out renamed fields.\"\"\"\n820         self.renamed_fields = {}\n821         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n822             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n823             old_model_state = self.from_state.models[app_label, old_model_name]\n824             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n825             # Scan to see if this is actually a rename!\n826             field_dec = self.deep_deconstruct(field)\n827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):\n828                 if rem_app_label == app_label and rem_model_name == model_name:\n829                     old_field = old_model_state.fields[rem_field_name]\n830                     old_field_dec = self.deep_deconstruct(old_field)\n831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:\n832                         old_rel_to = old_field_dec[2]['to']\n833                         if old_rel_to in self.renamed_models_rel:\n834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]\n835                     old_field.set_attributes_from_name(rem_field_name)\n836                     old_db_column = old_field.get_attname_column()[1]\n837                     if (old_field_dec == field_dec or (\n838                             # Was the field renamed and db_column equal to the\n839                             # old field's column added?\n840                             old_field_dec[0:2] == field_dec[0:2] and\n841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):\n842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):\n843                             self.add_operation(\n844                                 app_label,\n845                                 operations.RenameField(\n846                                     model_name=model_name,\n847                                     old_name=rem_field_name,\n848                                     new_name=field_name,\n849                                 )\n850                             )\n851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))\n852                             self.old_field_keys.add((app_label, model_name, field_name))\n853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name\n854                             break\n855 \n856     def generate_added_fields(self):\n857         \"\"\"Make AddField operations.\"\"\"\n858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n859             self._generate_added_field(app_label, model_name, field_name)\n860 \n861     def _generate_added_field(self, app_label, model_name, field_name):\n862         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n863         # Fields that are foreignkeys/m2ms depend on stuff\n864         dependencies = []\n865         if field.remote_field and field.remote_field.model:\n866             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n867         # You can't just add NOT NULL fields with no default or fields\n868         # which don't allow empty strings as default.\n869         time_fields = (models.DateField, models.DateTimeField, models.TimeField)\n870         preserve_default = (\n871             field.null or field.has_default() or field.many_to_many or\n872             (field.blank and field.empty_strings_allowed) or\n873             (isinstance(field, time_fields) and field.auto_now)\n874         )\n875         if not preserve_default:\n876             field = field.clone()\n877             if isinstance(field, time_fields) and field.auto_now_add:\n878                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)\n879             else:\n880                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)\n881         self.add_operation(\n882             app_label,\n883             operations.AddField(\n884                 model_name=model_name,\n885                 name=field_name,\n886                 field=field,\n887                 preserve_default=preserve_default,\n888             ),\n889             dependencies=dependencies,\n890         )\n891 \n892     def generate_removed_fields(self):\n893         \"\"\"Make RemoveField operations.\"\"\"\n894         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):\n895             self._generate_removed_field(app_label, model_name, field_name)\n896 \n897     def _generate_removed_field(self, app_label, model_name, field_name):\n898         self.add_operation(\n899             app_label,\n900             operations.RemoveField(\n901                 model_name=model_name,\n902                 name=field_name,\n903             ),\n904             # We might need to depend on the removal of an\n905             # order_with_respect_to or index/unique_together operation;\n906             # this is safely ignored if there isn't one\n907             dependencies=[\n908                 (app_label, model_name, field_name, \"order_wrt_unset\"),\n909                 (app_label, model_name, field_name, \"foo_together_change\"),\n910             ],\n911         )\n912 \n913     def generate_altered_fields(self):\n914         \"\"\"\n915         Make AlterField operations, or possibly RemovedField/AddField if alter\n916         isn's possible.\n917         \"\"\"\n918         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):\n919             # Did the field change?\n920             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n921             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)\n922             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)\n923             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n924             dependencies = []\n925             # Implement any model renames on relations; these are handled by RenameModel\n926             # so we need to exclude them from the comparison\n927             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"model\", None):\n928                 rename_key = (\n929                     new_field.remote_field.model._meta.app_label,\n930                     new_field.remote_field.model._meta.model_name,\n931                 )\n932                 if rename_key in self.renamed_models:\n933                     new_field.remote_field.model = old_field.remote_field.model\n934                 # Handle ForeignKey which can only have a single to_field.\n935                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)\n936                 if remote_field_name:\n937                     to_field_rename_key = rename_key + (remote_field_name,)\n938                     if to_field_rename_key in self.renamed_fields:\n939                         # Repoint both model and field name because to_field\n940                         # inclusion in ForeignKey.deconstruct() is based on\n941                         # both.\n942                         new_field.remote_field.model = old_field.remote_field.model\n943                         new_field.remote_field.field_name = old_field.remote_field.field_name\n944                 # Handle ForeignObjects which can have multiple from_fields/to_fields.\n945                 from_fields = getattr(new_field, 'from_fields', None)\n946                 if from_fields:\n947                     from_rename_key = (app_label, model_name)\n948                     new_field.from_fields = tuple([\n949                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)\n950                         for from_field in from_fields\n951                     ])\n952                     new_field.to_fields = tuple([\n953                         self.renamed_fields.get(rename_key + (to_field,), to_field)\n954                         for to_field in new_field.to_fields\n955                     ])\n956                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))\n957             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"through\", None):\n958                 rename_key = (\n959                     new_field.remote_field.through._meta.app_label,\n960                     new_field.remote_field.through._meta.model_name,\n961                 )\n962                 if rename_key in self.renamed_models:\n963                     new_field.remote_field.through = old_field.remote_field.through\n964             old_field_dec = self.deep_deconstruct(old_field)\n965             new_field_dec = self.deep_deconstruct(new_field)\n966             if old_field_dec != new_field_dec:\n967                 both_m2m = old_field.many_to_many and new_field.many_to_many\n968                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n969                 if both_m2m or neither_m2m:\n970                     # Either both fields are m2m or neither is\n971                     preserve_default = True\n972                     if (old_field.null and not new_field.null and not new_field.has_default() and\n973                             not new_field.many_to_many):\n974                         field = new_field.clone()\n975                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)\n976                         if new_default is not models.NOT_PROVIDED:\n977                             field.default = new_default\n978                             preserve_default = False\n979                     else:\n980                         field = new_field\n981                     self.add_operation(\n982                         app_label,\n983                         operations.AlterField(\n984                             model_name=model_name,\n985                             name=field_name,\n986                             field=field,\n987                             preserve_default=preserve_default,\n988                         ),\n989                         dependencies=dependencies,\n990                     )\n991                 else:\n992                     # We cannot alter between m2m and concrete fields\n993                     self._generate_removed_field(app_label, model_name, field_name)\n994                     self._generate_added_field(app_label, model_name, field_name)\n995 \n996     def create_altered_indexes(self):\n997         option_name = operations.AddIndex.option_name\n998         for app_label, model_name in sorted(self.kept_model_keys):\n999             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1000             old_model_state = self.from_state.models[app_label, old_model_name]\n1001             new_model_state = self.to_state.models[app_label, model_name]\n1002 \n1003             old_indexes = old_model_state.options[option_name]\n1004             new_indexes = new_model_state.options[option_name]\n1005             add_idx = [idx for idx in new_indexes if idx not in old_indexes]\n1006             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]\n1007 \n1008             self.altered_indexes.update({\n1009                 (app_label, model_name): {\n1010                     'added_indexes': add_idx, 'removed_indexes': rem_idx,\n1011                 }\n1012             })\n1013 \n1014     def generate_added_indexes(self):\n1015         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1016             for index in alt_indexes['added_indexes']:\n1017                 self.add_operation(\n1018                     app_label,\n1019                     operations.AddIndex(\n1020                         model_name=model_name,\n1021                         index=index,\n1022                     )\n1023                 )\n1024 \n1025     def generate_removed_indexes(self):\n1026         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1027             for index in alt_indexes['removed_indexes']:\n1028                 self.add_operation(\n1029                     app_label,\n1030                     operations.RemoveIndex(\n1031                         model_name=model_name,\n1032                         name=index.name,\n1033                     )\n1034                 )\n1035 \n1036     def create_altered_constraints(self):\n1037         option_name = operations.AddConstraint.option_name\n1038         for app_label, model_name in sorted(self.kept_model_keys):\n1039             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1040             old_model_state = self.from_state.models[app_label, old_model_name]\n1041             new_model_state = self.to_state.models[app_label, model_name]\n1042 \n1043             old_constraints = old_model_state.options[option_name]\n1044             new_constraints = new_model_state.options[option_name]\n1045             add_constraints = [c for c in new_constraints if c not in old_constraints]\n1046             rem_constraints = [c for c in old_constraints if c not in new_constraints]\n1047 \n1048             self.altered_constraints.update({\n1049                 (app_label, model_name): {\n1050                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,\n1051                 }\n1052             })\n1053 \n1054     def generate_added_constraints(self):\n1055         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1056             for constraint in alt_constraints['added_constraints']:\n1057                 self.add_operation(\n1058                     app_label,\n1059                     operations.AddConstraint(\n1060                         model_name=model_name,\n1061                         constraint=constraint,\n1062                     )\n1063                 )\n1064 \n1065     def generate_removed_constraints(self):\n1066         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1067             for constraint in alt_constraints['removed_constraints']:\n1068                 self.add_operation(\n1069                     app_label,\n1070                     operations.RemoveConstraint(\n1071                         model_name=model_name,\n1072                         name=constraint.name,\n1073                     )\n1074                 )\n1075 \n1076     def _get_dependencies_for_foreign_key(self, field):\n1077         # Account for FKs to swappable models\n1078         swappable_setting = getattr(field, 'swappable_setting', None)\n1079         if swappable_setting is not None:\n1080             dep_app_label = \"__setting__\"\n1081             dep_object_name = swappable_setting\n1082         else:\n1083             dep_app_label = field.remote_field.model._meta.app_label\n1084             dep_object_name = field.remote_field.model._meta.object_name\n1085         dependencies = [(dep_app_label, dep_object_name, None, True)]\n1086         if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n1087             dependencies.append((\n1088                 field.remote_field.through._meta.app_label,\n1089                 field.remote_field.through._meta.object_name,\n1090                 None,\n1091                 True,\n1092             ))\n1093         return dependencies\n1094 \n1095     def _generate_altered_foo_together(self, operation):\n1096         option_name = operation.option_name\n1097         for app_label, model_name in sorted(self.kept_model_keys):\n1098             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1099             old_model_state = self.from_state.models[app_label, old_model_name]\n1100             new_model_state = self.to_state.models[app_label, model_name]\n1101 \n1102             # We run the old version through the field renames to account for those\n1103             old_value = old_model_state.options.get(option_name)\n1104             old_value = {\n1105                 tuple(\n1106                     self.renamed_fields.get((app_label, model_name, n), n)\n1107                     for n in unique\n1108                 )\n1109                 for unique in old_value\n1110             } if old_value else set()\n1111 \n1112             new_value = new_model_state.options.get(option_name)\n1113             new_value = set(new_value) if new_value else set()\n1114 \n1115             if old_value != new_value:\n1116                 dependencies = []\n1117                 for foo_togethers in new_value:\n1118                     for field_name in foo_togethers:\n1119                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n1120                         if field.remote_field and field.remote_field.model:\n1121                             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n1122 \n1123                 self.add_operation(\n1124                     app_label,\n1125                     operation(\n1126                         name=model_name,\n1127                         **{option_name: new_value}\n1128                     ),\n1129                     dependencies=dependencies,\n1130                 )\n1131 \n1132     def generate_altered_unique_together(self):\n1133         self._generate_altered_foo_together(operations.AlterUniqueTogether)\n1134 \n1135     def generate_altered_index_together(self):\n1136         self._generate_altered_foo_together(operations.AlterIndexTogether)\n1137 \n1138     def generate_altered_db_table(self):\n1139         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)\n1140         for app_label, model_name in sorted(models_to_check):\n1141             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1142             old_model_state = self.from_state.models[app_label, old_model_name]\n1143             new_model_state = self.to_state.models[app_label, model_name]\n1144             old_db_table_name = old_model_state.options.get('db_table')\n1145             new_db_table_name = new_model_state.options.get('db_table')\n1146             if old_db_table_name != new_db_table_name:\n1147                 self.add_operation(\n1148                     app_label,\n1149                     operations.AlterModelTable(\n1150                         name=model_name,\n1151                         table=new_db_table_name,\n1152                     )\n1153                 )\n1154 \n1155     def generate_altered_options(self):\n1156         \"\"\"\n1157         Work out if any non-schema-affecting options have changed and make an\n1158         operation to represent them in state changes (in case Python code in\n1159         migrations needs them).\n1160         \"\"\"\n1161         models_to_check = self.kept_model_keys.union(\n1162             self.kept_proxy_keys,\n1163             self.kept_unmanaged_keys,\n1164             # unmanaged converted to managed\n1165             self.old_unmanaged_keys & self.new_model_keys,\n1166             # managed converted to unmanaged\n1167             self.old_model_keys & self.new_unmanaged_keys,\n1168         )\n1169 \n1170         for app_label, model_name in sorted(models_to_check):\n1171             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1172             old_model_state = self.from_state.models[app_label, old_model_name]\n1173             new_model_state = self.to_state.models[app_label, model_name]\n1174             old_options = {\n1175                 key: value for key, value in old_model_state.options.items()\n1176                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1177             }\n1178             new_options = {\n1179                 key: value for key, value in new_model_state.options.items()\n1180                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1181             }\n1182             if old_options != new_options:\n1183                 self.add_operation(\n1184                     app_label,\n1185                     operations.AlterModelOptions(\n1186                         name=model_name,\n1187                         options=new_options,\n1188                     )\n1189                 )\n1190 \n1191     def generate_altered_order_with_respect_to(self):\n1192         for app_label, model_name in sorted(self.kept_model_keys):\n1193             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1194             old_model_state = self.from_state.models[app_label, old_model_name]\n1195             new_model_state = self.to_state.models[app_label, model_name]\n1196             if (old_model_state.options.get(\"order_with_respect_to\") !=\n1197                     new_model_state.options.get(\"order_with_respect_to\")):\n1198                 # Make sure it comes second if we're adding\n1199                 # (removal dependency is part of RemoveField)\n1200                 dependencies = []\n1201                 if new_model_state.options.get(\"order_with_respect_to\"):\n1202                     dependencies.append((\n1203                         app_label,\n1204                         model_name,\n1205                         new_model_state.options[\"order_with_respect_to\"],\n1206                         True,\n1207                     ))\n1208                 # Actually generate the operation\n1209                 self.add_operation(\n1210                     app_label,\n1211                     operations.AlterOrderWithRespectTo(\n1212                         name=model_name,\n1213                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n1214                     ),\n1215                     dependencies=dependencies,\n1216                 )\n1217 \n1218     def generate_altered_managers(self):\n1219         for app_label, model_name in sorted(self.kept_model_keys):\n1220             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1221             old_model_state = self.from_state.models[app_label, old_model_name]\n1222             new_model_state = self.to_state.models[app_label, model_name]\n1223             if old_model_state.managers != new_model_state.managers:\n1224                 self.add_operation(\n1225                     app_label,\n1226                     operations.AlterModelManagers(\n1227                         name=model_name,\n1228                         managers=new_model_state.managers,\n1229                     )\n1230                 )\n1231 \n1232     def arrange_for_graph(self, changes, graph, migration_name=None):\n1233         \"\"\"\n1234         Take a result from changes() and a MigrationGraph, and fix the names\n1235         and dependencies of the changes so they extend the graph from the leaf\n1236         nodes for each app.\n1237         \"\"\"\n1238         leaves = graph.leaf_nodes()\n1239         name_map = {}\n1240         for app_label, migrations in list(changes.items()):\n1241             if not migrations:\n1242                 continue\n1243             # Find the app label's current leaf node\n1244             app_leaf = None\n1245             for leaf in leaves:\n1246                 if leaf[0] == app_label:\n1247                     app_leaf = leaf\n1248                     break\n1249             # Do they want an initial migration for this app?\n1250             if app_leaf is None and not self.questioner.ask_initial(app_label):\n1251                 # They don't.\n1252                 for migration in migrations:\n1253                     name_map[(app_label, migration.name)] = (app_label, \"__first__\")\n1254                 del changes[app_label]\n1255                 continue\n1256             # Work out the next number in the sequence\n1257             if app_leaf is None:\n1258                 next_number = 1\n1259             else:\n1260                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1\n1261             # Name each migration\n1262             for i, migration in enumerate(migrations):\n1263                 if i == 0 and app_leaf:\n1264                     migration.dependencies.append(app_leaf)\n1265                 new_name_parts = ['%04i' % next_number]\n1266                 if migration_name:\n1267                     new_name_parts.append(migration_name)\n1268                 elif i == 0 and not app_leaf:\n1269                     new_name_parts.append('initial')\n1270                 else:\n1271                     new_name_parts.append(migration.suggest_name()[:100])\n1272                 new_name = '_'.join(new_name_parts)\n1273                 name_map[(app_label, migration.name)] = (app_label, new_name)\n1274                 next_number += 1\n1275                 migration.name = new_name\n1276         # Now fix dependencies\n1277         for migrations in changes.values():\n1278             for migration in migrations:\n1279                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]\n1280         return changes\n1281 \n1282     def _trim_to_apps(self, changes, app_labels):\n1283         \"\"\"\n1284         Take changes from arrange_for_graph() and set of app labels, and return\n1285         a modified set of changes which trims out as many migrations that are\n1286         not in app_labels as possible. Note that some other migrations may\n1287         still be present as they may be required dependencies.\n1288         \"\"\"\n1289         # Gather other app dependencies in a first pass\n1290         app_dependencies = {}\n1291         for app_label, migrations in changes.items():\n1292             for migration in migrations:\n1293                 for dep_app_label, name in migration.dependencies:\n1294                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)\n1295         required_apps = set(app_labels)\n1296         # Keep resolving till there's no change\n1297         old_required_apps = None\n1298         while old_required_apps != required_apps:\n1299             old_required_apps = set(required_apps)\n1300             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])\n1301         # Remove all migrations that aren't needed\n1302         for app_label in list(changes):\n1303             if app_label not in required_apps:\n1304                 del changes[app_label]\n1305         return changes\n1306 \n1307     @classmethod\n1308     def parse_number(cls, name):\n1309         \"\"\"\n1310         Given a migration name, try to extract a number from the beginning of\n1311         it. If no number is found, return None.\n1312         \"\"\"\n1313         match = re.match(r'^\\d+', name)\n1314         if match:\n1315             return int(match[0])\n1316         return None\n",
        "intended_behavior": "Enhance the logic to correctly handle models with the same name across different apps especially when they reference each other through `ManyToManyField`. This includes ensuring that the `related_name` attribute does not cause conflicts during migration generation, even when set to `'+'`, which is supposed to prevent the reverse relation."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/fields/related.py",
        "start": 1,
        "end": 1690,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,\n23     ForwardOneToOneDescriptor, ManyToManyDescriptor,\n24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,\n25 )\n26 from .related_lookups import (\n27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,\n28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,\n29 )\n30 from .reverse_related import (\n31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,\n32 )\n33 \n34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n35 \n36 \n37 def resolve_relation(scope_model, relation):\n38     \"\"\"\n39     Transform relation into a model or fully-qualified model string of the form\n40     \"app_label.ModelName\", relative to scope_model.\n41 \n42     The relation argument can be:\n43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n44         the model argument will be returned.\n45       * A bare model name without an app_label, in which case scope_model's\n46         app_label will be prepended.\n47       * An \"app_label.ModelName\" string.\n48       * A model class, which will be returned unchanged.\n49     \"\"\"\n50     # Check for recursive relations\n51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n52         relation = scope_model\n53 \n54     # Look for an \"app.Model\" relation\n55     if isinstance(relation, str):\n56         if \".\" not in relation:\n57             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n58 \n59     return relation\n60 \n61 \n62 def lazy_related_operation(function, model, *related_models, **kwargs):\n63     \"\"\"\n64     Schedule `function` to be called once `model` and all `related_models`\n65     have been imported and registered with the app registry. `function` will\n66     be called with the newly-loaded model classes as its positional arguments,\n67     plus any optional keyword arguments.\n68 \n69     The `model` argument must be a model class. Each subsequent positional\n70     argument is another model, or a reference to another model - see\n71     `resolve_relation()` for the various forms these may take. Any relative\n72     references will be resolved relative to `model`.\n73 \n74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n75     registry model used is the one found in `model._meta.apps`.\n76     \"\"\"\n77     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n78     model_keys = (make_model_tuple(m) for m in models)\n79     apps = model._meta.apps\n80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n81 \n82 \n83 class RelatedField(FieldCacheMixin, Field):\n84     \"\"\"Base class that all relational fields inherit from.\"\"\"\n85 \n86     # Field flags\n87     one_to_many = False\n88     one_to_one = False\n89     many_to_many = False\n90     many_to_one = False\n91 \n92     @cached_property\n93     def related_model(self):\n94         # Can't cache this property until all the models are loaded.\n95         apps.check_models_ready()\n96         return self.remote_field.model\n97 \n98     def check(self, **kwargs):\n99         return [\n100             *super().check(**kwargs),\n101             *self._check_related_name_is_valid(),\n102             *self._check_related_query_name_is_valid(),\n103             *self._check_relation_model_exists(),\n104             *self._check_referencing_to_swapped_model(),\n105             *self._check_clashes(),\n106         ]\n107 \n108     def _check_related_name_is_valid(self):\n109         import keyword\n110         related_name = self.remote_field.related_name\n111         if related_name is None:\n112             return []\n113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()\n114         if not (is_valid_id or related_name.endswith('+')):\n115             return [\n116                 checks.Error(\n117                     \"The name '%s' is invalid related_name for field %s.%s\" %\n118                     (self.remote_field.related_name, self.model._meta.object_name,\n119                      self.name),\n120                     hint=\"Related name must be a valid Python identifier or end with a '+'\",\n121                     obj=self,\n122                     id='fields.E306',\n123                 )\n124             ]\n125         return []\n126 \n127     def _check_related_query_name_is_valid(self):\n128         if self.remote_field.is_hidden():\n129             return []\n130         rel_query_name = self.related_query_name()\n131         errors = []\n132         if rel_query_name.endswith('_'):\n133             errors.append(\n134                 checks.Error(\n135                     \"Reverse query name '%s' must not end with an underscore.\"\n136                     % rel_query_name,\n137                     hint=(\"Add or change a related_name or related_query_name \"\n138                           \"argument for this field.\"),\n139                     obj=self,\n140                     id='fields.E308',\n141                 )\n142             )\n143         if LOOKUP_SEP in rel_query_name:\n144             errors.append(\n145                 checks.Error(\n146                     \"Reverse query name '%s' must not contain '%s'.\"\n147                     % (rel_query_name, LOOKUP_SEP),\n148                     hint=(\"Add or change a related_name or related_query_name \"\n149                           \"argument for this field.\"),\n150                     obj=self,\n151                     id='fields.E309',\n152                 )\n153             )\n154         return errors\n155 \n156     def _check_relation_model_exists(self):\n157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n158         rel_is_string = isinstance(self.remote_field.model, str)\n159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name\n160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):\n161             return [\n162                 checks.Error(\n163                     \"Field defines a relation with model '%s', which is either \"\n164                     \"not installed, or is abstract.\" % model_name,\n165                     obj=self,\n166                     id='fields.E300',\n167                 )\n168             ]\n169         return []\n170 \n171     def _check_referencing_to_swapped_model(self):\n172         if (self.remote_field.model not in self.opts.apps.get_models() and\n173                 not isinstance(self.remote_field.model, str) and\n174                 self.remote_field.model._meta.swapped):\n175             return [\n176                 checks.Error(\n177                     \"Field defines a relation with the model '%s', which has \"\n178                     \"been swapped out.\" % self.remote_field.model._meta.label,\n179                     hint=\"Update the relation to point at 'settings.%s'.\" % self.remote_field.model._meta.swappable,\n180                     obj=self,\n181                     id='fields.E301',\n182                 )\n183             ]\n184         return []\n185 \n186     def _check_clashes(self):\n187         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n188         from django.db.models.base import ModelBase\n189 \n190         errors = []\n191         opts = self.model._meta\n192 \n193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is\n194         # not resolved.\n195         if not isinstance(self.remote_field.model, ModelBase):\n196             return []\n197 \n198         # Consider that we are checking field `Model.foreign` and the models\n199         # are:\n200         #\n201         #     class Target(models.Model):\n202         #         model = models.IntegerField()\n203         #         model_set = models.IntegerField()\n204         #\n205         #     class Model(models.Model):\n206         #         foreign = models.ForeignKey(Target)\n207         #         m2m = models.ManyToManyField(Target)\n208 \n209         # rel_opts.object_name == \"Target\"\n210         rel_opts = self.remote_field.model._meta\n211         # If the field doesn't install a backward relation on the target model\n212         # (so `is_hidden` returns True), then there are no clashes to check\n213         # and we can skip these fields.\n214         rel_is_hidden = self.remote_field.is_hidden()\n215         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n216         rel_query_name = self.related_query_name()  # i. e. \"model\"\n217         # i.e. \"app_label.Model.field\".\n218         field_name = '%s.%s' % (opts.label, self.name)\n219 \n220         # Check clashes between accessor or reverse query name of `field`\n221         # and any other field name -- i.e. accessor for Model.foreign is\n222         # model_set and it clashes with Target.model_set.\n223         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n224         for clash_field in potential_clashes:\n225             # i.e. \"app_label.Target.model_set\".\n226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)\n227             if not rel_is_hidden and clash_field.name == rel_name:\n228                 errors.append(\n229                     checks.Error(\n230                         \"Reverse accessor for '%s' clashes with field name '%s'.\" % (field_name, clash_name),\n231                         hint=(\"Rename field '%s', or add/change a related_name \"\n232                               \"argument to the definition for field '%s'.\") % (clash_name, field_name),\n233                         obj=self,\n234                         id='fields.E302',\n235                     )\n236                 )\n237 \n238             if clash_field.name == rel_query_name:\n239                 errors.append(\n240                     checks.Error(\n241                         \"Reverse query name for '%s' clashes with field name '%s'.\" % (field_name, clash_name),\n242                         hint=(\"Rename field '%s', or add/change a related_name \"\n243                               \"argument to the definition for field '%s'.\") % (clash_name, field_name),\n244                         obj=self,\n245                         id='fields.E303',\n246                     )\n247                 )\n248 \n249         # Check clashes between accessors/reverse query names of `field` and\n250         # any other field accessor -- i. e. Model.foreign accessor clashes with\n251         # Model.m2m accessor.\n252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n253         for clash_field in potential_clashes:\n254             # i.e. \"app_label.Model.m2m\".\n255             clash_name = '%s.%s' % (\n256                 clash_field.related_model._meta.label,\n257                 clash_field.field.name,\n258             )\n259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n260                 errors.append(\n261                     checks.Error(\n262                         \"Reverse accessor for '%s' clashes with reverse accessor for '%s'.\" % (field_name, clash_name),\n263                         hint=(\"Add or change a related_name argument \"\n264                               \"to the definition for '%s' or '%s'.\") % (field_name, clash_name),\n265                         obj=self,\n266                         id='fields.E304',\n267                     )\n268                 )\n269 \n270             if clash_field.get_accessor_name() == rel_query_name:\n271                 errors.append(\n272                     checks.Error(\n273                         \"Reverse query name for '%s' clashes with reverse query name for '%s'.\"\n274                         % (field_name, clash_name),\n275                         hint=(\"Add or change a related_name argument \"\n276                               \"to the definition for '%s' or '%s'.\") % (field_name, clash_name),\n277                         obj=self,\n278                         id='fields.E305',\n279                     )\n280                 )\n281 \n282         return errors\n283 \n284     def db_type(self, connection):\n285         # By default related field will not have a column as it relates to\n286         # columns from another table.\n287         return None\n288 \n289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n290 \n291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n292 \n293         self.opts = cls._meta\n294 \n295         if not cls._meta.abstract:\n296             if self.remote_field.related_name:\n297                 related_name = self.remote_field.related_name\n298             else:\n299                 related_name = self.opts.default_related_name\n300             if related_name:\n301                 related_name = related_name % {\n302                     'class': cls.__name__.lower(),\n303                     'model_name': cls._meta.model_name.lower(),\n304                     'app_label': cls._meta.app_label.lower()\n305                 }\n306                 self.remote_field.related_name = related_name\n307 \n308             if self.remote_field.related_query_name:\n309                 related_query_name = self.remote_field.related_query_name % {\n310                     'class': cls.__name__.lower(),\n311                     'app_label': cls._meta.app_label.lower(),\n312                 }\n313                 self.remote_field.related_query_name = related_query_name\n314 \n315             def resolve_related_class(model, related, field):\n316                 field.remote_field.model = related\n317                 field.do_related_class(related, model)\n318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)\n319 \n320     def deconstruct(self):\n321         name, path, args, kwargs = super().deconstruct()\n322         if self.remote_field.limit_choices_to:\n323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to\n324         if self.remote_field.related_name is not None:\n325             kwargs['related_name'] = self.remote_field.related_name\n326         if self.remote_field.related_query_name is not None:\n327             kwargs['related_query_name'] = self.remote_field.related_query_name\n328         return name, path, args, kwargs\n329 \n330     def get_forward_related_filter(self, obj):\n331         \"\"\"\n332         Return the keyword arguments that when supplied to\n333         self.model.object.filter(), would select all instances related through\n334         this field to the remote obj. This is used to build the querysets\n335         returned by related descriptors. obj is an instance of\n336         self.related_field.model.\n337         \"\"\"\n338         return {\n339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n340             for _, rh_field in self.related_fields\n341         }\n342 \n343     def get_reverse_related_filter(self, obj):\n344         \"\"\"\n345         Complement to get_forward_related_filter(). Return the keyword\n346         arguments that when passed to self.related_field.model.object.filter()\n347         select all instances of self.related_field.model related through\n348         this field to obj. obj is an instance of self.model.\n349         \"\"\"\n350         base_filter = {\n351             rh_field.attname: getattr(obj, lh_field.attname)\n352             for lh_field, rh_field in self.related_fields\n353         }\n354         descriptor_filter = self.get_extra_descriptor_filter(obj)\n355         base_q = Q(**base_filter)\n356         if isinstance(descriptor_filter, dict):\n357             return base_q & Q(**descriptor_filter)\n358         elif descriptor_filter:\n359             return base_q & descriptor_filter\n360         return base_q\n361 \n362     @property\n363     def swappable_setting(self):\n364         \"\"\"\n365         Get the setting that this is powered from for swapping, or None\n366         if it's not swapped in / marked with swappable=False.\n367         \"\"\"\n368         if self.swappable:\n369             # Work out string form of \"to\"\n370             if isinstance(self.remote_field.model, str):\n371                 to_string = self.remote_field.model\n372             else:\n373                 to_string = self.remote_field.model._meta.label\n374             return apps.get_swappable_settings_name(to_string)\n375         return None\n376 \n377     def set_attributes_from_rel(self):\n378         self.name = (\n379             self.name or\n380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)\n381         )\n382         if self.verbose_name is None:\n383             self.verbose_name = self.remote_field.model._meta.verbose_name\n384         self.remote_field.set_field_name()\n385 \n386     def do_related_class(self, other, cls):\n387         self.set_attributes_from_rel()\n388         self.contribute_to_related_class(other, self.remote_field)\n389 \n390     def get_limit_choices_to(self):\n391         \"\"\"\n392         Return ``limit_choices_to`` for this model field.\n393 \n394         If it is a callable, it will be invoked and the result will be\n395         returned.\n396         \"\"\"\n397         if callable(self.remote_field.limit_choices_to):\n398             return self.remote_field.limit_choices_to()\n399         return self.remote_field.limit_choices_to\n400 \n401     def formfield(self, **kwargs):\n402         \"\"\"\n403         Pass ``limit_choices_to`` to the field being constructed.\n404 \n405         Only passes it if there is a type that supports related fields.\n406         This is a similar strategy used to pass the ``queryset`` to the field\n407         being constructed.\n408         \"\"\"\n409         defaults = {}\n410         if hasattr(self.remote_field, 'get_related_field'):\n411             # If this is a callable, do not invoke it here. Just pass\n412             # it in the defaults for when the form class will later be\n413             # instantiated.\n414             limit_choices_to = self.remote_field.limit_choices_to\n415             defaults.update({\n416                 'limit_choices_to': limit_choices_to,\n417             })\n418         defaults.update(kwargs)\n419         return super().formfield(**defaults)\n420 \n421     def related_query_name(self):\n422         \"\"\"\n423         Define the name that can be used to identify this related object in a\n424         table-spanning query.\n425         \"\"\"\n426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name\n427 \n428     @property\n429     def target_field(self):\n430         \"\"\"\n431         When filtering against this relation, return the field on the remote\n432         model against which the filtering should happen.\n433         \"\"\"\n434         target_fields = self.get_path_info()[-1].target_fields\n435         if len(target_fields) > 1:\n436             raise exceptions.FieldError(\n437                 \"The relation has multiple target fields, but only single target field was asked for\")\n438         return target_fields[0]\n439 \n440     def get_cache_name(self):\n441         return self.name\n442 \n443 \n444 class ForeignObject(RelatedField):\n445     \"\"\"\n446     Abstraction of the ForeignKey relation to support multi-column relations.\n447     \"\"\"\n448 \n449     # Field flags\n450     many_to_many = False\n451     many_to_one = True\n452     one_to_many = False\n453     one_to_one = False\n454 \n455     requires_unique_target = True\n456     related_accessor_class = ReverseManyToOneDescriptor\n457     forward_related_accessor_class = ForwardManyToOneDescriptor\n458     rel_class = ForeignObjectRel\n459 \n460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,\n461                  related_query_name=None, limit_choices_to=None, parent_link=False,\n462                  swappable=True, **kwargs):\n463 \n464         if rel is None:\n465             rel = self.rel_class(\n466                 self, to,\n467                 related_name=related_name,\n468                 related_query_name=related_query_name,\n469                 limit_choices_to=limit_choices_to,\n470                 parent_link=parent_link,\n471                 on_delete=on_delete,\n472             )\n473 \n474         super().__init__(rel=rel, **kwargs)\n475 \n476         self.from_fields = from_fields\n477         self.to_fields = to_fields\n478         self.swappable = swappable\n479 \n480     def check(self, **kwargs):\n481         return [\n482             *super().check(**kwargs),\n483             *self._check_to_fields_exist(),\n484             *self._check_unique_target(),\n485         ]\n486 \n487     def _check_to_fields_exist(self):\n488         # Skip nonexistent models.\n489         if isinstance(self.remote_field.model, str):\n490             return []\n491 \n492         errors = []\n493         for to_field in self.to_fields:\n494             if to_field:\n495                 try:\n496                     self.remote_field.model._meta.get_field(to_field)\n497                 except exceptions.FieldDoesNotExist:\n498                     errors.append(\n499                         checks.Error(\n500                             \"The to_field '%s' doesn't exist on the related \"\n501                             \"model '%s'.\"\n502                             % (to_field, self.remote_field.model._meta.label),\n503                             obj=self,\n504                             id='fields.E312',\n505                         )\n506                     )\n507         return errors\n508 \n509     def _check_unique_target(self):\n510         rel_is_string = isinstance(self.remote_field.model, str)\n511         if rel_is_string or not self.requires_unique_target:\n512             return []\n513 \n514         try:\n515             self.foreign_related_fields\n516         except exceptions.FieldDoesNotExist:\n517             return []\n518 \n519         if not self.foreign_related_fields:\n520             return []\n521 \n522         unique_foreign_fields = {\n523             frozenset([f.name])\n524             for f in self.remote_field.model._meta.get_fields()\n525             if getattr(f, 'unique', False)\n526         }\n527         unique_foreign_fields.update({\n528             frozenset(ut)\n529             for ut in self.remote_field.model._meta.unique_together\n530         })\n531         unique_foreign_fields.update({\n532             frozenset(uc.fields)\n533             for uc in self.remote_field.model._meta.total_unique_constraints\n534         })\n535         foreign_fields = {f.name for f in self.foreign_related_fields}\n536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n537 \n538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n539             field_combination = ', '.join(\n540                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n541             )\n542             model_name = self.remote_field.model.__name__\n543             return [\n544                 checks.Error(\n545                     \"No subset of the fields %s on model '%s' is unique.\"\n546                     % (field_combination, model_name),\n547                     hint=(\n548                         'Mark a single field as unique=True or add a set of '\n549                         'fields to a unique constraint (via unique_together '\n550                         'or a UniqueConstraint (without condition) in the '\n551                         'model Meta.constraints).'\n552                     ),\n553                     obj=self,\n554                     id='fields.E310',\n555                 )\n556             ]\n557         elif not has_unique_constraint:\n558             field_name = self.foreign_related_fields[0].name\n559             model_name = self.remote_field.model.__name__\n560             return [\n561                 checks.Error(\n562                     \"'%s.%s' must be unique because it is referenced by \"\n563                     \"a foreign key.\" % (model_name, field_name),\n564                     hint=(\n565                         'Add unique=True to this field or add a '\n566                         'UniqueConstraint (without condition) in the model '\n567                         'Meta.constraints.'\n568                     ),\n569                     obj=self,\n570                     id='fields.E311',\n571                 )\n572             ]\n573         else:\n574             return []\n575 \n576     def deconstruct(self):\n577         name, path, args, kwargs = super().deconstruct()\n578         kwargs['on_delete'] = self.remote_field.on_delete\n579         kwargs['from_fields'] = self.from_fields\n580         kwargs['to_fields'] = self.to_fields\n581 \n582         if self.remote_field.parent_link:\n583             kwargs['parent_link'] = self.remote_field.parent_link\n584         if isinstance(self.remote_field.model, str):\n585             if '.' in self.remote_field.model:\n586                 app_label, model_name = self.remote_field.model.split('.')\n587                 kwargs['to'] = '%s.%s' % (app_label, model_name.lower())\n588             else:\n589                 kwargs['to'] = self.remote_field.model.lower()\n590         else:\n591             kwargs['to'] = self.remote_field.model._meta.label_lower\n592         # If swappable is True, then see if we're actually pointing to the target\n593         # of a swap.\n594         swappable_setting = self.swappable_setting\n595         if swappable_setting is not None:\n596             # If it's already a settings reference, error\n597             if hasattr(kwargs['to'], \"setting_name\"):\n598                 if kwargs['to'].setting_name != swappable_setting:\n599                     raise ValueError(\n600                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n601                         \"that is swapped in place of more than one model (%s and %s)\"\n602                         % (kwargs['to'].setting_name, swappable_setting)\n603                     )\n604             # Set it\n605             kwargs['to'] = SettingsReference(\n606                 kwargs['to'],\n607                 swappable_setting,\n608             )\n609         return name, path, args, kwargs\n610 \n611     def resolve_related_fields(self):\n612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')\n614         if isinstance(self.remote_field.model, str):\n615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)\n616         related_fields = []\n617         for index in range(len(self.from_fields)):\n618             from_field_name = self.from_fields[index]\n619             to_field_name = self.to_fields[index]\n620             from_field = (\n621                 self\n622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n623                 else self.opts.get_field(from_field_name)\n624             )\n625             to_field = (self.remote_field.model._meta.pk if to_field_name is None\n626                         else self.remote_field.model._meta.get_field(to_field_name))\n627             related_fields.append((from_field, to_field))\n628         return related_fields\n629 \n630     @cached_property\n631     def related_fields(self):\n632         return self.resolve_related_fields()\n633 \n634     @cached_property\n635     def reverse_related_fields(self):\n636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n637 \n638     @cached_property\n639     def local_related_fields(self):\n640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n641 \n642     @cached_property\n643     def foreign_related_fields(self):\n644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n645 \n646     def get_local_related_value(self, instance):\n647         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n648 \n649     def get_foreign_related_value(self, instance):\n650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n651 \n652     @staticmethod\n653     def get_instance_value_for_fields(instance, fields):\n654         ret = []\n655         opts = instance._meta\n656         for field in fields:\n657             # Gotcha: in some cases (like fixture loading) a model can have\n658             # different values in parent_ptr_id and parent's id. So, use\n659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n660             if field.primary_key:\n661                 possible_parent_link = opts.get_ancestor_link(field.model)\n662                 if (not possible_parent_link or\n663                         possible_parent_link.primary_key or\n664                         possible_parent_link.model._meta.abstract):\n665                     ret.append(instance.pk)\n666                     continue\n667             ret.append(getattr(instance, field.attname))\n668         return tuple(ret)\n669 \n670     def get_attname_column(self):\n671         attname, column = super().get_attname_column()\n672         return attname, None\n673 \n674     def get_joining_columns(self, reverse_join=False):\n675         source = self.reverse_related_fields if reverse_join else self.related_fields\n676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)\n677 \n678     def get_reverse_joining_columns(self):\n679         return self.get_joining_columns(reverse_join=True)\n680 \n681     def get_extra_descriptor_filter(self, instance):\n682         \"\"\"\n683         Return an extra filter condition for related object fetching when\n684         user does 'instance.fieldname', that is the extra filter is used in\n685         the descriptor of the field.\n686 \n687         The filter should be either a dict usable in .filter(**kwargs) call or\n688         a Q-object. The condition will be ANDed together with the relation's\n689         joining columns.\n690 \n691         A parallel method is get_extra_restriction() which is used in\n692         JOIN and subquery conditions.\n693         \"\"\"\n694         return {}\n695 \n696     def get_extra_restriction(self, where_class, alias, related_alias):\n697         \"\"\"\n698         Return a pair condition used for joining and subquery pushdown. The\n699         condition is something that responds to as_sql(compiler, connection)\n700         method.\n701 \n702         Note that currently referring both the 'alias' and 'related_alias'\n703         will not work in some conditions, like subquery pushdown.\n704 \n705         A parallel method is get_extra_descriptor_filter() which is used in\n706         instance.fieldname related object fetching.\n707         \"\"\"\n708         return None\n709 \n710     def get_path_info(self, filtered_relation=None):\n711         \"\"\"Get path from this field to the related model.\"\"\"\n712         opts = self.remote_field.model._meta\n713         from_opts = self.model._meta\n714         return [PathInfo(\n715             from_opts=from_opts,\n716             to_opts=opts,\n717             target_fields=self.foreign_related_fields,\n718             join_field=self,\n719             m2m=False,\n720             direct=True,\n721             filtered_relation=filtered_relation,\n722         )]\n723 \n724     def get_reverse_path_info(self, filtered_relation=None):\n725         \"\"\"Get path from the related model to this field's model.\"\"\"\n726         opts = self.model._meta\n727         from_opts = self.remote_field.model._meta\n728         return [PathInfo(\n729             from_opts=from_opts,\n730             to_opts=opts,\n731             target_fields=(opts.pk,),\n732             join_field=self.remote_field,\n733             m2m=not self.unique,\n734             direct=False,\n735             filtered_relation=filtered_relation,\n736         )]\n737 \n738     @classmethod\n739     @functools.lru_cache(maxsize=None)\n740     def get_lookups(cls):\n741         bases = inspect.getmro(cls)\n742         bases = bases[:bases.index(ForeignObject) + 1]\n743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]\n744         return cls.merge_dicts(class_lookups)\n745 \n746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n748         setattr(cls, self.name, self.forward_related_accessor_class(self))\n749 \n750     def contribute_to_related_class(self, cls, related):\n751         # Internal FK's - i.e., those with a related name ending with '+' -\n752         # and swapped models don't get a related descriptor.\n753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))\n755             # While 'limit_choices_to' might be a callable, simply pass\n756             # it along for later - this is too early because it's still\n757             # model load time.\n758             if self.remote_field.limit_choices_to:\n759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)\n760 \n761 \n762 ForeignObject.register_lookup(RelatedIn)\n763 ForeignObject.register_lookup(RelatedExact)\n764 ForeignObject.register_lookup(RelatedLessThan)\n765 ForeignObject.register_lookup(RelatedGreaterThan)\n766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n767 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n768 ForeignObject.register_lookup(RelatedIsNull)\n769 \n770 \n771 class ForeignKey(ForeignObject):\n772     \"\"\"\n773     Provide a many-to-one relation by adding a column to the local model\n774     to hold the remote value.\n775 \n776     By default ForeignKey will target the pk of the remote model but this\n777     behavior can be changed by using the ``to_field`` argument.\n778     \"\"\"\n779     descriptor_class = ForeignKeyDeferredAttribute\n780     # Field flags\n781     many_to_many = False\n782     many_to_one = True\n783     one_to_many = False\n784     one_to_one = False\n785 \n786     rel_class = ManyToOneRel\n787 \n788     empty_strings_allowed = False\n789     default_error_messages = {\n790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n791     }\n792     description = _(\"Foreign Key (type determined by related field)\")\n793 \n794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,\n795                  limit_choices_to=None, parent_link=False, to_field=None,\n796                  db_constraint=True, **kwargs):\n797         try:\n798             to._meta.model_name\n799         except AttributeError:\n800             assert isinstance(to, str), (\n801                 \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n802                 \"either a model, a model name, or the string %r\" % (\n803                     self.__class__.__name__, to,\n804                     RECURSIVE_RELATIONSHIP_CONSTANT,\n805                 )\n806             )\n807         else:\n808             # For backwards compatibility purposes, we need to *try* and set\n809             # the to_field during FK construction. It won't be guaranteed to\n810             # be correct until contribute_to_class is called. Refs #12190.\n811             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n812         if not callable(on_delete):\n813             raise TypeError('on_delete must be callable.')\n814 \n815         kwargs['rel'] = self.rel_class(\n816             self, to, to_field,\n817             related_name=related_name,\n818             related_query_name=related_query_name,\n819             limit_choices_to=limit_choices_to,\n820             parent_link=parent_link,\n821             on_delete=on_delete,\n822         )\n823         kwargs.setdefault('db_index', True)\n824 \n825         super().__init__(\n826             to,\n827             on_delete,\n828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n829             to_fields=[to_field],\n830             **kwargs,\n831         )\n832         self.db_constraint = db_constraint\n833 \n834     def check(self, **kwargs):\n835         return [\n836             *super().check(**kwargs),\n837             *self._check_on_delete(),\n838             *self._check_unique(),\n839         ]\n840 \n841     def _check_on_delete(self):\n842         on_delete = getattr(self.remote_field, 'on_delete', None)\n843         if on_delete == SET_NULL and not self.null:\n844             return [\n845                 checks.Error(\n846                     'Field specifies on_delete=SET_NULL, but cannot be null.',\n847                     hint='Set null=True argument on the field, or change the on_delete rule.',\n848                     obj=self,\n849                     id='fields.E320',\n850                 )\n851             ]\n852         elif on_delete == SET_DEFAULT and not self.has_default():\n853             return [\n854                 checks.Error(\n855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',\n856                     hint='Set a default value, or change the on_delete rule.',\n857                     obj=self,\n858                     id='fields.E321',\n859                 )\n860             ]\n861         else:\n862             return []\n863 \n864     def _check_unique(self, **kwargs):\n865         return [\n866             checks.Warning(\n867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',\n868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',\n869                 obj=self,\n870                 id='fields.W342',\n871             )\n872         ] if self.unique else []\n873 \n874     def deconstruct(self):\n875         name, path, args, kwargs = super().deconstruct()\n876         del kwargs['to_fields']\n877         del kwargs['from_fields']\n878         # Handle the simpler arguments\n879         if self.db_index:\n880             del kwargs['db_index']\n881         else:\n882             kwargs['db_index'] = False\n883         if self.db_constraint is not True:\n884             kwargs['db_constraint'] = self.db_constraint\n885         # Rel needs more work.\n886         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n887         if self.remote_field.field_name and (\n888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):\n889             kwargs['to_field'] = self.remote_field.field_name\n890         return name, path, args, kwargs\n891 \n892     def to_python(self, value):\n893         return self.target_field.to_python(value)\n894 \n895     @property\n896     def target_field(self):\n897         return self.foreign_related_fields[0]\n898 \n899     def get_reverse_path_info(self, filtered_relation=None):\n900         \"\"\"Get path from the related model to this field's model.\"\"\"\n901         opts = self.model._meta\n902         from_opts = self.remote_field.model._meta\n903         return [PathInfo(\n904             from_opts=from_opts,\n905             to_opts=opts,\n906             target_fields=(opts.pk,),\n907             join_field=self.remote_field,\n908             m2m=not self.unique,\n909             direct=False,\n910             filtered_relation=filtered_relation,\n911         )]\n912 \n913     def validate(self, value, model_instance):\n914         if self.remote_field.parent_link:\n915             return\n916         super().validate(value, model_instance)\n917         if value is None:\n918             return\n919 \n920         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n921         qs = self.remote_field.model._base_manager.using(using).filter(\n922             **{self.remote_field.field_name: value}\n923         )\n924         qs = qs.complex_filter(self.get_limit_choices_to())\n925         if not qs.exists():\n926             raise exceptions.ValidationError(\n927                 self.error_messages['invalid'],\n928                 code='invalid',\n929                 params={\n930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,\n931                     'field': self.remote_field.field_name, 'value': value,\n932                 },  # 'pk' is included for backwards compatibility\n933             )\n934 \n935     def resolve_related_fields(self):\n936         related_fields = super().resolve_related_fields()\n937         for from_field, to_field in related_fields:\n938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:\n939                 raise exceptions.FieldError(\n940                     \"'%s.%s' refers to field '%s' which is not local to model \"\n941                     \"'%s'.\" % (\n942                         self.model._meta.label,\n943                         self.name,\n944                         to_field.name,\n945                         self.remote_field.model._meta.concrete_model._meta.label,\n946                     )\n947                 )\n948         return related_fields\n949 \n950     def get_attname(self):\n951         return '%s_id' % self.name\n952 \n953     def get_attname_column(self):\n954         attname = self.get_attname()\n955         column = self.db_column or attname\n956         return attname, column\n957 \n958     def get_default(self):\n959         \"\"\"Return the to_field if the default value is an object.\"\"\"\n960         field_default = super().get_default()\n961         if isinstance(field_default, self.remote_field.model):\n962             return getattr(field_default, self.target_field.attname)\n963         return field_default\n964 \n965     def get_db_prep_save(self, value, connection):\n966         if value is None or (value == '' and\n967                              (not self.target_field.empty_strings_allowed or\n968                               connection.features.interprets_empty_strings_as_nulls)):\n969             return None\n970         else:\n971             return self.target_field.get_db_prep_save(value, connection=connection)\n972 \n973     def get_db_prep_value(self, value, connection, prepared=False):\n974         return self.target_field.get_db_prep_value(value, connection, prepared)\n975 \n976     def get_prep_value(self, value):\n977         return self.target_field.get_prep_value(value)\n978 \n979     def contribute_to_related_class(self, cls, related):\n980         super().contribute_to_related_class(cls, related)\n981         if self.remote_field.field_name is None:\n982             self.remote_field.field_name = cls._meta.pk.name\n983 \n984     def formfield(self, *, using=None, **kwargs):\n985         if isinstance(self.remote_field.model, str):\n986             raise ValueError(\"Cannot create form field for %r yet, because \"\n987                              \"its related model %r has not been loaded yet\" %\n988                              (self.name, self.remote_field.model))\n989         return super().formfield(**{\n990             'form_class': forms.ModelChoiceField,\n991             'queryset': self.remote_field.model._default_manager.using(using),\n992             'to_field_name': self.remote_field.field_name,\n993             **kwargs,\n994             'blank': self.blank,\n995         })\n996 \n997     def db_check(self, connection):\n998         return []\n999 \n1000     def db_type(self, connection):\n1001         return self.target_field.rel_db_type(connection=connection)\n1002 \n1003     def db_parameters(self, connection):\n1004         return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}\n1005 \n1006     def convert_empty_strings(self, value, expression, connection):\n1007         if (not value) and isinstance(value, str):\n1008             return None\n1009         return value\n1010 \n1011     def get_db_converters(self, connection):\n1012         converters = super().get_db_converters(connection)\n1013         if connection.features.interprets_empty_strings_as_nulls:\n1014             converters += [self.convert_empty_strings]\n1015         return converters\n1016 \n1017     def get_col(self, alias, output_field=None):\n1018         if output_field is None:\n1019             output_field = self.target_field\n1020             while isinstance(output_field, ForeignKey):\n1021                 output_field = output_field.target_field\n1022                 if output_field is self:\n1023                     raise ValueError('Cannot resolve output_field.')\n1024         return super().get_col(alias, output_field)\n1025 \n1026 \n1027 class OneToOneField(ForeignKey):\n1028     \"\"\"\n1029     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1030     that it always carries a \"unique\" constraint with it and the reverse\n1031     relation always returns the object pointed to (since there will only ever\n1032     be one), rather than returning a list.\n1033     \"\"\"\n1034 \n1035     # Field flags\n1036     many_to_many = False\n1037     many_to_one = False\n1038     one_to_many = False\n1039     one_to_one = True\n1040 \n1041     related_accessor_class = ReverseOneToOneDescriptor\n1042     forward_related_accessor_class = ForwardOneToOneDescriptor\n1043     rel_class = OneToOneRel\n1044 \n1045     description = _(\"One-to-one relationship\")\n1046 \n1047     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1048         kwargs['unique'] = True\n1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1050 \n1051     def deconstruct(self):\n1052         name, path, args, kwargs = super().deconstruct()\n1053         if \"unique\" in kwargs:\n1054             del kwargs['unique']\n1055         return name, path, args, kwargs\n1056 \n1057     def formfield(self, **kwargs):\n1058         if self.remote_field.parent_link:\n1059             return None\n1060         return super().formfield(**kwargs)\n1061 \n1062     def save_form_data(self, instance, data):\n1063         if isinstance(data, self.remote_field.model):\n1064             setattr(instance, self.name, data)\n1065         else:\n1066             setattr(instance, self.attname, data)\n1067             # Remote field object must be cleared otherwise Model.save()\n1068             # will reassign attname using the related object pk.\n1069             if data is None:\n1070                 setattr(instance, self.name, data)\n1071 \n1072     def _check_unique(self, **kwargs):\n1073         # Override ForeignKey since check isn't applicable here.\n1074         return []\n1075 \n1076 \n1077 def create_many_to_many_intermediary_model(field, klass):\n1078     from django.db import models\n1079 \n1080     def set_managed(model, related, through):\n1081         through._meta.managed = model._meta.managed or related._meta.managed\n1082 \n1083     to_model = resolve_relation(klass, field.remote_field.model)\n1084     name = '%s_%s' % (klass._meta.object_name, field.name)\n1085     lazy_related_operation(set_managed, klass, to_model, name)\n1086 \n1087     to = make_model_tuple(to_model)[1]\n1088     from_ = klass._meta.model_name\n1089     if to == from_:\n1090         to = 'to_%s' % to\n1091         from_ = 'from_%s' % from_\n1092 \n1093     meta = type('Meta', (), {\n1094         'db_table': field._get_m2m_db_table(klass._meta),\n1095         'auto_created': klass,\n1096         'app_label': klass._meta.app_label,\n1097         'db_tablespace': klass._meta.db_tablespace,\n1098         'unique_together': (from_, to),\n1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},\n1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},\n1101         'apps': field.model._meta.apps,\n1102     })\n1103     # Construct and return the new class.\n1104     return type(name, (models.Model,), {\n1105         'Meta': meta,\n1106         '__module__': klass.__module__,\n1107         from_: models.ForeignKey(\n1108             klass,\n1109             related_name='%s+' % name,\n1110             db_tablespace=field.db_tablespace,\n1111             db_constraint=field.remote_field.db_constraint,\n1112             on_delete=CASCADE,\n1113         ),\n1114         to: models.ForeignKey(\n1115             to_model,\n1116             related_name='%s+' % name,\n1117             db_tablespace=field.db_tablespace,\n1118             db_constraint=field.remote_field.db_constraint,\n1119             on_delete=CASCADE,\n1120         )\n1121     })\n1122 \n1123 \n1124 class ManyToManyField(RelatedField):\n1125     \"\"\"\n1126     Provide a many-to-many relation by using an intermediary model that\n1127     holds two ForeignKey fields pointed at the two sides of the relation.\n1128 \n1129     Unless a ``through`` model was provided, ManyToManyField will use the\n1130     create_many_to_many_intermediary_model factory to automatically generate\n1131     the intermediary model.\n1132     \"\"\"\n1133 \n1134     # Field flags\n1135     many_to_many = True\n1136     many_to_one = False\n1137     one_to_many = False\n1138     one_to_one = False\n1139 \n1140     rel_class = ManyToManyRel\n1141 \n1142     description = _(\"Many-to-many relationship\")\n1143 \n1144     def __init__(self, to, related_name=None, related_query_name=None,\n1145                  limit_choices_to=None, symmetrical=None, through=None,\n1146                  through_fields=None, db_constraint=True, db_table=None,\n1147                  swappable=True, **kwargs):\n1148         try:\n1149             to._meta\n1150         except AttributeError:\n1151             assert isinstance(to, str), (\n1152                 \"%s(%r) is invalid. First parameter to ManyToManyField must be \"\n1153                 \"either a model, a model name, or the string %r\" %\n1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)\n1155             )\n1156 \n1157         if symmetrical is None:\n1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n1159 \n1160         if through is not None:\n1161             assert db_table is None, (\n1162                 \"Cannot specify a db_table if an intermediary model is used.\"\n1163             )\n1164 \n1165         kwargs['rel'] = self.rel_class(\n1166             self, to,\n1167             related_name=related_name,\n1168             related_query_name=related_query_name,\n1169             limit_choices_to=limit_choices_to,\n1170             symmetrical=symmetrical,\n1171             through=through,\n1172             through_fields=through_fields,\n1173             db_constraint=db_constraint,\n1174         )\n1175         self.has_null_arg = 'null' in kwargs\n1176 \n1177         super().__init__(**kwargs)\n1178 \n1179         self.db_table = db_table\n1180         self.swappable = swappable\n1181 \n1182     def check(self, **kwargs):\n1183         return [\n1184             *super().check(**kwargs),\n1185             *self._check_unique(**kwargs),\n1186             *self._check_relationship_model(**kwargs),\n1187             *self._check_ignored_options(**kwargs),\n1188             *self._check_table_uniqueness(**kwargs),\n1189         ]\n1190 \n1191     def _check_unique(self, **kwargs):\n1192         if self.unique:\n1193             return [\n1194                 checks.Error(\n1195                     'ManyToManyFields cannot be unique.',\n1196                     obj=self,\n1197                     id='fields.E330',\n1198                 )\n1199             ]\n1200         return []\n1201 \n1202     def _check_ignored_options(self, **kwargs):\n1203         warnings = []\n1204 \n1205         if self.has_null_arg:\n1206             warnings.append(\n1207                 checks.Warning(\n1208                     'null has no effect on ManyToManyField.',\n1209                     obj=self,\n1210                     id='fields.W340',\n1211                 )\n1212             )\n1213 \n1214         if self._validators:\n1215             warnings.append(\n1216                 checks.Warning(\n1217                     'ManyToManyField does not support validators.',\n1218                     obj=self,\n1219                     id='fields.W341',\n1220                 )\n1221             )\n1222         if (self.remote_field.limit_choices_to and self.remote_field.through and\n1223                 not self.remote_field.through._meta.auto_created):\n1224             warnings.append(\n1225                 checks.Warning(\n1226                     'limit_choices_to has no effect on ManyToManyField '\n1227                     'with a through model.',\n1228                     obj=self,\n1229                     id='fields.W343',\n1230                 )\n1231             )\n1232 \n1233         return warnings\n1234 \n1235     def _check_relationship_model(self, from_model=None, **kwargs):\n1236         if hasattr(self.remote_field.through, '_meta'):\n1237             qualified_model_name = \"%s.%s\" % (\n1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n1239         else:\n1240             qualified_model_name = self.remote_field.through\n1241 \n1242         errors = []\n1243 \n1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n1245             # The relationship model is not installed.\n1246             errors.append(\n1247                 checks.Error(\n1248                     \"Field specifies a many-to-many relation through model \"\n1249                     \"'%s', which has not been installed.\" % qualified_model_name,\n1250                     obj=self,\n1251                     id='fields.E331',\n1252                 )\n1253             )\n1254 \n1255         else:\n1256             assert from_model is not None, (\n1257                 \"ManyToManyField with intermediate \"\n1258                 \"tables cannot be checked if you don't pass the model \"\n1259                 \"where the field is attached to.\"\n1260             )\n1261             # Set some useful local variables\n1262             to_model = resolve_relation(from_model, self.remote_field.model)\n1263             from_model_name = from_model._meta.object_name\n1264             if isinstance(to_model, str):\n1265                 to_model_name = to_model\n1266             else:\n1267                 to_model_name = to_model._meta.object_name\n1268             relationship_model_name = self.remote_field.through._meta.object_name\n1269             self_referential = from_model == to_model\n1270             # Count foreign keys in intermediate model\n1271             if self_referential:\n1272                 seen_self = sum(\n1273                     from_model == getattr(field.remote_field, 'model', None)\n1274                     for field in self.remote_field.through._meta.fields\n1275                 )\n1276 \n1277                 if seen_self > 2 and not self.remote_field.through_fields:\n1278                     errors.append(\n1279                         checks.Error(\n1280                             \"The model is used as an intermediate model by \"\n1281                             \"'%s', but it has more than two foreign keys \"\n1282                             \"to '%s', which is ambiguous. You must specify \"\n1283                             \"which two foreign keys Django should use via the \"\n1284                             \"through_fields keyword argument.\" % (self, from_model_name),\n1285                             hint=\"Use through_fields to specify which two foreign keys Django should use.\",\n1286                             obj=self.remote_field.through,\n1287                             id='fields.E333',\n1288                         )\n1289                     )\n1290 \n1291             else:\n1292                 # Count foreign keys in relationship model\n1293                 seen_from = sum(\n1294                     from_model == getattr(field.remote_field, 'model', None)\n1295                     for field in self.remote_field.through._meta.fields\n1296                 )\n1297                 seen_to = sum(\n1298                     to_model == getattr(field.remote_field, 'model', None)\n1299                     for field in self.remote_field.through._meta.fields\n1300                 )\n1301 \n1302                 if seen_from > 1 and not self.remote_field.through_fields:\n1303                     errors.append(\n1304                         checks.Error(\n1305                             (\"The model is used as an intermediate model by \"\n1306                              \"'%s', but it has more than one foreign key \"\n1307                              \"from '%s', which is ambiguous. You must specify \"\n1308                              \"which foreign key Django should use via the \"\n1309                              \"through_fields keyword argument.\") % (self, from_model_name),\n1310                             hint=(\n1311                                 'If you want to create a recursive relationship, '\n1312                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1313                             ) % (\n1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1315                                 relationship_model_name,\n1316                             ),\n1317                             obj=self,\n1318                             id='fields.E334',\n1319                         )\n1320                     )\n1321 \n1322                 if seen_to > 1 and not self.remote_field.through_fields:\n1323                     errors.append(\n1324                         checks.Error(\n1325                             \"The model is used as an intermediate model by \"\n1326                             \"'%s', but it has more than one foreign key \"\n1327                             \"to '%s', which is ambiguous. You must specify \"\n1328                             \"which foreign key Django should use via the \"\n1329                             \"through_fields keyword argument.\" % (self, to_model_name),\n1330                             hint=(\n1331                                 'If you want to create a recursive relationship, '\n1332                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1333                             ) % (\n1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1335                                 relationship_model_name,\n1336                             ),\n1337                             obj=self,\n1338                             id='fields.E335',\n1339                         )\n1340                     )\n1341 \n1342                 if seen_from == 0 or seen_to == 0:\n1343                     errors.append(\n1344                         checks.Error(\n1345                             \"The model is used as an intermediate model by \"\n1346                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\" % (\n1347                                 self, from_model_name, to_model_name\n1348                             ),\n1349                             obj=self.remote_field.through,\n1350                             id='fields.E336',\n1351                         )\n1352                     )\n1353 \n1354         # Validate `through_fields`.\n1355         if self.remote_field.through_fields is not None:\n1356             # Validate that we're given an iterable of at least two items\n1357             # and that none of them is \"falsy\".\n1358             if not (len(self.remote_field.through_fields) >= 2 and\n1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):\n1360                 errors.append(\n1361                     checks.Error(\n1362                         \"Field specifies 'through_fields' but does not provide \"\n1363                         \"the names of the two link fields that should be used \"\n1364                         \"for the relation through model '%s'.\" % qualified_model_name,\n1365                         hint=\"Make sure you specify 'through_fields' as through_fields=('field1', 'field2')\",\n1366                         obj=self,\n1367                         id='fields.E337',\n1368                     )\n1369                 )\n1370 \n1371             # Validate the given through fields -- they should be actual\n1372             # fields on the through model, and also be foreign keys to the\n1373             # expected models.\n1374             else:\n1375                 assert from_model is not None, (\n1376                     \"ManyToManyField with intermediate \"\n1377                     \"tables cannot be checked if you don't pass the model \"\n1378                     \"where the field is attached to.\"\n1379                 )\n1380 \n1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model\n1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]\n1383 \n1384                 for field_name, related_model in ((source_field_name, source),\n1385                                                   (target_field_name, target)):\n1386 \n1387                     possible_field_names = []\n1388                     for f in through._meta.fields:\n1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:\n1390                             possible_field_names.append(f.name)\n1391                     if possible_field_names:\n1392                         hint = \"Did you mean one of the following foreign keys to '%s': %s?\" % (\n1393                             related_model._meta.object_name,\n1394                             ', '.join(possible_field_names),\n1395                         )\n1396                     else:\n1397                         hint = None\n1398 \n1399                     try:\n1400                         field = through._meta.get_field(field_name)\n1401                     except exceptions.FieldDoesNotExist:\n1402                         errors.append(\n1403                             checks.Error(\n1404                                 \"The intermediary model '%s' has no field '%s'.\"\n1405                                 % (qualified_model_name, field_name),\n1406                                 hint=hint,\n1407                                 obj=self,\n1408                                 id='fields.E338',\n1409                             )\n1410                         )\n1411                     else:\n1412                         if not (hasattr(field, 'remote_field') and\n1413                                 getattr(field.remote_field, 'model', None) == related_model):\n1414                             errors.append(\n1415                                 checks.Error(\n1416                                     \"'%s.%s' is not a foreign key to '%s'.\" % (\n1417                                         through._meta.object_name, field_name,\n1418                                         related_model._meta.object_name,\n1419                                     ),\n1420                                     hint=hint,\n1421                                     obj=self,\n1422                                     id='fields.E339',\n1423                                 )\n1424                             )\n1425 \n1426         return errors\n1427 \n1428     def _check_table_uniqueness(self, **kwargs):\n1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:\n1430             return []\n1431         registered_tables = {\n1432             model._meta.db_table: model\n1433             for model in self.opts.apps.get_models(include_auto_created=True)\n1434             if model != self.remote_field.through and model._meta.managed\n1435         }\n1436         m2m_db_table = self.m2m_db_table()\n1437         model = registered_tables.get(m2m_db_table)\n1438         # The second condition allows multiple m2m relations on a model if\n1439         # some point to a through model that proxies another through model.\n1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:\n1441             if model._meta.auto_created:\n1442                 def _get_field_name(model):\n1443                     for field in model._meta.auto_created._meta.many_to_many:\n1444                         if field.remote_field.through is model:\n1445                             return field.name\n1446                 opts = model._meta.auto_created._meta\n1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))\n1448             else:\n1449                 clashing_obj = model._meta.label\n1450             if settings.DATABASE_ROUTERS:\n1451                 error_class, error_id = checks.Warning, 'fields.W344'\n1452                 error_hint = (\n1453                     'You have configured settings.DATABASE_ROUTERS. Verify '\n1454                     'that the table of %r is correctly routed to a separate '\n1455                     'database.' % clashing_obj\n1456                 )\n1457             else:\n1458                 error_class, error_id = checks.Error, 'fields.E340'\n1459                 error_hint = None\n1460             return [\n1461                 error_class(\n1462                     \"The field's intermediary table '%s' clashes with the \"\n1463                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1464                     obj=self,\n1465                     hint=error_hint,\n1466                     id=error_id,\n1467                 )\n1468             ]\n1469         return []\n1470 \n1471     def deconstruct(self):\n1472         name, path, args, kwargs = super().deconstruct()\n1473         # Handle the simpler arguments.\n1474         if self.db_table is not None:\n1475             kwargs['db_table'] = self.db_table\n1476         if self.remote_field.db_constraint is not True:\n1477             kwargs['db_constraint'] = self.remote_field.db_constraint\n1478         # Rel needs more work.\n1479         if isinstance(self.remote_field.model, str):\n1480             kwargs['to'] = self.remote_field.model\n1481         else:\n1482             kwargs['to'] = self.remote_field.model._meta.label\n1483         if getattr(self.remote_field, 'through', None) is not None:\n1484             if isinstance(self.remote_field.through, str):\n1485                 kwargs['through'] = self.remote_field.through\n1486             elif not self.remote_field.through._meta.auto_created:\n1487                 kwargs['through'] = self.remote_field.through._meta.label\n1488         # If swappable is True, then see if we're actually pointing to the target\n1489         # of a swap.\n1490         swappable_setting = self.swappable_setting\n1491         if swappable_setting is not None:\n1492             # If it's already a settings reference, error.\n1493             if hasattr(kwargs['to'], \"setting_name\"):\n1494                 if kwargs['to'].setting_name != swappable_setting:\n1495                     raise ValueError(\n1496                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1497                         \"model that is swapped in place of more than one model \"\n1498                         \"(%s and %s)\" % (kwargs['to'].setting_name, swappable_setting)\n1499                     )\n1500 \n1501             kwargs['to'] = SettingsReference(\n1502                 kwargs['to'],\n1503                 swappable_setting,\n1504             )\n1505         return name, path, args, kwargs\n1506 \n1507     def _get_path_info(self, direct=False, filtered_relation=None):\n1508         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1509         int_model = self.remote_field.through\n1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1512         if direct:\n1513             join1infos = linkfield1.get_reverse_path_info()\n1514             join2infos = linkfield2.get_path_info(filtered_relation)\n1515         else:\n1516             join1infos = linkfield2.get_reverse_path_info()\n1517             join2infos = linkfield1.get_path_info(filtered_relation)\n1518 \n1519         # Get join infos between the last model of join 1 and the first model\n1520         # of join 2. Assume the only reason these may differ is due to model\n1521         # inheritance.\n1522         join1_final = join1infos[-1].to_opts\n1523         join2_initial = join2infos[0].from_opts\n1524         if join1_final is join2_initial:\n1525             intermediate_infos = []\n1526         elif issubclass(join1_final.model, join2_initial.model):\n1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1528         else:\n1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1530 \n1531         return [*join1infos, *intermediate_infos, *join2infos]\n1532 \n1533     def get_path_info(self, filtered_relation=None):\n1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1535 \n1536     def get_reverse_path_info(self, filtered_relation=None):\n1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1538 \n1539     def _get_m2m_db_table(self, opts):\n1540         \"\"\"\n1541         Function that can be curried to provide the m2m table name for this\n1542         relation.\n1543         \"\"\"\n1544         if self.remote_field.through is not None:\n1545             return self.remote_field.through._meta.db_table\n1546         elif self.db_table:\n1547             return self.db_table\n1548         else:\n1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)\n1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1551 \n1552     def _get_m2m_attr(self, related, attr):\n1553         \"\"\"\n1554         Function that can be curried to provide the source accessor or DB\n1555         column name for the m2m table.\n1556         \"\"\"\n1557         cache_attr = '_m2m_%s_cache' % attr\n1558         if hasattr(self, cache_attr):\n1559             return getattr(self, cache_attr)\n1560         if self.remote_field.through_fields is not None:\n1561             link_field_name = self.remote_field.through_fields[0]\n1562         else:\n1563             link_field_name = None\n1564         for f in self.remote_field.through._meta.fields:\n1565             if (f.is_relation and f.remote_field.model == related.related_model and\n1566                     (link_field_name is None or link_field_name == f.name)):\n1567                 setattr(self, cache_attr, getattr(f, attr))\n1568                 return getattr(self, cache_attr)\n1569 \n1570     def _get_m2m_reverse_attr(self, related, attr):\n1571         \"\"\"\n1572         Function that can be curried to provide the related accessor or DB\n1573         column name for the m2m table.\n1574         \"\"\"\n1575         cache_attr = '_m2m_reverse_%s_cache' % attr\n1576         if hasattr(self, cache_attr):\n1577             return getattr(self, cache_attr)\n1578         found = False\n1579         if self.remote_field.through_fields is not None:\n1580             link_field_name = self.remote_field.through_fields[1]\n1581         else:\n1582             link_field_name = None\n1583         for f in self.remote_field.through._meta.fields:\n1584             if f.is_relation and f.remote_field.model == related.model:\n1585                 if link_field_name is None and related.related_model == related.model:\n1586                     # If this is an m2m-intermediate to self,\n1587                     # the first foreign key you find will be\n1588                     # the source column. Keep searching for\n1589                     # the second foreign key.\n1590                     if found:\n1591                         setattr(self, cache_attr, getattr(f, attr))\n1592                         break\n1593                     else:\n1594                         found = True\n1595                 elif link_field_name is None or link_field_name == f.name:\n1596                     setattr(self, cache_attr, getattr(f, attr))\n1597                     break\n1598         return getattr(self, cache_attr)\n1599 \n1600     def contribute_to_class(self, cls, name, **kwargs):\n1601         # To support multiple relations to self, it's useful to have a non-None\n1602         # related name on symmetrical relations for internal reasons. The\n1603         # concept doesn't make a lot of sense externally (\"you want me to\n1604         # specify *what* on my non-reversible relation?!\"), so we set it up\n1605         # automatically. The funky name reduces the chance of an accidental\n1606         # clash.\n1607         if self.remote_field.symmetrical and (\n1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or\n1609             self.remote_field.model == cls._meta.object_name\n1610         ):\n1611             self.remote_field.related_name = \"%s_rel_+\" % name\n1612         elif self.remote_field.is_hidden():\n1613             # If the backwards relation is disabled, replace the original\n1614             # related_name with one generated from the m2m field name. Django\n1615             # still uses backwards relations internally and we need to avoid\n1616             # clashes between multiple m2m fields with related_name == '+'.\n1617             self.remote_field.related_name = \"_%s_%s_+\" % (cls.__name__.lower(), name)\n1618 \n1619         super().contribute_to_class(cls, name, **kwargs)\n1620 \n1621         # The intermediate m2m model is not auto created if:\n1622         #  1) There is a manually specified intermediate, or\n1623         #  2) The class owning the m2m field is abstract.\n1624         #  3) The class owning the m2m field has been swapped out.\n1625         if not cls._meta.abstract:\n1626             if self.remote_field.through:\n1627                 def resolve_through_model(_, model, field):\n1628                     field.remote_field.through = model\n1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)\n1630             elif not cls._meta.swapped:\n1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)\n1632 \n1633         # Add the descriptor for the m2m relation.\n1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1635 \n1636         # Set up the accessor for the m2m table name for the relation.\n1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1638 \n1639     def contribute_to_related_class(self, cls, related):\n1640         # Internal M2Ms (i.e., those with a related name ending with '+')\n1641         # and swapped models don't get a related descriptor.\n1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))\n1644 \n1645         # Set up the accessors for the column names on the m2m table.\n1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')\n1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')\n1648 \n1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')\n1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')\n1651 \n1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')\n1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')\n1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1656 \n1657     def set_attributes_from_rel(self):\n1658         pass\n1659 \n1660     def value_from_object(self, obj):\n1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1662 \n1663     def save_form_data(self, instance, data):\n1664         getattr(instance, self.attname).set(data)\n1665 \n1666     def formfield(self, *, using=None, **kwargs):\n1667         defaults = {\n1668             'form_class': forms.ModelMultipleChoiceField,\n1669             'queryset': self.remote_field.model._default_manager.using(using),\n1670             **kwargs,\n1671         }\n1672         # If initial is passed in, it's a list of related objects, but the\n1673         # MultipleChoiceField takes a list of IDs.\n1674         if defaults.get('initial') is not None:\n1675             initial = defaults['initial']\n1676             if callable(initial):\n1677                 initial = initial()\n1678             defaults['initial'] = [i.pk for i in initial]\n1679         return super().formfield(**defaults)\n1680 \n1681     def db_check(self, connection):\n1682         return None\n1683 \n1684     def db_type(self, connection):\n1685         # A ManyToManyField is not represented by a single column,\n1686         # so return None.\n1687         return None\n1688 \n1689     def db_parameters(self, connection):\n1690         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Ensure that the `related_name='+'` or similar directives do not lead to migration errors when used in models with identical names across different applications. There might need to be a clarification or enhancement in how these models and their relationships are processed to allow for smooth migration creation."
    }
]