[
    {
        "rel_file_path": "lib/matplotlib/colors.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.3/lib/matplotlib/colors.py",
        "start": 1223,
        "end": 1227,
        "class_name": "Normalize",
        "method_name": "autoscale",
        "code": "1223     def autoscale(self, A):\n1224         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n1225         A = np.asanyarray(A)\n1226         self.vmin = A.min()\n1227         self.vmax = A.max()\n",
        "intended_behavior": "These methods should be modified or augmented to include a notification mechanism for when vmin and vmax are changed. After updating these parameters, the method should emit a signal indicating the change. This signal should be caught by all connected scalar-mappable objects that rely on this Normalize instance, prompting them to update their visual representation accordingly. It ensures that any change in the normalization parameters leads to an immediate and synchronized update in all dependent visual elements, maintaining the integrity of visual representations across the application."
    },
    {
        "rel_file_path": "lib/matplotlib/colors.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.3/lib/matplotlib/colors.py",
        "start": 1098,
        "end": 1239,
        "class_name": "Normalize",
        "method_name": null,
        "code": "1098 class Normalize:\n1099     \"\"\"\n1100     A class which, when called, linearly normalizes data into the\n1101     ``[0.0, 1.0]`` interval.\n1102     \"\"\"\n1103 \n1104     def __init__(self, vmin=None, vmax=None, clip=False):\n1105         \"\"\"\n1106         Parameters\n1107         ----------\n1108         vmin, vmax : float or None\n1109             If *vmin* and/or *vmax* is not given, they are initialized from the\n1110             minimum and maximum value, respectively, of the first input\n1111             processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n1112 \n1113         clip : bool, default: False\n1114             If ``True`` values falling outside the range ``[vmin, vmax]``,\n1115             are mapped to 0 or 1, whichever is closer, and masked values are\n1116             set to 1.  If ``False`` masked values remain masked.\n1117 \n1118             Clipping silently defeats the purpose of setting the over, under,\n1119             and masked colors in a colormap, so it is likely to lead to\n1120             surprises; therefore the default is ``clip=False``.\n1121 \n1122         Notes\n1123         -----\n1124         Returns 0 if ``vmin == vmax``.\n1125         \"\"\"\n1126         self.vmin = _sanitize_extrema(vmin)\n1127         self.vmax = _sanitize_extrema(vmax)\n1128         self.clip = clip\n1129         self._scale = None  # will default to LinearScale for colorbar\n1130 \n1131     @staticmethod\n1132     def process_value(value):\n1133         \"\"\"\n1134         Homogenize the input *value* for easy and efficient normalization.\n1135 \n1136         *value* can be a scalar or sequence.\n1137 \n1138         Returns\n1139         -------\n1140         result : masked array\n1141             Masked array with the same shape as *value*.\n1142         is_scalar : bool\n1143             Whether *value* is a scalar.\n1144 \n1145         Notes\n1146         -----\n1147         Float dtypes are preserved; integer types with two bytes or smaller are\n1148         converted to np.float32, and larger types are converted to np.float64.\n1149         Preserving float32 when possible, and using in-place operations,\n1150         greatly improves speed for large arrays.\n1151         \"\"\"\n1152         is_scalar = not np.iterable(value)\n1153         if is_scalar:\n1154             value = [value]\n1155         dtype = np.min_scalar_type(value)\n1156         if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n1157             # bool_/int8/int16 -> float32; int32/int64 -> float64\n1158             dtype = np.promote_types(dtype, np.float32)\n1159         # ensure data passed in as an ndarray subclass are interpreted as\n1160         # an ndarray. See issue #6622.\n1161         mask = np.ma.getmask(value)\n1162         data = np.asarray(value)\n1163         result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n1164         return result, is_scalar\n1165 \n1166     def __call__(self, value, clip=None):\n1167         \"\"\"\n1168         Normalize *value* data in the ``[vmin, vmax]`` interval into the\n1169         ``[0.0, 1.0]`` interval and return it.\n1170 \n1171         Parameters\n1172         ----------\n1173         value\n1174             Data to normalize.\n1175         clip : bool\n1176             If ``None``, defaults to ``self.clip`` (which defaults to\n1177             ``False``).\n1178 \n1179         Notes\n1180         -----\n1181         If not already initialized, ``self.vmin`` and ``self.vmax`` are\n1182         initialized using ``self.autoscale_None(value)``.\n1183         \"\"\"\n1184         if clip is None:\n1185             clip = self.clip\n1186 \n1187         result, is_scalar = self.process_value(value)\n1188 \n1189         self.autoscale_None(result)\n1190         # Convert at least to float, without losing precision.\n1191         (vmin,), _ = self.process_value(self.vmin)\n1192         (vmax,), _ = self.process_value(self.vmax)\n1193         if vmin == vmax:\n1194             result.fill(0)   # Or should it be all masked?  Or 0.5?\n1195         elif vmin > vmax:\n1196             raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n1197         else:\n1198             if clip:\n1199                 mask = np.ma.getmask(result)\n1200                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n1201                                      mask=mask)\n1202             # ma division is very slow; we can take a shortcut\n1203             resdat = result.data\n1204             resdat -= vmin\n1205             resdat /= (vmax - vmin)\n1206             result = np.ma.array(resdat, mask=result.mask, copy=False)\n1207         if is_scalar:\n1208             result = result[0]\n1209         return result\n1210 \n1211     def inverse(self, value):\n1212         if not self.scaled():\n1213             raise ValueError(\"Not invertible until both vmin and vmax are set\")\n1214         (vmin,), _ = self.process_value(self.vmin)\n1215         (vmax,), _ = self.process_value(self.vmax)\n1216 \n1217         if np.iterable(value):\n1218             val = np.ma.asarray(value)\n1219             return vmin + val * (vmax - vmin)\n1220         else:\n1221             return vmin + value * (vmax - vmin)\n1222 \n1223     def autoscale(self, A):\n1224         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n1225         A = np.asanyarray(A)\n1226         self.vmin = A.min()\n1227         self.vmax = A.max()\n1228 \n1229     def autoscale_None(self, A):\n1230         \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n1231         A = np.asanyarray(A)\n1232         if self.vmin is None and A.size:\n1233             self.vmin = A.min()\n1234         if self.vmax is None and A.size:\n1235             self.vmax = A.max()\n1236 \n1237     def scaled(self):\n1238         \"\"\"Return whether vmin and vmax are set.\"\"\"\n1239         return self.vmin is not None and self.vmax is not None\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "lib/matplotlib/cbook/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.3/lib/matplotlib/cbook/__init__.py",
        "start": 209,
        "end": 222,
        "class_name": "CallbackRegistry",
        "method_name": "connect",
        "code": "209     def connect(self, signal, func):\n210         \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n211         if signal == \"units finalize\":\n212             _api.warn_deprecated(\n213                 \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n214         self._func_cid_map.setdefault(signal, {})\n215         proxy = _weak_or_strong_ref(func, self._remove_proxy)\n216         if proxy in self._func_cid_map[signal]:\n217             return self._func_cid_map[signal][proxy]\n218         cid = next(self._cid_gen)\n219         self._func_cid_map[signal][proxy] = cid\n220         self.callbacks.setdefault(signal, {})\n221         self.callbacks[signal][cid] = proxy\n222         return cid\n",
        "intended_behavior": "While the connect method itself may not be buggy, the issue lies in how or if it's utilized by the Normalize class and scalar-mappable objects such as AxesImage. To resolve the issue, ensure that Normalize instances correctly register change events with the CallbackRegistry, and scalar-mappable objects subscribe to these events. When a change event occurs (e.g., a change in normalization parameters), the connected callback in the scalar-mappable object triggers an update to its displayed data. This approach requires ensuring that the mechanism for emitting and responding to signals (perhaps via connect or a similar pattern) is robustly implemented and utilized within the codebase, linking changes in normalization directly to updates in visual representations."
    },
    {
        "rel_file_path": "lib/matplotlib/cbook/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.3/lib/matplotlib/cbook/__init__.py",
        "start": 123,
        "end": 313,
        "class_name": "CallbackRegistry",
        "method_name": null,
        "code": "123 class CallbackRegistry:\n124     \"\"\"\n125     Handle registering, processing, blocking, and disconnecting\n126     for a set of signals and callbacks:\n127 \n128         >>> def oneat(x):\n129         ...    print('eat', x)\n130         >>> def ondrink(x):\n131         ...    print('drink', x)\n132 \n133         >>> from matplotlib.cbook import CallbackRegistry\n134         >>> callbacks = CallbackRegistry()\n135 \n136         >>> id_eat = callbacks.connect('eat', oneat)\n137         >>> id_drink = callbacks.connect('drink', ondrink)\n138 \n139         >>> callbacks.process('drink', 123)\n140         drink 123\n141         >>> callbacks.process('eat', 456)\n142         eat 456\n143         >>> callbacks.process('be merry', 456) # nothing will be called\n144 \n145         >>> callbacks.disconnect(id_eat)\n146         >>> callbacks.process('eat', 456)      # nothing will be called\n147 \n148         >>> with callbacks.blocked(signal='drink'):\n149         ...     callbacks.process('drink', 123) # nothing will be called\n150         >>> callbacks.process('drink', 123)\n151         drink 123\n152 \n153     In practice, one should always disconnect all callbacks when they are\n154     no longer needed to avoid dangling references (and thus memory leaks).\n155     However, real code in Matplotlib rarely does so, and due to its design,\n156     it is rather difficult to place this kind of code.  To get around this,\n157     and prevent this class of memory leaks, we instead store weak references\n158     to bound methods only, so when the destination object needs to die, the\n159     CallbackRegistry won't keep it alive.\n160 \n161     Parameters\n162     ----------\n163     exception_handler : callable, optional\n164        If not None, *exception_handler* must be a function that takes an\n165        `Exception` as single parameter.  It gets called with any `Exception`\n166        raised by the callbacks during `CallbackRegistry.process`, and may\n167        either re-raise the exception or handle it in another manner.\n168 \n169        The default handler prints the exception (with `traceback.print_exc`) if\n170        an interactive event loop is running; it re-raises the exception if no\n171        interactive event loop is running.\n172     \"\"\"\n173 \n174     # We maintain two mappings:\n175     #   callbacks: signal -> {cid -> weakref-to-callback}\n176     #   _func_cid_map: signal -> {weakref-to-callback -> cid}\n177 \n178     def __init__(self, exception_handler=_exception_printer):\n179         self.exception_handler = exception_handler\n180         self.callbacks = {}\n181         self._cid_gen = itertools.count()\n182         self._func_cid_map = {}\n183         # A hidden variable that marks cids that need to be pickled.\n184         self._pickled_cids = set()\n185 \n186     def __getstate__(self):\n187         return {\n188             **vars(self),\n189             # In general, callbacks may not be pickled, so we just drop them,\n190             # unless directed otherwise by self._pickled_cids.\n191             \"callbacks\": {s: {cid: proxy() for cid, proxy in d.items()\n192                               if cid in self._pickled_cids}\n193                           for s, d in self.callbacks.items()},\n194             # It is simpler to reconstruct this from callbacks in __setstate__.\n195             \"_func_cid_map\": None,\n196         }\n197 \n198     def __setstate__(self, state):\n199         vars(self).update(state)\n200         self.callbacks = {\n201             s: {cid: _weak_or_strong_ref(func, self._remove_proxy)\n202                 for cid, func in d.items()}\n203             for s, d in self.callbacks.items()}\n204         self._func_cid_map = {\n205             s: {proxy: cid for cid, proxy in d.items()}\n206             for s, d in self.callbacks.items()}\n207 \n208     @_api.rename_parameter(\"3.4\", \"s\", \"signal\")\n209     def connect(self, signal, func):\n210         \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n211         if signal == \"units finalize\":\n212             _api.warn_deprecated(\n213                 \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n214         self._func_cid_map.setdefault(signal, {})\n215         proxy = _weak_or_strong_ref(func, self._remove_proxy)\n216         if proxy in self._func_cid_map[signal]:\n217             return self._func_cid_map[signal][proxy]\n218         cid = next(self._cid_gen)\n219         self._func_cid_map[signal][proxy] = cid\n220         self.callbacks.setdefault(signal, {})\n221         self.callbacks[signal][cid] = proxy\n222         return cid\n223 \n224     # Keep a reference to sys.is_finalizing, as sys may have been cleared out\n225     # at that point.\n226     def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n227         if _is_finalizing():\n228             # Weakrefs can't be properly torn down at that point anymore.\n229             return\n230         for signal, proxy_to_cid in list(self._func_cid_map.items()):\n231             cid = proxy_to_cid.pop(proxy, None)\n232             if cid is not None:\n233                 del self.callbacks[signal][cid]\n234                 self._pickled_cids.discard(cid)\n235                 break\n236         else:\n237             # Not found\n238             return\n239         # Clean up empty dicts\n240         if len(self.callbacks[signal]) == 0:\n241             del self.callbacks[signal]\n242             del self._func_cid_map[signal]\n243 \n244     def disconnect(self, cid):\n245         \"\"\"\n246         Disconnect the callback registered with callback id *cid*.\n247 \n248         No error is raised if such a callback does not exist.\n249         \"\"\"\n250         self._pickled_cids.discard(cid)\n251         # Clean up callbacks\n252         for signal, cid_to_proxy in list(self.callbacks.items()):\n253             proxy = cid_to_proxy.pop(cid, None)\n254             if proxy is not None:\n255                 break\n256         else:\n257             # Not found\n258             return\n259 \n260         proxy_to_cid = self._func_cid_map[signal]\n261         for current_proxy, current_cid in list(proxy_to_cid.items()):\n262             if current_cid == cid:\n263                 assert proxy is current_proxy\n264                 del proxy_to_cid[current_proxy]\n265         # Clean up empty dicts\n266         if len(self.callbacks[signal]) == 0:\n267             del self.callbacks[signal]\n268             del self._func_cid_map[signal]\n269 \n270     def process(self, s, *args, **kwargs):\n271         \"\"\"\n272         Process signal *s*.\n273 \n274         All of the functions registered to receive callbacks on *s* will be\n275         called with ``*args`` and ``**kwargs``.\n276         \"\"\"\n277         for cid, ref in list(self.callbacks.get(s, {}).items()):\n278             func = ref()\n279             if func is not None:\n280                 try:\n281                     func(*args, **kwargs)\n282                 # this does not capture KeyboardInterrupt, SystemExit,\n283                 # and GeneratorExit\n284                 except Exception as exc:\n285                     if self.exception_handler is not None:\n286                         self.exception_handler(exc)\n287                     else:\n288                         raise\n289 \n290     @contextlib.contextmanager\n291     def blocked(self, *, signal=None):\n292         \"\"\"\n293         Block callback signals from being processed.\n294 \n295         A context manager to temporarily block/disable callback signals\n296         from being processed by the registered listeners.\n297 \n298         Parameters\n299         ----------\n300         signal : str, optional\n301             The callback signal to block. The default is to block all signals.\n302         \"\"\"\n303         orig = self.callbacks\n304         try:\n305             if signal is None:\n306                 # Empty out the callbacks\n307                 self.callbacks = {}\n308             else:\n309                 # Only remove the specific signal\n310                 self.callbacks = {k: orig[k] for k in orig if k != signal}\n311             yield\n312         finally:\n313             self.callbacks = orig\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]