[
    {
        "rel_file_path": "django/db/migrations/loader.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/migrations/loader.py",
        "start": 18,
        "end": 356,
        "class_name": "MigrationLoader",
        "method_name": null,
        "code": "18 class MigrationLoader:\n19     \"\"\"\n20     Load migration files from disk and their status from the database.\n21 \n22     Migration files are expected to live in the \"migrations\" directory of\n23     an app. Their names are entirely unimportant from a code perspective,\n24     but will probably follow the 1234_name.py convention.\n25 \n26     On initialization, this class will scan those directories, and open and\n27     read the Python files, looking for a class called Migration, which should\n28     inherit from django.db.migrations.Migration. See\n29     django.db.migrations.migration for what that looks like.\n30 \n31     Some migrations will be marked as \"replacing\" another set of migrations.\n32     These are loaded into a separate set of migrations away from the main ones.\n33     If all the migrations they replace are either unapplied or missing from\n34     disk, then they are injected into the main set, replacing the named migrations.\n35     Any dependency pointers to the replaced migrations are re-pointed to the\n36     new migration.\n37 \n38     This does mean that this class MUST also talk to the database as well as\n39     to disk, but this is probably fine. We're already not just operating\n40     in memory.\n41     \"\"\"\n42 \n43     def __init__(\n44         self, connection, load=True, ignore_no_migrations=False,\n45         replace_migrations=True,\n46     ):\n47         self.connection = connection\n48         self.disk_migrations = None\n49         self.applied_migrations = None\n50         self.ignore_no_migrations = ignore_no_migrations\n51         self.replace_migrations = replace_migrations\n52         if load:\n53             self.build_graph()\n54 \n55     @classmethod\n56     def migrations_module(cls, app_label):\n57         \"\"\"\n58         Return the path to the migrations module for the specified app_label\n59         and a boolean indicating if the module is specified in\n60         settings.MIGRATION_MODULE.\n61         \"\"\"\n62         if app_label in settings.MIGRATION_MODULES:\n63             return settings.MIGRATION_MODULES[app_label], True\n64         else:\n65             app_package_name = apps.get_app_config(app_label).name\n66             return '%s.%s' % (app_package_name, MIGRATIONS_MODULE_NAME), False\n67 \n68     def load_disk(self):\n69         \"\"\"Load the migrations from all INSTALLED_APPS from disk.\"\"\"\n70         self.disk_migrations = {}\n71         self.unmigrated_apps = set()\n72         self.migrated_apps = set()\n73         for app_config in apps.get_app_configs():\n74             # Get the migrations module directory\n75             module_name, explicit = self.migrations_module(app_config.label)\n76             if module_name is None:\n77                 self.unmigrated_apps.add(app_config.label)\n78                 continue\n79             was_loaded = module_name in sys.modules\n80             try:\n81                 module = import_module(module_name)\n82             except ModuleNotFoundError as e:\n83                 if (\n84                     (explicit and self.ignore_no_migrations) or\n85                     (not explicit and MIGRATIONS_MODULE_NAME in e.name.split('.'))\n86                 ):\n87                     self.unmigrated_apps.add(app_config.label)\n88                     continue\n89                 raise\n90             else:\n91                 # Module is not a package (e.g. migrations.py).\n92                 if not hasattr(module, '__path__'):\n93                     self.unmigrated_apps.add(app_config.label)\n94                     continue\n95                 # Empty directories are namespaces. Namespace packages have no\n96                 # __file__ and don't use a list for __path__. See\n97                 # https://docs.python.org/3/reference/import.html#namespace-packages\n98                 if (\n99                     getattr(module, '__file__', None) is None and\n100                     not isinstance(module.__path__, list)\n101                 ):\n102                     self.unmigrated_apps.add(app_config.label)\n103                     continue\n104                 # Force a reload if it's already loaded (tests need this)\n105                 if was_loaded:\n106                     reload(module)\n107             self.migrated_apps.add(app_config.label)\n108             migration_names = {\n109                 name for _, name, is_pkg in pkgutil.iter_modules(module.__path__)\n110                 if not is_pkg and name[0] not in '_~'\n111             }\n112             # Load migrations\n113             for migration_name in migration_names:\n114                 migration_path = '%s.%s' % (module_name, migration_name)\n115                 try:\n116                     migration_module = import_module(migration_path)\n117                 except ImportError as e:\n118                     if 'bad magic number' in str(e):\n119                         raise ImportError(\n120                             \"Couldn't import %r as it appears to be a stale \"\n121                             \".pyc file.\" % migration_path\n122                         ) from e\n123                     else:\n124                         raise\n125                 if not hasattr(migration_module, \"Migration\"):\n126                     raise BadMigrationError(\n127                         \"Migration %s in app %s has no Migration class\" % (migration_name, app_config.label)\n128                     )\n129                 self.disk_migrations[app_config.label, migration_name] = migration_module.Migration(\n130                     migration_name,\n131                     app_config.label,\n132                 )\n133 \n134     def get_migration(self, app_label, name_prefix):\n135         \"\"\"Return the named migration or raise NodeNotFoundError.\"\"\"\n136         return self.graph.nodes[app_label, name_prefix]\n137 \n138     def get_migration_by_prefix(self, app_label, name_prefix):\n139         \"\"\"\n140         Return the migration(s) which match the given app label and name_prefix.\n141         \"\"\"\n142         # Do the search\n143         results = []\n144         for migration_app_label, migration_name in self.disk_migrations:\n145             if migration_app_label == app_label and migration_name.startswith(name_prefix):\n146                 results.append((migration_app_label, migration_name))\n147         if len(results) > 1:\n148             raise AmbiguityError(\n149                 \"There is more than one migration for '%s' with the prefix '%s'\" % (app_label, name_prefix)\n150             )\n151         elif not results:\n152             raise KeyError(\n153                 f\"There is no migration for '{app_label}' with the prefix \"\n154                 f\"'{name_prefix}'\"\n155             )\n156         else:\n157             return self.disk_migrations[results[0]]\n158 \n159     def check_key(self, key, current_app):\n160         if (key[1] != \"__first__\" and key[1] != \"__latest__\") or key in self.graph:\n161             return key\n162         # Special-case __first__, which means \"the first migration\" for\n163         # migrated apps, and is ignored for unmigrated apps. It allows\n164         # makemigrations to declare dependencies on apps before they even have\n165         # migrations.\n166         if key[0] == current_app:\n167             # Ignore __first__ references to the same app (#22325)\n168             return\n169         if key[0] in self.unmigrated_apps:\n170             # This app isn't migrated, but something depends on it.\n171             # The models will get auto-added into the state, though\n172             # so we're fine.\n173             return\n174         if key[0] in self.migrated_apps:\n175             try:\n176                 if key[1] == \"__first__\":\n177                     return self.graph.root_nodes(key[0])[0]\n178                 else:  # \"__latest__\"\n179                     return self.graph.leaf_nodes(key[0])[0]\n180             except IndexError:\n181                 if self.ignore_no_migrations:\n182                     return None\n183                 else:\n184                     raise ValueError(\"Dependency on app with no migrations: %s\" % key[0])\n185         raise ValueError(\"Dependency on unknown app: %s\" % key[0])\n186 \n187     def add_internal_dependencies(self, key, migration):\n188         \"\"\"\n189         Internal dependencies need to be added first to ensure `__first__`\n190         dependencies find the correct root node.\n191         \"\"\"\n192         for parent in migration.dependencies:\n193             # Ignore __first__ references to the same app.\n194             if parent[0] == key[0] and parent[1] != '__first__':\n195                 self.graph.add_dependency(migration, key, parent, skip_validation=True)\n196 \n197     def add_external_dependencies(self, key, migration):\n198         for parent in migration.dependencies:\n199             # Skip internal dependencies\n200             if key[0] == parent[0]:\n201                 continue\n202             parent = self.check_key(parent, key[0])\n203             if parent is not None:\n204                 self.graph.add_dependency(migration, key, parent, skip_validation=True)\n205         for child in migration.run_before:\n206             child = self.check_key(child, key[0])\n207             if child is not None:\n208                 self.graph.add_dependency(migration, child, key, skip_validation=True)\n209 \n210     def build_graph(self):\n211         \"\"\"\n212         Build a migration dependency graph using both the disk and database.\n213         You'll need to rebuild the graph if you apply migrations. This isn't\n214         usually a problem as generally migration stuff runs in a one-shot process.\n215         \"\"\"\n216         # Load disk data\n217         self.load_disk()\n218         # Load database data\n219         if self.connection is None:\n220             self.applied_migrations = {}\n221         else:\n222             recorder = MigrationRecorder(self.connection)\n223             self.applied_migrations = recorder.applied_migrations()\n224         # To start, populate the migration graph with nodes for ALL migrations\n225         # and their dependencies. Also make note of replacing migrations at this step.\n226         self.graph = MigrationGraph()\n227         self.replacements = {}\n228         for key, migration in self.disk_migrations.items():\n229             self.graph.add_node(key, migration)\n230             # Replacing migrations.\n231             if migration.replaces:\n232                 self.replacements[key] = migration\n233         for key, migration in self.disk_migrations.items():\n234             # Internal (same app) dependencies.\n235             self.add_internal_dependencies(key, migration)\n236         # Add external dependencies now that the internal ones have been resolved.\n237         for key, migration in self.disk_migrations.items():\n238             self.add_external_dependencies(key, migration)\n239         # Carry out replacements where possible and if enabled.\n240         if self.replace_migrations:\n241             for key, migration in self.replacements.items():\n242                 # Get applied status of each of this migration's replacement\n243                 # targets.\n244                 applied_statuses = [(target in self.applied_migrations) for target in migration.replaces]\n245                 # The replacing migration is only marked as applied if all of\n246                 # its replacement targets are.\n247                 if all(applied_statuses):\n248                     self.applied_migrations[key] = migration\n249                 else:\n250                     self.applied_migrations.pop(key, None)\n251                 # A replacing migration can be used if either all or none of\n252                 # its replacement targets have been applied.\n253                 if all(applied_statuses) or (not any(applied_statuses)):\n254                     self.graph.remove_replaced_nodes(key, migration.replaces)\n255                 else:\n256                     # This replacing migration cannot be used because it is\n257                     # partially applied. Remove it from the graph and remap\n258                     # dependencies to it (#25945).\n259                     self.graph.remove_replacement_node(key, migration.replaces)\n260         # Ensure the graph is consistent.\n261         try:\n262             self.graph.validate_consistency()\n263         except NodeNotFoundError as exc:\n264             # Check if the missing node could have been replaced by any squash\n265             # migration but wasn't because the squash migration was partially\n266             # applied before. In that case raise a more understandable exception\n267             # (#23556).\n268             # Get reverse replacements.\n269             reverse_replacements = {}\n270             for key, migration in self.replacements.items():\n271                 for replaced in migration.replaces:\n272                     reverse_replacements.setdefault(replaced, set()).add(key)\n273             # Try to reraise exception with more detail.\n274             if exc.node in reverse_replacements:\n275                 candidates = reverse_replacements.get(exc.node, set())\n276                 is_replaced = any(candidate in self.graph.nodes for candidate in candidates)\n277                 if not is_replaced:\n278                     tries = ', '.join('%s.%s' % c for c in candidates)\n279                     raise NodeNotFoundError(\n280                         \"Migration {0} depends on nonexistent node ('{1}', '{2}'). \"\n281                         \"Django tried to replace migration {1}.{2} with any of [{3}] \"\n282                         \"but wasn't able to because some of the replaced migrations \"\n283                         \"are already applied.\".format(\n284                             exc.origin, exc.node[0], exc.node[1], tries\n285                         ),\n286                         exc.node\n287                     ) from exc\n288             raise\n289         self.graph.ensure_not_cyclic()\n290 \n291     def check_consistent_history(self, connection):\n292         \"\"\"\n293         Raise InconsistentMigrationHistory if any applied migrations have\n294         unapplied dependencies.\n295         \"\"\"\n296         recorder = MigrationRecorder(connection)\n297         applied = recorder.applied_migrations()\n298         for migration in applied:\n299             # If the migration is unknown, skip it.\n300             if migration not in self.graph.nodes:\n301                 continue\n302             for parent in self.graph.node_map[migration].parents:\n303                 if parent not in applied:\n304                     # Skip unapplied squashed migrations that have all of their\n305                     # `replaces` applied.\n306                     if parent in self.replacements:\n307                         if all(m in applied for m in self.replacements[parent].replaces):\n308                             continue\n309                     raise InconsistentMigrationHistory(\n310                         \"Migration {}.{} is applied before its dependency \"\n311                         \"{}.{} on database '{}'.\".format(\n312                             migration[0], migration[1], parent[0], parent[1],\n313                             connection.alias,\n314                         )\n315                     )\n316 \n317     def detect_conflicts(self):\n318         \"\"\"\n319         Look through the loaded graph and detect any conflicts - apps\n320         with more than one leaf migration. Return a dict of the app labels\n321         that conflict with the migration names that conflict.\n322         \"\"\"\n323         seen_apps = {}\n324         conflicting_apps = set()\n325         for app_label, migration_name in self.graph.leaf_nodes():\n326             if app_label in seen_apps:\n327                 conflicting_apps.add(app_label)\n328             seen_apps.setdefault(app_label, set()).add(migration_name)\n329         return {app_label: sorted(seen_apps[app_label]) for app_label in conflicting_apps}\n330 \n331     def project_state(self, nodes=None, at_end=True):\n332         \"\"\"\n333         Return a ProjectState object representing the most recent state\n334         that the loaded migrations represent.\n335 \n336         See graph.make_state() for the meaning of \"nodes\" and \"at_end\".\n337         \"\"\"\n338         return self.graph.make_state(nodes=nodes, at_end=at_end, real_apps=self.unmigrated_apps)\n339 \n340     def collect_sql(self, plan):\n341         \"\"\"\n342         Take a migration plan and return a list of collected SQL statements\n343         that represent the best-efforts version of that plan.\n344         \"\"\"\n345         statements = []\n346         state = None\n347         for migration, backwards in plan:\n348             with self.connection.schema_editor(collect_sql=True, atomic=migration.atomic) as schema_editor:\n349                 if state is None:\n350                     state = self.project_state((migration.app_label, migration.name), at_end=False)\n351                 if not backwards:\n352                     state = migration.apply(state, schema_editor, collect_sql=True)\n353                 else:\n354                     state = migration.unapply(state, schema_editor, collect_sql=True)\n355             statements.extend(schema_editor.collected_sql)\n356         return statements\n",
        "intended_behavior": "This component should be enhanced to more accurately factor in squashed migrations when assessing the current migration landscape. It should ensure that when considering what the next migration number should be, it fully accounts for all existing migrations, including those that may have been squashed into a single file. The enhancement would likely involve adjusting the logic that tracks and identifies the highest current migration number, ensuring that it does not simply increment from the highest standalone migration but also considers the endpoint of squashed migrations."
    },
    {
        "rel_file_path": "django/core/management/commands/makemigrations.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/core/management/commands/makemigrations.py",
        "start": 1,
        "end": 333,
        "class_name": null,
        "method_name": null,
        "code": "1 import os\n2 import sys\n3 import warnings\n4 from itertools import takewhile\n5 \n6 from django.apps import apps\n7 from django.conf import settings\n8 from django.core.management.base import (\n9     BaseCommand, CommandError, no_translations,\n10 )\n11 from django.db import DEFAULT_DB_ALIAS, OperationalError, connections, router\n12 from django.db.migrations import Migration\n13 from django.db.migrations.autodetector import MigrationAutodetector\n14 from django.db.migrations.loader import MigrationLoader\n15 from django.db.migrations.questioner import (\n16     InteractiveMigrationQuestioner, MigrationQuestioner,\n17     NonInteractiveMigrationQuestioner,\n18 )\n19 from django.db.migrations.state import ProjectState\n20 from django.db.migrations.utils import get_migration_name_timestamp\n21 from django.db.migrations.writer import MigrationWriter\n22 \n23 \n24 class Command(BaseCommand):\n25     help = \"Creates new migration(s) for apps.\"\n26 \n27     def add_arguments(self, parser):\n28         parser.add_argument(\n29             'args', metavar='app_label', nargs='*',\n30             help='Specify the app label(s) to create migrations for.',\n31         )\n32         parser.add_argument(\n33             '--dry-run', action='store_true',\n34             help=\"Just show what migrations would be made; don't actually write them.\",\n35         )\n36         parser.add_argument(\n37             '--merge', action='store_true',\n38             help=\"Enable fixing of migration conflicts.\",\n39         )\n40         parser.add_argument(\n41             '--empty', action='store_true',\n42             help=\"Create an empty migration.\",\n43         )\n44         parser.add_argument(\n45             '--noinput', '--no-input', action='store_false', dest='interactive',\n46             help='Tells Django to NOT prompt the user for input of any kind.',\n47         )\n48         parser.add_argument(\n49             '-n', '--name',\n50             help=\"Use this name for migration file(s).\",\n51         )\n52         parser.add_argument(\n53             '--no-header', action='store_false', dest='include_header',\n54             help='Do not add header comments to new migration file(s).',\n55         )\n56         parser.add_argument(\n57             '--check', action='store_true', dest='check_changes',\n58             help='Exit with a non-zero status if model changes are missing migrations.',\n59         )\n60 \n61     def log(self, msg):\n62         self.stdout.write(msg)\n63 \n64     @no_translations\n65     def handle(self, *app_labels, **options):\n66         self.verbosity = options['verbosity']\n67         self.interactive = options['interactive']\n68         self.dry_run = options['dry_run']\n69         self.merge = options['merge']\n70         self.empty = options['empty']\n71         self.migration_name = options['name']\n72         if self.migration_name and not self.migration_name.isidentifier():\n73             raise CommandError('The migration name must be a valid Python identifier.')\n74         self.include_header = options['include_header']\n75         check_changes = options['check_changes']\n76 \n77         # Make sure the app they asked for exists\n78         app_labels = set(app_labels)\n79         has_bad_labels = False\n80         for app_label in app_labels:\n81             try:\n82                 apps.get_app_config(app_label)\n83             except LookupError as err:\n84                 self.stderr.write(str(err))\n85                 has_bad_labels = True\n86         if has_bad_labels:\n87             sys.exit(2)\n88 \n89         # Load the current graph state. Pass in None for the connection so\n90         # the loader doesn't try to resolve replaced migrations from DB.\n91         loader = MigrationLoader(None, ignore_no_migrations=True)\n92 \n93         # Raise an error if any migrations are applied before their dependencies.\n94         consistency_check_labels = {config.label for config in apps.get_app_configs()}\n95         # Non-default databases are only checked if database routers used.\n96         aliases_to_check = connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS]\n97         for alias in sorted(aliases_to_check):\n98             connection = connections[alias]\n99             if (connection.settings_dict['ENGINE'] != 'django.db.backends.dummy' and any(\n100                     # At least one model must be migrated to the database.\n101                     router.allow_migrate(connection.alias, app_label, model_name=model._meta.object_name)\n102                     for app_label in consistency_check_labels\n103                     for model in apps.get_app_config(app_label).get_models()\n104             )):\n105                 try:\n106                     loader.check_consistent_history(connection)\n107                 except OperationalError as error:\n108                     warnings.warn(\n109                         \"Got an error checking a consistent migration history \"\n110                         \"performed for database connection '%s': %s\"\n111                         % (alias, error),\n112                         RuntimeWarning,\n113                     )\n114         # Before anything else, see if there's conflicting apps and drop out\n115         # hard if there are any and they don't want to merge\n116         conflicts = loader.detect_conflicts()\n117 \n118         # If app_labels is specified, filter out conflicting migrations for unspecified apps\n119         if app_labels:\n120             conflicts = {\n121                 app_label: conflict for app_label, conflict in conflicts.items()\n122                 if app_label in app_labels\n123             }\n124 \n125         if conflicts and not self.merge:\n126             name_str = \"; \".join(\n127                 \"%s in %s\" % (\", \".join(names), app)\n128                 for app, names in conflicts.items()\n129             )\n130             raise CommandError(\n131                 \"Conflicting migrations detected; multiple leaf nodes in the \"\n132                 \"migration graph: (%s).\\nTo fix them run \"\n133                 \"'python manage.py makemigrations --merge'\" % name_str\n134             )\n135 \n136         # If they want to merge and there's nothing to merge, then politely exit\n137         if self.merge and not conflicts:\n138             self.log('No conflicts detected to merge.')\n139             return\n140 \n141         # If they want to merge and there is something to merge, then\n142         # divert into the merge code\n143         if self.merge and conflicts:\n144             return self.handle_merge(loader, conflicts)\n145 \n146         if self.interactive:\n147             questioner = InteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run)\n148         else:\n149             questioner = NonInteractiveMigrationQuestioner(\n150                 specified_apps=app_labels,\n151                 dry_run=self.dry_run,\n152                 verbosity=self.verbosity,\n153                 log=self.log,\n154             )\n155         # Set up autodetector\n156         autodetector = MigrationAutodetector(\n157             loader.project_state(),\n158             ProjectState.from_apps(apps),\n159             questioner,\n160         )\n161 \n162         # If they want to make an empty migration, make one for each app\n163         if self.empty:\n164             if not app_labels:\n165                 raise CommandError(\"You must supply at least one app label when using --empty.\")\n166             # Make a fake changes() result we can pass to arrange_for_graph\n167             changes = {\n168                 app: [Migration(\"custom\", app)]\n169                 for app in app_labels\n170             }\n171             changes = autodetector.arrange_for_graph(\n172                 changes=changes,\n173                 graph=loader.graph,\n174                 migration_name=self.migration_name,\n175             )\n176             self.write_migration_files(changes)\n177             return\n178 \n179         # Detect changes\n180         changes = autodetector.changes(\n181             graph=loader.graph,\n182             trim_to_apps=app_labels or None,\n183             convert_apps=app_labels or None,\n184             migration_name=self.migration_name,\n185         )\n186 \n187         if not changes:\n188             # No changes? Tell them.\n189             if self.verbosity >= 1:\n190                 if app_labels:\n191                     if len(app_labels) == 1:\n192                         self.log(\"No changes detected in app '%s'\" % app_labels.pop())\n193                     else:\n194                         self.log(\"No changes detected in apps '%s'\" % (\"', '\".join(app_labels)))\n195                 else:\n196                     self.log('No changes detected')\n197         else:\n198             self.write_migration_files(changes)\n199             if check_changes:\n200                 sys.exit(1)\n201 \n202     def write_migration_files(self, changes):\n203         \"\"\"\n204         Take a changes dict and write them out as migration files.\n205         \"\"\"\n206         directory_created = {}\n207         for app_label, app_migrations in changes.items():\n208             if self.verbosity >= 1:\n209                 self.log(self.style.MIGRATE_HEADING(\"Migrations for '%s':\" % app_label))\n210             for migration in app_migrations:\n211                 # Describe the migration\n212                 writer = MigrationWriter(migration, self.include_header)\n213                 if self.verbosity >= 1:\n214                     # Display a relative path if it's below the current working\n215                     # directory, or an absolute path otherwise.\n216                     try:\n217                         migration_string = os.path.relpath(writer.path)\n218                     except ValueError:\n219                         migration_string = writer.path\n220                     if migration_string.startswith('..'):\n221                         migration_string = writer.path\n222                     self.log('  %s\\n' % self.style.MIGRATE_LABEL(migration_string))\n223                     for operation in migration.operations:\n224                         self.log('    - %s' % operation.describe())\n225                 if not self.dry_run:\n226                     # Write the migrations file to the disk.\n227                     migrations_directory = os.path.dirname(writer.path)\n228                     if not directory_created.get(app_label):\n229                         os.makedirs(migrations_directory, exist_ok=True)\n230                         init_path = os.path.join(migrations_directory, \"__init__.py\")\n231                         if not os.path.isfile(init_path):\n232                             open(init_path, \"w\").close()\n233                         # We just do this once per app\n234                         directory_created[app_label] = True\n235                     migration_string = writer.as_string()\n236                     with open(writer.path, \"w\", encoding='utf-8') as fh:\n237                         fh.write(migration_string)\n238                 elif self.verbosity == 3:\n239                     # Alternatively, makemigrations --dry-run --verbosity 3\n240                     # will log the migrations rather than saving the file to\n241                     # the disk.\n242                     self.log(self.style.MIGRATE_HEADING(\n243                         \"Full migrations file '%s':\" % writer.filename\n244                     ))\n245                     self.log(writer.as_string())\n246 \n247     def handle_merge(self, loader, conflicts):\n248         \"\"\"\n249         Handles merging together conflicted migrations interactively,\n250         if it's safe; otherwise, advises on how to fix it.\n251         \"\"\"\n252         if self.interactive:\n253             questioner = InteractiveMigrationQuestioner()\n254         else:\n255             questioner = MigrationQuestioner(defaults={'ask_merge': True})\n256 \n257         for app_label, migration_names in conflicts.items():\n258             # Grab out the migrations in question, and work out their\n259             # common ancestor.\n260             merge_migrations = []\n261             for migration_name in migration_names:\n262                 migration = loader.get_migration(app_label, migration_name)\n263                 migration.ancestry = [\n264                     mig for mig in loader.graph.forwards_plan((app_label, migration_name))\n265                     if mig[0] == migration.app_label\n266                 ]\n267                 merge_migrations.append(migration)\n268 \n269             def all_items_equal(seq):\n270                 return all(item == seq[0] for item in seq[1:])\n271 \n272             merge_migrations_generations = zip(*(m.ancestry for m in merge_migrations))\n273             common_ancestor_count = sum(1 for common_ancestor_generation\n274                                         in takewhile(all_items_equal, merge_migrations_generations))\n275             if not common_ancestor_count:\n276                 raise ValueError(\"Could not find common ancestor of %s\" % migration_names)\n277             # Now work out the operations along each divergent branch\n278             for migration in merge_migrations:\n279                 migration.branch = migration.ancestry[common_ancestor_count:]\n280                 migrations_ops = (loader.get_migration(node_app, node_name).operations\n281                                   for node_app, node_name in migration.branch)\n282                 migration.merged_operations = sum(migrations_ops, [])\n283             # In future, this could use some of the Optimizer code\n284             # (can_optimize_through) to automatically see if they're\n285             # mergeable. For now, we always just prompt the user.\n286             if self.verbosity > 0:\n287                 self.log(self.style.MIGRATE_HEADING('Merging %s' % app_label))\n288                 for migration in merge_migrations:\n289                     self.log(self.style.MIGRATE_LABEL('  Branch %s' % migration.name))\n290                     for operation in migration.merged_operations:\n291                         self.log('    - %s' % operation.describe())\n292             if questioner.ask_merge(app_label):\n293                 # If they still want to merge it, then write out an empty\n294                 # file depending on the migrations needing merging.\n295                 numbers = [\n296                     MigrationAutodetector.parse_number(migration.name)\n297                     for migration in merge_migrations\n298                 ]\n299                 try:\n300                     biggest_number = max(x for x in numbers if x is not None)\n301                 except ValueError:\n302                     biggest_number = 1\n303                 subclass = type(\"Migration\", (Migration,), {\n304                     \"dependencies\": [(app_label, migration.name) for migration in merge_migrations],\n305                 })\n306                 parts = ['%04i' % (biggest_number + 1)]\n307                 if self.migration_name:\n308                     parts.append(self.migration_name)\n309                 else:\n310                     parts.append('merge')\n311                     leaf_names = '_'.join(sorted(migration.name for migration in merge_migrations))\n312                     if len(leaf_names) > 47:\n313                         parts.append(get_migration_name_timestamp())\n314                     else:\n315                         parts.append(leaf_names)\n316                 migration_name = '_'.join(parts)\n317                 new_migration = subclass(migration_name, app_label)\n318                 writer = MigrationWriter(new_migration, self.include_header)\n319 \n320                 if not self.dry_run:\n321                     # Write the merge migrations file to the disk\n322                     with open(writer.path, \"w\", encoding='utf-8') as fh:\n323                         fh.write(writer.as_string())\n324                     if self.verbosity > 0:\n325                         self.log('\\nCreated new merge migration %s' % writer.path)\n326                 elif self.verbosity == 3:\n327                     # Alternatively, makemigrations --merge --dry-run --verbosity 3\n328                     # will log the merge migrations rather than saving the file\n329                     # to the disk.\n330                     self.log(self.style.MIGRATE_HEADING(\n331                         \"Full merge migrations file '%s':\" % writer.filename\n332                     ))\n333                     self.log(writer.as_string())\n",
        "intended_behavior": "The adjustments needed aren't tied to a specific method discovered in our searches, suggesting the logic that determines new migration numbers is distributed or abstracted away from a single point in the code. Ideally, the process leading up to invoking `MigrationWriter` to create a new migration file should be scrutinized to ensure it accurately considers the entirety of migration history, including squashed migrations. This might involve augmenting the methodology to assess current migrations, possibly involving adjustments or enhancements in several areas including the initial gathering of migration states, processing of the migration graph to consider squashed migrations, and the final decision logic for numbering new migrations."
    }
]