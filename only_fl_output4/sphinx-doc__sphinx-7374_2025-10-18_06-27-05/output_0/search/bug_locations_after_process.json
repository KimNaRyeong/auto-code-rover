[
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 1077,
        "end": 1300,
        "class_name": "PythonDomain",
        "method_name": null,
        "code": "1077 class PythonDomain(Domain):\n1078     \"\"\"Python language domain.\"\"\"\n1079     name = 'py'\n1080     label = 'Python'\n1081     object_types = {\n1082         'function':     ObjType(_('function'),      'func', 'obj'),\n1083         'data':         ObjType(_('data'),          'data', 'obj'),\n1084         'class':        ObjType(_('class'),         'class', 'exc', 'obj'),\n1085         'exception':    ObjType(_('exception'),     'exc', 'class', 'obj'),\n1086         'method':       ObjType(_('method'),        'meth', 'obj'),\n1087         'classmethod':  ObjType(_('class method'),  'meth', 'obj'),\n1088         'staticmethod': ObjType(_('static method'), 'meth', 'obj'),\n1089         'attribute':    ObjType(_('attribute'),     'attr', 'obj'),\n1090         'module':       ObjType(_('module'),        'mod', 'obj'),\n1091     }  # type: Dict[str, ObjType]\n1092 \n1093     directives = {\n1094         'function':        PyFunction,\n1095         'data':            PyVariable,\n1096         'class':           PyClasslike,\n1097         'exception':       PyClasslike,\n1098         'method':          PyMethod,\n1099         'classmethod':     PyClassMethod,\n1100         'staticmethod':    PyStaticMethod,\n1101         'attribute':       PyAttribute,\n1102         'module':          PyModule,\n1103         'currentmodule':   PyCurrentModule,\n1104         'decorator':       PyDecoratorFunction,\n1105         'decoratormethod': PyDecoratorMethod,\n1106     }\n1107     roles = {\n1108         'data':  PyXRefRole(),\n1109         'exc':   PyXRefRole(),\n1110         'func':  PyXRefRole(fix_parens=True),\n1111         'class': PyXRefRole(),\n1112         'const': PyXRefRole(),\n1113         'attr':  PyXRefRole(),\n1114         'meth':  PyXRefRole(fix_parens=True),\n1115         'mod':   PyXRefRole(),\n1116         'obj':   PyXRefRole(),\n1117     }\n1118     initial_data = {\n1119         'objects': {},  # fullname -> docname, objtype\n1120         'modules': {},  # modname -> docname, synopsis, platform, deprecated\n1121     }  # type: Dict[str, Dict[str, Tuple[Any]]]\n1122     indices = [\n1123         PythonModuleIndex,\n1124     ]\n1125 \n1126     @property\n1127     def objects(self) -> Dict[str, Tuple[str, str, str]]:\n1128         return self.data.setdefault('objects', {})  # fullname -> docname, node_id, objtype\n1129 \n1130     def note_object(self, name: str, objtype: str, node_id: str, location: Any = None) -> None:\n1131         \"\"\"Note a python object for cross reference.\n1132 \n1133         .. versionadded:: 2.1\n1134         \"\"\"\n1135         if name in self.objects:\n1136             docname = self.objects[name][0]\n1137             logger.warning(__('duplicate object description of %s, '\n1138                               'other instance in %s, use :noindex: for one of them'),\n1139                            name, docname, location=location)\n1140         self.objects[name] = (self.env.docname, node_id, objtype)\n1141 \n1142     @property\n1143     def modules(self) -> Dict[str, Tuple[str, str, str, str, bool]]:\n1144         return self.data.setdefault('modules', {})  # modname -> docname, node_id, synopsis, platform, deprecated  # NOQA\n1145 \n1146     def note_module(self, name: str, node_id: str, synopsis: str,\n1147                     platform: str, deprecated: bool) -> None:\n1148         \"\"\"Note a python module for cross reference.\n1149 \n1150         .. versionadded:: 2.1\n1151         \"\"\"\n1152         self.modules[name] = (self.env.docname, node_id, synopsis, platform, deprecated)\n1153 \n1154     def clear_doc(self, docname: str) -> None:\n1155         for fullname, (fn, _x, _x) in list(self.objects.items()):\n1156             if fn == docname:\n1157                 del self.objects[fullname]\n1158         for modname, (fn, _x, _x, _x, _y) in list(self.modules.items()):\n1159             if fn == docname:\n1160                 del self.modules[modname]\n1161 \n1162     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n1163         # XXX check duplicates?\n1164         for fullname, (fn, node_id, objtype) in otherdata['objects'].items():\n1165             if fn in docnames:\n1166                 self.objects[fullname] = (fn, node_id, objtype)\n1167         for modname, data in otherdata['modules'].items():\n1168             if data[0] in docnames:\n1169                 self.modules[modname] = data\n1170 \n1171     def find_obj(self, env: BuildEnvironment, modname: str, classname: str,\n1172                  name: str, type: str, searchmode: int = 0\n1173                  ) -> List[Tuple[str, Tuple[str, str, str]]]:\n1174         \"\"\"Find a Python object for \"name\", perhaps using the given module\n1175         and/or classname.  Returns a list of (name, object entry) tuples.\n1176         \"\"\"\n1177         # skip parens\n1178         if name[-2:] == '()':\n1179             name = name[:-2]\n1180 \n1181         if not name:\n1182             return []\n1183 \n1184         matches = []  # type: List[Tuple[str, Tuple[str, str, str]]]\n1185 \n1186         newname = None\n1187         if searchmode == 1:\n1188             if type is None:\n1189                 objtypes = list(self.object_types)\n1190             else:\n1191                 objtypes = self.objtypes_for_role(type)\n1192             if objtypes is not None:\n1193                 if modname and classname:\n1194                     fullname = modname + '.' + classname + '.' + name\n1195                     if fullname in self.objects and self.objects[fullname][2] in objtypes:\n1196                         newname = fullname\n1197                 if not newname:\n1198                     if modname and modname + '.' + name in self.objects and \\\n1199                        self.objects[modname + '.' + name][2] in objtypes:\n1200                         newname = modname + '.' + name\n1201                     elif name in self.objects and self.objects[name][2] in objtypes:\n1202                         newname = name\n1203                     else:\n1204                         # \"fuzzy\" searching mode\n1205                         searchname = '.' + name\n1206                         matches = [(oname, self.objects[oname]) for oname in self.objects\n1207                                    if oname.endswith(searchname) and\n1208                                    self.objects[oname][2] in objtypes]\n1209         else:\n1210             # NOTE: searching for exact match, object type is not considered\n1211             if name in self.objects:\n1212                 newname = name\n1213             elif type == 'mod':\n1214                 # only exact matches allowed for modules\n1215                 return []\n1216             elif classname and classname + '.' + name in self.objects:\n1217                 newname = classname + '.' + name\n1218             elif modname and modname + '.' + name in self.objects:\n1219                 newname = modname + '.' + name\n1220             elif modname and classname and \\\n1221                     modname + '.' + classname + '.' + name in self.objects:\n1222                 newname = modname + '.' + classname + '.' + name\n1223         if newname is not None:\n1224             matches.append((newname, self.objects[newname]))\n1225         return matches\n1226 \n1227     def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n1228                      type: str, target: str, node: pending_xref, contnode: Element\n1229                      ) -> Element:\n1230         modname = node.get('py:module')\n1231         clsname = node.get('py:class')\n1232         searchmode = 1 if node.hasattr('refspecific') else 0\n1233         matches = self.find_obj(env, modname, clsname, target,\n1234                                 type, searchmode)\n1235 \n1236         if not matches and type == 'attr':\n1237             # fallback to meth (for property)\n1238             matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)\n1239 \n1240         if not matches:\n1241             return None\n1242         elif len(matches) > 1:\n1243             logger.warning(__('more than one target found for cross-reference %r: %s'),\n1244                            target, ', '.join(match[0] for match in matches),\n1245                            type='ref', subtype='python', location=node)\n1246         name, obj = matches[0]\n1247 \n1248         if obj[2] == 'module':\n1249             return self._make_module_refnode(builder, fromdocname, name, contnode)\n1250         else:\n1251             return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)\n1252 \n1253     def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n1254                          target: str, node: pending_xref, contnode: Element\n1255                          ) -> List[Tuple[str, Element]]:\n1256         modname = node.get('py:module')\n1257         clsname = node.get('py:class')\n1258         results = []  # type: List[Tuple[str, Element]]\n1259 \n1260         # always search in \"refspecific\" mode with the :any: role\n1261         matches = self.find_obj(env, modname, clsname, target, None, 1)\n1262         for name, obj in matches:\n1263             if obj[2] == 'module':\n1264                 results.append(('py:mod',\n1265                                 self._make_module_refnode(builder, fromdocname,\n1266                                                           name, contnode)))\n1267             else:\n1268                 results.append(('py:' + self.role_for_objtype(obj[2]),\n1269                                 make_refnode(builder, fromdocname, obj[0], obj[1],\n1270                                              contnode, name)))\n1271         return results\n1272 \n1273     def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,\n1274                              contnode: Node) -> Element:\n1275         # get additional info for modules\n1276         docname, node_id, synopsis, platform, deprecated = self.modules[name]\n1277         title = name\n1278         if synopsis:\n1279             title += ': ' + synopsis\n1280         if deprecated:\n1281             title += _(' (deprecated)')\n1282         if platform:\n1283             title += ' (' + platform + ')'\n1284         return make_refnode(builder, fromdocname, docname, node_id, contnode, title)\n1285 \n1286     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:\n1287         for modname, info in self.modules.items():\n1288             yield (modname, modname, 'module', info[0], info[1], 0)\n1289         for refname, (docname, node_id, type) in self.objects.items():\n1290             if type != 'module':  # modules are already handled\n1291                 yield (refname, refname, type, docname, node_id, 1)\n1292 \n1293     def get_full_qualified_name(self, node: Element) -> str:\n1294         modname = node.get('py:module')\n1295         clsname = node.get('py:class')\n1296         target = node.get('reftarget')\n1297         if target is None:\n1298             return None\n1299         else:\n1300             return '.'.join(filter(None, [modname, clsname, target]))\n",
        "intended_behavior": "The `PythonDomain` class should ensure that when Python function names are translated to fragment identifiers, they retain their original character format, including underscores, to maintain backward compatibility with existing external and internal links. If this class or its methods directly or indirectly influence how fragment identifiers are generated (especially in converting identifiers to a web-friendly format), it should either avoid changing underscores to dashes for Python functions or provide a configurable option to dictate this behavior. This preserves the functionality of accurately referencing Python functions in the documentation while preventing the breaking of links due to identifier format changes."
    }
]