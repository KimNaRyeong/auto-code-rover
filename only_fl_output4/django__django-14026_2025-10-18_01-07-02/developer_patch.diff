diff --git a/django/contrib/postgres/aggregates/general.py b/django/contrib/postgres/aggregates/general.py
--- a/django/contrib/postgres/aggregates/general.py
+++ b/django/contrib/postgres/aggregates/general.py
@@ -1,5 +1,8 @@
+import warnings
+
 from django.contrib.postgres.fields import ArrayField
 from django.db.models import Aggregate, BooleanField, JSONField, Value
+from django.utils.deprecation import RemovedInDjango50Warning
 
 from .mixins import OrderableAggMixin
 
@@ -8,20 +11,44 @@
 ]
 
 
-class ArrayAgg(OrderableAggMixin, Aggregate):
+# RemovedInDjango50Warning
+NOT_PROVIDED = object()
+
+
+class DeprecatedConvertValueMixin:
+    def __init__(self, *expressions, default=NOT_PROVIDED, **extra):
+        if default is NOT_PROVIDED:
+            default = None
+            self._default_provided = False
+        else:
+            self._default_provided = True
+        super().__init__(*expressions, default=default, **extra)
+
+    def convert_value(self, value, expression, connection):
+        if value is None and not self._default_provided:
+            warnings.warn(self.deprecation_msg, category=RemovedInDjango50Warning)
+            return self.deprecation_value
+        return value
+
+
+class ArrayAgg(DeprecatedConvertValueMixin, OrderableAggMixin, Aggregate):
     function = 'ARRAY_AGG'
     template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'
     allow_distinct = True
 
+    # RemovedInDjango50Warning
+    deprecation_value = property(lambda self: [])
+    deprecation_msg = (
+        'In Django 5.0, ArrayAgg() will return None instead of an empty list '
+        'if there are no rows. Pass default=None to opt into the new behavior '
+        'and silence this warning or default=Value([]) to keep the previous '
+        'behavior.'
+    )
+
     @property
     def output_field(self):
         return ArrayField(self.source_expressions[0].output_field)
 
-    def convert_value(self, value, expression, connection):
-        if not value:
-            return []
-        return value
-
 
 class BitAnd(Aggregate):
     function = 'BIT_AND'
@@ -41,28 +68,36 @@ class BoolOr(Aggregate):
     output_field = BooleanField()
 
 
-class JSONBAgg(OrderableAggMixin, Aggregate):
+class JSONBAgg(DeprecatedConvertValueMixin, OrderableAggMixin, Aggregate):
     function = 'JSONB_AGG'
     template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'
     allow_distinct = True
     output_field = JSONField()
 
-    def convert_value(self, value, expression, connection):
-        if not value:
-            return '[]'
-        return value
+    # RemovedInDjango50Warning
+    deprecation_value = '[]'
+    deprecation_msg = (
+        "In Django 5.0, JSONBAgg() will return None instead of an empty list "
+        "if there are no rows. Pass default=None to opt into the new behavior "
+        "and silence this warning or default=Value('[]') to keep the previous "
+        "behavior."
+    )
 
 
-class StringAgg(OrderableAggMixin, Aggregate):
+class StringAgg(DeprecatedConvertValueMixin, OrderableAggMixin, Aggregate):
     function = 'STRING_AGG'
     template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'
     allow_distinct = True
 
+    # RemovedInDjango50Warning
+    deprecation_value = ''
+    deprecation_msg = (
+        "In Django 5.0, StringAgg() will return None instead of an empty "
+        "string if there are no rows. Pass default=None to opt into the new "
+        "behavior and silence this warning or default=Value('') to keep the "
+        "previous behavior."
+    )
+
     def __init__(self, expression, delimiter, **extra):
         delimiter_expr = Value(str(delimiter))
         super().__init__(expression, delimiter_expr, **extra)
-
-    def convert_value(self, value, expression, connection):
-        if not value:
-            return ''
-        return value
diff --git a/django/contrib/postgres/aggregates/statistics.py b/django/contrib/postgres/aggregates/statistics.py
--- a/django/contrib/postgres/aggregates/statistics.py
+++ b/django/contrib/postgres/aggregates/statistics.py
@@ -9,10 +9,10 @@
 class StatAggregate(Aggregate):
     output_field = FloatField()
 
-    def __init__(self, y, x, output_field=None, filter=None):
+    def __init__(self, y, x, output_field=None, filter=None, default=None):
         if not x or not y:
             raise ValueError('Both y and x must be provided.')
-        super().__init__(y, x, output_field=output_field, filter=filter)
+        super().__init__(y, x, output_field=output_field, filter=filter, default=default)
 
 
 class Corr(StatAggregate):
@@ -20,9 +20,9 @@ class Corr(StatAggregate):
 
 
 class CovarPop(StatAggregate):
-    def __init__(self, y, x, sample=False, filter=None):
+    def __init__(self, y, x, sample=False, filter=None, default=None):
         self.function = 'COVAR_SAMP' if sample else 'COVAR_POP'
-        super().__init__(y, x, filter=filter)
+        super().__init__(y, x, filter=filter, default=default)
 
 
 class RegrAvgX(StatAggregate):
diff --git a/django/db/backends/mysql/features.py b/django/db/backends/mysql/features.py
--- a/django/db/backends/mysql/features.py
+++ b/django/db/backends/mysql/features.py
@@ -88,6 +88,17 @@ def django_test_skips(self):
                     'annotations.tests.NonAggregateAnnotationTestCase.test_annotation_aggregate_with_m2o',
                 },
             })
+        if not self.connection.mysql_is_mariadb and self.connection.mysql_version < (8,):
+            skips.update({
+                'Casting to datetime/time is not supported by MySQL < 8.0. (#30224)': {
+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_time_from_python',
+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_datetime_from_python',
+                },
+                'MySQL < 8.0 returns string type instead of datetime/time. (#30224)': {
+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_time_from_database',
+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_datetime_from_database',
+                },
+            })
         if (
             self.connection.mysql_is_mariadb and
             (10, 4, 3) < self.connection.mysql_version < (10, 5, 2)
diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -4,6 +4,7 @@
 from django.core.exceptions import FieldError
 from django.db.models.expressions import Case, Func, Star, When
 from django.db.models.fields import IntegerField
+from django.db.models.functions.comparison import Coalesce
 from django.db.models.functions.mixins import (
     FixDurationInputMixin, NumericOutputFieldMixin,
 )
@@ -22,11 +23,14 @@ class Aggregate(Func):
     allow_distinct = False
     empty_aggregate_value = None
 
-    def __init__(self, *expressions, distinct=False, filter=None, **extra):
+    def __init__(self, *expressions, distinct=False, filter=None, default=None, **extra):
         if distinct and not self.allow_distinct:
             raise TypeError("%s does not allow distinct." % self.__class__.__name__)
+        if default is not None and self.empty_aggregate_value is not None:
+            raise TypeError(f'{self.__class__.__name__} does not allow default.')
         self.distinct = distinct
         self.filter = filter
+        self.default = default
         super().__init__(*expressions, **extra)
 
     def get_source_fields(self):
@@ -56,7 +60,12 @@ def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize
                     before_resolved = self.get_source_expressions()[index]
                     name = before_resolved.name if hasattr(before_resolved, 'name') else repr(before_resolved)
                     raise FieldError("Cannot compute %s('%s'): '%s' is an aggregate" % (c.name, name, name))
-        return c
+        if (default := c.default) is None:
+            return c
+        if hasattr(default, 'resolve_expression'):
+            default = default.resolve_expression(query, allow_joins, reuse, summarize)
+        c.default = None  # Reset the default argument before wrapping.
+        return Coalesce(c, default, output_field=c._output_field_or_none)
 
     @property
     def default_alias(self):
