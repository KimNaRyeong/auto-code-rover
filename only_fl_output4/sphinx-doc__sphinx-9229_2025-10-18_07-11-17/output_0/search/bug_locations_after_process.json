[
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.1/sphinx/application.py",
        "start": 1093,
        "end": 1114,
        "class_name": "Sphinx",
        "method_name": "add_autodocumenter",
        "code": "1093     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:\n1094         \"\"\"Register a new documenter class for the autodoc extension.\n1095 \n1096         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`\n1097         extension.  It must be a subclass of\n1098         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document\n1099         new types of objects.  See the source of the autodoc module for\n1100         examples on how to subclass :class:`Documenter`.\n1101 \n1102         If *override* is True, the given *cls* is forcedly installed even if\n1103         a documenter having the same name is already installed.\n1104 \n1105         See :ref:`autodoc_ext_tutorial`.\n1106 \n1107         .. versionadded:: 0.6\n1108         .. versionchanged:: 2.2\n1109            Add *override* keyword.\n1110         \"\"\"\n1111         logger.debug('[app] adding autodocumenter: %r', cls)\n1112         from sphinx.ext.autodoc.directive import AutodocDirective\n1113         self.registry.add_documenter(cls.objtype, cls)\n1114         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n",
        "intended_behavior": "The `add_autodocumenter` method should ensure that a documenter that is capable of handling type aliases is registered and used when generating documentation."
    },
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.1/sphinx/application.py",
        "start": 126,
        "end": 1265,
        "class_name": "Sphinx",
        "method_name": null,
        "code": "126 class Sphinx:\n127     \"\"\"The main application class and extensibility interface.\n128 \n129     :ivar srcdir: Directory containing source.\n130     :ivar confdir: Directory containing ``conf.py``.\n131     :ivar doctreedir: Directory for storing pickled doctrees.\n132     :ivar outdir: Directory for storing build documents.\n133     \"\"\"\n134 \n135     warningiserror: bool\n136     _warncount: int\n137 \n138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,\n139                  buildername: str, confoverrides: Dict = None,\n140                  status: IO = sys.stdout, warning: IO = sys.stderr,\n141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,\n142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:\n143         self.phase = BuildPhase.INITIALIZATION\n144         self.verbosity = verbosity\n145         self.extensions: Dict[str, Extension] = {}\n146         self.builder: Optional[Builder] = None\n147         self.env: Optional[BuildEnvironment] = None\n148         self.project: Optional[Project] = None\n149         self.registry = SphinxComponentRegistry()\n150 \n151         # validate provided directories\n152         self.srcdir = abspath(srcdir)\n153         self.outdir = abspath(outdir)\n154         self.doctreedir = abspath(doctreedir)\n155         self.confdir = confdir\n156         if self.confdir:  # confdir is optional\n157             self.confdir = abspath(self.confdir)\n158             if not path.isfile(path.join(self.confdir, 'conf.py')):\n159                 raise ApplicationError(__(\"config directory doesn't contain a \"\n160                                           \"conf.py file (%s)\") % confdir)\n161 \n162         if not path.isdir(self.srcdir):\n163             raise ApplicationError(__('Cannot find source directory (%s)') %\n164                                    self.srcdir)\n165 \n166         if path.exists(self.outdir) and not path.isdir(self.outdir):\n167             raise ApplicationError(__('Output directory (%s) is not a directory') %\n168                                    self.outdir)\n169 \n170         if self.srcdir == self.outdir:\n171             raise ApplicationError(__('Source directory and destination '\n172                                       'directory cannot be identical'))\n173 \n174         self.parallel = parallel\n175 \n176         if status is None:\n177             self._status: IO = StringIO()\n178             self.quiet: bool = True\n179         else:\n180             self._status = status\n181             self.quiet = False\n182 \n183         if warning is None:\n184             self._warning: IO = StringIO()\n185         else:\n186             self._warning = warning\n187         self._warncount = 0\n188         self.keep_going = warningiserror and keep_going\n189         if self.keep_going:\n190             self.warningiserror = False\n191         else:\n192             self.warningiserror = warningiserror\n193         logging.setup(self, self._status, self._warning)\n194 \n195         self.events = EventManager(self)\n196 \n197         # keep last few messages for traceback\n198         # This will be filled by sphinx.util.logging.LastMessagesWriter\n199         self.messagelog: deque = deque(maxlen=10)\n200 \n201         # say hello to the world\n202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))\n203 \n204         # notice for parallel build on macOS and py38+\n205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:\n206             logger.info(bold(__(\"For security reason, parallel mode is disabled on macOS and \"\n207                                 \"python3.8 and above. For more details, please read \"\n208                                 \"https://github.com/sphinx-doc/sphinx/issues/6803\")))\n209 \n210         # status code for command-line application\n211         self.statuscode = 0\n212 \n213         # read config\n214         self.tags = Tags(tags)\n215         if self.confdir is None:\n216             self.config = Config({}, confoverrides or {})\n217         else:\n218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)\n219 \n220         # initialize some limited config variables before initialize i18n and loading\n221         # extensions\n222         self.config.pre_init_values()\n223 \n224         # set up translation infrastructure\n225         self._init_i18n()\n226 \n227         # check the Sphinx version if requested\n228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:\n229             raise VersionRequirementError(\n230                 __('This project needs at least Sphinx v%s and therefore cannot '\n231                    'be built with this version.') % self.config.needs_sphinx)\n232 \n233         # set confdir to srcdir if -C given (!= no confdir); a few pieces\n234         # of code expect a confdir to be set\n235         if self.confdir is None:\n236             self.confdir = self.srcdir\n237 \n238         # load all built-in extension modules\n239         for extension in builtin_extensions:\n240             self.setup_extension(extension)\n241 \n242         # load all user-given extension modules\n243         for extension in self.config.extensions:\n244             self.setup_extension(extension)\n245 \n246         # preload builder module (before init config values)\n247         self.preload_builder(buildername)\n248 \n249         if not path.isdir(outdir):\n250             with progress_message(__('making output directory')):\n251                 ensuredir(outdir)\n252 \n253         # the config file itself can be an extension\n254         if self.config.setup:\n255             prefix = __('while setting up extension %s:') % \"conf.py\"\n256             with prefixed_warnings(prefix):\n257                 if callable(self.config.setup):\n258                     self.config.setup(self)\n259                 else:\n260                     raise ConfigError(\n261                         __(\"'setup' as currently defined in conf.py isn't a Python callable. \"\n262                            \"Please modify its definition to make it a callable function. \"\n263                            \"This is needed for conf.py to behave as a Sphinx extension.\")\n264                     )\n265 \n266         # now that we know all config values, collect them from conf.py\n267         self.config.init_values()\n268         self.events.emit('config-inited', self.config)\n269 \n270         # create the project\n271         self.project = Project(self.srcdir, self.config.source_suffix)\n272         # create the builder\n273         self.builder = self.create_builder(buildername)\n274         # set up the build environment\n275         self._init_env(freshenv)\n276         # set up the builder\n277         self._init_builder()\n278 \n279     def _init_i18n(self) -> None:\n280         \"\"\"Load translated strings from the configured localedirs if enabled in\n281         the configuration.\n282         \"\"\"\n283         if self.config.language is None:\n284             self.translator, has_translation = locale.init([], None)\n285         else:\n286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),\n287                         nonl=True)\n288 \n289             # compile mo files if sphinx.po file in user locale directories are updated\n290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n291                                      self.config.language, self.config.source_encoding)\n292             for catalog in repo.catalogs:\n293                 if catalog.domain == 'sphinx' and catalog.is_outdated():\n294                     catalog.write_mo(self.config.language)\n295 \n296             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)\n297             locale_dirs += [None]\n298             locale_dirs += [path.join(package_dir, 'locale')]\n299 \n300             self.translator, has_translation = locale.init(locale_dirs, self.config.language)\n301             if has_translation or self.config.language == 'en':\n302                 # \"en\" never needs to be translated\n303                 logger.info(__('done'))\n304             else:\n305                 logger.info(__('not available for built-in messages'))\n306 \n307     def _init_env(self, freshenv: bool) -> None:\n308         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n309         if freshenv or not os.path.exists(filename):\n310             self.env = BuildEnvironment()\n311             self.env.setup(self)\n312             self.env.find_files(self.config, self.builder)\n313         else:\n314             try:\n315                 with progress_message(__('loading pickled environment')):\n316                     with open(filename, 'rb') as f:\n317                         self.env = pickle.load(f)\n318                         self.env.setup(self)\n319             except Exception as err:\n320                 logger.info(__('failed: %s'), err)\n321                 self._init_env(freshenv=True)\n322 \n323     def preload_builder(self, name: str) -> None:\n324         self.registry.preload_builder(self, name)\n325 \n326     def create_builder(self, name: str) -> \"Builder\":\n327         if name is None:\n328             logger.info(__('No builder selected, using default: html'))\n329             name = 'html'\n330 \n331         return self.registry.create_builder(self, name)\n332 \n333     def _init_builder(self) -> None:\n334         self.builder.set_environment(self.env)\n335         self.builder.init()\n336         self.events.emit('builder-inited')\n337 \n338     # ---- main \"build\" method -------------------------------------------------\n339 \n340     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:\n341         self.phase = BuildPhase.READING\n342         try:\n343             if force_all:\n344                 self.builder.compile_all_catalogs()\n345                 self.builder.build_all()\n346             elif filenames:\n347                 self.builder.compile_specific_catalogs(filenames)\n348                 self.builder.build_specific(filenames)\n349             else:\n350                 self.builder.compile_update_catalogs()\n351                 self.builder.build_update()\n352 \n353             if self._warncount and self.keep_going:\n354                 self.statuscode = 1\n355 \n356             status = (__('succeeded') if self.statuscode == 0\n357                       else __('finished with problems'))\n358             if self._warncount:\n359                 if self.warningiserror:\n360                     if self._warncount == 1:\n361                         msg = __('build %s, %s warning (with warnings treated as errors).')\n362                     else:\n363                         msg = __('build %s, %s warnings (with warnings treated as errors).')\n364                 else:\n365                     if self._warncount == 1:\n366                         msg = __('build %s, %s warning.')\n367                     else:\n368                         msg = __('build %s, %s warnings.')\n369 \n370                 logger.info(bold(msg % (status, self._warncount)))\n371             else:\n372                 logger.info(bold(__('build %s.') % status))\n373 \n374             if self.statuscode == 0 and self.builder.epilog:\n375                 logger.info('')\n376                 logger.info(self.builder.epilog % {\n377                     'outdir': relpath(self.outdir),\n378                     'project': self.config.project\n379                 })\n380         except Exception as err:\n381             # delete the saved env to force a fresh build next time\n382             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n383             if path.isfile(envfile):\n384                 os.unlink(envfile)\n385             self.events.emit('build-finished', err)\n386             raise\n387         else:\n388             self.events.emit('build-finished', None)\n389         self.builder.cleanup()\n390 \n391     # ---- general extensibility interface -------------------------------------\n392 \n393     def setup_extension(self, extname: str) -> None:\n394         \"\"\"Import and setup a Sphinx extension module.\n395 \n396         Load the extension given by the module *name*.  Use this if your\n397         extension needs the features provided by another extension.  No-op if\n398         called twice.\n399         \"\"\"\n400         logger.debug('[app] setting up extension: %r', extname)\n401         self.registry.load_extension(self, extname)\n402 \n403     def require_sphinx(self, version: str) -> None:\n404         \"\"\"Check the Sphinx version if requested.\n405 \n406         Compare *version* with the version of the running Sphinx, and abort the\n407         build when it is too old.\n408 \n409         :param version: The required version in the form of ``major.minor``.\n410 \n411         .. versionadded:: 1.0\n412         \"\"\"\n413         if version > sphinx.__display_version__[:3]:\n414             raise VersionRequirementError(version)\n415 \n416     # event interface\n417     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:\n418         \"\"\"Register *callback* to be called when *event* is emitted.\n419 \n420         For details on available core events and the arguments of callback\n421         functions, please see :ref:`events`.\n422 \n423         :param event: The name of target event\n424         :param callback: Callback function for the event\n425         :param priority: The priority of the callback.  The callbacks will be invoked\n426                          in the order of *priority* in asending.\n427         :return: A listener ID.  It can be used for :meth:`disconnect`.\n428 \n429         .. versionchanged:: 3.0\n430 \n431            Support *priority*\n432         \"\"\"\n433         listener_id = self.events.connect(event, callback, priority)\n434         logger.debug('[app] connecting event %r (%d): %r [id=%s]',\n435                      event, priority, callback, listener_id)\n436         return listener_id\n437 \n438     def disconnect(self, listener_id: int) -> None:\n439         \"\"\"Unregister callback by *listener_id*.\n440 \n441         :param listener_id: A listener_id that :meth:`connect` returns\n442         \"\"\"\n443         logger.debug('[app] disconnecting event: [id=%s]', listener_id)\n444         self.events.disconnect(listener_id)\n445 \n446     def emit(self, event: str, *args: Any,\n447              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:\n448         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n449 \n450         Return the return values of all callbacks as a list.  Do not emit core\n451         Sphinx events in extensions!\n452 \n453         :param event: The name of event that will be emitted\n454         :param args: The arguments for the event\n455         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks\n456 \n457         .. versionchanged:: 3.1\n458 \n459            Added *allowed_exceptions* to specify path-through exceptions\n460         \"\"\"\n461         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)\n462 \n463     def emit_firstresult(self, event: str, *args: Any,\n464                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:\n465         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n466 \n467         Return the result of the first callback that doesn't return ``None``.\n468 \n469         :param event: The name of event that will be emitted\n470         :param args: The arguments for the event\n471         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks\n472 \n473         .. versionadded:: 0.5\n474         .. versionchanged:: 3.1\n475 \n476            Added *allowed_exceptions* to specify path-through exceptions\n477         \"\"\"\n478         return self.events.emit_firstresult(event, *args,\n479                                             allowed_exceptions=allowed_exceptions)\n480 \n481     # registering addon parts\n482 \n483     def add_builder(self, builder: Type[\"Builder\"], override: bool = False) -> None:\n484         \"\"\"Register a new builder.\n485 \n486         :param builder: A builder class\n487         :param override: If true, install the builder forcedly even if another builder\n488                          is already installed as the same name\n489 \n490         .. versionchanged:: 1.8\n491            Add *override* keyword.\n492         \"\"\"\n493         self.registry.add_builder(builder, override=override)\n494 \n495     # TODO(stephenfin): Describe 'types' parameter\n496     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],\n497                          types: Any = ()) -> None:\n498         \"\"\"Register a configuration value.\n499 \n500         This is necessary for Sphinx to recognize new values and set default\n501         values accordingly.\n502 \n503 \n504         :param name: The name of configuration value.  It is recommended to be prefixed\n505                      with the extension name (ex. ``html_logo``, ``epub_title``)\n506         :param default: The default value of the configuration.\n507         :param rebuild: The condition of rebuild.  It must be one of those values:\n508 \n509                         * ``'env'`` if a change in the setting only takes effect when a\n510                           document is parsed -- this means that the whole environment must be\n511                           rebuilt.\n512                         * ``'html'`` if a change in the setting needs a full rebuild of HTML\n513                           documents.\n514                         * ``''`` if a change in the setting will not need any special rebuild.\n515         :param types: The type of configuration value.  A list of types can be specified.  For\n516                       example, ``[str]`` is used to describe a configuration that takes string\n517                       value.\n518 \n519         .. versionchanged:: 0.4\n520            If the *default* value is a callable, it will be called with the\n521            config object as its argument in order to get the default value.\n522            This can be used to implement config values whose default depends on\n523            other values.\n524 \n525         .. versionchanged:: 0.6\n526            Changed *rebuild* from a simple boolean (equivalent to ``''`` or\n527            ``'env'``) to a string.  However, booleans are still accepted and\n528            converted internally.\n529         \"\"\"\n530         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))\n531         if rebuild in (False, True):\n532             rebuild = 'env' if rebuild else ''\n533         self.config.add(name, default, rebuild, types)\n534 \n535     def add_event(self, name: str) -> None:\n536         \"\"\"Register an event called *name*.\n537 \n538         This is needed to be able to emit it.\n539 \n540         :param name: The name of the event\n541         \"\"\"\n542         logger.debug('[app] adding event: %r', name)\n543         self.events.add(name)\n544 \n545     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],\n546                        override: bool = False) -> None:\n547         \"\"\"Register or override a Docutils translator class.\n548 \n549         This is used to register a custom output translator or to replace a\n550         builtin translator.  This allows extensions to use custom translator\n551         and define custom nodes for the translator (see :meth:`add_node`).\n552 \n553         :param name: The name of builder for the translator\n554         :param translator_class: A translator class\n555         :param override: If true, install the translator forcedly even if another translator\n556                          is already installed as the same name\n557 \n558         .. versionadded:: 1.3\n559         .. versionchanged:: 1.8\n560            Add *override* keyword.\n561         \"\"\"\n562         self.registry.add_translator(name, translator_class, override=override)\n563 \n564     def add_node(self, node: Type[Element], override: bool = False,\n565                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:\n566         \"\"\"Register a Docutils node class.\n567 \n568         This is necessary for Docutils internals.  It may also be used in the\n569         future to validate nodes in the parsed documents.\n570 \n571         :param node: A node class\n572         :param kwargs: Visitor functions for each builder (see below)\n573         :param override: If true, install the node forcedly even if another node is already\n574                          installed as the same name\n575 \n576         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage\n577         writers can be given as keyword arguments: the keyword should be one or\n578         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``\n579         or any other supported translators, the value a 2-tuple of ``(visit,\n580         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``\n581         function raises :exc:`docutils.nodes.SkipNode`.  Example:\n582 \n583         .. code-block:: python\n584 \n585            class math(docutils.nodes.Element): pass\n586 \n587            def visit_math_html(self, node):\n588                self.body.append(self.starttag(node, 'math'))\n589            def depart_math_html(self, node):\n590                self.body.append('</math>')\n591 \n592            app.add_node(math, html=(visit_math_html, depart_math_html))\n593 \n594         Obviously, translators for which you don't specify visitor methods will\n595         choke on the node when encountered in a document to translate.\n596 \n597         .. versionchanged:: 0.5\n598            Added the support for keyword arguments giving visit functions.\n599         \"\"\"\n600         logger.debug('[app] adding node: %r', (node, kwargs))\n601         if not override and docutils.is_node_registered(node):\n602             logger.warning(__('node class %r is already registered, '\n603                               'its visitors will be overridden'),\n604                            node.__name__, type='app', subtype='add_node')\n605         docutils.register_node(node)\n606         self.registry.add_translation_handlers(node, **kwargs)\n607 \n608     def add_enumerable_node(self, node: Type[Element], figtype: str,\n609                             title_getter: TitleGetter = None, override: bool = False,\n610                             **kwargs: Tuple[Callable, Callable]) -> None:\n611         \"\"\"Register a Docutils node class as a numfig target.\n612 \n613         Sphinx numbers the node automatically. And then the users can refer it\n614         using :rst:role:`numref`.\n615 \n616         :param node: A node class\n617         :param figtype: The type of enumerable nodes.  Each figtypes have individual numbering\n618                         sequences.  As a system figtypes, ``figure``, ``table`` and\n619                         ``code-block`` are defined.  It is able to add custom nodes to these\n620                         default figtypes.  It is also able to define new custom figtype if new\n621                         figtype is given.\n622         :param title_getter: A getter function to obtain the title of node.  It takes an\n623                              instance of the enumerable node, and it must return its title as\n624                              string.  The title is used to the default title of references for\n625                              :rst:role:`ref`.  By default, Sphinx searches\n626                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the\n627                              node as a title.\n628         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)\n629         :param override: If true, install the node forcedly even if another node is already\n630                          installed as the same name\n631 \n632         .. versionadded:: 1.4\n633         \"\"\"\n634         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)\n635         self.add_node(node, override=override, **kwargs)\n636 \n637     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:\n638         \"\"\"Register a Docutils directive.\n639 \n640         :param name: The name of directive\n641         :param cls: A directive class\n642         :param override: If true, install the directive forcedly even if another directive\n643                          is already installed as the same name\n644 \n645         For example, a custom directive named ``my-directive`` would be added\n646         like this:\n647 \n648         .. code-block:: python\n649 \n650            from docutils.parsers.rst import Directive, directives\n651 \n652            class MyDirective(Directive):\n653                has_content = True\n654                required_arguments = 1\n655                optional_arguments = 0\n656                final_argument_whitespace = True\n657                option_spec = {\n658                    'class': directives.class_option,\n659                    'name': directives.unchanged,\n660                }\n661 \n662                def run(self):\n663                    ...\n664 \n665            def setup(app):\n666                add_directive('my-directive', MyDirective)\n667 \n668         For more details, see `the Docutils docs\n669         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`__ .\n670 \n671         .. versionchanged:: 0.6\n672            Docutils 0.5-style directive classes are now supported.\n673         .. deprecated:: 1.8\n674            Docutils 0.4-style (function based) directives support is deprecated.\n675         .. versionchanged:: 1.8\n676            Add *override* keyword.\n677         \"\"\"\n678         logger.debug('[app] adding directive: %r', (name, cls))\n679         if not override and docutils.is_directive_registered(name):\n680             logger.warning(__('directive %r is already registered, it will be overridden'),\n681                            name, type='app', subtype='add_directive')\n682 \n683         docutils.register_directive(name, cls)\n684 \n685     def add_role(self, name: str, role: Any, override: bool = False) -> None:\n686         \"\"\"Register a Docutils role.\n687 \n688         :param name: The name of role\n689         :param role: A role function\n690         :param override: If true, install the role forcedly even if another role is already\n691                          installed as the same name\n692 \n693         For more details about role functions, see `the Docutils docs\n694         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`__ .\n695 \n696         .. versionchanged:: 1.8\n697            Add *override* keyword.\n698         \"\"\"\n699         logger.debug('[app] adding role: %r', (name, role))\n700         if not override and docutils.is_role_registered(name):\n701             logger.warning(__('role %r is already registered, it will be overridden'),\n702                            name, type='app', subtype='add_role')\n703         docutils.register_role(name, role)\n704 \n705     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:\n706         \"\"\"Register a generic Docutils role.\n707 \n708         Register a Docutils role that does nothing but wrap its contents in the\n709         node given by *nodeclass*.\n710 \n711         If *override* is True, the given *nodeclass* is forcedly installed even if\n712         a role named as *name* is already installed.\n713 \n714         .. versionadded:: 0.6\n715         .. versionchanged:: 1.8\n716            Add *override* keyword.\n717         \"\"\"\n718         # Don't use ``roles.register_generic_role`` because it uses\n719         # ``register_canonical_role``.\n720         logger.debug('[app] adding generic role: %r', (name, nodeclass))\n721         if not override and docutils.is_role_registered(name):\n722             logger.warning(__('role %r is already registered, it will be overridden'),\n723                            name, type='app', subtype='add_generic_role')\n724         role = roles.GenericRole(name, nodeclass)\n725         docutils.register_role(name, role)\n726 \n727     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:\n728         \"\"\"Register a domain.\n729 \n730         :param domain: A domain class\n731         :param override: If true, install the domain forcedly even if another domain\n732                          is already installed as the same name\n733 \n734         .. versionadded:: 1.0\n735         .. versionchanged:: 1.8\n736            Add *override* keyword.\n737         \"\"\"\n738         self.registry.add_domain(domain, override=override)\n739 \n740     def add_directive_to_domain(self, domain: str, name: str,\n741                                 cls: Type[Directive], override: bool = False) -> None:\n742         \"\"\"Register a Docutils directive in a domain.\n743 \n744         Like :meth:`add_directive`, but the directive is added to the domain\n745         named *domain*.\n746 \n747         :param domain: The name of target domain\n748         :param name: A name of directive\n749         :param cls: A directive class\n750         :param override: If true, install the directive forcedly even if another directive\n751                          is already installed as the same name\n752 \n753         .. versionadded:: 1.0\n754         .. versionchanged:: 1.8\n755            Add *override* keyword.\n756         \"\"\"\n757         self.registry.add_directive_to_domain(domain, name, cls, override=override)\n758 \n759     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],\n760                            override: bool = False) -> None:\n761         \"\"\"Register a Docutils role in a domain.\n762 \n763         Like :meth:`add_role`, but the role is added to the domain named\n764         *domain*.\n765 \n766         :param domain: The name of target domain\n767         :param name: A name of role\n768         :param role: A role function\n769         :param override: If true, install the role forcedly even if another role is already\n770                          installed as the same name\n771 \n772         .. versionadded:: 1.0\n773         .. versionchanged:: 1.8\n774            Add *override* keyword.\n775         \"\"\"\n776         self.registry.add_role_to_domain(domain, name, role, override=override)\n777 \n778     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False\n779                             ) -> None:\n780         \"\"\"Register a custom index for a domain.\n781 \n782         Add a custom *index* class to the domain named *domain*.\n783 \n784         :param domain: The name of target domain\n785         :param index: A index class\n786         :param override: If true, install the index forcedly even if another index is\n787                          already installed as the same name\n788 \n789         .. versionadded:: 1.0\n790         .. versionchanged:: 1.8\n791            Add *override* keyword.\n792         \"\"\"\n793         self.registry.add_index_to_domain(domain, index)\n794 \n795     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',\n796                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,\n797                         objname: str = '', doc_field_types: List = [], override: bool = False\n798                         ) -> None:\n799         \"\"\"Register a new object type.\n800 \n801         This method is a very convenient way to add a new :term:`object` type\n802         that can be cross-referenced.  It will do this:\n803 \n804         - Create a new directive (called *directivename*) for documenting an\n805           object.  It will automatically add index entries if *indextemplate*\n806           is nonempty; if given, it must contain exactly one instance of\n807           ``%s``.  See the example below for how the template will be\n808           interpreted.\n809         - Create a new role (called *rolename*) to cross-reference to these\n810           object descriptions.\n811         - If you provide *parse_node*, it must be a function that takes a\n812           string and a docutils node, and it must populate the node with\n813           children parsed from the string.  It must then return the name of the\n814           item to be used in cross-referencing and index entries.  See the\n815           :file:`conf.py` file in the source for this documentation for an\n816           example.\n817         - The *objname* (if not given, will default to *directivename*) names\n818           the type of object.  It is used when listing objects, e.g. in search\n819           results.\n820 \n821         For example, if you have this call in a custom Sphinx extension::\n822 \n823            app.add_object_type('directive', 'dir', 'pair: %s; directive')\n824 \n825         you can use this markup in your documents::\n826 \n827            .. rst:directive:: function\n828 \n829               Document a function.\n830 \n831            <...>\n832 \n833            See also the :rst:dir:`function` directive.\n834 \n835         For the directive, an index entry will be generated as if you had prepended ::\n836 \n837            .. index:: pair: function; directive\n838 \n839         The reference node will be of class ``literal`` (so it will be rendered\n840         in a proportional font, as appropriate for code) unless you give the\n841         *ref_nodeclass* argument, which must be a docutils node class.  Most\n842         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --\n843         you can also use ``docutils.nodes.generated`` if you want no further\n844         text decoration.  If the text should be treated as literal (e.g. no\n845         smart quote replacement), but not have typewriter styling, use\n846         ``sphinx.addnodes.literal_emphasis`` or\n847         ``sphinx.addnodes.literal_strong``.\n848 \n849         For the role content, you have the same syntactical possibilities as\n850         for standard Sphinx roles (see :ref:`xref-syntax`).\n851 \n852         If *override* is True, the given object_type is forcedly installed even if\n853         an object_type having the same name is already installed.\n854 \n855         .. versionchanged:: 1.8\n856            Add *override* keyword.\n857         \"\"\"\n858         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,\n859                                       ref_nodeclass, objname, doc_field_types,\n860                                       override=override)\n861 \n862     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',\n863                           ref_nodeclass: Type[TextElement] = None, objname: str = '',\n864                           override: bool = False) -> None:\n865         \"\"\"Register a new crossref object type.\n866 \n867         This method is very similar to :meth:`add_object_type` except that the\n868         directive it generates must be empty, and will produce no output.\n869 \n870         That means that you can add semantic targets to your sources, and refer\n871         to them using custom roles instead of generic ones (like\n872         :rst:role:`ref`).  Example call::\n873 \n874            app.add_crossref_type('topic', 'topic', 'single: %s',\n875                                  docutils.nodes.emphasis)\n876 \n877         Example usage::\n878 \n879            .. topic:: application API\n880 \n881            The application API\n882            -------------------\n883 \n884            Some random text here.\n885 \n886            See also :topic:`this section <application API>`.\n887 \n888         (Of course, the element following the ``topic`` directive needn't be a\n889         section.)\n890 \n891         If *override* is True, the given crossref_type is forcedly installed even if\n892         a crossref_type having the same name is already installed.\n893 \n894         .. versionchanged:: 1.8\n895            Add *override* keyword.\n896         \"\"\"\n897         self.registry.add_crossref_type(directivename, rolename,\n898                                         indextemplate, ref_nodeclass, objname,\n899                                         override=override)\n900 \n901     def add_transform(self, transform: Type[Transform]) -> None:\n902         \"\"\"Register a Docutils transform to be applied after parsing.\n903 \n904         Add the standard docutils :class:`Transform` subclass *transform* to\n905         the list of transforms that are applied after Sphinx parses a reST\n906         document.\n907 \n908         :param transform: A transform class\n909 \n910         .. list-table:: priority range categories for Sphinx transforms\n911            :widths: 20,80\n912 \n913            * - Priority\n914              - Main purpose in Sphinx\n915            * - 0-99\n916              - Fix invalid nodes by docutils. Translate a doctree.\n917            * - 100-299\n918              - Preparation\n919            * - 300-399\n920              - early\n921            * - 400-699\n922              - main\n923            * - 700-799\n924              - Post processing. Deadline to modify text and referencing.\n925            * - 800-899\n926              - Collect referencing and referenced nodes. Domain processing.\n927            * - 900-999\n928              - Finalize and clean up.\n929 \n930         refs: `Transform Priority Range Categories`__\n931 \n932         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories\n933         \"\"\"  # NOQA\n934         self.registry.add_transform(transform)\n935 \n936     def add_post_transform(self, transform: Type[Transform]) -> None:\n937         \"\"\"Register a Docutils transform to be applied before writing.\n938 \n939         Add the standard docutils :class:`Transform` subclass *transform* to\n940         the list of transforms that are applied before Sphinx writes a\n941         document.\n942 \n943         :param transform: A transform class\n944         \"\"\"\n945         self.registry.add_post_transform(transform)\n946 \n947     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:\n948         \"\"\"Register a JavaScript file to include in the HTML output.\n949 \n950         Add *filename* to the list of JavaScript files that the default HTML\n951         template will include in order of *priority* (ascending).  The filename\n952         must be relative to the HTML static path , or a full URI with scheme.\n953         If the priority of JavaScript file is the same as others, the JavaScript\n954         files will be included in order of the registration.  If the keyword\n955         argument ``body`` is given, its value will be added between the\n956         ``<script>`` tags. Extra keyword arguments are included as attributes of\n957         the ``<script>`` tag.\n958 \n959         Example::\n960 \n961             app.add_js_file('example.js')\n962             # => <script src=\"_static/example.js\"></script>\n963 \n964             app.add_js_file('example.js', async=\"async\")\n965             # => <script src=\"_static/example.js\" async=\"async\"></script>\n966 \n967             app.add_js_file(None, body=\"var myVariable = 'foo';\")\n968             # => <script>var myVariable = 'foo';</script>\n969 \n970         .. list-table:: priority range for JavaScript files\n971            :widths: 20,80\n972 \n973            * - Priority\n974              - Main purpose in Sphinx\n975            * - 200\n976              - default priority for built-in JavaScript files\n977            * - 500\n978              - default priority for extensions\n979            * - 800\n980              - default priority for :confval:`html_js_files`\n981 \n982         A JavaScript file can be added to the specific HTML page when on extension\n983         calls this method on :event:`html-page-context` event.\n984 \n985         .. versionadded:: 0.5\n986 \n987         .. versionchanged:: 1.8\n988            Renamed from ``app.add_javascript()``.\n989            And it allows keyword arguments as attributes of script tag.\n990 \n991         .. versionchanged:: 3.5\n992            Take priority argument.  Allow to add a JavaScript file to the specific page.\n993         \"\"\"\n994         self.registry.add_js_file(filename, priority=priority, **kwargs)\n995         if hasattr(self.builder, 'add_js_file'):\n996             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore\n997 \n998     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:\n999         \"\"\"Register a stylesheet to include in the HTML output.\n1000 \n1001         Add *filename* to the list of CSS files that the default HTML template\n1002         will include in order of *priority* (ascending).  The filename must be\n1003         relative to the HTML static path, or a full URI with scheme.  If the\n1004         priority of CSS file is the same as others, the CSS files will be\n1005         included in order of the registration.  The keyword arguments are also\n1006         accepted for attributes of ``<link>`` tag.\n1007 \n1008         Example::\n1009 \n1010             app.add_css_file('custom.css')\n1011             # => <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n1012 \n1013             app.add_css_file('print.css', media='print')\n1014             # => <link rel=\"stylesheet\" href=\"_static/print.css\"\n1015             #          type=\"text/css\" media=\"print\" />\n1016 \n1017             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')\n1018             # => <link rel=\"alternate stylesheet\" href=\"_static/fancy.css\"\n1019             #          type=\"text/css\" title=\"fancy\" />\n1020 \n1021         .. list-table:: priority range for CSS files\n1022            :widths: 20,80\n1023 \n1024            * - Priority\n1025              - Main purpose in Sphinx\n1026            * - 200\n1027              - default priority for built-in CSS files\n1028            * - 500\n1029              - default priority for extensions\n1030            * - 800\n1031              - default priority for :confval:`html_css_files`\n1032 \n1033         A CSS file can be added to the specific HTML page when on extension calls\n1034         this method on :event:`html-page-context` event.\n1035 \n1036         .. versionadded:: 1.0\n1037 \n1038         .. versionchanged:: 1.6\n1039            Optional ``alternate`` and/or ``title`` attributes can be supplied\n1040            with the *alternate* (of boolean type) and *title* (a string)\n1041            arguments. The default is no title and *alternate* = ``False``. For\n1042            more information, refer to the `documentation\n1043            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.\n1044 \n1045         .. versionchanged:: 1.8\n1046            Renamed from ``app.add_stylesheet()``.\n1047            And it allows keyword arguments as attributes of link tag.\n1048 \n1049         .. versionchanged:: 3.5\n1050            Take priority argument.  Allow to add a CSS file to the specific page.\n1051         \"\"\"\n1052         logger.debug('[app] adding stylesheet: %r', filename)\n1053         self.registry.add_css_files(filename, priority=priority, **kwargs)\n1054         if hasattr(self.builder, 'add_css_file'):\n1055             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore\n1056 \n1057     def add_latex_package(self, packagename: str, options: str = None,\n1058                           after_hyperref: bool = False) -> None:\n1059         r\"\"\"Register a package to include in the LaTeX source code.\n1060 \n1061         Add *packagename* to the list of packages that LaTeX source code will\n1062         include.  If you provide *options*, it will be taken to `\\usepackage`\n1063         declaration.  If you set *after_hyperref* truthy, the package will be\n1064         loaded after ``hyperref`` package.\n1065 \n1066         .. code-block:: python\n1067 \n1068            app.add_latex_package('mypackage')\n1069            # => \\usepackage{mypackage}\n1070            app.add_latex_package('mypackage', 'foo,bar')\n1071            # => \\usepackage[foo,bar]{mypackage}\n1072 \n1073         .. versionadded:: 1.3\n1074         .. versionadded:: 3.1\n1075 \n1076            *after_hyperref* option.\n1077         \"\"\"\n1078         self.registry.add_latex_package(packagename, options, after_hyperref)\n1079 \n1080     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:\n1081         \"\"\"Register a new lexer for source code.\n1082 \n1083         Use *lexer* to highlight code blocks with the given language *alias*.\n1084 \n1085         .. versionadded:: 0.6\n1086         .. versionchanged:: 2.1\n1087            Take a lexer class as an argument.  An instance of lexers are\n1088            still supported until Sphinx-3.x.\n1089         \"\"\"\n1090         logger.debug('[app] adding lexer: %r', (alias, lexer))\n1091         lexer_classes[alias] = lexer\n1092 \n1093     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:\n1094         \"\"\"Register a new documenter class for the autodoc extension.\n1095 \n1096         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`\n1097         extension.  It must be a subclass of\n1098         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document\n1099         new types of objects.  See the source of the autodoc module for\n1100         examples on how to subclass :class:`Documenter`.\n1101 \n1102         If *override* is True, the given *cls* is forcedly installed even if\n1103         a documenter having the same name is already installed.\n1104 \n1105         See :ref:`autodoc_ext_tutorial`.\n1106 \n1107         .. versionadded:: 0.6\n1108         .. versionchanged:: 2.2\n1109            Add *override* keyword.\n1110         \"\"\"\n1111         logger.debug('[app] adding autodocumenter: %r', cls)\n1112         from sphinx.ext.autodoc.directive import AutodocDirective\n1113         self.registry.add_documenter(cls.objtype, cls)\n1114         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n1115 \n1116     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]\n1117                                ) -> None:\n1118         \"\"\"Register a new ``getattr``-like function for the autodoc extension.\n1119 \n1120         Add *getter*, which must be a function with an interface compatible to\n1121         the :func:`getattr` builtin, as the autodoc attribute getter for\n1122         objects that are instances of *typ*.  All cases where autodoc needs to\n1123         get an attribute of a type are then handled by this function instead of\n1124         :func:`getattr`.\n1125 \n1126         .. versionadded:: 0.6\n1127         \"\"\"\n1128         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))\n1129         self.registry.add_autodoc_attrgetter(typ, getter)\n1130 \n1131     def add_search_language(self, cls: Any) -> None:\n1132         \"\"\"Register a new language for the HTML search index.\n1133 \n1134         Add *cls*, which must be a subclass of\n1135         :class:`sphinx.search.SearchLanguage`, as a support language for\n1136         building the HTML full-text search index.  The class must have a *lang*\n1137         attribute that indicates the language it should be used for.  See\n1138         :confval:`html_search_language`.\n1139 \n1140         .. versionadded:: 1.1\n1141         \"\"\"\n1142         logger.debug('[app] adding search language: %r', cls)\n1143         from sphinx.search import SearchLanguage, languages\n1144         assert issubclass(cls, SearchLanguage)\n1145         languages[cls.lang] = cls\n1146 \n1147     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:\n1148         \"\"\"Register a suffix of source files.\n1149 \n1150         Same as :confval:`source_suffix`.  The users can override this\n1151         using the setting.\n1152 \n1153         If *override* is True, the given *suffix* is forcedly installed even if\n1154         a same suffix is already installed.\n1155 \n1156         .. versionadded:: 1.8\n1157         \"\"\"\n1158         self.registry.add_source_suffix(suffix, filetype, override=override)\n1159 \n1160     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:\n1161         \"\"\"Register a parser class.\n1162 \n1163         If *override* is True, the given *parser* is forcedly installed even if\n1164         a parser for the same suffix is already installed.\n1165 \n1166         .. versionadded:: 1.4\n1167         .. versionchanged:: 1.8\n1168            *suffix* argument is deprecated.  It only accepts *parser* argument.\n1169            Use :meth:`add_source_suffix` API to register suffix instead.\n1170         .. versionchanged:: 1.8\n1171            Add *override* keyword.\n1172         \"\"\"\n1173         self.registry.add_source_parser(parser, override=override)\n1174 \n1175     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:\n1176         \"\"\"Register an environment collector class.\n1177 \n1178         Refer to :ref:`collector-api`.\n1179 \n1180         .. versionadded:: 1.6\n1181         \"\"\"\n1182         logger.debug('[app] adding environment collector: %r', collector)\n1183         collector().enable(self)\n1184 \n1185     def add_html_theme(self, name: str, theme_path: str) -> None:\n1186         \"\"\"Register a HTML Theme.\n1187 \n1188         The *name* is a name of theme, and *theme_path* is a full path to the\n1189         theme (refs: :ref:`distribute-your-theme`).\n1190 \n1191         .. versionadded:: 1.6\n1192         \"\"\"\n1193         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)\n1194         self.registry.add_html_theme(name, theme_path)\n1195 \n1196     def add_html_math_renderer(self, name: str,\n1197                                inline_renderers: Tuple[Callable, Callable] = None,\n1198                                block_renderers: Tuple[Callable, Callable] = None) -> None:\n1199         \"\"\"Register a math renderer for HTML.\n1200 \n1201         The *name* is a name of math renderer.  Both *inline_renderers* and\n1202         *block_renderers* are used as visitor functions for the HTML writer:\n1203         the former for inline math node (``nodes.math``), the latter for\n1204         block math node (``nodes.math_block``).  Regarding visitor functions,\n1205         see :meth:`add_node` for details.\n1206 \n1207         .. versionadded:: 1.8\n1208 \n1209         \"\"\"\n1210         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)\n1211 \n1212     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:\n1213         \"\"\"Register a message catalog.\n1214 \n1215         :param catalog: A name of catalog\n1216         :param locale_dir: The base path of message catalog\n1217 \n1218         For more details, see :func:`sphinx.locale.get_translation()`.\n1219 \n1220         .. versionadded:: 1.8\n1221         \"\"\"\n1222         locale.init([locale_dir], self.config.language, catalog)\n1223         locale.init_console(locale_dir, catalog)\n1224 \n1225     # ---- other methods -------------------------------------------------\n1226     def is_parallel_allowed(self, typ: str) -> bool:\n1227         \"\"\"Check parallel processing is allowed or not.\n1228 \n1229         :param typ: A type of processing; ``'read'`` or ``'write'``.\n1230         \"\"\"\n1231         if typ == 'read':\n1232             attrname = 'parallel_read_safe'\n1233             message_not_declared = __(\"the %s extension does not declare if it \"\n1234                                       \"is safe for parallel reading, assuming \"\n1235                                       \"it isn't - please ask the extension author \"\n1236                                       \"to check and make it explicit\")\n1237             message_not_safe = __(\"the %s extension is not safe for parallel reading\")\n1238         elif typ == 'write':\n1239             attrname = 'parallel_write_safe'\n1240             message_not_declared = __(\"the %s extension does not declare if it \"\n1241                                       \"is safe for parallel writing, assuming \"\n1242                                       \"it isn't - please ask the extension author \"\n1243                                       \"to check and make it explicit\")\n1244             message_not_safe = __(\"the %s extension is not safe for parallel writing\")\n1245         else:\n1246             raise ValueError('parallel type %s is not supported' % typ)\n1247 \n1248         for ext in self.extensions.values():\n1249             allowed = getattr(ext, attrname, None)\n1250             if allowed is None:\n1251                 logger.warning(message_not_declared, ext.name)\n1252                 logger.warning(__('doing serial %s'), typ)\n1253                 return False\n1254             elif not allowed:\n1255                 logger.warning(message_not_safe, ext.name)\n1256                 logger.warning(__('doing serial %s'), typ)\n1257                 return False\n1258 \n1259         return True\n1260 \n1261     @property\n1262     def html_themes(self) -> Dict[str, str]:\n1263         warnings.warn('app.html_themes is deprecated.',\n1264                       RemovedInSphinx60Warning)\n1265         return self.registry.html_themes\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "sphinx/util/docstrings.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.1/sphinx/util/docstrings.py",
        "start": 1,
        "end": 114,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.docstrings\n3     ~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utilities for docstring processing.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import sys\n13 import warnings\n14 from typing import Dict, List, Tuple\n15 \n16 from docutils.parsers.rst.states import Body\n17 \n18 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning\n19 \n20 field_list_item_re = re.compile(Body.patterns['field_marker'])\n21 \n22 \n23 def separate_metadata(s: str) -> Tuple[str, Dict[str, str]]:\n24     \"\"\"Separate docstring into metadata and others.\"\"\"\n25     in_other_element = False\n26     metadata: Dict[str, str] = {}\n27     lines = []\n28 \n29     if not s:\n30         return s, metadata\n31 \n32     for line in prepare_docstring(s):\n33         if line.strip() == '':\n34             in_other_element = False\n35             lines.append(line)\n36         else:\n37             matched = field_list_item_re.match(line)\n38             if matched and not in_other_element:\n39                 field_name = matched.group()[1:].split(':', 1)[0]\n40                 if field_name.startswith('meta '):\n41                     name = field_name[5:].strip()\n42                     metadata[name] = line[matched.end():].strip()\n43                 else:\n44                     lines.append(line)\n45             else:\n46                 in_other_element = True\n47                 lines.append(line)\n48 \n49     return '\\n'.join(lines), metadata\n50 \n51 \n52 def extract_metadata(s: str) -> Dict[str, str]:\n53     warnings.warn(\"extract_metadata() is deprecated.\",\n54                   RemovedInSphinx60Warning, stacklevel=2)\n55 \n56     docstring, metadata = separate_metadata(s)\n57     return metadata\n58 \n59 \n60 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:\n61     \"\"\"Convert a docstring into lines of parseable reST.  Remove common leading\n62     indentation, where the indentation of a given number of lines (usually just\n63     one) is ignored.\n64 \n65     Return the docstring as a list of lines usable for inserting into a docutils\n66     ViewList (used as argument of nested_parse().)  An empty line is added to\n67     act as a separator between this docstring and following content.\n68     \"\"\"\n69     if ignore is None:\n70         ignore = 1\n71     else:\n72         warnings.warn(\"The 'ignore' argument to prepare_docstring() is deprecated.\",\n73                       RemovedInSphinx50Warning, stacklevel=2)\n74 \n75     lines = s.expandtabs(tabsize).splitlines()\n76     # Find minimum indentation of any non-blank lines after ignored lines.\n77     margin = sys.maxsize\n78     for line in lines[ignore:]:\n79         content = len(line.lstrip())\n80         if content:\n81             indent = len(line) - content\n82             margin = min(margin, indent)\n83     # Remove indentation from ignored lines.\n84     for i in range(ignore):\n85         if i < len(lines):\n86             lines[i] = lines[i].lstrip()\n87     if margin < sys.maxsize:\n88         for i in range(ignore, len(lines)):\n89             lines[i] = lines[i][margin:]\n90     # Remove any leading blank lines.\n91     while lines and not lines[0]:\n92         lines.pop(0)\n93     # make sure there is an empty line at the end\n94     if lines and lines[-1]:\n95         lines.append('')\n96     return lines\n97 \n98 \n99 def prepare_commentdoc(s: str) -> List[str]:\n100     \"\"\"Extract documentation comment lines (starting with #:) and return them\n101     as a list of lines.  Returns an empty list if there is no documentation.\n102     \"\"\"\n103     result = []\n104     lines = [line.strip() for line in s.expandtabs().splitlines()]\n105     for line in lines:\n106         if line.startswith('#:'):\n107             line = line[2:]\n108             # the first space after the comment is ignored\n109             if line and line[0] == ' ':\n110                 line = line[1:]\n111             result.append(line)\n112     if result and result[-1]:\n113         result.append('')\n114     return result\n",
        "intended_behavior": "This utility module should ensure that docstring processing functionality properly recognizes and extracts docstrings from type aliases."
    }
]