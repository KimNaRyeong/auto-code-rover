[
    {
        "rel_file_path": "django/core/files/storage.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/files/storage.py",
        "start": 226,
        "end": 287,
        "class_name": "FileSystemStorage",
        "method_name": "_save",
        "code": "226     def _save(self, name, content):\n227         full_path = self.path(name)\n228 \n229         # Create any intermediate directories that do not exist.\n230         directory = os.path.dirname(full_path)\n231         try:\n232             if self.directory_permissions_mode is not None:\n233                 # os.makedirs applies the global umask, so we reset it,\n234                 # for consistency with file_permissions_mode behavior.\n235                 old_umask = os.umask(0)\n236                 try:\n237                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n238                 finally:\n239                     os.umask(old_umask)\n240             else:\n241                 os.makedirs(directory, exist_ok=True)\n242         except FileExistsError:\n243             raise FileExistsError('%s exists and is not a directory.' % directory)\n244 \n245         # There's a potential race condition between get_available_name and\n246         # saving the file; it's possible that two threads might return the\n247         # same name, at which point all sorts of fun happens. So we need to\n248         # try to create the file, but if it already exists we have to go back\n249         # to get_available_name() and try again.\n250 \n251         while True:\n252             try:\n253                 # This file has a file path that we can move.\n254                 if hasattr(content, 'temporary_file_path'):\n255                     file_move_safe(content.temporary_file_path(), full_path)\n256 \n257                 # This is a normal uploadedfile that we can stream.\n258                 else:\n259                     # The current umask value is masked out by os.open!\n260                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n261                     _file = None\n262                     try:\n263                         locks.lock(fd, locks.LOCK_EX)\n264                         for chunk in content.chunks():\n265                             if _file is None:\n266                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n267                                 _file = os.fdopen(fd, mode)\n268                             _file.write(chunk)\n269                     finally:\n270                         locks.unlock(fd)\n271                         if _file is not None:\n272                             _file.close()\n273                         else:\n274                             os.close(fd)\n275             except FileExistsError:\n276                 # A new name is needed if the file exists.\n277                 name = self.get_available_name(name)\n278                 full_path = self.path(name)\n279             else:\n280                 # OK, the file save worked. Break out of the loop.\n281                 break\n282 \n283         if self.file_permissions_mode is not None:\n284             os.chmod(full_path, self.file_permissions_mode)\n285 \n286         # Store filenames with forward slashes, even on Windows.\n287         return name.replace('\\\\', '/')\n",
        "intended_behavior": "The `_save` method should ensure that, after a file is saved to its final location on the filesystem, it explicitly checks and applies the file permissions defined by `FILE_UPLOAD_PERMISSIONS`. This includes handling files uploaded through both `MemoryUploadedFile` and `TemporaryUploadedFile` mechanisms. The functionality should remain unchanged, except for an additional step to verify and enforce the specified file permissions on the newly saved file. This approach ensures consistent file permissions aligned with the administrator's configuration, potentially mitigating security concerns arising from overly restrictive or permissive default permissions."
    },
    {
        "rel_file_path": "django/core/files/storage.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/files/storage.py",
        "start": 170,
        "end": 348,
        "class_name": "FileSystemStorage",
        "method_name": null,
        "code": "170 class FileSystemStorage(Storage):\n171     \"\"\"\n172     Standard filesystem storage\n173     \"\"\"\n174     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if\n175     # the file already exists before it's opened.\n176     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)\n177 \n178     def __init__(self, location=None, base_url=None, file_permissions_mode=None,\n179                  directory_permissions_mode=None):\n180         self._location = location\n181         self._base_url = base_url\n182         self._file_permissions_mode = file_permissions_mode\n183         self._directory_permissions_mode = directory_permissions_mode\n184         setting_changed.connect(self._clear_cached_properties)\n185 \n186     def _clear_cached_properties(self, setting, **kwargs):\n187         \"\"\"Reset setting based property values.\"\"\"\n188         if setting == 'MEDIA_ROOT':\n189             self.__dict__.pop('base_location', None)\n190             self.__dict__.pop('location', None)\n191         elif setting == 'MEDIA_URL':\n192             self.__dict__.pop('base_url', None)\n193         elif setting == 'FILE_UPLOAD_PERMISSIONS':\n194             self.__dict__.pop('file_permissions_mode', None)\n195         elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':\n196             self.__dict__.pop('directory_permissions_mode', None)\n197 \n198     def _value_or_setting(self, value, setting):\n199         return setting if value is None else value\n200 \n201     @cached_property\n202     def base_location(self):\n203         return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n204 \n205     @cached_property\n206     def location(self):\n207         return os.path.abspath(self.base_location)\n208 \n209     @cached_property\n210     def base_url(self):\n211         if self._base_url is not None and not self._base_url.endswith('/'):\n212             self._base_url += '/'\n213         return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n214 \n215     @cached_property\n216     def file_permissions_mode(self):\n217         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)\n218 \n219     @cached_property\n220     def directory_permissions_mode(self):\n221         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)\n222 \n223     def _open(self, name, mode='rb'):\n224         return File(open(self.path(name), mode))\n225 \n226     def _save(self, name, content):\n227         full_path = self.path(name)\n228 \n229         # Create any intermediate directories that do not exist.\n230         directory = os.path.dirname(full_path)\n231         try:\n232             if self.directory_permissions_mode is not None:\n233                 # os.makedirs applies the global umask, so we reset it,\n234                 # for consistency with file_permissions_mode behavior.\n235                 old_umask = os.umask(0)\n236                 try:\n237                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n238                 finally:\n239                     os.umask(old_umask)\n240             else:\n241                 os.makedirs(directory, exist_ok=True)\n242         except FileExistsError:\n243             raise FileExistsError('%s exists and is not a directory.' % directory)\n244 \n245         # There's a potential race condition between get_available_name and\n246         # saving the file; it's possible that two threads might return the\n247         # same name, at which point all sorts of fun happens. So we need to\n248         # try to create the file, but if it already exists we have to go back\n249         # to get_available_name() and try again.\n250 \n251         while True:\n252             try:\n253                 # This file has a file path that we can move.\n254                 if hasattr(content, 'temporary_file_path'):\n255                     file_move_safe(content.temporary_file_path(), full_path)\n256 \n257                 # This is a normal uploadedfile that we can stream.\n258                 else:\n259                     # The current umask value is masked out by os.open!\n260                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n261                     _file = None\n262                     try:\n263                         locks.lock(fd, locks.LOCK_EX)\n264                         for chunk in content.chunks():\n265                             if _file is None:\n266                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n267                                 _file = os.fdopen(fd, mode)\n268                             _file.write(chunk)\n269                     finally:\n270                         locks.unlock(fd)\n271                         if _file is not None:\n272                             _file.close()\n273                         else:\n274                             os.close(fd)\n275             except FileExistsError:\n276                 # A new name is needed if the file exists.\n277                 name = self.get_available_name(name)\n278                 full_path = self.path(name)\n279             else:\n280                 # OK, the file save worked. Break out of the loop.\n281                 break\n282 \n283         if self.file_permissions_mode is not None:\n284             os.chmod(full_path, self.file_permissions_mode)\n285 \n286         # Store filenames with forward slashes, even on Windows.\n287         return name.replace('\\\\', '/')\n288 \n289     def delete(self, name):\n290         assert name, \"The name argument is not allowed to be empty.\"\n291         name = self.path(name)\n292         # If the file or directory exists, delete it from the filesystem.\n293         try:\n294             if os.path.isdir(name):\n295                 os.rmdir(name)\n296             else:\n297                 os.remove(name)\n298         except FileNotFoundError:\n299             # FileNotFoundError is raised if the file or directory was removed\n300             # concurrently.\n301             pass\n302 \n303     def exists(self, name):\n304         return os.path.exists(self.path(name))\n305 \n306     def listdir(self, path):\n307         path = self.path(path)\n308         directories, files = [], []\n309         for entry in os.scandir(path):\n310             if entry.is_dir():\n311                 directories.append(entry.name)\n312             else:\n313                 files.append(entry.name)\n314         return directories, files\n315 \n316     def path(self, name):\n317         return safe_join(self.location, name)\n318 \n319     def size(self, name):\n320         return os.path.getsize(self.path(name))\n321 \n322     def url(self, name):\n323         if self.base_url is None:\n324             raise ValueError(\"This file is not accessible via a URL.\")\n325         url = filepath_to_uri(name)\n326         if url is not None:\n327             url = url.lstrip('/')\n328         return urljoin(self.base_url, url)\n329 \n330     def _datetime_from_timestamp(self, ts):\n331         \"\"\"\n332         If timezone support is enabled, make an aware datetime object in UTC;\n333         otherwise make a naive one in the local timezone.\n334         \"\"\"\n335         if settings.USE_TZ:\n336             # Safe to use .replace() because UTC doesn't have DST\n337             return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)\n338         else:\n339             return datetime.fromtimestamp(ts)\n340 \n341     def get_accessed_time(self, name):\n342         return self._datetime_from_timestamp(os.path.getatime(self.path(name)))\n343 \n344     def get_created_time(self, name):\n345         return self._datetime_from_timestamp(os.path.getctime(self.path(name)))\n346 \n347     def get_modified_time(self, name):\n348         return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/files/uploadedfile.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/files/uploadedfile.py",
        "start": 55,
        "end": 75,
        "class_name": "TemporaryUploadedFile",
        "method_name": null,
        "code": "55 class TemporaryUploadedFile(UploadedFile):\n56     \"\"\"\n57     A file uploaded to a temporary location (i.e. stream-to-disk).\n58     \"\"\"\n59     def __init__(self, name, content_type, size, charset, content_type_extra=None):\n60         _, ext = os.path.splitext(name)\n61         file = tempfile.NamedTemporaryFile(suffix='.upload' + ext, dir=settings.FILE_UPLOAD_TEMP_DIR)\n62         super().__init__(file, name, content_type, size, charset, content_type_extra)\n63 \n64     def temporary_file_path(self):\n65         \"\"\"Return the full path of this file.\"\"\"\n66         return self.file.name\n67 \n68     def close(self):\n69         try:\n70             return self.file.close()\n71         except FileNotFoundError:\n72             # The file was moved or deleted before the tempfile could unlink\n73             # it. Still sets self.file.close_called and calls\n74             # self.file.file.close() before the exception.\n75             pass\n",
        "intended_behavior": "Consider introducing a mechanism (either within `__init__`, `temporary_file_path`, or `close` method; but more context is needed to specify further) that enforces the application of `FILE_UPLOAD_PERMISSIONS` settings to the temporary file before it gets moved to its permanent location. This step would help in maintaining consistency in file permissions from the moment a file is uploaded and stored temporarily, to when it is permanently stored on the filesystem."
    }
]