[
    {
        "rel_file_path": "sympy/printing/pycode.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/printing/pycode.py",
        "start": 527,
        "end": 534,
        "class_name": "MpmathPrinter",
        "method_name": "_print_Float",
        "code": "527     def _print_Float(self, e):\n528         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that\n529         # the caller of the lambdified function will have set it to sufficient\n530         # precision to match the Floats in the expression.\n531 \n532         # Remove 'mpz' if gmpy is installed.\n533         args = str(tuple(map(int, e._mpf_)))\n534         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)\n",
        "intended_behavior": "This method should be modified to account for min_fixed and max_fixed settings passed via the printer's settings, allowing for dynamic control over the number formatting, particularly for floats. This adjustment would enable users to specify the range within which floats are printed in fixed-point notation, preserving the existing functionality of the method while extending its capabilities."
    },
    {
        "rel_file_path": "sympy/printing/pycode.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/printing/pycode.py",
        "start": 513,
        "end": 569,
        "class_name": "MpmathPrinter",
        "method_name": null,
        "code": "513 class MpmathPrinter(PythonCodePrinter):\n514     \"\"\"\n515     Lambda printer for mpmath which maintains precision for floats\n516     \"\"\"\n517     printmethod = \"_mpmathcode\"\n518 \n519     language = \"Python with mpmath\"\n520 \n521     _kf = dict(chain(\n522         _known_functions.items(),\n523         [(k, 'mpmath.' + v) for k, v in _known_functions_mpmath.items()]\n524     ))\n525     _kc = {k: 'mpmath.'+v for k, v in _known_constants_mpmath.items()}\n526 \n527     def _print_Float(self, e):\n528         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that\n529         # the caller of the lambdified function will have set it to sufficient\n530         # precision to match the Floats in the expression.\n531 \n532         # Remove 'mpz' if gmpy is installed.\n533         args = str(tuple(map(int, e._mpf_)))\n534         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)\n535 \n536 \n537     def _print_Rational(self, e):\n538         return \"{func}({p})/{func}({q})\".format(\n539             func=self._module_format('mpmath.mpf'),\n540             q=self._print(e.q),\n541             p=self._print(e.p)\n542         )\n543 \n544     def _print_Half(self, e):\n545         return self._print_Rational(e)\n546 \n547     def _print_uppergamma(self, e):\n548         return \"{0}({1}, {2}, {3})\".format(\n549             self._module_format('mpmath.gammainc'),\n550             self._print(e.args[0]),\n551             self._print(e.args[1]),\n552             self._module_format('mpmath.inf'))\n553 \n554     def _print_lowergamma(self, e):\n555         return \"{0}({1}, 0, {2})\".format(\n556             self._module_format('mpmath.gammainc'),\n557             self._print(e.args[0]),\n558             self._print(e.args[1]))\n559 \n560     def _print_log2(self, e):\n561         return '{0}({1})/{0}(2)'.format(\n562             self._module_format('mpmath.log'), self._print(e.args[0]))\n563 \n564     def _print_log1p(self, e):\n565         return '{0}({1}+1)'.format(\n566             self._module_format('mpmath.log'), self._print(e.args[0]))\n567 \n568     def _print_Pow(self, expr, rational=False):\n569         return self._hprint_Pow(expr, rational=rational, sqrt='mpmath.sqrt')\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "sympy/printing/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/printing/latex.py",
        "start": 414,
        "end": 439,
        "class_name": "LatexPrinter",
        "method_name": "_print_Float",
        "code": "414     def _print_Float(self, expr):\n415         # Based off of that in StrPrinter\n416         dps = prec_to_dps(expr._prec)\n417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n418 \n419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n420         # thus we use the number separator\n421         separator = self._settings['mul_symbol_latex_numbers']\n422 \n423         if 'e' in str_real:\n424             (mant, exp) = str_real.split('e')\n425 \n426             if exp[0] == '+':\n427                 exp = exp[1:]\n428             if self._settings['decimal_separator'] == 'comma':\n429                 mant = mant.replace('.','{,}')\n430 \n431             return r\"%s%s10^{%s}\" % (mant, separator, exp)\n432         elif str_real == \"+inf\":\n433             return r\"\\infty\"\n434         elif str_real == \"-inf\":\n435             return r\"- \\infty\"\n436         else:\n437             if self._settings['decimal_separator'] == 'comma':\n438                 str_real = str_real.replace('.','{,}')\n439             return str_real\n",
        "intended_behavior": "Similar to MpmathPrinter, the _print_Float method here should be updated to incorporate min_fixed and max_fixed settings. This change would ensure that floats are printed consistently with user preferences on notation within LaTeX output. It's important that this implementation respects the existing LaTeX formatting rules, adding the ability for detailed control over float presentation without disrupting other latex settings."
    },
    {
        "rel_file_path": "sympy/printing/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/printing/latex.py",
        "start": 124,
        "end": 2520,
        "class_name": "LatexPrinter",
        "method_name": null,
        "code": "124 class LatexPrinter(Printer):\n125     printmethod = \"_latex\"\n126 \n127     _default_settings = {\n128         \"fold_frac_powers\": False,\n129         \"fold_func_brackets\": False,\n130         \"fold_short_frac\": None,\n131         \"inv_trig_style\": \"abbreviated\",\n132         \"itex\": False,\n133         \"ln_notation\": False,\n134         \"long_frac_ratio\": None,\n135         \"mat_delim\": \"[\",\n136         \"mat_str\": None,\n137         \"mode\": \"plain\",\n138         \"mul_symbol\": None,\n139         \"order\": None,\n140         \"symbol_names\": {},\n141         \"root_notation\": True,\n142         \"mat_symbol_style\": \"plain\",\n143         \"imaginary_unit\": \"i\",\n144         \"gothic_re_im\": False,\n145         \"decimal_separator\": \"period\",\n146         \"perm_cyclic\": True,\n147     }  # type: Dict[str, Any]\n148 \n149     def __init__(self, settings=None):\n150         Printer.__init__(self, settings)\n151 \n152         if 'mode' in self._settings:\n153             valid_modes = ['inline', 'plain', 'equation',\n154                            'equation*']\n155             if self._settings['mode'] not in valid_modes:\n156                 raise ValueError(\"'mode' must be one of 'inline', 'plain', \"\n157                                  \"'equation' or 'equation*'\")\n158 \n159         if self._settings['fold_short_frac'] is None and \\\n160                 self._settings['mode'] == 'inline':\n161             self._settings['fold_short_frac'] = True\n162 \n163         mul_symbol_table = {\n164             None: r\" \",\n165             \"ldot\": r\" \\,.\\, \",\n166             \"dot\": r\" \\cdot \",\n167             \"times\": r\" \\times \"\n168         }\n169         try:\n170             self._settings['mul_symbol_latex'] = \\\n171                 mul_symbol_table[self._settings['mul_symbol']]\n172         except KeyError:\n173             self._settings['mul_symbol_latex'] = \\\n174                 self._settings['mul_symbol']\n175         try:\n176             self._settings['mul_symbol_latex_numbers'] = \\\n177                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n178         except KeyError:\n179             if (self._settings['mul_symbol'].strip() in\n180                     ['', ' ', '\\\\', '\\\\,', '\\\\:', '\\\\;', '\\\\quad']):\n181                 self._settings['mul_symbol_latex_numbers'] = \\\n182                     mul_symbol_table['dot']\n183             else:\n184                 self._settings['mul_symbol_latex_numbers'] = \\\n185                     self._settings['mul_symbol']\n186 \n187         self._delim_dict = {'(': ')', '[': ']'}\n188 \n189         imaginary_unit_table = {\n190             None: r\"i\",\n191             \"i\": r\"i\",\n192             \"ri\": r\"\\mathrm{i}\",\n193             \"ti\": r\"\\text{i}\",\n194             \"j\": r\"j\",\n195             \"rj\": r\"\\mathrm{j}\",\n196             \"tj\": r\"\\text{j}\",\n197         }\n198         try:\n199             self._settings['imaginary_unit_latex'] = \\\n200                 imaginary_unit_table[self._settings['imaginary_unit']]\n201         except KeyError:\n202             self._settings['imaginary_unit_latex'] = \\\n203                 self._settings['imaginary_unit']\n204 \n205     def parenthesize(self, item, level, strict=False):\n206         prec_val = precedence_traditional(item)\n207         if (prec_val < level) or ((not strict) and prec_val <= level):\n208             return r\"\\left({}\\right)\".format(self._print(item))\n209         else:\n210             return self._print(item)\n211 \n212     def parenthesize_super(self, s):\n213         \"\"\" Parenthesize s if there is a superscript in s\"\"\"\n214         if \"^\" in s:\n215             return r\"\\left({}\\right)\".format(s)\n216         return s\n217 \n218     def embed_super(self, s):\n219         \"\"\" Embed s in {} if there is a superscript in s\"\"\"\n220         if \"^\" in s:\n221             return \"{{{}}}\".format(s)\n222         return s\n223 \n224     def doprint(self, expr):\n225         tex = Printer.doprint(self, expr)\n226 \n227         if self._settings['mode'] == 'plain':\n228             return tex\n229         elif self._settings['mode'] == 'inline':\n230             return r\"$%s$\" % tex\n231         elif self._settings['itex']:\n232             return r\"$$%s$$\" % tex\n233         else:\n234             env_str = self._settings['mode']\n235             return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n236 \n237     def _needs_brackets(self, expr):\n238         \"\"\"\n239         Returns True if the expression needs to be wrapped in brackets when\n240         printed, False otherwise. For example: a + b => True; a => False;\n241         10 => False; -10 => True.\n242         \"\"\"\n243         return not ((expr.is_Integer and expr.is_nonnegative)\n244                     or (expr.is_Atom and (expr is not S.NegativeOne\n245                                           and expr.is_Rational is False)))\n246 \n247     def _needs_function_brackets(self, expr):\n248         \"\"\"\n249         Returns True if the expression needs to be wrapped in brackets when\n250         passed as an argument to a function, False otherwise. This is a more\n251         liberal version of _needs_brackets, in that many expressions which need\n252         to be wrapped in brackets when added/subtracted/raised to a power do\n253         not need them when passed to a function. Such an example is a*b.\n254         \"\"\"\n255         if not self._needs_brackets(expr):\n256             return False\n257         else:\n258             # Muls of the form a*b*c... can be folded\n259             if expr.is_Mul and not self._mul_is_clean(expr):\n260                 return True\n261             # Pows which don't need brackets can be folded\n262             elif expr.is_Pow and not self._pow_is_clean(expr):\n263                 return True\n264             # Add and Function always need brackets\n265             elif expr.is_Add or expr.is_Function:\n266                 return True\n267             else:\n268                 return False\n269 \n270     def _needs_mul_brackets(self, expr, first=False, last=False):\n271         \"\"\"\n272         Returns True if the expression needs to be wrapped in brackets when\n273         printed as part of a Mul, False otherwise. This is True for Add,\n274         but also for some container objects that would not need brackets\n275         when appearing last in a Mul, e.g. an Integral. ``last=True``\n276         specifies that this expr is the last to appear in a Mul.\n277         ``first=True`` specifies that this expr is the first to appear in\n278         a Mul.\n279         \"\"\"\n280         from sympy import Integral, Product, Sum\n281 \n282         if expr.is_Mul:\n283             if not first and _coeff_isneg(expr):\n284                 return True\n285         elif precedence_traditional(expr) < PRECEDENCE[\"Mul\"]:\n286             return True\n287         elif expr.is_Relational:\n288             return True\n289         if expr.is_Piecewise:\n290             return True\n291         if any([expr.has(x) for x in (Mod,)]):\n292             return True\n293         if (not last and\n294                 any([expr.has(x) for x in (Integral, Product, Sum)])):\n295             return True\n296 \n297         return False\n298 \n299     def _needs_add_brackets(self, expr):\n300         \"\"\"\n301         Returns True if the expression needs to be wrapped in brackets when\n302         printed as part of an Add, False otherwise.  This is False for most\n303         things.\n304         \"\"\"\n305         if expr.is_Relational:\n306             return True\n307         if any([expr.has(x) for x in (Mod,)]):\n308             return True\n309         if expr.is_Add:\n310             return True\n311         return False\n312 \n313     def _mul_is_clean(self, expr):\n314         for arg in expr.args:\n315             if arg.is_Function:\n316                 return False\n317         return True\n318 \n319     def _pow_is_clean(self, expr):\n320         return not self._needs_brackets(expr.base)\n321 \n322     def _do_exponent(self, expr, exp):\n323         if exp is not None:\n324             return r\"\\left(%s\\right)^{%s}\" % (expr, exp)\n325         else:\n326             return expr\n327 \n328     def _print_Basic(self, expr):\n329         ls = [self._print(o) for o in expr.args]\n330         return self._deal_with_super_sub(expr.__class__.__name__) + \\\n331             r\"\\left(%s\\right)\" % \", \".join(ls)\n332 \n333     def _print_bool(self, e):\n334         return r\"\\text{%s}\" % e\n335 \n336     _print_BooleanTrue = _print_bool\n337     _print_BooleanFalse = _print_bool\n338 \n339     def _print_NoneType(self, e):\n340         return r\"\\text{%s}\" % e\n341 \n342     def _print_Add(self, expr, order=None):\n343         if self.order == 'none':\n344             terms = list(expr.args)\n345         else:\n346             terms = self._as_ordered_terms(expr, order=order)\n347 \n348         tex = \"\"\n349         for i, term in enumerate(terms):\n350             if i == 0:\n351                 pass\n352             elif _coeff_isneg(term):\n353                 tex += \" - \"\n354                 term = -term\n355             else:\n356                 tex += \" + \"\n357             term_tex = self._print(term)\n358             if self._needs_add_brackets(term):\n359                 term_tex = r\"\\left(%s\\right)\" % term_tex\n360             tex += term_tex\n361 \n362         return tex\n363 \n364     def _print_Cycle(self, expr):\n365         from sympy.combinatorics.permutations import Permutation\n366         if expr.size == 0:\n367             return r\"\\left( \\right)\"\n368         expr = Permutation(expr)\n369         expr_perm = expr.cyclic_form\n370         siz = expr.size\n371         if expr.array_form[-1] == siz - 1:\n372             expr_perm = expr_perm + [[siz - 1]]\n373         term_tex = ''\n374         for i in expr_perm:\n375             term_tex += str(i).replace(',', r\"\\;\")\n376         term_tex = term_tex.replace('[', r\"\\left( \")\n377         term_tex = term_tex.replace(']', r\"\\right)\")\n378         return term_tex\n379 \n380     def _print_Permutation(self, expr):\n381         from sympy.combinatorics.permutations import Permutation\n382         from sympy.utilities.exceptions import SymPyDeprecationWarning\n383 \n384         perm_cyclic = Permutation.print_cyclic\n385         if perm_cyclic is not None:\n386             SymPyDeprecationWarning(\n387                 feature=\"Permutation.print_cyclic = {}\".format(perm_cyclic),\n388                 useinstead=\"init_printing(perm_cyclic={})\"\n389                 .format(perm_cyclic),\n390                 issue=15201,\n391                 deprecated_since_version=\"1.6\").warn()\n392         else:\n393             perm_cyclic = self._settings.get(\"perm_cyclic\", True)\n394 \n395         if perm_cyclic:\n396             return self._print_Cycle(expr)\n397 \n398         if expr.size == 0:\n399             return r\"\\left( \\right)\"\n400 \n401         lower = [self._print(arg) for arg in expr.array_form]\n402         upper = [self._print(arg) for arg in range(len(lower))]\n403 \n404         row1 = \" & \".join(upper)\n405         row2 = \" & \".join(lower)\n406         mat = r\" \\\\ \".join((row1, row2))\n407         return r\"\\begin{pmatrix} %s \\end{pmatrix}\" % mat\n408 \n409 \n410     def _print_AppliedPermutation(self, expr):\n411         perm, var = expr.args\n412         return r\"\\sigma_{%s}(%s)\" % (self._print(perm), self._print(var))\n413 \n414     def _print_Float(self, expr):\n415         # Based off of that in StrPrinter\n416         dps = prec_to_dps(expr._prec)\n417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n418 \n419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n420         # thus we use the number separator\n421         separator = self._settings['mul_symbol_latex_numbers']\n422 \n423         if 'e' in str_real:\n424             (mant, exp) = str_real.split('e')\n425 \n426             if exp[0] == '+':\n427                 exp = exp[1:]\n428             if self._settings['decimal_separator'] == 'comma':\n429                 mant = mant.replace('.','{,}')\n430 \n431             return r\"%s%s10^{%s}\" % (mant, separator, exp)\n432         elif str_real == \"+inf\":\n433             return r\"\\infty\"\n434         elif str_real == \"-inf\":\n435             return r\"- \\infty\"\n436         else:\n437             if self._settings['decimal_separator'] == 'comma':\n438                 str_real = str_real.replace('.','{,}')\n439             return str_real\n440 \n441     def _print_Cross(self, expr):\n442         vec1 = expr._expr1\n443         vec2 = expr._expr2\n444         return r\"%s \\times %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n445                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n446 \n447     def _print_Curl(self, expr):\n448         vec = expr._expr\n449         return r\"\\nabla\\times %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n450 \n451     def _print_Divergence(self, expr):\n452         vec = expr._expr\n453         return r\"\\nabla\\cdot %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n454 \n455     def _print_Dot(self, expr):\n456         vec1 = expr._expr1\n457         vec2 = expr._expr2\n458         return r\"%s \\cdot %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n459                                  self.parenthesize(vec2, PRECEDENCE['Mul']))\n460 \n461     def _print_Gradient(self, expr):\n462         func = expr._expr\n463         return r\"\\nabla %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n464 \n465     def _print_Laplacian(self, expr):\n466         func = expr._expr\n467         return r\"\\triangle %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n468 \n469     def _print_Mul(self, expr):\n470         from sympy.core.power import Pow\n471         from sympy.physics.units import Quantity\n472         include_parens = False\n473         if _coeff_isneg(expr):\n474             expr = -expr\n475             tex = \"- \"\n476             if expr.is_Add:\n477                 tex += \"(\"\n478                 include_parens = True\n479         else:\n480             tex = \"\"\n481 \n482         from sympy.simplify import fraction\n483         numer, denom = fraction(expr, exact=True)\n484         separator = self._settings['mul_symbol_latex']\n485         numbersep = self._settings['mul_symbol_latex_numbers']\n486 \n487         def convert(expr):\n488             if not expr.is_Mul:\n489                 return str(self._print(expr))\n490             else:\n491                 _tex = last_term_tex = \"\"\n492 \n493                 if self.order not in ('old', 'none'):\n494                     args = expr.as_ordered_factors()\n495                 else:\n496                     args = list(expr.args)\n497 \n498                 # If quantities are present append them at the back\n499                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or\n500                               (isinstance(x, Pow) and\n501                                isinstance(x.base, Quantity)))\n502 \n503                 for i, term in enumerate(args):\n504                     term_tex = self._print(term)\n505 \n506                     if self._needs_mul_brackets(term, first=(i == 0),\n507                                                 last=(i == len(args) - 1)):\n508                         term_tex = r\"\\left(%s\\right)\" % term_tex\n509 \n510                     if _between_two_numbers_p[0].search(last_term_tex) and \\\n511                             _between_two_numbers_p[1].match(term_tex):\n512                         # between two numbers\n513                         _tex += numbersep\n514                     elif _tex:\n515                         _tex += separator\n516 \n517                     _tex += term_tex\n518                     last_term_tex = term_tex\n519                 return _tex\n520 \n521         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:\n522             # use the original expression here, since fraction() may have\n523             # altered it when producing numer and denom\n524             tex += convert(expr)\n525 \n526         else:\n527             snumer = convert(numer)\n528             sdenom = convert(denom)\n529             ldenom = len(sdenom.split())\n530             ratio = self._settings['long_frac_ratio']\n531             if self._settings['fold_short_frac'] and ldenom <= 2 and \\\n532                     \"^\" not in sdenom:\n533                 # handle short fractions\n534                 if self._needs_mul_brackets(numer, last=False):\n535                     tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n536                 else:\n537                     tex += r\"%s / %s\" % (snumer, sdenom)\n538             elif ratio is not None and \\\n539                     len(snumer.split()) > ratio*ldenom:\n540                 # handle long fractions\n541                 if self._needs_mul_brackets(numer, last=True):\n542                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n543                         % (sdenom, separator, snumer)\n544                 elif numer.is_Mul:\n545                     # split a long numerator\n546                     a = S.One\n547                     b = S.One\n548                     for x in numer.args:\n549                         if self._needs_mul_brackets(x, last=False) or \\\n550                                 len(convert(a*x).split()) > ratio*ldenom or \\\n551                                 (b.is_commutative is x.is_commutative is False):\n552                             b *= x\n553                         else:\n554                             a *= x\n555                     if self._needs_mul_brackets(b, last=True):\n556                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n557                             % (convert(a), sdenom, separator, convert(b))\n558                     else:\n559                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n560                             % (convert(a), sdenom, separator, convert(b))\n561                 else:\n562                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n563             else:\n564                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n565 \n566         if include_parens:\n567             tex += \")\"\n568         return tex\n569 \n570     def _print_Pow(self, expr):\n571         # Treat x**Rational(1,n) as special case\n572         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \\\n573                 and self._settings['root_notation']:\n574             base = self._print(expr.base)\n575             expq = expr.exp.q\n576 \n577             if expq == 2:\n578                 tex = r\"\\sqrt{%s}\" % base\n579             elif self._settings['itex']:\n580                 tex = r\"\\root{%d}{%s}\" % (expq, base)\n581             else:\n582                 tex = r\"\\sqrt[%d]{%s}\" % (expq, base)\n583 \n584             if expr.exp.is_negative:\n585                 return r\"\\frac{1}{%s}\" % tex\n586             else:\n587                 return tex\n588         elif self._settings['fold_frac_powers'] \\\n589             and expr.exp.is_Rational \\\n590                 and expr.exp.q != 1:\n591             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n592             p, q = expr.exp.p, expr.exp.q\n593             # issue #12886: add parentheses for superscripts raised to powers\n594             if '^' in base and expr.base.is_Symbol:\n595                 base = r\"\\left(%s\\right)\" % base\n596             if expr.base.is_Function:\n597                 return self._print(expr.base, exp=\"%s/%s\" % (p, q))\n598             return r\"%s^{%s/%s}\" % (base, p, q)\n599         elif expr.exp.is_Rational and expr.exp.is_negative and \\\n600                 expr.base.is_commutative:\n601             # special case for 1^(-x), issue 9216\n602             if expr.base == 1:\n603                 return r\"%s^{%s}\" % (expr.base, expr.exp)\n604             # things like 1/x\n605             return self._print_Mul(expr)\n606         else:\n607             if expr.base.is_Function:\n608                 return self._print(expr.base, exp=self._print(expr.exp))\n609             else:\n610                 tex = r\"%s^{%s}\"\n611                 return self._helper_print_standard_power(expr, tex)\n612 \n613     def _helper_print_standard_power(self, expr, template):\n614         exp = self._print(expr.exp)\n615         # issue #12886: add parentheses around superscripts raised\n616         # to powers\n617         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n618         if '^' in base and expr.base.is_Symbol:\n619             base = r\"\\left(%s\\right)\" % base\n620         elif (isinstance(expr.base, Derivative)\n621             and base.startswith(r'\\left(')\n622             and re.match(r'\\\\left\\(\\\\d?d?dot', base)\n623             and base.endswith(r'\\right)')):\n624             # don't use parentheses around dotted derivative\n625             base = base[6: -7]  # remove outermost added parens\n626         return template % (base, exp)\n627 \n628     def _print_UnevaluatedExpr(self, expr):\n629         return self._print(expr.args[0])\n630 \n631     def _print_Sum(self, expr):\n632         if len(expr.limits) == 1:\n633             tex = r\"\\sum_{%s=%s}^{%s} \" % \\\n634                 tuple([self._print(i) for i in expr.limits[0]])\n635         else:\n636             def _format_ineq(l):\n637                 return r\"%s \\leq %s \\leq %s\" % \\\n638                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n639 \n640             tex = r\"\\sum_{\\substack{%s}} \" % \\\n641                 str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n642 \n643         if isinstance(expr.function, Add):\n644             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n645         else:\n646             tex += self._print(expr.function)\n647 \n648         return tex\n649 \n650     def _print_Product(self, expr):\n651         if len(expr.limits) == 1:\n652             tex = r\"\\prod_{%s=%s}^{%s} \" % \\\n653                 tuple([self._print(i) for i in expr.limits[0]])\n654         else:\n655             def _format_ineq(l):\n656                 return r\"%s \\leq %s \\leq %s\" % \\\n657                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n658 \n659             tex = r\"\\prod_{\\substack{%s}} \" % \\\n660                 str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n661 \n662         if isinstance(expr.function, Add):\n663             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n664         else:\n665             tex += self._print(expr.function)\n666 \n667         return tex\n668 \n669     def _print_BasisDependent(self, expr):\n670         from sympy.vector import Vector\n671 \n672         o1 = []\n673         if expr == expr.zero:\n674             return expr.zero._latex_form\n675         if isinstance(expr, Vector):\n676             items = expr.separate().items()\n677         else:\n678             items = [(0, expr)]\n679 \n680         for system, vect in items:\n681             inneritems = list(vect.components.items())\n682             inneritems.sort(key=lambda x: x[0].__str__())\n683             for k, v in inneritems:\n684                 if v == 1:\n685                     o1.append(' + ' + k._latex_form)\n686                 elif v == -1:\n687                     o1.append(' - ' + k._latex_form)\n688                 else:\n689                     arg_str = '(' + LatexPrinter().doprint(v) + ')'\n690                     o1.append(' + ' + arg_str + k._latex_form)\n691 \n692         outstr = (''.join(o1))\n693         if outstr[1] != '-':\n694             outstr = outstr[3:]\n695         else:\n696             outstr = outstr[1:]\n697         return outstr\n698 \n699     def _print_Indexed(self, expr):\n700         tex_base = self._print(expr.base)\n701         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(\n702             map(self._print, expr.indices))\n703         return tex\n704 \n705     def _print_IndexedBase(self, expr):\n706         return self._print(expr.label)\n707 \n708     def _print_Derivative(self, expr):\n709         if requires_partial(expr.expr):\n710             diff_symbol = r'\\partial'\n711         else:\n712             diff_symbol = r'd'\n713 \n714         tex = \"\"\n715         dim = 0\n716         for x, num in reversed(expr.variable_count):\n717             dim += num\n718             if num == 1:\n719                 tex += r\"%s %s\" % (diff_symbol, self._print(x))\n720             else:\n721                 tex += r\"%s %s^{%s}\" % (diff_symbol,\n722                                         self.parenthesize_super(self._print(x)),\n723                                         self._print(num))\n724 \n725         if dim == 1:\n726             tex = r\"\\frac{%s}{%s}\" % (diff_symbol, tex)\n727         else:\n728             tex = r\"\\frac{%s^{%s}}{%s}\" % (diff_symbol, self._print(dim), tex)\n729 \n730         return r\"%s %s\" % (tex, self.parenthesize(expr.expr,\n731                                                   PRECEDENCE[\"Mul\"],\n732                                                   strict=True))\n733 \n734     def _print_Subs(self, subs):\n735         expr, old, new = subs.args\n736         latex_expr = self._print(expr)\n737         latex_old = (self._print(e) for e in old)\n738         latex_new = (self._print(e) for e in new)\n739         latex_subs = r'\\\\ '.join(\n740             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n741         return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr,\n742                                                          latex_subs)\n743 \n744     def _print_Integral(self, expr):\n745         tex, symbols = \"\", []\n746 \n747         # Only up to \\iiiint exists\n748         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):\n749             # Use len(expr.limits)-1 so that syntax highlighters don't think\n750             # \\\" is an escaped quote\n751             tex = r\"\\i\" + \"i\"*(len(expr.limits) - 1) + \"nt\"\n752             symbols = [r\"\\, d%s\" % self._print(symbol[0])\n753                        for symbol in expr.limits]\n754 \n755         else:\n756             for lim in reversed(expr.limits):\n757                 symbol = lim[0]\n758                 tex += r\"\\int\"\n759 \n760                 if len(lim) > 1:\n761                     if self._settings['mode'] != 'inline' \\\n762                             and not self._settings['itex']:\n763                         tex += r\"\\limits\"\n764 \n765                     if len(lim) == 3:\n766                         tex += \"_{%s}^{%s}\" % (self._print(lim[1]),\n767                                                self._print(lim[2]))\n768                     if len(lim) == 2:\n769                         tex += \"^{%s}\" % (self._print(lim[1]))\n770 \n771                 symbols.insert(0, r\"\\, d%s\" % self._print(symbol))\n772 \n773         return r\"%s %s%s\" % (tex, self.parenthesize(expr.function,\n774                                                     PRECEDENCE[\"Mul\"],\n775                                                     strict=True),\n776                              \"\".join(symbols))\n777 \n778     def _print_Limit(self, expr):\n779         e, z, z0, dir = expr.args\n780 \n781         tex = r\"\\lim_{%s \\to \" % self._print(z)\n782         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n783             tex += r\"%s}\" % self._print(z0)\n784         else:\n785             tex += r\"%s^%s}\" % (self._print(z0), self._print(dir))\n786 \n787         if isinstance(e, AssocOp):\n788             return r\"%s\\left(%s\\right)\" % (tex, self._print(e))\n789         else:\n790             return r\"%s %s\" % (tex, self._print(e))\n791 \n792     def _hprint_Function(self, func):\n793         r'''\n794         Logic to decide how to render a function to latex\n795           - if it is a recognized latex name, use the appropriate latex command\n796           - if it is a single letter, just use that letter\n797           - if it is a longer name, then put \\operatorname{} around it and be\n798             mindful of undercores in the name\n799         '''\n800         func = self._deal_with_super_sub(func)\n801         if func in accepted_latex_functions:\n802             name = r\"\\%s\" % func\n803         elif len(func) == 1 or func.startswith('\\\\'):\n804             name = func\n805         else:\n806             name = r\"\\operatorname{%s}\" % func\n807         return name\n808 \n809     def _print_Function(self, expr, exp=None):\n810         r'''\n811         Render functions to LaTeX, handling functions that LaTeX knows about\n812         e.g., sin, cos, ... by using the proper LaTeX command (\\sin, \\cos, ...).\n813         For single-letter function names, render them as regular LaTeX math\n814         symbols. For multi-letter function names that LaTeX does not know\n815         about, (e.g., Li, sech) use \\operatorname{} so that the function name\n816         is rendered in Roman font and LaTeX handles spacing properly.\n817 \n818         expr is the expression involving the function\n819         exp is an exponent\n820         '''\n821         func = expr.func.__name__\n822         if hasattr(self, '_print_' + func) and \\\n823                 not isinstance(expr, AppliedUndef):\n824             return getattr(self, '_print_' + func)(expr, exp)\n825         else:\n826             args = [str(self._print(arg)) for arg in expr.args]\n827             # How inverse trig functions should be displayed, formats are:\n828             # abbreviated: asin, full: arcsin, power: sin^-1\n829             inv_trig_style = self._settings['inv_trig_style']\n830             # If we are dealing with a power-style inverse trig function\n831             inv_trig_power_case = False\n832             # If it is applicable to fold the argument brackets\n833             can_fold_brackets = self._settings['fold_func_brackets'] and \\\n834                 len(args) == 1 and \\\n835                 not self._needs_function_brackets(expr.args[0])\n836 \n837             inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\"]\n838 \n839             # If the function is an inverse trig function, handle the style\n840             if func in inv_trig_table:\n841                 if inv_trig_style == \"abbreviated\":\n842                     pass\n843                 elif inv_trig_style == \"full\":\n844                     func = \"arc\" + func[1:]\n845                 elif inv_trig_style == \"power\":\n846                     func = func[1:]\n847                     inv_trig_power_case = True\n848 \n849                     # Can never fold brackets if we're raised to a power\n850                     if exp is not None:\n851                         can_fold_brackets = False\n852 \n853             if inv_trig_power_case:\n854                 if func in accepted_latex_functions:\n855                     name = r\"\\%s^{-1}\" % func\n856                 else:\n857                     name = r\"\\operatorname{%s}^{-1}\" % func\n858             elif exp is not None:\n859                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)\n860             else:\n861                 name = self._hprint_Function(func)\n862 \n863             if can_fold_brackets:\n864                 if func in accepted_latex_functions:\n865                     # Wrap argument safely to avoid parse-time conflicts\n866                     # with the function name itself\n867                     name += r\" {%s}\"\n868                 else:\n869                     name += r\"%s\"\n870             else:\n871                 name += r\"{\\left(%s \\right)}\"\n872 \n873             if inv_trig_power_case and exp is not None:\n874                 name += r\"^{%s}\" % exp\n875 \n876             return name % \",\".join(args)\n877 \n878     def _print_UndefinedFunction(self, expr):\n879         return self._hprint_Function(str(expr))\n880 \n881     def _print_ElementwiseApplyFunction(self, expr):\n882         return r\"{%s}_{\\circ}\\left({%s}\\right)\" % (\n883             self._print(expr.function),\n884             self._print(expr.expr),\n885         )\n886 \n887     @property\n888     def _special_function_classes(self):\n889         from sympy.functions.special.tensor_functions import KroneckerDelta\n890         from sympy.functions.special.gamma_functions import gamma, lowergamma\n891         from sympy.functions.special.beta_functions import beta\n892         from sympy.functions.special.delta_functions import DiracDelta\n893         from sympy.functions.special.error_functions import Chi\n894         return {KroneckerDelta: r'\\delta',\n895                 gamma:  r'\\Gamma',\n896                 lowergamma: r'\\gamma',\n897                 beta: r'\\operatorname{B}',\n898                 DiracDelta: r'\\delta',\n899                 Chi: r'\\operatorname{Chi}'}\n900 \n901     def _print_FunctionClass(self, expr):\n902         for cls in self._special_function_classes:\n903             if issubclass(expr, cls) and expr.__name__ == cls.__name__:\n904                 return self._special_function_classes[cls]\n905         return self._hprint_Function(str(expr))\n906 \n907     def _print_Lambda(self, expr):\n908         symbols, expr = expr.args\n909 \n910         if len(symbols) == 1:\n911             symbols = self._print(symbols[0])\n912         else:\n913             symbols = self._print(tuple(symbols))\n914 \n915         tex = r\"\\left( %s \\mapsto %s \\right)\" % (symbols, self._print(expr))\n916 \n917         return tex\n918 \n919     def _hprint_variadic_function(self, expr, exp=None):\n920         args = sorted(expr.args, key=default_sort_key)\n921         texargs = [r\"%s\" % self._print(symbol) for symbol in args]\n922         tex = r\"\\%s\\left(%s\\right)\" % (self._print((str(expr.func)).lower()),\n923                                        \", \".join(texargs))\n924         if exp is not None:\n925             return r\"%s^{%s}\" % (tex, exp)\n926         else:\n927             return tex\n928 \n929     _print_Min = _print_Max = _hprint_variadic_function\n930 \n931     def _print_floor(self, expr, exp=None):\n932         tex = r\"\\left\\lfloor{%s}\\right\\rfloor\" % self._print(expr.args[0])\n933 \n934         if exp is not None:\n935             return r\"%s^{%s}\" % (tex, exp)\n936         else:\n937             return tex\n938 \n939     def _print_ceiling(self, expr, exp=None):\n940         tex = r\"\\left\\lceil{%s}\\right\\rceil\" % self._print(expr.args[0])\n941 \n942         if exp is not None:\n943             return r\"%s^{%s}\" % (tex, exp)\n944         else:\n945             return tex\n946 \n947     def _print_log(self, expr, exp=None):\n948         if not self._settings[\"ln_notation\"]:\n949             tex = r\"\\log{\\left(%s \\right)}\" % self._print(expr.args[0])\n950         else:\n951             tex = r\"\\ln{\\left(%s \\right)}\" % self._print(expr.args[0])\n952 \n953         if exp is not None:\n954             return r\"%s^{%s}\" % (tex, exp)\n955         else:\n956             return tex\n957 \n958     def _print_Abs(self, expr, exp=None):\n959         tex = r\"\\left|{%s}\\right|\" % self._print(expr.args[0])\n960 \n961         if exp is not None:\n962             return r\"%s^{%s}\" % (tex, exp)\n963         else:\n964             return tex\n965     _print_Determinant = _print_Abs\n966 \n967     def _print_re(self, expr, exp=None):\n968         if self._settings['gothic_re_im']:\n969             tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n970         else:\n971             tex = r\"\\operatorname{{re}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))\n972 \n973         return self._do_exponent(tex, exp)\n974 \n975     def _print_im(self, expr, exp=None):\n976         if self._settings['gothic_re_im']:\n977             tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n978         else:\n979             tex = r\"\\operatorname{{im}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))\n980 \n981         return self._do_exponent(tex, exp)\n982 \n983     def _print_Not(self, e):\n984         from sympy import Equivalent, Implies\n985         if isinstance(e.args[0], Equivalent):\n986             return self._print_Equivalent(e.args[0], r\"\\not\\Leftrightarrow\")\n987         if isinstance(e.args[0], Implies):\n988             return self._print_Implies(e.args[0], r\"\\not\\Rightarrow\")\n989         if (e.args[0].is_Boolean):\n990             return r\"\\neg \\left(%s\\right)\" % self._print(e.args[0])\n991         else:\n992             return r\"\\neg %s\" % self._print(e.args[0])\n993 \n994     def _print_LogOp(self, args, char):\n995         arg = args[0]\n996         if arg.is_Boolean and not arg.is_Not:\n997             tex = r\"\\left(%s\\right)\" % self._print(arg)\n998         else:\n999             tex = r\"%s\" % self._print(arg)\n1000 \n1001         for arg in args[1:]:\n1002             if arg.is_Boolean and not arg.is_Not:\n1003                 tex += r\" %s \\left(%s\\right)\" % (char, self._print(arg))\n1004             else:\n1005                 tex += r\" %s %s\" % (char, self._print(arg))\n1006 \n1007         return tex\n1008 \n1009     def _print_And(self, e):\n1010         args = sorted(e.args, key=default_sort_key)\n1011         return self._print_LogOp(args, r\"\\wedge\")\n1012 \n1013     def _print_Or(self, e):\n1014         args = sorted(e.args, key=default_sort_key)\n1015         return self._print_LogOp(args, r\"\\vee\")\n1016 \n1017     def _print_Xor(self, e):\n1018         args = sorted(e.args, key=default_sort_key)\n1019         return self._print_LogOp(args, r\"\\veebar\")\n1020 \n1021     def _print_Implies(self, e, altchar=None):\n1022         return self._print_LogOp(e.args, altchar or r\"\\Rightarrow\")\n1023 \n1024     def _print_Equivalent(self, e, altchar=None):\n1025         args = sorted(e.args, key=default_sort_key)\n1026         return self._print_LogOp(args, altchar or r\"\\Leftrightarrow\")\n1027 \n1028     def _print_conjugate(self, expr, exp=None):\n1029         tex = r\"\\overline{%s}\" % self._print(expr.args[0])\n1030 \n1031         if exp is not None:\n1032             return r\"%s^{%s}\" % (tex, exp)\n1033         else:\n1034             return tex\n1035 \n1036     def _print_polar_lift(self, expr, exp=None):\n1037         func = r\"\\operatorname{polar\\_lift}\"\n1038         arg = r\"{\\left(%s \\right)}\" % self._print(expr.args[0])\n1039 \n1040         if exp is not None:\n1041             return r\"%s^{%s}%s\" % (func, exp, arg)\n1042         else:\n1043             return r\"%s%s\" % (func, arg)\n1044 \n1045     def _print_ExpBase(self, expr, exp=None):\n1046         # TODO should exp_polar be printed differently?\n1047         #      what about exp_polar(0), exp_polar(1)?\n1048         tex = r\"e^{%s}\" % self._print(expr.args[0])\n1049         return self._do_exponent(tex, exp)\n1050 \n1051     def _print_elliptic_k(self, expr, exp=None):\n1052         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1053         if exp is not None:\n1054             return r\"K^{%s}%s\" % (exp, tex)\n1055         else:\n1056             return r\"K%s\" % tex\n1057 \n1058     def _print_elliptic_f(self, expr, exp=None):\n1059         tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n1060             (self._print(expr.args[0]), self._print(expr.args[1]))\n1061         if exp is not None:\n1062             return r\"F^{%s}%s\" % (exp, tex)\n1063         else:\n1064             return r\"F%s\" % tex\n1065 \n1066     def _print_elliptic_e(self, expr, exp=None):\n1067         if len(expr.args) == 2:\n1068             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n1069                 (self._print(expr.args[0]), self._print(expr.args[1]))\n1070         else:\n1071             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1072         if exp is not None:\n1073             return r\"E^{%s}%s\" % (exp, tex)\n1074         else:\n1075             return r\"E%s\" % tex\n1076 \n1077     def _print_elliptic_pi(self, expr, exp=None):\n1078         if len(expr.args) == 3:\n1079             tex = r\"\\left(%s; %s\\middle| %s\\right)\" % \\\n1080                 (self._print(expr.args[0]), self._print(expr.args[1]),\n1081                  self._print(expr.args[2]))\n1082         else:\n1083             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n1084                 (self._print(expr.args[0]), self._print(expr.args[1]))\n1085         if exp is not None:\n1086             return r\"\\Pi^{%s}%s\" % (exp, tex)\n1087         else:\n1088             return r\"\\Pi%s\" % tex\n1089 \n1090     def _print_beta(self, expr, exp=None):\n1091         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1092                                         self._print(expr.args[1]))\n1093 \n1094         if exp is not None:\n1095             return r\"\\operatorname{B}^{%s}%s\" % (exp, tex)\n1096         else:\n1097             return r\"\\operatorname{B}%s\" % tex\n1098 \n1099     def _print_uppergamma(self, expr, exp=None):\n1100         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1101                                         self._print(expr.args[1]))\n1102 \n1103         if exp is not None:\n1104             return r\"\\Gamma^{%s}%s\" % (exp, tex)\n1105         else:\n1106             return r\"\\Gamma%s\" % tex\n1107 \n1108     def _print_lowergamma(self, expr, exp=None):\n1109         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1110                                         self._print(expr.args[1]))\n1111 \n1112         if exp is not None:\n1113             return r\"\\gamma^{%s}%s\" % (exp, tex)\n1114         else:\n1115             return r\"\\gamma%s\" % tex\n1116 \n1117     def _hprint_one_arg_func(self, expr, exp=None):\n1118         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1119 \n1120         if exp is not None:\n1121             return r\"%s^{%s}%s\" % (self._print(expr.func), exp, tex)\n1122         else:\n1123             return r\"%s%s\" % (self._print(expr.func), tex)\n1124 \n1125     _print_gamma = _hprint_one_arg_func\n1126 \n1127     def _print_Chi(self, expr, exp=None):\n1128         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1129 \n1130         if exp is not None:\n1131             return r\"\\operatorname{Chi}^{%s}%s\" % (exp, tex)\n1132         else:\n1133             return r\"\\operatorname{Chi}%s\" % tex\n1134 \n1135     def _print_expint(self, expr, exp=None):\n1136         tex = r\"\\left(%s\\right)\" % self._print(expr.args[1])\n1137         nu = self._print(expr.args[0])\n1138 \n1139         if exp is not None:\n1140             return r\"\\operatorname{E}_{%s}^{%s}%s\" % (nu, exp, tex)\n1141         else:\n1142             return r\"\\operatorname{E}_{%s}%s\" % (nu, tex)\n1143 \n1144     def _print_fresnels(self, expr, exp=None):\n1145         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1146 \n1147         if exp is not None:\n1148             return r\"S^{%s}%s\" % (exp, tex)\n1149         else:\n1150             return r\"S%s\" % tex\n1151 \n1152     def _print_fresnelc(self, expr, exp=None):\n1153         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1154 \n1155         if exp is not None:\n1156             return r\"C^{%s}%s\" % (exp, tex)\n1157         else:\n1158             return r\"C%s\" % tex\n1159 \n1160     def _print_subfactorial(self, expr, exp=None):\n1161         tex = r\"!%s\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1162 \n1163         if exp is not None:\n1164             return r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1165         else:\n1166             return tex\n1167 \n1168     def _print_factorial(self, expr, exp=None):\n1169         tex = r\"%s!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1170 \n1171         if exp is not None:\n1172             return r\"%s^{%s}\" % (tex, exp)\n1173         else:\n1174             return tex\n1175 \n1176     def _print_factorial2(self, expr, exp=None):\n1177         tex = r\"%s!!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1178 \n1179         if exp is not None:\n1180             return r\"%s^{%s}\" % (tex, exp)\n1181         else:\n1182             return tex\n1183 \n1184     def _print_binomial(self, expr, exp=None):\n1185         tex = r\"{\\binom{%s}{%s}}\" % (self._print(expr.args[0]),\n1186                                      self._print(expr.args[1]))\n1187 \n1188         if exp is not None:\n1189             return r\"%s^{%s}\" % (tex, exp)\n1190         else:\n1191             return tex\n1192 \n1193     def _print_RisingFactorial(self, expr, exp=None):\n1194         n, k = expr.args\n1195         base = r\"%s\" % self.parenthesize(n, PRECEDENCE['Func'])\n1196 \n1197         tex = r\"{%s}^{\\left(%s\\right)}\" % (base, self._print(k))\n1198 \n1199         return self._do_exponent(tex, exp)\n1200 \n1201     def _print_FallingFactorial(self, expr, exp=None):\n1202         n, k = expr.args\n1203         sub = r\"%s\" % self.parenthesize(k, PRECEDENCE['Func'])\n1204 \n1205         tex = r\"{\\left(%s\\right)}_{%s}\" % (self._print(n), sub)\n1206 \n1207         return self._do_exponent(tex, exp)\n1208 \n1209     def _hprint_BesselBase(self, expr, exp, sym):\n1210         tex = r\"%s\" % (sym)\n1211 \n1212         need_exp = False\n1213         if exp is not None:\n1214             if tex.find('^') == -1:\n1215                 tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1216             else:\n1217                 need_exp = True\n1218 \n1219         tex = r\"%s_{%s}\\left(%s\\right)\" % (tex, self._print(expr.order),\n1220                                            self._print(expr.argument))\n1221 \n1222         if need_exp:\n1223             tex = self._do_exponent(tex, exp)\n1224         return tex\n1225 \n1226     def _hprint_vec(self, vec):\n1227         if not vec:\n1228             return \"\"\n1229         s = \"\"\n1230         for i in vec[:-1]:\n1231             s += \"%s, \" % self._print(i)\n1232         s += self._print(vec[-1])\n1233         return s\n1234 \n1235     def _print_besselj(self, expr, exp=None):\n1236         return self._hprint_BesselBase(expr, exp, 'J')\n1237 \n1238     def _print_besseli(self, expr, exp=None):\n1239         return self._hprint_BesselBase(expr, exp, 'I')\n1240 \n1241     def _print_besselk(self, expr, exp=None):\n1242         return self._hprint_BesselBase(expr, exp, 'K')\n1243 \n1244     def _print_bessely(self, expr, exp=None):\n1245         return self._hprint_BesselBase(expr, exp, 'Y')\n1246 \n1247     def _print_yn(self, expr, exp=None):\n1248         return self._hprint_BesselBase(expr, exp, 'y')\n1249 \n1250     def _print_jn(self, expr, exp=None):\n1251         return self._hprint_BesselBase(expr, exp, 'j')\n1252 \n1253     def _print_hankel1(self, expr, exp=None):\n1254         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')\n1255 \n1256     def _print_hankel2(self, expr, exp=None):\n1257         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')\n1258 \n1259     def _print_hn1(self, expr, exp=None):\n1260         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')\n1261 \n1262     def _print_hn2(self, expr, exp=None):\n1263         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')\n1264 \n1265     def _hprint_airy(self, expr, exp=None, notation=\"\"):\n1266         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1267 \n1268         if exp is not None:\n1269             return r\"%s^{%s}%s\" % (notation, exp, tex)\n1270         else:\n1271             return r\"%s%s\" % (notation, tex)\n1272 \n1273     def _hprint_airy_prime(self, expr, exp=None, notation=\"\"):\n1274         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1275 \n1276         if exp is not None:\n1277             return r\"{%s^\\prime}^{%s}%s\" % (notation, exp, tex)\n1278         else:\n1279             return r\"%s^\\prime%s\" % (notation, tex)\n1280 \n1281     def _print_airyai(self, expr, exp=None):\n1282         return self._hprint_airy(expr, exp, 'Ai')\n1283 \n1284     def _print_airybi(self, expr, exp=None):\n1285         return self._hprint_airy(expr, exp, 'Bi')\n1286 \n1287     def _print_airyaiprime(self, expr, exp=None):\n1288         return self._hprint_airy_prime(expr, exp, 'Ai')\n1289 \n1290     def _print_airybiprime(self, expr, exp=None):\n1291         return self._hprint_airy_prime(expr, exp, 'Bi')\n1292 \n1293     def _print_hyper(self, expr, exp=None):\n1294         tex = r\"{{}_{%s}F_{%s}\\left(\\begin{matrix} %s \\\\ %s \\end{matrix}\" \\\n1295               r\"\\middle| {%s} \\right)}\" % \\\n1296             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1297               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),\n1298               self._print(expr.argument))\n1299 \n1300         if exp is not None:\n1301             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1302         return tex\n1303 \n1304     def _print_meijerg(self, expr, exp=None):\n1305         tex = r\"{G_{%s, %s}^{%s, %s}\\left(\\begin{matrix} %s & %s \\\\\" \\\n1306               r\"%s & %s \\end{matrix} \\middle| {%s} \\right)}\" % \\\n1307             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1308               self._print(len(expr.bm)), self._print(len(expr.an)),\n1309               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),\n1310               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),\n1311               self._print(expr.argument))\n1312 \n1313         if exp is not None:\n1314             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1315         return tex\n1316 \n1317     def _print_dirichlet_eta(self, expr, exp=None):\n1318         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1319         if exp is not None:\n1320             return r\"\\eta^{%s}%s\" % (self._print(exp), tex)\n1321         return r\"\\eta%s\" % tex\n1322 \n1323     def _print_zeta(self, expr, exp=None):\n1324         if len(expr.args) == 2:\n1325             tex = r\"\\left(%s, %s\\right)\" % tuple(map(self._print, expr.args))\n1326         else:\n1327             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1328         if exp is not None:\n1329             return r\"\\zeta^{%s}%s\" % (self._print(exp), tex)\n1330         return r\"\\zeta%s\" % tex\n1331 \n1332     def _print_stieltjes(self, expr, exp=None):\n1333         if len(expr.args) == 2:\n1334             tex = r\"_{%s}\\left(%s\\right)\" % tuple(map(self._print, expr.args))\n1335         else:\n1336             tex = r\"_{%s}\" % self._print(expr.args[0])\n1337         if exp is not None:\n1338             return r\"\\gamma%s^{%s}\" % (tex, self._print(exp))\n1339         return r\"\\gamma%s\" % tex\n1340 \n1341     def _print_lerchphi(self, expr, exp=None):\n1342         tex = r\"\\left(%s, %s, %s\\right)\" % tuple(map(self._print, expr.args))\n1343         if exp is None:\n1344             return r\"\\Phi%s\" % tex\n1345         return r\"\\Phi^{%s}%s\" % (self._print(exp), tex)\n1346 \n1347     def _print_polylog(self, expr, exp=None):\n1348         s, z = map(self._print, expr.args)\n1349         tex = r\"\\left(%s\\right)\" % z\n1350         if exp is None:\n1351             return r\"\\operatorname{Li}_{%s}%s\" % (s, tex)\n1352         return r\"\\operatorname{Li}_{%s}^{%s}%s\" % (s, self._print(exp), tex)\n1353 \n1354     def _print_jacobi(self, expr, exp=None):\n1355         n, a, b, x = map(self._print, expr.args)\n1356         tex = r\"P_{%s}^{\\left(%s,%s\\right)}\\left(%s\\right)\" % (n, a, b, x)\n1357         if exp is not None:\n1358             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1359         return tex\n1360 \n1361     def _print_gegenbauer(self, expr, exp=None):\n1362         n, a, x = map(self._print, expr.args)\n1363         tex = r\"C_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1364         if exp is not None:\n1365             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1366         return tex\n1367 \n1368     def _print_chebyshevt(self, expr, exp=None):\n1369         n, x = map(self._print, expr.args)\n1370         tex = r\"T_{%s}\\left(%s\\right)\" % (n, x)\n1371         if exp is not None:\n1372             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1373         return tex\n1374 \n1375     def _print_chebyshevu(self, expr, exp=None):\n1376         n, x = map(self._print, expr.args)\n1377         tex = r\"U_{%s}\\left(%s\\right)\" % (n, x)\n1378         if exp is not None:\n1379             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1380         return tex\n1381 \n1382     def _print_legendre(self, expr, exp=None):\n1383         n, x = map(self._print, expr.args)\n1384         tex = r\"P_{%s}\\left(%s\\right)\" % (n, x)\n1385         if exp is not None:\n1386             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1387         return tex\n1388 \n1389     def _print_assoc_legendre(self, expr, exp=None):\n1390         n, a, x = map(self._print, expr.args)\n1391         tex = r\"P_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1392         if exp is not None:\n1393             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1394         return tex\n1395 \n1396     def _print_hermite(self, expr, exp=None):\n1397         n, x = map(self._print, expr.args)\n1398         tex = r\"H_{%s}\\left(%s\\right)\" % (n, x)\n1399         if exp is not None:\n1400             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1401         return tex\n1402 \n1403     def _print_laguerre(self, expr, exp=None):\n1404         n, x = map(self._print, expr.args)\n1405         tex = r\"L_{%s}\\left(%s\\right)\" % (n, x)\n1406         if exp is not None:\n1407             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1408         return tex\n1409 \n1410     def _print_assoc_laguerre(self, expr, exp=None):\n1411         n, a, x = map(self._print, expr.args)\n1412         tex = r\"L_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1413         if exp is not None:\n1414             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1415         return tex\n1416 \n1417     def _print_Ynm(self, expr, exp=None):\n1418         n, m, theta, phi = map(self._print, expr.args)\n1419         tex = r\"Y_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1420         if exp is not None:\n1421             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1422         return tex\n1423 \n1424     def _print_Znm(self, expr, exp=None):\n1425         n, m, theta, phi = map(self._print, expr.args)\n1426         tex = r\"Z_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1427         if exp is not None:\n1428             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1429         return tex\n1430 \n1431     def __print_mathieu_functions(self, character, args, prime=False, exp=None):\n1432         a, q, z = map(self._print, args)\n1433         sup = r\"^{\\prime}\" if prime else \"\"\n1434         exp = \"\" if not exp else \"^{%s}\" % self._print(exp)\n1435         return r\"%s%s\\left(%s, %s, %s\\right)%s\" % (character, sup, a, q, z, exp)\n1436 \n1437     def _print_mathieuc(self, expr, exp=None):\n1438         return self.__print_mathieu_functions(\"C\", expr.args, exp=exp)\n1439 \n1440     def _print_mathieus(self, expr, exp=None):\n1441         return self.__print_mathieu_functions(\"S\", expr.args, exp=exp)\n1442 \n1443     def _print_mathieucprime(self, expr, exp=None):\n1444         return self.__print_mathieu_functions(\"C\", expr.args, prime=True, exp=exp)\n1445 \n1446     def _print_mathieusprime(self, expr, exp=None):\n1447         return self.__print_mathieu_functions(\"S\", expr.args, prime=True, exp=exp)\n1448 \n1449     def _print_Rational(self, expr):\n1450         if expr.q != 1:\n1451             sign = \"\"\n1452             p = expr.p\n1453             if expr.p < 0:\n1454                 sign = \"- \"\n1455                 p = -p\n1456             if self._settings['fold_short_frac']:\n1457                 return r\"%s%d / %d\" % (sign, p, expr.q)\n1458             return r\"%s\\frac{%d}{%d}\" % (sign, p, expr.q)\n1459         else:\n1460             return self._print(expr.p)\n1461 \n1462     def _print_Order(self, expr):\n1463         s = self._print(expr.expr)\n1464         if expr.point and any(p != S.Zero for p in expr.point) or \\\n1465            len(expr.variables) > 1:\n1466             s += '; '\n1467             if len(expr.variables) > 1:\n1468                 s += self._print(expr.variables)\n1469             elif expr.variables:\n1470                 s += self._print(expr.variables[0])\n1471             s += r'\\rightarrow '\n1472             if len(expr.point) > 1:\n1473                 s += self._print(expr.point)\n1474             else:\n1475                 s += self._print(expr.point[0])\n1476         return r\"O\\left(%s\\right)\" % s\n1477 \n1478     def _print_Symbol(self, expr, style='plain'):\n1479         if expr in self._settings['symbol_names']:\n1480             return self._settings['symbol_names'][expr]\n1481 \n1482         result = self._deal_with_super_sub(expr.name) if \\\n1483             '\\\\' not in expr.name else expr.name\n1484 \n1485         if style == 'bold':\n1486             result = r\"\\mathbf{{{}}}\".format(result)\n1487 \n1488         return result\n1489 \n1490     _print_RandomSymbol = _print_Symbol\n1491 \n1492     def _deal_with_super_sub(self, string):\n1493         if '{' in string:\n1494             return string\n1495 \n1496         name, supers, subs = split_super_sub(string)\n1497 \n1498         name = translate(name)\n1499         supers = [translate(sup) for sup in supers]\n1500         subs = [translate(sub) for sub in subs]\n1501 \n1502         # glue all items together:\n1503         if supers:\n1504             name += \"^{%s}\" % \" \".join(supers)\n1505         if subs:\n1506             name += \"_{%s}\" % \" \".join(subs)\n1507 \n1508         return name\n1509 \n1510     def _print_Relational(self, expr):\n1511         if self._settings['itex']:\n1512             gt = r\"\\gt\"\n1513             lt = r\"\\lt\"\n1514         else:\n1515             gt = \">\"\n1516             lt = \"<\"\n1517 \n1518         charmap = {\n1519             \"==\": \"=\",\n1520             \">\": gt,\n1521             \"<\": lt,\n1522             \">=\": r\"\\geq\",\n1523             \"<=\": r\"\\leq\",\n1524             \"!=\": r\"\\neq\",\n1525         }\n1526 \n1527         return \"%s %s %s\" % (self._print(expr.lhs),\n1528                              charmap[expr.rel_op], self._print(expr.rhs))\n1529 \n1530     def _print_Piecewise(self, expr):\n1531         ecpairs = [r\"%s & \\text{for}\\: %s\" % (self._print(e), self._print(c))\n1532                    for e, c in expr.args[:-1]]\n1533         if expr.args[-1].cond == true:\n1534             ecpairs.append(r\"%s & \\text{otherwise}\" %\n1535                            self._print(expr.args[-1].expr))\n1536         else:\n1537             ecpairs.append(r\"%s & \\text{for}\\: %s\" %\n1538                            (self._print(expr.args[-1].expr),\n1539                             self._print(expr.args[-1].cond)))\n1540         tex = r\"\\begin{cases} %s \\end{cases}\"\n1541         return tex % r\" \\\\\".join(ecpairs)\n1542 \n1543     def _print_MatrixBase(self, expr):\n1544         lines = []\n1545 \n1546         for line in range(expr.rows):  # horrible, should be 'rows'\n1547             lines.append(\" & \".join([self._print(i) for i in expr[line, :]]))\n1548 \n1549         mat_str = self._settings['mat_str']\n1550         if mat_str is None:\n1551             if self._settings['mode'] == 'inline':\n1552                 mat_str = 'smallmatrix'\n1553             else:\n1554                 if (expr.cols <= 10) is True:\n1555                     mat_str = 'matrix'\n1556                 else:\n1557                     mat_str = 'array'\n1558 \n1559         out_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1560         out_str = out_str.replace('%MATSTR%', mat_str)\n1561         if mat_str == 'array':\n1562             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')\n1563         if self._settings['mat_delim']:\n1564             left_delim = self._settings['mat_delim']\n1565             right_delim = self._delim_dict[left_delim]\n1566             out_str = r'\\left' + left_delim + out_str + \\\n1567                       r'\\right' + right_delim\n1568         return out_str % r\"\\\\\".join(lines)\n1569     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \\\n1570                            = _print_Matrix \\\n1571                            = _print_MatrixBase\n1572 \n1573     def _print_MatrixElement(self, expr):\n1574         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True)\\\n1575             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))\n1576 \n1577     def _print_MatrixSlice(self, expr):\n1578         def latexslice(x):\n1579             x = list(x)\n1580             if x[2] == 1:\n1581                 del x[2]\n1582             if x[1] == x[0] + 1:\n1583                 del x[1]\n1584             if x[0] == 0:\n1585                 x[0] = ''\n1586             return ':'.join(map(self._print, x))\n1587         return (self._print(expr.parent) + r'\\left[' +\n1588                 latexslice(expr.rowslice) + ', ' +\n1589                 latexslice(expr.colslice) + r'\\right]')\n1590 \n1591     def _print_BlockMatrix(self, expr):\n1592         return self._print(expr.blocks)\n1593 \n1594     def _print_Transpose(self, expr):\n1595         mat = expr.arg\n1596         from sympy.matrices import MatrixSymbol\n1597         if not isinstance(mat, MatrixSymbol):\n1598             return r\"\\left(%s\\right)^{T}\" % self._print(mat)\n1599         else:\n1600             return \"%s^{T}\" % self.parenthesize(mat, precedence_traditional(expr), True)\n1601 \n1602     def _print_Trace(self, expr):\n1603         mat = expr.arg\n1604         return r\"\\operatorname{tr}\\left(%s \\right)\" % self._print(mat)\n1605 \n1606     def _print_Adjoint(self, expr):\n1607         mat = expr.arg\n1608         from sympy.matrices import MatrixSymbol\n1609         if not isinstance(mat, MatrixSymbol):\n1610             return r\"\\left(%s\\right)^{\\dagger}\" % self._print(mat)\n1611         else:\n1612             return r\"%s^{\\dagger}\" % self._print(mat)\n1613 \n1614     def _print_MatMul(self, expr):\n1615         from sympy import MatMul, Mul\n1616 \n1617         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),\n1618                                              False)\n1619 \n1620         args = expr.args\n1621         if isinstance(args[0], Mul):\n1622             args = args[0].as_ordered_factors() + list(args[1:])\n1623         else:\n1624             args = list(args)\n1625 \n1626         if isinstance(expr, MatMul) and _coeff_isneg(expr):\n1627             if args[0] == -1:\n1628                 args = args[1:]\n1629             else:\n1630                 args[0] = -args[0]\n1631             return '- ' + ' '.join(map(parens, args))\n1632         else:\n1633             return ' '.join(map(parens, args))\n1634 \n1635     def _print_Mod(self, expr, exp=None):\n1636         if exp is not None:\n1637             return r'\\left(%s\\bmod{%s}\\right)^{%s}' % \\\n1638                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],\n1639                                    strict=True), self._print(expr.args[1]),\n1640                  self._print(exp))\n1641         return r'%s\\bmod{%s}' % (self.parenthesize(expr.args[0],\n1642                                  PRECEDENCE['Mul'], strict=True),\n1643                                  self._print(expr.args[1]))\n1644 \n1645     def _print_HadamardProduct(self, expr):\n1646         args = expr.args\n1647         prec = PRECEDENCE['Pow']\n1648         parens = self.parenthesize\n1649 \n1650         return r' \\circ '.join(\n1651             map(lambda arg: parens(arg, prec, strict=True), args))\n1652 \n1653     def _print_HadamardPower(self, expr):\n1654         if precedence_traditional(expr.exp) < PRECEDENCE[\"Mul\"]:\n1655             template = r\"%s^{\\circ \\left({%s}\\right)}\"\n1656         else:\n1657             template = r\"%s^{\\circ {%s}}\"\n1658         return self._helper_print_standard_power(expr, template)\n1659 \n1660     def _print_KroneckerProduct(self, expr):\n1661         args = expr.args\n1662         prec = PRECEDENCE['Pow']\n1663         parens = self.parenthesize\n1664 \n1665         return r' \\otimes '.join(\n1666             map(lambda arg: parens(arg, prec, strict=True), args))\n1667 \n1668     def _print_MatPow(self, expr):\n1669         base, exp = expr.base, expr.exp\n1670         from sympy.matrices import MatrixSymbol\n1671         if not isinstance(base, MatrixSymbol):\n1672             return \"\\\\left(%s\\\\right)^{%s}\" % (self._print(base),\n1673                                               self._print(exp))\n1674         else:\n1675             return \"%s^{%s}\" % (self._print(base), self._print(exp))\n1676 \n1677     def _print_MatrixSymbol(self, expr):\n1678         return self._print_Symbol(expr, style=self._settings[\n1679             'mat_symbol_style'])\n1680 \n1681     def _print_ZeroMatrix(self, Z):\n1682         return r\"\\mathbb{0}\" if self._settings[\n1683             'mat_symbol_style'] == 'plain' else r\"\\mathbf{0}\"\n1684 \n1685     def _print_OneMatrix(self, O):\n1686         return r\"\\mathbb{1}\" if self._settings[\n1687             'mat_symbol_style'] == 'plain' else r\"\\mathbf{1}\"\n1688 \n1689     def _print_Identity(self, I):\n1690         return r\"\\mathbb{I}\" if self._settings[\n1691             'mat_symbol_style'] == 'plain' else r\"\\mathbf{I}\"\n1692 \n1693     def _print_PermutationMatrix(self, P):\n1694         perm_str = self._print(P.args[0])\n1695         return \"P_{%s}\" % perm_str\n1696 \n1697     def _print_NDimArray(self, expr):\n1698 \n1699         if expr.rank() == 0:\n1700             return self._print(expr[()])\n1701 \n1702         mat_str = self._settings['mat_str']\n1703         if mat_str is None:\n1704             if self._settings['mode'] == 'inline':\n1705                 mat_str = 'smallmatrix'\n1706             else:\n1707                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):\n1708                     mat_str = 'matrix'\n1709                 else:\n1710                     mat_str = 'array'\n1711         block_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1712         block_str = block_str.replace('%MATSTR%', mat_str)\n1713         if self._settings['mat_delim']:\n1714             left_delim = self._settings['mat_delim']\n1715             right_delim = self._delim_dict[left_delim]\n1716             block_str = r'\\left' + left_delim + block_str + \\\n1717                         r'\\right' + right_delim\n1718 \n1719         if expr.rank() == 0:\n1720             return block_str % \"\"\n1721 \n1722         level_str = [[]] + [[] for i in range(expr.rank())]\n1723         shape_ranges = [list(range(i)) for i in expr.shape]\n1724         for outer_i in itertools.product(*shape_ranges):\n1725             level_str[-1].append(self._print(expr[outer_i]))\n1726             even = True\n1727             for back_outer_i in range(expr.rank()-1, -1, -1):\n1728                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:\n1729                     break\n1730                 if even:\n1731                     level_str[back_outer_i].append(\n1732                         r\" & \".join(level_str[back_outer_i+1]))\n1733                 else:\n1734                     level_str[back_outer_i].append(\n1735                         block_str % (r\"\\\\\".join(level_str[back_outer_i+1])))\n1736                     if len(level_str[back_outer_i+1]) == 1:\n1737                         level_str[back_outer_i][-1] = r\"\\left[\" + \\\n1738                             level_str[back_outer_i][-1] + r\"\\right]\"\n1739                 even = not even\n1740                 level_str[back_outer_i+1] = []\n1741 \n1742         out_str = level_str[0][0]\n1743 \n1744         if expr.rank() % 2 == 1:\n1745             out_str = block_str % out_str\n1746 \n1747         return out_str\n1748 \n1749     _print_ImmutableDenseNDimArray = _print_NDimArray\n1750     _print_ImmutableSparseNDimArray = _print_NDimArray\n1751     _print_MutableDenseNDimArray = _print_NDimArray\n1752     _print_MutableSparseNDimArray = _print_NDimArray\n1753 \n1754     def _printer_tensor_indices(self, name, indices, index_map={}):\n1755         out_str = self._print(name)\n1756         last_valence = None\n1757         prev_map = None\n1758         for index in indices:\n1759             new_valence = index.is_up\n1760             if ((index in index_map) or prev_map) and \\\n1761                     last_valence == new_valence:\n1762                 out_str += \",\"\n1763             if last_valence != new_valence:\n1764                 if last_valence is not None:\n1765                     out_str += \"}\"\n1766                 if index.is_up:\n1767                     out_str += \"{}^{\"\n1768                 else:\n1769                     out_str += \"{}_{\"\n1770             out_str += self._print(index.args[0])\n1771             if index in index_map:\n1772                 out_str += \"=\"\n1773                 out_str += self._print(index_map[index])\n1774                 prev_map = True\n1775             else:\n1776                 prev_map = False\n1777             last_valence = new_valence\n1778         if last_valence is not None:\n1779             out_str += \"}\"\n1780         return out_str\n1781 \n1782     def _print_Tensor(self, expr):\n1783         name = expr.args[0].args[0]\n1784         indices = expr.get_indices()\n1785         return self._printer_tensor_indices(name, indices)\n1786 \n1787     def _print_TensorElement(self, expr):\n1788         name = expr.expr.args[0].args[0]\n1789         indices = expr.expr.get_indices()\n1790         index_map = expr.index_map\n1791         return self._printer_tensor_indices(name, indices, index_map)\n1792 \n1793     def _print_TensMul(self, expr):\n1794         # prints expressions like \"A(a)\", \"3*A(a)\", \"(1+x)*A(a)\"\n1795         sign, args = expr._get_args_for_traditional_printer()\n1796         return sign + \"\".join(\n1797             [self.parenthesize(arg, precedence(expr)) for arg in args]\n1798         )\n1799 \n1800     def _print_TensAdd(self, expr):\n1801         a = []\n1802         args = expr.args\n1803         for x in args:\n1804             a.append(self.parenthesize(x, precedence(expr)))\n1805         a.sort()\n1806         s = ' + '.join(a)\n1807         s = s.replace('+ -', '- ')\n1808         return s\n1809 \n1810     def _print_TensorIndex(self, expr):\n1811         return \"{}%s{%s}\" % (\n1812             \"^\" if expr.is_up else \"_\",\n1813             self._print(expr.args[0])\n1814         )\n1815 \n1816     def _print_PartialDerivative(self, expr):\n1817         if len(expr.variables) == 1:\n1818             return r\"\\frac{\\partial}{\\partial {%s}}{%s}\" % (\n1819                 self._print(expr.variables[0]),\n1820                 self.parenthesize(expr.expr, PRECEDENCE[\"Mul\"], False)\n1821             )\n1822         else:\n1823             return r\"\\frac{\\partial^{%s}}{%s}{%s}\" % (\n1824                 len(expr.variables),\n1825                 \" \".join([r\"\\partial {%s}\" % self._print(i) for i in expr.variables]),\n1826                 self.parenthesize(expr.expr, PRECEDENCE[\"Mul\"], False)\n1827             )\n1828 \n1829     def _print_UniversalSet(self, expr):\n1830         return r\"\\mathbb{U}\"\n1831 \n1832     def _print_frac(self, expr, exp=None):\n1833         if exp is None:\n1834             return r\"\\operatorname{frac}{\\left(%s\\right)}\" % self._print(expr.args[0])\n1835         else:\n1836             return r\"\\operatorname{frac}{\\left(%s\\right)}^{%s}\" % (\n1837                     self._print(expr.args[0]), self._print(exp))\n1838 \n1839     def _print_tuple(self, expr):\n1840         if self._settings['decimal_separator'] =='comma':\n1841             return r\"\\left( %s\\right)\" % \\\n1842                 r\"; \\  \".join([self._print(i) for i in expr])\n1843         elif self._settings['decimal_separator'] =='period':\n1844             return r\"\\left( %s\\right)\" % \\\n1845                 r\", \\  \".join([self._print(i) for i in expr])\n1846         else:\n1847             raise ValueError('Unknown Decimal Separator')\n1848 \n1849     def _print_TensorProduct(self, expr):\n1850         elements = [self._print(a) for a in expr.args]\n1851         return r' \\otimes '.join(elements)\n1852 \n1853     def _print_WedgeProduct(self, expr):\n1854         elements = [self._print(a) for a in expr.args]\n1855         return r' \\wedge '.join(elements)\n1856 \n1857     def _print_Tuple(self, expr):\n1858         return self._print_tuple(expr)\n1859 \n1860     def _print_list(self, expr):\n1861         if self._settings['decimal_separator'] == 'comma':\n1862             return r\"\\left[ %s\\right]\" % \\\n1863                 r\"; \\  \".join([self._print(i) for i in expr])\n1864         elif self._settings['decimal_separator'] == 'period':\n1865             return r\"\\left[ %s\\right]\" % \\\n1866                 r\", \\  \".join([self._print(i) for i in expr])\n1867         else:\n1868             raise ValueError('Unknown Decimal Separator')\n1869 \n1870 \n1871     def _print_dict(self, d):\n1872         keys = sorted(d.keys(), key=default_sort_key)\n1873         items = []\n1874 \n1875         for key in keys:\n1876             val = d[key]\n1877             items.append(\"%s : %s\" % (self._print(key), self._print(val)))\n1878 \n1879         return r\"\\left\\{ %s\\right\\}\" % r\", \\  \".join(items)\n1880 \n1881     def _print_Dict(self, expr):\n1882         return self._print_dict(expr)\n1883 \n1884     def _print_DiracDelta(self, expr, exp=None):\n1885         if len(expr.args) == 1 or expr.args[1] == 0:\n1886             tex = r\"\\delta\\left(%s\\right)\" % self._print(expr.args[0])\n1887         else:\n1888             tex = r\"\\delta^{\\left( %s \\right)}\\left( %s \\right)\" % (\n1889                 self._print(expr.args[1]), self._print(expr.args[0]))\n1890         if exp:\n1891             tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1892         return tex\n1893 \n1894     def _print_SingularityFunction(self, expr):\n1895         shift = self._print(expr.args[0] - expr.args[1])\n1896         power = self._print(expr.args[2])\n1897         tex = r\"{\\left\\langle %s \\right\\rangle}^{%s}\" % (shift, power)\n1898         return tex\n1899 \n1900     def _print_Heaviside(self, expr, exp=None):\n1901         tex = r\"\\theta\\left(%s\\right)\" % self._print(expr.args[0])\n1902         if exp:\n1903             tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1904         return tex\n1905 \n1906     def _print_KroneckerDelta(self, expr, exp=None):\n1907         i = self._print(expr.args[0])\n1908         j = self._print(expr.args[1])\n1909         if expr.args[0].is_Atom and expr.args[1].is_Atom:\n1910             tex = r'\\delta_{%s %s}' % (i, j)\n1911         else:\n1912             tex = r'\\delta_{%s, %s}' % (i, j)\n1913         if exp is not None:\n1914             tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n1915         return tex\n1916 \n1917     def _print_LeviCivita(self, expr, exp=None):\n1918         indices = map(self._print, expr.args)\n1919         if all(x.is_Atom for x in expr.args):\n1920             tex = r'\\varepsilon_{%s}' % \" \".join(indices)\n1921         else:\n1922             tex = r'\\varepsilon_{%s}' % \", \".join(indices)\n1923         if exp:\n1924             tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n1925         return tex\n1926 \n1927     def _print_RandomDomain(self, d):\n1928         if hasattr(d, 'as_boolean'):\n1929             return '\\\\text{Domain: }' + self._print(d.as_boolean())\n1930         elif hasattr(d, 'set'):\n1931             return ('\\\\text{Domain: }' + self._print(d.symbols) + '\\\\text{ in }' +\n1932                     self._print(d.set))\n1933         elif hasattr(d, 'symbols'):\n1934             return '\\\\text{Domain on }' + self._print(d.symbols)\n1935         else:\n1936             return self._print(None)\n1937 \n1938     def _print_FiniteSet(self, s):\n1939         items = sorted(s.args, key=default_sort_key)\n1940         return self._print_set(items)\n1941 \n1942     def _print_set(self, s):\n1943         items = sorted(s, key=default_sort_key)\n1944         if self._settings['decimal_separator'] == 'comma':\n1945             items = \"; \".join(map(self._print, items))\n1946         elif self._settings['decimal_separator'] == 'period':\n1947             items = \", \".join(map(self._print, items))\n1948         else:\n1949             raise ValueError('Unknown Decimal Separator')\n1950         return r\"\\left\\{%s\\right\\}\" % items\n1951 \n1952 \n1953     _print_frozenset = _print_set\n1954 \n1955     def _print_Range(self, s):\n1956         dots = r'\\ldots'\n1957 \n1958         if s.has(Symbol):\n1959             return self._print_Basic(s)\n1960 \n1961         if s.start.is_infinite and s.stop.is_infinite:\n1962             if s.step.is_positive:\n1963                 printset = dots, -1, 0, 1, dots\n1964             else:\n1965                 printset = dots, 1, 0, -1, dots\n1966         elif s.start.is_infinite:\n1967             printset = dots, s[-1] - s.step, s[-1]\n1968         elif s.stop.is_infinite:\n1969             it = iter(s)\n1970             printset = next(it), next(it), dots\n1971         elif len(s) > 4:\n1972             it = iter(s)\n1973             printset = next(it), next(it), dots, s[-1]\n1974         else:\n1975             printset = tuple(s)\n1976 \n1977         return (r\"\\left\\{\" +\n1978                 r\", \".join(self._print(el) for el in printset) +\n1979                 r\"\\right\\}\")\n1980 \n1981     def __print_number_polynomial(self, expr, letter, exp=None):\n1982         if len(expr.args) == 2:\n1983             if exp is not None:\n1984                 return r\"%s_{%s}^{%s}\\left(%s\\right)\" % (letter,\n1985                             self._print(expr.args[0]), self._print(exp),\n1986                             self._print(expr.args[1]))\n1987             return r\"%s_{%s}\\left(%s\\right)\" % (letter,\n1988                         self._print(expr.args[0]), self._print(expr.args[1]))\n1989 \n1990         tex = r\"%s_{%s}\" % (letter, self._print(expr.args[0]))\n1991         if exp is not None:\n1992             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1993         return tex\n1994 \n1995     def _print_bernoulli(self, expr, exp=None):\n1996         return self.__print_number_polynomial(expr, \"B\", exp)\n1997 \n1998     def _print_bell(self, expr, exp=None):\n1999         if len(expr.args) == 3:\n2000             tex1 = r\"B_{%s, %s}\" % (self._print(expr.args[0]),\n2001                                 self._print(expr.args[1]))\n2002             tex2 = r\"\\left(%s\\right)\" % r\", \".join(self._print(el) for\n2003                                                el in expr.args[2])\n2004             if exp is not None:\n2005                 tex = r\"%s^{%s}%s\" % (tex1, self._print(exp), tex2)\n2006             else:\n2007                 tex = tex1 + tex2\n2008             return tex\n2009         return self.__print_number_polynomial(expr, \"B\", exp)\n2010 \n2011 \n2012     def _print_fibonacci(self, expr, exp=None):\n2013         return self.__print_number_polynomial(expr, \"F\", exp)\n2014 \n2015     def _print_lucas(self, expr, exp=None):\n2016         tex = r\"L_{%s}\" % self._print(expr.args[0])\n2017         if exp is not None:\n2018             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2019         return tex\n2020 \n2021     def _print_tribonacci(self, expr, exp=None):\n2022         return self.__print_number_polynomial(expr, \"T\", exp)\n2023 \n2024     def _print_SeqFormula(self, s):\n2025         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:\n2026             return r\"\\left\\{%s\\right\\}_{%s=%s}^{%s}\" % (\n2027                 self._print(s.formula),\n2028                 self._print(s.variables[0]),\n2029                 self._print(s.start),\n2030                 self._print(s.stop)\n2031             )\n2032         if s.start is S.NegativeInfinity:\n2033             stop = s.stop\n2034             printset = (r'\\ldots', s.coeff(stop - 3), s.coeff(stop - 2),\n2035                         s.coeff(stop - 1), s.coeff(stop))\n2036         elif s.stop is S.Infinity or s.length > 4:\n2037             printset = s[:4]\n2038             printset.append(r'\\ldots')\n2039         else:\n2040             printset = tuple(s)\n2041 \n2042         return (r\"\\left[\" +\n2043                 r\", \".join(self._print(el) for el in printset) +\n2044                 r\"\\right]\")\n2045 \n2046     _print_SeqPer = _print_SeqFormula\n2047     _print_SeqAdd = _print_SeqFormula\n2048     _print_SeqMul = _print_SeqFormula\n2049 \n2050     def _print_Interval(self, i):\n2051         if i.start == i.end:\n2052             return r\"\\left\\{%s\\right\\}\" % self._print(i.start)\n2053 \n2054         else:\n2055             if i.left_open:\n2056                 left = '('\n2057             else:\n2058                 left = '['\n2059 \n2060             if i.right_open:\n2061                 right = ')'\n2062             else:\n2063                 right = ']'\n2064 \n2065             return r\"\\left%s%s, %s\\right%s\" % \\\n2066                    (left, self._print(i.start), self._print(i.end), right)\n2067 \n2068     def _print_AccumulationBounds(self, i):\n2069         return r\"\\left\\langle %s, %s\\right\\rangle\" % \\\n2070                 (self._print(i.min), self._print(i.max))\n2071 \n2072     def _print_Union(self, u):\n2073         prec = precedence_traditional(u)\n2074         args_str = [self.parenthesize(i, prec) for i in u.args]\n2075         return r\" \\cup \".join(args_str)\n2076 \n2077     def _print_Complement(self, u):\n2078         prec = precedence_traditional(u)\n2079         args_str = [self.parenthesize(i, prec) for i in u.args]\n2080         return r\" \\setminus \".join(args_str)\n2081 \n2082     def _print_Intersection(self, u):\n2083         prec = precedence_traditional(u)\n2084         args_str = [self.parenthesize(i, prec) for i in u.args]\n2085         return r\" \\cap \".join(args_str)\n2086 \n2087     def _print_SymmetricDifference(self, u):\n2088         prec = precedence_traditional(u)\n2089         args_str = [self.parenthesize(i, prec) for i in u.args]\n2090         return r\" \\triangle \".join(args_str)\n2091 \n2092     def _print_ProductSet(self, p):\n2093         prec = precedence_traditional(p)\n2094         if len(p.sets) >= 1 and not has_variety(p.sets):\n2095             return self.parenthesize(p.sets[0], prec) + \"^{%d}\" % len(p.sets)\n2096         return r\" \\times \".join(\n2097             self.parenthesize(set, prec) for set in p.sets)\n2098 \n2099     def _print_EmptySet(self, e):\n2100         return r\"\\emptyset\"\n2101 \n2102     def _print_Naturals(self, n):\n2103         return r\"\\mathbb{N}\"\n2104 \n2105     def _print_Naturals0(self, n):\n2106         return r\"\\mathbb{N}_0\"\n2107 \n2108     def _print_Integers(self, i):\n2109         return r\"\\mathbb{Z}\"\n2110 \n2111     def _print_Rationals(self, i):\n2112         return r\"\\mathbb{Q}\"\n2113 \n2114     def _print_Reals(self, i):\n2115         return r\"\\mathbb{R}\"\n2116 \n2117     def _print_Complexes(self, i):\n2118         return r\"\\mathbb{C}\"\n2119 \n2120     def _print_ImageSet(self, s):\n2121         expr = s.lamda.expr\n2122         sig = s.lamda.signature\n2123         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))\n2124         xinys = r\" , \".join(r\"%s \\in %s\" % xy for xy in xys)\n2125         return r\"\\left\\{%s\\; |\\; %s\\right\\}\" % (self._print(expr), xinys)\n2126 \n2127     def _print_ConditionSet(self, s):\n2128         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])\n2129         if s.base_set is S.UniversalSet:\n2130             return r\"\\left\\{%s \\mid %s \\right\\}\" % \\\n2131                 (vars_print, self._print(s.condition))\n2132 \n2133         return r\"\\left\\{%s \\mid %s \\in %s \\wedge %s \\right\\}\" % (\n2134             vars_print,\n2135             vars_print,\n2136             self._print(s.base_set),\n2137             self._print(s.condition))\n2138 \n2139     def _print_ComplexRegion(self, s):\n2140         vars_print = ', '.join([self._print(var) for var in s.variables])\n2141         return r\"\\left\\{%s\\; |\\; %s \\in %s \\right\\}\" % (\n2142             self._print(s.expr),\n2143             vars_print,\n2144             self._print(s.sets))\n2145 \n2146     def _print_Contains(self, e):\n2147         return r\"%s \\in %s\" % tuple(self._print(a) for a in e.args)\n2148 \n2149     def _print_FourierSeries(self, s):\n2150         return self._print_Add(s.truncate()) + self._print(r' + \\ldots')\n2151 \n2152     def _print_FormalPowerSeries(self, s):\n2153         return self._print_Add(s.infinite)\n2154 \n2155     def _print_FiniteField(self, expr):\n2156         return r\"\\mathbb{F}_{%s}\" % expr.mod\n2157 \n2158     def _print_IntegerRing(self, expr):\n2159         return r\"\\mathbb{Z}\"\n2160 \n2161     def _print_RationalField(self, expr):\n2162         return r\"\\mathbb{Q}\"\n2163 \n2164     def _print_RealField(self, expr):\n2165         return r\"\\mathbb{R}\"\n2166 \n2167     def _print_ComplexField(self, expr):\n2168         return r\"\\mathbb{C}\"\n2169 \n2170     def _print_PolynomialRing(self, expr):\n2171         domain = self._print(expr.domain)\n2172         symbols = \", \".join(map(self._print, expr.symbols))\n2173         return r\"%s\\left[%s\\right]\" % (domain, symbols)\n2174 \n2175     def _print_FractionField(self, expr):\n2176         domain = self._print(expr.domain)\n2177         symbols = \", \".join(map(self._print, expr.symbols))\n2178         return r\"%s\\left(%s\\right)\" % (domain, symbols)\n2179 \n2180     def _print_PolynomialRingBase(self, expr):\n2181         domain = self._print(expr.domain)\n2182         symbols = \", \".join(map(self._print, expr.symbols))\n2183         inv = \"\"\n2184         if not expr.is_Poly:\n2185             inv = r\"S_<^{-1}\"\n2186         return r\"%s%s\\left[%s\\right]\" % (inv, domain, symbols)\n2187 \n2188     def _print_Poly(self, poly):\n2189         cls = poly.__class__.__name__\n2190         terms = []\n2191         for monom, coeff in poly.terms():\n2192             s_monom = ''\n2193             for i, exp in enumerate(monom):\n2194                 if exp > 0:\n2195                     if exp == 1:\n2196                         s_monom += self._print(poly.gens[i])\n2197                     else:\n2198                         s_monom += self._print(pow(poly.gens[i], exp))\n2199 \n2200             if coeff.is_Add:\n2201                 if s_monom:\n2202                     s_coeff = r\"\\left(%s\\right)\" % self._print(coeff)\n2203                 else:\n2204                     s_coeff = self._print(coeff)\n2205             else:\n2206                 if s_monom:\n2207                     if coeff is S.One:\n2208                         terms.extend(['+', s_monom])\n2209                         continue\n2210 \n2211                     if coeff is S.NegativeOne:\n2212                         terms.extend(['-', s_monom])\n2213                         continue\n2214 \n2215                 s_coeff = self._print(coeff)\n2216 \n2217             if not s_monom:\n2218                 s_term = s_coeff\n2219             else:\n2220                 s_term = s_coeff + \" \" + s_monom\n2221 \n2222             if s_term.startswith('-'):\n2223                 terms.extend(['-', s_term[1:]])\n2224             else:\n2225                 terms.extend(['+', s_term])\n2226 \n2227         if terms[0] in ['-', '+']:\n2228             modifier = terms.pop(0)\n2229 \n2230             if modifier == '-':\n2231                 terms[0] = '-' + terms[0]\n2232 \n2233         expr = ' '.join(terms)\n2234         gens = list(map(self._print, poly.gens))\n2235         domain = \"domain=%s\" % self._print(poly.get_domain())\n2236 \n2237         args = \", \".join([expr] + gens + [domain])\n2238         if cls in accepted_latex_functions:\n2239             tex = r\"\\%s {\\left(%s \\right)}\" % (cls, args)\n2240         else:\n2241             tex = r\"\\operatorname{%s}{\\left( %s \\right)}\" % (cls, args)\n2242 \n2243         return tex\n2244 \n2245     def _print_ComplexRootOf(self, root):\n2246         cls = root.__class__.__name__\n2247         if cls == \"ComplexRootOf\":\n2248             cls = \"CRootOf\"\n2249         expr = self._print(root.expr)\n2250         index = root.index\n2251         if cls in accepted_latex_functions:\n2252             return r\"\\%s {\\left(%s, %d\\right)}\" % (cls, expr, index)\n2253         else:\n2254             return r\"\\operatorname{%s} {\\left(%s, %d\\right)}\" % (cls, expr,\n2255                                                                  index)\n2256 \n2257     def _print_RootSum(self, expr):\n2258         cls = expr.__class__.__name__\n2259         args = [self._print(expr.expr)]\n2260 \n2261         if expr.fun is not S.IdentityFunction:\n2262             args.append(self._print(expr.fun))\n2263 \n2264         if cls in accepted_latex_functions:\n2265             return r\"\\%s {\\left(%s\\right)}\" % (cls, \", \".join(args))\n2266         else:\n2267             return r\"\\operatorname{%s} {\\left(%s\\right)}\" % (cls,\n2268                                                              \", \".join(args))\n2269 \n2270     def _print_PolyElement(self, poly):\n2271         mul_symbol = self._settings['mul_symbol_latex']\n2272         return poly.str(self, PRECEDENCE, \"{%s}^{%d}\", mul_symbol)\n2273 \n2274     def _print_FracElement(self, frac):\n2275         if frac.denom == 1:\n2276             return self._print(frac.numer)\n2277         else:\n2278             numer = self._print(frac.numer)\n2279             denom = self._print(frac.denom)\n2280             return r\"\\frac{%s}{%s}\" % (numer, denom)\n2281 \n2282     def _print_euler(self, expr, exp=None):\n2283         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args\n2284         tex = r\"E_{%s}\" % self._print(m)\n2285         if exp is not None:\n2286             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2287         if x is not None:\n2288             tex = r\"%s\\left(%s\\right)\" % (tex, self._print(x))\n2289         return tex\n2290 \n2291     def _print_catalan(self, expr, exp=None):\n2292         tex = r\"C_{%s}\" % self._print(expr.args[0])\n2293         if exp is not None:\n2294             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2295         return tex\n2296 \n2297     def _print_UnifiedTransform(self, expr, s, inverse=False):\n2298         return r\"\\mathcal{{{}}}{}_{{{}}}\\left[{}\\right]\\left({}\\right)\".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2299 \n2300     def _print_MellinTransform(self, expr):\n2301         return self._print_UnifiedTransform(expr, 'M')\n2302 \n2303     def _print_InverseMellinTransform(self, expr):\n2304         return self._print_UnifiedTransform(expr, 'M', True)\n2305 \n2306     def _print_LaplaceTransform(self, expr):\n2307         return self._print_UnifiedTransform(expr, 'L')\n2308 \n2309     def _print_InverseLaplaceTransform(self, expr):\n2310         return self._print_UnifiedTransform(expr, 'L', True)\n2311 \n2312     def _print_FourierTransform(self, expr):\n2313         return self._print_UnifiedTransform(expr, 'F')\n2314 \n2315     def _print_InverseFourierTransform(self, expr):\n2316         return self._print_UnifiedTransform(expr, 'F', True)\n2317 \n2318     def _print_SineTransform(self, expr):\n2319         return self._print_UnifiedTransform(expr, 'SIN')\n2320 \n2321     def _print_InverseSineTransform(self, expr):\n2322         return self._print_UnifiedTransform(expr, 'SIN', True)\n2323 \n2324     def _print_CosineTransform(self, expr):\n2325         return self._print_UnifiedTransform(expr, 'COS')\n2326 \n2327     def _print_InverseCosineTransform(self, expr):\n2328         return self._print_UnifiedTransform(expr, 'COS', True)\n2329 \n2330     def _print_DMP(self, p):\n2331         try:\n2332             if p.ring is not None:\n2333                 # TODO incorporate order\n2334                 return self._print(p.ring.to_sympy(p))\n2335         except SympifyError:\n2336             pass\n2337         return self._print(repr(p))\n2338 \n2339     def _print_DMF(self, p):\n2340         return self._print_DMP(p)\n2341 \n2342     def _print_Object(self, object):\n2343         return self._print(Symbol(object.name))\n2344 \n2345     def _print_LambertW(self, expr):\n2346         if len(expr.args) == 1:\n2347             return r\"W\\left(%s\\right)\" % self._print(expr.args[0])\n2348         return r\"W_{%s}\\left(%s\\right)\" % \\\n2349             (self._print(expr.args[1]), self._print(expr.args[0]))\n2350 \n2351     def _print_Morphism(self, morphism):\n2352         domain = self._print(morphism.domain)\n2353         codomain = self._print(morphism.codomain)\n2354         return \"%s\\\\rightarrow %s\" % (domain, codomain)\n2355 \n2356     def _print_NamedMorphism(self, morphism):\n2357         pretty_name = self._print(Symbol(morphism.name))\n2358         pretty_morphism = self._print_Morphism(morphism)\n2359         return \"%s:%s\" % (pretty_name, pretty_morphism)\n2360 \n2361     def _print_IdentityMorphism(self, morphism):\n2362         from sympy.categories import NamedMorphism\n2363         return self._print_NamedMorphism(NamedMorphism(\n2364             morphism.domain, morphism.codomain, \"id\"))\n2365 \n2366     def _print_CompositeMorphism(self, morphism):\n2367         # All components of the morphism have names and it is thus\n2368         # possible to build the name of the composite.\n2369         component_names_list = [self._print(Symbol(component.name)) for\n2370                                 component in morphism.components]\n2371         component_names_list.reverse()\n2372         component_names = \"\\\\circ \".join(component_names_list) + \":\"\n2373 \n2374         pretty_morphism = self._print_Morphism(morphism)\n2375         return component_names + pretty_morphism\n2376 \n2377     def _print_Category(self, morphism):\n2378         return r\"\\mathbf{{{}}}\".format(self._print(Symbol(morphism.name)))\n2379 \n2380     def _print_Diagram(self, diagram):\n2381         if not diagram.premises:\n2382             # This is an empty diagram.\n2383             return self._print(S.EmptySet)\n2384 \n2385         latex_result = self._print(diagram.premises)\n2386         if diagram.conclusions:\n2387             latex_result += \"\\\\Longrightarrow %s\" % \\\n2388                             self._print(diagram.conclusions)\n2389 \n2390         return latex_result\n2391 \n2392     def _print_DiagramGrid(self, grid):\n2393         latex_result = \"\\\\begin{array}{%s}\\n\" % (\"c\" * grid.width)\n2394 \n2395         for i in range(grid.height):\n2396             for j in range(grid.width):\n2397                 if grid[i, j]:\n2398                     latex_result += latex(grid[i, j])\n2399                 latex_result += \" \"\n2400                 if j != grid.width - 1:\n2401                     latex_result += \"& \"\n2402 \n2403             if i != grid.height - 1:\n2404                 latex_result += \"\\\\\\\\\"\n2405             latex_result += \"\\n\"\n2406 \n2407         latex_result += \"\\\\end{array}\\n\"\n2408         return latex_result\n2409 \n2410     def _print_FreeModule(self, M):\n2411         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))\n2412 \n2413     def _print_FreeModuleElement(self, m):\n2414         # Print as row vector for convenience, for now.\n2415         return r\"\\left[ {} \\right]\".format(\",\".join(\n2416             '{' + self._print(x) + '}' for x in m))\n2417 \n2418     def _print_SubModule(self, m):\n2419         return r\"\\left\\langle {} \\right\\rangle\".format(\",\".join(\n2420             '{' + self._print(x) + '}' for x in m.gens))\n2421 \n2422     def _print_ModuleImplementedIdeal(self, m):\n2423         return r\"\\left\\langle {} \\right\\rangle\".format(\",\".join(\n2424             '{' + self._print(x) + '}' for [x] in m._module.gens))\n2425 \n2426     def _print_Quaternion(self, expr):\n2427         # TODO: This expression is potentially confusing,\n2428         # shall we print it as `Quaternion( ... )`?\n2429         s = [self.parenthesize(i, PRECEDENCE[\"Mul\"], strict=True)\n2430              for i in expr.args]\n2431         a = [s[0]] + [i+\" \"+j for i, j in zip(s[1:], \"ijk\")]\n2432         return \" + \".join(a)\n2433 \n2434     def _print_QuotientRing(self, R):\n2435         # TODO nicer fractions for few generators...\n2436         return r\"\\frac{{{}}}{{{}}}\".format(self._print(R.ring),\n2437                  self._print(R.base_ideal))\n2438 \n2439     def _print_QuotientRingElement(self, x):\n2440         return r\"{{{}}} + {{{}}}\".format(self._print(x.data),\n2441                  self._print(x.ring.base_ideal))\n2442 \n2443     def _print_QuotientModuleElement(self, m):\n2444         return r\"{{{}}} + {{{}}}\".format(self._print(m.data),\n2445                  self._print(m.module.killed_module))\n2446 \n2447     def _print_QuotientModule(self, M):\n2448         # TODO nicer fractions for few generators...\n2449         return r\"\\frac{{{}}}{{{}}}\".format(self._print(M.base),\n2450                  self._print(M.killed_module))\n2451 \n2452     def _print_MatrixHomomorphism(self, h):\n2453         return r\"{{{}}} : {{{}}} \\to {{{}}}\".format(self._print(h._sympy_matrix()),\n2454             self._print(h.domain), self._print(h.codomain))\n2455 \n2456     def _print_BaseScalarField(self, field):\n2457         string = field._coord_sys._names[field._index]\n2458         return r'\\mathbf{{{}}}'.format(self._print(Symbol(string)))\n2459 \n2460     def _print_BaseVectorField(self, field):\n2461         string = field._coord_sys._names[field._index]\n2462         return r'\\partial_{{{}}}'.format(self._print(Symbol(string)))\n2463 \n2464     def _print_Differential(self, diff):\n2465         field = diff._form_field\n2466         if hasattr(field, '_coord_sys'):\n2467             string = field._coord_sys._names[field._index]\n2468             return r'\\operatorname{{d}}{}'.format(self._print(Symbol(string)))\n2469         else:\n2470             string = self._print(field)\n2471             return r'\\operatorname{{d}}\\left({}\\right)'.format(string)\n2472 \n2473     def _print_Tr(self, p):\n2474         # TODO: Handle indices\n2475         contents = self._print(p.args[0])\n2476         return r'\\operatorname{{tr}}\\left({}\\right)'.format(contents)\n2477 \n2478     def _print_totient(self, expr, exp=None):\n2479         if exp is not None:\n2480             return r'\\left(\\phi\\left(%s\\right)\\right)^{%s}' % \\\n2481                 (self._print(expr.args[0]), self._print(exp))\n2482         return r'\\phi\\left(%s\\right)' % self._print(expr.args[0])\n2483 \n2484     def _print_reduced_totient(self, expr, exp=None):\n2485         if exp is not None:\n2486             return r'\\left(\\lambda\\left(%s\\right)\\right)^{%s}' % \\\n2487                 (self._print(expr.args[0]), self._print(exp))\n2488         return r'\\lambda\\left(%s\\right)' % self._print(expr.args[0])\n2489 \n2490     def _print_divisor_sigma(self, expr, exp=None):\n2491         if len(expr.args) == 2:\n2492             tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n2493                                                 (expr.args[1], expr.args[0])))\n2494         else:\n2495             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n2496         if exp is not None:\n2497             return r\"\\sigma^{%s}%s\" % (self._print(exp), tex)\n2498         return r\"\\sigma%s\" % tex\n2499 \n2500     def _print_udivisor_sigma(self, expr, exp=None):\n2501         if len(expr.args) == 2:\n2502             tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n2503                                                 (expr.args[1], expr.args[0])))\n2504         else:\n2505             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n2506         if exp is not None:\n2507             return r\"\\sigma^*^{%s}%s\" % (self._print(exp), tex)\n2508         return r\"\\sigma^*%s\" % tex\n2509 \n2510     def _print_primenu(self, expr, exp=None):\n2511         if exp is not None:\n2512             return r'\\left(\\nu\\left(%s\\right)\\right)^{%s}' % \\\n2513                 (self._print(expr.args[0]), self._print(exp))\n2514         return r'\\nu\\left(%s\\right)' % self._print(expr.args[0])\n2515 \n2516     def _print_primeomega(self, expr, exp=None):\n2517         if exp is not None:\n2518             return r'\\left(\\Omega\\left(%s\\right)\\right)^{%s}' % \\\n2519                 (self._print(expr.args[0]), self._print(exp))\n2520         return r'\\Omega\\left(%s\\right)' % self._print(expr.args[0])\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]