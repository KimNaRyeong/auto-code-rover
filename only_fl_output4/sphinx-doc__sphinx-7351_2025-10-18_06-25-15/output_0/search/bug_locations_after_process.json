[
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/application.py",
        "start": 1,
        "end": 1191,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.application\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Sphinx application class and extensibility interface.\n6 \n7     Gracefully adapted from the TextPress system by Armin.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import os\n14 import pickle\n15 import platform\n16 import sys\n17 import warnings\n18 from collections import deque\n19 from io import StringIO\n20 from os import path\n21 from typing import Any, Callable, Dict, IO, List, Tuple, Union\n22 \n23 from docutils import nodes\n24 from docutils.nodes import Element, TextElement\n25 from docutils.parsers.rst import Directive, roles\n26 from docutils.transforms import Transform\n27 from pygments.lexer import Lexer\n28 \n29 import sphinx\n30 from sphinx import package_dir, locale\n31 from sphinx.config import Config\n32 from sphinx.deprecation import RemovedInSphinx40Warning\n33 from sphinx.domains import Domain, Index\n34 from sphinx.environment import BuildEnvironment\n35 from sphinx.environment.collectors import EnvironmentCollector\n36 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError\n37 from sphinx.events import EventManager\n38 from sphinx.extension import Extension\n39 from sphinx.highlighting import lexer_classes, lexers\n40 from sphinx.locale import __\n41 from sphinx.project import Project\n42 from sphinx.registry import SphinxComponentRegistry\n43 from sphinx.roles import XRefRole\n44 from sphinx.theming import Theme\n45 from sphinx.util import docutils\n46 from sphinx.util import logging\n47 from sphinx.util import progress_message\n48 from sphinx.util.build_phase import BuildPhase\n49 from sphinx.util.console import bold  # type: ignore\n50 from sphinx.util.i18n import CatalogRepository\n51 from sphinx.util.logging import prefixed_warnings\n52 from sphinx.util.osutil import abspath, ensuredir, relpath\n53 from sphinx.util.tags import Tags\n54 from sphinx.util.typing import RoleFunction, TitleGetter\n55 \n56 if False:\n57     # For type annotation\n58     from docutils.nodes import Node  # NOQA\n59     from typing import Type  # for python3.5.1\n60     from sphinx.builders import Builder\n61 \n62 \n63 builtin_extensions = (\n64     'sphinx.addnodes',\n65     'sphinx.builders.changes',\n66     'sphinx.builders.epub3',\n67     'sphinx.builders.dirhtml',\n68     'sphinx.builders.dummy',\n69     'sphinx.builders.gettext',\n70     'sphinx.builders.html',\n71     'sphinx.builders.latex',\n72     'sphinx.builders.linkcheck',\n73     'sphinx.builders.manpage',\n74     'sphinx.builders.singlehtml',\n75     'sphinx.builders.texinfo',\n76     'sphinx.builders.text',\n77     'sphinx.builders.xml',\n78     'sphinx.config',\n79     'sphinx.domains.c',\n80     'sphinx.domains.changeset',\n81     'sphinx.domains.citation',\n82     'sphinx.domains.cpp',\n83     'sphinx.domains.index',\n84     'sphinx.domains.javascript',\n85     'sphinx.domains.math',\n86     'sphinx.domains.python',\n87     'sphinx.domains.rst',\n88     'sphinx.domains.std',\n89     'sphinx.directives',\n90     'sphinx.directives.code',\n91     'sphinx.directives.other',\n92     'sphinx.directives.patches',\n93     'sphinx.extension',\n94     'sphinx.parsers',\n95     'sphinx.registry',\n96     'sphinx.roles',\n97     'sphinx.transforms',\n98     'sphinx.transforms.compact_bullet_list',\n99     'sphinx.transforms.i18n',\n100     'sphinx.transforms.references',\n101     'sphinx.transforms.post_transforms',\n102     'sphinx.transforms.post_transforms.code',\n103     'sphinx.transforms.post_transforms.images',\n104     'sphinx.util.compat',\n105     'sphinx.versioning',\n106     # collectors should be loaded by specific order\n107     'sphinx.environment.collectors.dependencies',\n108     'sphinx.environment.collectors.asset',\n109     'sphinx.environment.collectors.metadata',\n110     'sphinx.environment.collectors.title',\n111     'sphinx.environment.collectors.toctree',\n112     # 1st party extensions\n113     'sphinxcontrib.applehelp',\n114     'sphinxcontrib.devhelp',\n115     'sphinxcontrib.htmlhelp',\n116     'sphinxcontrib.serializinghtml',\n117     'sphinxcontrib.qthelp',\n118     # Strictly, alabaster theme is not a builtin extension,\n119     # but it is loaded automatically to use it as default theme.\n120     'alabaster',\n121 )\n122 \n123 ENV_PICKLE_FILENAME = 'environment.pickle'\n124 \n125 logger = logging.getLogger(__name__)\n126 \n127 \n128 class Sphinx:\n129     \"\"\"The main application class and extensibility interface.\n130 \n131     :ivar srcdir: Directory containing source.\n132     :ivar confdir: Directory containing ``conf.py``.\n133     :ivar doctreedir: Directory for storing pickled doctrees.\n134     :ivar outdir: Directory for storing build documents.\n135     \"\"\"\n136 \n137     def __init__(self, srcdir: str, confdir: str, outdir: str, doctreedir: str,\n138                  buildername: str, confoverrides: Dict = None,\n139                  status: IO = sys.stdout, warning: IO = sys.stderr,\n140                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,\n141                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:\n142         self.phase = BuildPhase.INITIALIZATION\n143         self.verbosity = verbosity\n144         self.extensions = {}                    # type: Dict[str, Extension]\n145         self.builder = None                     # type: Builder\n146         self.env = None                         # type: BuildEnvironment\n147         self.project = None                     # type: Project\n148         self.registry = SphinxComponentRegistry()\n149         self.html_themes = {}                   # type: Dict[str, str]\n150 \n151         # validate provided directories\n152         self.srcdir = abspath(srcdir)\n153         self.outdir = abspath(outdir)\n154         self.doctreedir = abspath(doctreedir)\n155         self.confdir = confdir\n156         if self.confdir:  # confdir is optional\n157             self.confdir = abspath(self.confdir)\n158             if not path.isfile(path.join(self.confdir, 'conf.py')):\n159                 raise ApplicationError(__(\"config directory doesn't contain a \"\n160                                           \"conf.py file (%s)\") % confdir)\n161 \n162         if not path.isdir(self.srcdir):\n163             raise ApplicationError(__('Cannot find source directory (%s)') %\n164                                    self.srcdir)\n165 \n166         if path.exists(self.outdir) and not path.isdir(self.outdir):\n167             raise ApplicationError(__('Output directory (%s) is not a directory') %\n168                                    self.srcdir)\n169 \n170         if self.srcdir == self.outdir:\n171             raise ApplicationError(__('Source directory and destination '\n172                                       'directory cannot be identical'))\n173 \n174         self.parallel = parallel\n175 \n176         if status is None:\n177             self._status = StringIO()      # type: IO\n178             self.quiet = True\n179         else:\n180             self._status = status\n181             self.quiet = False\n182 \n183         if warning is None:\n184             self._warning = StringIO()     # type: IO\n185         else:\n186             self._warning = warning\n187         self._warncount = 0\n188         self.keep_going = warningiserror and keep_going\n189         if self.keep_going:\n190             self.warningiserror = False\n191         else:\n192             self.warningiserror = warningiserror\n193         logging.setup(self, self._status, self._warning)\n194 \n195         self.events = EventManager(self)\n196 \n197         # keep last few messages for traceback\n198         # This will be filled by sphinx.util.logging.LastMessagesWriter\n199         self.messagelog = deque(maxlen=10)  # type: deque\n200 \n201         # say hello to the world\n202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))\n203 \n204         # notice for parallel build on macOS and py38+\n205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:\n206             logger.info(bold(__(\"For security reason, parallel mode is disabled on macOS and \"\n207                                 \"python3.8 and above.  For more details, please read \"\n208                                 \"https://github.com/sphinx-doc/sphinx/issues/6803\")))\n209 \n210         # status code for command-line application\n211         self.statuscode = 0\n212 \n213         # read config\n214         self.tags = Tags(tags)\n215         if self.confdir is None:\n216             self.config = Config({}, confoverrides or {})\n217         else:\n218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)\n219 \n220         # initialize some limited config variables before initialize i18n and loading\n221         # extensions\n222         self.config.pre_init_values()\n223 \n224         # set up translation infrastructure\n225         self._init_i18n()\n226 \n227         # check the Sphinx version if requested\n228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:\n229             raise VersionRequirementError(\n230                 __('This project needs at least Sphinx v%s and therefore cannot '\n231                    'be built with this version.') % self.config.needs_sphinx)\n232 \n233         # set confdir to srcdir if -C given (!= no confdir); a few pieces\n234         # of code expect a confdir to be set\n235         if self.confdir is None:\n236             self.confdir = self.srcdir\n237 \n238         # load all built-in extension modules\n239         for extension in builtin_extensions:\n240             self.setup_extension(extension)\n241 \n242         # load all user-given extension modules\n243         for extension in self.config.extensions:\n244             self.setup_extension(extension)\n245 \n246         # preload builder module (before init config values)\n247         self.preload_builder(buildername)\n248 \n249         if not path.isdir(outdir):\n250             with progress_message(__('making output directory')):\n251                 ensuredir(outdir)\n252 \n253         # the config file itself can be an extension\n254         if self.config.setup:\n255             prefix = __('while setting up extension %s:') % \"conf.py\"\n256             with prefixed_warnings(prefix):\n257                 if callable(self.config.setup):\n258                     self.config.setup(self)\n259                 else:\n260                     raise ConfigError(\n261                         __(\"'setup' as currently defined in conf.py isn't a Python callable. \"\n262                            \"Please modify its definition to make it a callable function. \"\n263                            \"This is needed for conf.py to behave as a Sphinx extension.\")\n264                     )\n265 \n266         # now that we know all config values, collect them from conf.py\n267         self.config.init_values()\n268         self.events.emit('config-inited', self.config)\n269 \n270         # create the project\n271         self.project = Project(self.srcdir, self.config.source_suffix)\n272         # create the builder\n273         self.builder = self.create_builder(buildername)\n274         # set up the build environment\n275         self._init_env(freshenv)\n276         # set up the builder\n277         self._init_builder()\n278 \n279     def _init_i18n(self) -> None:\n280         \"\"\"Load translated strings from the configured localedirs if enabled in\n281         the configuration.\n282         \"\"\"\n283         if self.config.language is None:\n284             self.translator, has_translation = locale.init([], None)\n285         else:\n286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),\n287                         nonl=True)\n288 \n289             # compile mo files if sphinx.po file in user locale directories are updated\n290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n291                                      self.config.language, self.config.source_encoding)\n292             for catalog in repo.catalogs:\n293                 if catalog.domain == 'sphinx' and catalog.is_outdated():\n294                     catalog.write_mo(self.config.language)\n295 \n296             locale_dirs = [None, path.join(package_dir, 'locale')] + list(repo.locale_dirs)\n297             self.translator, has_translation = locale.init(locale_dirs, self.config.language)\n298             if has_translation or self.config.language == 'en':\n299                 # \"en\" never needs to be translated\n300                 logger.info(__('done'))\n301             else:\n302                 logger.info(__('not available for built-in messages'))\n303 \n304     def _init_env(self, freshenv: bool) -> None:\n305         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n306         if freshenv or not os.path.exists(filename):\n307             self.env = BuildEnvironment()\n308             self.env.setup(self)\n309             self.env.find_files(self.config, self.builder)\n310         else:\n311             try:\n312                 with progress_message(__('loading pickled environment')):\n313                     with open(filename, 'rb') as f:\n314                         self.env = pickle.load(f)\n315                         self.env.setup(self)\n316             except Exception as err:\n317                 logger.info(__('failed: %s'), err)\n318                 self._init_env(freshenv=True)\n319 \n320     def preload_builder(self, name: str) -> None:\n321         self.registry.preload_builder(self, name)\n322 \n323     def create_builder(self, name: str) -> \"Builder\":\n324         if name is None:\n325             logger.info(__('No builder selected, using default: html'))\n326             name = 'html'\n327 \n328         return self.registry.create_builder(self, name)\n329 \n330     def _init_builder(self) -> None:\n331         self.builder.set_environment(self.env)\n332         self.builder.init()\n333         self.events.emit('builder-inited')\n334 \n335     # ---- main \"build\" method -------------------------------------------------\n336 \n337     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:\n338         self.phase = BuildPhase.READING\n339         try:\n340             if force_all:\n341                 self.builder.compile_all_catalogs()\n342                 self.builder.build_all()\n343             elif filenames:\n344                 self.builder.compile_specific_catalogs(filenames)\n345                 self.builder.build_specific(filenames)\n346             else:\n347                 self.builder.compile_update_catalogs()\n348                 self.builder.build_update()\n349 \n350             if self._warncount and self.keep_going:\n351                 self.statuscode = 1\n352 \n353             status = (__('succeeded') if self.statuscode == 0\n354                       else __('finished with problems'))\n355             if self._warncount:\n356                 if self.warningiserror:\n357                     if self._warncount == 1:\n358                         msg = __('build %s, %s warning (with warnings treated as errors).')\n359                     else:\n360                         msg = __('build %s, %s warnings (with warnings treated as errors).')\n361                 else:\n362                     if self._warncount == 1:\n363                         msg = __('build %s, %s warning.')\n364                     else:\n365                         msg = __('build %s, %s warnings.')\n366 \n367                 logger.info(bold(msg % (status, self._warncount)))\n368             else:\n369                 logger.info(bold(__('build %s.') % status))\n370 \n371             if self.statuscode == 0 and self.builder.epilog:\n372                 logger.info('')\n373                 logger.info(self.builder.epilog % {\n374                     'outdir': relpath(self.outdir),\n375                     'project': self.config.project\n376                 })\n377         except Exception as err:\n378             # delete the saved env to force a fresh build next time\n379             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n380             if path.isfile(envfile):\n381                 os.unlink(envfile)\n382             self.events.emit('build-finished', err)\n383             raise\n384         else:\n385             self.events.emit('build-finished', None)\n386         self.builder.cleanup()\n387 \n388     # ---- general extensibility interface -------------------------------------\n389 \n390     def setup_extension(self, extname: str) -> None:\n391         \"\"\"Import and setup a Sphinx extension module.\n392 \n393         Load the extension given by the module *name*.  Use this if your\n394         extension needs the features provided by another extension.  No-op if\n395         called twice.\n396         \"\"\"\n397         logger.debug('[app] setting up extension: %r', extname)\n398         self.registry.load_extension(self, extname)\n399 \n400     def require_sphinx(self, version: str) -> None:\n401         \"\"\"Check the Sphinx version if requested.\n402 \n403         Compare *version* (which must be a ``major.minor`` version string, e.g.\n404         ``'1.1'``) with the version of the running Sphinx, and abort the build\n405         when it is too old.\n406 \n407         .. versionadded:: 1.0\n408         \"\"\"\n409         if version > sphinx.__display_version__[:3]:\n410             raise VersionRequirementError(version)\n411 \n412     # event interface\n413     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:\n414         \"\"\"Register *callback* to be called when *event* is emitted.\n415 \n416         For details on available core events and the arguments of callback\n417         functions, please see :ref:`events`.\n418 \n419         Registered callbacks will be invoked on event in the order of *priority* and\n420         registration.  The priority is ascending order.\n421 \n422         The method returns a \"listener ID\" that can be used as an argument to\n423         :meth:`disconnect`.\n424 \n425         .. versionchanged:: 3.0\n426 \n427            Support *priority*\n428         \"\"\"\n429         listener_id = self.events.connect(event, callback, priority)\n430         logger.debug('[app] connecting event %r (%d): %r [id=%s]',\n431                      event, priority, callback, listener_id)\n432         return listener_id\n433 \n434     def disconnect(self, listener_id: int) -> None:\n435         \"\"\"Unregister callback by *listener_id*.\"\"\"\n436         logger.debug('[app] disconnecting event: [id=%s]', listener_id)\n437         self.events.disconnect(listener_id)\n438 \n439     def emit(self, event: str, *args: Any) -> List:\n440         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n441 \n442         Return the return values of all callbacks as a list.  Do not emit core\n443         Sphinx events in extensions!\n444         \"\"\"\n445         return self.events.emit(event, *args)\n446 \n447     def emit_firstresult(self, event: str, *args: Any) -> Any:\n448         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n449 \n450         Return the result of the first callback that doesn't return ``None``.\n451 \n452         .. versionadded:: 0.5\n453         \"\"\"\n454         return self.events.emit_firstresult(event, *args)\n455 \n456     # registering addon parts\n457 \n458     def add_builder(self, builder: \"Type[Builder]\", override: bool = False) -> None:\n459         \"\"\"Register a new builder.\n460 \n461         *builder* must be a class that inherits from\n462         :class:`~sphinx.builders.Builder`.\n463 \n464         .. versionchanged:: 1.8\n465            Add *override* keyword.\n466         \"\"\"\n467         self.registry.add_builder(builder, override=override)\n468 \n469     # TODO(stephenfin): Describe 'types' parameter\n470     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],\n471                          types: Any = ()) -> None:\n472         \"\"\"Register a configuration value.\n473 \n474         This is necessary for Sphinx to recognize new values and set default\n475         values accordingly.  The *name* should be prefixed with the extension\n476         name, to avoid clashes.  The *default* value can be any Python object.\n477         The string value *rebuild* must be one of those values:\n478 \n479         * ``'env'`` if a change in the setting only takes effect when a\n480           document is parsed -- this means that the whole environment must be\n481           rebuilt.\n482         * ``'html'`` if a change in the setting needs a full rebuild of HTML\n483           documents.\n484         * ``''`` if a change in the setting will not need any special rebuild.\n485 \n486         .. versionchanged:: 0.6\n487            Changed *rebuild* from a simple boolean (equivalent to ``''`` or\n488            ``'env'``) to a string.  However, booleans are still accepted and\n489            converted internally.\n490 \n491         .. versionchanged:: 0.4\n492            If the *default* value is a callable, it will be called with the\n493            config object as its argument in order to get the default value.\n494            This can be used to implement config values whose default depends on\n495            other values.\n496         \"\"\"\n497         logger.debug('[app] adding config value: %r',\n498                      (name, default, rebuild) + ((types,) if types else ()))\n499         if rebuild in (False, True):\n500             rebuild = 'env' if rebuild else ''\n501         self.config.add(name, default, rebuild, types)\n502 \n503     def add_event(self, name: str) -> None:\n504         \"\"\"Register an event called *name*.\n505 \n506         This is needed to be able to emit it.\n507         \"\"\"\n508         logger.debug('[app] adding event: %r', name)\n509         self.events.add(name)\n510 \n511     def set_translator(self, name: str, translator_class: \"Type[nodes.NodeVisitor]\",\n512                        override: bool = False) -> None:\n513         \"\"\"Register or override a Docutils translator class.\n514 \n515         This is used to register a custom output translator or to replace a\n516         builtin translator.  This allows extensions to use custom translator\n517         and define custom nodes for the translator (see :meth:`add_node`).\n518 \n519         .. versionadded:: 1.3\n520         .. versionchanged:: 1.8\n521            Add *override* keyword.\n522         \"\"\"\n523         self.registry.add_translator(name, translator_class, override=override)\n524 \n525     def add_node(self, node: \"Type[Element]\", override: bool = False,\n526                  **kwargs: Tuple[Callable, Callable]) -> None:\n527         \"\"\"Register a Docutils node class.\n528 \n529         This is necessary for Docutils internals.  It may also be used in the\n530         future to validate nodes in the parsed documents.\n531 \n532         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage\n533         writers can be given as keyword arguments: the keyword should be one or\n534         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``\n535         or any other supported translators, the value a 2-tuple of ``(visit,\n536         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``\n537         function raises :exc:`docutils.nodes.SkipNode`.  Example:\n538 \n539         .. code-block:: python\n540 \n541            class math(docutils.nodes.Element): pass\n542 \n543            def visit_math_html(self, node):\n544                self.body.append(self.starttag(node, 'math'))\n545            def depart_math_html(self, node):\n546                self.body.append('</math>')\n547 \n548            app.add_node(math, html=(visit_math_html, depart_math_html))\n549 \n550         Obviously, translators for which you don't specify visitor methods will\n551         choke on the node when encountered in a document to translate.\n552 \n553         .. versionchanged:: 0.5\n554            Added the support for keyword arguments giving visit functions.\n555         \"\"\"\n556         logger.debug('[app] adding node: %r', (node, kwargs))\n557         if not override and docutils.is_node_registered(node):\n558             logger.warning(__('node class %r is already registered, '\n559                               'its visitors will be overridden'),\n560                            node.__name__, type='app', subtype='add_node')\n561         docutils.register_node(node)\n562         self.registry.add_translation_handlers(node, **kwargs)\n563 \n564     def add_enumerable_node(self, node: \"Type[Element]\", figtype: str,\n565                             title_getter: TitleGetter = None, override: bool = False,\n566                             **kwargs: Tuple[Callable, Callable]) -> None:\n567         \"\"\"Register a Docutils node class as a numfig target.\n568 \n569         Sphinx numbers the node automatically. And then the users can refer it\n570         using :rst:role:`numref`.\n571 \n572         *figtype* is a type of enumerable nodes.  Each figtypes have individual\n573         numbering sequences.  As a system figtypes, ``figure``, ``table`` and\n574         ``code-block`` are defined.  It is able to add custom nodes to these\n575         default figtypes.  It is also able to define new custom figtype if new\n576         figtype is given.\n577 \n578         *title_getter* is a getter function to obtain the title of node.  It\n579         takes an instance of the enumerable node, and it must return its title\n580         as string.  The title is used to the default title of references for\n581         :rst:role:`ref`.  By default, Sphinx searches\n582         ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the node as\n583         a title.\n584 \n585         Other keyword arguments are used for node visitor functions. See the\n586         :meth:`.Sphinx.add_node` for details.\n587 \n588         .. versionadded:: 1.4\n589         \"\"\"\n590         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)\n591         self.add_node(node, override=override, **kwargs)\n592 \n593     def add_directive(self, name: str, cls: \"Type[Directive]\", override: bool = False) -> None:\n594         \"\"\"Register a Docutils directive.\n595 \n596         *name* must be the prospective directive name.  *cls* is a directive\n597         class which inherits ``docutils.parsers.rst.Directive``.  For more\n598         details, see `the Docutils docs\n599         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ .\n600 \n601         For example, the (already existing) :rst:dir:`literalinclude` directive\n602         would be added like this:\n603 \n604         .. code-block:: python\n605 \n606            from docutils.parsers.rst import Directive, directives\n607 \n608            class LiteralIncludeDirective(Directive):\n609                has_content = True\n610                required_arguments = 1\n611                optional_arguments = 0\n612                final_argument_whitespace = True\n613                option_spec = {\n614                    'class': directives.class_option,\n615                    'name': directives.unchanged,\n616                }\n617 \n618                def run(self):\n619                    ...\n620 \n621            add_directive('literalinclude', LiteralIncludeDirective)\n622 \n623         .. versionchanged:: 0.6\n624            Docutils 0.5-style directive classes are now supported.\n625         .. deprecated:: 1.8\n626            Docutils 0.4-style (function based) directives support is deprecated.\n627         .. versionchanged:: 1.8\n628            Add *override* keyword.\n629         \"\"\"\n630         logger.debug('[app] adding directive: %r', (name, cls))\n631         if not override and docutils.is_directive_registered(name):\n632             logger.warning(__('directive %r is already registered, it will be overridden'),\n633                            name, type='app', subtype='add_directive')\n634 \n635         docutils.register_directive(name, cls)\n636 \n637     def add_role(self, name: str, role: Any, override: bool = False) -> None:\n638         \"\"\"Register a Docutils role.\n639 \n640         *name* must be the role name that occurs in the source, *role* the role\n641         function. Refer to the `Docutils documentation\n642         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for\n643         more information.\n644 \n645         .. versionchanged:: 1.8\n646            Add *override* keyword.\n647         \"\"\"\n648         logger.debug('[app] adding role: %r', (name, role))\n649         if not override and docutils.is_role_registered(name):\n650             logger.warning(__('role %r is already registered, it will be overridden'),\n651                            name, type='app', subtype='add_role')\n652         docutils.register_role(name, role)\n653 \n654     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:\n655         \"\"\"Register a generic Docutils role.\n656 \n657         Register a Docutils role that does nothing but wrap its contents in the\n658         node given by *nodeclass*.\n659 \n660         .. versionadded:: 0.6\n661         .. versionchanged:: 1.8\n662            Add *override* keyword.\n663         \"\"\"\n664         # Don't use ``roles.register_generic_role`` because it uses\n665         # ``register_canonical_role``.\n666         logger.debug('[app] adding generic role: %r', (name, nodeclass))\n667         if not override and docutils.is_role_registered(name):\n668             logger.warning(__('role %r is already registered, it will be overridden'),\n669                            name, type='app', subtype='add_generic_role')\n670         role = roles.GenericRole(name, nodeclass)\n671         docutils.register_role(name, role)\n672 \n673     def add_domain(self, domain: \"Type[Domain]\", override: bool = False) -> None:\n674         \"\"\"Register a domain.\n675 \n676         Make the given *domain* (which must be a class; more precisely, a\n677         subclass of :class:`~sphinx.domains.Domain`) known to Sphinx.\n678 \n679         .. versionadded:: 1.0\n680         .. versionchanged:: 1.8\n681            Add *override* keyword.\n682         \"\"\"\n683         self.registry.add_domain(domain, override=override)\n684 \n685     def add_directive_to_domain(self, domain: str, name: str,\n686                                 cls: \"Type[Directive]\", override: bool = False) -> None:\n687         \"\"\"Register a Docutils directive in a domain.\n688 \n689         Like :meth:`add_directive`, but the directive is added to the domain\n690         named *domain*.\n691 \n692         .. versionadded:: 1.0\n693         .. versionchanged:: 1.8\n694            Add *override* keyword.\n695         \"\"\"\n696         self.registry.add_directive_to_domain(domain, name, cls, override=override)\n697 \n698     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],\n699                            override: bool = False) -> None:\n700         \"\"\"Register a Docutils role in a domain.\n701 \n702         Like :meth:`add_role`, but the role is added to the domain named\n703         *domain*.\n704 \n705         .. versionadded:: 1.0\n706         .. versionchanged:: 1.8\n707            Add *override* keyword.\n708         \"\"\"\n709         self.registry.add_role_to_domain(domain, name, role, override=override)\n710 \n711     def add_index_to_domain(self, domain: str, index: \"Type[Index]\", override: bool = False\n712                             ) -> None:\n713         \"\"\"Register a custom index for a domain.\n714 \n715         Add a custom *index* class to the domain named *domain*.  *index* must\n716         be a subclass of :class:`~sphinx.domains.Index`.\n717 \n718         .. versionadded:: 1.0\n719         .. versionchanged:: 1.8\n720            Add *override* keyword.\n721         \"\"\"\n722         self.registry.add_index_to_domain(domain, index)\n723 \n724     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',\n725                         parse_node: Callable = None, ref_nodeclass: \"Type[TextElement]\" = None,\n726                         objname: str = '', doc_field_types: List = [], override: bool = False\n727                         ) -> None:\n728         \"\"\"Register a new object type.\n729 \n730         This method is a very convenient way to add a new :term:`object` type\n731         that can be cross-referenced.  It will do this:\n732 \n733         - Create a new directive (called *directivename*) for documenting an\n734           object.  It will automatically add index entries if *indextemplate*\n735           is nonempty; if given, it must contain exactly one instance of\n736           ``%s``.  See the example below for how the template will be\n737           interpreted.\n738         - Create a new role (called *rolename*) to cross-reference to these\n739           object descriptions.\n740         - If you provide *parse_node*, it must be a function that takes a\n741           string and a docutils node, and it must populate the node with\n742           children parsed from the string.  It must then return the name of the\n743           item to be used in cross-referencing and index entries.  See the\n744           :file:`conf.py` file in the source for this documentation for an\n745           example.\n746         - The *objname* (if not given, will default to *directivename*) names\n747           the type of object.  It is used when listing objects, e.g. in search\n748           results.\n749 \n750         For example, if you have this call in a custom Sphinx extension::\n751 \n752            app.add_object_type('directive', 'dir', 'pair: %s; directive')\n753 \n754         you can use this markup in your documents::\n755 \n756            .. rst:directive:: function\n757 \n758               Document a function.\n759 \n760            <...>\n761 \n762            See also the :rst:dir:`function` directive.\n763 \n764         For the directive, an index entry will be generated as if you had prepended ::\n765 \n766            .. index:: pair: function; directive\n767 \n768         The reference node will be of class ``literal`` (so it will be rendered\n769         in a proportional font, as appropriate for code) unless you give the\n770         *ref_nodeclass* argument, which must be a docutils node class.  Most\n771         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --\n772         you can also use ``docutils.nodes.generated`` if you want no further\n773         text decoration.  If the text should be treated as literal (e.g. no\n774         smart quote replacement), but not have typewriter styling, use\n775         ``sphinx.addnodes.literal_emphasis`` or\n776         ``sphinx.addnodes.literal_strong``.\n777 \n778         For the role content, you have the same syntactical possibilities as\n779         for standard Sphinx roles (see :ref:`xref-syntax`).\n780 \n781         .. versionchanged:: 1.8\n782            Add *override* keyword.\n783         \"\"\"\n784         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,\n785                                       ref_nodeclass, objname, doc_field_types,\n786                                       override=override)\n787 \n788     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',\n789                           ref_nodeclass: \"Type[TextElement]\" = None, objname: str = '',\n790                           override: bool = False) -> None:\n791         \"\"\"Register a new crossref object type.\n792 \n793         This method is very similar to :meth:`add_object_type` except that the\n794         directive it generates must be empty, and will produce no output.\n795 \n796         That means that you can add semantic targets to your sources, and refer\n797         to them using custom roles instead of generic ones (like\n798         :rst:role:`ref`).  Example call::\n799 \n800            app.add_crossref_type('topic', 'topic', 'single: %s',\n801                                  docutils.nodes.emphasis)\n802 \n803         Example usage::\n804 \n805            .. topic:: application API\n806 \n807            The application API\n808            -------------------\n809 \n810            Some random text here.\n811 \n812            See also :topic:`this section <application API>`.\n813 \n814         (Of course, the element following the ``topic`` directive needn't be a\n815         section.)\n816 \n817         .. versionchanged:: 1.8\n818            Add *override* keyword.\n819         \"\"\"\n820         self.registry.add_crossref_type(directivename, rolename,\n821                                         indextemplate, ref_nodeclass, objname,\n822                                         override=override)\n823 \n824     def add_transform(self, transform: \"Type[Transform]\") -> None:\n825         \"\"\"Register a Docutils transform to be applied after parsing.\n826 \n827         Add the standard docutils :class:`Transform` subclass *transform* to\n828         the list of transforms that are applied after Sphinx parses a reST\n829         document.\n830 \n831         .. list-table:: priority range categories for Sphinx transforms\n832            :widths: 20,80\n833 \n834            * - Priority\n835              - Main purpose in Sphinx\n836            * - 0-99\n837              - Fix invalid nodes by docutils. Translate a doctree.\n838            * - 100-299\n839              - Preparation\n840            * - 300-399\n841              - early\n842            * - 400-699\n843              - main\n844            * - 700-799\n845              - Post processing. Deadline to modify text and referencing.\n846            * - 800-899\n847              - Collect referencing and referenced nodes. Domain processing.\n848            * - 900-999\n849              - Finalize and clean up.\n850 \n851         refs: `Transform Priority Range Categories`__\n852 \n853         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories\n854         \"\"\"  # NOQA\n855         self.registry.add_transform(transform)\n856 \n857     def add_post_transform(self, transform: \"Type[Transform]\") -> None:\n858         \"\"\"Register a Docutils transform to be applied before writing.\n859 \n860         Add the standard docutils :class:`Transform` subclass *transform* to\n861         the list of transforms that are applied before Sphinx writes a\n862         document.\n863         \"\"\"\n864         self.registry.add_post_transform(transform)\n865 \n866     def add_javascript(self, filename: str, **kwargs: str) -> None:\n867         \"\"\"An alias of :meth:`add_js_file`.\"\"\"\n868         warnings.warn('The app.add_javascript() is deprecated. '\n869                       'Please use app.add_js_file() instead.',\n870                       RemovedInSphinx40Warning, stacklevel=2)\n871         self.add_js_file(filename, **kwargs)\n872 \n873     def add_js_file(self, filename: str, **kwargs: str) -> None:\n874         \"\"\"Register a JavaScript file to include in the HTML output.\n875 \n876         Add *filename* to the list of JavaScript files that the default HTML\n877         template will include.  The filename must be relative to the HTML\n878         static path , or a full URI with scheme.  If the keyword argument\n879         ``body`` is given, its value will be added between the\n880         ``<script>`` tags. Extra keyword arguments are included as\n881         attributes of the ``<script>`` tag.\n882 \n883         Example::\n884 \n885             app.add_js_file('example.js')\n886             # => <script src=\"_static/example.js\"></script>\n887 \n888             app.add_js_file('example.js', async=\"async\")\n889             # => <script src=\"_static/example.js\" async=\"async\"></script>\n890 \n891             app.add_js_file(None, body=\"var myVariable = 'foo';\")\n892             # => <script>var myVariable = 'foo';</script>\n893 \n894         .. versionadded:: 0.5\n895 \n896         .. versionchanged:: 1.8\n897            Renamed from ``app.add_javascript()``.\n898            And it allows keyword arguments as attributes of script tag.\n899         \"\"\"\n900         self.registry.add_js_file(filename, **kwargs)\n901         if hasattr(self.builder, 'add_js_file'):\n902             self.builder.add_js_file(filename, **kwargs)  # type: ignore\n903 \n904     def add_css_file(self, filename: str, **kwargs: str) -> None:\n905         \"\"\"Register a stylesheet to include in the HTML output.\n906 \n907         Add *filename* to the list of CSS files that the default HTML template\n908         will include.  The filename must be relative to the HTML static path,\n909         or a full URI with scheme.  The keyword arguments are also accepted for\n910         attributes of ``<link>`` tag.\n911 \n912         Example::\n913 \n914             app.add_css_file('custom.css')\n915             # => <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n916 \n917             app.add_css_file('print.css', media='print')\n918             # => <link rel=\"stylesheet\" href=\"_static/print.css\"\n919             #          type=\"text/css\" media=\"print\" />\n920 \n921             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')\n922             # => <link rel=\"alternate stylesheet\" href=\"_static/fancy.css\"\n923             #          type=\"text/css\" title=\"fancy\" />\n924 \n925         .. versionadded:: 1.0\n926 \n927         .. versionchanged:: 1.6\n928            Optional ``alternate`` and/or ``title`` attributes can be supplied\n929            with the *alternate* (of boolean type) and *title* (a string)\n930            arguments. The default is no title and *alternate* = ``False``. For\n931            more information, refer to the `documentation\n932            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.\n933 \n934         .. versionchanged:: 1.8\n935            Renamed from ``app.add_stylesheet()``.\n936            And it allows keyword arguments as attributes of link tag.\n937         \"\"\"\n938         logger.debug('[app] adding stylesheet: %r', filename)\n939         self.registry.add_css_files(filename, **kwargs)\n940         if hasattr(self.builder, 'add_css_file'):\n941             self.builder.add_css_file(filename, **kwargs)  # type: ignore\n942 \n943     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None\n944                        ) -> None:\n945         \"\"\"An alias of :meth:`add_css_file`.\"\"\"\n946         warnings.warn('The app.add_stylesheet() is deprecated. '\n947                       'Please use app.add_css_file() instead.',\n948                       RemovedInSphinx40Warning, stacklevel=2)\n949 \n950         attributes = {}  # type: Dict[str, str]\n951         if alternate:\n952             attributes['rel'] = 'alternate stylesheet'\n953         else:\n954             attributes['rel'] = 'stylesheet'\n955 \n956         if title:\n957             attributes['title'] = title\n958 \n959         self.add_css_file(filename, **attributes)\n960 \n961     def add_latex_package(self, packagename: str, options: str = None) -> None:\n962         r\"\"\"Register a package to include in the LaTeX source code.\n963 \n964         Add *packagename* to the list of packages that LaTeX source code will\n965         include.  If you provide *options*, it will be taken to `\\usepackage`\n966         declaration.\n967 \n968         .. code-block:: python\n969 \n970            app.add_latex_package('mypackage')\n971            # => \\usepackage{mypackage}\n972            app.add_latex_package('mypackage', 'foo,bar')\n973            # => \\usepackage[foo,bar]{mypackage}\n974 \n975         .. versionadded:: 1.3\n976         \"\"\"\n977         self.registry.add_latex_package(packagename, options)\n978 \n979     def add_lexer(self, alias: str, lexer: Union[Lexer, \"Type[Lexer]\"]) -> None:\n980         \"\"\"Register a new lexer for source code.\n981 \n982         Use *lexer* to highlight code blocks with the given language *alias*.\n983 \n984         .. versionadded:: 0.6\n985         .. versionchanged:: 2.1\n986            Take a lexer class as an argument.  An instance of lexers are\n987            still supported until Sphinx-3.x.\n988         \"\"\"\n989         logger.debug('[app] adding lexer: %r', (alias, lexer))\n990         if isinstance(lexer, Lexer):\n991             warnings.warn('app.add_lexer() API changed; '\n992                           'Please give lexer class instead instance',\n993                           RemovedInSphinx40Warning)\n994             lexers[alias] = lexer\n995         else:\n996             lexer_classes[alias] = lexer\n997 \n998     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:\n999         \"\"\"Register a new documenter class for the autodoc extension.\n1000 \n1001         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`\n1002         extension.  It must be a subclass of\n1003         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document\n1004         new types of objects.  See the source of the autodoc module for\n1005         examples on how to subclass :class:`Documenter`.\n1006 \n1007         .. todo:: Add real docs for Documenter and subclassing\n1008 \n1009         .. versionadded:: 0.6\n1010         .. versionchanged:: 2.2\n1011            Add *override* keyword.\n1012         \"\"\"\n1013         logger.debug('[app] adding autodocumenter: %r', cls)\n1014         from sphinx.ext.autodoc.directive import AutodocDirective\n1015         self.registry.add_documenter(cls.objtype, cls)\n1016         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n1017 \n1018     def add_autodoc_attrgetter(self, typ: \"Type\", getter: Callable[[Any, str, Any], Any]\n1019                                ) -> None:\n1020         \"\"\"Register a new ``getattr``-like function for the autodoc extension.\n1021 \n1022         Add *getter*, which must be a function with an interface compatible to\n1023         the :func:`getattr` builtin, as the autodoc attribute getter for\n1024         objects that are instances of *typ*.  All cases where autodoc needs to\n1025         get an attribute of a type are then handled by this function instead of\n1026         :func:`getattr`.\n1027 \n1028         .. versionadded:: 0.6\n1029         \"\"\"\n1030         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))\n1031         self.registry.add_autodoc_attrgetter(typ, getter)\n1032 \n1033     def add_search_language(self, cls: Any) -> None:\n1034         \"\"\"Register a new language for the HTML search index.\n1035 \n1036         Add *cls*, which must be a subclass of\n1037         :class:`sphinx.search.SearchLanguage`, as a support language for\n1038         building the HTML full-text search index.  The class must have a *lang*\n1039         attribute that indicates the language it should be used for.  See\n1040         :confval:`html_search_language`.\n1041 \n1042         .. versionadded:: 1.1\n1043         \"\"\"\n1044         logger.debug('[app] adding search language: %r', cls)\n1045         from sphinx.search import languages, SearchLanguage\n1046         assert issubclass(cls, SearchLanguage)\n1047         languages[cls.lang] = cls\n1048 \n1049     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:\n1050         \"\"\"Register a suffix of source files.\n1051 \n1052         Same as :confval:`source_suffix`.  The users can override this\n1053         using the setting.\n1054 \n1055         .. versionadded:: 1.8\n1056         \"\"\"\n1057         self.registry.add_source_suffix(suffix, filetype, override=override)\n1058 \n1059     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:\n1060         \"\"\"Register a parser class.\n1061 \n1062         .. versionadded:: 1.4\n1063         .. versionchanged:: 1.8\n1064            *suffix* argument is deprecated.  It only accepts *parser* argument.\n1065            Use :meth:`add_source_suffix` API to register suffix instead.\n1066         .. versionchanged:: 1.8\n1067            Add *override* keyword.\n1068         \"\"\"\n1069         self.registry.add_source_parser(*args, **kwargs)\n1070 \n1071     def add_env_collector(self, collector: \"Type[EnvironmentCollector]\") -> None:\n1072         \"\"\"Register an environment collector class.\n1073 \n1074         Refer to :ref:`collector-api`.\n1075 \n1076         .. versionadded:: 1.6\n1077         \"\"\"\n1078         logger.debug('[app] adding environment collector: %r', collector)\n1079         collector().enable(self)\n1080 \n1081     def add_html_theme(self, name: str, theme_path: str) -> None:\n1082         \"\"\"Register a HTML Theme.\n1083 \n1084         The *name* is a name of theme, and *path* is a full path to the theme\n1085         (refs: :ref:`distribute-your-theme`).\n1086 \n1087         .. versionadded:: 1.6\n1088         \"\"\"\n1089         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)\n1090         self.html_themes[name] = theme_path\n1091 \n1092     def add_html_math_renderer(self, name: str,\n1093                                inline_renderers: Tuple[Callable, Callable] = None,\n1094                                block_renderers: Tuple[Callable, Callable] = None) -> None:\n1095         \"\"\"Register a math renderer for HTML.\n1096 \n1097         The *name* is a name of math renderer.  Both *inline_renderers* and\n1098         *block_renderers* are used as visitor functions for the HTML writer:\n1099         the former for inline math node (``nodes.math``), the latter for\n1100         block math node (``nodes.math_block``).  Regarding visitor functions,\n1101         see :meth:`add_node` for details.\n1102 \n1103         .. versionadded:: 1.8\n1104 \n1105         \"\"\"\n1106         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)\n1107 \n1108     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:\n1109         \"\"\"Register a message catalog.\n1110 \n1111         The *catalog* is a name of catalog, and *locale_dir* is a base path\n1112         of message catalog.  For more details, see\n1113         :func:`sphinx.locale.get_translation()`.\n1114 \n1115         .. versionadded:: 1.8\n1116         \"\"\"\n1117         locale.init([locale_dir], self.config.language, catalog)\n1118         locale.init_console(locale_dir, catalog)\n1119 \n1120     # ---- other methods -------------------------------------------------\n1121     def is_parallel_allowed(self, typ: str) -> bool:\n1122         \"\"\"Check parallel processing is allowed or not.\n1123 \n1124         ``typ`` is a type of processing; ``'read'`` or ``'write'``.\n1125         \"\"\"\n1126         if typ == 'read':\n1127             attrname = 'parallel_read_safe'\n1128             message_not_declared = __(\"the %s extension does not declare if it \"\n1129                                       \"is safe for parallel reading, assuming \"\n1130                                       \"it isn't - please ask the extension author \"\n1131                                       \"to check and make it explicit\")\n1132             message_not_safe = __(\"the %s extension is not safe for parallel reading\")\n1133         elif typ == 'write':\n1134             attrname = 'parallel_write_safe'\n1135             message_not_declared = __(\"the %s extension does not declare if it \"\n1136                                       \"is safe for parallel writing, assuming \"\n1137                                       \"it isn't - please ask the extension author \"\n1138                                       \"to check and make it explicit\")\n1139             message_not_safe = __(\"the %s extension is not safe for parallel writing\")\n1140         else:\n1141             raise ValueError('parallel type %s is not supported' % typ)\n1142 \n1143         for ext in self.extensions.values():\n1144             allowed = getattr(ext, attrname, None)\n1145             if allowed is None:\n1146                 logger.warning(message_not_declared, ext.name)\n1147                 logger.warning(__('doing serial %s'), typ)\n1148                 return False\n1149             elif not allowed:\n1150                 logger.warning(message_not_safe, ext.name)\n1151                 logger.warning(__('doing serial %s'), typ)\n1152                 return False\n1153 \n1154         return True\n1155 \n1156 \n1157 class TemplateBridge:\n1158     \"\"\"\n1159     This class defines the interface for a \"template bridge\", that is, a class\n1160     that renders templates given a template name and a context.\n1161     \"\"\"\n1162 \n1163     def init(self, builder: \"Builder\", theme: Theme = None, dirs: List[str] = None) -> None:\n1164         \"\"\"Called by the builder to initialize the template system.\n1165 \n1166         *builder* is the builder object; you'll probably want to look at the\n1167         value of ``builder.config.templates_path``.\n1168 \n1169         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter\n1170         case, *dirs* can be list of fixed directories to look for templates.\n1171         \"\"\"\n1172         raise NotImplementedError('must be implemented in subclasses')\n1173 \n1174     def newest_template_mtime(self) -> float:\n1175         \"\"\"Called by the builder to determine if output files are outdated\n1176         because of template changes.  Return the mtime of the newest template\n1177         file that was changed.  The default implementation returns ``0``.\n1178         \"\"\"\n1179         return 0\n1180 \n1181     def render(self, template: str, context: Dict) -> None:\n1182         \"\"\"Called by the builder to render a template given as a filename with\n1183         a specified context (a Python dictionary).\n1184         \"\"\"\n1185         raise NotImplementedError('must be implemented in subclasses')\n1186 \n1187     def render_string(self, template: str, context: Dict) -> str:\n1188         \"\"\"Called by the builder to render a template given as a string with a\n1189         specified context (a Python dictionary).\n1190         \"\"\"\n1191         raise NotImplementedError('must be implemented in subclasses')\n",
        "intended_behavior": "The application layer, which initializes and configures extensions, should include logic to prioritize file extensions when multiple sources with the same name but different extensions exist. This could be implemented either by enhancing existing methods or introducing a new method to filter and sort files based on a configurable priority list before including them in the build process. This priority list could be configured through the existing Sphinx configuration mechanisms, allowing users to specify their preference for `.md` over `.rst` or vice versa. It's essential that this change does not disrupt the current functionality for projects not requiring this feature."
    },
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/config.py",
        "start": 1,
        "end": 492,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.config\n3     ~~~~~~~~~~~~~\n4 \n5     Build configuration file handling.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import traceback\n13 import types\n14 import warnings\n15 from collections import OrderedDict\n16 from os import path, getenv\n17 from typing import (\n18     Any, Callable, Dict, Generator, Iterator, List, NamedTuple, Set, Tuple, Union\n19 )\n20 \n21 from sphinx.deprecation import RemovedInSphinx40Warning\n22 from sphinx.errors import ConfigError, ExtensionError\n23 from sphinx.locale import _, __\n24 from sphinx.util import logging\n25 from sphinx.util.i18n import format_date\n26 from sphinx.util.osutil import cd\n27 from sphinx.util.pycompat import execfile_\n28 from sphinx.util.tags import Tags\n29 from sphinx.util.typing import NoneType\n30 \n31 if False:\n32     # For type annotation\n33     from sphinx.application import Sphinx\n34     from sphinx.environment import BuildEnvironment\n35 \n36 logger = logging.getLogger(__name__)\n37 \n38 CONFIG_FILENAME = 'conf.py'\n39 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)\n40 copyright_year_re = re.compile(r'^((\\d{4}-)?)(\\d{4})(?=[ ,])')\n41 \n42 ConfigValue = NamedTuple('ConfigValue', [('name', str),\n43                                          ('value', Any),\n44                                          ('rebuild', Union[bool, str])])\n45 \n46 \n47 def is_serializable(obj: Any) -> bool:\n48     \"\"\"Check if object is serializable or not.\"\"\"\n49     if isinstance(obj, UNSERIALIZABLE_TYPES):\n50         return False\n51     elif isinstance(obj, dict):\n52         for key, value in obj.items():\n53             if not is_serializable(key) or not is_serializable(value):\n54                 return False\n55     elif isinstance(obj, (list, tuple, set)):\n56         return all(is_serializable(i) for i in obj)\n57 \n58     return True\n59 \n60 \n61 class ENUM:\n62     \"\"\"represents the config value should be a one of candidates.\n63 \n64     Example:\n65         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))\n66     \"\"\"\n67     def __init__(self, *candidates: str) -> None:\n68         self.candidates = candidates\n69 \n70     def match(self, value: Union[str, List, Tuple]) -> bool:\n71         if isinstance(value, (list, tuple)):\n72             return all(item in self.candidates for item in value)\n73         else:\n74             return value in self.candidates\n75 \n76 \n77 # RemovedInSphinx40Warning\n78 string_classes = [str]  # type: List\n79 \n80 \n81 class Config:\n82     \"\"\"Configuration file abstraction.\n83 \n84     The config object makes the values of all config values available as\n85     attributes.\n86 \n87     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n89     to get the value of :confval:`language`, use either ``app.config.language``\n90     or ``env.config.language``.\n91     \"\"\"\n92 \n93     # the values are: (default, what needs to be rebuilt if changed)\n94 \n95     # If you add a value here, don't forget to include it in the\n96     # quickstart.py file template as well as in the docs!\n97 \n98     config_values = {\n99         # general options\n100         'project': ('Python', 'env', []),\n101         'author': ('unknown', 'env', []),\n102         'copyright': ('', 'html', []),\n103         'version': ('', 'env', []),\n104         'release': ('', 'env', []),\n105         'today': ('', 'env', []),\n106         # the real default is locale-dependent\n107         'today_fmt': (None, 'env', [str]),\n108 \n109         'language': (None, 'env', [str]),\n110         'locale_dirs': (['locales'], 'env', []),\n111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n112 \n113         'master_doc': ('index', 'env', []),\n114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n115         'source_encoding': ('utf-8-sig', 'env', []),\n116         'source_parsers': ({}, 'env', []),\n117         'exclude_patterns': ([], 'env', []),\n118         'default_role': (None, 'env', [str]),\n119         'add_function_parentheses': (True, 'env', []),\n120         'add_module_names': (True, 'env', []),\n121         'trim_footnote_reference_space': (False, 'env', []),\n122         'show_authors': (False, 'env', []),\n123         'pygments_style': (None, 'html', [str]),\n124         'highlight_language': ('default', 'env', []),\n125         'highlight_options': ({}, 'env', []),\n126         'templates_path': ([], 'html', []),\n127         'template_bridge': (None, 'html', [str]),\n128         'keep_warnings': (False, 'env', []),\n129         'suppress_warnings': ([], 'env', []),\n130         'modindex_common_prefix': ([], 'html', []),\n131         'rst_epilog': (None, 'env', [str]),\n132         'rst_prolog': (None, 'env', [str]),\n133         'trim_doctest_flags': (True, 'env', []),\n134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n135         'needs_sphinx': (None, None, [str]),\n136         'needs_extensions': ({}, None, []),\n137         'manpages_url': (None, 'env', []),\n138         'nitpicky': (False, None, []),\n139         'nitpick_ignore': ([], None, []),\n140         'numfig': (False, 'env', []),\n141         'numfig_secnum_depth': (1, 'env', []),\n142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n143 \n144         'math_number_all': (False, 'env', []),\n145         'math_eqref_format': (None, 'env', [str]),\n146         'math_numfig': (True, 'env', []),\n147         'tls_verify': (True, 'env', []),\n148         'tls_cacerts': (None, 'env', []),\n149         'user_agent': (None, 'env', [str]),\n150         'smartquotes': (True, 'env', []),\n151         'smartquotes_action': ('qDe', 'env', []),\n152         'smartquotes_excludes': ({'languages': ['ja'],\n153                                   'builders': ['man', 'text']},\n154                                  'env', []),\n155     }  # type: Dict[str, Tuple]\n156 \n157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n158         self.overrides = dict(overrides)\n159         self.values = Config.config_values.copy()\n160         self._raw_config = config\n161         self.setup = config.get('setup', None)  # type: Callable\n162 \n163         if 'extensions' in self.overrides:\n164             if isinstance(self.overrides['extensions'], str):\n165                 config['extensions'] = self.overrides.pop('extensions').split(',')\n166             else:\n167                 config['extensions'] = self.overrides.pop('extensions')\n168         self.extensions = config.get('extensions', [])  # type: List[str]\n169 \n170     @classmethod\n171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n172         \"\"\"Create a Config object from configuration file.\"\"\"\n173         filename = path.join(confdir, CONFIG_FILENAME)\n174         namespace = eval_config_file(filename, tags)\n175         return cls(namespace, overrides or {})\n176 \n177     def convert_overrides(self, name: str, value: Any) -> Any:\n178         if not isinstance(value, str):\n179             return value\n180         else:\n181             defvalue = self.values[name][0]\n182             if self.values[name][2] == Any:\n183                 return value\n184             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n185                 if value == '0':\n186                     # given falsy string from command line option\n187                     return False\n188                 else:\n189                     return bool(value)\n190             elif isinstance(defvalue, dict):\n191                 raise ValueError(__('cannot override dictionary config setting %r, '\n192                                     'ignoring (use %r to set individual elements)') %\n193                                  (name, name + '.key=value'))\n194             elif isinstance(defvalue, list):\n195                 return value.split(',')\n196             elif isinstance(defvalue, int):\n197                 try:\n198                     return int(value)\n199                 except ValueError:\n200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n201                                      (value, name))\n202             elif hasattr(defvalue, '__call__'):\n203                 return value\n204             elif defvalue is not None and not isinstance(defvalue, str):\n205                 raise ValueError(__('cannot override config setting %r with unsupported '\n206                                     'type, ignoring') % name)\n207             else:\n208                 return value\n209 \n210     def pre_init_values(self) -> None:\n211         \"\"\"\n212         Initialize some limited config variables before initialize i18n and loading extensions\n213         \"\"\"\n214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n215         for name in variables:\n216             try:\n217                 if name in self.overrides:\n218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n219                 elif name in self._raw_config:\n220                     self.__dict__[name] = self._raw_config[name]\n221             except ValueError as exc:\n222                 logger.warning(\"%s\", exc)\n223 \n224     def init_values(self) -> None:\n225         config = self._raw_config\n226         for valname, value in self.overrides.items():\n227             try:\n228                 if '.' in valname:\n229                     realvalname, key = valname.split('.', 1)\n230                     config.setdefault(realvalname, {})[key] = value\n231                     continue\n232                 elif valname not in self.values:\n233                     logger.warning(__('unknown config value %r in override, ignoring'),\n234                                    valname)\n235                     continue\n236                 if isinstance(value, str):\n237                     config[valname] = self.convert_overrides(valname, value)\n238                 else:\n239                     config[valname] = value\n240             except ValueError as exc:\n241                 logger.warning(\"%s\", exc)\n242         for name in config:\n243             if name in self.values:\n244                 self.__dict__[name] = config[name]\n245 \n246     def __getattr__(self, name: str) -> Any:\n247         if name.startswith('_'):\n248             raise AttributeError(name)\n249         if name not in self.values:\n250             raise AttributeError(__('No such config value: %s') % name)\n251         default = self.values[name][0]\n252         if hasattr(default, '__call__'):\n253             return default(self)\n254         return default\n255 \n256     def __getitem__(self, name: str) -> str:\n257         return getattr(self, name)\n258 \n259     def __setitem__(self, name: str, value: Any) -> None:\n260         setattr(self, name, value)\n261 \n262     def __delitem__(self, name: str) -> None:\n263         delattr(self, name)\n264 \n265     def __contains__(self, name: str) -> bool:\n266         return name in self.values\n267 \n268     def __iter__(self) -> Generator[ConfigValue, None, None]:\n269         for name, value in self.values.items():\n270             yield ConfigValue(name, getattr(self, name), value[1])\n271 \n272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n273         if name in self.values:\n274             raise ExtensionError(__('Config value %r already present') % name)\n275         else:\n276             self.values[name] = (default, rebuild, types)\n277 \n278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n279         if isinstance(rebuild, str):\n280             rebuild = [rebuild]\n281         return (value for value in self if value.rebuild in rebuild)\n282 \n283     def __getstate__(self) -> Dict:\n284         \"\"\"Obtains serializable data for pickling.\"\"\"\n285         # remove potentially pickling-problematic values from config\n286         __dict__ = {}\n287         for key, value in self.__dict__.items():\n288             if key.startswith('_') or not is_serializable(value):\n289                 pass\n290             else:\n291                 __dict__[key] = value\n292 \n293         # create a picklable copy of values list\n294         __dict__['values'] = {}\n295         for key, value in self.values.items():\n296             real_value = getattr(self, key)\n297             if not is_serializable(real_value):\n298                 # omit unserializable value\n299                 real_value = None\n300 \n301             # types column is also omitted\n302             __dict__['values'][key] = (real_value, value[1], None)\n303 \n304         return __dict__\n305 \n306     def __setstate__(self, state: Dict) -> None:\n307         self.__dict__.update(state)\n308 \n309 \n310 def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:\n311     \"\"\"Evaluate a config file.\"\"\"\n312     namespace = {}  # type: Dict[str, Any]\n313     namespace['__file__'] = filename\n314     namespace['tags'] = tags\n315 \n316     with cd(path.dirname(filename)):\n317         # during executing config file, current dir is changed to ``confdir``.\n318         try:\n319             execfile_(filename, namespace)\n320         except SyntaxError as err:\n321             msg = __(\"There is a syntax error in your configuration file: %s\\n\")\n322             raise ConfigError(msg % err)\n323         except SystemExit:\n324             msg = __(\"The configuration file (or one of the modules it imports) \"\n325                      \"called sys.exit()\")\n326             raise ConfigError(msg)\n327         except ConfigError:\n328             # pass through ConfigError from conf.py as is.  It will be shown in console.\n329             raise\n330         except Exception:\n331             msg = __(\"There is a programmable error in your configuration file:\\n\\n%s\")\n332             raise ConfigError(msg % traceback.format_exc())\n333 \n334     return namespace\n335 \n336 \n337 def convert_source_suffix(app: \"Sphinx\", config: Config) -> None:\n338     \"\"\"This converts old styled source_suffix to new styled one.\n339 \n340     * old style: str or list\n341     * new style: a dict which maps from fileext to filetype\n342     \"\"\"\n343     source_suffix = config.source_suffix\n344     if isinstance(source_suffix, str):\n345         # if str, considers as default filetype (None)\n346         #\n347         # The default filetype is determined on later step.\n348         # By default, it is considered as restructuredtext.\n349         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore\n350     elif isinstance(source_suffix, (list, tuple)):\n351         # if list, considers as all of them are default filetype\n352         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA\n353     elif isinstance(source_suffix, dict):\n354         # if dict, convert it to OrderedDict\n355         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore\n356     else:\n357         logger.warning(__(\"The config value `source_suffix' expects \"\n358                           \"a string, list of strings, or dictionary. \"\n359                           \"But `%r' is given.\" % source_suffix))\n360 \n361 \n362 def init_numfig_format(app: \"Sphinx\", config: Config) -> None:\n363     \"\"\"Initialize :confval:`numfig_format`.\"\"\"\n364     numfig_format = {'section': _('Section %s'),\n365                      'figure': _('Fig. %s'),\n366                      'table': _('Table %s'),\n367                      'code-block': _('Listing %s')}\n368 \n369     # override default labels by configuration\n370     numfig_format.update(config.numfig_format)\n371     config.numfig_format = numfig_format  # type: ignore\n372 \n373 \n374 def correct_copyright_year(app: \"Sphinx\", config: Config) -> None:\n375     \"\"\"correct values of copyright year that are not coherent with\n376     the SOURCE_DATE_EPOCH environment variable (if set)\n377 \n378     See https://reproducible-builds.org/specs/source-date-epoch/\n379     \"\"\"\n380     if getenv('SOURCE_DATE_EPOCH') is not None:\n381         for k in ('copyright', 'epub_copyright'):\n382             if k in config:\n383                 replace = r'\\g<1>%s' % format_date('%Y')\n384                 config[k] = copyright_year_re.sub(replace, config[k])\n385 \n386 \n387 def check_confval_types(app: \"Sphinx\", config: Config) -> None:\n388     \"\"\"check all values for deviation from the default value's type, since\n389     that can result in TypeErrors all over the place NB.\n390     \"\"\"\n391     for confval in config:\n392         default, rebuild, annotations = config.values[confval.name]\n393 \n394         if hasattr(default, '__call__'):\n395             default = default(config)  # evaluate default value\n396         if default is None and not annotations:\n397             continue  # neither inferrable nor expliclitly annotated types\n398 \n399         if annotations is Any:\n400             # any type of value is accepted\n401             pass\n402         elif isinstance(annotations, ENUM):\n403             if not annotations.match(confval.value):\n404                 msg = __(\"The config value `{name}` has to be a one of {candidates}, \"\n405                          \"but `{current}` is given.\")\n406                 logger.warning(msg.format(name=confval.name,\n407                                           current=confval.value,\n408                                           candidates=annotations.candidates))\n409         else:\n410             if type(confval.value) is type(default):\n411                 continue\n412             if type(confval.value) in annotations:\n413                 continue\n414 \n415             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &\n416                             set(type(default).__bases__))\n417             common_bases.discard(object)\n418             if common_bases:\n419                 continue  # at least we share a non-trivial base class\n420 \n421             if annotations:\n422                 msg = __(\"The config value `{name}' has type `{current.__name__}'; \"\n423                          \"expected {permitted}.\")\n424                 wrapped_annotations = [\"`{}'\".format(c.__name__) for c in annotations]\n425                 if len(wrapped_annotations) > 2:\n426                     permitted = \"{}, or {}\".format(\n427                         \", \".join(wrapped_annotations[:-1]),\n428                         wrapped_annotations[-1])\n429                 else:\n430                     permitted = \" or \".join(wrapped_annotations)\n431                 logger.warning(msg.format(name=confval.name,\n432                                           current=type(confval.value),\n433                                           permitted=permitted))\n434             else:\n435                 msg = __(\"The config value `{name}' has type `{current.__name__}', \"\n436                          \"defaults to `{default.__name__}'.\")\n437                 logger.warning(msg.format(name=confval.name,\n438                                           current=type(confval.value),\n439                                           default=type(default)))\n440 \n441 \n442 def check_unicode(config: Config) -> None:\n443     \"\"\"check all string values for non-ASCII characters in bytestrings,\n444     since that can result in UnicodeErrors all over the place\n445     \"\"\"\n446     warnings.warn('sphinx.config.check_unicode() is deprecated.',\n447                   RemovedInSphinx40Warning)\n448 \n449     nonascii_re = re.compile(br'[\\x80-\\xff]')\n450 \n451     for name, value in config._raw_config.items():\n452         if isinstance(value, bytes) and nonascii_re.search(value):\n453             logger.warning(__('the config value %r is set to a string with non-ASCII '\n454                               'characters; this can lead to Unicode errors occurring. '\n455                               'Please use Unicode strings, e.g. %r.'), name, 'Content')\n456 \n457 \n458 def check_primary_domain(app: \"Sphinx\", config: Config) -> None:\n459     primary_domain = config.primary_domain\n460     if primary_domain and not app.registry.has_domain(primary_domain):\n461         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)\n462         config.primary_domain = None  # type: ignore\n463 \n464 \n465 def check_master_doc(app: \"Sphinx\", env: \"BuildEnvironment\", added: Set[str],\n466                      changed: Set[str], removed: Set[str]) -> Set[str]:\n467     \"\"\"Adjust master_doc to 'contents' to support an old project which does not have\n468     no master_doc setting.\n469     \"\"\"\n470     if (app.config.master_doc == 'index' and\n471             'index' not in app.project.docnames and\n472             'contents' in app.project.docnames):\n473         logger.warning(__('Since v2.0, Sphinx uses \"index\" as master_doc by default. '\n474                           'Please add \"master_doc = \\'contents\\'\" to your conf.py.'))\n475         app.config.master_doc = \"contents\"  # type: ignore\n476 \n477     return changed\n478 \n479 \n480 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n481     app.connect('config-inited', convert_source_suffix)\n482     app.connect('config-inited', init_numfig_format)\n483     app.connect('config-inited', correct_copyright_year)\n484     app.connect('config-inited', check_confval_types)\n485     app.connect('config-inited', check_primary_domain)\n486     app.connect('env-get-outdated', check_master_doc)\n487 \n488     return {\n489         'version': 'builtin',\n490         'parallel_read_safe': True,\n491         'parallel_write_safe': True,\n492     }\n",
        "intended_behavior": "This file is responsible for handling Sphinx configuration. An update here should introduce a new configuration option, e.g., `file_extension_priority`, which allows users to specify an ordered list of file extensions according to their priorities. This new configuration option should be documented and have default behavior that preserves the current functionality (e.g., an empty list or a list favoring Sphinx's default file extension handling), ensuring backward compatibility."
    }
]