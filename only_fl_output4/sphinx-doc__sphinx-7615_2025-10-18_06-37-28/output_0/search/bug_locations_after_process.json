[
    {
        "rel_file_path": "sphinx/parsers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/parsers.py",
        "start": 83,
        "end": 103,
        "class_name": "RSTParser",
        "method_name": "parse",
        "code": "83     def parse(self, inputstring: Union[str, StringList], document: nodes.document) -> None:\n84         \"\"\"Parse text and generate a document tree.\"\"\"\n85         self.setup_parse(inputstring, document)  # type: ignore\n86         self.statemachine = states.RSTStateMachine(\n87             state_classes=self.state_classes,\n88             initial_state=self.initial_state,\n89             debug=document.reporter.debug_flag)\n90 \n91         # preprocess inputstring\n92         if isinstance(inputstring, str):\n93             lines = docutils.statemachine.string2lines(\n94                 inputstring, tab_width=document.settings.tab_width,\n95                 convert_whitespace=True)\n96 \n97             inputlines = StringList(lines, document.current_source)\n98         else:\n99             inputlines = inputstring\n100 \n101         self.decorate(inputlines)\n102         self.statemachine.run(inputlines, document, inliner=self.inliner)\n103         self.finish_parse()\n",
        "intended_behavior": "The `parse` method needs to correctly handle the parsing of backslashes so that it adheres to the RST specification and Docutils' behavior. This means ensuring that the sequence of backslashes is processed in a way that for every pair of backslashes in the input, one backslash is rendered in the output, starting from two backslashes resulting in a single backslash in the output, and scaling up accordingly. This implementation should consider edge cases and ensure that the existing functionality for parsing RST documents is preserved, specifically in handling other escape sequences and special characters. The method might require adjusting or extending the logic that interprets escape sequences or backslashes in the input string or leveraging/extending Docutils' core parsing strategies to retain consistency."
    },
    {
        "rel_file_path": "sphinx/parsers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/parsers.py",
        "start": 71,
        "end": 108,
        "class_name": "RSTParser",
        "method_name": null,
        "code": "71 class RSTParser(docutils.parsers.rst.Parser, Parser):\n72     \"\"\"A reST parser for Sphinx.\"\"\"\n73 \n74     def get_transforms(self) -> List[\"Type[Transform]\"]:\n75         \"\"\"Sphinx's reST parser replaces a transform class for smart-quotes by own's\n76 \n77         refs: sphinx.io.SphinxStandaloneReader\n78         \"\"\"\n79         transforms = super().get_transforms()\n80         transforms.remove(SmartQuotes)\n81         return transforms\n82 \n83     def parse(self, inputstring: Union[str, StringList], document: nodes.document) -> None:\n84         \"\"\"Parse text and generate a document tree.\"\"\"\n85         self.setup_parse(inputstring, document)  # type: ignore\n86         self.statemachine = states.RSTStateMachine(\n87             state_classes=self.state_classes,\n88             initial_state=self.initial_state,\n89             debug=document.reporter.debug_flag)\n90 \n91         # preprocess inputstring\n92         if isinstance(inputstring, str):\n93             lines = docutils.statemachine.string2lines(\n94                 inputstring, tab_width=document.settings.tab_width,\n95                 convert_whitespace=True)\n96 \n97             inputlines = StringList(lines, document.current_source)\n98         else:\n99             inputlines = inputstring\n100 \n101         self.decorate(inputlines)\n102         self.statemachine.run(inputlines, document, inliner=self.inliner)\n103         self.finish_parse()\n104 \n105     def decorate(self, content: StringList) -> None:\n106         \"\"\"Preprocess reST content before parsing.\"\"\"\n107         prepend_prolog(content, self.config.rst_prolog)\n108         append_epilog(content, self.config.rst_epilog)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "sphinx/util/texescape.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/util/texescape.py",
        "start": 1,
        "end": 169,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.texescape\n3     ~~~~~~~~~~~~~~~~~~~~~\n4 \n5     TeX escaping helper.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 from typing import Dict\n13 \n14 from sphinx.deprecation import RemovedInSphinx40Warning, deprecated_alias\n15 \n16 \n17 tex_replacements = [\n18     # map TeX special chars\n19     ('$', r'\\$'),\n20     ('%', r'\\%'),\n21     ('&', r'\\&'),\n22     ('#', r'\\#'),\n23     ('_', r'\\_'),\n24     ('{', r'\\{'),\n25     ('}', r'\\}'),\n26     ('\\\\', r'\\textbackslash{}'),\n27     ('~', r'\\textasciitilde{}'),\n28     ('^', r'\\textasciicircum{}'),\n29     # map chars to avoid mis-interpretation in LaTeX\n30     ('[', r'{[}'),\n31     (']', r'{]}'),\n32     # map special Unicode characters to TeX commands\n33     ('\u2713', r'\\(\\checkmark\\)'),\n34     ('\u2714', r'\\(\\pmb{\\checkmark}\\)'),\n35     # used to separate -- in options\n36     ('\ufeff', r'{}'),\n37     # map some special Unicode characters to similar ASCII ones\n38     # (even for Unicode LaTeX as may not be supported by OpenType font)\n39     ('\u23bd', r'\\_'),\n40     ('\u212f', r'e'),\n41     ('\u2148', r'i'),\n42     # Greek alphabet not escaped: pdflatex handles it via textalpha and inputenc\n43     # OHM SIGN U+2126 is handled by LaTeX textcomp package\n44 ]\n45 \n46 # A map to avoid TeX ligatures or character replacements in PDF output\n47 # xelatex/lualatex/uplatex are handled differently (#5790, #6888)\n48 ascii_tex_replacements = [\n49     # Note: the \" renders curly in OT1 encoding but straight in T1, T2A, LY1...\n50     #       escaping it to \\textquotedbl would break documents using OT1\n51     #       Sphinx does \\shorthandoff{\"} to avoid problems with some languages\n52     # There is no \\text... LaTeX escape for the hyphen character -\n53     ('-', r'\\sphinxhyphen{}'),  # -- and --- are TeX ligatures\n54     # ,, is a TeX ligature in T1 encoding, but escaping the comma adds\n55     # complications (whether by {}, or a macro) and is not done\n56     # the next two require textcomp package\n57     (\"'\", r'\\textquotesingle{}'),  # else ' renders curly, and '' is a ligature\n58     ('`', r'\\textasciigrave{}'),   # else \\` and \\`\\` render curly\n59     ('<', r'\\textless{}'),     # < is inv. exclam in OT1, << is a T1-ligature\n60     ('>', r'\\textgreater{}'),  # > is inv. quest. mark in 0T1, >> a T1-ligature\n61 ]\n62 \n63 # A map Unicode characters to LaTeX representation\n64 # (for LaTeX engines which don't support unicode)\n65 unicode_tex_replacements = [\n66     # map some more common Unicode characters to TeX commands\n67     ('\u00b6', r'\\P{}'),\n68     ('\u00a7', r'\\S{}'),\n69     ('\u20ac', r'\\texteuro{}'),\n70     ('\u221e', r'\\(\\infty\\)'),\n71     ('\u00b1', r'\\(\\pm\\)'),\n72     ('\u2192', r'\\(\\rightarrow\\)'),\n73     ('\u2023', r'\\(\\rightarrow\\)'),\n74     ('\u2013', r'\\textendash{}'),\n75     # superscript\n76     ('\u2070', r'\\(\\sp{\\text{0}}\\)'),\n77     ('\u00b9', r'\\(\\sp{\\text{1}}\\)'),\n78     ('\u00b2', r'\\(\\sp{\\text{2}}\\)'),\n79     ('\u00b3', r'\\(\\sp{\\text{3}}\\)'),\n80     ('\u2074', r'\\(\\sp{\\text{4}}\\)'),\n81     ('\u2075', r'\\(\\sp{\\text{5}}\\)'),\n82     ('\u2076', r'\\(\\sp{\\text{6}}\\)'),\n83     ('\u2077', r'\\(\\sp{\\text{7}}\\)'),\n84     ('\u2078', r'\\(\\sp{\\text{8}}\\)'),\n85     ('\u2079', r'\\(\\sp{\\text{9}}\\)'),\n86     # subscript\n87     ('\u2080', r'\\(\\sb{\\text{0}}\\)'),\n88     ('\u2081', r'\\(\\sb{\\text{1}}\\)'),\n89     ('\u2082', r'\\(\\sb{\\text{2}}\\)'),\n90     ('\u2083', r'\\(\\sb{\\text{3}}\\)'),\n91     ('\u2084', r'\\(\\sb{\\text{4}}\\)'),\n92     ('\u2085', r'\\(\\sb{\\text{5}}\\)'),\n93     ('\u2086', r'\\(\\sb{\\text{6}}\\)'),\n94     ('\u2087', r'\\(\\sb{\\text{7}}\\)'),\n95     ('\u2088', r'\\(\\sb{\\text{8}}\\)'),\n96     ('\u2089', r'\\(\\sb{\\text{9}}\\)'),\n97 ]\n98 \n99 # TODO: this should be called tex_idescape_map because its only use is in\n100 #       sphinx.writers.latex.LaTeXTranslator.idescape()\n101 # %, {, }, \\, #, and ~ are the only ones which must be replaced by _ character\n102 # It would be simpler to define it entirely here rather than in init().\n103 # Unicode replacements are superfluous, as idescape() uses backslashreplace\n104 tex_replace_map = {}  # type: Dict[int, str]\n105 \n106 _tex_escape_map = {}  # type: Dict[int, str]\n107 _tex_escape_map_without_unicode = {}  # type: Dict[int, str]\n108 _tex_hlescape_map = {}  # type: Dict[int, str]\n109 _tex_hlescape_map_without_unicode = {}  # type: Dict[int, str]\n110 \n111 \n112 deprecated_alias('sphinx.util.texescape',\n113                  {\n114                      'tex_escape_map': _tex_escape_map,\n115                      'tex_hl_escape_map_new': _tex_hlescape_map,\n116                  },\n117                  RemovedInSphinx40Warning)\n118 \n119 \n120 def escape(s: str, latex_engine: str = None) -> str:\n121     \"\"\"Escape text for LaTeX output.\"\"\"\n122     if latex_engine in ('lualatex', 'xelatex'):\n123         # unicode based LaTeX engine\n124         return s.translate(_tex_escape_map_without_unicode)\n125     else:\n126         return s.translate(_tex_escape_map)\n127 \n128 \n129 def hlescape(s: str, latex_engine: str = None) -> str:\n130     \"\"\"Escape text for LaTeX highlighter.\"\"\"\n131     if latex_engine in ('lualatex', 'xelatex'):\n132         # unicode based LaTeX engine\n133         return s.translate(_tex_hlescape_map_without_unicode)\n134     else:\n135         return s.translate(_tex_hlescape_map)\n136 \n137 \n138 def escape_abbr(text: str) -> str:\n139     \"\"\"Adjust spacing after abbreviations. Works with @ letter or other.\"\"\"\n140     return re.sub(r'\\.(?=\\s|$)', r'.\\@{}', text)\n141 \n142 \n143 def init() -> None:\n144     for a, b in tex_replacements:\n145         _tex_escape_map[ord(a)] = b\n146         _tex_escape_map_without_unicode[ord(a)] = b\n147         tex_replace_map[ord(a)] = '_'\n148 \n149     # no reason to do this for _tex_escape_map_without_unicode\n150     for a, b in ascii_tex_replacements:\n151         _tex_escape_map[ord(a)] = b\n152 \n153     # but the hyphen has a specific PDF bookmark problem\n154     # https://github.com/latex3/hyperref/issues/112\n155     _tex_escape_map_without_unicode[ord('-')] = r'\\sphinxhyphen{}'\n156 \n157     for a, b in unicode_tex_replacements:\n158         _tex_escape_map[ord(a)] = b\n159         #  This is actually unneeded:\n160         tex_replace_map[ord(a)] = '_'\n161 \n162     for a, b in tex_replacements:\n163         if a in '[]{}\\\\':\n164             continue\n165         _tex_hlescape_map[ord(a)] = b\n166         _tex_hlescape_map_without_unicode[ord(a)] = b\n167 \n168     for a, b in unicode_tex_replacements:\n169         _tex_hlescape_map[ord(a)] = b\n",
        "intended_behavior": "Since this file likely deals with LaTeX-specific escaping logic, including handling of backslashes for LaTeX documents, it should ensure that escaping backslashes for LaTeX output does not conflict with the logic described for general parsing and rendering in RST. The intended behavior here is to review and possibly adjust the handling of consecutive backslashes specifically for LaTeX rendering, making sure it aligns with the expectations outlined in the issue (replicating Docutils' rendering behavior). Adjustments or enhancements here should preserve any existing LaTeX-specific escaping functionalities, ensuring that modifications do not introduce regressions for other characters or escape sequences."
    }
]