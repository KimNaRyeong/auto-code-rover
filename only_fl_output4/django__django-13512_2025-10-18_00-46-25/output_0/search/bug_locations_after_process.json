[
    {
        "rel_file_path": "django/contrib/admin/utils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/contrib/admin/utils.py",
        "start": 1,
        "end": 550,
        "class_name": null,
        "method_name": null,
        "code": "1 import datetime\n2 import decimal\n3 from collections import defaultdict\n4 \n5 from django.core.exceptions import FieldDoesNotExist\n6 from django.db import models, router\n7 from django.db.models.constants import LOOKUP_SEP\n8 from django.db.models.deletion import Collector\n9 from django.forms.utils import pretty_name\n10 from django.urls import NoReverseMatch, reverse\n11 from django.utils import formats, timezone\n12 from django.utils.html import format_html\n13 from django.utils.regex_helper import _lazy_re_compile\n14 from django.utils.text import capfirst\n15 from django.utils.translation import ngettext, override as translation_override\n16 \n17 QUOTE_MAP = {i: '_%02X' % i for i in b'\":/_#?;@&=+$,\"[]<>%\\n\\\\'}\n18 UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}\n19 UNQUOTE_RE = _lazy_re_compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))\n20 \n21 \n22 class FieldIsAForeignKeyColumnName(Exception):\n23     \"\"\"A field is a foreign key attname, i.e. <FK>_id.\"\"\"\n24     pass\n25 \n26 \n27 def lookup_needs_distinct(opts, lookup_path):\n28     \"\"\"\n29     Return True if 'distinct()' should be used to query the given lookup path.\n30     \"\"\"\n31     lookup_fields = lookup_path.split(LOOKUP_SEP)\n32     # Go through the fields (following all relations) and look for an m2m.\n33     for field_name in lookup_fields:\n34         if field_name == 'pk':\n35             field_name = opts.pk.name\n36         try:\n37             field = opts.get_field(field_name)\n38         except FieldDoesNotExist:\n39             # Ignore query lookups.\n40             continue\n41         else:\n42             if hasattr(field, 'get_path_info'):\n43                 # This field is a relation; update opts to follow the relation.\n44                 path_info = field.get_path_info()\n45                 opts = path_info[-1].to_opts\n46                 if any(path.m2m for path in path_info):\n47                     # This field is a m2m relation so distinct must be called.\n48                     return True\n49     return False\n50 \n51 \n52 def prepare_lookup_value(key, value):\n53     \"\"\"\n54     Return a lookup value prepared to be used in queryset filtering.\n55     \"\"\"\n56     # if key ends with __in, split parameter into separate values\n57     if key.endswith('__in'):\n58         value = value.split(',')\n59     # if key ends with __isnull, special case '' and the string literals 'false' and '0'\n60     elif key.endswith('__isnull'):\n61         value = value.lower() not in ('', 'false', '0')\n62     return value\n63 \n64 \n65 def quote(s):\n66     \"\"\"\n67     Ensure that primary key values do not confuse the admin URLs by escaping\n68     any '/', '_' and ':' and similarly problematic characters.\n69     Similar to urllib.parse.quote(), except that the quoting is slightly\n70     different so that it doesn't get automatically unquoted by the Web browser.\n71     \"\"\"\n72     return s.translate(QUOTE_MAP) if isinstance(s, str) else s\n73 \n74 \n75 def unquote(s):\n76     \"\"\"Undo the effects of quote().\"\"\"\n77     return UNQUOTE_RE.sub(lambda m: UNQUOTE_MAP[m[0]], s)\n78 \n79 \n80 def flatten(fields):\n81     \"\"\"\n82     Return a list which is a single level of flattening of the original list.\n83     \"\"\"\n84     flat = []\n85     for field in fields:\n86         if isinstance(field, (list, tuple)):\n87             flat.extend(field)\n88         else:\n89             flat.append(field)\n90     return flat\n91 \n92 \n93 def flatten_fieldsets(fieldsets):\n94     \"\"\"Return a list of field names from an admin fieldsets structure.\"\"\"\n95     field_names = []\n96     for name, opts in fieldsets:\n97         field_names.extend(\n98             flatten(opts['fields'])\n99         )\n100     return field_names\n101 \n102 \n103 def get_deleted_objects(objs, request, admin_site):\n104     \"\"\"\n105     Find all objects related to ``objs`` that should also be deleted. ``objs``\n106     must be a homogeneous iterable of objects (e.g. a QuerySet).\n107 \n108     Return a nested list of strings suitable for display in the\n109     template with the ``unordered_list`` filter.\n110     \"\"\"\n111     try:\n112         obj = objs[0]\n113     except IndexError:\n114         return [], {}, set(), []\n115     else:\n116         using = router.db_for_write(obj._meta.model)\n117     collector = NestedObjects(using=using)\n118     collector.collect(objs)\n119     perms_needed = set()\n120 \n121     def format_callback(obj):\n122         model = obj.__class__\n123         has_admin = model in admin_site._registry\n124         opts = obj._meta\n125 \n126         no_edit_link = '%s: %s' % (capfirst(opts.verbose_name), obj)\n127 \n128         if has_admin:\n129             if not admin_site._registry[model].has_delete_permission(request, obj):\n130                 perms_needed.add(opts.verbose_name)\n131             try:\n132                 admin_url = reverse('%s:%s_%s_change'\n133                                     % (admin_site.name,\n134                                        opts.app_label,\n135                                        opts.model_name),\n136                                     None, (quote(obj.pk),))\n137             except NoReverseMatch:\n138                 # Change url doesn't exist -- don't display link to edit\n139                 return no_edit_link\n140 \n141             # Display a link to the admin page.\n142             return format_html('{}: <a href=\"{}\">{}</a>',\n143                                capfirst(opts.verbose_name),\n144                                admin_url,\n145                                obj)\n146         else:\n147             # Don't display link to edit, because it either has no\n148             # admin or is edited inline.\n149             return no_edit_link\n150 \n151     to_delete = collector.nested(format_callback)\n152 \n153     protected = [format_callback(obj) for obj in collector.protected]\n154     model_count = {model._meta.verbose_name_plural: len(objs) for model, objs in collector.model_objs.items()}\n155 \n156     return to_delete, model_count, perms_needed, protected\n157 \n158 \n159 class NestedObjects(Collector):\n160     def __init__(self, *args, **kwargs):\n161         super().__init__(*args, **kwargs)\n162         self.edges = {}  # {from_instance: [to_instances]}\n163         self.protected = set()\n164         self.model_objs = defaultdict(set)\n165 \n166     def add_edge(self, source, target):\n167         self.edges.setdefault(source, []).append(target)\n168 \n169     def collect(self, objs, source=None, source_attr=None, **kwargs):\n170         for obj in objs:\n171             if source_attr and not source_attr.endswith('+'):\n172                 related_name = source_attr % {\n173                     'class': source._meta.model_name,\n174                     'app_label': source._meta.app_label,\n175                 }\n176                 self.add_edge(getattr(obj, related_name), obj)\n177             else:\n178                 self.add_edge(None, obj)\n179             self.model_objs[obj._meta.model].add(obj)\n180         try:\n181             return super().collect(objs, source_attr=source_attr, **kwargs)\n182         except models.ProtectedError as e:\n183             self.protected.update(e.protected_objects)\n184         except models.RestrictedError as e:\n185             self.protected.update(e.restricted_objects)\n186 \n187     def related_objects(self, related_model, related_fields, objs):\n188         qs = super().related_objects(related_model, related_fields, objs)\n189         return qs.select_related(*[related_field.name for related_field in related_fields])\n190 \n191     def _nested(self, obj, seen, format_callback):\n192         if obj in seen:\n193             return []\n194         seen.add(obj)\n195         children = []\n196         for child in self.edges.get(obj, ()):\n197             children.extend(self._nested(child, seen, format_callback))\n198         if format_callback:\n199             ret = [format_callback(obj)]\n200         else:\n201             ret = [obj]\n202         if children:\n203             ret.append(children)\n204         return ret\n205 \n206     def nested(self, format_callback=None):\n207         \"\"\"\n208         Return the graph as a nested list.\n209         \"\"\"\n210         seen = set()\n211         roots = []\n212         for root in self.edges.get(None, ()):\n213             roots.extend(self._nested(root, seen, format_callback))\n214         return roots\n215 \n216     def can_fast_delete(self, *args, **kwargs):\n217         \"\"\"\n218         We always want to load the objects into memory so that we can display\n219         them to the user in confirm page.\n220         \"\"\"\n221         return False\n222 \n223 \n224 def model_format_dict(obj):\n225     \"\"\"\n226     Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',\n227     typically for use with string formatting.\n228 \n229     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.\n230     \"\"\"\n231     if isinstance(obj, (models.Model, models.base.ModelBase)):\n232         opts = obj._meta\n233     elif isinstance(obj, models.query.QuerySet):\n234         opts = obj.model._meta\n235     else:\n236         opts = obj\n237     return {\n238         'verbose_name': opts.verbose_name,\n239         'verbose_name_plural': opts.verbose_name_plural,\n240     }\n241 \n242 \n243 def model_ngettext(obj, n=None):\n244     \"\"\"\n245     Return the appropriate `verbose_name` or `verbose_name_plural` value for\n246     `obj` depending on the count `n`.\n247 \n248     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.\n249     If `obj` is a `QuerySet` instance, `n` is optional and the length of the\n250     `QuerySet` is used.\n251     \"\"\"\n252     if isinstance(obj, models.query.QuerySet):\n253         if n is None:\n254             n = obj.count()\n255         obj = obj.model\n256     d = model_format_dict(obj)\n257     singular, plural = d[\"verbose_name\"], d[\"verbose_name_plural\"]\n258     return ngettext(singular, plural, n or 0)\n259 \n260 \n261 def lookup_field(name, obj, model_admin=None):\n262     opts = obj._meta\n263     try:\n264         f = _get_non_gfk_field(opts, name)\n265     except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):\n266         # For non-field values, the value is either a method, property or\n267         # returned via a callable.\n268         if callable(name):\n269             attr = name\n270             value = attr(obj)\n271         elif hasattr(model_admin, name) and name != '__str__':\n272             attr = getattr(model_admin, name)\n273             value = attr(obj)\n274         else:\n275             attr = getattr(obj, name)\n276             if callable(attr):\n277                 value = attr()\n278             else:\n279                 value = attr\n280         f = None\n281     else:\n282         attr = None\n283         value = getattr(obj, name)\n284     return f, attr, value\n285 \n286 \n287 def _get_non_gfk_field(opts, name):\n288     \"\"\"\n289     For historical reasons, the admin app relies on GenericForeignKeys as being\n290     \"not found\" by get_field(). This could likely be cleaned up.\n291 \n292     Reverse relations should also be excluded as these aren't attributes of the\n293     model (rather something like `foo_set`).\n294     \"\"\"\n295     field = opts.get_field(name)\n296     if (field.is_relation and\n297             # Generic foreign keys OR reverse relations\n298             ((field.many_to_one and not field.related_model) or field.one_to_many)):\n299         raise FieldDoesNotExist()\n300 \n301     # Avoid coercing <FK>_id fields to FK\n302     if field.is_relation and not field.many_to_many and hasattr(field, 'attname') and field.attname == name:\n303         raise FieldIsAForeignKeyColumnName()\n304 \n305     return field\n306 \n307 \n308 def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\n309     \"\"\"\n310     Return a sensible label for a field name. The name can be a callable,\n311     property (but not created with @property decorator), or the name of an\n312     object's attribute, as well as a model field. If return_attr is True, also\n313     return the resolved attribute (which could be a callable). This will be\n314     None if (and only if) the name refers to a field.\n315     \"\"\"\n316     attr = None\n317     try:\n318         field = _get_non_gfk_field(model._meta, name)\n319         try:\n320             label = field.verbose_name\n321         except AttributeError:\n322             # field is likely a ForeignObjectRel\n323             label = field.related_model._meta.verbose_name\n324     except FieldDoesNotExist:\n325         if name == \"__str__\":\n326             label = str(model._meta.verbose_name)\n327             attr = str\n328         else:\n329             if callable(name):\n330                 attr = name\n331             elif hasattr(model_admin, name):\n332                 attr = getattr(model_admin, name)\n333             elif hasattr(model, name):\n334                 attr = getattr(model, name)\n335             elif form and name in form.fields:\n336                 attr = form.fields[name]\n337             else:\n338                 message = \"Unable to lookup '%s' on %s\" % (name, model._meta.object_name)\n339                 if model_admin:\n340                     message += \" or %s\" % model_admin.__class__.__name__\n341                 if form:\n342                     message += \" or %s\" % form.__class__.__name__\n343                 raise AttributeError(message)\n344 \n345             if hasattr(attr, \"short_description\"):\n346                 label = attr.short_description\n347             elif (isinstance(attr, property) and\n348                   hasattr(attr, \"fget\") and\n349                   hasattr(attr.fget, \"short_description\")):\n350                 label = attr.fget.short_description\n351             elif callable(attr):\n352                 if attr.__name__ == \"<lambda>\":\n353                     label = \"--\"\n354                 else:\n355                     label = pretty_name(attr.__name__)\n356             else:\n357                 label = pretty_name(name)\n358     except FieldIsAForeignKeyColumnName:\n359         label = pretty_name(name)\n360         attr = name\n361 \n362     if return_attr:\n363         return (label, attr)\n364     else:\n365         return label\n366 \n367 \n368 def help_text_for_field(name, model):\n369     help_text = \"\"\n370     try:\n371         field = _get_non_gfk_field(model._meta, name)\n372     except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):\n373         pass\n374     else:\n375         if hasattr(field, 'help_text'):\n376             help_text = field.help_text\n377     return help_text\n378 \n379 \n380 def display_for_field(value, field, empty_value_display):\n381     from django.contrib.admin.templatetags.admin_list import _boolean_icon\n382 \n383     if getattr(field, 'flatchoices', None):\n384         return dict(field.flatchoices).get(value, empty_value_display)\n385     # BooleanField needs special-case null-handling, so it comes before the\n386     # general null test.\n387     elif isinstance(field, models.BooleanField):\n388         return _boolean_icon(value)\n389     elif value is None:\n390         return empty_value_display\n391     elif isinstance(field, models.DateTimeField):\n392         return formats.localize(timezone.template_localtime(value))\n393     elif isinstance(field, (models.DateField, models.TimeField)):\n394         return formats.localize(value)\n395     elif isinstance(field, models.DecimalField):\n396         return formats.number_format(value, field.decimal_places)\n397     elif isinstance(field, (models.IntegerField, models.FloatField)):\n398         return formats.number_format(value)\n399     elif isinstance(field, models.FileField) and value:\n400         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n401     elif isinstance(field, models.JSONField) and value:\n402         try:\n403             return field.get_prep_value(value)\n404         except TypeError:\n405             return display_for_value(value, empty_value_display)\n406     else:\n407         return display_for_value(value, empty_value_display)\n408 \n409 \n410 def display_for_value(value, empty_value_display, boolean=False):\n411     from django.contrib.admin.templatetags.admin_list import _boolean_icon\n412 \n413     if boolean:\n414         return _boolean_icon(value)\n415     elif value is None:\n416         return empty_value_display\n417     elif isinstance(value, bool):\n418         return str(value)\n419     elif isinstance(value, datetime.datetime):\n420         return formats.localize(timezone.template_localtime(value))\n421     elif isinstance(value, (datetime.date, datetime.time)):\n422         return formats.localize(value)\n423     elif isinstance(value, (int, decimal.Decimal, float)):\n424         return formats.number_format(value)\n425     elif isinstance(value, (list, tuple)):\n426         return ', '.join(str(v) for v in value)\n427     else:\n428         return str(value)\n429 \n430 \n431 class NotRelationField(Exception):\n432     pass\n433 \n434 \n435 def get_model_from_relation(field):\n436     if hasattr(field, 'get_path_info'):\n437         return field.get_path_info()[-1].to_opts.model\n438     else:\n439         raise NotRelationField\n440 \n441 \n442 def reverse_field_path(model, path):\n443     \"\"\" Create a reversed field path.\n444 \n445     E.g. Given (Order, \"user__groups\"),\n446     return (Group, \"user__order\").\n447 \n448     Final field must be a related model, not a data field.\n449     \"\"\"\n450     reversed_path = []\n451     parent = model\n452     pieces = path.split(LOOKUP_SEP)\n453     for piece in pieces:\n454         field = parent._meta.get_field(piece)\n455         # skip trailing data field if extant:\n456         if len(reversed_path) == len(pieces) - 1:  # final iteration\n457             try:\n458                 get_model_from_relation(field)\n459             except NotRelationField:\n460                 break\n461 \n462         # Field should point to another model\n463         if field.is_relation and not (field.auto_created and not field.concrete):\n464             related_name = field.related_query_name()\n465             parent = field.remote_field.model\n466         else:\n467             related_name = field.field.name\n468             parent = field.related_model\n469         reversed_path.insert(0, related_name)\n470     return (parent, LOOKUP_SEP.join(reversed_path))\n471 \n472 \n473 def get_fields_from_path(model, path):\n474     \"\"\" Return list of Fields given path relative to model.\n475 \n476     e.g. (ModelX, \"user__groups__name\") -> [\n477         <django.db.models.fields.related.ForeignKey object at 0x...>,\n478         <django.db.models.fields.related.ManyToManyField object at 0x...>,\n479         <django.db.models.fields.CharField object at 0x...>,\n480     ]\n481     \"\"\"\n482     pieces = path.split(LOOKUP_SEP)\n483     fields = []\n484     for piece in pieces:\n485         if fields:\n486             parent = get_model_from_relation(fields[-1])\n487         else:\n488             parent = model\n489         fields.append(parent._meta.get_field(piece))\n490     return fields\n491 \n492 \n493 def construct_change_message(form, formsets, add):\n494     \"\"\"\n495     Construct a JSON structure describing changes from a changed object.\n496     Translations are deactivated so that strings are stored untranslated.\n497     Translation happens later on LogEntry access.\n498     \"\"\"\n499     # Evaluating `form.changed_data` prior to disabling translations is required\n500     # to avoid fields affected by localization from being included incorrectly,\n501     # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.\n502     changed_data = form.changed_data\n503     with translation_override(None):\n504         # Deactivate translations while fetching verbose_name for form\n505         # field labels and using `field_name`, if verbose_name is not provided.\n506         # Translations will happen later on LogEntry access.\n507         changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)\n508 \n509     change_message = []\n510     if add:\n511         change_message.append({'added': {}})\n512     elif form.changed_data:\n513         change_message.append({'changed': {'fields': changed_field_labels}})\n514     if formsets:\n515         with translation_override(None):\n516             for formset in formsets:\n517                 for added_object in formset.new_objects:\n518                     change_message.append({\n519                         'added': {\n520                             'name': str(added_object._meta.verbose_name),\n521                             'object': str(added_object),\n522                         }\n523                     })\n524                 for changed_object, changed_fields in formset.changed_objects:\n525                     change_message.append({\n526                         'changed': {\n527                             'name': str(changed_object._meta.verbose_name),\n528                             'object': str(changed_object),\n529                             'fields': _get_changed_field_labels_from_form(formset.forms[0], changed_fields),\n530                         }\n531                     })\n532                 for deleted_object in formset.deleted_objects:\n533                     change_message.append({\n534                         'deleted': {\n535                             'name': str(deleted_object._meta.verbose_name),\n536                             'object': str(deleted_object),\n537                         }\n538                     })\n539     return change_message\n540 \n541 \n542 def _get_changed_field_labels_from_form(form, changed_data):\n543     changed_field_labels = []\n544     for field_name in changed_data:\n545         try:\n546             verbose_field_name = form.fields[field_name].label or field_name\n547         except KeyError:\n548             verbose_field_name = field_name\n549         changed_field_labels.append(str(verbose_field_name))\n550     return changed_field_labels\n",
        "intended_behavior": "Ensure that any serialization of `JSONField` for admin purposes supports non-ASCII characters correctly. This could involve adjusting the use of `json.dumps` to include `ensure_ascii=False` and ensuring that any such change does not affect the functionality for other field types or the admin interface at large."
    },
    {
        "rel_file_path": "django/db/models/fields/json.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/fields/json.py",
        "start": 1,
        "end": 520,
        "class_name": null,
        "method_name": null,
        "code": "1 import json\n2 \n3 from django import forms\n4 from django.core import checks, exceptions\n5 from django.db import NotSupportedError, connections, router\n6 from django.db.models import lookups\n7 from django.db.models.lookups import PostgresOperatorLookup, Transform\n8 from django.utils.translation import gettext_lazy as _\n9 \n10 from . import Field\n11 from .mixins import CheckFieldDefaultMixin\n12 \n13 __all__ = ['JSONField']\n14 \n15 \n16 class JSONField(CheckFieldDefaultMixin, Field):\n17     empty_strings_allowed = False\n18     description = _('A JSON object')\n19     default_error_messages = {\n20         'invalid': _('Value must be valid JSON.'),\n21     }\n22     _default_hint = ('dict', '{}')\n23 \n24     def __init__(\n25         self, verbose_name=None, name=None, encoder=None, decoder=None,\n26         **kwargs,\n27     ):\n28         if encoder and not callable(encoder):\n29             raise ValueError('The encoder parameter must be a callable object.')\n30         if decoder and not callable(decoder):\n31             raise ValueError('The decoder parameter must be a callable object.')\n32         self.encoder = encoder\n33         self.decoder = decoder\n34         super().__init__(verbose_name, name, **kwargs)\n35 \n36     def check(self, **kwargs):\n37         errors = super().check(**kwargs)\n38         databases = kwargs.get('databases') or []\n39         errors.extend(self._check_supported(databases))\n40         return errors\n41 \n42     def _check_supported(self, databases):\n43         errors = []\n44         for db in databases:\n45             if not router.allow_migrate_model(db, self.model):\n46                 continue\n47             connection = connections[db]\n48             if not (\n49                 'supports_json_field' in self.model._meta.required_db_features or\n50                 connection.features.supports_json_field\n51             ):\n52                 errors.append(\n53                     checks.Error(\n54                         '%s does not support JSONFields.'\n55                         % connection.display_name,\n56                         obj=self.model,\n57                         id='fields.E180',\n58                     )\n59                 )\n60         return errors\n61 \n62     def deconstruct(self):\n63         name, path, args, kwargs = super().deconstruct()\n64         if self.encoder is not None:\n65             kwargs['encoder'] = self.encoder\n66         if self.decoder is not None:\n67             kwargs['decoder'] = self.decoder\n68         return name, path, args, kwargs\n69 \n70     def from_db_value(self, value, expression, connection):\n71         if value is None:\n72             return value\n73         try:\n74             return json.loads(value, cls=self.decoder)\n75         except json.JSONDecodeError:\n76             return value\n77 \n78     def get_internal_type(self):\n79         return 'JSONField'\n80 \n81     def get_prep_value(self, value):\n82         if value is None:\n83             return value\n84         return json.dumps(value, cls=self.encoder)\n85 \n86     def get_transform(self, name):\n87         transform = super().get_transform(name)\n88         if transform:\n89             return transform\n90         return KeyTransformFactory(name)\n91 \n92     def validate(self, value, model_instance):\n93         super().validate(value, model_instance)\n94         try:\n95             json.dumps(value, cls=self.encoder)\n96         except TypeError:\n97             raise exceptions.ValidationError(\n98                 self.error_messages['invalid'],\n99                 code='invalid',\n100                 params={'value': value},\n101             )\n102 \n103     def value_to_string(self, obj):\n104         return self.value_from_object(obj)\n105 \n106     def formfield(self, **kwargs):\n107         return super().formfield(**{\n108             'form_class': forms.JSONField,\n109             'encoder': self.encoder,\n110             'decoder': self.decoder,\n111             **kwargs,\n112         })\n113 \n114 \n115 def compile_json_path(key_transforms, include_root=True):\n116     path = ['$'] if include_root else []\n117     for key_transform in key_transforms:\n118         try:\n119             num = int(key_transform)\n120         except ValueError:  # non-integer\n121             path.append('.')\n122             path.append(json.dumps(key_transform))\n123         else:\n124             path.append('[%s]' % num)\n125     return ''.join(path)\n126 \n127 \n128 class DataContains(PostgresOperatorLookup):\n129     lookup_name = 'contains'\n130     postgres_operator = '@>'\n131 \n132     def as_sql(self, compiler, connection):\n133         if not connection.features.supports_json_field_contains:\n134             raise NotSupportedError(\n135                 'contains lookup is not supported on this database backend.'\n136             )\n137         lhs, lhs_params = self.process_lhs(compiler, connection)\n138         rhs, rhs_params = self.process_rhs(compiler, connection)\n139         params = tuple(lhs_params) + tuple(rhs_params)\n140         return 'JSON_CONTAINS(%s, %s)' % (lhs, rhs), params\n141 \n142 \n143 class ContainedBy(PostgresOperatorLookup):\n144     lookup_name = 'contained_by'\n145     postgres_operator = '<@'\n146 \n147     def as_sql(self, compiler, connection):\n148         if not connection.features.supports_json_field_contains:\n149             raise NotSupportedError(\n150                 'contained_by lookup is not supported on this database backend.'\n151             )\n152         lhs, lhs_params = self.process_lhs(compiler, connection)\n153         rhs, rhs_params = self.process_rhs(compiler, connection)\n154         params = tuple(rhs_params) + tuple(lhs_params)\n155         return 'JSON_CONTAINS(%s, %s)' % (rhs, lhs), params\n156 \n157 \n158 class HasKeyLookup(PostgresOperatorLookup):\n159     logical_operator = None\n160 \n161     def as_sql(self, compiler, connection, template=None):\n162         # Process JSON path from the left-hand side.\n163         if isinstance(self.lhs, KeyTransform):\n164             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n165             lhs_json_path = compile_json_path(lhs_key_transforms)\n166         else:\n167             lhs, lhs_params = self.process_lhs(compiler, connection)\n168             lhs_json_path = '$'\n169         sql = template % lhs\n170         # Process JSON path from the right-hand side.\n171         rhs = self.rhs\n172         rhs_params = []\n173         if not isinstance(rhs, (list, tuple)):\n174             rhs = [rhs]\n175         for key in rhs:\n176             if isinstance(key, KeyTransform):\n177                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n178             else:\n179                 rhs_key_transforms = [key]\n180             rhs_params.append('%s%s' % (\n181                 lhs_json_path,\n182                 compile_json_path(rhs_key_transforms, include_root=False),\n183             ))\n184         # Add condition for each key.\n185         if self.logical_operator:\n186             sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))\n187         return sql, tuple(lhs_params) + tuple(rhs_params)\n188 \n189     def as_mysql(self, compiler, connection):\n190         return self.as_sql(compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\")\n191 \n192     def as_oracle(self, compiler, connection):\n193         sql, params = self.as_sql(compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\")\n194         # Add paths directly into SQL because path expressions cannot be passed\n195         # as bind variables on Oracle.\n196         return sql % tuple(params), []\n197 \n198     def as_postgresql(self, compiler, connection):\n199         if isinstance(self.rhs, KeyTransform):\n200             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n201             for key in rhs_key_transforms[:-1]:\n202                 self.lhs = KeyTransform(key, self.lhs)\n203             self.rhs = rhs_key_transforms[-1]\n204         return super().as_postgresql(compiler, connection)\n205 \n206     def as_sqlite(self, compiler, connection):\n207         return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')\n208 \n209 \n210 class HasKey(HasKeyLookup):\n211     lookup_name = 'has_key'\n212     postgres_operator = '?'\n213     prepare_rhs = False\n214 \n215 \n216 class HasKeys(HasKeyLookup):\n217     lookup_name = 'has_keys'\n218     postgres_operator = '?&'\n219     logical_operator = ' AND '\n220 \n221     def get_prep_lookup(self):\n222         return [str(item) for item in self.rhs]\n223 \n224 \n225 class HasAnyKeys(HasKeys):\n226     lookup_name = 'has_any_keys'\n227     postgres_operator = '?|'\n228     logical_operator = ' OR '\n229 \n230 \n231 class JSONExact(lookups.Exact):\n232     can_use_none_as_rhs = True\n233 \n234     def process_lhs(self, compiler, connection):\n235         lhs, lhs_params = super().process_lhs(compiler, connection)\n236         if connection.vendor == 'sqlite':\n237             rhs, rhs_params = super().process_rhs(compiler, connection)\n238             if rhs == '%s' and rhs_params == [None]:\n239                 # Use JSON_TYPE instead of JSON_EXTRACT for NULLs.\n240                 lhs = \"JSON_TYPE(%s, '$')\" % lhs\n241         return lhs, lhs_params\n242 \n243     def process_rhs(self, compiler, connection):\n244         rhs, rhs_params = super().process_rhs(compiler, connection)\n245         # Treat None lookup values as null.\n246         if rhs == '%s' and rhs_params == [None]:\n247             rhs_params = ['null']\n248         if connection.vendor == 'mysql':\n249             func = [\"JSON_EXTRACT(%s, '$')\"] * len(rhs_params)\n250             rhs = rhs % tuple(func)\n251         return rhs, rhs_params\n252 \n253 \n254 JSONField.register_lookup(DataContains)\n255 JSONField.register_lookup(ContainedBy)\n256 JSONField.register_lookup(HasKey)\n257 JSONField.register_lookup(HasKeys)\n258 JSONField.register_lookup(HasAnyKeys)\n259 JSONField.register_lookup(JSONExact)\n260 \n261 \n262 class KeyTransform(Transform):\n263     postgres_operator = '->'\n264     postgres_nested_operator = '#>'\n265 \n266     def __init__(self, key_name, *args, **kwargs):\n267         super().__init__(*args, **kwargs)\n268         self.key_name = str(key_name)\n269 \n270     def preprocess_lhs(self, compiler, connection, lhs_only=False):\n271         if not lhs_only:\n272             key_transforms = [self.key_name]\n273         previous = self.lhs\n274         while isinstance(previous, KeyTransform):\n275             if not lhs_only:\n276                 key_transforms.insert(0, previous.key_name)\n277             previous = previous.lhs\n278         lhs, params = compiler.compile(previous)\n279         if connection.vendor == 'oracle':\n280             # Escape string-formatting.\n281             key_transforms = [key.replace('%', '%%') for key in key_transforms]\n282         return (lhs, params, key_transforms) if not lhs_only else (lhs, params)\n283 \n284     def as_mysql(self, compiler, connection):\n285         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n286         json_path = compile_json_path(key_transforms)\n287         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n288 \n289     def as_oracle(self, compiler, connection):\n290         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n291         json_path = compile_json_path(key_transforms)\n292         return (\n293             \"COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))\" %\n294             ((lhs, json_path) * 2)\n295         ), tuple(params) * 2\n296 \n297     def as_postgresql(self, compiler, connection):\n298         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n299         if len(key_transforms) > 1:\n300             return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]\n301         try:\n302             lookup = int(self.key_name)\n303         except ValueError:\n304             lookup = self.key_name\n305         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)\n306 \n307     def as_sqlite(self, compiler, connection):\n308         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n309         json_path = compile_json_path(key_transforms)\n310         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n311 \n312 \n313 class KeyTextTransform(KeyTransform):\n314     postgres_operator = '->>'\n315     postgres_nested_operator = '#>>'\n316 \n317 \n318 class KeyTransformTextLookupMixin:\n319     \"\"\"\n320     Mixin for combining with a lookup expecting a text lhs from a JSONField\n321     key lookup. On PostgreSQL, make use of the ->> operator instead of casting\n322     key values to text and performing the lookup on the resulting\n323     representation.\n324     \"\"\"\n325     def __init__(self, key_transform, *args, **kwargs):\n326         if not isinstance(key_transform, KeyTransform):\n327             raise TypeError(\n328                 'Transform should be an instance of KeyTransform in order to '\n329                 'use this lookup.'\n330             )\n331         key_text_transform = KeyTextTransform(\n332             key_transform.key_name, *key_transform.source_expressions,\n333             **key_transform.extra,\n334         )\n335         super().__init__(key_text_transform, *args, **kwargs)\n336 \n337 \n338 class CaseInsensitiveMixin:\n339     \"\"\"\n340     Mixin to allow case-insensitive comparison of JSON values on MySQL.\n341     MySQL handles strings used in JSON context using the utf8mb4_bin collation.\n342     Because utf8mb4_bin is a binary collation, comparison of JSON values is\n343     case-sensitive.\n344     \"\"\"\n345     def process_lhs(self, compiler, connection):\n346         lhs, lhs_params = super().process_lhs(compiler, connection)\n347         if connection.vendor == 'mysql':\n348             return 'LOWER(%s)' % lhs, lhs_params\n349         return lhs, lhs_params\n350 \n351     def process_rhs(self, compiler, connection):\n352         rhs, rhs_params = super().process_rhs(compiler, connection)\n353         if connection.vendor == 'mysql':\n354             return 'LOWER(%s)' % rhs, rhs_params\n355         return rhs, rhs_params\n356 \n357 \n358 class KeyTransformIsNull(lookups.IsNull):\n359     # key__isnull=False is the same as has_key='key'\n360     def as_oracle(self, compiler, connection):\n361         if not self.rhs:\n362             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n363         return super().as_sql(compiler, connection)\n364 \n365     def as_sqlite(self, compiler, connection):\n366         if not self.rhs:\n367             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n368         return super().as_sql(compiler, connection)\n369 \n370 \n371 class KeyTransformIn(lookups.In):\n372     def process_rhs(self, compiler, connection):\n373         rhs, rhs_params = super().process_rhs(compiler, connection)\n374         if not connection.features.has_native_json_field:\n375             func = ()\n376             if connection.vendor == 'oracle':\n377                 func = []\n378                 for value in rhs_params:\n379                     value = json.loads(value)\n380                     function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\n381                     func.append(\"%s('%s', '$.value')\" % (\n382                         function,\n383                         json.dumps({'value': value}),\n384                     ))\n385                 func = tuple(func)\n386                 rhs_params = ()\n387             elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:\n388                 func = (\"JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))\",) * len(rhs_params)\n389             elif connection.vendor in {'sqlite', 'mysql'}:\n390                 func = (\"JSON_EXTRACT(%s, '$')\",) * len(rhs_params)\n391             rhs = rhs % func\n392         return rhs, rhs_params\n393 \n394 \n395 class KeyTransformExact(JSONExact):\n396     def process_lhs(self, compiler, connection):\n397         lhs, lhs_params = super().process_lhs(compiler, connection)\n398         if connection.vendor == 'sqlite':\n399             rhs, rhs_params = super().process_rhs(compiler, connection)\n400             if rhs == '%s' and rhs_params == ['null']:\n401                 lhs, _ = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)\n402                 lhs = 'JSON_TYPE(%s, %%s)' % lhs\n403         return lhs, lhs_params\n404 \n405     def process_rhs(self, compiler, connection):\n406         if isinstance(self.rhs, KeyTransform):\n407             return super(lookups.Exact, self).process_rhs(compiler, connection)\n408         rhs, rhs_params = super().process_rhs(compiler, connection)\n409         if connection.vendor == 'oracle':\n410             func = []\n411             for value in rhs_params:\n412                 value = json.loads(value)\n413                 function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\n414                 func.append(\"%s('%s', '$.value')\" % (\n415                     function,\n416                     json.dumps({'value': value}),\n417                 ))\n418             rhs = rhs % tuple(func)\n419             rhs_params = []\n420         elif connection.vendor == 'sqlite':\n421             func = [\"JSON_EXTRACT(%s, '$')\" if value != 'null' else '%s' for value in rhs_params]\n422             rhs = rhs % tuple(func)\n423         return rhs, rhs_params\n424 \n425     def as_oracle(self, compiler, connection):\n426         rhs, rhs_params = super().process_rhs(compiler, connection)\n427         if rhs_params == ['null']:\n428             # Field has key and it's NULL.\n429             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)\n430             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)\n431             is_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)\n432             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)\n433             return (\n434                 '%s AND %s' % (has_key_sql, is_null_sql),\n435                 tuple(has_key_params) + tuple(is_null_params),\n436             )\n437         return super().as_sql(compiler, connection)\n438 \n439 \n440 class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n441     pass\n442 \n443 \n444 class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n445     pass\n446 \n447 \n448 class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n449     pass\n450 \n451 \n452 class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n453     pass\n454 \n455 \n456 class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n457     pass\n458 \n459 \n460 class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n461     pass\n462 \n463 \n464 class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n465     pass\n466 \n467 \n468 class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n469     pass\n470 \n471 \n472 class KeyTransformNumericLookupMixin:\n473     def process_rhs(self, compiler, connection):\n474         rhs, rhs_params = super().process_rhs(compiler, connection)\n475         if not connection.features.has_native_json_field:\n476             rhs_params = [json.loads(value) for value in rhs_params]\n477         return rhs, rhs_params\n478 \n479 \n480 class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):\n481     pass\n482 \n483 \n484 class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):\n485     pass\n486 \n487 \n488 class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):\n489     pass\n490 \n491 \n492 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):\n493     pass\n494 \n495 \n496 KeyTransform.register_lookup(KeyTransformIn)\n497 KeyTransform.register_lookup(KeyTransformExact)\n498 KeyTransform.register_lookup(KeyTransformIExact)\n499 KeyTransform.register_lookup(KeyTransformIsNull)\n500 KeyTransform.register_lookup(KeyTransformIContains)\n501 KeyTransform.register_lookup(KeyTransformStartsWith)\n502 KeyTransform.register_lookup(KeyTransformIStartsWith)\n503 KeyTransform.register_lookup(KeyTransformEndsWith)\n504 KeyTransform.register_lookup(KeyTransformIEndsWith)\n505 KeyTransform.register_lookup(KeyTransformRegex)\n506 KeyTransform.register_lookup(KeyTransformIRegex)\n507 \n508 KeyTransform.register_lookup(KeyTransformLt)\n509 KeyTransform.register_lookup(KeyTransformLte)\n510 KeyTransform.register_lookup(KeyTransformGt)\n511 KeyTransform.register_lookup(KeyTransformGte)\n512 \n513 \n514 class KeyTransformFactory:\n515 \n516     def __init__(self, key_name):\n517         self.key_name = key_name\n518 \n519     def __call__(self, *args, **kwargs):\n520         return KeyTransform(self.key_name, *args, **kwargs)\n",
        "intended_behavior": "Investigate and ensure that the serialization mechanism to and from the database is Unicode-friendly and that any transformations performed before rendering in the admin interface preserve Unicode characters. Ensure compatibility across different database backends."
    }
]