[
    {
        "rel_file_path": "sympy/ntheory/partitions_.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/ntheory/partitions_.py",
        "start": 1,
        "end": 193,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 from mpmath.libmp import (fzero, from_int, from_rational,\n3     fone, fhalf, bitcount, to_int, to_str, mpf_mul, mpf_div, mpf_sub,\n4     mpf_add, mpf_sqrt, mpf_pi, mpf_cosh_sinh, mpf_cos, mpf_sin)\n5 from sympy.core.numbers import igcd\n6 from .residue_ntheory import (_sqrt_mod_prime_power,\n7     legendre_symbol, jacobi_symbol, is_quad_residue)\n8 \n9 import math\n10 \n11 def _pre():\n12     maxn = 10**5\n13     global _factor\n14     global _totient\n15     _factor = [0]*maxn\n16     _totient = [1]*maxn\n17     lim = int(maxn**0.5) + 5\n18     for i in range(2, lim):\n19         if _factor[i] == 0:\n20             for j in range(i*i, maxn, i):\n21                 if _factor[j] == 0:\n22                     _factor[j] = i\n23     for i in range(2, maxn):\n24         if _factor[i] == 0:\n25             _factor[i] = i\n26             _totient[i] = i-1\n27             continue\n28         x = _factor[i]\n29         y = i//x\n30         if y % x == 0:\n31             _totient[i] = _totient[y]*x\n32         else:\n33             _totient[i] = _totient[y]*(x - 1)\n34 \n35 def _a(n, k, prec):\n36     \"\"\" Compute the inner sum in HRR formula [1]_\n37 \n38     References\n39     ==========\n40 \n41     .. [1] http://msp.org/pjm/1956/6-1/pjm-v6-n1-p18-p.pdf\n42 \n43     \"\"\"\n44     if k == 1:\n45         return fone\n46 \n47     k1 = k\n48     e = 0\n49     p = _factor[k]\n50     while k1 % p == 0:\n51         k1 //= p\n52         e += 1\n53     k2 = k//k1 # k2 = p^e\n54     v = 1 - 24*n\n55     pi = mpf_pi(prec)\n56 \n57     if k1 == 1:\n58         # k  = p^e\n59         if p == 2:\n60             mod = 8*k\n61             v = mod + v % mod\n62             v = (v*pow(9, k - 1, mod)) % mod\n63             m = _sqrt_mod_prime_power(v, 2, e + 3)[0]\n64             arg = mpf_div(mpf_mul(\n65                 from_int(4*m), pi, prec), from_int(mod), prec)\n66             return mpf_mul(mpf_mul(\n67                 from_int((-1)**e*jacobi_symbol(m - 1, m)),\n68                 mpf_sqrt(from_int(k), prec), prec),\n69                 mpf_sin(arg, prec), prec)\n70         if p == 3:\n71             mod = 3*k\n72             v = mod + v % mod\n73             if e > 1:\n74                 v = (v*pow(64, k//3 - 1, mod)) % mod\n75             m = _sqrt_mod_prime_power(v, 3, e + 1)[0]\n76             arg = mpf_div(mpf_mul(from_int(4*m), pi, prec),\n77                 from_int(mod), prec)\n78             return mpf_mul(mpf_mul(\n79                 from_int(2*(-1)**(e + 1)*legendre_symbol(m, 3)),\n80                 mpf_sqrt(from_int(k//3), prec), prec),\n81                 mpf_sin(arg, prec), prec)\n82         v = k + v % k\n83         if v % p == 0:\n84             if e == 1:\n85                 return mpf_mul(\n86                     from_int(jacobi_symbol(3, k)),\n87                     mpf_sqrt(from_int(k), prec), prec)\n88             return fzero\n89         if not is_quad_residue(v, p):\n90             return fzero\n91         _phi = p**(e - 1)*(p - 1)\n92         v = (v*pow(576, _phi - 1, k))\n93         m = _sqrt_mod_prime_power(v, p, e)[0]\n94         arg = mpf_div(\n95             mpf_mul(from_int(4*m), pi, prec),\n96             from_int(k), prec)\n97         return mpf_mul(mpf_mul(\n98             from_int(2*jacobi_symbol(3, k)),\n99             mpf_sqrt(from_int(k), prec), prec),\n100             mpf_cos(arg, prec), prec)\n101 \n102     if p != 2 or e >= 3:\n103         d1, d2 = igcd(k1, 24), igcd(k2, 24)\n104         e = 24//(d1*d2)\n105         n1 = ((d2*e*n + (k2**2 - 1)//d1)*\n106             pow(e*k2*k2*d2, _totient[k1] - 1, k1)) % k1\n107         n2 = ((d1*e*n + (k1**2 - 1)//d2)*\n108             pow(e*k1*k1*d1, _totient[k2] - 1, k2)) % k2\n109         return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n110     if e == 2:\n111         n1 = ((8*n + 5)*pow(128, _totient[k1] - 1, k1)) % k1\n112         n2 = (4 + ((n - 2 - (k1**2 - 1)//8)*(k1**2)) % 4) % 4\n113         return mpf_mul(mpf_mul(\n114             from_int(-1),\n115             _a(n1, k1, prec), prec),\n116             _a(n2, k2, prec))\n117     n1 = ((8*n + 1)*pow(32, _totient[k1] - 1, k1)) % k1\n118     n2 = (2 + (n - (k1**2 - 1)//8) % 2) % 2\n119     return mpf_mul(_a(n1, k1, prec), _a(n2, k2, prec), prec)\n120 \n121 def _d(n, j, prec, sq23pi, sqrt8):\n122     \"\"\"\n123     Compute the sinh term in the outer sum of the HRR formula.\n124     The constants sqrt(2/3*pi) and sqrt(8) must be precomputed.\n125     \"\"\"\n126     j = from_int(j)\n127     pi = mpf_pi(prec)\n128     a = mpf_div(sq23pi, j, prec)\n129     b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec)\n130     c = mpf_sqrt(b, prec)\n131     ch, sh = mpf_cosh_sinh(mpf_mul(a, c), prec)\n132     D = mpf_div(\n133         mpf_sqrt(j, prec),\n134         mpf_mul(mpf_mul(sqrt8, b), pi), prec)\n135     E = mpf_sub(mpf_mul(a, ch), mpf_div(sh, c, prec), prec)\n136     return mpf_mul(D, E)\n137 \n138 \n139 def npartitions(n, verbose=False):\n140     \"\"\"\n141     Calculate the partition function P(n), i.e. the number of ways that\n142     n can be written as a sum of positive integers.\n143 \n144     P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\n145 \n146 \n147     The correctness of this implementation has been tested through 10**10.\n148 \n149     Examples\n150     ========\n151 \n152     >>> from sympy.ntheory import npartitions\n153     >>> npartitions(25)\n154     1958\n155 \n156     References\n157     ==========\n158 \n159     .. [1] http://mathworld.wolfram.com/PartitionFunctionP.html\n160 \n161     \"\"\"\n162     n = int(n)\n163     if n < 0:\n164         return 0\n165     if n <= 5:\n166         return [1, 1, 2, 3, 5, 7][n]\n167     if '_factor' not in globals():\n168         _pre()\n169     # Estimate number of bits in p(n). This formula could be tidied\n170     pbits = int((\n171         math.pi*(2*n/3.)**0.5 -\n172         math.log(4*n))/math.log(10) + 1) * \\\n173         math.log(10, 2)\n174     prec = p = int(pbits*1.1 + 100)\n175     s = fzero\n176     M = max(6, int(0.24*n**0.5 + 4))\n177     if M > 10**5:\n178         raise ValueError(\"Input too big\") # Corresponds to n > 1.7e11\n179     sq23pi = mpf_mul(mpf_sqrt(from_rational(2, 3, p), p), mpf_pi(p), p)\n180     sqrt8 = mpf_sqrt(from_int(8), p)\n181     for q in range(1, M):\n182         a = _a(n, q, p)\n183         d = _d(n, q, p, sq23pi, sqrt8)\n184         s = mpf_add(s, mpf_mul(a, d), prec)\n185         if verbose:\n186             print(\"step\", q, \"of\", M, to_str(a, 10), to_str(d, 10))\n187         # On average, the terms decrease rapidly in magnitude.\n188         # Dynamically reducing the precision greatly improves\n189         # performance.\n190         p = bitcount(abs(to_int(d))) + 50\n191     return int(to_int(mpf_add(s, fhalf, prec)))\n192 \n193 __all__ = ['npartitions']\n",
        "intended_behavior": "This file should include a new class or method specifically designed for calculating Schur Numbers, leveraging existing partition utilities. The new functionality should accurately partition any given positive integer range into k sum-free sets, following the mathematical definitions of Schur numbers. This should be done in a manner that preserves the integrity and functionality of existing partitioning methods."
    },
    {
        "rel_file_path": "sympy/ntheory/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/ntheory/__init__.py",
        "start": 1,
        "end": 56,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Number theory module (primes, etc)\n3 \"\"\"\n4 \n5 from .generate import nextprime, prevprime, prime, primepi, primerange, \\\n6     randprime, Sieve, sieve, primorial, cycle_length, composite, compositepi\n7 from .primetest import isprime\n8 from .factor_ import divisors, proper_divisors, factorint, multiplicity, \\\n9     perfect_power, pollard_pm1, pollard_rho, primefactors, totient, trailing, \\\n10     divisor_count, proper_divisor_count, divisor_sigma, factorrat, \\\n11     reduced_totient, primenu, primeomega, mersenne_prime_exponent, \\\n12     is_perfect, is_mersenne_prime, is_abundant, is_deficient, is_amicable, \\\n13     abundance, dra, drm\n14 \n15 from .partitions_ import npartitions\n16 from .residue_ntheory import is_primitive_root, is_quad_residue, \\\n17     legendre_symbol, jacobi_symbol, n_order, sqrt_mod, quadratic_residues, \\\n18     primitive_root, nthroot_mod, is_nthpow_residue, sqrt_mod_iter, mobius, \\\n19     discrete_log, quadratic_congruence, polynomial_congruence\n20 from .multinomial import binomial_coefficients, binomial_coefficients_list, \\\n21     multinomial_coefficients\n22 from .continued_fraction import continued_fraction_periodic, \\\n23     continued_fraction_iterator, continued_fraction_reduce, \\\n24     continued_fraction_convergents, continued_fraction\n25 from .egyptian_fraction import egyptian_fraction\n26 \n27 __all__ = [\n28     'nextprime', 'prevprime', 'prime', 'primepi', 'primerange', 'randprime',\n29     'Sieve', 'sieve', 'primorial', 'cycle_length', 'composite', 'compositepi',\n30 \n31     'isprime',\n32 \n33 \n34     'divisors', 'proper_divisors', 'factorint', 'multiplicity', 'perfect_power',\n35     'pollard_pm1', 'pollard_rho', 'primefactors', 'totient', 'trailing',\n36     'divisor_count', 'proper_divisor_count', 'divisor_sigma', 'factorrat',\n37     'reduced_totient', 'primenu', 'primeomega', 'mersenne_prime_exponent',\n38     'is_perfect', 'is_mersenne_prime', 'is_abundant', 'is_deficient', 'is_amicable',\n39     'abundance', 'dra', 'drm',\n40 \n41     'npartitions',\n42 \n43     'is_primitive_root', 'is_quad_residue', 'legendre_symbol',\n44     'jacobi_symbol', 'n_order', 'sqrt_mod', 'quadratic_residues',\n45     'primitive_root', 'nthroot_mod', 'is_nthpow_residue', 'sqrt_mod_iter',\n46     'mobius', 'discrete_log', 'quadratic_congruence', 'polynomial_congruence',\n47 \n48     'binomial_coefficients', 'binomial_coefficients_list',\n49     'multinomial_coefficients',\n50 \n51     'continued_fraction_periodic', 'continued_fraction_iterator',\n52     'continued_fraction_reduce', 'continued_fraction_convergents',\n53     'continued_fraction',\n54 \n55     'egyptian_fraction',\n56 ]\n",
        "intended_behavior": "To be updated to import and expose the new Schur Number functionality as part of the number theory module's public API. This ensures that users of SymPy can easily access the Schur Number calculations alongside other number theory tools."
    }
]