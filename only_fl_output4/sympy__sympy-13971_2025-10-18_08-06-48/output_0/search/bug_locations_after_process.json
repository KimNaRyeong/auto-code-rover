[
    {
        "rel_file_path": "sympy/series/sequences.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/series/sequences.py",
        "start": 602,
        "end": 711,
        "class_name": "SeqFormula",
        "method_name": null,
        "code": "602 class SeqFormula(SeqExpr):\n603     \"\"\"Represents sequence based on a formula.\n604 \n605     Elements are generated using a formula.\n606 \n607     Examples\n608     ========\n609 \n610     >>> from sympy import SeqFormula, oo, Symbol\n611     >>> n = Symbol('n')\n612     >>> s = SeqFormula(n**2, (n, 0, 5))\n613     >>> s.formula\n614     n**2\n615 \n616     For value at a particular point\n617 \n618     >>> s.coeff(3)\n619     9\n620 \n621     supports slicing\n622 \n623     >>> s[:]\n624     [0, 1, 4, 9, 16, 25]\n625 \n626     iterable\n627 \n628     >>> list(s)\n629     [0, 1, 4, 9, 16, 25]\n630 \n631     sequence starts from negative infinity\n632 \n633     >>> SeqFormula(n**2, (-oo, 0))[0:6]\n634     [0, 1, 4, 9, 16, 25]\n635 \n636     See Also\n637     ========\n638 \n639     sympy.series.sequences.SeqPer\n640     \"\"\"\n641 \n642     def __new__(cls, formula, limits=None):\n643         formula = sympify(formula)\n644 \n645         def _find_x(formula):\n646             free = formula.free_symbols\n647             if len(formula.free_symbols) == 1:\n648                 return free.pop()\n649             elif len(formula.free_symbols) == 0:\n650                 return Dummy('k')\n651             else:\n652                 raise ValueError(\n653                     \" specify dummy variables for %s. If the formula contains\"\n654                     \" more than one free symbol, a dummy variable should be\"\n655                     \" supplied explicitly e.g., SeqFormula(m*n**2, (n, 0, 5))\"\n656                     % formula)\n657 \n658         x, start, stop = None, None, None\n659         if limits is None:\n660             x, start, stop = _find_x(formula), 0, S.Infinity\n661         if is_sequence(limits, Tuple):\n662             if len(limits) == 3:\n663                 x, start, stop = limits\n664             elif len(limits) == 2:\n665                 x = _find_x(formula)\n666                 start, stop = limits\n667 \n668         if not isinstance(x, (Symbol, Idx)) or start is None or stop is None:\n669             raise ValueError('Invalid limits given: %s' % str(limits))\n670 \n671         if start is S.NegativeInfinity and stop is S.Infinity:\n672                 raise ValueError(\"Both the start and end value\"\n673                                  \"cannot be unbounded\")\n674         limits = sympify((x, start, stop))\n675 \n676         if Interval(limits[1], limits[2]) is S.EmptySet:\n677             return S.EmptySequence\n678 \n679         return Basic.__new__(cls, formula, limits)\n680 \n681     @property\n682     def formula(self):\n683         return self.gen\n684 \n685     def _eval_coeff(self, pt):\n686         d = self.variables[0]\n687         return self.formula.subs(d, pt)\n688 \n689     def _add(self, other):\n690         \"\"\"See docstring of SeqBase._add\"\"\"\n691         if isinstance(other, SeqFormula):\n692             form1, v1 = self.formula, self.variables[0]\n693             form2, v2 = other.formula, other.variables[0]\n694             formula = form1 + form2.subs(v2, v1)\n695             start, stop = self._intersect_interval(other)\n696             return SeqFormula(formula, (v1, start, stop))\n697 \n698     def _mul(self, other):\n699         \"\"\"See docstring of SeqBase._mul\"\"\"\n700         if isinstance(other, SeqFormula):\n701             form1, v1 = self.formula, self.variables[0]\n702             form2, v2 = other.formula, other.variables[0]\n703             formula = form1 * form2.subs(v2, v1)\n704             start, stop = self._intersect_interval(other)\n705             return SeqFormula(formula, (v1, start, stop))\n706 \n707     def coeff_mul(self, coeff):\n708         \"\"\"See docstring of SeqBase.coeff_mul\"\"\"\n709         coeff = sympify(coeff)\n710         formula = self.formula * coeff\n711         return SeqFormula(formula, self.args[1])\n",
        "intended_behavior": "This code should correctly render SeqFormula objects to LaTeX, ensuring that square brackets are not escaped, for accurate display in Jupyter notebooks."
    },
    {
        "rel_file_path": "sympy/series/sequences.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/series/sequences.py",
        "start": 408,
        "end": 455,
        "class_name": "SeqExpr",
        "method_name": null,
        "code": "408 class SeqExpr(SeqBase):\n409     \"\"\"Sequence expression class.\n410 \n411     Various sequences should inherit from this class.\n412 \n413     Examples\n414     ========\n415 \n416     >>> from sympy.series.sequences import SeqExpr\n417     >>> from sympy.abc import x\n418     >>> s = SeqExpr((1, 2, 3), (x, 0, 10))\n419     >>> s.gen\n420     (1, 2, 3)\n421     >>> s.interval\n422     Interval(0, 10)\n423     >>> s.length\n424     11\n425 \n426     See Also\n427     ========\n428 \n429     sympy.series.sequences.SeqPer\n430     sympy.series.sequences.SeqFormula\n431     \"\"\"\n432 \n433     @property\n434     def gen(self):\n435         return self.args[0]\n436 \n437     @property\n438     def interval(self):\n439         return Interval(self.args[1][1], self.args[1][2])\n440 \n441     @property\n442     def start(self):\n443         return self.interval.inf\n444 \n445     @property\n446     def stop(self):\n447         return self.interval.sup\n448 \n449     @property\n450     def length(self):\n451         return self.stop - self.start + 1\n452 \n453     @property\n454     def variables(self):\n455         return (self.args[1][0],)\n",
        "intended_behavior": "Understand how SeqExpr influences LaTeX rendering of Sympy objects, particularly for sequences in Jupyter notebooks, ensuring square brackets are correctly handled."
    }
]