2025-10-18 04:25:30.525 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 04:25:34.339 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=288, output_tokens=12, cost=0.003240
2025-10-18 04:25:48.342 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=468, output_tokens=631, cost=0.023610
2025-10-18 04:25:49.364 | INFO     | registered non reproducing test 0
2025-10-18 04:26:03.503 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1715, output_tokens=648, cost=0.036590
2025-10-18 04:26:18.366 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1715, output_tokens=738, cost=0.039290
2025-10-18 04:26:19.351 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:26:24.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=595, output_tokens=157, cost=0.010660
2025-10-18 04:26:24.111 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:26:26.679 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=511, output_tokens=49, cost=0.006580
2025-10-18 04:26:26.680 | DEBUG    | Extracted a valid json.
2025-10-18 04:26:26.680 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"check_unused_imports\")",
        "search_code(\"type: abc.ABC\")",
        "search_code(\"type: ABC\")"
    ],
    "bug_locations": []
}
2025-10-18 04:26:26.700 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:26:26.701 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:26:35.298 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=935, output_tokens=344, cost=0.019670
2025-10-18 04:26:35.308 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:26:47.179 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1495, output_tokens=537, cost=0.031060
2025-10-18 04:26:47.188 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:26:52.911 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=891, output_tokens=195, cost=0.014760
2025-10-18 04:26:52.912 | DEBUG    | Extracted a valid json.
2025-10-18 04:26:52.912 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "File that handles import analysis",
            "class": "",
            "method": "",
            "intended_behavior": "Enhance the method(s) to recognize when an imported module is referenced in a type comment, parsing comments for type hints and considering such imports as utilized."
        },
        {
            "file": "",
            "class": "",
            "method": "responsible for parsing type comments",
            "intended_behavior": "The parsing mechanism should correctly identify types mentioned in comments and match them with import statements, marking matched imports as used."
        },
        {
            "file": "",
            "class": "",
            "method": "logic responsible for generating warnings for unused imports",
            "intended_behavior": "Update the logic to check for imports utilized within type comments and ensure they are not flagged as unused by integrating with comment processing."
        }
    ]
}
2025-10-18 04:26:52.916 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 04:26:52.917 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 04:26:52.917 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:27:00.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2066, output_tokens=319, cost=0.030230
2025-10-18 04:27:00.248 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:27:02.915 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=673, output_tokens=54, cost=0.008350
2025-10-18 04:27:02.916 | DEBUG    | Extracted a valid json.
2025-10-18 04:27:02.916 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"process_module\")",
        "search_method(\"visit_Assign\")",
        "search_method(\"parse_type_comment\")",
        "search_code(\"astroid\")"
    ],
    "bug_locations": []
}
2025-10-18 04:27:03.333 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:27:03.334 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:27:18.891 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3580, output_tokens=666, cost=0.055780
2025-10-18 04:27:18.897 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:27:28.046 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4462, output_tokens=400, cost=0.056620
2025-10-18 04:27:28.052 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:27:35.843 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=754, output_tokens=245, cost=0.014890
2025-10-18 04:27:35.844 | DEBUG    | Extracted a valid json.
2025-10-18 04:27:35.844 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/checkers/imports.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely contains logic for detecting unused imports. A modification or enhancement should be made here to include logic that recognizes and validates imports used in type comments. The checker should parse comments for variables, class attributes, and function annotations, identify type hints within these comments, and cross-reference these types with imported modules or objects. Such an enhancement would address the issue by not flagging imports as unused if they are referenced in type comments."
        },
        {
            "file": "pylint/utils/ast_walker.py",
            "class": "ASTWalker",
            "method": "",
            "intended_behavior": "Adjustments to ensure type comments are adequately considered during the visitation of nodes related to import statements. The intended behavior would include enhancements to traverse and analyze comments adjacent to or within node structures that can have associated type hints (e.g., variable annotations, function signatures). This would ensure that the AST traversal logic supports identifying use cases of imported types within comments."
        }
    ]
}
2025-10-18 04:27:35.856 | DEBUG    | Bug location extracted successfully: [<file>pylint/checkers/imports.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006-2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2012-2014 Google, Inc.
3 # Copyright (c) 2013 buck@yelp.com <buck@yelp.com>
4 # Copyright (c) 2014-2020 Claudiu Popa <pcmanticore@gmail.com>
5 # Copyright (c) 2014 Brett Cannon <brett@python.org>
6 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
7 # Copyright (c) 2015-2016 Moises Lopez <moylop260@vauxoo.com>
8 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
9 # Copyright (c) 2015 Cezar <celnazli@bitdefender.com>
10 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
11 # Copyright (c) 2015 Noam Yorav-Raphael <noamraph@gmail.com>
12 # Copyright (c) 2015 James Morgensen <james.morgensen@gmail.com>
13 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
14 # Copyright (c) 2016 Jared Garst <cultofjared@gmail.com>
15 # Copyright (c) 2016 Maik Röder <maikroeder@gmail.com>
16 # Copyright (c) 2016 Glenn Matthews <glenn@e-dad.net>
17 # Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>
18 # Copyright (c) 2017, 2020 hippo91 <guillaume.peillex@gmail.com>
19 # Copyright (c) 2017 Michka Popoff <michkapopoff@gmail.com>
20 # Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
21 # Copyright (c) 2017 Erik Wright <erik.wright@shopify.com>
22 # Copyright (c) 2018 Lucas Cimon <lucas.cimon@gmail.com>
23 # Copyright (c) 2018 Hornwitser <github@hornwitser.no>
24 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
25 # Copyright (c) 2018 Natalie Serebryakova <natalie.serebryakova@Natalies-MacBook-Pro.local>
26 # Copyright (c) 2018 Mike Frysinger <vapier@gmail.com>
27 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>
28 # Copyright (c) 2018 Marianna Polatoglou <mpolatoglou@bloomberg.net>
29 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
30 # Copyright (c) 2019 Nick Drozd <nicholasdrozd@gmail.com>
31 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>
32 # Copyright (c) 2019 Nick Smith <clickthisnick@users.noreply.github.com>
33 # Copyright (c) 2019 Paul Renvoisé <renvoisepaul@gmail.com>
34 # Copyright (c) 2020 Peter Kolbus <peter.kolbus@gmail.com>
35 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>
36 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>
37 # Copyright (c) 2021 yushao2 <36848472+yushao2@users.noreply.github.com>
38 # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>
39 # Copyright (c) 2021 Matus Valo <matusvalo@users.noreply.github.com>
40 # Copyright (c) 2021 Andrew Howe <howeaj@users.noreply.github.com>
41 
42 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
43 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
44 
45 """imports checkers for Python code"""
46 
47 import collections
48 import copy
49 import os
50 import sys
51 from distutils import sysconfig
52 from typing import Dict, List, Union
53 
54 import astroid
55 
56 from pylint.checkers import BaseChecker, DeprecatedMixin
57 from pylint.checkers.utils import (
58     check_messages,
59     is_from_fallback_block,
60     node_ignores_exception,
61 )
62 from pylint.exceptions import EmptyReportError
63 from pylint.graph import DotBackend, get_cycles
64 from pylint.interfaces import IAstroidChecker
65 from pylint.reporters.ureports.nodes import Paragraph, VerbatimText, VNode
66 from pylint.utils import IsortDriver, get_global_option
67 
68 
69 def _qualified_names(modname):
70     """Split the names of the given module into subparts
71 
72     For example,
73         _qualified_names('pylint.checkers.ImportsChecker')
74     returns
75         ['pylint', 'pylint.checkers', 'pylint.checkers.ImportsChecker']
76     """
77     names = modname.split(".")
78     return [".".join(names[0 : i + 1]) for i in range(len(names))]
79 
80 
81 def _get_import_name(importnode, modname):
82     """Get a prepared module name from the given import node
83 
84     In the case of relative imports, this will return the
85     absolute qualified module name, which might be useful
86     for debugging. Otherwise, the initial module name
87     is returned unchanged.
88     """
89     if isinstance(importnode, astroid.ImportFrom):
90         if importnode.level:
91             root = importnode.root()
92             if isinstance(root, astroid.Module):
93                 modname = root.relative_to_absolute_name(
94                     modname, level=importnode.level
95                 )
96     return modname
97 
98 
99 def _get_first_import(node, context, name, base, level, alias):
100     """return the node where [base.]<name> is imported or None if not found"""
101     fullname = f"{base}.{name}" if base else name
102 
103     first = None
104     found = False
105     for first in context.body:
106         if first is node:
107             continue
108         if first.scope() is node.scope() and first.fromlineno > node.fromlineno:
109             continue
110         if isinstance(first, astroid.Import):
111             if any(fullname == iname[0] for iname in first.names):
112                 found = True
113                 break
114         elif isinstance(first, astroid.ImportFrom):
115             if level == first.level:
116                 for imported_name, imported_alias in first.names:
117                     if fullname == f"{first.modname}.{imported_name}":
118                         found = True
119                         break
120                     if (
121                         name != "*"
122                         and name == imported_name
123                         and not (alias or imported_alias)
124                     ):
125                         found = True
126                         break
127                 if found:
128                     break
129     if found and not astroid.are_exclusive(first, node):
130         return first
131     return None
132 
133 
134 def _ignore_import_failure(node, modname, ignored_modules):
135     for submodule in _qualified_names(modname):
136         if submodule in ignored_modules:
137             return True
138 
139     # ignore import failure if guarded by `sys.version_info` test
140     if isinstance(node.parent, astroid.If) and isinstance(
141         node.parent.test, astroid.Compare
142     ):
143         value = node.parent.test.left
144         if isinstance(value, astroid.Subscript):
145             value = value.value
146         if (
147             isinstance(value, astroid.Attribute)
148             and value.as_string() == "sys.version_info"
149         ):
150             return True
151 
152     return node_ignores_exception(node, ImportError)
153 
154 
155 # utilities to represents import dependencies as tree and dot graph ###########
156 
157 
158 def _make_tree_defs(mod_files_list):
159     """get a list of 2-uple (module, list_of_files_which_import_this_module),
160     it will return a dictionary to represent this as a tree
161     """
162     tree_defs = {}
163     for mod, files in mod_files_list:
164         node = (tree_defs, ())
165         for prefix in mod.split("."):
166             node = node[0].setdefault(prefix, [{}, []])
167         node[1] += files
168     return tree_defs
169 
170 
171 def _repr_tree_defs(data, indent_str=None):
172     """return a string which represents imports as a tree"""
173     lines = []
174     nodes = data.items()
175     for i, (mod, (sub, files)) in enumerate(sorted(nodes, key=lambda x: x[0])):
176         if not files:
177             files = ""
178         else:
179             files = "(%s)" % ",".join(sorted(files))
180         if indent_str is None:
181             lines.append(f"{mod} {files}")
182             sub_indent_str = "  "
183         else:
184             lines.append(fr"{indent_str}\-{mod} {files}")
185             if i == len(nodes) - 1:
186                 sub_indent_str = "%s  " % indent_str
187             else:
188                 sub_indent_str = "%s| " % indent_str
189         if sub:
190             lines.append(_repr_tree_defs(sub, sub_indent_str))
191     return "\n".join(lines)
192 
193 
194 def _dependencies_graph(filename: str, dep_info: Dict[str, List[str]]) -> str:
195     """write dependencies as a dot (graphviz) file"""
196     done = {}
197     printer = DotBackend(os.path.splitext(os.path.basename(filename))[0], rankdir="LR")
198     printer.emit('URL="." node[shape="box"]')
199     for modname, dependencies in sorted(dep_info.items()):
200         done[modname] = 1
201         printer.emit_node(modname)
202         for depmodname in dependencies:
203             if depmodname not in done:
204                 done[depmodname] = 1
205                 printer.emit_node(depmodname)
206     for depmodname, dependencies in sorted(dep_info.items()):
207         for modname in dependencies:
208             printer.emit_edge(modname, depmodname)
209     return printer.generate(filename)
210 
211 
212 def _make_graph(filename: str, dep_info: Dict[str, List[str]], sect: VNode, gtype: str):
213     """generate a dependencies graph and add some information about it in the
214     report's section
215     """
216     outputfile = _dependencies_graph(filename, dep_info)
217     sect.append(Paragraph(f"{gtype}imports graph has been written to {outputfile}"))
218 
219 
220 # the import checker itself ###################################################
221 
222 MSGS = {
223     "E0401": (
224         "Unable to import %s",
225         "import-error",
226         "Used when pylint has been unable to import a module.",
227         {"old_names": [("F0401", "old-import-error")]},
228     ),
229     "E0402": (
230         "Attempted relative import beyond top-level package",
231         "relative-beyond-top-level",
232         "Used when a relative import tries to access too many levels "
233         "in the current package.",
234     ),
235     "R0401": (
236         "Cyclic import (%s)",
237         "cyclic-import",
238         "Used when a cyclic import between two or more modules is detected.",
239     ),
240     "R0402": (
241         "Use 'from %s import %s' instead",
242         "consider-using-from-import",
243         "Emitted when a submodule/member of a package is imported and "
244         "aliased with the same name. "
245         "E.g., instead of ``import pandas.DataFrame as DataFrame`` use "
246         "``from pandas import DataFrame``",
247     ),
248     "W0401": (
249         "Wildcard import %s",
250         "wildcard-import",
251         "Used when `from module import *` is detected.",
252     ),
253     "W0402": (
254         "Uses of a deprecated module %r",
255         "deprecated-module",
256         "Used a module marked as deprecated is imported.",
257     ),
258     "W0404": (
259         "Reimport %r (imported line %s)",
260         "reimported",
261         "Used when a module is reimported multiple times.",
262     ),
263     "W0406": (
264         "Module import itself",
265         "import-self",
266         "Used when a module is importing itself.",
267     ),
268     "W0407": (
269         "Prefer importing %r instead of %r",
270         "preferred-module",
271         "Used when a module imported has a preferred replacement module.",
272     ),
273     "W0410": (
274         "__future__ import is not the first non docstring statement",
275         "misplaced-future",
276         "Python 2.5 and greater require __future__ import to be the "
277         "first non docstring statement in the module.",
278     ),
279     "C0410": (
280         "Multiple imports on one line (%s)",
281         "multiple-imports",
282         "Used when import statement importing multiple modules is detected.",
283     ),
284     "C0411": (
285         "%s should be placed before %s",
286         "wrong-import-order",
287         "Used when PEP8 import order is not respected (standard imports "
288         "first, then third-party libraries, then local imports)",
289     ),
290     "C0412": (
291         "Imports from package %s are not grouped",
292         "ungrouped-imports",
293         "Used when imports are not grouped by packages",
294     ),
295     "C0413": (
296         'Import "%s" should be placed at the top of the module',
297         "wrong-import-position",
298         "Used when code and imports are mixed",
299     ),
300     "C0414": (
301         "Import alias does not rename original package",
302         "useless-import-alias",
303         "Used when an import alias is same as original package."
304         "e.g using import numpy as numpy instead of import numpy as np",
305     ),
306     "C0415": (
307         "Import outside toplevel (%s)",
308         "import-outside-toplevel",
309         "Used when an import statement is used anywhere other than the module "
310         "toplevel. Move this import to the top of the file.",
311     ),
312 }
313 
314 
315 DEFAULT_STANDARD_LIBRARY = ()
316 DEFAULT_KNOWN_THIRD_PARTY = ("enchant",)
317 DEFAULT_PREFERRED_MODULES = ()
318 
319 
320 class ImportsChecker(DeprecatedMixin, BaseChecker):
321     """checks for
322     * external modules dependencies
323     * relative / wildcard imports
324     * cyclic imports
325     * uses of deprecated modules
326     * uses of modules instead of preferred modules
327     """
328 
329     __implements__ = IAstroidChecker
330 
331     name = "imports"
332     msgs = MSGS
333     priority = -2
334     default_deprecated_modules = ()
335 
336     options = (
337         (
338             "deprecated-modules",
339             {
340                 "default": default_deprecated_modules,
341                 "type": "csv",
342                 "metavar": "<modules>",
343                 "help": "Deprecated modules which should not be used,"
344                 " separated by a comma.",
345             },
346         ),
347         (
348             "preferred-modules",
349             {
350                 "default": DEFAULT_PREFERRED_MODULES,
351                 "type": "csv",
352                 "metavar": "<module:preferred-module>",
353                 "help": "Couples of modules and preferred modules,"
354                 " separated by a comma.",
355             },
356         ),
357         (
358             "import-graph",
359             {
360                 "default": "",
361                 "type": "string",
362                 "metavar": "<file.gv>",
363                 "help": "Output a graph (.gv or any supported image format) of"
364                 " all (i.e. internal and external) dependencies to the given file"
365                 " (report RP0402 must not be disabled).",
366             },
367         ),
368         (
369             "ext-import-graph",
370             {
371                 "default": "",
372                 "type": "string",
373                 "metavar": "<file.gv>",
374                 "help": "Output a graph (.gv or any supported image format)"
375                 " of external dependencies to the given file"
376                 " (report RP0402 must not be disabled).",
377             },
378         ),
379         (
380             "int-import-graph",
381             {
382                 "default": "",
383                 "type": "string",
384                 "metavar": "<file.gv>",
385                 "help": "Output a graph (.gv or any supported image format)"
386                 " of internal dependencies to the given file"
387                 " (report RP0402 must not be disabled).",
388             },
389         ),
390         (
391             "known-standard-library",
392             {
393                 "default": DEFAULT_STANDARD_LIBRARY,
394                 "type": "csv",
395                 "metavar": "<modules>",
396                 "help": "Force import order to recognize a module as part of "
397                 "the standard compatibility libraries.",
398             },
399         ),
400         (
401             "known-third-party",
402             {
403                 "default": DEFAULT_KNOWN_THIRD_PARTY,
404                 "type": "csv",
405                 "metavar": "<modules>",
406                 "help": "Force import order to recognize a module as part of "
407                 "a third party library.",
408             },
409         ),
410         (
411             "allow-any-import-level",
412             {
413                 "default": (),
414                 "type": "csv",
415                 "metavar": "<modules>",
416                 "help": (
417                     "List of modules that can be imported at any level, not just "
418                     "the top level one."
419                 ),
420             },
421         ),
422         (
423             "analyse-fallback-blocks",
424             {
425                 "default": False,
426                 "type": "yn",
427                 "metavar": "<y_or_n>",
428                 "help": "Analyse import fallback blocks. This can be used to "
429                 "support both Python 2 and 3 compatible code, which "
430                 "means that the block might have code that exists "
431                 "only in one or another interpreter, leading to false "
432                 "positives when analysed.",
433             },
434         ),
435         (
436             "allow-wildcard-with-all",
437             {
438                 "default": False,
439                 "type": "yn",
440                 "metavar": "<y_or_n>",
441                 "help": "Allow wildcard imports from modules that define __all__.",
442             },
443         ),
444     )
445 
446     def __init__(self, linter=None):
447         BaseChecker.__init__(self, linter)
448         self.stats = None
449         self.import_graph = None
450         self._imports_stack = []
451         self._first_non_import_node = None
452         self._module_pkg = {}  # mapping of modules to the pkg they belong in
453         self._allow_any_import_level = set()
454         self.reports = (
455             ("RP0401", "External dependencies", self._report_external_dependencies),
456             ("RP0402", "Modules dependencies graph", self._report_dependencies_graph),
457         )
458 
459         self._site_packages = self._compute_site_packages()
460 
461     @staticmethod
462     def _compute_site_packages():
463         def _normalized_path(path):
464             return os.path.normcase(os.path.abspath(path))
465 
466         paths = set()
467         real_prefix = getattr(sys, "real_prefix", None)
468         for prefix in filter(None, (real_prefix, sys.prefix)):
469             path = sysconfig.get_python_lib(prefix=prefix)
470             path = _normalized_path(path)
471             paths.add(path)
472 
473         # Handle Debian's derivatives /usr/local.
474         if os.path.isfile("/etc/debian_version"):
475             for prefix in filter(None, (real_prefix, sys.prefix)):
476                 libpython = os.path.join(
477                     prefix,
478                     "local",
479                     "lib",
480                     "python" + sysconfig.get_python_version(),
481                     "dist-packages",
482                 )
483                 paths.add(libpython)
484         return paths
485 
486     def open(self):
487         """called before visiting project (i.e set of modules)"""
488         self.linter.add_stats(dependencies={})
489         self.linter.add_stats(cycles=[])
490         self.stats = self.linter.stats
491         self.import_graph = collections.defaultdict(set)
492         self._module_pkg = {}  # mapping of modules to the pkg they belong in
493         self._excluded_edges = collections.defaultdict(set)
494         self._ignored_modules = get_global_option(self, "ignored-modules", default=[])
495         # Build a mapping {'module': 'preferred-module'}
496         self.preferred_modules = dict(
497             module.split(":")
498             for module in self.config.preferred_modules
499             if ":" in module
500         )
501         self._allow_any_import_level = set(self.config.allow_any_import_level)
502 
503     def _import_graph_without_ignored_edges(self):
504         filtered_graph = copy.deepcopy(self.import_graph)
505         for node in filtered_graph:
506             filtered_graph[node].difference_update(self._excluded_edges[node])
507         return filtered_graph
508 
509     def close(self):
510         """called before visiting project (i.e set of modules)"""
511         if self.linter.is_message_enabled("cyclic-import"):
512             graph = self._import_graph_without_ignored_edges()
513             vertices = list(graph)
514             for cycle in get_cycles(graph, vertices=vertices):
515                 self.add_message("cyclic-import", args=" -> ".join(cycle))
516 
517     def deprecated_modules(self):
518         """Callback returning the deprecated modules."""
519         return self.config.deprecated_modules
520 
521     @check_messages(*MSGS)
522     def visit_import(self, node):
523         """triggered when an import statement is seen"""
524         self._check_reimport(node)
525         self._check_import_as_rename(node)
526         self._check_toplevel(node)
527 
528         names = [name for name, _ in node.names]
529         if len(names) >= 2:
530             self.add_message("multiple-imports", args=", ".join(names), node=node)
531 
532         for name in names:
533             self.check_deprecated_module(node, name)
534             self._check_preferred_module(node, name)
535             imported_module = self._get_imported_module(node, name)
536             if isinstance(node.parent, astroid.Module):
537                 # Allow imports nested
538                 self._check_position(node)
539             if isinstance(node.scope(), astroid.Module):
540                 self._record_import(node, imported_module)
541 
542             if imported_module is None:
543                 continue
544 
545             self._add_imported_module(node, imported_module.name)
546 
547     @check_messages(*MSGS)
548     def visit_importfrom(self, node):
549         """triggered when a from statement is seen"""
550         basename = node.modname
551         imported_module = self._get_imported_module(node, basename)
552 
553         self._check_import_as_rename(node)
554         self._check_misplaced_future(node)
555         self.check_deprecated_module(node, basename)
556         self._check_preferred_module(node, basename)
557         self._check_wildcard_imports(node, imported_module)
558         self._check_same_line_imports(node)
559         self._check_reimport(node, basename=basename, level=node.level)
560         self._check_toplevel(node)
561 
562         if isinstance(node.parent, astroid.Module):
563             # Allow imports nested
564             self._check_position(node)
565         if isinstance(node.scope(), astroid.Module):
566             self._record_import(node, imported_module)
567         if imported_module is None:
568             return
569         for name, _ in node.names:
570             if name != "*":
571                 self._add_imported_module(node, f"{imported_module.name}.{name}")
572             else:
573                 self._add_imported_module(node, imported_module.name)
574 
575     @check_messages(*MSGS)
576     def leave_module(self, node):
577         # Check imports are grouped by category (standard, 3rd party, local)
578         std_imports, ext_imports, loc_imports = self._check_imports_order(node)
579 
580         # Check that imports are grouped by package within a given category
581         met_import = set()  # set for 'import x' style
582         met_from = set()  # set for 'from x import y' style
583         current_package = None
584         for import_node, import_name in std_imports + ext_imports + loc_imports:
585             if not self.linter.is_message_enabled(
586                 "ungrouped-imports", import_node.fromlineno
587             ):
588                 continue
589             if isinstance(import_node, astroid.node_classes.ImportFrom):
590                 met = met_from
591             else:
592                 met = met_import
593             package, _, _ = import_name.partition(".")
594             if current_package and current_package != package and package in met:
595                 self.add_message("ungrouped-imports", node=import_node, args=package)
596             current_package = package
597             met.add(package)
598 
599         self._imports_stack = []
600         self._first_non_import_node = None
601 
602     def compute_first_non_import_node(self, node):
603         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
604             return
605         # if the node does not contain an import instruction, and if it is the
606         # first node of the module, keep a track of it (all the import positions
607         # of the module will be compared to the position of this first
608         # instruction)
609         if self._first_non_import_node:
610             return
611         if not isinstance(node.parent, astroid.Module):
612             return
613         nested_allowed = [astroid.TryExcept, astroid.TryFinally]
614         is_nested_allowed = [
615             allowed for allowed in nested_allowed if isinstance(node, allowed)
616         ]
617         if is_nested_allowed and any(
618             node.nodes_of_class((astroid.Import, astroid.ImportFrom))
619         ):
620             return
621         if isinstance(node, astroid.Assign):
622             # Add compatibility for module level dunder names
623             # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names
624             valid_targets = [
625                 isinstance(target, astroid.AssignName)
626                 and target.name.startswith("__")
627                 and target.name.endswith("__")
628                 for target in node.targets
629             ]
630             if all(valid_targets):
631                 return
632         self._first_non_import_node = node
633 
634     visit_tryfinally = (
635         visit_tryexcept
636     ) = (
637         visit_assignattr
638     ) = (
639         visit_assign
640     ) = (
641         visit_ifexp
642     ) = visit_comprehension = visit_expr = visit_if = compute_first_non_import_node
643 
644     def visit_functiondef(self, node):
645         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
646             return
647         # If it is the first non import instruction of the module, record it.
648         if self._first_non_import_node:
649             return
650 
651         # Check if the node belongs to an `If` or a `Try` block. If they
652         # contain imports, skip recording this node.
653         if not isinstance(node.parent.scope(), astroid.Module):
654             return
655 
656         root = node
657         while not isinstance(root.parent, astroid.Module):
658             root = root.parent
659 
660         if isinstance(root, (astroid.If, astroid.TryFinally, astroid.TryExcept)):
661             if any(root.nodes_of_class((astroid.Import, astroid.ImportFrom))):
662                 return
663 
664         self._first_non_import_node = node
665 
666     visit_classdef = visit_for = visit_while = visit_functiondef
667 
668     def _check_misplaced_future(self, node):
669         basename = node.modname
670         if basename == "__future__":
671             # check if this is the first non-docstring statement in the module
672             prev = node.previous_sibling()
673             if prev:
674                 # consecutive future statements are possible
675                 if not (
676                     isinstance(prev, astroid.ImportFrom)
677                     and prev.modname == "__future__"
678                 ):
679                     self.add_message("misplaced-future", node=node)
680             return
681 
682     def _check_same_line_imports(self, node):
683         # Detect duplicate imports on the same line.
684         names = (name for name, _ in node.names)
685         counter = collections.Counter(names)
686         for name, count in counter.items():
687             if count > 1:
688                 self.add_message("reimported", node=node, args=(name, node.fromlineno))
689 
690     def _check_position(self, node):
691         """Check `node` import or importfrom node position is correct
692 
693         Send a message  if `node` comes before another instruction
694         """
695         # if a first non-import instruction has already been encountered,
696         # it means the import comes after it and therefore is not well placed
697         if self._first_non_import_node:
698             self.add_message("wrong-import-position", node=node, args=node.as_string())
699 
700     def _record_import(self, node, importedmodnode):
701         """Record the package `node` imports from"""
702         if isinstance(node, astroid.ImportFrom):
703             importedname = node.modname
704         else:
705             importedname = importedmodnode.name if importedmodnode else None
706         if not importedname:
707             importedname = node.names[0][0].split(".")[0]
708 
709         if isinstance(node, astroid.ImportFrom) and (node.level or 0) >= 1:
710             # We need the importedname with first point to detect local package
711             # Example of node:
712             #  'from .my_package1 import MyClass1'
713             #  the output should be '.my_package1' instead of 'my_package1'
714             # Example of node:
715             #  'from . import my_package2'
716             #  the output should be '.my_package2' instead of '{pyfile}'
717             importedname = "." + importedname
718 
719         self._imports_stack.append((node, importedname))
720 
721     @staticmethod
722     def _is_fallback_import(node, imports):
723         imports = [import_node for (import_node, _) in imports]
724         return any(astroid.are_exclusive(import_node, node) for import_node in imports)
725 
726     def _check_imports_order(self, _module_node):
727         """Checks imports of module `node` are grouped by category
728 
729         Imports must follow this order: standard, 3rd party, local
730         """
731         std_imports = []
732         third_party_imports = []
733         first_party_imports = []
734         # need of a list that holds third or first party ordered import
735         external_imports = []
736         local_imports = []
737         third_party_not_ignored = []
738         first_party_not_ignored = []
739         local_not_ignored = []
740         isort_driver = IsortDriver(self.config)
741         for node, modname in self._imports_stack:
742             if modname.startswith("."):
743                 package = "." + modname.split(".")[1]
744             else:
745                 package = modname.split(".")[0]
746             nested = not isinstance(node.parent, astroid.Module)
747             ignore_for_import_order = not self.linter.is_message_enabled(
748                 "wrong-import-order", node.fromlineno
749             )
750             import_category = isort_driver.place_module(package)
751             node_and_package_import = (node, package)
752             if import_category in ("FUTURE", "STDLIB"):
753                 std_imports.append(node_and_package_import)
754                 wrong_import = (
755                     third_party_not_ignored
756                     or first_party_not_ignored
757                     or local_not_ignored
758                 )
759                 if self._is_fallback_import(node, wrong_import):
760                     continue
761                 if wrong_import and not nested:
762                     self.add_message(
763                         "wrong-import-order",
764                         node=node,
765                         args=(
766                             'standard import "%s"' % node.as_string(),
767                             '"%s"' % wrong_import[0][0].as_string(),
768                         ),
769                     )
770             elif import_category == "THIRDPARTY":
771                 third_party_imports.append(node_and_package_import)
772                 external_imports.append(node_and_package_import)
773                 if not nested and not ignore_for_import_order:
774                     third_party_not_ignored.append(node_and_package_import)
775                 wrong_import = first_party_not_ignored or local_not_ignored
776                 if wrong_import and not nested:
777                     self.add_message(
778                         "wrong-import-order",
779                         node=node,
780                         args=(
781                             'third party import "%s"' % node.as_string(),
782                             '"%s"' % wrong_import[0][0].as_string(),
783                         ),
784                     )
785             elif import_category == "FIRSTPARTY":
786                 first_party_imports.append(node_and_package_import)
787                 external_imports.append(node_and_package_import)
788                 if not nested and not ignore_for_import_order:
789                     first_party_not_ignored.append(node_and_package_import)
790                 wrong_import = local_not_ignored
791                 if wrong_import and not nested:
792                     self.add_message(
793                         "wrong-import-order",
794                         node=node,
795                         args=(
796                             'first party import "%s"' % node.as_string(),
797                             '"%s"' % wrong_import[0][0].as_string(),
798                         ),
799                     )
800             elif import_category == "LOCALFOLDER":
801                 local_imports.append((node, package))
802                 if not nested and not ignore_for_import_order:
803                     local_not_ignored.append((node, package))
804         return std_imports, external_imports, local_imports
805 
806     def _get_imported_module(self, importnode, modname):
807         try:
808             return importnode.do_import_module(modname)
809         except astroid.TooManyLevelsError:
810             if _ignore_import_failure(importnode, modname, self._ignored_modules):
811                 return None
812             self.add_message("relative-beyond-top-level", node=importnode)
813         except astroid.AstroidSyntaxError as exc:
814             message = "Cannot import {!r} due to syntax error {!r}".format(
815                 modname, str(exc.error)  # pylint: disable=no-member; false positive
816             )
817             self.add_message("syntax-error", line=importnode.lineno, args=message)
818 
819         except astroid.AstroidBuildingException:
820             if not self.linter.is_message_enabled("import-error"):
821                 return None
822             if _ignore_import_failure(importnode, modname, self._ignored_modules):
823                 return None
824             if not self.config.analyse_fallback_blocks and is_from_fallback_block(
825                 importnode
826             ):
827                 return None
828 
829             dotted_modname = _get_import_name(importnode, modname)
830             self.add_message("import-error", args=repr(dotted_modname), node=importnode)
831         return None
832 
833     def _add_imported_module(self, node, importedmodname):
834         """notify an imported module, used to analyze dependencies"""
835         module_file = node.root().file
836         context_name = node.root().name
837         base = os.path.splitext(os.path.basename(module_file))[0]
838 
839         try:
840             importedmodname = astroid.modutils.get_module_part(
841                 importedmodname, module_file
842             )
843         except ImportError:
844             pass
845 
846         if context_name == importedmodname:
847             self.add_message("import-self", node=node)
848 
849         elif not astroid.modutils.is_standard_module(importedmodname):
850             # if this is not a package __init__ module
851             if base != "__init__" and context_name not in self._module_pkg:
852                 # record the module's parent, or the module itself if this is
853                 # a top level module, as the package it belongs to
854                 self._module_pkg[context_name] = context_name.rsplit(".", 1)[0]
855 
856             # handle dependencies
857             importedmodnames = self.stats["dependencies"].setdefault(
858                 importedmodname, set()
859             )
860             if context_name not in importedmodnames:
861                 importedmodnames.add(context_name)
862 
863             # update import graph
864             self.import_graph[context_name].add(importedmodname)
865             if not self.linter.is_message_enabled("cyclic-import", line=node.lineno):
866                 self._excluded_edges[context_name].add(importedmodname)
867 
868     def _check_preferred_module(self, node, mod_path):
869         """check if the module has a preferred replacement"""
870         if mod_path in self.preferred_modules:
871             self.add_message(
872                 "preferred-module",
873                 node=node,
874                 args=(self.preferred_modules[mod_path], mod_path),
875             )
876 
877     def _check_import_as_rename(
878         self, node: Union[astroid.Import, astroid.ImportFrom]
879     ) -> None:
880         names = node.names
881         for name in names:
882             if not all(name):
883                 return
884 
885             splitted_packages = name[0].rsplit(".", maxsplit=1)
886             import_name = splitted_packages[-1]
887             aliased_name = name[1]
888             if import_name != aliased_name:
889                 continue
890 
891             if len(splitted_packages) == 1:
892                 self.add_message("useless-import-alias", node=node)
893             elif len(splitted_packages) == 2:
894                 self.add_message(
895                     "consider-using-from-import",
896                     node=node,
897                     args=(splitted_packages[0], import_name),
898                 )
899 
900     def _check_reimport(self, node, basename=None, level=None):
901         """check if the import is necessary (i.e. not already done)"""
902         if not self.linter.is_message_enabled("reimported"):
903             return
904 
905         frame = node.frame()
906         root = node.root()
907         contexts = [(frame, level)]
908         if root is not frame:
909             contexts.append((root, None))
910 
911         for known_context, known_level in contexts:
912             for name, alias in node.names:
913                 first = _get_first_import(
914                     node, known_context, name, basename, known_level, alias
915                 )
916                 if first is not None:
917                     self.add_message(
918                         "reimported", node=node, args=(name, first.fromlineno)
919                     )
920 
921     def _report_external_dependencies(self, sect, _, _dummy):
922         """return a verbatim layout for displaying dependencies"""
923         dep_info = _make_tree_defs(self._external_dependencies_info().items())
924         if not dep_info:
925             raise EmptyReportError()
926         tree_str = _repr_tree_defs(dep_info)
927         sect.append(VerbatimText(tree_str))
928 
929     def _report_dependencies_graph(self, sect, _, _dummy):
930         """write dependencies as a dot (graphviz) file"""
931         dep_info = self.stats["dependencies"]
932         if not dep_info or not (
933             self.config.import_graph
934             or self.config.ext_import_graph
935             or self.config.int_import_graph
936         ):
937             raise EmptyReportError()
938         filename = self.config.import_graph
939         if filename:
940             _make_graph(filename, dep_info, sect, "")
941         filename = self.config.ext_import_graph
942         if filename:
943             _make_graph(filename, self._external_dependencies_info(), sect, "external ")
944         filename = self.config.int_import_graph
945         if filename:
946             _make_graph(filename, self._internal_dependencies_info(), sect, "internal ")
947 
948     def _filter_dependencies_graph(self, internal):
949         """build the internal or the external dependency graph"""
950         graph = collections.defaultdict(set)
951         for importee, importers in self.stats["dependencies"].items():
952             for importer in importers:
953                 package = self._module_pkg.get(importer, importer)
954                 is_inside = importee.startswith(package)
955                 if is_inside and internal or not is_inside and not internal:
956                     graph[importee].add(importer)
957         return graph
958 
959     @astroid.decorators.cached
960     def _external_dependencies_info(self):
961         """return cached external dependencies information or build and
962         cache them
963         """
964         return self._filter_dependencies_graph(internal=False)
965 
966     @astroid.decorators.cached
967     def _internal_dependencies_info(self):
968         """return cached internal dependencies information or build and
969         cache them
970         """
971         return self._filter_dependencies_graph(internal=True)
972 
973     def _check_wildcard_imports(self, node, imported_module):
974         if node.root().package:
975             # Skip the check if in __init__.py issue #2026
976             return
977 
978         wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)
979         for name, _ in node.names:
980             if name == "*" and not wildcard_import_is_allowed:
981                 self.add_message("wildcard-import", args=node.modname, node=node)
982 
983     def _wildcard_import_is_allowed(self, imported_module):
984         return (
985             self.config.allow_wildcard_with_all
986             and imported_module is not None
987             and "__all__" in imported_module.locals
988         )
989 
990     def _check_toplevel(self, node):
991         """Check whether the import is made outside the module toplevel."""
992         # If the scope of the import is a module, then obviously it is
993         # not outside the module toplevel.
994         if isinstance(node.scope(), astroid.Module):
995             return
996 
997         module_names = [
998             f"{node.modname}.{name[0]}"
999             if isinstance(node, astroid.ImportFrom)
1000             else name[0]
1001             for name in node.names
1002         ]
1003 
1004         # Get the full names of all the imports that are only allowed at the module level
1005         scoped_imports = [
1006             name for name in module_names if name not in self._allow_any_import_level
1007         ]
1008 
1009         if scoped_imports:
1010             self.add_message(
1011                 "import-outside-toplevel", args=", ".join(scoped_imports), node=node
1012             )
1013 
1014 
1015 def register(linter):
1016     """required method to auto register this checker"""
1017     linter.register_checker(ImportsChecker(linter))

</code><intended_behavior>This file likely contains logic for detecting unused imports. A modification or enhancement should be made here to include logic that recognizes and validates imports used in type comments. The checker should parse comments for variables, class attributes, and function annotations, identify type hints within these comments, and cross-reference these types with imported modules or objects. Such an enhancement would address the issue by not flagging imports as unused if they are referenced in type comments.</intended_behavior>, <file>pylint/utils/ast_walker.py</file>
<class>ASTWalker</class>
<method>None</method>
<code>
9 class ASTWalker:
10     def __init__(self, linter):
11         # callbacks per node types
12         self.nbstatements = 0
13         self.visit_events = collections.defaultdict(list)
14         self.leave_events = collections.defaultdict(list)
15         self.linter = linter
16         self.exception_msg = False
17 
18     def _is_method_enabled(self, method):
19         if not hasattr(method, "checks_msgs"):
20             return True
21         for msg_desc in method.checks_msgs:
22             if self.linter.is_message_enabled(msg_desc):
23                 return True
24         return False
25 
26     def add_checker(self, checker):
27         """walk to the checker's dir and collect visit and leave methods"""
28         vcids = set()
29         lcids = set()
30         visits = self.visit_events
31         leaves = self.leave_events
32         for member in dir(checker):
33             cid = member[6:]
34             if cid == "default":
35                 continue
36             if member.startswith("visit_"):
37                 v_meth = getattr(checker, member)
38                 # don't use visit_methods with no activated message:
39                 if self._is_method_enabled(v_meth):
40                     visits[cid].append(v_meth)
41                     vcids.add(cid)
42             elif member.startswith("leave_"):
43                 l_meth = getattr(checker, member)
44                 # don't use leave_methods with no activated message:
45                 if self._is_method_enabled(l_meth):
46                     leaves[cid].append(l_meth)
47                     lcids.add(cid)
48         visit_default = getattr(checker, "visit_default", None)
49         if visit_default:
50             for cls in nodes.ALL_NODE_CLASSES:
51                 cid = cls.__name__.lower()
52                 if cid not in vcids:
53                     visits[cid].append(visit_default)
54         # for now we have no "leave_default" method in Pylint
55 
56     def walk(self, astroid):
57         """call visit events of astroid checkers for the given node, recurse on
58         its children, then leave events.
59         """
60         cid = astroid.__class__.__name__.lower()
61 
62         # Detect if the node is a new name for a deprecated alias.
63         # In this case, favour the methods for the deprecated
64         # alias if any,  in order to maintain backwards
65         # compatibility.
66         visit_events = self.visit_events.get(cid, ())
67         leave_events = self.leave_events.get(cid, ())
68 
69         try:
70             if astroid.is_statement:
71                 self.nbstatements += 1
72             # generate events for this node on each checker
73             for callback in visit_events or ():
74                 callback(astroid)
75             # recurse on children
76             for child in astroid.get_children():
77                 self.walk(child)
78             for callback in leave_events or ():
79                 callback(astroid)
80         except Exception:
81             if self.exception_msg is False:
82                 file = getattr(astroid.root(), "file", None)
83                 print(f"Exception on node {repr(astroid)} in file '{file}'")
84                 self.exception_msg = True
85             raise

</code><intended_behavior>Adjustments to ensure type comments are adequately considered during the visitation of nodes related to import statements. The intended behavior would include enhancements to traverse and analyze comments adjacent to or within node structures that can have associated type hints (e.g., variable annotations, function signatures). This would ensure that the AST traversal logic supports identifying use cases of imported types within comments.</intended_behavior>]
2025-10-18 04:27:35.857 | INFO     | Search completed. Bug locations: [<file>pylint/checkers/imports.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006-2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2012-2014 Google, Inc.
3 # Copyright (c) 2013 buck@yelp.com <buck@yelp.com>
4 # Copyright (c) 2014-2020 Claudiu Popa <pcmanticore@gmail.com>
5 # Copyright (c) 2014 Brett Cannon <brett@python.org>
6 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
7 # Copyright (c) 2015-2016 Moises Lopez <moylop260@vauxoo.com>
8 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
9 # Copyright (c) 2015 Cezar <celnazli@bitdefender.com>
10 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
11 # Copyright (c) 2015 Noam Yorav-Raphael <noamraph@gmail.com>
12 # Copyright (c) 2015 James Morgensen <james.morgensen@gmail.com>
13 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
14 # Copyright (c) 2016 Jared Garst <cultofjared@gmail.com>
15 # Copyright (c) 2016 Maik Röder <maikroeder@gmail.com>
16 # Copyright (c) 2016 Glenn Matthews <glenn@e-dad.net>
17 # Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>
18 # Copyright (c) 2017, 2020 hippo91 <guillaume.peillex@gmail.com>
19 # Copyright (c) 2017 Michka Popoff <michkapopoff@gmail.com>
20 # Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
21 # Copyright (c) 2017 Erik Wright <erik.wright@shopify.com>
22 # Copyright (c) 2018 Lucas Cimon <lucas.cimon@gmail.com>
23 # Copyright (c) 2018 Hornwitser <github@hornwitser.no>
24 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
25 # Copyright (c) 2018 Natalie Serebryakova <natalie.serebryakova@Natalies-MacBook-Pro.local>
26 # Copyright (c) 2018 Mike Frysinger <vapier@gmail.com>
27 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>
28 # Copyright (c) 2018 Marianna Polatoglou <mpolatoglou@bloomberg.net>
29 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
30 # Copyright (c) 2019 Nick Drozd <nicholasdrozd@gmail.com>
31 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>
32 # Copyright (c) 2019 Nick Smith <clickthisnick@users.noreply.github.com>
33 # Copyright (c) 2019 Paul Renvoisé <renvoisepaul@gmail.com>
34 # Copyright (c) 2020 Peter Kolbus <peter.kolbus@gmail.com>
35 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>
36 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>
37 # Copyright (c) 2021 yushao2 <36848472+yushao2@users.noreply.github.com>
38 # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>
39 # Copyright (c) 2021 Matus Valo <matusvalo@users.noreply.github.com>
40 # Copyright (c) 2021 Andrew Howe <howeaj@users.noreply.github.com>
41 
42 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
43 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
44 
45 """imports checkers for Python code"""
46 
47 import collections
48 import copy
49 import os
50 import sys
51 from distutils import sysconfig
52 from typing import Dict, List, Union
53 
54 import astroid
55 
56 from pylint.checkers import BaseChecker, DeprecatedMixin
57 from pylint.checkers.utils import (
58     check_messages,
59     is_from_fallback_block,
60     node_ignores_exception,
61 )
62 from pylint.exceptions import EmptyReportError
63 from pylint.graph import DotBackend, get_cycles
64 from pylint.interfaces import IAstroidChecker
65 from pylint.reporters.ureports.nodes import Paragraph, VerbatimText, VNode
66 from pylint.utils import IsortDriver, get_global_option
67 
68 
69 def _qualified_names(modname):
70     """Split the names of the given module into subparts
71 
72     For example,
73         _qualified_names('pylint.checkers.ImportsChecker')
74     returns
75         ['pylint', 'pylint.checkers', 'pylint.checkers.ImportsChecker']
76     """
77     names = modname.split(".")
78     return [".".join(names[0 : i + 1]) for i in range(len(names))]
79 
80 
81 def _get_import_name(importnode, modname):
82     """Get a prepared module name from the given import node
83 
84     In the case of relative imports, this will return the
85     absolute qualified module name, which might be useful
86     for debugging. Otherwise, the initial module name
87     is returned unchanged.
88     """
89     if isinstance(importnode, astroid.ImportFrom):
90         if importnode.level:
91             root = importnode.root()
92             if isinstance(root, astroid.Module):
93                 modname = root.relative_to_absolute_name(
94                     modname, level=importnode.level
95                 )
96     return modname
97 
98 
99 def _get_first_import(node, context, name, base, level, alias):
100     """return the node where [base.]<name> is imported or None if not found"""
101     fullname = f"{base}.{name}" if base else name
102 
103     first = None
104     found = False
105     for first in context.body:
106         if first is node:
107             continue
108         if first.scope() is node.scope() and first.fromlineno > node.fromlineno:
109             continue
110         if isinstance(first, astroid.Import):
111             if any(fullname == iname[0] for iname in first.names):
112                 found = True
113                 break
114         elif isinstance(first, astroid.ImportFrom):
115             if level == first.level:
116                 for imported_name, imported_alias in first.names:
117                     if fullname == f"{first.modname}.{imported_name}":
118                         found = True
119                         break
120                     if (
121                         name != "*"
122                         and name == imported_name
123                         and not (alias or imported_alias)
124                     ):
125                         found = True
126                         break
127                 if found:
128                     break
129     if found and not astroid.are_exclusive(first, node):
130         return first
131     return None
132 
133 
134 def _ignore_import_failure(node, modname, ignored_modules):
135     for submodule in _qualified_names(modname):
136         if submodule in ignored_modules:
137             return True
138 
139     # ignore import failure if guarded by `sys.version_info` test
140     if isinstance(node.parent, astroid.If) and isinstance(
141         node.parent.test, astroid.Compare
142     ):
143         value = node.parent.test.left
144         if isinstance(value, astroid.Subscript):
145             value = value.value
146         if (
147             isinstance(value, astroid.Attribute)
148             and value.as_string() == "sys.version_info"
149         ):
150             return True
151 
152     return node_ignores_exception(node, ImportError)
153 
154 
155 # utilities to represents import dependencies as tree and dot graph ###########
156 
157 
158 def _make_tree_defs(mod_files_list):
159     """get a list of 2-uple (module, list_of_files_which_import_this_module),
160     it will return a dictionary to represent this as a tree
161     """
162     tree_defs = {}
163     for mod, files in mod_files_list:
164         node = (tree_defs, ())
165         for prefix in mod.split("."):
166             node = node[0].setdefault(prefix, [{}, []])
167         node[1] += files
168     return tree_defs
169 
170 
171 def _repr_tree_defs(data, indent_str=None):
172     """return a string which represents imports as a tree"""
173     lines = []
174     nodes = data.items()
175     for i, (mod, (sub, files)) in enumerate(sorted(nodes, key=lambda x: x[0])):
176         if not files:
177             files = ""
178         else:
179             files = "(%s)" % ",".join(sorted(files))
180         if indent_str is None:
181             lines.append(f"{mod} {files}")
182             sub_indent_str = "  "
183         else:
184             lines.append(fr"{indent_str}\-{mod} {files}")
185             if i == len(nodes) - 1:
186                 sub_indent_str = "%s  " % indent_str
187             else:
188                 sub_indent_str = "%s| " % indent_str
189         if sub:
190             lines.append(_repr_tree_defs(sub, sub_indent_str))
191     return "\n".join(lines)
192 
193 
194 def _dependencies_graph(filename: str, dep_info: Dict[str, List[str]]) -> str:
195     """write dependencies as a dot (graphviz) file"""
196     done = {}
197     printer = DotBackend(os.path.splitext(os.path.basename(filename))[0], rankdir="LR")
198     printer.emit('URL="." node[shape="box"]')
199     for modname, dependencies in sorted(dep_info.items()):
200         done[modname] = 1
201         printer.emit_node(modname)
202         for depmodname in dependencies:
203             if depmodname not in done:
204                 done[depmodname] = 1
205                 printer.emit_node(depmodname)
206     for depmodname, dependencies in sorted(dep_info.items()):
207         for modname in dependencies:
208             printer.emit_edge(modname, depmodname)
209     return printer.generate(filename)
210 
211 
212 def _make_graph(filename: str, dep_info: Dict[str, List[str]], sect: VNode, gtype: str):
213     """generate a dependencies graph and add some information about it in the
214     report's section
215     """
216     outputfile = _dependencies_graph(filename, dep_info)
217     sect.append(Paragraph(f"{gtype}imports graph has been written to {outputfile}"))
218 
219 
220 # the import checker itself ###################################################
221 
222 MSGS = {
223     "E0401": (
224         "Unable to import %s",
225         "import-error",
226         "Used when pylint has been unable to import a module.",
227         {"old_names": [("F0401", "old-import-error")]},
228     ),
229     "E0402": (
230         "Attempted relative import beyond top-level package",
231         "relative-beyond-top-level",
232         "Used when a relative import tries to access too many levels "
233         "in the current package.",
234     ),
235     "R0401": (
236         "Cyclic import (%s)",
237         "cyclic-import",
238         "Used when a cyclic import between two or more modules is detected.",
239     ),
240     "R0402": (
241         "Use 'from %s import %s' instead",
242         "consider-using-from-import",
243         "Emitted when a submodule/member of a package is imported and "
244         "aliased with the same name. "
245         "E.g., instead of ``import pandas.DataFrame as DataFrame`` use "
246         "``from pandas import DataFrame``",
247     ),
248     "W0401": (
249         "Wildcard import %s",
250         "wildcard-import",
251         "Used when `from module import *` is detected.",
252     ),
253     "W0402": (
254         "Uses of a deprecated module %r",
255         "deprecated-module",
256         "Used a module marked as deprecated is imported.",
257     ),
258     "W0404": (
259         "Reimport %r (imported line %s)",
260         "reimported",
261         "Used when a module is reimported multiple times.",
262     ),
263     "W0406": (
264         "Module import itself",
265         "import-self",
266         "Used when a module is importing itself.",
267     ),
268     "W0407": (
269         "Prefer importing %r instead of %r",
270         "preferred-module",
271         "Used when a module imported has a preferred replacement module.",
272     ),
273     "W0410": (
274         "__future__ import is not the first non docstring statement",
275         "misplaced-future",
276         "Python 2.5 and greater require __future__ import to be the "
277         "first non docstring statement in the module.",
278     ),
279     "C0410": (
280         "Multiple imports on one line (%s)",
281         "multiple-imports",
282         "Used when import statement importing multiple modules is detected.",
283     ),
284     "C0411": (
285         "%s should be placed before %s",
286         "wrong-import-order",
287         "Used when PEP8 import order is not respected (standard imports "
288         "first, then third-party libraries, then local imports)",
289     ),
290     "C0412": (
291         "Imports from package %s are not grouped",
292         "ungrouped-imports",
293         "Used when imports are not grouped by packages",
294     ),
295     "C0413": (
296         'Import "%s" should be placed at the top of the module',
297         "wrong-import-position",
298         "Used when code and imports are mixed",
299     ),
300     "C0414": (
301         "Import alias does not rename original package",
302         "useless-import-alias",
303         "Used when an import alias is same as original package."
304         "e.g using import numpy as numpy instead of import numpy as np",
305     ),
306     "C0415": (
307         "Import outside toplevel (%s)",
308         "import-outside-toplevel",
309         "Used when an import statement is used anywhere other than the module "
310         "toplevel. Move this import to the top of the file.",
311     ),
312 }
313 
314 
315 DEFAULT_STANDARD_LIBRARY = ()
316 DEFAULT_KNOWN_THIRD_PARTY = ("enchant",)
317 DEFAULT_PREFERRED_MODULES = ()
318 
319 
320 class ImportsChecker(DeprecatedMixin, BaseChecker):
321     """checks for
322     * external modules dependencies
323     * relative / wildcard imports
324     * cyclic imports
325     * uses of deprecated modules
326     * uses of modules instead of preferred modules
327     """
328 
329     __implements__ = IAstroidChecker
330 
331     name = "imports"
332     msgs = MSGS
333     priority = -2
334     default_deprecated_modules = ()
335 
336     options = (
337         (
338             "deprecated-modules",
339             {
340                 "default": default_deprecated_modules,
341                 "type": "csv",
342                 "metavar": "<modules>",
343                 "help": "Deprecated modules which should not be used,"
344                 " separated by a comma.",
345             },
346         ),
347         (
348             "preferred-modules",
349             {
350                 "default": DEFAULT_PREFERRED_MODULES,
351                 "type": "csv",
352                 "metavar": "<module:preferred-module>",
353                 "help": "Couples of modules and preferred modules,"
354                 " separated by a comma.",
355             },
356         ),
357         (
358             "import-graph",
359             {
360                 "default": "",
361                 "type": "string",
362                 "metavar": "<file.gv>",
363                 "help": "Output a graph (.gv or any supported image format) of"
364                 " all (i.e. internal and external) dependencies to the given file"
365                 " (report RP0402 must not be disabled).",
366             },
367         ),
368         (
369             "ext-import-graph",
370             {
371                 "default": "",
372                 "type": "string",
373                 "metavar": "<file.gv>",
374                 "help": "Output a graph (.gv or any supported image format)"
375                 " of external dependencies to the given file"
376                 " (report RP0402 must not be disabled).",
377             },
378         ),
379         (
380             "int-import-graph",
381             {
382                 "default": "",
383                 "type": "string",
384                 "metavar": "<file.gv>",
385                 "help": "Output a graph (.gv or any supported image format)"
386                 " of internal dependencies to the given file"
387                 " (report RP0402 must not be disabled).",
388             },
389         ),
390         (
391             "known-standard-library",
392             {
393                 "default": DEFAULT_STANDARD_LIBRARY,
394                 "type": "csv",
395                 "metavar": "<modules>",
396                 "help": "Force import order to recognize a module as part of "
397                 "the standard compatibility libraries.",
398             },
399         ),
400         (
401             "known-third-party",
402             {
403                 "default": DEFAULT_KNOWN_THIRD_PARTY,
404                 "type": "csv",
405                 "metavar": "<modules>",
406                 "help": "Force import order to recognize a module as part of "
407                 "a third party library.",
408             },
409         ),
410         (
411             "allow-any-import-level",
412             {
413                 "default": (),
414                 "type": "csv",
415                 "metavar": "<modules>",
416                 "help": (
417                     "List of modules that can be imported at any level, not just "
418                     "the top level one."
419                 ),
420             },
421         ),
422         (
423             "analyse-fallback-blocks",
424             {
425                 "default": False,
426                 "type": "yn",
427                 "metavar": "<y_or_n>",
428                 "help": "Analyse import fallback blocks. This can be used to "
429                 "support both Python 2 and 3 compatible code, which "
430                 "means that the block might have code that exists "
431                 "only in one or another interpreter, leading to false "
432                 "positives when analysed.",
433             },
434         ),
435         (
436             "allow-wildcard-with-all",
437             {
438                 "default": False,
439                 "type": "yn",
440                 "metavar": "<y_or_n>",
441                 "help": "Allow wildcard imports from modules that define __all__.",
442             },
443         ),
444     )
445 
446     def __init__(self, linter=None):
447         BaseChecker.__init__(self, linter)
448         self.stats = None
449         self.import_graph = None
450         self._imports_stack = []
451         self._first_non_import_node = None
452         self._module_pkg = {}  # mapping of modules to the pkg they belong in
453         self._allow_any_import_level = set()
454         self.reports = (
455             ("RP0401", "External dependencies", self._report_external_dependencies),
456             ("RP0402", "Modules dependencies graph", self._report_dependencies_graph),
457         )
458 
459         self._site_packages = self._compute_site_packages()
460 
461     @staticmethod
462     def _compute_site_packages():
463         def _normalized_path(path):
464             return os.path.normcase(os.path.abspath(path))
465 
466         paths = set()
467         real_prefix = getattr(sys, "real_prefix", None)
468         for prefix in filter(None, (real_prefix, sys.prefix)):
469             path = sysconfig.get_python_lib(prefix=prefix)
470             path = _normalized_path(path)
471             paths.add(path)
472 
473         # Handle Debian's derivatives /usr/local.
474         if os.path.isfile("/etc/debian_version"):
475             for prefix in filter(None, (real_prefix, sys.prefix)):
476                 libpython = os.path.join(
477                     prefix,
478                     "local",
479                     "lib",
480                     "python" + sysconfig.get_python_version(),
481                     "dist-packages",
482                 )
483                 paths.add(libpython)
484         return paths
485 
486     def open(self):
487         """called before visiting project (i.e set of modules)"""
488         self.linter.add_stats(dependencies={})
489         self.linter.add_stats(cycles=[])
490         self.stats = self.linter.stats
491         self.import_graph = collections.defaultdict(set)
492         self._module_pkg = {}  # mapping of modules to the pkg they belong in
493         self._excluded_edges = collections.defaultdict(set)
494         self._ignored_modules = get_global_option(self, "ignored-modules", default=[])
495         # Build a mapping {'module': 'preferred-module'}
496         self.preferred_modules = dict(
497             module.split(":")
498             for module in self.config.preferred_modules
499             if ":" in module
500         )
501         self._allow_any_import_level = set(self.config.allow_any_import_level)
502 
503     def _import_graph_without_ignored_edges(self):
504         filtered_graph = copy.deepcopy(self.import_graph)
505         for node in filtered_graph:
506             filtered_graph[node].difference_update(self._excluded_edges[node])
507         return filtered_graph
508 
509     def close(self):
510         """called before visiting project (i.e set of modules)"""
511         if self.linter.is_message_enabled("cyclic-import"):
512             graph = self._import_graph_without_ignored_edges()
513             vertices = list(graph)
514             for cycle in get_cycles(graph, vertices=vertices):
515                 self.add_message("cyclic-import", args=" -> ".join(cycle))
516 
517     def deprecated_modules(self):
518         """Callback returning the deprecated modules."""
519         return self.config.deprecated_modules
520 
521     @check_messages(*MSGS)
522     def visit_import(self, node):
523         """triggered when an import statement is seen"""
524         self._check_reimport(node)
525         self._check_import_as_rename(node)
526         self._check_toplevel(node)
527 
528         names = [name for name, _ in node.names]
529         if len(names) >= 2:
530             self.add_message("multiple-imports", args=", ".join(names), node=node)
531 
532         for name in names:
533             self.check_deprecated_module(node, name)
534             self._check_preferred_module(node, name)
535             imported_module = self._get_imported_module(node, name)
536             if isinstance(node.parent, astroid.Module):
537                 # Allow imports nested
538                 self._check_position(node)
539             if isinstance(node.scope(), astroid.Module):
540                 self._record_import(node, imported_module)
541 
542             if imported_module is None:
543                 continue
544 
545             self._add_imported_module(node, imported_module.name)
546 
547     @check_messages(*MSGS)
548     def visit_importfrom(self, node):
549         """triggered when a from statement is seen"""
550         basename = node.modname
551         imported_module = self._get_imported_module(node, basename)
552 
553         self._check_import_as_rename(node)
554         self._check_misplaced_future(node)
555         self.check_deprecated_module(node, basename)
556         self._check_preferred_module(node, basename)
557         self._check_wildcard_imports(node, imported_module)
558         self._check_same_line_imports(node)
559         self._check_reimport(node, basename=basename, level=node.level)
560         self._check_toplevel(node)
561 
562         if isinstance(node.parent, astroid.Module):
563             # Allow imports nested
564             self._check_position(node)
565         if isinstance(node.scope(), astroid.Module):
566             self._record_import(node, imported_module)
567         if imported_module is None:
568             return
569         for name, _ in node.names:
570             if name != "*":
571                 self._add_imported_module(node, f"{imported_module.name}.{name}")
572             else:
573                 self._add_imported_module(node, imported_module.name)
574 
575     @check_messages(*MSGS)
576     def leave_module(self, node):
577         # Check imports are grouped by category (standard, 3rd party, local)
578         std_imports, ext_imports, loc_imports = self._check_imports_order(node)
579 
580         # Check that imports are grouped by package within a given category
581         met_import = set()  # set for 'import x' style
582         met_from = set()  # set for 'from x import y' style
583         current_package = None
584         for import_node, import_name in std_imports + ext_imports + loc_imports:
585             if not self.linter.is_message_enabled(
586                 "ungrouped-imports", import_node.fromlineno
587             ):
588                 continue
589             if isinstance(import_node, astroid.node_classes.ImportFrom):
590                 met = met_from
591             else:
592                 met = met_import
593             package, _, _ = import_name.partition(".")
594             if current_package and current_package != package and package in met:
595                 self.add_message("ungrouped-imports", node=import_node, args=package)
596             current_package = package
597             met.add(package)
598 
599         self._imports_stack = []
600         self._first_non_import_node = None
601 
602     def compute_first_non_import_node(self, node):
603         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
604             return
605         # if the node does not contain an import instruction, and if it is the
606         # first node of the module, keep a track of it (all the import positions
607         # of the module will be compared to the position of this first
608         # instruction)
609         if self._first_non_import_node:
610             return
611         if not isinstance(node.parent, astroid.Module):
612             return
613         nested_allowed = [astroid.TryExcept, astroid.TryFinally]
614         is_nested_allowed = [
615             allowed for allowed in nested_allowed if isinstance(node, allowed)
616         ]
617         if is_nested_allowed and any(
618             node.nodes_of_class((astroid.Import, astroid.ImportFrom))
619         ):
620             return
621         if isinstance(node, astroid.Assign):
622             # Add compatibility for module level dunder names
623             # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names
624             valid_targets = [
625                 isinstance(target, astroid.AssignName)
626                 and target.name.startswith("__")
627                 and target.name.endswith("__")
628                 for target in node.targets
629             ]
630             if all(valid_targets):
631                 return
632         self._first_non_import_node = node
633 
634     visit_tryfinally = (
635         visit_tryexcept
636     ) = (
637         visit_assignattr
638     ) = (
639         visit_assign
640     ) = (
641         visit_ifexp
642     ) = visit_comprehension = visit_expr = visit_if = compute_first_non_import_node
643 
644     def visit_functiondef(self, node):
645         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
646             return
647         # If it is the first non import instruction of the module, record it.
648         if self._first_non_import_node:
649             return
650 
651         # Check if the node belongs to an `If` or a `Try` block. If they
652         # contain imports, skip recording this node.
653         if not isinstance(node.parent.scope(), astroid.Module):
654             return
655 
656         root = node
657         while not isinstance(root.parent, astroid.Module):
658             root = root.parent
659 
660         if isinstance(root, (astroid.If, astroid.TryFinally, astroid.TryExcept)):
661             if any(root.nodes_of_class((astroid.Import, astroid.ImportFrom))):
662                 return
663 
664         self._first_non_import_node = node
665 
666     visit_classdef = visit_for = visit_while = visit_functiondef
667 
668     def _check_misplaced_future(self, node):
669         basename = node.modname
670         if basename == "__future__":
671             # check if this is the first non-docstring statement in the module
672             prev = node.previous_sibling()
673             if prev:
674                 # consecutive future statements are possible
675                 if not (
676                     isinstance(prev, astroid.ImportFrom)
677                     and prev.modname == "__future__"
678                 ):
679                     self.add_message("misplaced-future", node=node)
680             return
681 
682     def _check_same_line_imports(self, node):
683         # Detect duplicate imports on the same line.
684         names = (name for name, _ in node.names)
685         counter = collections.Counter(names)
686         for name, count in counter.items():
687             if count > 1:
688                 self.add_message("reimported", node=node, args=(name, node.fromlineno))
689 
690     def _check_position(self, node):
691         """Check `node` import or importfrom node position is correct
692 
693         Send a message  if `node` comes before another instruction
694         """
695         # if a first non-import instruction has already been encountered,
696         # it means the import comes after it and therefore is not well placed
697         if self._first_non_import_node:
698             self.add_message("wrong-import-position", node=node, args=node.as_string())
699 
700     def _record_import(self, node, importedmodnode):
701         """Record the package `node` imports from"""
702         if isinstance(node, astroid.ImportFrom):
703             importedname = node.modname
704         else:
705             importedname = importedmodnode.name if importedmodnode else None
706         if not importedname:
707             importedname = node.names[0][0].split(".")[0]
708 
709         if isinstance(node, astroid.ImportFrom) and (node.level or 0) >= 1:
710             # We need the importedname with first point to detect local package
711             # Example of node:
712             #  'from .my_package1 import MyClass1'
713             #  the output should be '.my_package1' instead of 'my_package1'
714             # Example of node:
715             #  'from . import my_package2'
716             #  the output should be '.my_package2' instead of '{pyfile}'
717             importedname = "." + importedname
718 
719         self._imports_stack.append((node, importedname))
720 
721     @staticmethod
722     def _is_fallback_import(node, imports):
723         imports = [import_node for (import_node, _) in imports]
724         return any(astroid.are_exclusive(import_node, node) for import_node in imports)
725 
726     def _check_imports_order(self, _module_node):
727         """Checks imports of module `node` are grouped by category
728 
729         Imports must follow this order: standard, 3rd party, local
730         """
731         std_imports = []
732         third_party_imports = []
733         first_party_imports = []
734         # need of a list that holds third or first party ordered import
735         external_imports = []
736         local_imports = []
737         third_party_not_ignored = []
738         first_party_not_ignored = []
739         local_not_ignored = []
740         isort_driver = IsortDriver(self.config)
741         for node, modname in self._imports_stack:
742             if modname.startswith("."):
743                 package = "." + modname.split(".")[1]
744             else:
745                 package = modname.split(".")[0]
746             nested = not isinstance(node.parent, astroid.Module)
747             ignore_for_import_order = not self.linter.is_message_enabled(
748                 "wrong-import-order", node.fromlineno
749             )
750             import_category = isort_driver.place_module(package)
751             node_and_package_import = (node, package)
752             if import_category in ("FUTURE", "STDLIB"):
753                 std_imports.append(node_and_package_import)
754                 wrong_import = (
755                     third_party_not_ignored
756                     or first_party_not_ignored
757                     or local_not_ignored
758                 )
759                 if self._is_fallback_import(node, wrong_import):
760                     continue
761                 if wrong_import and not nested:
762                     self.add_message(
763                         "wrong-import-order",
764                         node=node,
765                         args=(
766                             'standard import "%s"' % node.as_string(),
767                             '"%s"' % wrong_import[0][0].as_string(),
768                         ),
769                     )
770             elif import_category == "THIRDPARTY":
771                 third_party_imports.append(node_and_package_import)
772                 external_imports.append(node_and_package_import)
773                 if not nested and not ignore_for_import_order:
774                     third_party_not_ignored.append(node_and_package_import)
775                 wrong_import = first_party_not_ignored or local_not_ignored
776                 if wrong_import and not nested:
777                     self.add_message(
778                         "wrong-import-order",
779                         node=node,
780                         args=(
781                             'third party import "%s"' % node.as_string(),
782                             '"%s"' % wrong_import[0][0].as_string(),
783                         ),
784                     )
785             elif import_category == "FIRSTPARTY":
786                 first_party_imports.append(node_and_package_import)
787                 external_imports.append(node_and_package_import)
788                 if not nested and not ignore_for_import_order:
789                     first_party_not_ignored.append(node_and_package_import)
790                 wrong_import = local_not_ignored
791                 if wrong_import and not nested:
792                     self.add_message(
793                         "wrong-import-order",
794                         node=node,
795                         args=(
796                             'first party import "%s"' % node.as_string(),
797                             '"%s"' % wrong_import[0][0].as_string(),
798                         ),
799                     )
800             elif import_category == "LOCALFOLDER":
801                 local_imports.append((node, package))
802                 if not nested and not ignore_for_import_order:
803                     local_not_ignored.append((node, package))
804         return std_imports, external_imports, local_imports
805 
806     def _get_imported_module(self, importnode, modname):
807         try:
808             return importnode.do_import_module(modname)
809         except astroid.TooManyLevelsError:
810             if _ignore_import_failure(importnode, modname, self._ignored_modules):
811                 return None
812             self.add_message("relative-beyond-top-level", node=importnode)
813         except astroid.AstroidSyntaxError as exc:
814             message = "Cannot import {!r} due to syntax error {!r}".format(
815                 modname, str(exc.error)  # pylint: disable=no-member; false positive
816             )
817             self.add_message("syntax-error", line=importnode.lineno, args=message)
818 
819         except astroid.AstroidBuildingException:
820             if not self.linter.is_message_enabled("import-error"):
821                 return None
822             if _ignore_import_failure(importnode, modname, self._ignored_modules):
823                 return None
824             if not self.config.analyse_fallback_blocks and is_from_fallback_block(
825                 importnode
826             ):
827                 return None
828 
829             dotted_modname = _get_import_name(importnode, modname)
830             self.add_message("import-error", args=repr(dotted_modname), node=importnode)
831         return None
832 
833     def _add_imported_module(self, node, importedmodname):
834         """notify an imported module, used to analyze dependencies"""
835         module_file = node.root().file
836         context_name = node.root().name
837         base = os.path.splitext(os.path.basename(module_file))[0]
838 
839         try:
840             importedmodname = astroid.modutils.get_module_part(
841                 importedmodname, module_file
842             )
843         except ImportError:
844             pass
845 
846         if context_name == importedmodname:
847             self.add_message("import-self", node=node)
848 
849         elif not astroid.modutils.is_standard_module(importedmodname):
850             # if this is not a package __init__ module
851             if base != "__init__" and context_name not in self._module_pkg:
852                 # record the module's parent, or the module itself if this is
853                 # a top level module, as the package it belongs to
854                 self._module_pkg[context_name] = context_name.rsplit(".", 1)[0]
855 
856             # handle dependencies
857             importedmodnames = self.stats["dependencies"].setdefault(
858                 importedmodname, set()
859             )
860             if context_name not in importedmodnames:
861                 importedmodnames.add(context_name)
862 
863             # update import graph
864             self.import_graph[context_name].add(importedmodname)
865             if not self.linter.is_message_enabled("cyclic-import", line=node.lineno):
866                 self._excluded_edges[context_name].add(importedmodname)
867 
868     def _check_preferred_module(self, node, mod_path):
869         """check if the module has a preferred replacement"""
870         if mod_path in self.preferred_modules:
871             self.add_message(
872                 "preferred-module",
873                 node=node,
874                 args=(self.preferred_modules[mod_path], mod_path),
875             )
876 
877     def _check_import_as_rename(
878         self, node: Union[astroid.Import, astroid.ImportFrom]
879     ) -> None:
880         names = node.names
881         for name in names:
882             if not all(name):
883                 return
884 
885             splitted_packages = name[0].rsplit(".", maxsplit=1)
886             import_name = splitted_packages[-1]
887             aliased_name = name[1]
888             if import_name != aliased_name:
889                 continue
890 
891             if len(splitted_packages) == 1:
892                 self.add_message("useless-import-alias", node=node)
893             elif len(splitted_packages) == 2:
894                 self.add_message(
895                     "consider-using-from-import",
896                     node=node,
897                     args=(splitted_packages[0], import_name),
898                 )
899 
900     def _check_reimport(self, node, basename=None, level=None):
901         """check if the import is necessary (i.e. not already done)"""
902         if not self.linter.is_message_enabled("reimported"):
903             return
904 
905         frame = node.frame()
906         root = node.root()
907         contexts = [(frame, level)]
908         if root is not frame:
909             contexts.append((root, None))
910 
911         for known_context, known_level in contexts:
912             for name, alias in node.names:
913                 first = _get_first_import(
914                     node, known_context, name, basename, known_level, alias
915                 )
916                 if first is not None:
917                     self.add_message(
918                         "reimported", node=node, args=(name, first.fromlineno)
919                     )
920 
921     def _report_external_dependencies(self, sect, _, _dummy):
922         """return a verbatim layout for displaying dependencies"""
923         dep_info = _make_tree_defs(self._external_dependencies_info().items())
924         if not dep_info:
925             raise EmptyReportError()
926         tree_str = _repr_tree_defs(dep_info)
927         sect.append(VerbatimText(tree_str))
928 
929     def _report_dependencies_graph(self, sect, _, _dummy):
930         """write dependencies as a dot (graphviz) file"""
931         dep_info = self.stats["dependencies"]
932         if not dep_info or not (
933             self.config.import_graph
934             or self.config.ext_import_graph
935             or self.config.int_import_graph
936         ):
937             raise EmptyReportError()
938         filename = self.config.import_graph
939         if filename:
940             _make_graph(filename, dep_info, sect, "")
941         filename = self.config.ext_import_graph
942         if filename:
943             _make_graph(filename, self._external_dependencies_info(), sect, "external ")
944         filename = self.config.int_import_graph
945         if filename:
946             _make_graph(filename, self._internal_dependencies_info(), sect, "internal ")
947 
948     def _filter_dependencies_graph(self, internal):
949         """build the internal or the external dependency graph"""
950         graph = collections.defaultdict(set)
951         for importee, importers in self.stats["dependencies"].items():
952             for importer in importers:
953                 package = self._module_pkg.get(importer, importer)
954                 is_inside = importee.startswith(package)
955                 if is_inside and internal or not is_inside and not internal:
956                     graph[importee].add(importer)
957         return graph
958 
959     @astroid.decorators.cached
960     def _external_dependencies_info(self):
961         """return cached external dependencies information or build and
962         cache them
963         """
964         return self._filter_dependencies_graph(internal=False)
965 
966     @astroid.decorators.cached
967     def _internal_dependencies_info(self):
968         """return cached internal dependencies information or build and
969         cache them
970         """
971         return self._filter_dependencies_graph(internal=True)
972 
973     def _check_wildcard_imports(self, node, imported_module):
974         if node.root().package:
975             # Skip the check if in __init__.py issue #2026
976             return
977 
978         wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)
979         for name, _ in node.names:
980             if name == "*" and not wildcard_import_is_allowed:
981                 self.add_message("wildcard-import", args=node.modname, node=node)
982 
983     def _wildcard_import_is_allowed(self, imported_module):
984         return (
985             self.config.allow_wildcard_with_all
986             and imported_module is not None
987             and "__all__" in imported_module.locals
988         )
989 
990     def _check_toplevel(self, node):
991         """Check whether the import is made outside the module toplevel."""
992         # If the scope of the import is a module, then obviously it is
993         # not outside the module toplevel.
994         if isinstance(node.scope(), astroid.Module):
995             return
996 
997         module_names = [
998             f"{node.modname}.{name[0]}"
999             if isinstance(node, astroid.ImportFrom)
1000             else name[0]
1001             for name in node.names
1002         ]
1003 
1004         # Get the full names of all the imports that are only allowed at the module level
1005         scoped_imports = [
1006             name for name in module_names if name not in self._allow_any_import_level
1007         ]
1008 
1009         if scoped_imports:
1010             self.add_message(
1011                 "import-outside-toplevel", args=", ".join(scoped_imports), node=node
1012             )
1013 
1014 
1015 def register(linter):
1016     """required method to auto register this checker"""
1017     linter.register_checker(ImportsChecker(linter))

</code><intended_behavior>This file likely contains logic for detecting unused imports. A modification or enhancement should be made here to include logic that recognizes and validates imports used in type comments. The checker should parse comments for variables, class attributes, and function annotations, identify type hints within these comments, and cross-reference these types with imported modules or objects. Such an enhancement would address the issue by not flagging imports as unused if they are referenced in type comments.</intended_behavior>, <file>pylint/utils/ast_walker.py</file>
<class>ASTWalker</class>
<method>None</method>
<code>
9 class ASTWalker:
10     def __init__(self, linter):
11         # callbacks per node types
12         self.nbstatements = 0
13         self.visit_events = collections.defaultdict(list)
14         self.leave_events = collections.defaultdict(list)
15         self.linter = linter
16         self.exception_msg = False
17 
18     def _is_method_enabled(self, method):
19         if not hasattr(method, "checks_msgs"):
20             return True
21         for msg_desc in method.checks_msgs:
22             if self.linter.is_message_enabled(msg_desc):
23                 return True
24         return False
25 
26     def add_checker(self, checker):
27         """walk to the checker's dir and collect visit and leave methods"""
28         vcids = set()
29         lcids = set()
30         visits = self.visit_events
31         leaves = self.leave_events
32         for member in dir(checker):
33             cid = member[6:]
34             if cid == "default":
35                 continue
36             if member.startswith("visit_"):
37                 v_meth = getattr(checker, member)
38                 # don't use visit_methods with no activated message:
39                 if self._is_method_enabled(v_meth):
40                     visits[cid].append(v_meth)
41                     vcids.add(cid)
42             elif member.startswith("leave_"):
43                 l_meth = getattr(checker, member)
44                 # don't use leave_methods with no activated message:
45                 if self._is_method_enabled(l_meth):
46                     leaves[cid].append(l_meth)
47                     lcids.add(cid)
48         visit_default = getattr(checker, "visit_default", None)
49         if visit_default:
50             for cls in nodes.ALL_NODE_CLASSES:
51                 cid = cls.__name__.lower()
52                 if cid not in vcids:
53                     visits[cid].append(visit_default)
54         # for now we have no "leave_default" method in Pylint
55 
56     def walk(self, astroid):
57         """call visit events of astroid checkers for the given node, recurse on
58         its children, then leave events.
59         """
60         cid = astroid.__class__.__name__.lower()
61 
62         # Detect if the node is a new name for a deprecated alias.
63         # In this case, favour the methods for the deprecated
64         # alias if any,  in order to maintain backwards
65         # compatibility.
66         visit_events = self.visit_events.get(cid, ())
67         leave_events = self.leave_events.get(cid, ())
68 
69         try:
70             if astroid.is_statement:
71                 self.nbstatements += 1
72             # generate events for this node on each checker
73             for callback in visit_events or ():
74                 callback(astroid)
75             # recurse on children
76             for child in astroid.get_children():
77                 self.walk(child)
78             for callback in leave_events or ():
79                 callback(astroid)
80         except Exception:
81             if self.exception_msg is False:
82                 file = getattr(astroid.root(), "file", None)
83                 print(f"Exception on node {repr(astroid)} in file '{file}'")
84                 self.exception_msg = True
85             raise

</code><intended_behavior>Adjustments to ensure type comments are adequately considered during the visitation of nodes related to import statements. The intended behavior would include enhancements to traverse and analyze comments adjacent to or within node structures that can have associated type hints (e.g., variable annotations, function signatures). This would ensure that the AST traversal logic supports identifying use cases of imported types within comments.</intended_behavior>]
2025-10-18 04:27:35.857 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 04:27:35.858 | INFO     | Search-only: skipping patch selection
2025-10-18 04:27:35.930 | INFO     | Task pylint-dev__pylint-4604 completed successfully.
2025-10-18 04:27:35.931 | INFO     | No patch generated. You can try running ACR again.
