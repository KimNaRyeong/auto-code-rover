2025-10-18 01:20:31.888 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 01:20:35.754 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=544, output_tokens=12, cost=0.005800
2025-10-18 01:20:35.755 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 01:20:35.759 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:20:45.575 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=849, output_tokens=430, cost=0.021390
2025-10-18 01:20:45.583 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:20:49.024 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=784, output_tokens=100, cost=0.010840
2025-10-18 01:20:49.025 | DEBUG    | Extracted a valid json.
2025-10-18 01:20:49.025 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"CsrfViewMiddleware\")",
        "search_method_in_class(\"process_view\", \"CsrfViewMiddleware\")",
        "search_method_in_class(\"_get_token\", \"CsrfViewMiddleware\")",
        "search_method_in_class(\"_get_new_csrf_token\", \"CsrfViewMiddleware\")",
        "search_method_in_class(\"process_request\", \"CsrfViewMiddleware\")"
    ],
    "bug_locations": []
}
2025-10-18 01:20:49.054 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 01:20:49.055 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 01:21:05.667 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3118, output_tokens=709, cost=0.052450
2025-10-18 01:21:05.683 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:21:13.059 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4043, output_tokens=322, cost=0.050090
2025-10-18 01:21:13.066 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:21:21.952 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=676, output_tokens=340, cost=0.016960
2025-10-18 01:21:21.954 | DEBUG    | Extracted a valid json.
2025-10-18 01:21:21.954 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"_get_new_csrf_token\")",
        "search_method(\"_sanitize_token\")"
    ],
    "bug_locations": [
        {
            "file": "django/middleware/csrf.py",
            "class": "CsrfViewMiddleware",
            "method": "_get_token",
            "intended_behavior": "The `_get_token` method needs to be modified to allow the `InvalidTokenFormat` exception to propagate when it encounters a cookie token with an invalid format (wrong length or containing invalid characters). This change will prevent the unnecessary generation of a new token and mask for a format-invalid token. Specifically, rather than catching the `InvalidTokenFormat` exception and generating a new token, the method should let this exception go unhandled, allowing the calling context (such as `process_view`) to take appropriate action based on the specific scenario (e.g., rejecting the request early)."
        },
        {
            "file": "django/middleware/csrf.py",
            "class": "CsrfViewMiddleware",
            "method": "process_view",
            "intended_behavior": "The `process_view` method should include additional exception handling logic for `InvalidTokenFormat`, which can arise from `_get_token`. Upon catching this exception, the method should immediately reject the request using the reason string from the exception, rather than proceeding with any further processing. This ensures that requests with CSRF cookies of incorrect formats are efficiently rejected early in the request lifecycle, without unnecessary computation or misleading response preparations. This update preserves the method's primary function while enhancing its efficiency and clarity in handling malformed CSRF tokens."
        }
    ]
}
2025-10-18 01:21:21.969 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 01:21:21.970 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 01:21:37.442 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4803, output_tokens=609, cost=0.066300
2025-10-18 01:21:37.453 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:21:45.358 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5628, output_tokens=333, cost=0.066270
2025-10-18 01:21:45.365 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:21:53.310 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=687, output_tokens=348, cost=0.017310
2025-10-18 01:21:53.311 | DEBUG    | Extracted a valid json.
2025-10-18 01:21:53.311 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/middleware/csrf.py",
            "class": "CsrfViewMiddleware",
            "method": "_get_token",
            "intended_behavior": "To address the issue, `_get_token` should be adjusted so that it does not proceed to generate a new token upon catching an `InvalidTokenFormat` exception raised by `_sanitize_token`. Instead, it should allow the `InvalidTokenFormat` exception to propagate. This change would enable `process_view` (or other calling contexts) to handle the exception appropriately by rejecting the request early without the additional, unnecessary steps of token regeneration. This exception handling strategy contributes directly to a more efficient request processing path, specifically for requests with invalid CSRF tokens, adhering to the fail-fast principle."
        },
        {
            "file": "django/middleware/csrf.py",
            "class": "CsrfViewMiddleware",
            "method": "process_view",
            "intended_behavior": "`process_view` should include an exception handling block specifically for `InvalidTokenFormat`. Upon catching this exception, it directly rejects the request using the reason included in the exception (e.g., incorrect length or invalid characters of the CSRF token). This behavior ensures a clearer and more immediate response to requests with invalid CSRF tokens, streamlining the middleware's protection mechanism against CSRF attacks and enhancing the debugging experience for developers. This update logically follows the more precise exception handling suggested for `_get_token`, completing the handling pathway for invalid token formats.\n\nThese modifications preserve the existing functionality of the CSRF protection mechanism while improving its efficiency and security posture in line with the issue's description."
        }
    ]
}
2025-10-18 01:21:53.320 | DEBUG    | Bug location extracted successfully: [<file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>_get_token</method>
<code>
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token

</code><intended_behavior>To address the issue, `_get_token` should be adjusted so that it does not proceed to generate a new token upon catching an `InvalidTokenFormat` exception raised by `_sanitize_token`. Instead, it should allow the `InvalidTokenFormat` exception to propagate. This change would enable `process_view` (or other calling contexts) to handle the exception appropriately by rejecting the request early without the additional, unnecessary steps of token regeneration. This exception handling strategy contributes directly to a more efficient request processing path, specifically for requests with invalid CSRF tokens, adhering to the fail-fast principle.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>process_view</method>
<code>
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)

</code><intended_behavior>`process_view` should include an exception handling block specifically for `InvalidTokenFormat`. Upon catching this exception, it directly rejects the request using the reason included in the exception (e.g., incorrect length or invalid characters of the CSRF token). This behavior ensures a clearer and more immediate response to requests with invalid CSRF tokens, streamlining the middleware's protection mechanism against CSRF attacks and enhancing the debugging experience for developers. This update logically follows the more precise exception handling suggested for `_get_token`, completing the handling pathway for invalid token formats.

These modifications preserve the existing functionality of the CSRF protection mechanism while improving its efficiency and security posture in line with the issue's description.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 01:21:53.320 | INFO     | Search completed. Bug locations: [<file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>_get_token</method>
<code>
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token

</code><intended_behavior>To address the issue, `_get_token` should be adjusted so that it does not proceed to generate a new token upon catching an `InvalidTokenFormat` exception raised by `_sanitize_token`. Instead, it should allow the `InvalidTokenFormat` exception to propagate. This change would enable `process_view` (or other calling contexts) to handle the exception appropriately by rejecting the request early without the additional, unnecessary steps of token regeneration. This exception handling strategy contributes directly to a more efficient request processing path, specifically for requests with invalid CSRF tokens, adhering to the fail-fast principle.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>process_view</method>
<code>
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)

</code><intended_behavior>`process_view` should include an exception handling block specifically for `InvalidTokenFormat`. Upon catching this exception, it directly rejects the request using the reason included in the exception (e.g., incorrect length or invalid characters of the CSRF token). This behavior ensures a clearer and more immediate response to requests with invalid CSRF tokens, streamlining the middleware's protection mechanism against CSRF attacks and enhancing the debugging experience for developers. This update logically follows the more precise exception handling suggested for `_get_token`, completing the handling pathway for invalid token formats.

These modifications preserve the existing functionality of the CSRF protection mechanism while improving its efficiency and security posture in line with the issue's description.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 01:21:53.320 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 01:21:53.321 | INFO     | Search-only: skipping patch selection
2025-10-18 01:21:53.453 | INFO     | Task django__django-14471 completed successfully.
2025-10-18 01:21:53.454 | INFO     | No patch generated. You can try running ACR again.
