[
    {
        "rel_file_path": "lib/matplotlib/backends/backend_pdf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.5/lib/matplotlib/backends/backend_pdf.py",
        "start": 2313,
        "end": 2411,
        "class_name": null,
        "method_name": "draw_text",
        "code": "2313     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n2314         # docstring inherited\n2315 \n2316         # TODO: combine consecutive texts into one BT/ET delimited section\n2317 \n2318         self.check_gc(gc, gc._rgb)\n2319         if ismath:\n2320             return self.draw_mathtext(gc, x, y, s, prop, angle)\n2321 \n2322         fontsize = prop.get_size_in_points()\n2323 \n2324         if mpl.rcParams['pdf.use14corefonts']:\n2325             font = self._get_font_afm(prop)\n2326             fonttype = 1\n2327         else:\n2328             font = self._get_font_ttf(prop)\n2329             self.file._character_tracker.track(font, s)\n2330             fonttype = mpl.rcParams['pdf.fonttype']\n2331 \n2332         if gc.get_url() is not None:\n2333             font.set_text(s)\n2334             width, height = font.get_width_height()\n2335             link_annotation = {\n2336                 'Type': Name('Annot'),\n2337                 'Subtype': Name('Link'),\n2338                 'Rect': (x, y, x + width / 64, y + height / 64),\n2339                 'Border': [0, 0, 0],\n2340                 'A': {\n2341                     'S': Name('URI'),\n2342                     'URI': gc.get_url(),\n2343                 },\n2344             }\n2345             self.file._annotations[-1][1].append(link_annotation)\n2346 \n2347         # If fonttype is neither 3 nor 42, emit the whole string at once\n2348         # without manual kerning.\n2349         if fonttype not in [3, 42]:\n2350             self.file.output(Op.begin_text,\n2351                              self.file.fontName(prop), fontsize, Op.selectfont)\n2352             self._setup_textpos(x, y, angle)\n2353             self.file.output(self.encode_string(s, fonttype),\n2354                              Op.show, Op.end_text)\n2355 \n2356         # A sequence of characters is broken into multiple chunks. The chunking\n2357         # serves two purposes:\n2358         #   - For Type 3 fonts, there is no way to access multibyte characters,\n2359         #     as they cannot have a CIDMap.  Therefore, in this case we break\n2360         #     the string into chunks, where each chunk contains either a string\n2361         #     of consecutive 1-byte characters or a single multibyte character.\n2362         #   - A sequence of 1-byte characters is split into chunks to allow for\n2363         #     kerning adjustments between consecutive chunks.\n2364         #\n2365         # Each chunk is emitted with a separate command: 1-byte characters use\n2366         # the regular text show command (TJ) with appropriate kerning between\n2367         # chunks, whereas multibyte characters use the XObject command (Do).\n2368         else:\n2369             # List of (start_x, [prev_kern, char, char, ...]), w/o zero kerns.\n2370             singlebyte_chunks = []\n2371             # List of (start_x, glyph_index).\n2372             multibyte_glyphs = []\n2373             prev_was_multibyte = True\n2374             for item in _text_helpers.layout(\n2375                     s, font, kern_mode=KERNING_UNFITTED):\n2376                 if _font_supports_glyph(fonttype, ord(item.char)):\n2377                     if prev_was_multibyte:\n2378                         singlebyte_chunks.append((item.x, []))\n2379                     if item.prev_kern:\n2380                         singlebyte_chunks[-1][1].append(item.prev_kern)\n2381                     singlebyte_chunks[-1][1].append(item.char)\n2382                     prev_was_multibyte = False\n2383                 else:\n2384                     multibyte_glyphs.append((item.x, item.glyph_idx))\n2385                     prev_was_multibyte = True\n2386             # Do the rotation and global translation as a single matrix\n2387             # concatenation up front\n2388             self.file.output(Op.gsave)\n2389             a = math.radians(angle)\n2390             self.file.output(math.cos(a), math.sin(a),\n2391                              -math.sin(a), math.cos(a),\n2392                              x, y, Op.concat_matrix)\n2393             # Emit all the 1-byte characters in a BT/ET group.\n2394             self.file.output(Op.begin_text,\n2395                              self.file.fontName(prop), fontsize, Op.selectfont)\n2396             prev_start_x = 0\n2397             for start_x, kerns_or_chars in singlebyte_chunks:\n2398                 self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n2399                 self.file.output(\n2400                     # See pdf spec \"Text space details\" for the 1000/fontsize\n2401                     # (aka. 1000/T_fs) factor.\n2402                     [-1000 * next(group) / fontsize if tp == float  # a kern\n2403                      else self.encode_string(\"\".join(group), fonttype)\n2404                      for tp, group in itertools.groupby(kerns_or_chars, type)],\n2405                     Op.showkern)\n2406                 prev_start_x = start_x\n2407             self.file.output(Op.end_text)\n2408             # Then emit all the multibyte characters, one at a time.\n2409             for start_x, glyph_idx in multibyte_glyphs:\n2410                 self._draw_xobject_glyph(font, fontsize, glyph_idx, start_x, 0)\n2411             self.file.output(Op.grestore)\n",
        "intended_behavior": "The `draw_text` method within the PDF backend should be updated or extended to include handling of the `QuadPoints` attribute for text elements with URLs. When text is rotated, the method should calculate the appropriate `QuadPoints` that define the actual, visually rotated clickable area for the hyperlink. This ensures that the clickable area for the URL matches the rotated orientation of the text, providing an intuitive user experience. The implementation should fall back to using the rectangular (`Rect`) clickable area in scenarios where `QuadPoints` is not supported by the viewer. This update should preserve all existing text rendering functionalities, ensuring that text appearance and other properties (like font, size, color) remain unaffected by changes introduced to support clickable area rotation."
    },
    {
        "rel_file_path": "lib/matplotlib/backends/backend_pdf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.5/lib/matplotlib/backends/backend_pdf.py",
        "start": 2313,
        "end": 2411,
        "class_name": "RendererPdf",
        "method_name": "draw_text",
        "code": "2313     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n2314         # docstring inherited\n2315 \n2316         # TODO: combine consecutive texts into one BT/ET delimited section\n2317 \n2318         self.check_gc(gc, gc._rgb)\n2319         if ismath:\n2320             return self.draw_mathtext(gc, x, y, s, prop, angle)\n2321 \n2322         fontsize = prop.get_size_in_points()\n2323 \n2324         if mpl.rcParams['pdf.use14corefonts']:\n2325             font = self._get_font_afm(prop)\n2326             fonttype = 1\n2327         else:\n2328             font = self._get_font_ttf(prop)\n2329             self.file._character_tracker.track(font, s)\n2330             fonttype = mpl.rcParams['pdf.fonttype']\n2331 \n2332         if gc.get_url() is not None:\n2333             font.set_text(s)\n2334             width, height = font.get_width_height()\n2335             link_annotation = {\n2336                 'Type': Name('Annot'),\n2337                 'Subtype': Name('Link'),\n2338                 'Rect': (x, y, x + width / 64, y + height / 64),\n2339                 'Border': [0, 0, 0],\n2340                 'A': {\n2341                     'S': Name('URI'),\n2342                     'URI': gc.get_url(),\n2343                 },\n2344             }\n2345             self.file._annotations[-1][1].append(link_annotation)\n2346 \n2347         # If fonttype is neither 3 nor 42, emit the whole string at once\n2348         # without manual kerning.\n2349         if fonttype not in [3, 42]:\n2350             self.file.output(Op.begin_text,\n2351                              self.file.fontName(prop), fontsize, Op.selectfont)\n2352             self._setup_textpos(x, y, angle)\n2353             self.file.output(self.encode_string(s, fonttype),\n2354                              Op.show, Op.end_text)\n2355 \n2356         # A sequence of characters is broken into multiple chunks. The chunking\n2357         # serves two purposes:\n2358         #   - For Type 3 fonts, there is no way to access multibyte characters,\n2359         #     as they cannot have a CIDMap.  Therefore, in this case we break\n2360         #     the string into chunks, where each chunk contains either a string\n2361         #     of consecutive 1-byte characters or a single multibyte character.\n2362         #   - A sequence of 1-byte characters is split into chunks to allow for\n2363         #     kerning adjustments between consecutive chunks.\n2364         #\n2365         # Each chunk is emitted with a separate command: 1-byte characters use\n2366         # the regular text show command (TJ) with appropriate kerning between\n2367         # chunks, whereas multibyte characters use the XObject command (Do).\n2368         else:\n2369             # List of (start_x, [prev_kern, char, char, ...]), w/o zero kerns.\n2370             singlebyte_chunks = []\n2371             # List of (start_x, glyph_index).\n2372             multibyte_glyphs = []\n2373             prev_was_multibyte = True\n2374             for item in _text_helpers.layout(\n2375                     s, font, kern_mode=KERNING_UNFITTED):\n2376                 if _font_supports_glyph(fonttype, ord(item.char)):\n2377                     if prev_was_multibyte:\n2378                         singlebyte_chunks.append((item.x, []))\n2379                     if item.prev_kern:\n2380                         singlebyte_chunks[-1][1].append(item.prev_kern)\n2381                     singlebyte_chunks[-1][1].append(item.char)\n2382                     prev_was_multibyte = False\n2383                 else:\n2384                     multibyte_glyphs.append((item.x, item.glyph_idx))\n2385                     prev_was_multibyte = True\n2386             # Do the rotation and global translation as a single matrix\n2387             # concatenation up front\n2388             self.file.output(Op.gsave)\n2389             a = math.radians(angle)\n2390             self.file.output(math.cos(a), math.sin(a),\n2391                              -math.sin(a), math.cos(a),\n2392                              x, y, Op.concat_matrix)\n2393             # Emit all the 1-byte characters in a BT/ET group.\n2394             self.file.output(Op.begin_text,\n2395                              self.file.fontName(prop), fontsize, Op.selectfont)\n2396             prev_start_x = 0\n2397             for start_x, kerns_or_chars in singlebyte_chunks:\n2398                 self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n2399                 self.file.output(\n2400                     # See pdf spec \"Text space details\" for the 1000/fontsize\n2401                     # (aka. 1000/T_fs) factor.\n2402                     [-1000 * next(group) / fontsize if tp == float  # a kern\n2403                      else self.encode_string(\"\".join(group), fonttype)\n2404                      for tp, group in itertools.groupby(kerns_or_chars, type)],\n2405                     Op.showkern)\n2406                 prev_start_x = start_x\n2407             self.file.output(Op.end_text)\n2408             # Then emit all the multibyte characters, one at a time.\n2409             for start_x, glyph_idx in multibyte_glyphs:\n2410                 self._draw_xobject_glyph(font, fontsize, glyph_idx, start_x, 0)\n2411             self.file.output(Op.grestore)\n",
        "intended_behavior": "The `draw_text` method within the PDF backend should be updated or extended to include handling of the `QuadPoints` attribute for text elements with URLs. When text is rotated, the method should calculate the appropriate `QuadPoints` that define the actual, visually rotated clickable area for the hyperlink. This ensures that the clickable area for the URL matches the rotated orientation of the text, providing an intuitive user experience. The implementation should fall back to using the rectangular (`Rect`) clickable area in scenarios where `QuadPoints` is not supported by the viewer. This update should preserve all existing text rendering functionalities, ensuring that text appearance and other properties (like font, size, color) remain unaffected by changes introduced to support clickable area rotation."
    }
]