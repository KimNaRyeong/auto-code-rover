[
    {
        "rel_file_path": "sympy/stats/crv_types.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/crv_types.py",
        "start": 1,
        "end": 3353,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Continuous Random Variables - Prebuilt variables\n3 \n4 Contains\n5 ========\n6 Arcsin\n7 Benini\n8 Beta\n9 BetaNoncentral\n10 BetaPrime\n11 Cauchy\n12 Chi\n13 ChiNoncentral\n14 ChiSquared\n15 Dagum\n16 Erlang\n17 Exponential\n18 FDistribution\n19 FisherZ\n20 Frechet\n21 Gamma\n22 GammaInverse\n23 Gumbel\n24 Gompertz\n25 Kumaraswamy\n26 Laplace\n27 Logistic\n28 LogNormal\n29 Maxwell\n30 Nakagami\n31 Normal\n32 Pareto\n33 QuadraticU\n34 RaisedCosine\n35 Rayleigh\n36 ShiftedGompertz\n37 StudentT\n38 Trapezoidal\n39 Triangular\n40 Uniform\n41 UniformSum\n42 VonMises\n43 Weibull\n44 WignerSemicircle\n45 \"\"\"\n46 \n47 from __future__ import print_function, division\n48 \n49 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,\n50                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,\n51                    Lambda, Basic, lowergamma, erf, erfi,  erfinv, I, hyper,\n52                    uppergamma, sinh, atan, Ne, expint)\n53 \n54 from sympy import beta as beta_fn\n55 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk\n56 from sympy.external import import_module\n57 from sympy.matrices import MatrixBase\n58 from sympy.stats.crv import (SingleContinuousPSpace, SingleContinuousDistribution,\n59         ContinuousDistributionHandmade)\n60 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution\n61 from sympy.stats.joint_rv_types import multivariate_rv\n62 from sympy.stats.rv import _value_check, RandomSymbol\n63 import random\n64 \n65 oo = S.Infinity\n66 \n67 __all__ = ['ContinuousRV',\n68 'Arcsin',\n69 'Benini',\n70 'Beta',\n71 'BetaNoncentral',\n72 'BetaPrime',\n73 'Cauchy',\n74 'Chi',\n75 'ChiNoncentral',\n76 'ChiSquared',\n77 'Dagum',\n78 'Erlang',\n79 'Exponential',\n80 'FDistribution',\n81 'FisherZ',\n82 'Frechet',\n83 'Gamma',\n84 'GammaInverse',\n85 'Gompertz',\n86 'Gumbel',\n87 'Kumaraswamy',\n88 'Laplace',\n89 'Logistic',\n90 'LogNormal',\n91 'Maxwell',\n92 'Nakagami',\n93 'Normal',\n94 'Pareto',\n95 'QuadraticU',\n96 'RaisedCosine',\n97 'Rayleigh',\n98 'StudentT',\n99 'ShiftedGompertz',\n100 'Trapezoidal',\n101 'Triangular',\n102 'Uniform',\n103 'UniformSum',\n104 'VonMises',\n105 'Weibull',\n106 'WignerSemicircle'\n107 ]\n108 \n109 \n110 \n111 def ContinuousRV(symbol, density, set=Interval(-oo, oo)):\n112     \"\"\"\n113     Create a Continuous Random Variable given the following:\n114 \n115     -- a symbol\n116     -- a probability density function\n117     -- set on which the pdf is valid (defaults to entire real line)\n118 \n119     Returns a RandomSymbol.\n120 \n121     Many common continuous random variable types are already implemented.\n122     This function should be necessary only very rarely.\n123 \n124     Examples\n125     ========\n126 \n127     >>> from sympy import Symbol, sqrt, exp, pi\n128     >>> from sympy.stats import ContinuousRV, P, E\n129 \n130     >>> x = Symbol(\"x\")\n131 \n132     >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution\n133     >>> X = ContinuousRV(x, pdf)\n134 \n135     >>> E(X)\n136     0\n137     >>> P(X>0)\n138     1/2\n139     \"\"\"\n140     pdf = Piecewise((density, set.as_relational(symbol)), (0, True))\n141     pdf = Lambda(symbol, pdf)\n142     dist = ContinuousDistributionHandmade(pdf, set)\n143     return SingleContinuousPSpace(symbol, dist).value\n144 \n145 \n146 def rv(symbol, cls, args):\n147     args = list(map(sympify, args))\n148     dist = cls(*args)\n149     dist.check(*args)\n150     pspace = SingleContinuousPSpace(symbol, dist)\n151     if any(isinstance(arg, RandomSymbol) for arg in args):\n152         pspace = JointPSpace(symbol, CompoundDistribution(dist))\n153     return pspace.value\n154 \n155 ########################################\n156 # Continuous Probability Distributions #\n157 ########################################\n158 \n159 #-------------------------------------------------------------------------------\n160 # Arcsin distribution ----------------------------------------------------------\n161 \n162 \n163 class ArcsinDistribution(SingleContinuousDistribution):\n164     _argnames = ('a', 'b')\n165 \n166     def pdf(self, x):\n167         return 1/(pi*sqrt((x - self.a)*(self.b - x)))\n168 \n169     def _cdf(self, x):\n170         from sympy import asin\n171         a, b = self.a, self.b\n172         return Piecewise(\n173             (S.Zero, x < a),\n174             (2*asin(sqrt((x - a)/(b - a)))/pi, x <= b),\n175             (S.One, True))\n176 \n177 \n178 def Arcsin(name, a=0, b=1):\n179     r\"\"\"\n180     Create a Continuous Random Variable with an arcsin distribution.\n181 \n182     The density of the arcsin distribution is given by\n183 \n184     .. math::\n185         f(x) := \\frac{1}{\\pi\\sqrt{(x-a)(b-x)}}\n186 \n187     with :math:`x \\in (a,b)`. It must hold that :math:`-\\infty < a < b < \\infty`.\n188 \n189     Parameters\n190     ==========\n191 \n192     a : Real number, the left interval boundary\n193     b : Real number, the right interval boundary\n194 \n195     Returns\n196     =======\n197 \n198     A RandomSymbol.\n199 \n200     Examples\n201     ========\n202 \n203     >>> from sympy.stats import Arcsin, density, cdf\n204     >>> from sympy import Symbol, simplify\n205 \n206     >>> a = Symbol(\"a\", real=True)\n207     >>> b = Symbol(\"b\", real=True)\n208     >>> z = Symbol(\"z\")\n209 \n210     >>> X = Arcsin(\"x\", a, b)\n211 \n212     >>> density(X)(z)\n213     1/(pi*sqrt((-a + z)*(b - z)))\n214 \n215     >>> cdf(X)(z)\n216     Piecewise((0, a > z),\n217             (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),\n218             (1, True))\n219 \n220 \n221     References\n222     ==========\n223 \n224     .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution\n225 \n226     \"\"\"\n227 \n228     return rv(name, ArcsinDistribution, (a, b))\n229 \n230 #-------------------------------------------------------------------------------\n231 # Benini distribution ----------------------------------------------------------\n232 \n233 \n234 class BeniniDistribution(SingleContinuousDistribution):\n235     _argnames = ('alpha', 'beta', 'sigma')\n236 \n237     @staticmethod\n238     def check(alpha, beta, sigma):\n239         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n240         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n241         _value_check(sigma > 0, \"Scale parameter Sigma must be positive.\")\n242 \n243     @property\n244     def set(self):\n245         return Interval(self.sigma, oo)\n246 \n247     def pdf(self, x):\n248         alpha, beta, sigma = self.alpha, self.beta, self.sigma\n249         return (exp(-alpha*log(x/sigma) - beta*log(x/sigma)**2)\n250                *(alpha/x + 2*beta*log(x/sigma)/x))\n251 \n252     def _moment_generating_function(self, t):\n253         raise NotImplementedError('The moment generating function of the '\n254                                   'Benini distribution does not exist.')\n255 \n256 def Benini(name, alpha, beta, sigma):\n257     r\"\"\"\n258     Create a Continuous Random Variable with a Benini distribution.\n259 \n260     The density of the Benini distribution is given by\n261 \n262     .. math::\n263         f(x) := e^{-\\alpha\\log{\\frac{x}{\\sigma}}\n264                 -\\beta\\log^2\\left[{\\frac{x}{\\sigma}}\\right]}\n265                 \\left(\\frac{\\alpha}{x}+\\frac{2\\beta\\log{\\frac{x}{\\sigma}}}{x}\\right)\n266 \n267     This is a heavy-tailed distrubtion and is also known as the log-Rayleigh\n268     distribution.\n269 \n270     Parameters\n271     ==========\n272 \n273     alpha : Real number, `\\alpha > 0`, a shape\n274     beta : Real number, `\\beta > 0`, a shape\n275     sigma : Real number, `\\sigma > 0`, a scale\n276 \n277     Returns\n278     =======\n279 \n280     A RandomSymbol.\n281 \n282     Examples\n283     ========\n284 \n285     >>> from sympy.stats import Benini, density, cdf\n286     >>> from sympy import Symbol, simplify, pprint\n287 \n288     >>> alpha = Symbol(\"alpha\", positive=True)\n289     >>> beta = Symbol(\"beta\", positive=True)\n290     >>> sigma = Symbol(\"sigma\", positive=True)\n291     >>> z = Symbol(\"z\")\n292 \n293     >>> X = Benini(\"x\", alpha, beta, sigma)\n294 \n295     >>> D = density(X)(z)\n296     >>> pprint(D, use_unicode=False)\n297     /                  /  z  \\\\             /  z  \\            2/  z  \\\n298     |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|\n299     |alpha             \\sigma/|             \\sigma/             \\sigma/\n300     |----- + -----------------|*e\n301     \\  z             z        /\n302 \n303     >>> cdf(X)(z)\n304     Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),\n305             (0, True))\n306 \n307 \n308     References\n309     ==========\n310 \n311     .. [1] https://en.wikipedia.org/wiki/Benini_distribution\n312     .. [2] http://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html\n313 \n314     \"\"\"\n315 \n316     return rv(name, BeniniDistribution, (alpha, beta, sigma))\n317 \n318 #-------------------------------------------------------------------------------\n319 # Beta distribution ------------------------------------------------------------\n320 \n321 \n322 class BetaDistribution(SingleContinuousDistribution):\n323     _argnames = ('alpha', 'beta')\n324 \n325     set = Interval(0, 1)\n326 \n327     @staticmethod\n328     def check(alpha, beta):\n329         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n330         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n331 \n332     def pdf(self, x):\n333         alpha, beta = self.alpha, self.beta\n334         return x**(alpha - 1) * (1 - x)**(beta - 1) / beta_fn(alpha, beta)\n335 \n336     def sample(self):\n337         return random.betavariate(self.alpha, self.beta)\n338 \n339     def _characteristic_function(self, t):\n340         return hyper((self.alpha,), (self.alpha + self.beta,), I*t)\n341 \n342     def _moment_generating_function(self, t):\n343         return hyper((self.alpha,), (self.alpha + self.beta,), t)\n344 \n345 def Beta(name, alpha, beta):\n346     r\"\"\"\n347     Create a Continuous Random Variable with a Beta distribution.\n348 \n349     The density of the Beta distribution is given by\n350 \n351     .. math::\n352         f(x) := \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\n353 \n354     with :math:`x \\in [0,1]`.\n355 \n356     Parameters\n357     ==========\n358 \n359     alpha : Real number, `\\alpha > 0`, a shape\n360     beta : Real number, `\\beta > 0`, a shape\n361 \n362     Returns\n363     =======\n364 \n365     A RandomSymbol.\n366 \n367     Examples\n368     ========\n369 \n370     >>> from sympy.stats import Beta, density, E, variance\n371     >>> from sympy import Symbol, simplify, pprint, factor\n372 \n373     >>> alpha = Symbol(\"alpha\", positive=True)\n374     >>> beta = Symbol(\"beta\", positive=True)\n375     >>> z = Symbol(\"z\")\n376 \n377     >>> X = Beta(\"x\", alpha, beta)\n378 \n379     >>> D = density(X)(z)\n380     >>> pprint(D, use_unicode=False)\n381      alpha - 1        beta - 1\n382     z         *(1 - z)\n383     --------------------------\n384           B(alpha, beta)\n385 \n386     >>> simplify(E(X))\n387     alpha/(alpha + beta)\n388 \n389     >>> factor(simplify(variance(X)))  #doctest: +SKIP\n390     alpha*beta/((alpha + beta)**2*(alpha + beta + 1))\n391 \n392     References\n393     ==========\n394 \n395     .. [1] https://en.wikipedia.org/wiki/Beta_distribution\n396     .. [2] http://mathworld.wolfram.com/BetaDistribution.html\n397 \n398     \"\"\"\n399 \n400     return rv(name, BetaDistribution, (alpha, beta))\n401 \n402 #-------------------------------------------------------------------------------\n403 # Noncentral Beta distribution ------------------------------------------------------------\n404 \n405 \n406 class BetaNoncentralDistribution(SingleContinuousDistribution):\n407     _argnames = ('alpha', 'beta', 'lamda')\n408 \n409     set = Interval(0, 1)\n410 \n411     @staticmethod\n412     def check(alpha, beta, lamda):\n413         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n414         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n415         _value_check(lamda >= 0, \"Noncentrality parameter Lambda must be positive\")\n416 \n417     def pdf(self, x):\n418         alpha, beta, lamda = self.alpha, self.beta, self.lamda\n419         k = Dummy(\"k\")\n420         return Sum(exp(-lamda / 2) * (lamda / 2)**k * x**(alpha + k - 1) *(\n421             1 - x)**(beta - 1) / (factorial(k) * beta_fn(alpha + k, beta)), (k, 0, oo))\n422 \n423 def BetaNoncentral(name, alpha, beta, lamda):\n424     r\"\"\"\n425     Create a Continuous Random Variable with a Type I Noncentral Beta distribution.\n426 \n427     The density of the Noncentral Beta distribution is given by\n428 \n429     .. math::\n430         f(x) := \\sum_{k=0}^\\infty e^{-\\lambda/2}\\frac{(\\lambda/2)^k}{k!}\n431                 \\frac{x^{\\alpha+k-1}(1-x)^{\\beta-1}}{\\mathrm{B}(\\alpha+k,\\beta)}\n432 \n433     with :math:`x \\in [0,1]`.\n434 \n435     Parameters\n436     ==========\n437 \n438     alpha : Real number, `\\alpha > 0`, a shape\n439     beta : Real number, `\\beta > 0`, a shape\n440     lamda: Real number, `\\lambda >= 0`, noncentrality parameter\n441 \n442     Returns\n443     =======\n444 \n445     A RandomSymbol.\n446 \n447     Examples\n448     ========\n449 \n450     >>> from sympy.stats import BetaNoncentral, density, cdf\n451     >>> from sympy import Symbol, pprint\n452 \n453     >>> alpha = Symbol(\"alpha\", positive=True)\n454     >>> beta = Symbol(\"beta\", positive=True)\n455     >>> lamda = Symbol(\"lamda\", nonnegative=True)\n456     >>> z = Symbol(\"z\")\n457 \n458     >>> X = BetaNoncentral(\"x\", alpha, beta, lamda)\n459 \n460     >>> D = density(X)(z)\n461     >>> pprint(D, use_unicode=False)\n462       oo\n463     _____\n464     \\    `\n465      \\                                              -lamda\n466       \\                          k                  -------\n467        \\    k + alpha - 1 /lamda\\         beta - 1     2\n468         )  z             *|-----| *(1 - z)        *e\n469        /                  \\  2  /\n470       /    ------------------------------------------------\n471      /                  B(k + alpha, beta)*k!\n472     /____,\n473     k = 0\n474 \n475     Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows :\n476     >>> cdf(BetaNoncentral(\"x\", 1, 1, 1), evaluate=False)(2).doit()\n477     exp(-1/2)*Integral(Sum(2**(-_k)*_x**_k/(beta(_k + 1, 1)*factorial(_k)), (_k, 0, oo)), (_x, 0, 2))\n478 \n479     The argument evaluate=False prevents an attempt at evaluation\n480     of the sum for general x, before the argument 2 is passed.\n481 \n482     References\n483     ==========\n484 \n485     .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution\n486     .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html\n487 \n488     \"\"\"\n489 \n490     return rv(name, BetaNoncentralDistribution, (alpha, beta, lamda))\n491 \n492 \n493 #-------------------------------------------------------------------------------\n494 # Beta prime distribution ------------------------------------------------------\n495 \n496 \n497 class BetaPrimeDistribution(SingleContinuousDistribution):\n498     _argnames = ('alpha', 'beta')\n499 \n500     @staticmethod\n501     def check(alpha, beta):\n502         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n503         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n504 \n505     set = Interval(0, oo)\n506 \n507     def pdf(self, x):\n508         alpha, beta = self.alpha, self.beta\n509         return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)\n510 \n511 def BetaPrime(name, alpha, beta):\n512     r\"\"\"\n513     Create a continuous random variable with a Beta prime distribution.\n514 \n515     The density of the Beta prime distribution is given by\n516 \n517     .. math::\n518         f(x) := \\frac{x^{\\alpha-1} (1+x)^{-\\alpha -\\beta}}{B(\\alpha,\\beta)}\n519 \n520     with :math:`x > 0`.\n521 \n522     Parameters\n523     ==========\n524 \n525     alpha : Real number, `\\alpha > 0`, a shape\n526     beta : Real number, `\\beta > 0`, a shape\n527 \n528     Returns\n529     =======\n530 \n531     A RandomSymbol.\n532 \n533     Examples\n534     ========\n535 \n536     >>> from sympy.stats import BetaPrime, density\n537     >>> from sympy import Symbol, pprint\n538 \n539     >>> alpha = Symbol(\"alpha\", positive=True)\n540     >>> beta = Symbol(\"beta\", positive=True)\n541     >>> z = Symbol(\"z\")\n542 \n543     >>> X = BetaPrime(\"x\", alpha, beta)\n544 \n545     >>> D = density(X)(z)\n546     >>> pprint(D, use_unicode=False)\n547      alpha - 1        -alpha - beta\n548     z         *(z + 1)\n549     -------------------------------\n550              B(alpha, beta)\n551 \n552     References\n553     ==========\n554 \n555     .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution\n556     .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html\n557 \n558     \"\"\"\n559 \n560     return rv(name, BetaPrimeDistribution, (alpha, beta))\n561 \n562 #-------------------------------------------------------------------------------\n563 # Cauchy distribution ----------------------------------------------------------\n564 \n565 \n566 class CauchyDistribution(SingleContinuousDistribution):\n567     _argnames = ('x0', 'gamma')\n568 \n569     @staticmethod\n570     def check(x0, gamma):\n571         _value_check(gamma > 0, \"Scale parameter Gamma must be positive.\")\n572 \n573     def pdf(self, x):\n574         return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))\n575 \n576     def _cdf(self, x):\n577         x0, gamma = self.x0, self.gamma\n578         return (1/pi)*atan((x - x0)/gamma) + S.Half\n579 \n580     def _characteristic_function(self, t):\n581         return exp(self.x0 * I * t -  self.gamma * Abs(t))\n582 \n583     def _moment_generating_function(self, t):\n584         raise NotImplementedError(\"The moment generating function for the \"\n585                                   \"Cauchy distribution does not exist.\")\n586 \n587     def _quantile(self, p):\n588         return self.x0 + self.gamma*tan(pi*(p - S.Half))\n589 \n590 def Cauchy(name, x0, gamma):\n591     r\"\"\"\n592     Create a continuous random variable with a Cauchy distribution.\n593 \n594     The density of the Cauchy distribution is given by\n595 \n596     .. math::\n597         f(x) := \\frac{1}{\\pi \\gamma [1 + {(\\frac{x-x_0}{\\gamma})}^2]}\n598 \n599     Parameters\n600     ==========\n601 \n602     x0 : Real number, the location\n603     gamma : Real number, `\\gamma > 0`, a scale\n604 \n605     Returns\n606     =======\n607 \n608     A RandomSymbol.\n609 \n610     Examples\n611     ========\n612 \n613     >>> from sympy.stats import Cauchy, density\n614     >>> from sympy import Symbol\n615 \n616     >>> x0 = Symbol(\"x0\")\n617     >>> gamma = Symbol(\"gamma\", positive=True)\n618     >>> z = Symbol(\"z\")\n619 \n620     >>> X = Cauchy(\"x\", x0, gamma)\n621 \n622     >>> density(X)(z)\n623     1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))\n624 \n625     References\n626     ==========\n627 \n628     .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution\n629     .. [2] http://mathworld.wolfram.com/CauchyDistribution.html\n630 \n631     \"\"\"\n632 \n633     return rv(name, CauchyDistribution, (x0, gamma))\n634 \n635 #-------------------------------------------------------------------------------\n636 # Chi distribution -------------------------------------------------------------\n637 \n638 \n639 class ChiDistribution(SingleContinuousDistribution):\n640     _argnames = ('k',)\n641 \n642     @staticmethod\n643     def check(k):\n644         _value_check(k > 0, \"Number of degrees of freedom (k) must be positive.\")\n645         _value_check(k.is_integer, \"Number of degrees of freedom (k) must be an integer.\")\n646 \n647     set = Interval(0, oo)\n648 \n649     def pdf(self, x):\n650         return 2**(1 - self.k/2)*x**(self.k - 1)*exp(-x**2/2)/gamma(self.k/2)\n651 \n652     def _characteristic_function(self, t):\n653         k = self.k\n654 \n655         part_1 = hyper((k/2,), (S(1)/2,), -t**2/2)\n656         part_2 = I*t*sqrt(2)*gamma((k+1)/2)/gamma(k/2)\n657         part_3 = hyper(((k+1)/2,), (S(3)/2,), -t**2/2)\n658         return part_1 + part_2*part_3\n659 \n660     def _moment_generating_function(self, t):\n661         k = self.k\n662 \n663         part_1 = hyper((k / 2,), (S(1) / 2,), t ** 2 / 2)\n664         part_2 = t * sqrt(2) * gamma((k + 1) / 2) / gamma(k / 2)\n665         part_3 = hyper(((k + 1) / 2,), (S(3) / 2,), t ** 2 / 2)\n666         return part_1 + part_2 * part_3\n667 \n668 def Chi(name, k):\n669     r\"\"\"\n670     Create a continuous random variable with a Chi distribution.\n671 \n672     The density of the Chi distribution is given by\n673 \n674     .. math::\n675         f(x) := \\frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\\Gamma(k/2)}\n676 \n677     with :math:`x \\geq 0`.\n678 \n679     Parameters\n680     ==========\n681 \n682     k : Positive integer, The number of degrees of freedom\n683 \n684     Returns\n685     =======\n686 \n687     A RandomSymbol.\n688 \n689     Examples\n690     ========\n691 \n692     >>> from sympy.stats import Chi, density, E\n693     >>> from sympy import Symbol, simplify\n694 \n695     >>> k = Symbol(\"k\", integer=True)\n696     >>> z = Symbol(\"z\")\n697 \n698     >>> X = Chi(\"x\", k)\n699 \n700     >>> density(X)(z)\n701     2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)\n702 \n703     >>> simplify(E(X))\n704     sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)\n705 \n706     References\n707     ==========\n708 \n709     .. [1] https://en.wikipedia.org/wiki/Chi_distribution\n710     .. [2] http://mathworld.wolfram.com/ChiDistribution.html\n711 \n712     \"\"\"\n713 \n714     return rv(name, ChiDistribution, (k,))\n715 \n716 #-------------------------------------------------------------------------------\n717 # Non-central Chi distribution -------------------------------------------------\n718 \n719 \n720 class ChiNoncentralDistribution(SingleContinuousDistribution):\n721     _argnames = ('k', 'l')\n722 \n723     @staticmethod\n724     def check(k, l):\n725         _value_check(k > 0, \"Number of degrees of freedom (k) must be positive.\")\n726         _value_check(k.is_integer, \"Number of degrees of freedom (k) must be an integer.\")\n727         _value_check(l > 0, \"Shift parameter Lambda must be positive.\")\n728 \n729     set = Interval(0, oo)\n730 \n731     def pdf(self, x):\n732         k, l = self.k, self.l\n733         return exp(-(x**2+l**2)/2)*x**k*l / (l*x)**(k/2) * besseli(k/2-1, l*x)\n734 \n735 def ChiNoncentral(name, k, l):\n736     r\"\"\"\n737     Create a continuous random variable with a non-central Chi distribution.\n738 \n739     The density of the non-central Chi distribution is given by\n740 \n741     .. math::\n742         f(x) := \\frac{e^{-(x^2+\\lambda^2)/2} x^k\\lambda}\n743                 {(\\lambda x)^{k/2}} I_{k/2-1}(\\lambda x)\n744 \n745     with `x \\geq 0`. Here, `I_\\nu (x)` is the\n746     :ref:`modified Bessel function of the first kind <besseli>`.\n747 \n748     Parameters\n749     ==========\n750 \n751     k : A positive Integer, `k > 0`, the number of degrees of freedom\n752     lambda : Real number, `\\lambda > 0`, Shift parameter\n753 \n754     Returns\n755     =======\n756 \n757     A RandomSymbol.\n758 \n759     Examples\n760     ========\n761 \n762     >>> from sympy.stats import ChiNoncentral, density\n763     >>> from sympy import Symbol\n764 \n765     >>> k = Symbol(\"k\", integer=True)\n766     >>> l = Symbol(\"l\")\n767     >>> z = Symbol(\"z\")\n768 \n769     >>> X = ChiNoncentral(\"x\", k, l)\n770 \n771     >>> density(X)(z)\n772     l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)\n773 \n774     References\n775     ==========\n776 \n777     .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution\n778     \"\"\"\n779 \n780     return rv(name, ChiNoncentralDistribution, (k, l))\n781 \n782 #-------------------------------------------------------------------------------\n783 # Chi squared distribution -----------------------------------------------------\n784 \n785 \n786 class ChiSquaredDistribution(SingleContinuousDistribution):\n787     _argnames = ('k',)\n788 \n789     @staticmethod\n790     def check(k):\n791         _value_check(k > 0, \"Number of degrees of freedom (k) must be positive.\")\n792         _value_check(k.is_integer, \"Number of degrees of freedom (k) must be an integer.\")\n793 \n794     set = Interval(0, oo)\n795 \n796     def pdf(self, x):\n797         k = self.k\n798         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)\n799 \n800     def _cdf(self, x):\n801         k = self.k\n802         return Piecewise(\n803                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),\n804                 (0, True)\n805         )\n806 \n807     def _characteristic_function(self, t):\n808         return (1 - 2*I*t)**(-self.k/2)\n809 \n810     def  _moment_generating_function(self, t):\n811         return (1 - 2*t)**(-self.k/2)\n812 \n813 def ChiSquared(name, k):\n814     r\"\"\"\n815     Create a continuous random variable with a Chi-squared distribution.\n816 \n817     The density of the Chi-squared distribution is given by\n818 \n819     .. math::\n820         f(x) := \\frac{1}{2^{\\frac{k}{2}}\\Gamma\\left(\\frac{k}{2}\\right)}\n821                 x^{\\frac{k}{2}-1} e^{-\\frac{x}{2}}\n822 \n823     with :math:`x \\geq 0`.\n824 \n825     Parameters\n826     ==========\n827 \n828     k : Positive integer, The number of degrees of freedom\n829 \n830     Returns\n831     =======\n832 \n833     A RandomSymbol.\n834 \n835     Examples\n836     ========\n837 \n838     >>> from sympy.stats import ChiSquared, density, E, variance, moment\n839     >>> from sympy import Symbol\n840 \n841     >>> k = Symbol(\"k\", integer=True, positive=True)\n842     >>> z = Symbol(\"z\")\n843 \n844     >>> X = ChiSquared(\"x\", k)\n845 \n846     >>> density(X)(z)\n847     2**(-k/2)*z**(k/2 - 1)*exp(-z/2)/gamma(k/2)\n848 \n849     >>> E(X)\n850     k\n851 \n852     >>> variance(X)\n853     2*k\n854 \n855     >>> moment(X, 3)\n856     k**3 + 6*k**2 + 8*k\n857 \n858     References\n859     ==========\n860 \n861     .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution\n862     .. [2] http://mathworld.wolfram.com/Chi-SquaredDistribution.html\n863     \"\"\"\n864 \n865     return rv(name, ChiSquaredDistribution, (k, ))\n866 \n867 #-------------------------------------------------------------------------------\n868 # Dagum distribution -----------------------------------------------------------\n869 \n870 \n871 class DagumDistribution(SingleContinuousDistribution):\n872     _argnames = ('p', 'a', 'b')\n873 \n874     @staticmethod\n875     def check(p, a, b):\n876         _value_check(p > 0, \"Shape parameter p must be positive.\")\n877         _value_check(a > 0, \"Shape parameter a must be positive.\")\n878         _value_check(b > 0, \"Scale parameter b must be positive.\")\n879 \n880     def pdf(self, x):\n881         p, a, b = self.p, self.a, self.b\n882         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))\n883 \n884     def _cdf(self, x):\n885         p, a, b = self.p, self.a, self.b\n886         return Piecewise(((S.One + (S(x)/b)**-a)**-p, x>=0),\n887                     (S.Zero, True))\n888 \n889 def Dagum(name, p, a, b):\n890     r\"\"\"\n891     Create a continuous random variable with a Dagum distribution.\n892 \n893     The density of the Dagum distribution is given by\n894 \n895     .. math::\n896         f(x) := \\frac{a p}{x} \\left( \\frac{\\left(\\tfrac{x}{b}\\right)^{a p}}\n897                 {\\left(\\left(\\tfrac{x}{b}\\right)^a + 1 \\right)^{p+1}} \\right)\n898 \n899     with :math:`x > 0`.\n900 \n901     Parameters\n902     ==========\n903 \n904     p : Real number, `p > 0`, a shape\n905     a : Real number, `a > 0`, a shape\n906     b : Real number, `b > 0`, a scale\n907 \n908     Returns\n909     =======\n910 \n911     A RandomSymbol.\n912 \n913     Examples\n914     ========\n915 \n916     >>> from sympy.stats import Dagum, density, cdf\n917     >>> from sympy import Symbol\n918 \n919     >>> p = Symbol(\"p\", positive=True)\n920     >>> a = Symbol(\"a\", positive=True)\n921     >>> b = Symbol(\"b\", positive=True)\n922     >>> z = Symbol(\"z\")\n923 \n924     >>> X = Dagum(\"x\", p, a, b)\n925 \n926     >>> density(X)(z)\n927     a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z\n928 \n929     >>> cdf(X)(z)\n930     Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))\n931 \n932 \n933     References\n934     ==========\n935 \n936     .. [1] https://en.wikipedia.org/wiki/Dagum_distribution\n937 \n938     \"\"\"\n939 \n940     return rv(name, DagumDistribution, (p, a, b))\n941 \n942 #-------------------------------------------------------------------------------\n943 # Erlang distribution ----------------------------------------------------------\n944 \n945 \n946 def Erlang(name, k, l):\n947     r\"\"\"\n948     Create a continuous random variable with an Erlang distribution.\n949 \n950     The density of the Erlang distribution is given by\n951 \n952     .. math::\n953         f(x) := \\frac{\\lambda^k x^{k-1} e^{-\\lambda x}}{(k-1)!}\n954 \n955     with :math:`x \\in [0,\\infty]`.\n956 \n957     Parameters\n958     ==========\n959 \n960     k : Positive integer\n961     l : Real number, `\\lambda > 0`, the rate\n962 \n963     Returns\n964     =======\n965 \n966     A RandomSymbol.\n967 \n968     Examples\n969     ========\n970 \n971     >>> from sympy.stats import Erlang, density, cdf, E, variance\n972     >>> from sympy import Symbol, simplify, pprint\n973 \n974     >>> k = Symbol(\"k\", integer=True, positive=True)\n975     >>> l = Symbol(\"l\", positive=True)\n976     >>> z = Symbol(\"z\")\n977 \n978     >>> X = Erlang(\"x\", k, l)\n979 \n980     >>> D = density(X)(z)\n981     >>> pprint(D, use_unicode=False)\n982      k  k - 1  -l*z\n983     l *z     *e\n984     ---------------\n985         Gamma(k)\n986 \n987     >>> C = cdf(X)(z)\n988     >>> pprint(C, use_unicode=False)\n989     /lowergamma(k, l*z)\n990     |------------------  for z > 0\n991     <     Gamma(k)\n992     |\n993     \\        0           otherwise\n994 \n995 \n996     >>> E(X)\n997     k/l\n998 \n999     >>> simplify(variance(X))\n1000     k/l**2\n1001 \n1002     References\n1003     ==========\n1004 \n1005     .. [1] https://en.wikipedia.org/wiki/Erlang_distribution\n1006     .. [2] http://mathworld.wolfram.com/ErlangDistribution.html\n1007 \n1008     \"\"\"\n1009 \n1010     return rv(name, GammaDistribution, (k, S.One/l))\n1011 \n1012 #-------------------------------------------------------------------------------\n1013 # Exponential distribution -----------------------------------------------------\n1014 \n1015 \n1016 class ExponentialDistribution(SingleContinuousDistribution):\n1017     _argnames = ('rate',)\n1018 \n1019     set  = Interval(0, oo)\n1020 \n1021     @staticmethod\n1022     def check(rate):\n1023         _value_check(rate > 0, \"Rate must be positive.\")\n1024 \n1025     def pdf(self, x):\n1026         return self.rate * exp(-self.rate*x)\n1027 \n1028     def sample(self):\n1029         return random.expovariate(self.rate)\n1030 \n1031     def _cdf(self, x):\n1032         return Piecewise(\n1033                 (S.One - exp(-self.rate*x), x >= 0),\n1034                 (0, True),\n1035         )\n1036 \n1037     def _characteristic_function(self, t):\n1038         rate = self.rate\n1039         return rate / (rate - I*t)\n1040 \n1041     def _moment_generating_function(self, t):\n1042         rate = self.rate\n1043         return rate / (rate - t)\n1044 \n1045     def _quantile(self, p):\n1046         return -log(1-p)/self.rate\n1047 \n1048 def Exponential(name, rate):\n1049     r\"\"\"\n1050     Create a continuous random variable with an Exponential distribution.\n1051 \n1052     The density of the exponential distribution is given by\n1053 \n1054     .. math::\n1055         f(x) := \\lambda \\exp(-\\lambda x)\n1056 \n1057     with `x > 0`. Note that the expected value is `1/\\lambda`.\n1058 \n1059     Parameters\n1060     ==========\n1061 \n1062     rate : A positive Real number, `\\lambda > 0`, the rate (or inverse scale/inverse mean)\n1063 \n1064     Returns\n1065     =======\n1066 \n1067     A RandomSymbol.\n1068 \n1069     Examples\n1070     ========\n1071 \n1072     >>> from sympy.stats import Exponential, density, cdf, E\n1073     >>> from sympy.stats import variance, std, skewness, quantile\n1074     >>> from sympy import Symbol, symbols\n1075 \n1076     >>> l = Symbol(\"lambda\", positive=True)\n1077     >>> z = Symbol(\"z\")\n1078     >>> p = Symbol(\"p\")\n1079     >>> X = Exponential(\"x\", l)\n1080 \n1081     >>> density(X)(z)\n1082     lambda*exp(-lambda*z)\n1083 \n1084     >>> cdf(X)(z)\n1085     Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))\n1086 \n1087     >>> quantile(X)(p)\n1088     -log(1 - p)/lambda\n1089 \n1090     >>> E(X)\n1091     1/lambda\n1092 \n1093     >>> variance(X)\n1094     lambda**(-2)\n1095 \n1096     >>> skewness(X)\n1097     2\n1098 \n1099     >>> X = Exponential('x', 10)\n1100 \n1101     >>> density(X)(z)\n1102     10*exp(-10*z)\n1103 \n1104     >>> E(X)\n1105     1/10\n1106 \n1107     >>> std(X)\n1108     1/10\n1109 \n1110     References\n1111     ==========\n1112 \n1113     .. [1] https://en.wikipedia.org/wiki/Exponential_distribution\n1114     .. [2] http://mathworld.wolfram.com/ExponentialDistribution.html\n1115 \n1116     \"\"\"\n1117 \n1118     return rv(name, ExponentialDistribution, (rate, ))\n1119 \n1120 #-------------------------------------------------------------------------------\n1121 # F distribution ---------------------------------------------------------------\n1122 \n1123 \n1124 class FDistributionDistribution(SingleContinuousDistribution):\n1125     _argnames = ('d1', 'd2')\n1126 \n1127     set = Interval(0, oo)\n1128 \n1129     @staticmethod\n1130     def check(d1, d2):\n1131         _value_check((d1 > 0, d1.is_integer),\n1132             \"Degrees of freedom d1 must be positive integer.\")\n1133         _value_check((d2 > 0, d2.is_integer),\n1134             \"Degrees of freedom d2 must be positive integer.\")\n1135 \n1136     def pdf(self, x):\n1137         d1, d2 = self.d1, self.d2\n1138         return (sqrt((d1*x)**d1*d2**d2 / (d1*x+d2)**(d1+d2))\n1139                / (x * beta_fn(d1/2, d2/2)))\n1140 \n1141     def _moment_generating_function(self, t):\n1142         raise NotImplementedError('The moment generating function for the '\n1143                                   'F-distribution does not exist.')\n1144 \n1145 def FDistribution(name, d1, d2):\n1146     r\"\"\"\n1147     Create a continuous random variable with a F distribution.\n1148 \n1149     The density of the F distribution is given by\n1150 \n1151     .. math::\n1152         f(x) := \\frac{\\sqrt{\\frac{(d_1 x)^{d_1} d_2^{d_2}}\n1153                 {(d_1 x + d_2)^{d_1 + d_2}}}}\n1154                 {x \\mathrm{B} \\left(\\frac{d_1}{2}, \\frac{d_2}{2}\\right)}\n1155 \n1156     with :math:`x > 0`.\n1157 \n1158     Parameters\n1159     ==========\n1160 \n1161     d1 : `d_1 > 0`, where d_1 is the degrees of freedom (n_1 - 1)\n1162     d2 : `d_2 > 0`, where d_2 is the degrees of freedom (n_2 - 1)\n1163 \n1164     Returns\n1165     =======\n1166 \n1167     A RandomSymbol.\n1168 \n1169     Examples\n1170     ========\n1171 \n1172     >>> from sympy.stats import FDistribution, density\n1173     >>> from sympy import Symbol, simplify, pprint\n1174 \n1175     >>> d1 = Symbol(\"d1\", positive=True)\n1176     >>> d2 = Symbol(\"d2\", positive=True)\n1177     >>> z = Symbol(\"z\")\n1178 \n1179     >>> X = FDistribution(\"x\", d1, d2)\n1180 \n1181     >>> D = density(X)(z)\n1182     >>> pprint(D, use_unicode=False)\n1183       d2\n1184       --    ______________________________\n1185       2    /       d1            -d1 - d2\n1186     d2  *\\/  (d1*z)  *(d1*z + d2)\n1187     --------------------------------------\n1188                     /d1  d2\\\n1189                  z*B|--, --|\n1190                     \\2   2 /\n1191 \n1192     References\n1193     ==========\n1194 \n1195     .. [1] https://en.wikipedia.org/wiki/F-distribution\n1196     .. [2] http://mathworld.wolfram.com/F-Distribution.html\n1197 \n1198     \"\"\"\n1199 \n1200     return rv(name, FDistributionDistribution, (d1, d2))\n1201 \n1202 #-------------------------------------------------------------------------------\n1203 # Fisher Z distribution --------------------------------------------------------\n1204 \n1205 class FisherZDistribution(SingleContinuousDistribution):\n1206     _argnames = ('d1', 'd2')\n1207 \n1208     def pdf(self, x):\n1209         d1, d2 = self.d1, self.d2\n1210         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *\n1211                exp(d1*x) / (d1*exp(2*x)+d2)**((d1+d2)/2))\n1212 \n1213 def FisherZ(name, d1, d2):\n1214     r\"\"\"\n1215     Create a Continuous Random Variable with an Fisher's Z distribution.\n1216 \n1217     The density of the Fisher's Z distribution is given by\n1218 \n1219     .. math::\n1220         f(x) := \\frac{2d_1^{d_1/2} d_2^{d_2/2}} {\\mathrm{B}(d_1/2, d_2/2)}\n1221                 \\frac{e^{d_1z}}{\\left(d_1e^{2z}+d_2\\right)^{\\left(d_1+d_2\\right)/2}}\n1222 \n1223 \n1224     .. TODO - What is the difference between these degrees of freedom?\n1225 \n1226     Parameters\n1227     ==========\n1228 \n1229     d1 : `d_1 > 0`, degree of freedom\n1230     d2 : `d_2 > 0`, degree of freedom\n1231 \n1232     Returns\n1233     =======\n1234 \n1235     A RandomSymbol.\n1236 \n1237     Examples\n1238     ========\n1239 \n1240     >>> from sympy.stats import FisherZ, density\n1241     >>> from sympy import Symbol, simplify, pprint\n1242 \n1243     >>> d1 = Symbol(\"d1\", positive=True)\n1244     >>> d2 = Symbol(\"d2\", positive=True)\n1245     >>> z = Symbol(\"z\")\n1246 \n1247     >>> X = FisherZ(\"x\", d1, d2)\n1248 \n1249     >>> D = density(X)(z)\n1250     >>> pprint(D, use_unicode=False)\n1251                                 d1   d2\n1252         d1   d2               - -- - --\n1253         --   --                 2    2\n1254         2    2  /    2*z     \\           d1*z\n1255     2*d1  *d2  *\\d1*e    + d2/         *e\n1256     -----------------------------------------\n1257                      /d1  d2\\\n1258                     B|--, --|\n1259                      \\2   2 /\n1260 \n1261     References\n1262     ==========\n1263 \n1264     .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution\n1265     .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html\n1266 \n1267     \"\"\"\n1268 \n1269     return rv(name, FisherZDistribution, (d1, d2))\n1270 \n1271 #-------------------------------------------------------------------------------\n1272 # Frechet distribution ---------------------------------------------------------\n1273 \n1274 class FrechetDistribution(SingleContinuousDistribution):\n1275     _argnames = ('a', 's', 'm')\n1276 \n1277     set = Interval(0, oo)\n1278 \n1279     def __new__(cls, a, s=1, m=0):\n1280         a, s, m = list(map(sympify, (a, s, m)))\n1281         return Basic.__new__(cls, a, s, m)\n1282 \n1283     def pdf(self, x):\n1284         a, s, m = self.a, self.s, self.m\n1285         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n1286 \n1287     def _cdf(self, x):\n1288         a, s, m = self.a, self.s, self.m\n1289         return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),\n1290                         (S.Zero, True))\n1291 \n1292 def Frechet(name, a, s=1, m=0):\n1293     r\"\"\"\n1294     Create a continuous random variable with a Frechet distribution.\n1295 \n1296     The density of the Frechet distribution is given by\n1297 \n1298     .. math::\n1299         f(x) := \\frac{\\alpha}{s} \\left(\\frac{x-m}{s}\\right)^{-1-\\alpha}\n1300                  e^{-(\\frac{x-m}{s})^{-\\alpha}}\n1301 \n1302     with :math:`x \\geq m`.\n1303 \n1304     Parameters\n1305     ==========\n1306 \n1307     a : Real number, :math:`a \\in \\left(0, \\infty\\right)` the shape\n1308     s : Real number, :math:`s \\in \\left(0, \\infty\\right)` the scale\n1309     m : Real number, :math:`m \\in \\left(-\\infty, \\infty\\right)` the minimum\n1310 \n1311     Returns\n1312     =======\n1313 \n1314     A RandomSymbol.\n1315 \n1316     Examples\n1317     ========\n1318 \n1319     >>> from sympy.stats import Frechet, density, E, std, cdf\n1320     >>> from sympy import Symbol, simplify\n1321 \n1322     >>> a = Symbol(\"a\", positive=True)\n1323     >>> s = Symbol(\"s\", positive=True)\n1324     >>> m = Symbol(\"m\", real=True)\n1325     >>> z = Symbol(\"z\")\n1326 \n1327     >>> X = Frechet(\"x\", a, s, m)\n1328 \n1329     >>> density(X)(z)\n1330     a*((-m + z)/s)**(-a - 1)*exp(-((-m + z)/s)**(-a))/s\n1331 \n1332     >>> cdf(X)(z)\n1333      Piecewise((exp(-((-m + z)/s)**(-a)), m <= z), (0, True))\n1334 \n1335     References\n1336     ==========\n1337 \n1338     .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution\n1339 \n1340     \"\"\"\n1341 \n1342     return rv(name, FrechetDistribution, (a, s, m))\n1343 \n1344 #-------------------------------------------------------------------------------\n1345 # Gamma distribution -----------------------------------------------------------\n1346 \n1347 \n1348 class GammaDistribution(SingleContinuousDistribution):\n1349     _argnames = ('k', 'theta')\n1350 \n1351     set = Interval(0, oo)\n1352 \n1353     @staticmethod\n1354     def check(k, theta):\n1355         _value_check(k > 0, \"k must be positive\")\n1356         _value_check(theta > 0, \"Theta must be positive\")\n1357 \n1358     def pdf(self, x):\n1359         k, theta = self.k, self.theta\n1360         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)\n1361 \n1362     def sample(self):\n1363         return random.gammavariate(self.k, self.theta)\n1364 \n1365     def _cdf(self, x):\n1366         k, theta = self.k, self.theta\n1367         return Piecewise(\n1368                     (lowergamma(k, S(x)/theta)/gamma(k), x > 0),\n1369                     (S.Zero, True))\n1370 \n1371     def _characteristic_function(self, t):\n1372         return (1 - self.theta*I*t)**(-self.k)\n1373 \n1374     def _moment_generating_function(self, t):\n1375         return (1- self.theta*t)**(-self.k)\n1376 \n1377 def Gamma(name, k, theta):\n1378     r\"\"\"\n1379     Create a continuous random variable with a Gamma distribution.\n1380 \n1381     The density of the Gamma distribution is given by\n1382 \n1383     .. math::\n1384         f(x) := \\frac{1}{\\Gamma(k) \\theta^k} x^{k - 1} e^{-\\frac{x}{\\theta}}\n1385 \n1386     with :math:`x \\in [0,1]`.\n1387 \n1388     Parameters\n1389     ==========\n1390 \n1391     k : Real number, `k > 0`, a shape\n1392     theta : Real number, `\\theta > 0`, a scale\n1393 \n1394     Returns\n1395     =======\n1396 \n1397     A RandomSymbol.\n1398 \n1399     Examples\n1400     ========\n1401 \n1402     >>> from sympy.stats import Gamma, density, cdf, E, variance\n1403     >>> from sympy import Symbol, pprint, simplify\n1404 \n1405     >>> k = Symbol(\"k\", positive=True)\n1406     >>> theta = Symbol(\"theta\", positive=True)\n1407     >>> z = Symbol(\"z\")\n1408 \n1409     >>> X = Gamma(\"x\", k, theta)\n1410 \n1411     >>> D = density(X)(z)\n1412     >>> pprint(D, use_unicode=False)\n1413                       -z\n1414                     -----\n1415          -k  k - 1  theta\n1416     theta  *z     *e\n1417     ---------------------\n1418            Gamma(k)\n1419 \n1420     >>> C = cdf(X, meijerg=True)(z)\n1421     >>> pprint(C, use_unicode=False)\n1422     /            /     z  \\\n1423     |k*lowergamma|k, -----|\n1424     |            \\   theta/\n1425     <----------------------  for z >= 0\n1426     |     Gamma(k + 1)\n1427     |\n1428     \\          0             otherwise\n1429 \n1430     >>> E(X)\n1431     k*theta\n1432 \n1433     >>> V = simplify(variance(X))\n1434     >>> pprint(V, use_unicode=False)\n1435            2\n1436     k*theta\n1437 \n1438 \n1439     References\n1440     ==========\n1441 \n1442     .. [1] https://en.wikipedia.org/wiki/Gamma_distribution\n1443     .. [2] http://mathworld.wolfram.com/GammaDistribution.html\n1444 \n1445     \"\"\"\n1446 \n1447     return rv(name, GammaDistribution, (k, theta))\n1448 \n1449 #-------------------------------------------------------------------------------\n1450 # Inverse Gamma distribution ---------------------------------------------------\n1451 \n1452 \n1453 class GammaInverseDistribution(SingleContinuousDistribution):\n1454     _argnames = ('a', 'b')\n1455 \n1456     set = Interval(0, oo)\n1457 \n1458     @staticmethod\n1459     def check(a, b):\n1460         _value_check(a > 0, \"alpha must be positive\")\n1461         _value_check(b > 0, \"beta must be positive\")\n1462 \n1463     def pdf(self, x):\n1464         a, b = self.a, self.b\n1465         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)\n1466 \n1467     def _cdf(self, x):\n1468         a, b = self.a, self.b\n1469         return Piecewise((uppergamma(a,b/x)/gamma(a), x > 0),\n1470                         (S.Zero, True))\n1471 \n1472     def sample(self):\n1473         scipy = import_module('scipy')\n1474         if scipy:\n1475             from scipy.stats import invgamma\n1476             return invgamma.rvs(float(self.a), 0, float(self.b))\n1477         else:\n1478             raise NotImplementedError('Sampling the inverse Gamma Distribution requires Scipy.')\n1479 \n1480     def _characteristic_function(self, t):\n1481         a, b = self.a, self.b\n1482         return 2 * (-I*b*t)**(a/2) * besselk(sqrt(-4*I*b*t)) / gamma(a)\n1483 \n1484     def _moment_generating_function(self, t):\n1485         raise NotImplementedError('The moment generating function for the '\n1486                                   'gamma inverse distribution does not exist.')\n1487 \n1488 def GammaInverse(name, a, b):\n1489     r\"\"\"\n1490     Create a continuous random variable with an inverse Gamma distribution.\n1491 \n1492     The density of the inverse Gamma distribution is given by\n1493 \n1494     .. math::\n1495         f(x) := \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{-\\alpha - 1}\n1496                 \\exp\\left(\\frac{-\\beta}{x}\\right)\n1497 \n1498     with :math:`x > 0`.\n1499 \n1500     Parameters\n1501     ==========\n1502 \n1503     a : Real number, `a > 0` a shape\n1504     b : Real number, `b > 0` a scale\n1505 \n1506     Returns\n1507     =======\n1508 \n1509     A RandomSymbol.\n1510 \n1511     Examples\n1512     ========\n1513 \n1514     >>> from sympy.stats import GammaInverse, density, cdf, E, variance\n1515     >>> from sympy import Symbol, pprint\n1516 \n1517     >>> a = Symbol(\"a\", positive=True)\n1518     >>> b = Symbol(\"b\", positive=True)\n1519     >>> z = Symbol(\"z\")\n1520 \n1521     >>> X = GammaInverse(\"x\", a, b)\n1522 \n1523     >>> D = density(X)(z)\n1524     >>> pprint(D, use_unicode=False)\n1525                 -b\n1526                 ---\n1527      a  -a - 1   z\n1528     b *z      *e\n1529     ---------------\n1530        Gamma(a)\n1531 \n1532     >>> cdf(X)(z)\n1533     Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))\n1534 \n1535 \n1536     References\n1537     ==========\n1538 \n1539     .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution\n1540 \n1541     \"\"\"\n1542 \n1543     return rv(name, GammaInverseDistribution, (a, b))\n1544 \n1545 #-------------------------------------------------------------------------------\n1546 # Gumbel distribution --------------------------------------------------------\n1547 \n1548 \n1549 class GumbelDistribution(SingleContinuousDistribution):\n1550     _argnames = ('beta', 'mu')\n1551 \n1552     set = Interval(-oo, oo)\n1553 \n1554     def pdf(self, x):\n1555         beta, mu = self.beta, self.mu\n1556         z = (x - mu)/beta\n1557         return (1/beta)*exp(-(z + exp(-z)))\n1558 \n1559     def _cdf(self, x):\n1560         beta, mu = self.beta, self.mu\n1561         return exp(-exp((mu - x)/beta))\n1562 \n1563     def _characteristic_function(self, t):\n1564         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)\n1565 \n1566     def _moment_generating_function(self, t):\n1567         return gamma(1 - self.beta*t) * exp(I*self.mu*t)\n1568 \n1569 def Gumbel(name, beta, mu):\n1570     r\"\"\"\n1571     Create a Continuous Random Variable with Gumbel distribution.\n1572 \n1573     The density of the Gumbel distribution is given by\n1574 \n1575     .. math::\n1576         f(x) := \\dfrac{1}{\\beta} \\exp \\left( -\\dfrac{x-\\mu}{\\beta}\n1577                 - \\exp \\left( -\\dfrac{x - \\mu}{\\beta} \\right) \\right)\n1578 \n1579     with :math:`x \\in [ - \\infty, \\infty ]`.\n1580 \n1581     Parameters\n1582     ==========\n1583 \n1584     mu: Real number, 'mu' is a location\n1585     beta: Real number, 'beta > 0' is a scale\n1586 \n1587     Returns\n1588     ==========\n1589 \n1590     A RandomSymbol\n1591 \n1592     Examples\n1593     ==========\n1594     >>> from sympy.stats import Gumbel, density, E, variance, cdf\n1595     >>> from sympy import Symbol, simplify, pprint\n1596     >>> x = Symbol(\"x\")\n1597     >>> mu = Symbol(\"mu\")\n1598     >>> beta = Symbol(\"beta\", positive=True)\n1599     >>> X = Gumbel(\"x\", beta, mu)\n1600     >>> density(X)(x)\n1601     exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta\n1602     >>> cdf(X)(x)\n1603     exp(-exp((mu - x)/beta))\n1604 \n1605     References\n1606     ==========\n1607 \n1608     .. [1] http://mathworld.wolfram.com/GumbelDistribution.html\n1609     .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution\n1610 \n1611     \"\"\"\n1612     return rv(name, GumbelDistribution, (beta, mu))\n1613 \n1614 #-------------------------------------------------------------------------------\n1615 # Gompertz distribution --------------------------------------------------------\n1616 \n1617 class GompertzDistribution(SingleContinuousDistribution):\n1618     _argnames = ('b', 'eta')\n1619 \n1620     set = Interval(0, oo)\n1621 \n1622     @staticmethod\n1623     def check(b, eta):\n1624         _value_check(b > 0, \"b must be positive\")\n1625         _value_check(eta > 0, \"eta must be positive\")\n1626 \n1627     def pdf(self, x):\n1628         eta, b = self.eta, self.b\n1629         return b*eta*exp(b*x)*exp(eta)*exp(-eta*exp(b*x))\n1630 \n1631     def _cdf(self, x):\n1632         eta, b = self.eta, self.b\n1633         return 1 - exp(eta)*exp(-eta*exp(b*x))\n1634 \n1635     def _moment_generating_function(self, t):\n1636         eta, b = self.eta, self.b\n1637         return eta * exp(eta) * expint(t/b, eta)\n1638 \n1639 def Gompertz(name, b, eta):\n1640     r\"\"\"\n1641     Create a Continuous Random Variable with Gompertz distribution.\n1642 \n1643     The density of the Gompertz distribution is given by\n1644 \n1645     .. math::\n1646         f(x) := b \\eta e^{b x} e^{\\eta} \\exp \\left(-\\eta e^{bx} \\right)\n1647 \n1648     with :math: 'x \\in [0, \\inf)'.\n1649 \n1650     Parameters\n1651     ==========\n1652 \n1653     b: Real number, 'b > 0' a scale\n1654     eta: Real number, 'eta > 0' a shape\n1655 \n1656     Returns\n1657     =======\n1658 \n1659     A RandomSymbol.\n1660 \n1661     Examples\n1662     ========\n1663 \n1664     >>> from sympy.stats import Gompertz, density, E, variance\n1665     >>> from sympy import Symbol, simplify, pprint\n1666 \n1667     >>> b = Symbol(\"b\", positive=True)\n1668     >>> eta = Symbol(\"eta\", positive=True)\n1669     >>> z = Symbol(\"z\")\n1670 \n1671     >>> X = Gompertz(\"x\", b, eta)\n1672 \n1673     >>> density(X)(z)\n1674     b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))\n1675 \n1676     References\n1677     ==========\n1678 \n1679     .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution\n1680 \n1681     \"\"\"\n1682     return rv(name, GompertzDistribution, (b, eta))\n1683 \n1684 #-------------------------------------------------------------------------------\n1685 # Kumaraswamy distribution -----------------------------------------------------\n1686 \n1687 \n1688 class KumaraswamyDistribution(SingleContinuousDistribution):\n1689     _argnames = ('a', 'b')\n1690 \n1691     set = Interval(0, oo)\n1692 \n1693     @staticmethod\n1694     def check(a, b):\n1695         _value_check(a > 0, \"a must be positive\")\n1696         _value_check(b > 0, \"b must be positive\")\n1697 \n1698     def pdf(self, x):\n1699         a, b = self.a, self.b\n1700         return a * b * x**(a-1) * (1-x**a)**(b-1)\n1701 \n1702     def _cdf(self, x):\n1703         a, b = self.a, self.b\n1704         return Piecewise(\n1705             (S.Zero, x < S.Zero),\n1706             (1 - (1 - x**a)**b, x <= S.One),\n1707             (S.One, True))\n1708 \n1709 def Kumaraswamy(name, a, b):\n1710     r\"\"\"\n1711     Create a Continuous Random Variable with a Kumaraswamy distribution.\n1712 \n1713     The density of the Kumaraswamy distribution is given by\n1714 \n1715     .. math::\n1716         f(x) := a b x^{a-1} (1-x^a)^{b-1}\n1717 \n1718     with :math:`x \\in [0,1]`.\n1719 \n1720     Parameters\n1721     ==========\n1722 \n1723     a : Real number, `a > 0` a shape\n1724     b : Real number, `b > 0` a shape\n1725 \n1726     Returns\n1727     =======\n1728 \n1729     A RandomSymbol.\n1730 \n1731     Examples\n1732     ========\n1733 \n1734     >>> from sympy.stats import Kumaraswamy, density, E, variance, cdf\n1735     >>> from sympy import Symbol, simplify, pprint\n1736 \n1737     >>> a = Symbol(\"a\", positive=True)\n1738     >>> b = Symbol(\"b\", positive=True)\n1739     >>> z = Symbol(\"z\")\n1740 \n1741     >>> X = Kumaraswamy(\"x\", a, b)\n1742 \n1743     >>> D = density(X)(z)\n1744     >>> pprint(D, use_unicode=False)\n1745                        b - 1\n1746          a - 1 /     a\\\n1747     a*b*z     *\\1 - z /\n1748 \n1749     >>> cdf(X)(z)\n1750     Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))\n1751 \n1752     References\n1753     ==========\n1754 \n1755     .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution\n1756 \n1757     \"\"\"\n1758 \n1759     return rv(name, KumaraswamyDistribution, (a, b))\n1760 \n1761 #-------------------------------------------------------------------------------\n1762 # Laplace distribution ---------------------------------------------------------\n1763 \n1764 \n1765 class LaplaceDistribution(SingleContinuousDistribution):\n1766     _argnames = ('mu', 'b')\n1767 \n1768     def pdf(self, x):\n1769         mu, b = self.mu, self.b\n1770         return 1/(2*b)*exp(-Abs(x - mu)/b)\n1771 \n1772     def _cdf(self, x):\n1773         mu, b = self.mu, self.b\n1774         return Piecewise(\n1775                     (S.Half*exp((x - mu)/b), x < mu),\n1776                     (S.One - S.Half*exp(-(x - mu)/b), x >= mu)\n1777                         )\n1778 \n1779     def _characteristic_function(self, t):\n1780         return exp(self.mu*I*t) / (1 + self.b**2*t**2)\n1781 \n1782     def _moment_generating_function(self, t):\n1783         return exp(self.mu*t) / (1 - self.b**2*t**2)\n1784 \n1785 def Laplace(name, mu, b):\n1786     r\"\"\"\n1787     Create a continuous random variable with a Laplace distribution.\n1788 \n1789     The density of the Laplace distribution is given by\n1790 \n1791     .. math::\n1792         f(x) := \\frac{1}{2 b} \\exp \\left(-\\frac{|x-\\mu|}b \\right)\n1793 \n1794     Parameters\n1795     ==========\n1796 \n1797     mu : Real number or a list/matrix, the location (mean) or the\n1798         location vector\n1799     b : Real number or a positive definite matrix, representing a scale\n1800         or the covariance matrix.\n1801 \n1802     Returns\n1803     =======\n1804 \n1805     A RandomSymbol.\n1806 \n1807     Examples\n1808     ========\n1809 \n1810     >>> from sympy.stats import Laplace, density, cdf\n1811     >>> from sympy import Symbol, pprint\n1812 \n1813     >>> mu = Symbol(\"mu\")\n1814     >>> b = Symbol(\"b\", positive=True)\n1815     >>> z = Symbol(\"z\")\n1816 \n1817     >>> X = Laplace(\"x\", mu, b)\n1818 \n1819     >>> density(X)(z)\n1820     exp(-Abs(mu - z)/b)/(2*b)\n1821 \n1822     >>> cdf(X)(z)\n1823     Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))\n1824 \n1825     >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])\n1826     >>> pprint(density(L)(1, 2), use_unicode=False)\n1827      5        /     ____\\\n1828     e *besselk\\0, \\/ 35 /\n1829     ---------------------\n1830               pi\n1831 \n1832     References\n1833     ==========\n1834 \n1835     .. [1] https://en.wikipedia.org/wiki/Laplace_distribution\n1836     .. [2] http://mathworld.wolfram.com/LaplaceDistribution.html\n1837 \n1838     \"\"\"\n1839 \n1840     if isinstance(mu, (list, MatrixBase)) and\\\n1841         isinstance(b, (list, MatrixBase)):\n1842         from sympy.stats.joint_rv_types import MultivariateLaplaceDistribution\n1843         return multivariate_rv(\n1844             MultivariateLaplaceDistribution, name, mu, b)\n1845 \n1846     return rv(name, LaplaceDistribution, (mu, b))\n1847 \n1848 #-------------------------------------------------------------------------------\n1849 # Logistic distribution --------------------------------------------------------\n1850 \n1851 \n1852 class LogisticDistribution(SingleContinuousDistribution):\n1853     _argnames = ('mu', 's')\n1854 \n1855     def pdf(self, x):\n1856         mu, s = self.mu, self.s\n1857         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)\n1858 \n1859     def _cdf(self, x):\n1860         mu, s = self.mu, self.s\n1861         return S.One/(1 + exp(-(x - mu)/s))\n1862 \n1863     def _characteristic_function(self, t):\n1864         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))\n1865 \n1866     def _moment_generating_function(self, t):\n1867         return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)\n1868 \n1869     def _quantile(self, p):\n1870         return self.mu - self.s*log(-S.One + S.One/p)\n1871 \n1872 def Logistic(name, mu, s):\n1873     r\"\"\"\n1874     Create a continuous random variable with a logistic distribution.\n1875 \n1876     The density of the logistic distribution is given by\n1877 \n1878     .. math::\n1879         f(x) := \\frac{e^{-(x-\\mu)/s}} {s\\left(1+e^{-(x-\\mu)/s}\\right)^2}\n1880 \n1881     Parameters\n1882     ==========\n1883 \n1884     mu : Real number, the location (mean)\n1885     s : Real number, `s > 0` a scale\n1886 \n1887     Returns\n1888     =======\n1889 \n1890     A RandomSymbol.\n1891 \n1892     Examples\n1893     ========\n1894 \n1895     >>> from sympy.stats import Logistic, density, cdf\n1896     >>> from sympy import Symbol\n1897 \n1898     >>> mu = Symbol(\"mu\", real=True)\n1899     >>> s = Symbol(\"s\", positive=True)\n1900     >>> z = Symbol(\"z\")\n1901 \n1902     >>> X = Logistic(\"x\", mu, s)\n1903 \n1904     >>> density(X)(z)\n1905     exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)\n1906 \n1907     >>> cdf(X)(z)\n1908     1/(exp((mu - z)/s) + 1)\n1909 \n1910     References\n1911     ==========\n1912 \n1913     .. [1] https://en.wikipedia.org/wiki/Logistic_distribution\n1914     .. [2] http://mathworld.wolfram.com/LogisticDistribution.html\n1915 \n1916     \"\"\"\n1917 \n1918     return rv(name, LogisticDistribution, (mu, s))\n1919 \n1920 #-------------------------------------------------------------------------------\n1921 # Log Normal distribution ------------------------------------------------------\n1922 \n1923 \n1924 class LogNormalDistribution(SingleContinuousDistribution):\n1925     _argnames = ('mean', 'std')\n1926 \n1927     set = Interval(0, oo)\n1928 \n1929     def pdf(self, x):\n1930         mean, std = self.mean, self.std\n1931         return exp(-(log(x) - mean)**2 / (2*std**2)) / (x*sqrt(2*pi)*std)\n1932 \n1933     def sample(self):\n1934         return random.lognormvariate(self.mean, self.std)\n1935 \n1936     def _cdf(self, x):\n1937         mean, std = self.mean, self.std\n1938         return Piecewise(\n1939                 (S.Half + S.Half*erf((log(x) - mean)/sqrt(2)/std), x > 0),\n1940                 (S.Zero, True)\n1941         )\n1942 \n1943     def _moment_generating_function(self, t):\n1944         raise NotImplementedError('Moment generating function of the log-normal distribution is not defined.')\n1945 \n1946 def LogNormal(name, mean, std):\n1947     r\"\"\"\n1948     Create a continuous random variable with a log-normal distribution.\n1949 \n1950     The density of the log-normal distribution is given by\n1951 \n1952     .. math::\n1953         f(x) := \\frac{1}{x\\sqrt{2\\pi\\sigma^2}}\n1954                 e^{-\\frac{\\left(\\ln x-\\mu\\right)^2}{2\\sigma^2}}\n1955 \n1956     with :math:`x \\geq 0`.\n1957 \n1958     Parameters\n1959     ==========\n1960 \n1961     mu : Real number, the log-scale\n1962     sigma : Real number, :math:`\\sigma^2 > 0` a shape\n1963 \n1964     Returns\n1965     =======\n1966 \n1967     A RandomSymbol.\n1968 \n1969     Examples\n1970     ========\n1971 \n1972     >>> from sympy.stats import LogNormal, density\n1973     >>> from sympy import Symbol, simplify, pprint\n1974 \n1975     >>> mu = Symbol(\"mu\", real=True)\n1976     >>> sigma = Symbol(\"sigma\", positive=True)\n1977     >>> z = Symbol(\"z\")\n1978 \n1979     >>> X = LogNormal(\"x\", mu, sigma)\n1980 \n1981     >>> D = density(X)(z)\n1982     >>> pprint(D, use_unicode=False)\n1983                           2\n1984            -(-mu + log(z))\n1985            -----------------\n1986                       2\n1987       ___      2*sigma\n1988     \\/ 2 *e\n1989     ------------------------\n1990             ____\n1991         2*\\/ pi *sigma*z\n1992 \n1993 \n1994     >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1\n1995 \n1996     >>> density(X)(z)\n1997     sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)\n1998 \n1999     References\n2000     ==========\n2001 \n2002     .. [1] https://en.wikipedia.org/wiki/Lognormal\n2003     .. [2] http://mathworld.wolfram.com/LogNormalDistribution.html\n2004 \n2005     \"\"\"\n2006 \n2007     return rv(name, LogNormalDistribution, (mean, std))\n2008 \n2009 #-------------------------------------------------------------------------------\n2010 # Maxwell distribution ---------------------------------------------------------\n2011 \n2012 \n2013 class MaxwellDistribution(SingleContinuousDistribution):\n2014     _argnames = ('a',)\n2015 \n2016     set = Interval(0, oo)\n2017 \n2018     def pdf(self, x):\n2019         a = self.a\n2020         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3\n2021 \n2022     def _cdf(self, x):\n2023         a = self.a\n2024         return erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)\n2025 \n2026 def Maxwell(name, a):\n2027     r\"\"\"\n2028     Create a continuous random variable with a Maxwell distribution.\n2029 \n2030     The density of the Maxwell distribution is given by\n2031 \n2032     .. math::\n2033         f(x) := \\sqrt{\\frac{2}{\\pi}} \\frac{x^2 e^{-x^2/(2a^2)}}{a^3}\n2034 \n2035     with :math:`x \\geq 0`.\n2036 \n2037     .. TODO - what does the parameter mean?\n2038 \n2039     Parameters\n2040     ==========\n2041 \n2042     a : Real number, `a > 0`\n2043 \n2044     Returns\n2045     =======\n2046 \n2047     A RandomSymbol.\n2048 \n2049     Examples\n2050     ========\n2051 \n2052     >>> from sympy.stats import Maxwell, density, E, variance\n2053     >>> from sympy import Symbol, simplify\n2054 \n2055     >>> a = Symbol(\"a\", positive=True)\n2056     >>> z = Symbol(\"z\")\n2057 \n2058     >>> X = Maxwell(\"x\", a)\n2059 \n2060     >>> density(X)(z)\n2061     sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)\n2062 \n2063     >>> E(X)\n2064     2*sqrt(2)*a/sqrt(pi)\n2065 \n2066     >>> simplify(variance(X))\n2067     a**2*(-8 + 3*pi)/pi\n2068 \n2069     References\n2070     ==========\n2071 \n2072     .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution\n2073     .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html\n2074 \n2075     \"\"\"\n2076 \n2077     return rv(name, MaxwellDistribution, (a, ))\n2078 \n2079 #-------------------------------------------------------------------------------\n2080 # Nakagami distribution --------------------------------------------------------\n2081 \n2082 \n2083 class NakagamiDistribution(SingleContinuousDistribution):\n2084     _argnames = ('mu', 'omega')\n2085 \n2086     set = Interval(0, oo)\n2087 \n2088     def pdf(self, x):\n2089         mu, omega = self.mu, self.omega\n2090         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)\n2091 \n2092     def _cdf(self, x):\n2093         mu, omega = self.mu, self.omega\n2094         return Piecewise(\n2095                     (lowergamma(mu, (mu/omega)*x**2)/gamma(mu), x > 0),\n2096                     (S.Zero, True))\n2097 \n2098 def Nakagami(name, mu, omega):\n2099     r\"\"\"\n2100     Create a continuous random variable with a Nakagami distribution.\n2101 \n2102     The density of the Nakagami distribution is given by\n2103 \n2104     .. math::\n2105         f(x) := \\frac{2\\mu^\\mu}{\\Gamma(\\mu)\\omega^\\mu} x^{2\\mu-1}\n2106                 \\exp\\left(-\\frac{\\mu}{\\omega}x^2 \\right)\n2107 \n2108     with :math:`x > 0`.\n2109 \n2110     Parameters\n2111     ==========\n2112 \n2113     mu : Real number, `\\mu \\geq \\frac{1}{2}` a shape\n2114     omega : Real number, `\\omega > 0`, the spread\n2115 \n2116     Returns\n2117     =======\n2118 \n2119     A RandomSymbol.\n2120 \n2121     Examples\n2122     ========\n2123 \n2124     >>> from sympy.stats import Nakagami, density, E, variance, cdf\n2125     >>> from sympy import Symbol, simplify, pprint\n2126 \n2127     >>> mu = Symbol(\"mu\", positive=True)\n2128     >>> omega = Symbol(\"omega\", positive=True)\n2129     >>> z = Symbol(\"z\")\n2130 \n2131     >>> X = Nakagami(\"x\", mu, omega)\n2132 \n2133     >>> D = density(X)(z)\n2134     >>> pprint(D, use_unicode=False)\n2135                                     2\n2136                                -mu*z\n2137                                -------\n2138         mu      -mu  2*mu - 1  omega\n2139     2*mu  *omega   *z        *e\n2140     ----------------------------------\n2141                 Gamma(mu)\n2142 \n2143     >>> simplify(E(X))\n2144     sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)\n2145 \n2146     >>> V = simplify(variance(X))\n2147     >>> pprint(V, use_unicode=False)\n2148                         2\n2149              omega*Gamma (mu + 1/2)\n2150     omega - -----------------------\n2151             Gamma(mu)*Gamma(mu + 1)\n2152 \n2153     >>> cdf(X)(z)\n2154     Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),\n2155             (0, True))\n2156 \n2157 \n2158     References\n2159     ==========\n2160 \n2161     .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution\n2162 \n2163     \"\"\"\n2164 \n2165     return rv(name, NakagamiDistribution, (mu, omega))\n2166 \n2167 #-------------------------------------------------------------------------------\n2168 # Normal distribution ----------------------------------------------------------\n2169 \n2170 \n2171 class NormalDistribution(SingleContinuousDistribution):\n2172     _argnames = ('mean', 'std')\n2173 \n2174     @staticmethod\n2175     def check(mean, std):\n2176         _value_check(std > 0, \"Standard deviation must be positive\")\n2177 \n2178     def pdf(self, x):\n2179         return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)\n2180 \n2181     def sample(self):\n2182         return random.normalvariate(self.mean, self.std)\n2183 \n2184     def _cdf(self, x):\n2185         mean, std = self.mean, self.std\n2186         return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half\n2187 \n2188     def _characteristic_function(self, t):\n2189         mean, std = self.mean, self.std\n2190         return exp(I*mean*t - std**2*t**2/2)\n2191 \n2192     def _moment_generating_function(self, t):\n2193         mean, std = self.mean, self.std\n2194         return exp(mean*t + std**2*t**2/2)\n2195 \n2196     def _quantile(self, p):\n2197         mean, std = self.mean, self.std\n2198         return mean + std*sqrt(2)*erfinv(2*p - 1)\n2199 \n2200 def Normal(name, mean, std):\n2201     r\"\"\"\n2202     Create a continuous random variable with a Normal distribution.\n2203 \n2204     The density of the Normal distribution is given by\n2205 \n2206     .. math::\n2207         f(x) := \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{(x-\\mu)^2}{2\\sigma^2} }\n2208 \n2209     Parameters\n2210     ==========\n2211 \n2212     mu : Real number or a list representing the mean or the mean vector\n2213     sigma : Real number or a positive definite sqaure matrix,\n2214          :math:`\\sigma^2 > 0` the variance\n2215 \n2216     Returns\n2217     =======\n2218 \n2219     A RandomSymbol.\n2220 \n2221     Examples\n2222     ========\n2223 \n2224     >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile\n2225     >>> from sympy import Symbol, simplify, pprint, factor, together, factor_terms\n2226 \n2227     >>> mu = Symbol(\"mu\")\n2228     >>> sigma = Symbol(\"sigma\", positive=True)\n2229     >>> z = Symbol(\"z\")\n2230     >>> y = Symbol(\"y\")\n2231     >>> p = Symbol(\"p\")\n2232     >>> X = Normal(\"x\", mu, sigma)\n2233 \n2234     >>> density(X)(z)\n2235     sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)\n2236 \n2237     >>> C = simplify(cdf(X))(z) # it needs a little more help...\n2238     >>> pprint(C, use_unicode=False)\n2239        /  ___          \\\n2240        |\\/ 2 *(-mu + z)|\n2241     erf|---------------|\n2242        \\    2*sigma    /   1\n2243     -------------------- + -\n2244              2             2\n2245 \n2246     >>> quantile(X)(p)\n2247     mu + sqrt(2)*sigma*erfinv(2*p - 1)\n2248 \n2249     >>> simplify(skewness(X))\n2250     0\n2251 \n2252     >>> X = Normal(\"x\", 0, 1) # Mean 0, standard deviation 1\n2253     >>> density(X)(z)\n2254     sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))\n2255 \n2256     >>> E(2*X + 1)\n2257     1\n2258 \n2259     >>> simplify(std(2*X + 1))\n2260     2\n2261 \n2262     >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])\n2263     >>> from sympy.stats.joint_rv import marginal_distribution\n2264     >>> pprint(density(m)(y, z))\n2265            /1   y\\ /2*y   z\\   /    z\\ /  y   2*z    \\\n2266            |- - -|*|--- - -| + |1 - -|*|- - + --- - 1|\n2267       ___  \\2   2/ \\ 3    3/   \\    2/ \\  3    3     /\n2268     \\/ 3 *e\n2269     --------------------------------------------------\n2270                            6*pi\n2271 \n2272     >>> marginal_distribution(m, m[0])(1)\n2273      1/(2*sqrt(pi))\n2274 \n2275 \n2276     References\n2277     ==========\n2278 \n2279     .. [1] https://en.wikipedia.org/wiki/Normal_distribution\n2280     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html\n2281 \n2282     \"\"\"\n2283 \n2284     if isinstance(mean, (list, MatrixBase)) and\\\n2285         isinstance(std, (list, MatrixBase)):\n2286         from sympy.stats.joint_rv_types import MultivariateNormalDistribution\n2287         return multivariate_rv(\n2288             MultivariateNormalDistribution, name, mean, std)\n2289     return rv(name, NormalDistribution, (mean, std))\n2290 \n2291 #-------------------------------------------------------------------------------\n2292 # Pareto distribution ----------------------------------------------------------\n2293 \n2294 \n2295 class ParetoDistribution(SingleContinuousDistribution):\n2296     _argnames = ('xm', 'alpha')\n2297 \n2298     @property\n2299     def set(self):\n2300         return Interval(self.xm, oo)\n2301 \n2302     @staticmethod\n2303     def check(xm, alpha):\n2304         _value_check(xm > 0, \"Xm must be positive\")\n2305         _value_check(alpha > 0, \"Alpha must be positive\")\n2306 \n2307     def pdf(self, x):\n2308         xm, alpha = self.xm, self.alpha\n2309         return alpha * xm**alpha / x**(alpha + 1)\n2310 \n2311     def sample(self):\n2312         return random.paretovariate(self.alpha)\n2313 \n2314     def _cdf(self, x):\n2315         xm, alpha = self.xm, self.alpha\n2316         return Piecewise(\n2317                 (S.One - xm**alpha/x**alpha, x>=xm),\n2318                 (0, True),\n2319         )\n2320 \n2321     def _moment_generating_function(self, t):\n2322         xm, alpha = self.xm, self.alpha\n2323         return alpha * (-xm*t)**alpha * uppergamma(-alpha, -xm*t)\n2324 \n2325     def _characteristic_function(self, t):\n2326         xm, alpha = self.xm, self.alpha\n2327         return alpha * (-I * xm * t) ** alpha * uppergamma(-alpha, -I * xm * t)\n2328 \n2329 \n2330 def Pareto(name, xm, alpha):\n2331     r\"\"\"\n2332     Create a continuous random variable with the Pareto distribution.\n2333 \n2334     The density of the Pareto distribution is given by\n2335 \n2336     .. math::\n2337         f(x) := \\frac{\\alpha\\,x_m^\\alpha}{x^{\\alpha+1}}\n2338 \n2339     with :math:`x \\in [x_m,\\infty]`.\n2340 \n2341     Parameters\n2342     ==========\n2343 \n2344     xm : Real number, `x_m > 0`, a scale\n2345     alpha : Real number, `\\alpha > 0`, a shape\n2346 \n2347     Returns\n2348     =======\n2349 \n2350     A RandomSymbol.\n2351 \n2352     Examples\n2353     ========\n2354 \n2355     >>> from sympy.stats import Pareto, density\n2356     >>> from sympy import Symbol\n2357 \n2358     >>> xm = Symbol(\"xm\", positive=True)\n2359     >>> beta = Symbol(\"beta\", positive=True)\n2360     >>> z = Symbol(\"z\")\n2361 \n2362     >>> X = Pareto(\"x\", xm, beta)\n2363 \n2364     >>> density(X)(z)\n2365     beta*xm**beta*z**(-beta - 1)\n2366 \n2367     References\n2368     ==========\n2369 \n2370     .. [1] https://en.wikipedia.org/wiki/Pareto_distribution\n2371     .. [2] http://mathworld.wolfram.com/ParetoDistribution.html\n2372 \n2373     \"\"\"\n2374 \n2375     return rv(name, ParetoDistribution, (xm, alpha))\n2376 \n2377 #-------------------------------------------------------------------------------\n2378 # QuadraticU distribution ------------------------------------------------------\n2379 \n2380 \n2381 class QuadraticUDistribution(SingleContinuousDistribution):\n2382     _argnames = ('a', 'b')\n2383 \n2384     @property\n2385     def set(self):\n2386         return Interval(self.a, self.b)\n2387 \n2388     def pdf(self, x):\n2389         a, b = self.a, self.b\n2390         alpha = 12 / (b-a)**3\n2391         beta = (a+b) / 2\n2392         return Piecewise(\n2393                   (alpha * (x-beta)**2, And(a<=x, x<=b)),\n2394                   (S.Zero, True))\n2395 \n2396     def _moment_generating_function(self, t):\n2397         a, b = self.a, self.b\n2398 \n2399         return -3 * (exp(a*t) * (4  + (a**2 + 2*a*(-2 + b) + b**2) * t) - exp(b*t) * (4 + (-4*b + (a + b)**2) * t)) / ((a-b)**3 * t**2)\n2400 \n2401     def _characteristic_function(self, t):\n2402         def _moment_generating_function(self, t):\n2403             a, b = self.a, self.b\n2404 \n2405             return -3*I*(exp(I*a*t*exp(I*b*t)) * (4*I - (-4*b + (a+b)**2)*t)) / ((a-b)**3 * t**2)\n2406 \n2407 \n2408 def QuadraticU(name, a, b):\n2409     r\"\"\"\n2410     Create a Continuous Random Variable with a U-quadratic distribution.\n2411 \n2412     The density of the U-quadratic distribution is given by\n2413 \n2414     .. math::\n2415         f(x) := \\alpha (x-\\beta)^2\n2416 \n2417     with :math:`x \\in [a,b]`.\n2418 \n2419     Parameters\n2420     ==========\n2421 \n2422     a : Real number\n2423     b : Real number, :math:`a < b`\n2424 \n2425     Returns\n2426     =======\n2427 \n2428     A RandomSymbol.\n2429 \n2430     Examples\n2431     ========\n2432 \n2433     >>> from sympy.stats import QuadraticU, density, E, variance\n2434     >>> from sympy import Symbol, simplify, factor, pprint\n2435 \n2436     >>> a = Symbol(\"a\", real=True)\n2437     >>> b = Symbol(\"b\", real=True)\n2438     >>> z = Symbol(\"z\")\n2439 \n2440     >>> X = QuadraticU(\"x\", a, b)\n2441 \n2442     >>> D = density(X)(z)\n2443     >>> pprint(D, use_unicode=False)\n2444     /                2\n2445     |   /  a   b    \\\n2446     |12*|- - - - + z|\n2447     |   \\  2   2    /\n2448     <-----------------  for And(b >= z, a <= z)\n2449     |            3\n2450     |    (-a + b)\n2451     |\n2452     \\        0                 otherwise\n2453 \n2454     References\n2455     ==========\n2456 \n2457     .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution\n2458 \n2459     \"\"\"\n2460 \n2461     return rv(name, QuadraticUDistribution, (a, b))\n2462 \n2463 #-------------------------------------------------------------------------------\n2464 # RaisedCosine distribution ----------------------------------------------------\n2465 \n2466 \n2467 class RaisedCosineDistribution(SingleContinuousDistribution):\n2468     _argnames = ('mu', 's')\n2469 \n2470     @property\n2471     def set(self):\n2472         return Interval(self.mu - self.s, self.mu + self.s)\n2473 \n2474     @staticmethod\n2475     def check(mu, s):\n2476         _value_check(s > 0, \"s must be positive\")\n2477 \n2478     def pdf(self, x):\n2479         mu, s = self.mu, self.s\n2480         return Piecewise(\n2481                 ((1+cos(pi*(x-mu)/s)) / (2*s), And(mu-s<=x, x<=mu+s)),\n2482                 (S.Zero, True))\n2483 \n2484     def _characteristic_function(self, t):\n2485         mu, s = self.mu, self.s\n2486         return Piecewise((exp(-I*pi*mu/s)/2, Eq(t, -pi/s)),\n2487                          (exp(I*pi*mu/s)/2, Eq(t, pi/s)),\n2488                          (pi**2*sin(s*t)*exp(I*mu*t) / (s*t*(pi**2 - s**2*t**2)), True))\n2489 \n2490     def _moment_generating_function(self, t):\n2491         mu, s = self.mu, self.s\n2492         return pi**2 * sinh(s*t) * exp(mu*t) /  (s*t*(pi**2 + s**2*t**2))\n2493 \n2494 def RaisedCosine(name, mu, s):\n2495     r\"\"\"\n2496     Create a Continuous Random Variable with a raised cosine distribution.\n2497 \n2498     The density of the raised cosine distribution is given by\n2499 \n2500     .. math::\n2501         f(x) := \\frac{1}{2s}\\left(1+\\cos\\left(\\frac{x-\\mu}{s}\\pi\\right)\\right)\n2502 \n2503     with :math:`x \\in [\\mu-s,\\mu+s]`.\n2504 \n2505     Parameters\n2506     ==========\n2507 \n2508     mu : Real number\n2509     s : Real number, `s > 0`\n2510 \n2511     Returns\n2512     =======\n2513 \n2514     A RandomSymbol.\n2515 \n2516     Examples\n2517     ========\n2518 \n2519     >>> from sympy.stats import RaisedCosine, density, E, variance\n2520     >>> from sympy import Symbol, simplify, pprint\n2521 \n2522     >>> mu = Symbol(\"mu\", real=True)\n2523     >>> s = Symbol(\"s\", positive=True)\n2524     >>> z = Symbol(\"z\")\n2525 \n2526     >>> X = RaisedCosine(\"x\", mu, s)\n2527 \n2528     >>> D = density(X)(z)\n2529     >>> pprint(D, use_unicode=False)\n2530     /   /pi*(-mu + z)\\\n2531     |cos|------------| + 1\n2532     |   \\     s      /\n2533     <---------------------  for And(z >= mu - s, z <= mu + s)\n2534     |         2*s\n2535     |\n2536     \\          0                        otherwise\n2537 \n2538     References\n2539     ==========\n2540 \n2541     .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution\n2542 \n2543     \"\"\"\n2544 \n2545     return rv(name, RaisedCosineDistribution, (mu, s))\n2546 \n2547 #-------------------------------------------------------------------------------\n2548 # Rayleigh distribution --------------------------------------------------------\n2549 \n2550 \n2551 class RayleighDistribution(SingleContinuousDistribution):\n2552     _argnames = ('sigma',)\n2553 \n2554     set = Interval(0, oo)\n2555 \n2556     def pdf(self, x):\n2557         sigma = self.sigma\n2558         return x/sigma**2*exp(-x**2/(2*sigma**2))\n2559 \n2560     def _cdf(self, x):\n2561         sigma = self.sigma\n2562         return 1 - exp(-(x**2/(2*sigma**2)))\n2563 \n2564     def _characteristic_function(self, t):\n2565         sigma = self.sigma\n2566         return 1 - sigma*t*exp(-sigma**2*t**2/2) * sqrt(pi/2) * (erfi(sigma*t/sqrt(2)) - I)\n2567 \n2568     def _moment_generating_function(self, t):\n2569         sigma = self.sigma\n2570         return 1 + sigma*t*exp(sigma**2*t**2/2) * sqrt(pi/2) * (erf(sigma*t/sqrt(2)) + 1)\n2571 \n2572 \n2573 def Rayleigh(name, sigma):\n2574     r\"\"\"\n2575     Create a continuous random variable with a Rayleigh distribution.\n2576 \n2577     The density of the Rayleigh distribution is given by\n2578 \n2579     .. math ::\n2580         f(x) := \\frac{x}{\\sigma^2} e^{-x^2/2\\sigma^2}\n2581 \n2582     with :math:`x > 0`.\n2583 \n2584     Parameters\n2585     ==========\n2586 \n2587     sigma : Real number, `\\sigma > 0`\n2588 \n2589     Returns\n2590     =======\n2591 \n2592     A RandomSymbol.\n2593 \n2594     Examples\n2595     ========\n2596 \n2597     >>> from sympy.stats import Rayleigh, density, E, variance\n2598     >>> from sympy import Symbol, simplify\n2599 \n2600     >>> sigma = Symbol(\"sigma\", positive=True)\n2601     >>> z = Symbol(\"z\")\n2602 \n2603     >>> X = Rayleigh(\"x\", sigma)\n2604 \n2605     >>> density(X)(z)\n2606     z*exp(-z**2/(2*sigma**2))/sigma**2\n2607 \n2608     >>> E(X)\n2609     sqrt(2)*sqrt(pi)*sigma/2\n2610 \n2611     >>> variance(X)\n2612     -pi*sigma**2/2 + 2*sigma**2\n2613 \n2614     References\n2615     ==========\n2616 \n2617     .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution\n2618     .. [2] http://mathworld.wolfram.com/RayleighDistribution.html\n2619 \n2620     \"\"\"\n2621 \n2622     return rv(name, RayleighDistribution, (sigma, ))\n2623 \n2624 #-------------------------------------------------------------------------------\n2625 # Shifted Gompertz distribution ------------------------------------------------\n2626 \n2627 \n2628 class ShiftedGompertzDistribution(SingleContinuousDistribution):\n2629     _argnames = ('b', 'eta')\n2630 \n2631     set = Interval(0, oo)\n2632 \n2633     @staticmethod\n2634     def check(b, eta):\n2635         _value_check(b > 0, \"b must be positive\")\n2636         _value_check(eta > 0, \"eta must be positive\")\n2637 \n2638     def pdf(self, x):\n2639         b, eta = self.b, self.eta\n2640         return b*exp(-b*x)*exp(-eta*exp(-b*x))*(1+eta*(1-exp(-b*x)))\n2641 \n2642 def ShiftedGompertz(name, b, eta):\n2643     r\"\"\"\n2644     Create a continuous random variable with a Shifted Gompertz distribution.\n2645 \n2646     The density of the Shifted Gompertz distribution is given by\n2647 \n2648     .. math::\n2649         f(x) := b e^{-b x} e^{-\\eta \\exp(-b x)} \\left[1 + \\eta(1 - e^(-bx)) \\right]\n2650 \n2651     with :math: 'x \\in [0, \\inf)'.\n2652 \n2653     Parameters\n2654     ==========\n2655 \n2656     b: Real number, 'b > 0' a scale\n2657     eta: Real number, 'eta > 0' a shape\n2658 \n2659     Returns\n2660     =======\n2661 \n2662     A RandomSymbol.\n2663 \n2664     Examples\n2665     ========\n2666     >>> from sympy.stats import ShiftedGompertz, density, E, variance\n2667     >>> from sympy import Symbol\n2668 \n2669     >>> b = Symbol(\"b\", positive=True)\n2670     >>> eta = Symbol(\"eta\", positive=True)\n2671     >>> x = Symbol(\"x\")\n2672 \n2673     >>> X = ShiftedGompertz(\"x\", b, eta)\n2674 \n2675     >>> density(X)(x)\n2676     b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))\n2677 \n2678     References\n2679     ==========\n2680 \n2681     .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution\n2682 \n2683     \"\"\"\n2684     return rv(name, ShiftedGompertzDistribution, (b, eta))\n2685 \n2686 #-------------------------------------------------------------------------------\n2687 # StudentT distribution --------------------------------------------------------\n2688 \n2689 \n2690 class StudentTDistribution(SingleContinuousDistribution):\n2691     _argnames = ('nu',)\n2692 \n2693     def pdf(self, x):\n2694         nu = self.nu\n2695         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)\n2696 \n2697     def _cdf(self, x):\n2698         nu = self.nu\n2699         return S.Half + x*gamma((nu+1)/2)*hyper((S.Half, (nu+1)/2),\n2700                                 (S(3)/2,), -x**2/nu)/(sqrt(pi*nu)*gamma(nu/2))\n2701 \n2702     def _moment_generating_function(self, t):\n2703         raise NotImplementedError('The moment generating function for the Student-T distribution is undefined.')\n2704 \n2705 def StudentT(name, nu):\n2706     r\"\"\"\n2707     Create a continuous random variable with a student's t distribution.\n2708 \n2709     The density of the student's t distribution is given by\n2710 \n2711     .. math::\n2712         f(x) := \\frac{\\Gamma \\left(\\frac{\\nu+1}{2} \\right)}\n2713                 {\\sqrt{\\nu\\pi}\\Gamma \\left(\\frac{\\nu}{2} \\right)}\n2714                 \\left(1+\\frac{x^2}{\\nu} \\right)^{-\\frac{\\nu+1}{2}}\n2715 \n2716     Parameters\n2717     ==========\n2718 \n2719     nu : Real number, `\\nu > 0`, the degrees of freedom\n2720 \n2721     Returns\n2722     =======\n2723 \n2724     A RandomSymbol.\n2725 \n2726     Examples\n2727     ========\n2728 \n2729     >>> from sympy.stats import StudentT, density, E, variance, cdf\n2730     >>> from sympy import Symbol, simplify, pprint\n2731 \n2732     >>> nu = Symbol(\"nu\", positive=True)\n2733     >>> z = Symbol(\"z\")\n2734 \n2735     >>> X = StudentT(\"x\", nu)\n2736 \n2737     >>> D = density(X)(z)\n2738     >>> pprint(D, use_unicode=False)\n2739                nu   1\n2740              - -- - -\n2741                2    2\n2742      /     2\\\n2743      |    z |\n2744      |1 + --|\n2745      \\    nu/\n2746     -----------------\n2747       ____  /     nu\\\n2748     \\/ nu *B|1/2, --|\n2749             \\     2 /\n2750 \n2751     >>> cdf(X)(z)\n2752     1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),\n2753                                 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))\n2754 \n2755 \n2756     References\n2757     ==========\n2758 \n2759     .. [1] https://en.wikipedia.org/wiki/Student_t-distribution\n2760     .. [2] http://mathworld.wolfram.com/Studentst-Distribution.html\n2761 \n2762     \"\"\"\n2763 \n2764     return rv(name, StudentTDistribution, (nu, ))\n2765 \n2766 #-------------------------------------------------------------------------------\n2767 # Trapezoidal distribution ------------------------------------------------------\n2768 \n2769 \n2770 class TrapezoidalDistribution(SingleContinuousDistribution):\n2771     _argnames = ('a', 'b', 'c', 'd')\n2772 \n2773     def pdf(self, x):\n2774         a, b, c, d = self.a, self.b, self.c, self.d\n2775         return Piecewise(\n2776             (2*(x-a) / ((b-a)*(d+c-a-b)), And(a <= x, x < b)),\n2777             (2 / (d+c-a-b), And(b <= x, x < c)),\n2778             (2*(d-x) / ((d-c)*(d+c-a-b)), And(c <= x, x <= d)),\n2779             (S.Zero, True))\n2780 \n2781 def Trapezoidal(name, a, b, c, d):\n2782     r\"\"\"\n2783     Create a continuous random variable with a trapezoidal distribution.\n2784 \n2785     The density of the trapezoidal distribution is given by\n2786 \n2787     .. math::\n2788         f(x) := \\begin{cases}\n2789                   0 & \\mathrm{for\\ } x < a, \\\\\n2790                   \\frac{2(x-a)}{(b-a)(d+c-a-b)} & \\mathrm{for\\ } a \\le x < b, \\\\\n2791                   \\frac{2}{d+c-a-b} & \\mathrm{for\\ } b \\le x < c, \\\\\n2792                   \\frac{2(d-x)}{(d-c)(d+c-a-b)} & \\mathrm{for\\ } c \\le x < d, \\\\\n2793                   0 & \\mathrm{for\\ } d < x.\n2794                 \\end{cases}\n2795 \n2796     Parameters\n2797     ==========\n2798 \n2799     a : Real number, :math:`a < d`\n2800     b : Real number, :math:`a <= b < c`\n2801     c : Real number, :math:`b < c <= d`\n2802     d : Real number\n2803 \n2804     Returns\n2805     =======\n2806 \n2807     A RandomSymbol.\n2808 \n2809     Examples\n2810     ========\n2811 \n2812     >>> from sympy.stats import Trapezoidal, density, E\n2813     >>> from sympy import Symbol, pprint\n2814 \n2815     >>> a = Symbol(\"a\")\n2816     >>> b = Symbol(\"b\")\n2817     >>> c = Symbol(\"c\")\n2818     >>> d = Symbol(\"d\")\n2819     >>> z = Symbol(\"z\")\n2820 \n2821     >>> X = Trapezoidal(\"x\", a,b,c,d)\n2822 \n2823     >>> pprint(density(X)(z), use_unicode=False)\n2824     /        -2*a + 2*z\n2825     |-------------------------  for And(a <= z, b > z)\n2826     |(-a + b)*(-a - b + c + d)\n2827     |\n2828     |           2\n2829     |     --------------        for And(b <= z, c > z)\n2830     <     -a - b + c + d\n2831     |\n2832     |        2*d - 2*z\n2833     |-------------------------  for And(d >= z, c <= z)\n2834     |(-c + d)*(-a - b + c + d)\n2835     |\n2836     \\            0                     otherwise\n2837 \n2838     References\n2839     ==========\n2840 \n2841     .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution\n2842 \n2843     \"\"\"\n2844     return rv(name, TrapezoidalDistribution, (a, b, c, d))\n2845 \n2846 #-------------------------------------------------------------------------------\n2847 # Triangular distribution ------------------------------------------------------\n2848 \n2849 \n2850 class TriangularDistribution(SingleContinuousDistribution):\n2851     _argnames = ('a', 'b', 'c')\n2852 \n2853     def pdf(self, x):\n2854         a, b, c = self.a, self.b, self.c\n2855         return Piecewise(\n2856             (2*(x - a)/((b - a)*(c - a)), And(a <= x, x < c)),\n2857             (2/(b - a), Eq(x, c)),\n2858             (2*(b - x)/((b - a)*(b - c)), And(c < x, x <= b)),\n2859             (S.Zero, True))\n2860 \n2861     def _characteristic_function(self, t):\n2862         a, b, c = self.a, self.b, self.c\n2863         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)\n2864 \n2865     def _moment_generating_function(self, t):\n2866         a, b, c = self.a, self.b, self.c\n2867         return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (\n2868         (b - a) * (c - a) * (b - c) * t ** 2)\n2869 \n2870 \n2871 def Triangular(name, a, b, c):\n2872     r\"\"\"\n2873     Create a continuous random variable with a triangular distribution.\n2874 \n2875     The density of the triangular distribution is given by\n2876 \n2877     .. math::\n2878         f(x) := \\begin{cases}\n2879                   0 & \\mathrm{for\\ } x < a, \\\\\n2880                   \\frac{2(x-a)}{(b-a)(c-a)} & \\mathrm{for\\ } a \\le x < c, \\\\\n2881                   \\frac{2}{b-a} & \\mathrm{for\\ } x = c, \\\\\n2882                   \\frac{2(b-x)}{(b-a)(b-c)} & \\mathrm{for\\ } c < x \\le b, \\\\\n2883                   0 & \\mathrm{for\\ } b < x.\n2884                 \\end{cases}\n2885 \n2886     Parameters\n2887     ==========\n2888 \n2889     a : Real number, :math:`a \\in \\left(-\\infty, \\infty\\right)`\n2890     b : Real number, :math:`a < b`\n2891     c : Real number, :math:`a \\leq c \\leq b`\n2892 \n2893     Returns\n2894     =======\n2895 \n2896     A RandomSymbol.\n2897 \n2898     Examples\n2899     ========\n2900 \n2901     >>> from sympy.stats import Triangular, density, E\n2902     >>> from sympy import Symbol, pprint\n2903 \n2904     >>> a = Symbol(\"a\")\n2905     >>> b = Symbol(\"b\")\n2906     >>> c = Symbol(\"c\")\n2907     >>> z = Symbol(\"z\")\n2908 \n2909     >>> X = Triangular(\"x\", a,b,c)\n2910 \n2911     >>> pprint(density(X)(z), use_unicode=False)\n2912     /    -2*a + 2*z\n2913     |-----------------  for And(a <= z, c > z)\n2914     |(-a + b)*(-a + c)\n2915     |\n2916     |       2\n2917     |     ------              for c = z\n2918     <     -a + b\n2919     |\n2920     |   2*b - 2*z\n2921     |----------------   for And(b >= z, c < z)\n2922     |(-a + b)*(b - c)\n2923     |\n2924     \\        0                otherwise\n2925 \n2926     References\n2927     ==========\n2928 \n2929     .. [1] https://en.wikipedia.org/wiki/Triangular_distribution\n2930     .. [2] http://mathworld.wolfram.com/TriangularDistribution.html\n2931 \n2932     \"\"\"\n2933 \n2934     return rv(name, TriangularDistribution, (a, b, c))\n2935 \n2936 #-------------------------------------------------------------------------------\n2937 # Uniform distribution ---------------------------------------------------------\n2938 \n2939 \n2940 class UniformDistribution(SingleContinuousDistribution):\n2941     _argnames = ('left', 'right')\n2942 \n2943     def pdf(self, x):\n2944         left, right = self.left, self.right\n2945         return Piecewise(\n2946             (S.One/(right - left), And(left <= x, x <= right)),\n2947             (S.Zero, True)\n2948         )\n2949 \n2950     def _cdf(self, x):\n2951         left, right = self.left, self.right\n2952         return Piecewise(\n2953             (S.Zero, x < left),\n2954             ((x - left)/(right - left), x <= right),\n2955             (S.One, True)\n2956         )\n2957 \n2958     def _characteristic_function(self, t):\n2959         left, right = self.left, self.right\n2960         return Piecewise(((exp(I*t*right) - exp(I*t*left)) / (I*t*(right - left)), Ne(t, 0)),\n2961                          (S.One, True))\n2962 \n2963     def _moment_generating_function(self, t):\n2964         left, right = self.left, self.right\n2965         return Piecewise(((exp(t*right) - exp(t*left)) / (t * (right - left)), Ne(t, 0)),\n2966                          (S.One, True))\n2967 \n2968     def expectation(self, expr, var, **kwargs):\n2969         from sympy import Max, Min\n2970         kwargs['evaluate'] = True\n2971         result = SingleContinuousDistribution.expectation(self, expr, var, **kwargs)\n2972         result = result.subs({Max(self.left, self.right): self.right,\n2973                               Min(self.left, self.right): self.left})\n2974         return result\n2975 \n2976     def sample(self):\n2977         return random.uniform(self.left, self.right)\n2978 \n2979 \n2980 def Uniform(name, left, right):\n2981     r\"\"\"\n2982     Create a continuous random variable with a uniform distribution.\n2983 \n2984     The density of the uniform distribution is given by\n2985 \n2986     .. math::\n2987         f(x) := \\begin{cases}\n2988                   \\frac{1}{b - a} & \\text{for } x \\in [a,b]  \\\\\n2989                   0               & \\text{otherwise}\n2990                 \\end{cases}\n2991 \n2992     with :math:`x \\in [a,b]`.\n2993 \n2994     Parameters\n2995     ==========\n2996 \n2997     a : Real number, :math:`-\\infty < a` the left boundary\n2998     b : Real number, :math:`a < b < \\infty` the right boundary\n2999 \n3000     Returns\n3001     =======\n3002 \n3003     A RandomSymbol.\n3004 \n3005     Examples\n3006     ========\n3007 \n3008     >>> from sympy.stats import Uniform, density, cdf, E, variance, skewness\n3009     >>> from sympy import Symbol, simplify\n3010 \n3011     >>> a = Symbol(\"a\", negative=True)\n3012     >>> b = Symbol(\"b\", positive=True)\n3013     >>> z = Symbol(\"z\")\n3014 \n3015     >>> X = Uniform(\"x\", a, b)\n3016 \n3017     >>> density(X)(z)\n3018     Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))\n3019 \n3020     >>> cdf(X)(z)  # doctest: +SKIP\n3021     -a/(-a + b) + z/(-a + b)\n3022 \n3023     >>> simplify(E(X))\n3024     a/2 + b/2\n3025 \n3026     >>> simplify(variance(X))\n3027     a**2/12 - a*b/6 + b**2/12\n3028 \n3029     References\n3030     ==========\n3031 \n3032     .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29\n3033     .. [2] http://mathworld.wolfram.com/UniformDistribution.html\n3034 \n3035     \"\"\"\n3036 \n3037     return rv(name, UniformDistribution, (left, right))\n3038 \n3039 #-------------------------------------------------------------------------------\n3040 # UniformSum distribution ------------------------------------------------------\n3041 \n3042 \n3043 class UniformSumDistribution(SingleContinuousDistribution):\n3044     _argnames = ('n',)\n3045 \n3046     @property\n3047     def set(self):\n3048         return Interval(0, self.n)\n3049 \n3050     def pdf(self, x):\n3051         n = self.n\n3052         k = Dummy(\"k\")\n3053         return 1/factorial(\n3054             n - 1)*Sum((-1)**k*binomial(n, k)*(x - k)**(n - 1), (k, 0, floor(x)))\n3055 \n3056     def _cdf(self, x):\n3057         n = self.n\n3058         k = Dummy(\"k\")\n3059         return Piecewise((S.Zero, x < 0),\n3060                         (1/factorial(n)*Sum((-1)**k*binomial(n, k)*(x - k)**(n),\n3061                         (k, 0, floor(x))), x <= n),\n3062                         (S.One, True))\n3063 \n3064     def _characteristic_function(self, t):\n3065         return ((exp(I*t) - 1) / (I*t))**self.n\n3066 \n3067     def _moment_generating_function(self, t):\n3068         return ((exp(t) - 1) / t)**self.n\n3069 \n3070 def UniformSum(name, n):\n3071     r\"\"\"\n3072     Create a continuous random variable with an Irwin-Hall distribution.\n3073 \n3074     The probability distribution function depends on a single parameter\n3075     `n` which is an integer.\n3076 \n3077     The density of the Irwin-Hall distribution is given by\n3078 \n3079     .. math ::\n3080         f(x) := \\frac{1}{(n-1)!}\\sum_{k=0}^{\\left\\lfloor x\\right\\rfloor}(-1)^k\n3081                 \\binom{n}{k}(x-k)^{n-1}\n3082 \n3083     Parameters\n3084     ==========\n3085 \n3086     n : A positive Integer, `n > 0`\n3087 \n3088     Returns\n3089     =======\n3090 \n3091     A RandomSymbol.\n3092 \n3093     Examples\n3094     ========\n3095 \n3096     >>> from sympy.stats import UniformSum, density, cdf\n3097     >>> from sympy import Symbol, pprint\n3098 \n3099     >>> n = Symbol(\"n\", integer=True)\n3100     >>> z = Symbol(\"z\")\n3101 \n3102     >>> X = UniformSum(\"x\", n)\n3103 \n3104     >>> D = density(X)(z)\n3105     >>> pprint(D, use_unicode=False)\n3106     floor(z)\n3107       ___\n3108       \\  `\n3109        \\         k         n - 1 /n\\\n3110         )    (-1) *(-k + z)     *| |\n3111        /                         \\k/\n3112       /__,\n3113      k = 0\n3114     --------------------------------\n3115                 (n - 1)!\n3116 \n3117     >>> cdf(X)(z)\n3118     Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),\n3119                     (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))\n3120 \n3121 \n3122     Compute cdf with specific 'x' and 'n' values as follows :\n3123     >>> cdf(UniformSum(\"x\", 5), evaluate=False)(2).doit()\n3124     9/40\n3125 \n3126     The argument evaluate=False prevents an attempt at evaluation\n3127     of the sum for general n, before the argument 2 is passed.\n3128 \n3129     References\n3130     ==========\n3131 \n3132     .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution\n3133     .. [2] http://mathworld.wolfram.com/UniformSumDistribution.html\n3134 \n3135     \"\"\"\n3136 \n3137     return rv(name, UniformSumDistribution, (n, ))\n3138 \n3139 #-------------------------------------------------------------------------------\n3140 # VonMises distribution --------------------------------------------------------\n3141 \n3142 \n3143 class VonMisesDistribution(SingleContinuousDistribution):\n3144     _argnames = ('mu', 'k')\n3145 \n3146     set = Interval(0, 2*pi)\n3147 \n3148     @staticmethod\n3149     def check(mu, k):\n3150         _value_check(k > 0, \"k must be positive\")\n3151 \n3152     def pdf(self, x):\n3153         mu, k = self.mu, self.k\n3154         return exp(k*cos(x-mu)) / (2*pi*besseli(0, k))\n3155 \n3156 def VonMises(name, mu, k):\n3157     r\"\"\"\n3158     Create a Continuous Random Variable with a von Mises distribution.\n3159 \n3160     The density of the von Mises distribution is given by\n3161 \n3162     .. math::\n3163         f(x) := \\frac{e^{\\kappa\\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n3164 \n3165     with :math:`x \\in [0,2\\pi]`.\n3166 \n3167     Parameters\n3168     ==========\n3169 \n3170     mu : Real number, measure of location\n3171     k : Real number, measure of concentration\n3172 \n3173     Returns\n3174     =======\n3175 \n3176     A RandomSymbol.\n3177 \n3178     Examples\n3179     ========\n3180 \n3181     >>> from sympy.stats import VonMises, density, E, variance\n3182     >>> from sympy import Symbol, simplify, pprint\n3183 \n3184     >>> mu = Symbol(\"mu\")\n3185     >>> k = Symbol(\"k\", positive=True)\n3186     >>> z = Symbol(\"z\")\n3187 \n3188     >>> X = VonMises(\"x\", mu, k)\n3189 \n3190     >>> D = density(X)(z)\n3191     >>> pprint(D, use_unicode=False)\n3192          k*cos(mu - z)\n3193         e\n3194     ------------------\n3195     2*pi*besseli(0, k)\n3196 \n3197 \n3198     References\n3199     ==========\n3200 \n3201     .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution\n3202     .. [2] http://mathworld.wolfram.com/vonMisesDistribution.html\n3203 \n3204     \"\"\"\n3205 \n3206     return rv(name, VonMisesDistribution, (mu, k))\n3207 \n3208 #-------------------------------------------------------------------------------\n3209 # Weibull distribution ---------------------------------------------------------\n3210 \n3211 \n3212 class WeibullDistribution(SingleContinuousDistribution):\n3213     _argnames = ('alpha', 'beta')\n3214 \n3215     set = Interval(0, oo)\n3216 \n3217     @staticmethod\n3218     def check(alpha, beta):\n3219         _value_check(alpha > 0, \"Alpha must be positive\")\n3220         _value_check(beta > 0, \"Beta must be positive\")\n3221 \n3222     def pdf(self, x):\n3223         alpha, beta = self.alpha, self.beta\n3224         return beta * (x/alpha)**(beta - 1) * exp(-(x/alpha)**beta) / alpha\n3225 \n3226     def sample(self):\n3227         return random.weibullvariate(self.alpha, self.beta)\n3228 \n3229 def Weibull(name, alpha, beta):\n3230     r\"\"\"\n3231     Create a continuous random variable with a Weibull distribution.\n3232 \n3233     The density of the Weibull distribution is given by\n3234 \n3235     .. math::\n3236         f(x) := \\begin{cases}\n3237                   \\frac{k}{\\lambda}\\left(\\frac{x}{\\lambda}\\right)^{k-1}\n3238                   e^{-(x/\\lambda)^{k}} & x\\geq0\\\\\n3239                   0 & x<0\n3240                 \\end{cases}\n3241 \n3242     Parameters\n3243     ==========\n3244 \n3245     lambda : Real number, :math:`\\lambda > 0` a scale\n3246     k : Real number, `k > 0` a shape\n3247 \n3248     Returns\n3249     =======\n3250 \n3251     A RandomSymbol.\n3252 \n3253     Examples\n3254     ========\n3255 \n3256     >>> from sympy.stats import Weibull, density, E, variance\n3257     >>> from sympy import Symbol, simplify\n3258 \n3259     >>> l = Symbol(\"lambda\", positive=True)\n3260     >>> k = Symbol(\"k\", positive=True)\n3261     >>> z = Symbol(\"z\")\n3262 \n3263     >>> X = Weibull(\"x\", l, k)\n3264 \n3265     >>> density(X)(z)\n3266     k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda\n3267 \n3268     >>> simplify(E(X))\n3269     lambda*gamma(1 + 1/k)\n3270 \n3271     >>> simplify(variance(X))\n3272     lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))\n3273 \n3274     References\n3275     ==========\n3276 \n3277     .. [1] https://en.wikipedia.org/wiki/Weibull_distribution\n3278     .. [2] http://mathworld.wolfram.com/WeibullDistribution.html\n3279 \n3280     \"\"\"\n3281 \n3282     return rv(name, WeibullDistribution, (alpha, beta))\n3283 \n3284 #-------------------------------------------------------------------------------\n3285 # Wigner semicircle distribution -----------------------------------------------\n3286 \n3287 \n3288 class WignerSemicircleDistribution(SingleContinuousDistribution):\n3289     _argnames = ('R',)\n3290 \n3291     @property\n3292     def set(self):\n3293         return Interval(-self.R, self.R)\n3294 \n3295     def pdf(self, x):\n3296         R = self.R\n3297         return 2/(pi*R**2)*sqrt(R**2 - x**2)\n3298 \n3299     def _characteristic_function(self, t):\n3300         return Piecewise((2 * besselj(1, self.R*t) / (self.R*t), Ne(t, 0)),\n3301                          (S.One, True))\n3302 \n3303     def _moment_generating_function(self, t):\n3304         return Piecewise((2 * besseli(1, self.R*t) / (self.R*t), Ne(t, 0)),\n3305                          (S.One, True))\n3306 \n3307 def WignerSemicircle(name, R):\n3308     r\"\"\"\n3309     Create a continuous random variable with a Wigner semicircle distribution.\n3310 \n3311     The density of the Wigner semicircle distribution is given by\n3312 \n3313     .. math::\n3314         f(x) := \\frac2{\\pi R^2}\\,\\sqrt{R^2-x^2}\n3315 \n3316     with :math:`x \\in [-R,R]`.\n3317 \n3318     Parameters\n3319     ==========\n3320 \n3321     R : Real number, `R > 0`, the radius\n3322 \n3323     Returns\n3324     =======\n3325 \n3326     A `RandomSymbol`.\n3327 \n3328     Examples\n3329     ========\n3330 \n3331     >>> from sympy.stats import WignerSemicircle, density, E\n3332     >>> from sympy import Symbol, simplify\n3333 \n3334     >>> R = Symbol(\"R\", positive=True)\n3335     >>> z = Symbol(\"z\")\n3336 \n3337     >>> X = WignerSemicircle(\"x\", R)\n3338 \n3339     >>> density(X)(z)\n3340     2*sqrt(R**2 - z**2)/(pi*R**2)\n3341 \n3342     >>> E(X)\n3343     0\n3344 \n3345     References\n3346     ==========\n3347 \n3348     .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution\n3349     .. [2] http://mathworld.wolfram.com/WignersSemicircleLaw.html\n3350 \n3351     \"\"\"\n3352 \n3353     return rv(name, WignerSemicircleDistribution, (R,))\n",
        "intended_behavior": "Enhance or add parameter validation checks to ensure parameters meet the distribution-specific requirements, such as non-negative variances for normal distribution. Additionally, set attributes consistently and ensure they are valid and make sense within the context of each distribution. This could involve creating a standardized method for parameter checking that can be overridden in subclasses to enforce distribution-specific rules."
    },
    {
        "rel_file_path": "sympy/stats/drv_types.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/drv_types.py",
        "start": 1,
        "end": 520,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 \n3 Contains\n4 ========\n5 Geometric\n6 Poisson\n7 Logarithmic\n8 NegativeBinomial\n9 Poisson\n10 YuleSimon\n11 Zeta\n12 \"\"\"\n13 \n14 \n15 from __future__ import print_function, division\n16 \n17 from sympy import (factorial, exp, S, sympify, And, I, zeta, polylog, log, beta,\n18     hyper, binomial, Piecewise, floor)\n19 from sympy.stats import density\n20 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace\n21 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution\n22 from sympy.stats.rv import _value_check, RandomSymbol\n23 import random\n24 \n25 __all__ = ['Geometric',\n26 'Logarithmic',\n27 'NegativeBinomial',\n28 'Poisson',\n29 'YuleSimon',\n30 'Zeta'\n31 ]\n32 \n33 \n34 def rv(symbol, cls, *args):\n35     args = list(map(sympify, args))\n36     dist = cls(*args)\n37     dist.check(*args)\n38     pspace = SingleDiscretePSpace(symbol, dist)\n39     if any(isinstance(arg, RandomSymbol) for arg in args):\n40         pspace = JointPSpace(symbol, CompoundDistribution(dist))\n41     return pspace.value\n42 \n43 \n44 #-------------------------------------------------------------------------------\n45 # Geometric distribution ------------------------------------------------------------\n46 \n47 class GeometricDistribution(SingleDiscreteDistribution):\n48     _argnames = ('p',)\n49     set = S.Naturals\n50 \n51     @staticmethod\n52     def check(p):\n53         _value_check((0 < p, p <= 1), \"p must be between 0 and 1\")\n54 \n55     def pdf(self, k):\n56         return (1 - self.p)**(k - 1) * self.p\n57 \n58     def _characteristic_function(self, t):\n59         p = self.p\n60         return p * exp(I*t) / (1 - (1 - p)*exp(I*t))\n61 \n62     def _moment_generating_function(self, t):\n63         p = self.p\n64         return p * exp(t) / (1 - (1 - p) * exp(t))\n65 \n66 def Geometric(name, p):\n67     r\"\"\"\n68     Create a discrete random variable with a Geometric distribution.\n69 \n70     The density of the Geometric distribution is given by\n71 \n72     .. math::\n73         f(k) := p (1 - p)^{k - 1}\n74 \n75     Parameters\n76     ==========\n77 \n78     p: A probability between 0 and 1\n79 \n80     Returns\n81     =======\n82 \n83     A RandomSymbol.\n84 \n85     Examples\n86     ========\n87 \n88     >>> from sympy.stats import Geometric, density, E, variance\n89     >>> from sympy import Symbol, S\n90 \n91     >>> p = S.One / 5\n92     >>> z = Symbol(\"z\")\n93 \n94     >>> X = Geometric(\"x\", p)\n95 \n96     >>> density(X)(z)\n97     (4/5)**(z - 1)/5\n98 \n99     >>> E(X)\n100     5\n101 \n102     >>> variance(X)\n103     20\n104 \n105     References\n106     ==========\n107 \n108     .. [1] https://en.wikipedia.org/wiki/Geometric_distribution\n109     .. [2] http://mathworld.wolfram.com/GeometricDistribution.html\n110 \n111     \"\"\"\n112     return rv(name, GeometricDistribution, p)\n113 \n114 \n115 #-------------------------------------------------------------------------------\n116 # Logarithmic distribution ------------------------------------------------------------\n117 \n118 class LogarithmicDistribution(SingleDiscreteDistribution):\n119     _argnames = ('p',)\n120 \n121     set = S.Naturals\n122 \n123     @staticmethod\n124     def check(p):\n125         _value_check((p > 0, p < 1), \"p should be between 0 and 1\")\n126 \n127     def pdf(self, k):\n128         p = self.p\n129         return (-1) * p**k / (k * log(1 - p))\n130 \n131     def _characteristic_function(self, t):\n132         p = self.p\n133         return log(1 - p * exp(I*t)) / log(1 - p)\n134 \n135     def _moment_generating_function(self, t):\n136         p = self.p\n137         return log(1 - p * exp(t)) / log(1 - p)\n138 \n139     def sample(self):\n140         ### TODO\n141         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n142 \n143 \n144 def Logarithmic(name, p):\n145     r\"\"\"\n146     Create a discrete random variable with a Logarithmic distribution.\n147 \n148     The density of the Logarithmic distribution is given by\n149 \n150     .. math::\n151         f(k) := \\frac{-p^k}{k \\ln{(1 - p)}}\n152 \n153     Parameters\n154     ==========\n155 \n156     p: A value between 0 and 1\n157 \n158     Returns\n159     =======\n160 \n161     A RandomSymbol.\n162 \n163     Examples\n164     ========\n165 \n166     >>> from sympy.stats import Logarithmic, density, E, variance\n167     >>> from sympy import Symbol, S\n168 \n169     >>> p = S.One / 5\n170     >>> z = Symbol(\"z\")\n171 \n172     >>> X = Logarithmic(\"x\", p)\n173 \n174     >>> density(X)(z)\n175     -5**(-z)/(z*log(4/5))\n176 \n177     >>> E(X)\n178     -1/(-4*log(5) + 8*log(2))\n179 \n180     >>> variance(X)\n181     -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))\n182 \n183     References\n184     ==========\n185 \n186     .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution\n187     .. [2] http://mathworld.wolfram.com/LogarithmicDistribution.html\n188 \n189     \"\"\"\n190     return rv(name, LogarithmicDistribution, p)\n191 \n192 \n193 #-------------------------------------------------------------------------------\n194 # Negative binomial distribution ------------------------------------------------------------\n195 \n196 class NegativeBinomialDistribution(SingleDiscreteDistribution):\n197     _argnames = ('r', 'p')\n198     set = S.Naturals0\n199 \n200     @staticmethod\n201     def check(r, p):\n202         _value_check(r > 0, 'r should be positive')\n203         _value_check((p > 0, p < 1), 'p should be between 0 and 1')\n204 \n205     def pdf(self, k):\n206         r = self.r\n207         p = self.p\n208 \n209         return binomial(k + r - 1, k) * (1 - p)**r * p**k\n210 \n211     def _characteristic_function(self, t):\n212         r = self.r\n213         p = self.p\n214 \n215         return ((1 - p) / (1 - p * exp(I*t)))**r\n216 \n217     def _moment_generating_function(self, t):\n218         r = self.r\n219         p = self.p\n220 \n221         return ((1 - p) / (1 - p * exp(t)))**r\n222 \n223     def sample(self):\n224         ### TODO\n225         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n226 \n227 \n228 def NegativeBinomial(name, r, p):\n229     r\"\"\"\n230     Create a discrete random variable with a Negative Binomial distribution.\n231 \n232     The density of the Negative Binomial distribution is given by\n233 \n234     .. math::\n235         f(k) := \\binom{k + r - 1}{k} (1 - p)^r p^k\n236 \n237     Parameters\n238     ==========\n239 \n240     r: A positive value\n241     p: A value between 0 and 1\n242 \n243     Returns\n244     =======\n245 \n246     A RandomSymbol.\n247 \n248     Examples\n249     ========\n250 \n251     >>> from sympy.stats import NegativeBinomial, density, E, variance\n252     >>> from sympy import Symbol, S\n253 \n254     >>> r = 5\n255     >>> p = S.One / 5\n256     >>> z = Symbol(\"z\")\n257 \n258     >>> X = NegativeBinomial(\"x\", r, p)\n259 \n260     >>> density(X)(z)\n261     1024*5**(-z)*binomial(z + 4, z)/3125\n262 \n263     >>> E(X)\n264     5/4\n265 \n266     >>> variance(X)\n267     25/16\n268 \n269     References\n270     ==========\n271 \n272     .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution\n273     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html\n274 \n275     \"\"\"\n276     return rv(name, NegativeBinomialDistribution, r, p)\n277 \n278 \n279 #-------------------------------------------------------------------------------\n280 # Poisson distribution ------------------------------------------------------------\n281 \n282 class PoissonDistribution(SingleDiscreteDistribution):\n283     _argnames = ('lamda',)\n284 \n285     set = S.Naturals0\n286 \n287     @staticmethod\n288     def check(lamda):\n289         _value_check(lamda > 0, \"Lambda must be positive\")\n290 \n291     def pdf(self, k):\n292         return self.lamda**k / factorial(k) * exp(-self.lamda)\n293 \n294     def sample(self):\n295         def search(x, y, u):\n296             while x < y:\n297                 mid = (x + y)//2\n298                 if u <= self.cdf(mid):\n299                     y = mid\n300                 else:\n301                     x = mid + 1\n302             return x\n303 \n304         u = random.uniform(0, 1)\n305         if u <= self.cdf(S.Zero):\n306             return S.Zero\n307         n = S.One\n308         while True:\n309             if u > self.cdf(2*n):\n310                 n *= 2\n311             else:\n312                 return search(n, 2*n, u)\n313 \n314     def _characteristic_function(self, t):\n315         return exp(self.lamda * (exp(I*t) - 1))\n316 \n317     def _moment_generating_function(self, t):\n318         return exp(self.lamda * (exp(t) - 1))\n319 \n320 \n321 def Poisson(name, lamda):\n322     r\"\"\"\n323     Create a discrete random variable with a Poisson distribution.\n324 \n325     The density of the Poisson distribution is given by\n326 \n327     .. math::\n328         f(k) := \\frac{\\lambda^{k} e^{- \\lambda}}{k!}\n329 \n330     Parameters\n331     ==========\n332 \n333     lamda: Positive number, a rate\n334 \n335     Returns\n336     =======\n337 \n338     A RandomSymbol.\n339 \n340     Examples\n341     ========\n342 \n343     >>> from sympy.stats import Poisson, density, E, variance\n344     >>> from sympy import Symbol, simplify\n345 \n346     >>> rate = Symbol(\"lambda\", positive=True)\n347     >>> z = Symbol(\"z\")\n348 \n349     >>> X = Poisson(\"x\", rate)\n350 \n351     >>> density(X)(z)\n352     lambda**z*exp(-lambda)/factorial(z)\n353 \n354     >>> E(X)\n355     lambda\n356 \n357     >>> simplify(variance(X))\n358     lambda\n359 \n360     References\n361     ==========\n362 \n363     .. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n364     .. [2] http://mathworld.wolfram.com/PoissonDistribution.html\n365 \n366     \"\"\"\n367     return rv(name, PoissonDistribution, lamda)\n368 \n369 \n370 #-------------------------------------------------------------------------------\n371 # Yule-Simon distribution ------------------------------------------------------------\n372 \n373 class YuleSimonDistribution(SingleDiscreteDistribution):\n374     _argnames = ('rho',)\n375     set = S.Naturals\n376 \n377     @staticmethod\n378     def check(rho):\n379         _value_check(rho > 0, 'rho should be positive')\n380 \n381     def pdf(self, k):\n382         rho = self.rho\n383         return rho * beta(k, rho + 1)\n384 \n385     def _cdf(self, x):\n386         return Piecewise((1 - floor(x) * beta(floor(x), self.rho + 1), x >= 1), (0, True))\n387 \n388     def _characteristic_function(self, t):\n389         rho = self.rho\n390         return rho * hyper((1, 1), (rho + 2,), exp(I*t)) * exp(I*t) / (rho + 1)\n391 \n392     def _moment_generating_function(self, t):\n393         rho = self.rho\n394         return rho * hyper((1, 1), (rho + 2,), exp(t)) * exp(t) / (rho + 1)\n395 \n396     def sample(self):\n397         ### TODO\n398         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n399 \n400 \n401 def YuleSimon(name, rho):\n402     r\"\"\"\n403     Create a discrete random variable with a Yule-Simon distribution.\n404 \n405     The density of the Yule-Simon distribution is given by\n406 \n407     .. math::\n408         f(k) := \\rho B(k, \\rho + 1)\n409 \n410     Parameters\n411     ==========\n412 \n413     rho: A positive value\n414 \n415     Returns\n416     =======\n417 \n418     A RandomSymbol.\n419 \n420     Examples\n421     ========\n422 \n423     >>> from sympy.stats import YuleSimon, density, E, variance\n424     >>> from sympy import Symbol, simplify\n425 \n426     >>> p = 5\n427     >>> z = Symbol(\"z\")\n428 \n429     >>> X = YuleSimon(\"x\", p)\n430 \n431     >>> density(X)(z)\n432     5*beta(z, 6)\n433 \n434     >>> simplify(E(X))\n435     5/4\n436 \n437     >>> simplify(variance(X))\n438     25/48\n439 \n440     References\n441     ==========\n442 \n443     .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution\n444 \n445     \"\"\"\n446     return rv(name, YuleSimonDistribution, rho)\n447 \n448 \n449 #-------------------------------------------------------------------------------\n450 # Zeta distribution ------------------------------------------------------------\n451 \n452 class ZetaDistribution(SingleDiscreteDistribution):\n453     _argnames = ('s',)\n454     set = S.Naturals\n455 \n456     @staticmethod\n457     def check(s):\n458         _value_check(s > 1, 's should be greater than 1')\n459 \n460     def pdf(self, k):\n461         s = self.s\n462         return 1 / (k**s * zeta(s))\n463 \n464     def _characteristic_function(self, t):\n465         return polylog(self.s, exp(I*t)) / zeta(self.s)\n466 \n467     def _moment_generating_function(self, t):\n468         return polylog(self.s, exp(t)) / zeta(self.s)\n469 \n470     def sample(self):\n471         ### TODO\n472         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n473 \n474 \n475 def Zeta(name, s):\n476     r\"\"\"\n477     Create a discrete random variable with a Zeta distribution.\n478 \n479     The density of the Zeta distribution is given by\n480 \n481     .. math::\n482         f(k) := \\frac{1}{k^s \\zeta{(s)}}\n483 \n484     Parameters\n485     ==========\n486 \n487     s: A value greater than 1\n488 \n489     Returns\n490     =======\n491 \n492     A RandomSymbol.\n493 \n494     Examples\n495     ========\n496 \n497     >>> from sympy.stats import Zeta, density, E, variance\n498     >>> from sympy import Symbol\n499 \n500     >>> s = 5\n501     >>> z = Symbol(\"z\")\n502 \n503     >>> X = Zeta(\"x\", s)\n504 \n505     >>> density(X)(z)\n506     1/(z**5*zeta(5))\n507 \n508     >>> E(X)\n509     pi**4/(90*zeta(5))\n510 \n511     >>> variance(X)\n512     -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)\n513 \n514     References\n515     ==========\n516 \n517     .. [1] https://en.wikipedia.org/wiki/Zeta_distribution\n518 \n519     \"\"\"\n520     return rv(name, ZetaDistribution, s)\n",
        "intended_behavior": "Ensure parameter validation for discrete distributions. For example, check that the number of trials in a Binomial distribution is a positive integer, and the probability of success is between 0 and 1. Implement or ensure consistent and correct attribute assignment reflecting the distribution's parameters."
    },
    {
        "rel_file_path": "sympy/stats/rv.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/rv.py",
        "start": 1,
        "end": 1383,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Main Random Variables Module\n3 \n4 Defines abstract random variable type.\n5 Contains interfaces for probability space object (PSpace) as well as standard\n6 operators, P, E, sample, density, where, quantile\n7 \n8 See Also\n9 ========\n10 \n11 sympy.stats.crv\n12 sympy.stats.frv\n13 sympy.stats.rv_interface\n14 \"\"\"\n15 \n16 from __future__ import print_function, division\n17 \n18 from sympy import (Basic, S, Expr, Symbol, Tuple, And, Add, Eq, lambdify,\n19         Equality, Lambda, sympify, Dummy, Ne, KroneckerDelta,\n20         DiracDelta, Mul)\n21 from sympy.abc import x\n22 from sympy.core.compatibility import string_types\n23 from sympy.core.relational import Relational\n24 from sympy.logic.boolalg import Boolean\n25 from sympy.sets.sets import FiniteSet, ProductSet, Intersection\n26 from sympy.solvers.solveset import solveset\n27 \n28 \n29 class RandomDomain(Basic):\n30     \"\"\"\n31     Represents a set of variables and the values which they can take\n32 \n33     See Also\n34     ========\n35 \n36     sympy.stats.crv.ContinuousDomain\n37     sympy.stats.frv.FiniteDomain\n38     \"\"\"\n39 \n40     is_ProductDomain = False\n41     is_Finite = False\n42     is_Continuous = False\n43     is_Discrete = False\n44 \n45     def __new__(cls, symbols, *args):\n46         symbols = FiniteSet(*symbols)\n47         return Basic.__new__(cls, symbols, *args)\n48 \n49     @property\n50     def symbols(self):\n51         return self.args[0]\n52 \n53     @property\n54     def set(self):\n55         return self.args[1]\n56 \n57     def __contains__(self, other):\n58         raise NotImplementedError()\n59 \n60     def compute_expectation(self, expr):\n61         raise NotImplementedError()\n62 \n63 \n64 class SingleDomain(RandomDomain):\n65     \"\"\"\n66     A single variable and its domain\n67 \n68     See Also\n69     ========\n70 \n71     sympy.stats.crv.SingleContinuousDomain\n72     sympy.stats.frv.SingleFiniteDomain\n73     \"\"\"\n74     def __new__(cls, symbol, set):\n75         assert symbol.is_Symbol\n76         return Basic.__new__(cls, symbol, set)\n77 \n78     @property\n79     def symbol(self):\n80         return self.args[0]\n81 \n82     @property\n83     def symbols(self):\n84         return FiniteSet(self.symbol)\n85 \n86     def __contains__(self, other):\n87         if len(other) != 1:\n88             return False\n89         sym, val = tuple(other)[0]\n90         return self.symbol == sym and val in self.set\n91 \n92 \n93 class ConditionalDomain(RandomDomain):\n94     \"\"\"\n95     A RandomDomain with an attached condition\n96 \n97     See Also\n98     ========\n99 \n100     sympy.stats.crv.ConditionalContinuousDomain\n101     sympy.stats.frv.ConditionalFiniteDomain\n102     \"\"\"\n103     def __new__(cls, fulldomain, condition):\n104         condition = condition.xreplace(dict((rs, rs.symbol)\n105             for rs in random_symbols(condition)))\n106         return Basic.__new__(cls, fulldomain, condition)\n107 \n108     @property\n109     def symbols(self):\n110         return self.fulldomain.symbols\n111 \n112     @property\n113     def fulldomain(self):\n114         return self.args[0]\n115 \n116     @property\n117     def condition(self):\n118         return self.args[1]\n119 \n120     @property\n121     def set(self):\n122         raise NotImplementedError(\"Set of Conditional Domain not Implemented\")\n123 \n124     def as_boolean(self):\n125         return And(self.fulldomain.as_boolean(), self.condition)\n126 \n127 \n128 class PSpace(Basic):\n129     \"\"\"\n130     A Probability Space\n131 \n132     Probability Spaces encode processes that equal different values\n133     probabilistically. These underly Random Symbols which occur in SymPy\n134     expressions and contain the mechanics to evaluate statistical statements.\n135 \n136     See Also\n137     ========\n138 \n139     sympy.stats.crv.ContinuousPSpace\n140     sympy.stats.frv.FinitePSpace\n141     \"\"\"\n142 \n143     is_Finite = None\n144     is_Continuous = None\n145     is_Discrete = None\n146     is_real = None\n147 \n148     @property\n149     def domain(self):\n150         return self.args[0]\n151 \n152     @property\n153     def density(self):\n154         return self.args[1]\n155 \n156     @property\n157     def values(self):\n158         return frozenset(RandomSymbol(sym, self) for sym in self.symbols)\n159 \n160     @property\n161     def symbols(self):\n162         return self.domain.symbols\n163 \n164     def where(self, condition):\n165         raise NotImplementedError()\n166 \n167     def compute_density(self, expr):\n168         raise NotImplementedError()\n169 \n170     def sample(self):\n171         raise NotImplementedError()\n172 \n173     def probability(self, condition):\n174         raise NotImplementedError()\n175 \n176     def compute_expectation(self, expr):\n177         raise NotImplementedError()\n178 \n179 \n180 class SinglePSpace(PSpace):\n181     \"\"\"\n182     Represents the probabilities of a set of random events that can be\n183     attributed to a single variable/symbol.\n184     \"\"\"\n185     def __new__(cls, s, distribution):\n186         if isinstance(s, string_types):\n187             s = Symbol(s)\n188         if not isinstance(s, Symbol):\n189             raise TypeError(\"s should have been string or Symbol\")\n190         return Basic.__new__(cls, s, distribution)\n191 \n192     @property\n193     def value(self):\n194         return RandomSymbol(self.symbol, self)\n195 \n196     @property\n197     def symbol(self):\n198         return self.args[0]\n199 \n200     @property\n201     def distribution(self):\n202         return self.args[1]\n203 \n204     @property\n205     def pdf(self):\n206         return self.distribution.pdf(self.symbol)\n207 \n208 \n209 class RandomSymbol(Expr):\n210     \"\"\"\n211     Random Symbols represent ProbabilitySpaces in SymPy Expressions\n212     In principle they can take on any value that their symbol can take on\n213     within the associated PSpace with probability determined by the PSpace\n214     Density.\n215 \n216     Random Symbols contain pspace and symbol properties.\n217     The pspace property points to the represented Probability Space\n218     The symbol is a standard SymPy Symbol that is used in that probability space\n219     for example in defining a density.\n220 \n221     You can form normal SymPy expressions using RandomSymbols and operate on\n222     those expressions with the Functions\n223 \n224     E - Expectation of a random expression\n225     P - Probability of a condition\n226     density - Probability Density of an expression\n227     given - A new random expression (with new random symbols) given a condition\n228 \n229     An object of the RandomSymbol type should almost never be created by the\n230     user. They tend to be created instead by the PSpace class's value method.\n231     Traditionally a user doesn't even do this but instead calls one of the\n232     convenience functions Normal, Exponential, Coin, Die, FiniteRV, etc....\n233     \"\"\"\n234 \n235     def __new__(cls, symbol, pspace=None):\n236         from sympy.stats.joint_rv import JointRandomSymbol\n237         if pspace is None:\n238             # Allow single arg, representing pspace == PSpace()\n239             pspace = PSpace()\n240         if not isinstance(symbol, Symbol):\n241             raise TypeError(\"symbol should be of type Symbol\")\n242         if not isinstance(pspace, PSpace):\n243             raise TypeError(\"pspace variable should be of type PSpace\")\n244         if cls == JointRandomSymbol and isinstance(pspace, SinglePSpace):\n245             cls = RandomSymbol\n246         return Basic.__new__(cls, symbol, pspace)\n247 \n248     is_finite = True\n249     is_symbol = True\n250     is_Atom = True\n251 \n252     _diff_wrt = True\n253 \n254     pspace = property(lambda self: self.args[1])\n255     symbol = property(lambda self: self.args[0])\n256     name   = property(lambda self: self.symbol.name)\n257 \n258     def _eval_is_positive(self):\n259         return self.symbol.is_positive\n260 \n261     def _eval_is_integer(self):\n262         return self.symbol.is_integer\n263 \n264     def _eval_is_real(self):\n265         return self.symbol.is_real or self.pspace.is_real\n266 \n267     @property\n268     def is_commutative(self):\n269         return self.symbol.is_commutative\n270 \n271     def _hashable_content(self):\n272         return self.pspace, self.symbol\n273 \n274     @property\n275     def free_symbols(self):\n276         return {self}\n277 \n278 \n279 class ProductPSpace(PSpace):\n280     \"\"\"\n281     Abstract class for representing probability spaces with multiple random\n282     variables.\n283 \n284     See Also\n285     ========\n286 \n287     sympy.stats.rv.IndependentProductPSpace\n288     sympy.stats.joint_rv.JointPSpace\n289     \"\"\"\n290     pass\n291 \n292 class IndependentProductPSpace(ProductPSpace):\n293     \"\"\"\n294     A probability space resulting from the merger of two independent probability\n295     spaces.\n296 \n297     Often created using the function, pspace\n298     \"\"\"\n299 \n300     def __new__(cls, *spaces):\n301         rs_space_dict = {}\n302         for space in spaces:\n303             for value in space.values:\n304                 rs_space_dict[value] = space\n305 \n306         symbols = FiniteSet(*[val.symbol for val in rs_space_dict.keys()])\n307 \n308         # Overlapping symbols\n309         from sympy.stats.joint_rv import MarginalDistribution, CompoundDistribution\n310         if len(symbols) < sum(len(space.symbols) for space in spaces if not\n311          isinstance(space.distribution, (\n312             CompoundDistribution, MarginalDistribution))):\n313             raise ValueError(\"Overlapping Random Variables\")\n314 \n315         if all(space.is_Finite for space in spaces):\n316             from sympy.stats.frv import ProductFinitePSpace\n317             cls = ProductFinitePSpace\n318 \n319         obj = Basic.__new__(cls, *FiniteSet(*spaces))\n320 \n321         return obj\n322 \n323     @property\n324     def pdf(self):\n325         p = Mul(*[space.pdf for space in self.spaces])\n326         return p.subs(dict((rv, rv.symbol) for rv in self.values))\n327 \n328     @property\n329     def rs_space_dict(self):\n330         d = {}\n331         for space in self.spaces:\n332             for value in space.values:\n333                 d[value] = space\n334         return d\n335 \n336     @property\n337     def symbols(self):\n338         return FiniteSet(*[val.symbol for val in self.rs_space_dict.keys()])\n339 \n340     @property\n341     def spaces(self):\n342         return FiniteSet(*self.args)\n343 \n344     @property\n345     def values(self):\n346         return sumsets(space.values for space in self.spaces)\n347 \n348     def compute_expectation(self, expr, rvs=None, evaluate=False, **kwargs):\n349         rvs = rvs or self.values\n350         rvs = frozenset(rvs)\n351         for space in self.spaces:\n352             expr = space.compute_expectation(expr, rvs & space.values, evaluate=False, **kwargs)\n353         if evaluate and hasattr(expr, 'doit'):\n354             return expr.doit(**kwargs)\n355         return expr\n356 \n357     @property\n358     def domain(self):\n359         return ProductDomain(*[space.domain for space in self.spaces])\n360 \n361     @property\n362     def density(self):\n363         raise NotImplementedError(\"Density not available for ProductSpaces\")\n364 \n365     def sample(self):\n366         return {k: v for space in self.spaces\n367             for k, v in space.sample().items()}\n368 \n369     def probability(self, condition, **kwargs):\n370         cond_inv = False\n371         if isinstance(condition, Ne):\n372             condition = Eq(condition.args[0], condition.args[1])\n373             cond_inv = True\n374         expr = condition.lhs - condition.rhs\n375         rvs = random_symbols(expr)\n376         z = Dummy('z', real=True, Finite=True)\n377         dens = self.compute_density(expr)\n378         if any([pspace(rv).is_Continuous for rv in rvs]):\n379             from sympy.stats.crv import (ContinuousDistributionHandmade,\n380                 SingleContinuousPSpace)\n381             if expr in self.values:\n382                 # Marginalize all other random symbols out of the density\n383                 randomsymbols = tuple(set(self.values) - frozenset([expr]))\n384                 symbols = tuple(rs.symbol for rs in randomsymbols)\n385                 pdf = self.domain.integrate(self.pdf, symbols, **kwargs)\n386                 return Lambda(expr.symbol, pdf)\n387             dens = ContinuousDistributionHandmade(dens)\n388             space = SingleContinuousPSpace(z, dens)\n389             result = space.probability(condition.__class__(space.value, 0))\n390         else:\n391             from sympy.stats.drv import (DiscreteDistributionHandmade,\n392                 SingleDiscretePSpace)\n393             dens = DiscreteDistributionHandmade(dens)\n394             space = SingleDiscretePSpace(z, dens)\n395             result = space.probability(condition.__class__(space.value, 0))\n396         return result if not cond_inv else S.One - result\n397 \n398     def compute_density(self, expr, **kwargs):\n399         z = Dummy('z', real=True, finite=True)\n400         rvs = random_symbols(expr)\n401         if any(pspace(rv).is_Continuous for rv in rvs):\n402             expr = self.compute_expectation(DiracDelta(expr - z),\n403              **kwargs)\n404         else:\n405             expr = self.compute_expectation(KroneckerDelta(expr, z),\n406              **kwargs)\n407         return Lambda(z, expr)\n408 \n409     def compute_cdf(self, expr, **kwargs):\n410         raise ValueError(\"CDF not well defined on multivariate expressions\")\n411 \n412     def conditional_space(self, condition, normalize=True, **kwargs):\n413         rvs = random_symbols(condition)\n414         condition = condition.xreplace(dict((rv, rv.symbol) for rv in self.values))\n415         if any([pspace(rv).is_Continuous for rv in rvs]):\n416             from sympy.stats.crv import (ConditionalContinuousDomain,\n417                 ContinuousPSpace)\n418             space = ContinuousPSpace\n419             domain = ConditionalContinuousDomain(self.domain, condition)\n420         elif any([pspace(rv).is_Discrete for rv in rvs]):\n421             from sympy.stats.drv import (ConditionalDiscreteDomain,\n422                 DiscretePSpace)\n423             space = DiscretePSpace\n424             domain = ConditionalDiscreteDomain(self.domain, condition)\n425         elif all([pspace(rv).is_Finite for rv in rvs]):\n426             from sympy.stats.frv import FinitePSpace\n427             return FinitePSpace.conditional_space(self, condition)\n428         if normalize:\n429             replacement  = {rv: Dummy(str(rv)) for rv in self.symbols}\n430             norm = domain.compute_expectation(self.pdf, **kwargs)\n431             pdf = self.pdf / norm.xreplace(replacement)\n432             density = Lambda(domain.symbols, pdf)\n433 \n434         return space(domain, density)\n435 \n436 class ProductDomain(RandomDomain):\n437     \"\"\"\n438     A domain resulting from the merger of two independent domains\n439 \n440     See Also\n441     ========\n442     sympy.stats.crv.ProductContinuousDomain\n443     sympy.stats.frv.ProductFiniteDomain\n444     \"\"\"\n445     is_ProductDomain = True\n446 \n447     def __new__(cls, *domains):\n448         # Flatten any product of products\n449         domains2 = []\n450         for domain in domains:\n451             if not domain.is_ProductDomain:\n452                 domains2.append(domain)\n453             else:\n454                 domains2.extend(domain.domains)\n455         domains2 = FiniteSet(*domains2)\n456 \n457         if all(domain.is_Finite for domain in domains2):\n458             from sympy.stats.frv import ProductFiniteDomain\n459             cls = ProductFiniteDomain\n460         if all(domain.is_Continuous for domain in domains2):\n461             from sympy.stats.crv import ProductContinuousDomain\n462             cls = ProductContinuousDomain\n463         if all(domain.is_Discrete for domain in domains2):\n464             from sympy.stats.drv import ProductDiscreteDomain\n465             cls = ProductDiscreteDomain\n466 \n467         return Basic.__new__(cls, *domains2)\n468 \n469     @property\n470     def sym_domain_dict(self):\n471         return dict((symbol, domain) for domain in self.domains\n472                                      for symbol in domain.symbols)\n473 \n474     @property\n475     def symbols(self):\n476         return FiniteSet(*[sym for domain in self.domains\n477                                for sym    in domain.symbols])\n478 \n479     @property\n480     def domains(self):\n481         return self.args\n482 \n483     @property\n484     def set(self):\n485         return ProductSet(domain.set for domain in self.domains)\n486 \n487     def __contains__(self, other):\n488         # Split event into each subdomain\n489         for domain in self.domains:\n490             # Collect the parts of this event which associate to this domain\n491             elem = frozenset([item for item in other\n492                               if sympify(domain.symbols.contains(item[0]))\n493                               is S.true])\n494             # Test this sub-event\n495             if elem not in domain:\n496                 return False\n497         # All subevents passed\n498         return True\n499 \n500     def as_boolean(self):\n501         return And(*[domain.as_boolean() for domain in self.domains])\n502 \n503 \n504 def random_symbols(expr):\n505     \"\"\"\n506     Returns all RandomSymbols within a SymPy Expression.\n507     \"\"\"\n508     atoms = getattr(expr, 'atoms', None)\n509     if atoms is not None:\n510         return list(atoms(RandomSymbol))\n511     else:\n512         return []\n513 \n514 \n515 def pspace(expr):\n516     \"\"\"\n517     Returns the underlying Probability Space of a random expression.\n518 \n519     For internal use.\n520 \n521     Examples\n522     ========\n523 \n524     >>> from sympy.stats import pspace, Normal\n525     >>> from sympy.stats.rv import IndependentProductPSpace\n526     >>> X = Normal('X', 0, 1)\n527     >>> pspace(2*X + 1) == X.pspace\n528     True\n529     \"\"\"\n530     expr = sympify(expr)\n531     if isinstance(expr, RandomSymbol) and expr.pspace is not None:\n532         return expr.pspace\n533     rvs = random_symbols(expr)\n534     if not rvs:\n535         raise ValueError(\"Expression containing Random Variable expected, not %s\" % (expr))\n536     # If only one space present\n537     if all(rv.pspace == rvs[0].pspace for rv in rvs):\n538         return rvs[0].pspace\n539     # Otherwise make a product space\n540     return IndependentProductPSpace(*[rv.pspace for rv in rvs])\n541 \n542 \n543 def sumsets(sets):\n544     \"\"\"\n545     Union of sets\n546     \"\"\"\n547     return frozenset().union(*sets)\n548 \n549 \n550 def rs_swap(a, b):\n551     \"\"\"\n552     Build a dictionary to swap RandomSymbols based on their underlying symbol.\n553 \n554     i.e.\n555     if    ``X = ('x', pspace1)``\n556     and   ``Y = ('x', pspace2)``\n557     then ``X`` and ``Y`` match and the key, value pair\n558     ``{X:Y}`` will appear in the result\n559 \n560     Inputs: collections a and b of random variables which share common symbols\n561     Output: dict mapping RVs in a to RVs in b\n562     \"\"\"\n563     d = {}\n564     for rsa in a:\n565         d[rsa] = [rsb for rsb in b if rsa.symbol == rsb.symbol][0]\n566     return d\n567 \n568 \n569 def given(expr, condition=None, **kwargs):\n570     r\"\"\" Conditional Random Expression\n571     From a random expression and a condition on that expression creates a new\n572     probability space from the condition and returns the same expression on that\n573     conditional probability space.\n574 \n575     Examples\n576     ========\n577 \n578     >>> from sympy.stats import given, density, Die\n579     >>> X = Die('X', 6)\n580     >>> Y = given(X, X > 3)\n581     >>> density(Y).dict\n582     {4: 1/3, 5: 1/3, 6: 1/3}\n583 \n584     Following convention, if the condition is a random symbol then that symbol\n585     is considered fixed.\n586 \n587     >>> from sympy.stats import Normal\n588     >>> from sympy import pprint\n589     >>> from sympy.abc import z\n590 \n591     >>> X = Normal('X', 0, 1)\n592     >>> Y = Normal('Y', 0, 1)\n593     >>> pprint(density(X + Y, Y)(z), use_unicode=False)\n594                     2\n595            -(-Y + z)\n596            -----------\n597       ___       2\n598     \\/ 2 *e\n599     ------------------\n600              ____\n601          2*\\/ pi\n602     \"\"\"\n603 \n604     if not random_symbols(condition) or pspace_independent(expr, condition):\n605         return expr\n606 \n607     if isinstance(condition, RandomSymbol):\n608         condition = Eq(condition, condition.symbol)\n609 \n610     condsymbols = random_symbols(condition)\n611     if (isinstance(condition, Equality) and len(condsymbols) == 1 and\n612         not isinstance(pspace(expr).domain, ConditionalDomain)):\n613         rv = tuple(condsymbols)[0]\n614 \n615         results = solveset(condition, rv)\n616         if isinstance(results, Intersection) and S.Reals in results.args:\n617             results = list(results.args[1])\n618 \n619         sums = 0\n620         for res in results:\n621             temp = expr.subs(rv, res)\n622             if temp == True:\n623                 return True\n624             if temp != False:\n625                 sums += expr.subs(rv, res)\n626         if sums == 0:\n627             return False\n628         return sums\n629 \n630     # Get full probability space of both the expression and the condition\n631     fullspace = pspace(Tuple(expr, condition))\n632     # Build new space given the condition\n633     space = fullspace.conditional_space(condition, **kwargs)\n634     # Dictionary to swap out RandomSymbols in expr with new RandomSymbols\n635     # That point to the new conditional space\n636     swapdict = rs_swap(fullspace.values, space.values)\n637     # Swap random variables in the expression\n638     expr = expr.xreplace(swapdict)\n639     return expr\n640 \n641 \n642 def expectation(expr, condition=None, numsamples=None, evaluate=True, **kwargs):\n643     \"\"\"\n644     Returns the expected value of a random expression\n645 \n646     Parameters\n647     ==========\n648 \n649     expr : Expr containing RandomSymbols\n650         The expression of which you want to compute the expectation value\n651     given : Expr containing RandomSymbols\n652         A conditional expression. E(X, X>0) is expectation of X given X > 0\n653     numsamples : int\n654         Enables sampling and approximates the expectation with this many samples\n655     evalf : Bool (defaults to True)\n656         If sampling return a number rather than a complex expression\n657     evaluate : Bool (defaults to True)\n658         In case of continuous systems return unevaluated integral\n659 \n660     Examples\n661     ========\n662 \n663     >>> from sympy.stats import E, Die\n664     >>> X = Die('X', 6)\n665     >>> E(X)\n666     7/2\n667     >>> E(2*X + 1)\n668     8\n669 \n670     >>> E(X, X > 3) # Expectation of X given that it is above 3\n671     5\n672     \"\"\"\n673 \n674     if not random_symbols(expr):  # expr isn't random?\n675         return expr\n676     if numsamples:  # Computing by monte carlo sampling?\n677         return sampling_E(expr, condition, numsamples=numsamples)\n678 \n679     # Create new expr and recompute E\n680     if condition is not None:  # If there is a condition\n681         return expectation(given(expr, condition), evaluate=evaluate)\n682 \n683     # A few known statements for efficiency\n684 \n685     if expr.is_Add:  # We know that E is Linear\n686         return Add(*[expectation(arg, evaluate=evaluate)\n687                      for arg in expr.args])\n688 \n689     # Otherwise case is simple, pass work off to the ProbabilitySpace\n690     result = pspace(expr).compute_expectation(expr, evaluate=evaluate, **kwargs)\n691     if evaluate and hasattr(result, 'doit'):\n692         return result.doit(**kwargs)\n693     else:\n694         return result\n695 \n696 \n697 def probability(condition, given_condition=None, numsamples=None,\n698                 evaluate=True, **kwargs):\n699     \"\"\"\n700     Probability that a condition is true, optionally given a second condition\n701 \n702     Parameters\n703     ==========\n704 \n705     condition : Combination of Relationals containing RandomSymbols\n706         The condition of which you want to compute the probability\n707     given_condition : Combination of Relationals containing RandomSymbols\n708         A conditional expression. P(X > 1, X > 0) is expectation of X > 1\n709         given X > 0\n710     numsamples : int\n711         Enables sampling and approximates the probability with this many samples\n712     evaluate : Bool (defaults to True)\n713         In case of continuous systems return unevaluated integral\n714 \n715     Examples\n716     ========\n717 \n718     >>> from sympy.stats import P, Die\n719     >>> from sympy import Eq\n720     >>> X, Y = Die('X', 6), Die('Y', 6)\n721     >>> P(X > 3)\n722     1/2\n723     >>> P(Eq(X, 5), X > 2) # Probability that X == 5 given that X > 2\n724     1/4\n725     >>> P(X > Y)\n726     5/12\n727     \"\"\"\n728 \n729     condition = sympify(condition)\n730     given_condition = sympify(given_condition)\n731 \n732     if isinstance(given_condition, RandomSymbol):\n733         if any([dependent(rv, given_condition) for rv in random_symbols(condition)]):\n734             from sympy.stats.symbolic_probability import Probability\n735             return Probability(condition, given_condition)\n736         else:\n737             return probability(condition)\n738 \n739     if given_condition is not None and \\\n740             not isinstance(given_condition, (Relational, Boolean)):\n741         raise ValueError(\"%s is not a relational or combination of relationals\"\n742                 % (given_condition))\n743     if given_condition == False:\n744         return S.Zero\n745     if not isinstance(condition, (Relational, Boolean)):\n746         raise ValueError(\"%s is not a relational or combination of relationals\"\n747                 % (condition))\n748     if condition is S.true:\n749         return S.One\n750     if condition is S.false:\n751         return S.Zero\n752 \n753     if numsamples:\n754         return sampling_P(condition, given_condition, numsamples=numsamples,\n755                 **kwargs)\n756     if given_condition is not None:  # If there is a condition\n757         # Recompute on new conditional expr\n758         return probability(given(condition, given_condition, **kwargs), **kwargs)\n759 \n760     # Otherwise pass work off to the ProbabilitySpace\n761     result = pspace(condition).probability(condition, **kwargs)\n762     if evaluate and hasattr(result, 'doit'):\n763         return result.doit()\n764     else:\n765         return result\n766 \n767 \n768 class Density(Basic):\n769     expr = property(lambda self: self.args[0])\n770 \n771     @property\n772     def condition(self):\n773         if len(self.args) > 1:\n774             return self.args[1]\n775         else:\n776             return None\n777 \n778     def doit(self, evaluate=True, **kwargs):\n779         from sympy.stats.joint_rv import JointPSpace\n780         expr, condition = self.expr, self.condition\n781         if condition is not None:\n782             # Recompute on new conditional expr\n783             expr = given(expr, condition, **kwargs)\n784         if isinstance(expr, RandomSymbol) and \\\n785             isinstance(expr.pspace, JointPSpace):\n786             return expr.pspace.distribution\n787         if not random_symbols(expr):\n788             return Lambda(x, DiracDelta(x - expr))\n789         if (isinstance(expr, RandomSymbol) and\n790             hasattr(expr.pspace, 'distribution') and\n791             isinstance(pspace(expr), (SinglePSpace))):\n792             return expr.pspace.distribution\n793         result = pspace(expr).compute_density(expr, **kwargs)\n794 \n795         if evaluate and hasattr(result, 'doit'):\n796             return result.doit()\n797         else:\n798             return result\n799 \n800 \n801 def density(expr, condition=None, evaluate=True, numsamples=None, **kwargs):\n802     \"\"\"\n803     Probability density of a random expression, optionally given a second\n804     condition.\n805 \n806     This density will take on different forms for different types of\n807     probability spaces. Discrete variables produce Dicts. Continuous\n808     variables produce Lambdas.\n809 \n810     Parameters\n811     ==========\n812 \n813     expr : Expr containing RandomSymbols\n814         The expression of which you want to compute the density value\n815     condition : Relational containing RandomSymbols\n816         A conditional expression. density(X > 1, X > 0) is density of X > 1\n817         given X > 0\n818     numsamples : int\n819         Enables sampling and approximates the density with this many samples\n820 \n821     Examples\n822     ========\n823 \n824     >>> from sympy.stats import density, Die, Normal\n825     >>> from sympy import Symbol\n826 \n827     >>> x = Symbol('x')\n828     >>> D = Die('D', 6)\n829     >>> X = Normal(x, 0, 1)\n830 \n831     >>> density(D).dict\n832     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n833     >>> density(2*D).dict\n834     {2: 1/6, 4: 1/6, 6: 1/6, 8: 1/6, 10: 1/6, 12: 1/6}\n835     >>> density(X)(x)\n836     sqrt(2)*exp(-x**2/2)/(2*sqrt(pi))\n837     \"\"\"\n838 \n839     if numsamples:\n840         return sampling_density(expr, condition, numsamples=numsamples,\n841                 **kwargs)\n842 \n843     return Density(expr, condition).doit(evaluate=evaluate, **kwargs)\n844 \n845 \n846 def cdf(expr, condition=None, evaluate=True, **kwargs):\n847     \"\"\"\n848     Cumulative Distribution Function of a random expression.\n849 \n850     optionally given a second condition\n851 \n852     This density will take on different forms for different types of\n853     probability spaces.\n854     Discrete variables produce Dicts.\n855     Continuous variables produce Lambdas.\n856 \n857     Examples\n858     ========\n859 \n860     >>> from sympy.stats import density, Die, Normal, cdf\n861 \n862     >>> D = Die('D', 6)\n863     >>> X = Normal('X', 0, 1)\n864 \n865     >>> density(D).dict\n866     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n867     >>> cdf(D)\n868     {1: 1/6, 2: 1/3, 3: 1/2, 4: 2/3, 5: 5/6, 6: 1}\n869     >>> cdf(3*D, D > 2)\n870     {9: 1/4, 12: 1/2, 15: 3/4, 18: 1}\n871 \n872     >>> cdf(X)\n873     Lambda(_z, erf(sqrt(2)*_z/2)/2 + 1/2)\n874     \"\"\"\n875     if condition is not None:  # If there is a condition\n876         # Recompute on new conditional expr\n877         return cdf(given(expr, condition, **kwargs), **kwargs)\n878 \n879     # Otherwise pass work off to the ProbabilitySpace\n880     result = pspace(expr).compute_cdf(expr, **kwargs)\n881 \n882     if evaluate and hasattr(result, 'doit'):\n883         return result.doit()\n884     else:\n885         return result\n886 \n887 \n888 def characteristic_function(expr, condition=None, evaluate=True, **kwargs):\n889     \"\"\"\n890     Characteristic function of a random expression, optionally given a second condition\n891 \n892     Returns a Lambda\n893 \n894     Examples\n895     ========\n896 \n897     >>> from sympy.stats import Normal, DiscreteUniform, Poisson, characteristic_function\n898 \n899     >>> X = Normal('X', 0, 1)\n900     >>> characteristic_function(X)\n901     Lambda(_t, exp(-_t**2/2))\n902 \n903     >>> Y = DiscreteUniform('Y', [1, 2, 7])\n904     >>> characteristic_function(Y)\n905     Lambda(_t, exp(7*_t*I)/3 + exp(2*_t*I)/3 + exp(_t*I)/3)\n906 \n907     >>> Z = Poisson('Z', 2)\n908     >>> characteristic_function(Z)\n909     Lambda(_t, exp(2*exp(_t*I) - 2))\n910     \"\"\"\n911     if condition is not None:\n912         return characteristic_function(given(expr, condition, **kwargs), **kwargs)\n913 \n914     result = pspace(expr).compute_characteristic_function(expr, **kwargs)\n915 \n916     if evaluate and hasattr(result, 'doit'):\n917         return result.doit()\n918     else:\n919         return result\n920 \n921 def moment_generating_function(expr, condition=None, evaluate=True, **kwargs):\n922     if condition is not None:\n923         return moment_generating_function(given(expr, condition, **kwargs), **kwargs)\n924 \n925     result = pspace(expr).compute_moment_generating_function(expr, **kwargs)\n926 \n927     if evaluate and hasattr(result, 'doit'):\n928         return result.doit()\n929     else:\n930         return result\n931 \n932 def where(condition, given_condition=None, **kwargs):\n933     \"\"\"\n934     Returns the domain where a condition is True.\n935 \n936     Examples\n937     ========\n938 \n939     >>> from sympy.stats import where, Die, Normal\n940     >>> from sympy import symbols, And\n941 \n942     >>> D1, D2 = Die('a', 6), Die('b', 6)\n943     >>> a, b = D1.symbol, D2.symbol\n944     >>> X = Normal('x', 0, 1)\n945 \n946     >>> where(X**2<1)\n947     Domain: (-1 < x) & (x < 1)\n948 \n949     >>> where(X**2<1).set\n950     Interval.open(-1, 1)\n951 \n952     >>> where(And(D1<=D2 , D2<3))\n953     Domain: (Eq(a, 1) & Eq(b, 1)) | (Eq(a, 1) & Eq(b, 2)) | (Eq(a, 2) & Eq(b, 2))\n954     \"\"\"\n955     if given_condition is not None:  # If there is a condition\n956         # Recompute on new conditional expr\n957         return where(given(condition, given_condition, **kwargs), **kwargs)\n958 \n959     # Otherwise pass work off to the ProbabilitySpace\n960     return pspace(condition).where(condition, **kwargs)\n961 \n962 \n963 def sample(expr, condition=None, **kwargs):\n964     \"\"\"\n965     A realization of the random expression\n966 \n967     Examples\n968     ========\n969 \n970     >>> from sympy.stats import Die, sample\n971     >>> X, Y, Z = Die('X', 6), Die('Y', 6), Die('Z', 6)\n972 \n973     >>> die_roll = sample(X + Y + Z) # A random realization of three dice\n974     \"\"\"\n975     return next(sample_iter(expr, condition, numsamples=1))\n976 \n977 \n978 def sample_iter(expr, condition=None, numsamples=S.Infinity, **kwargs):\n979     \"\"\"\n980     Returns an iterator of realizations from the expression given a condition\n981 \n982     Parameters\n983     ==========\n984 \n985     expr: Expr\n986         Random expression to be realized\n987     condition: Expr, optional\n988         A conditional expression\n989     numsamples: integer, optional\n990         Length of the iterator (defaults to infinity)\n991 \n992     Examples\n993     ========\n994 \n995     >>> from sympy.stats import Normal, sample_iter\n996     >>> X = Normal('X', 0, 1)\n997     >>> expr = X*X + 3\n998     >>> iterator = sample_iter(expr, numsamples=3)\n999     >>> list(iterator) # doctest: +SKIP\n1000     [12, 4, 7]\n1001 \n1002     See Also\n1003     ========\n1004 \n1005     sample\n1006     sampling_P\n1007     sampling_E\n1008     sample_iter_lambdify\n1009     sample_iter_subs\n1010 \n1011     \"\"\"\n1012     # lambdify is much faster but not as robust\n1013     try:\n1014         return sample_iter_lambdify(expr, condition, numsamples, **kwargs)\n1015     # use subs when lambdify fails\n1016     except TypeError:\n1017         return sample_iter_subs(expr, condition, numsamples, **kwargs)\n1018 \n1019 def quantile(expr, evaluate=True, **kwargs):\n1020     r\"\"\"\n1021     Return the :math:`p^{th}` order quantile of a probability distribution.\n1022 \n1023     Quantile is defined as the value at which the probability of the random\n1024     variable is less than or equal to the given probability.\n1025 \n1026     ..math::\n1027         Q(p) = inf{x \\in (-\\infty, \\infty) such that p <= F(x)}\n1028 \n1029     Examples\n1030     ========\n1031 \n1032     >>> from sympy.stats import quantile, Die, Exponential\n1033     >>> from sympy import Symbol, pprint\n1034     >>> p = Symbol(\"p\")\n1035 \n1036     >>> l = Symbol(\"lambda\", positive=True)\n1037     >>> X = Exponential(\"x\", l)\n1038     >>> quantile(X)(p)\n1039     -log(1 - p)/lambda\n1040 \n1041     >>> D = Die(\"d\", 6)\n1042     >>> pprint(quantile(D)(p), use_unicode=False)\n1043     /nan  for Or(p > 1, p < 0)\n1044     |\n1045     | 1       for p <= 1/6\n1046     |\n1047     | 2       for p <= 1/3\n1048     |\n1049     < 3       for p <= 1/2\n1050     |\n1051     | 4       for p <= 2/3\n1052     |\n1053     | 5       for p <= 5/6\n1054     |\n1055     \\ 6        for p <= 1\n1056 \n1057     \"\"\"\n1058     result = pspace(expr).compute_quantile(expr, **kwargs)\n1059 \n1060     if evaluate and hasattr(result, 'doit'):\n1061         return result.doit()\n1062     else:\n1063         return result\n1064 \n1065 def sample_iter_lambdify(expr, condition=None, numsamples=S.Infinity, **kwargs):\n1066     \"\"\"\n1067     See sample_iter\n1068 \n1069     Uses lambdify for computation. This is fast but does not always work.\n1070     \"\"\"\n1071     if condition:\n1072         ps = pspace(Tuple(expr, condition))\n1073     else:\n1074         ps = pspace(expr)\n1075 \n1076     rvs = list(ps.values)\n1077     fn = lambdify(rvs, expr, **kwargs)\n1078     if condition:\n1079         given_fn = lambdify(rvs, condition, **kwargs)\n1080 \n1081     # Check that lambdify can handle the expression\n1082     # Some operations like Sum can prove difficult\n1083     try:\n1084         d = ps.sample()  # a dictionary that maps RVs to values\n1085         args = [d[rv] for rv in rvs]\n1086         fn(*args)\n1087         if condition:\n1088             given_fn(*args)\n1089     except Exception:\n1090         raise TypeError(\"Expr/condition too complex for lambdify\")\n1091 \n1092     def return_generator():\n1093         count = 0\n1094         while count < numsamples:\n1095             d = ps.sample()  # a dictionary that maps RVs to values\n1096             args = [d[rv] for rv in rvs]\n1097 \n1098             if condition:  # Check that these values satisfy the condition\n1099                 gd = given_fn(*args)\n1100                 if gd != True and gd != False:\n1101                     raise ValueError(\n1102                         \"Conditions must not contain free symbols\")\n1103                 if not gd:  # If the values don't satisfy then try again\n1104                     continue\n1105 \n1106             yield fn(*args)\n1107             count += 1\n1108     return return_generator()\n1109 \n1110 \n1111 def sample_iter_subs(expr, condition=None, numsamples=S.Infinity, **kwargs):\n1112     \"\"\"\n1113     See sample_iter\n1114 \n1115     Uses subs for computation. This is slow but almost always works.\n1116     \"\"\"\n1117     if condition is not None:\n1118         ps = pspace(Tuple(expr, condition))\n1119     else:\n1120         ps = pspace(expr)\n1121 \n1122     count = 0\n1123     while count < numsamples:\n1124         d = ps.sample()  # a dictionary that maps RVs to values\n1125 \n1126         if condition is not None:  # Check that these values satisfy the condition\n1127             gd = condition.xreplace(d)\n1128             if gd != True and gd != False:\n1129                 raise ValueError(\"Conditions must not contain free symbols\")\n1130             if not gd:  # If the values don't satisfy then try again\n1131                 continue\n1132 \n1133         yield expr.xreplace(d)\n1134         count += 1\n1135 \n1136 \n1137 def sampling_P(condition, given_condition=None, numsamples=1,\n1138                evalf=True, **kwargs):\n1139     \"\"\"\n1140     Sampling version of P\n1141 \n1142     See Also\n1143     ========\n1144 \n1145     P\n1146     sampling_E\n1147     sampling_density\n1148 \n1149     \"\"\"\n1150 \n1151     count_true = 0\n1152     count_false = 0\n1153 \n1154     samples = sample_iter(condition, given_condition,\n1155                           numsamples=numsamples, **kwargs)\n1156 \n1157     for sample in samples:\n1158         if sample != True and sample != False:\n1159             raise ValueError(\"Conditions must not contain free symbols\")\n1160 \n1161         if sample:\n1162             count_true += 1\n1163         else:\n1164             count_false += 1\n1165 \n1166     result = S(count_true) / numsamples\n1167     if evalf:\n1168         return result.evalf()\n1169     else:\n1170         return result\n1171 \n1172 \n1173 def sampling_E(expr, given_condition=None, numsamples=1,\n1174                evalf=True, **kwargs):\n1175     \"\"\"\n1176     Sampling version of E\n1177 \n1178     See Also\n1179     ========\n1180 \n1181     P\n1182     sampling_P\n1183     sampling_density\n1184     \"\"\"\n1185 \n1186     samples = sample_iter(expr, given_condition,\n1187                           numsamples=numsamples, **kwargs)\n1188 \n1189     result = Add(*list(samples)) / numsamples\n1190     if evalf:\n1191         return result.evalf()\n1192     else:\n1193         return result\n1194 \n1195 def sampling_density(expr, given_condition=None, numsamples=1, **kwargs):\n1196     \"\"\"\n1197     Sampling version of density\n1198 \n1199     See Also\n1200     ========\n1201     density\n1202     sampling_P\n1203     sampling_E\n1204     \"\"\"\n1205 \n1206     results = {}\n1207     for result in sample_iter(expr, given_condition,\n1208                               numsamples=numsamples, **kwargs):\n1209         results[result] = results.get(result, 0) + 1\n1210     return results\n1211 \n1212 \n1213 def dependent(a, b):\n1214     \"\"\"\n1215     Dependence of two random expressions\n1216 \n1217     Two expressions are independent if knowledge of one does not change\n1218     computations on the other.\n1219 \n1220     Examples\n1221     ========\n1222 \n1223     >>> from sympy.stats import Normal, dependent, given\n1224     >>> from sympy import Tuple, Eq\n1225 \n1226     >>> X, Y = Normal('X', 0, 1), Normal('Y', 0, 1)\n1227     >>> dependent(X, Y)\n1228     False\n1229     >>> dependent(2*X + Y, -Y)\n1230     True\n1231     >>> X, Y = given(Tuple(X, Y), Eq(X + Y, 3))\n1232     >>> dependent(X, Y)\n1233     True\n1234 \n1235     See Also\n1236     ========\n1237 \n1238     independent\n1239     \"\"\"\n1240     if pspace_independent(a, b):\n1241         return False\n1242 \n1243     z = Symbol('z', real=True)\n1244     # Dependent if density is unchanged when one is given information about\n1245     # the other\n1246     return (density(a, Eq(b, z)) != density(a) or\n1247             density(b, Eq(a, z)) != density(b))\n1248 \n1249 \n1250 def independent(a, b):\n1251     \"\"\"\n1252     Independence of two random expressions\n1253 \n1254     Two expressions are independent if knowledge of one does not change\n1255     computations on the other.\n1256 \n1257     Examples\n1258     ========\n1259 \n1260     >>> from sympy.stats import Normal, independent, given\n1261     >>> from sympy import Tuple, Eq\n1262 \n1263     >>> X, Y = Normal('X', 0, 1), Normal('Y', 0, 1)\n1264     >>> independent(X, Y)\n1265     True\n1266     >>> independent(2*X + Y, -Y)\n1267     False\n1268     >>> X, Y = given(Tuple(X, Y), Eq(X + Y, 3))\n1269     >>> independent(X, Y)\n1270     False\n1271 \n1272     See Also\n1273     ========\n1274 \n1275     dependent\n1276     \"\"\"\n1277     return not dependent(a, b)\n1278 \n1279 \n1280 def pspace_independent(a, b):\n1281     \"\"\"\n1282     Tests for independence between a and b by checking if their PSpaces have\n1283     overlapping symbols. This is a sufficient but not necessary condition for\n1284     independence and is intended to be used internally.\n1285 \n1286     Notes\n1287     =====\n1288 \n1289     pspace_independent(a, b) implies independent(a, b)\n1290     independent(a, b) does not imply pspace_independent(a, b)\n1291     \"\"\"\n1292     a_symbols = set(pspace(b).symbols)\n1293     b_symbols = set(pspace(a).symbols)\n1294 \n1295     if len(set(random_symbols(a)).intersection(random_symbols(b))) != 0:\n1296         return False\n1297 \n1298     if len(a_symbols.intersection(b_symbols)) == 0:\n1299         return True\n1300     return None\n1301 \n1302 \n1303 def rv_subs(expr, symbols=None):\n1304     \"\"\"\n1305     Given a random expression replace all random variables with their symbols.\n1306 \n1307     If symbols keyword is given restrict the swap to only the symbols listed.\n1308     \"\"\"\n1309     if symbols is None:\n1310         symbols = random_symbols(expr)\n1311     if not symbols:\n1312         return expr\n1313     swapdict = {rv: rv.symbol for rv in symbols}\n1314     return expr.xreplace(swapdict)\n1315 \n1316 class NamedArgsMixin(object):\n1317     _argnames = ()\n1318 \n1319     def __getattr__(self, attr):\n1320         try:\n1321             return self.args[self._argnames.index(attr)]\n1322         except ValueError:\n1323             raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n1324                 type(self).__name__, attr))\n1325 \n1326 def _value_check(condition, message):\n1327     \"\"\"\n1328     Raise a ValueError with message if condition is False, else\n1329     return True if all conditions were True, else False.\n1330 \n1331     Examples\n1332     ========\n1333 \n1334     >>> from sympy.stats.rv import _value_check\n1335     >>> from sympy.abc import a, b, c\n1336     >>> from sympy import And, Dummy\n1337 \n1338     >>> _value_check(2 < 3, '')\n1339     True\n1340 \n1341     Here, the condition is not False, but it doesn't evaluate to True\n1342     so False is returned (but no error is raised). So checking if the\n1343     return value is True or False will tell you if all conditions were\n1344     evaluated.\n1345 \n1346     >>> _value_check(a < b, '')\n1347     False\n1348 \n1349     In this case the condition is False so an error is raised:\n1350 \n1351     >>> r = Dummy(real=True)\n1352     >>> _value_check(r < r - 1, 'condition is not true')\n1353     Traceback (most recent call last):\n1354     ...\n1355     ValueError: condition is not true\n1356 \n1357     If no condition of many conditions must be False, they can be\n1358     checked by passing them as an iterable:\n1359 \n1360     >>> _value_check((a < 0, b < 0, c < 0), '')\n1361     False\n1362 \n1363     The iterable can be a generator, too:\n1364 \n1365     >>> _value_check((i < 0 for i in (a, b, c)), '')\n1366     False\n1367 \n1368     The following are equivalent to the above but do not pass\n1369     an iterable:\n1370 \n1371     >>> all(_value_check(i < 0, '') for i in (a, b, c))\n1372     False\n1373     >>> _value_check(And(a < 0, b < 0, c < 0), '')\n1374     False\n1375     \"\"\"\n1376     from sympy.core.compatibility import iterable\n1377     from sympy.core.logic import fuzzy_and\n1378     if not iterable(condition):\n1379         condition = [condition]\n1380     truth = fuzzy_and(condition)\n1381     if truth == False:\n1382         raise ValueError(message)\n1383     return truth == True\n",
        "intended_behavior": "If not already present, add or enhance methods to validate the soundness of a random variable's state, such as checking assigned distributions and parameters when the object is constructed or modified. This is a preventive measure to ensure errors are caught early."
    }
]