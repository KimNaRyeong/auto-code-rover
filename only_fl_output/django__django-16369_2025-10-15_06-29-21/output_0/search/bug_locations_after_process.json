[
    {
        "rel_file_path": "django/contrib/sitemaps/views.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/contrib/sitemaps/views.py",
        "start": 1,
        "end": 153,
        "class_name": null,
        "method_name": null,
        "code": "1 import datetime\n2 import warnings\n3 from dataclasses import dataclass\n4 from functools import wraps\n5 \n6 from django.contrib.sites.shortcuts import get_current_site\n7 from django.core.paginator import EmptyPage, PageNotAnInteger\n8 from django.http import Http404\n9 from django.template.response import TemplateResponse\n10 from django.urls import reverse\n11 from django.utils import timezone\n12 from django.utils.deprecation import RemovedInDjango50Warning\n13 from django.utils.http import http_date\n14 \n15 \n16 @dataclass\n17 class SitemapIndexItem:\n18     location: str\n19     last_mod: bool = None\n20 \n21     # RemovedInDjango50Warning\n22     def __str__(self):\n23         msg = (\n24             \"Calling `__str__` on SitemapIndexItem is deprecated, use the `location` \"\n25             \"attribute instead.\"\n26         )\n27         warnings.warn(msg, RemovedInDjango50Warning, stacklevel=2)\n28         return self.location\n29 \n30 \n31 def x_robots_tag(func):\n32     @wraps(func)\n33     def inner(request, *args, **kwargs):\n34         response = func(request, *args, **kwargs)\n35         response.headers[\"X-Robots-Tag\"] = \"noindex, noodp, noarchive\"\n36         return response\n37 \n38     return inner\n39 \n40 \n41 def _get_latest_lastmod(current_lastmod, new_lastmod):\n42     \"\"\"\n43     Returns the latest `lastmod` where `lastmod` can be either a date or a\n44     datetime.\n45     \"\"\"\n46     if not isinstance(new_lastmod, datetime.datetime):\n47         new_lastmod = datetime.datetime.combine(new_lastmod, datetime.time.min)\n48     if timezone.is_naive(new_lastmod):\n49         new_lastmod = timezone.make_aware(new_lastmod, datetime.timezone.utc)\n50     return new_lastmod if current_lastmod is None else max(current_lastmod, new_lastmod)\n51 \n52 \n53 @x_robots_tag\n54 def index(\n55     request,\n56     sitemaps,\n57     template_name=\"sitemap_index.xml\",\n58     content_type=\"application/xml\",\n59     sitemap_url_name=\"django.contrib.sitemaps.views.sitemap\",\n60 ):\n61 \n62     req_protocol = request.scheme\n63     req_site = get_current_site(request)\n64 \n65     sites = []  # all sections' sitemap URLs\n66     all_indexes_lastmod = True\n67     latest_lastmod = None\n68     for section, site in sitemaps.items():\n69         # For each section label, add links of all pages of its sitemap\n70         # (usually generated by the `sitemap` view).\n71         if callable(site):\n72             site = site()\n73         protocol = req_protocol if site.protocol is None else site.protocol\n74         sitemap_url = reverse(sitemap_url_name, kwargs={\"section\": section})\n75         absolute_url = \"%s://%s%s\" % (protocol, req_site.domain, sitemap_url)\n76         site_lastmod = site.get_latest_lastmod()\n77         if all_indexes_lastmod:\n78             if site_lastmod is not None:\n79                 latest_lastmod = _get_latest_lastmod(latest_lastmod, site_lastmod)\n80             else:\n81                 all_indexes_lastmod = False\n82         sites.append(SitemapIndexItem(absolute_url, site_lastmod))\n83         # Add links to all pages of the sitemap.\n84         for page in range(2, site.paginator.num_pages + 1):\n85             sites.append(\n86                 SitemapIndexItem(\"%s?p=%s\" % (absolute_url, page), site_lastmod)\n87             )\n88     # If lastmod is defined for all sites, set header so as\n89     # ConditionalGetMiddleware is able to send 304 NOT MODIFIED\n90     if all_indexes_lastmod and latest_lastmod:\n91         headers = {\"Last-Modified\": http_date(latest_lastmod.timestamp())}\n92     else:\n93         headers = None\n94     return TemplateResponse(\n95         request,\n96         template_name,\n97         {\"sitemaps\": sites},\n98         content_type=content_type,\n99         headers=headers,\n100     )\n101 \n102 \n103 @x_robots_tag\n104 def sitemap(\n105     request,\n106     sitemaps,\n107     section=None,\n108     template_name=\"sitemap.xml\",\n109     content_type=\"application/xml\",\n110 ):\n111 \n112     req_protocol = request.scheme\n113     req_site = get_current_site(request)\n114 \n115     if section is not None:\n116         if section not in sitemaps:\n117             raise Http404(\"No sitemap available for section: %r\" % section)\n118         maps = [sitemaps[section]]\n119     else:\n120         maps = sitemaps.values()\n121     page = request.GET.get(\"p\", 1)\n122 \n123     lastmod = None\n124     all_sites_lastmod = True\n125     urls = []\n126     for site in maps:\n127         try:\n128             if callable(site):\n129                 site = site()\n130             urls.extend(site.get_urls(page=page, site=req_site, protocol=req_protocol))\n131             if all_sites_lastmod:\n132                 site_lastmod = getattr(site, \"latest_lastmod\", None)\n133                 if site_lastmod is not None:\n134                     lastmod = _get_latest_lastmod(lastmod, site_lastmod)\n135                 else:\n136                     all_sites_lastmod = False\n137         except EmptyPage:\n138             raise Http404(\"Page %s empty\" % page)\n139         except PageNotAnInteger:\n140             raise Http404(\"No page '%s'\" % page)\n141     # If lastmod is defined for all sites, set header so as\n142     # ConditionalGetMiddleware is able to send 304 NOT MODIFIED\n143     if all_sites_lastmod:\n144         headers = {\"Last-Modified\": http_date(lastmod.timestamp())} if lastmod else None\n145     else:\n146         headers = None\n147     return TemplateResponse(\n148         request,\n149         template_name,\n150         {\"urlset\": urls},\n151         content_type=content_type,\n152         headers=headers,\n153     )\n",
        "intended_behavior": "Modify or extend the logic within this file to incorporate a check for item translation availability corresponding to the requested language. This mechanism would filter out items from the sitemap generation process if they do not have an available translation in the current language context."
    },
    {
        "rel_file_path": "django/middleware/locale.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/middleware/locale.py",
        "start": 1,
        "end": 89,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.conf import settings\n2 from django.conf.urls.i18n import is_language_prefix_patterns_used\n3 from django.http import HttpResponseRedirect\n4 from django.urls import get_script_prefix, is_valid_path\n5 from django.utils import translation\n6 from django.utils.cache import patch_vary_headers\n7 from django.utils.deprecation import MiddlewareMixin\n8 \n9 \n10 class LocaleMiddleware(MiddlewareMixin):\n11     \"\"\"\n12     Parse a request and decide what translation object to install in the\n13     current thread context. This allows pages to be dynamically translated to\n14     the language the user desires (if the language is available).\n15     \"\"\"\n16 \n17     response_redirect_class = HttpResponseRedirect\n18 \n19     def get_fallback_language(self, request):\n20         \"\"\"\n21         Return the fallback language for the current request based on the\n22         settings. If LANGUAGE_CODE is a variant not included in the supported\n23         languages, get_fallback_language() will try to fallback to a supported\n24         generic variant.\n25 \n26         Can be overridden to have a fallback language depending on the request,\n27         e.g. based on top level domain.\n28         \"\"\"\n29         try:\n30             return translation.get_supported_language_variant(settings.LANGUAGE_CODE)\n31         except LookupError:\n32             return settings.LANGUAGE_CODE\n33 \n34     def process_request(self, request):\n35         urlconf = getattr(request, \"urlconf\", settings.ROOT_URLCONF)\n36         i18n_patterns_used, _ = is_language_prefix_patterns_used(urlconf)\n37         language = translation.get_language_from_request(\n38             request, check_path=i18n_patterns_used\n39         )\n40         if not language:\n41             language = self.get_fallback_language(request)\n42 \n43         translation.activate(language)\n44         request.LANGUAGE_CODE = translation.get_language()\n45 \n46     def process_response(self, request, response):\n47         language = translation.get_language()\n48         language_from_path = translation.get_language_from_path(request.path_info)\n49         language_from_request = translation.get_language_from_request(request)\n50         urlconf = getattr(request, \"urlconf\", settings.ROOT_URLCONF)\n51         (\n52             i18n_patterns_used,\n53             prefixed_default_language,\n54         ) = is_language_prefix_patterns_used(urlconf)\n55 \n56         if (\n57             response.status_code == 404\n58             and not language_from_path\n59             and i18n_patterns_used\n60             and (prefixed_default_language or language_from_request)\n61         ):\n62             # Maybe the language code is missing in the URL? Try adding the\n63             # language prefix and redirecting to that URL.\n64             language_path = \"/%s%s\" % (language, request.path_info)\n65             path_valid = is_valid_path(language_path, urlconf)\n66             path_needs_slash = not path_valid and (\n67                 settings.APPEND_SLASH\n68                 and not language_path.endswith(\"/\")\n69                 and is_valid_path(\"%s/\" % language_path, urlconf)\n70             )\n71 \n72             if path_valid or path_needs_slash:\n73                 script_prefix = get_script_prefix()\n74                 # Insert language after the script prefix and before the\n75                 # rest of the URL\n76                 language_url = request.get_full_path(\n77                     force_append_slash=path_needs_slash\n78                 ).replace(script_prefix, \"%s%s/\" % (script_prefix, language), 1)\n79                 # Redirect to the language-specific URL as detected by\n80                 # get_language_from_request(). HTTP caches may cache this\n81                 # redirect, so add the Vary header.\n82                 redirect = self.response_redirect_class(language_url)\n83                 patch_vary_headers(redirect, (\"Accept-Language\", \"Cookie\"))\n84                 return redirect\n85 \n86         if not (i18n_patterns_used and language_from_path):\n87             patch_vary_headers(response, (\"Accept-Language\",))\n88         response.headers.setdefault(\"Content-Language\", language)\n89         return response\n",
        "intended_behavior": "Enhance the middleware to better handle locale selection in a way that seamlessly integrates with the sitemap generation logic, ensuring that the current language setting is appropriately considered when filtering items for sitemap inclusion."
    },
    {
        "rel_file_path": "django/contrib/sitemaps/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/contrib/sitemaps/__init__.py",
        "start": 1,
        "end": 258,
        "class_name": null,
        "method_name": null,
        "code": "1 import warnings\n2 from urllib.parse import urlencode\n3 from urllib.request import urlopen\n4 \n5 from django.apps import apps as django_apps\n6 from django.conf import settings\n7 from django.core import paginator\n8 from django.core.exceptions import ImproperlyConfigured\n9 from django.urls import NoReverseMatch, reverse\n10 from django.utils import translation\n11 from django.utils.deprecation import RemovedInDjango50Warning\n12 \n13 PING_URL = \"https://www.google.com/webmasters/tools/ping\"\n14 \n15 \n16 class SitemapNotFound(Exception):\n17     pass\n18 \n19 \n20 def ping_google(sitemap_url=None, ping_url=PING_URL, sitemap_uses_https=True):\n21     \"\"\"\n22     Alert Google that the sitemap for the current site has been updated.\n23     If sitemap_url is provided, it should be an absolute path to the sitemap\n24     for this site -- e.g., '/sitemap.xml'. If sitemap_url is not provided, this\n25     function will attempt to deduce it by using urls.reverse().\n26     \"\"\"\n27     sitemap_full_url = _get_sitemap_full_url(sitemap_url, sitemap_uses_https)\n28     params = urlencode({\"sitemap\": sitemap_full_url})\n29     urlopen(\"%s?%s\" % (ping_url, params))\n30 \n31 \n32 def _get_sitemap_full_url(sitemap_url, sitemap_uses_https=True):\n33     if not django_apps.is_installed(\"django.contrib.sites\"):\n34         raise ImproperlyConfigured(\n35             \"ping_google requires django.contrib.sites, which isn't installed.\"\n36         )\n37 \n38     if sitemap_url is None:\n39         try:\n40             # First, try to get the \"index\" sitemap URL.\n41             sitemap_url = reverse(\"django.contrib.sitemaps.views.index\")\n42         except NoReverseMatch:\n43             try:\n44                 # Next, try for the \"global\" sitemap URL.\n45                 sitemap_url = reverse(\"django.contrib.sitemaps.views.sitemap\")\n46             except NoReverseMatch:\n47                 pass\n48 \n49     if sitemap_url is None:\n50         raise SitemapNotFound(\n51             \"You didn't provide a sitemap_url, and the sitemap URL couldn't be \"\n52             \"auto-detected.\"\n53         )\n54 \n55     Site = django_apps.get_model(\"sites.Site\")\n56     current_site = Site.objects.get_current()\n57     scheme = \"https\" if sitemap_uses_https else \"http\"\n58     return \"%s://%s%s\" % (scheme, current_site.domain, sitemap_url)\n59 \n60 \n61 class Sitemap:\n62     # This limit is defined by Google. See the index documentation at\n63     # https://www.sitemaps.org/protocol.html#index.\n64     limit = 50000\n65 \n66     # If protocol is None, the URLs in the sitemap will use the protocol\n67     # with which the sitemap was requested.\n68     protocol = None\n69 \n70     # Enables generating URLs for all languages.\n71     i18n = False\n72 \n73     # Override list of languages to use.\n74     languages = None\n75 \n76     # Enables generating alternate/hreflang links.\n77     alternates = False\n78 \n79     # Add an alternate/hreflang link with value 'x-default'.\n80     x_default = False\n81 \n82     def _get(self, name, item, default=None):\n83         try:\n84             attr = getattr(self, name)\n85         except AttributeError:\n86             return default\n87         if callable(attr):\n88             if self.i18n:\n89                 # Split the (item, lang_code) tuples again for the location,\n90                 # priority, lastmod and changefreq method calls.\n91                 item, lang_code = item\n92             return attr(item)\n93         return attr\n94 \n95     def _languages(self):\n96         if self.languages is not None:\n97             return self.languages\n98         return [lang_code for lang_code, _ in settings.LANGUAGES]\n99 \n100     def _items(self):\n101         if self.i18n:\n102             # Create (item, lang_code) tuples for all items and languages.\n103             # This is necessary to paginate with all languages already considered.\n104             items = [\n105                 (item, lang_code)\n106                 for lang_code in self._languages()\n107                 for item in self.items()\n108             ]\n109             return items\n110         return self.items()\n111 \n112     def _location(self, item, force_lang_code=None):\n113         if self.i18n:\n114             obj, lang_code = item\n115             # Activate language from item-tuple or forced one before calling location.\n116             with translation.override(force_lang_code or lang_code):\n117                 return self._get(\"location\", item)\n118         return self._get(\"location\", item)\n119 \n120     @property\n121     def paginator(self):\n122         return paginator.Paginator(self._items(), self.limit)\n123 \n124     def items(self):\n125         return []\n126 \n127     def location(self, item):\n128         return item.get_absolute_url()\n129 \n130     def get_protocol(self, protocol=None):\n131         # Determine protocol\n132         if self.protocol is None and protocol is None:\n133             warnings.warn(\n134                 \"The default sitemap protocol will be changed from 'http' to \"\n135                 \"'https' in Django 5.0. Set Sitemap.protocol to silence this \"\n136                 \"warning.\",\n137                 category=RemovedInDjango50Warning,\n138                 stacklevel=2,\n139             )\n140         # RemovedInDjango50Warning: when the deprecation ends, replace 'http'\n141         # with 'https'.\n142         return self.protocol or protocol or \"http\"\n143 \n144     def get_domain(self, site=None):\n145         # Determine domain\n146         if site is None:\n147             if django_apps.is_installed(\"django.contrib.sites\"):\n148                 Site = django_apps.get_model(\"sites.Site\")\n149                 try:\n150                     site = Site.objects.get_current()\n151                 except Site.DoesNotExist:\n152                     pass\n153             if site is None:\n154                 raise ImproperlyConfigured(\n155                     \"To use sitemaps, either enable the sites framework or pass \"\n156                     \"a Site/RequestSite object in your view.\"\n157                 )\n158         return site.domain\n159 \n160     def get_urls(self, page=1, site=None, protocol=None):\n161         protocol = self.get_protocol(protocol)\n162         domain = self.get_domain(site)\n163         return self._urls(page, protocol, domain)\n164 \n165     def get_latest_lastmod(self):\n166         if not hasattr(self, \"lastmod\"):\n167             return None\n168         if callable(self.lastmod):\n169             try:\n170                 return max([self.lastmod(item) for item in self.items()], default=None)\n171             except TypeError:\n172                 return None\n173         else:\n174             return self.lastmod\n175 \n176     def _urls(self, page, protocol, domain):\n177         urls = []\n178         latest_lastmod = None\n179         all_items_lastmod = True  # track if all items have a lastmod\n180 \n181         paginator_page = self.paginator.page(page)\n182         for item in paginator_page.object_list:\n183             loc = f\"{protocol}://{domain}{self._location(item)}\"\n184             priority = self._get(\"priority\", item)\n185             lastmod = self._get(\"lastmod\", item)\n186 \n187             if all_items_lastmod:\n188                 all_items_lastmod = lastmod is not None\n189                 if all_items_lastmod and (\n190                     latest_lastmod is None or lastmod > latest_lastmod\n191                 ):\n192                     latest_lastmod = lastmod\n193 \n194             url_info = {\n195                 \"item\": item,\n196                 \"location\": loc,\n197                 \"lastmod\": lastmod,\n198                 \"changefreq\": self._get(\"changefreq\", item),\n199                 \"priority\": str(priority if priority is not None else \"\"),\n200                 \"alternates\": [],\n201             }\n202 \n203             if self.i18n and self.alternates:\n204                 for lang_code in self._languages():\n205                     loc = f\"{protocol}://{domain}{self._location(item, lang_code)}\"\n206                     url_info[\"alternates\"].append(\n207                         {\n208                             \"location\": loc,\n209                             \"lang_code\": lang_code,\n210                         }\n211                     )\n212                 if self.x_default:\n213                     lang_code = settings.LANGUAGE_CODE\n214                     loc = f\"{protocol}://{domain}{self._location(item, lang_code)}\"\n215                     loc = loc.replace(f\"/{lang_code}/\", \"/\", 1)\n216                     url_info[\"alternates\"].append(\n217                         {\n218                             \"location\": loc,\n219                             \"lang_code\": \"x-default\",\n220                         }\n221                     )\n222 \n223             urls.append(url_info)\n224 \n225         if all_items_lastmod and latest_lastmod:\n226             self.latest_lastmod = latest_lastmod\n227 \n228         return urls\n229 \n230 \n231 class GenericSitemap(Sitemap):\n232     priority = None\n233     changefreq = None\n234 \n235     def __init__(self, info_dict, priority=None, changefreq=None, protocol=None):\n236         self.queryset = info_dict[\"queryset\"]\n237         self.date_field = info_dict.get(\"date_field\")\n238         self.priority = self.priority or priority\n239         self.changefreq = self.changefreq or changefreq\n240         self.protocol = self.protocol or protocol\n241 \n242     def items(self):\n243         # Make sure to return a clone; we don't want premature evaluation.\n244         return self.queryset.filter()\n245 \n246     def lastmod(self, item):\n247         if self.date_field is not None:\n248             return getattr(item, self.date_field)\n249         return None\n250 \n251     def get_latest_lastmod(self):\n252         if self.date_field is not None:\n253             return (\n254                 self.queryset.order_by(\"-\" + self.date_field)\n255                 .values_list(self.date_field, flat=True)\n256                 .first()\n257             )\n258         return None\n",
        "intended_behavior": "Introduce or adjust functions responsible for collating items to be included in the sitemap to account for language-specific URLs and availability of translations. Ensure that these adjustments do not interfere with the default behavior for sitemaps where language-specific filtering is not applicable or desired."
    }
]