[
    {
        "rel_file_path": "pylint/config/config_initialization.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/config_initialization.py",
        "start": 20,
        "end": 106,
        "class_name": null,
        "method_name": "_config_initialization",
        "code": "20 def _config_initialization(\n21     linter: PyLinter,\n22     args_list: list[str],\n23     reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n24     config_file: None | str | Path = None,\n25     verbose_mode: bool = False,\n26 ) -> list[str]:\n27     \"\"\"Parse all available options, read config files and command line arguments and\n28     set options accordingly.\n29     \"\"\"\n30     config_file = Path(config_file) if config_file else None\n31 \n32     # Set the current module to the configuration file\n33     # to allow raising messages on the configuration file.\n34     linter.set_current_module(str(config_file) if config_file else None)\n35 \n36     # Read the configuration file\n37     config_file_parser = _ConfigurationFileParser(verbose_mode, linter)\n38     try:\n39         config_data, config_args = config_file_parser.parse_config_file(\n40             file_path=config_file\n41         )\n42     except OSError as ex:\n43         print(ex, file=sys.stderr)\n44         sys.exit(32)\n45 \n46     # Run init hook, if present, before loading plugins\n47     if \"init-hook\" in config_data:\n48         exec(utils._unquote(config_data[\"init-hook\"]))  # pylint: disable=exec-used\n49 \n50     # Load plugins if specified in the config file\n51     if \"load-plugins\" in config_data:\n52         linter.load_plugin_modules(utils._splitstrip(config_data[\"load-plugins\"]))\n53 \n54     # First we parse any options from a configuration file\n55     try:\n56         linter._parse_configuration_file(config_args)\n57     except _UnrecognizedOptionError as exc:\n58         msg = \", \".join(exc.options)\n59         linter.add_message(\"unrecognized-option\", line=0, args=msg)\n60 \n61     # Then, if a custom reporter is provided as argument, it may be overridden\n62     # by file parameters, so we re-set it here. We do this before command line\n63     # parsing, so it's still overridable by command line options\n64     if reporter:\n65         linter.set_reporter(reporter)\n66 \n67     # Set the current module to the command line\n68     # to allow raising messages on it\n69     linter.set_current_module(\"Command line\")\n70 \n71     # Now we parse any options from the command line, so they can override\n72     # the configuration file\n73     parsed_args_list = linter._parse_command_line_configuration(args_list)\n74 \n75     # Check if there are any options that we do not recognize\n76     unrecognized_options: list[str] = []\n77     for opt in parsed_args_list:\n78         if opt.startswith(\"--\"):\n79             unrecognized_options.append(opt[2:])\n80         elif opt.startswith(\"-\"):\n81             unrecognized_options.append(opt[1:])\n82     if unrecognized_options:\n83         msg = \", \".join(unrecognized_options)\n84         linter.add_message(\"unrecognized-option\", line=0, args=msg)\n85         raise _UnrecognizedOptionError(options=unrecognized_options)\n86 \n87     # Set the current module to configuration as we don't know where\n88     # the --load-plugins key is coming from\n89     linter.set_current_module(\"Command line or configuration file\")\n90 \n91     # We have loaded configuration from config file and command line. Now, we can\n92     # load plugin specific configuration.\n93     linter.load_plugin_configuration()\n94 \n95     # parsed_args_list should now only be a list of files/directories to lint.\n96     # All other options have been removed from the list.\n97     if not parsed_args_list:\n98         print(linter.help())\n99         sys.exit(32)\n100 \n101     # Now that plugins are loaded, get list of all fail_on messages, and enable them\n102     linter.enable_fail_on_messages()\n103 \n104     linter._parse_error_mode()\n105 \n106     return parsed_args_list\n",
        "intended_behavior": "Modify this method to handle the '_UnrecognizedOptionError' more gracefully. Instead of allowing the exception to propagate and cause a traceback, catch the exception within this method and print a user-friendly error message outlining the unrecognized options along with guidance on how to obtain a list of valid options (e.g., by using a help flag). Preserve the functionality that adds a message about the unrecognized option but enhances the final output provided to the user."
    },
    {
        "rel_file_path": "pylint/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/__init__.py",
        "start": 1,
        "end": 89,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 from __future__ import annotations\n6 \n7 import os\n8 import sys\n9 from collections.abc import Sequence\n10 from typing import NoReturn\n11 \n12 from pylint.__pkginfo__ import __version__\n13 \n14 # pylint: disable=import-outside-toplevel\n15 \n16 \n17 def run_pylint(argv: Sequence[str] | None = None) -> None:\n18     \"\"\"Run pylint.\n19 \n20     argv can be a sequence of strings normally supplied as arguments on the command line\n21     \"\"\"\n22     from pylint.lint import Run as PylintRun\n23 \n24     try:\n25         PylintRun(argv or sys.argv[1:])\n26     except KeyboardInterrupt:\n27         sys.exit(1)\n28 \n29 \n30 def run_epylint(argv: Sequence[str] | None = None) -> NoReturn:\n31     \"\"\"Run epylint.\n32 \n33     argv can be a list of strings normally supplied as arguments on the command line\n34     \"\"\"\n35     from pylint.epylint import Run as EpylintRun\n36 \n37     EpylintRun(argv)\n38 \n39 \n40 def run_pyreverse(argv: Sequence[str] | None = None) -> NoReturn:  # type: ignore[misc]\n41     \"\"\"Run pyreverse.\n42 \n43     argv can be a sequence of strings normally supplied as arguments on the command line\n44     \"\"\"\n45     from pylint.pyreverse.main import Run as PyreverseRun\n46 \n47     PyreverseRun(argv or sys.argv[1:])\n48 \n49 \n50 def run_symilar(argv: Sequence[str] | None = None) -> NoReturn:\n51     \"\"\"Run symilar.\n52 \n53     argv can be a sequence of strings normally supplied as arguments on the command line\n54     \"\"\"\n55     from pylint.checkers.similar import Run as SimilarRun\n56 \n57     SimilarRun(argv or sys.argv[1:])\n58 \n59 \n60 def modify_sys_path() -> None:\n61     \"\"\"Modify sys path for execution as Python module.\n62 \n63     Strip out the current working directory from sys.path.\n64     Having the working directory in `sys.path` means that `pylint` might\n65     inadvertently import user code from modules having the same name as\n66     stdlib or pylint's own modules.\n67     CPython issue: https://bugs.python.org/issue33053\n68 \n69     - Remove the first entry. This will always be either \"\" or the working directory\n70     - Remove the working directory from the second and third entries\n71       if PYTHONPATH includes a \":\" at the beginning or the end.\n72       https://github.com/PyCQA/pylint/issues/3636\n73       Don't remove it if PYTHONPATH contains the cwd or '.' as the entry will\n74       only be added once.\n75     - Don't remove the working directory from the rest. It will be included\n76       if pylint is installed in an editable configuration (as the last item).\n77       https://github.com/PyCQA/pylint/issues/4161\n78     \"\"\"\n79     sys.path.pop(0)\n80     env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n81     cwd = os.getcwd()\n82     if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n83         sys.path.pop(0)\n84     elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n85         sys.path.pop(1)\n86 \n87 \n88 version = __version__\n89 __all__ = [\"__version__\", \"version\", \"modify_sys_path\"]\n",
        "intended_behavior": "In the area of the code that calls '_config_initialization' or is responsible for initializing the pylint application, ensure any '_UnrecognizedOptionError' thrown by the configuration initialization is caught. Upon catching this exception, a help message should be printed to the console, similar to the 'mypy' example given in the issue description. This might entail developing a new method or enhancing an existing one to display help information and list options in a user-friendly manner without displaying the traceback."
    }
]