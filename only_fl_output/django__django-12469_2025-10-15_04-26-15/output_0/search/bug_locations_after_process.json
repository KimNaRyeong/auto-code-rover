[
    {
        "rel_file_path": "django/contrib/admin/views/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/views/main.py",
        "start": 434,
        "end": 477,
        "class_name": "ChangeList",
        "method_name": "get_queryset",
        "code": "434     def get_queryset(self, request):\n435         # First, we collect all the declared list filters.\n436         (self.filter_specs, self.has_filters, remaining_lookup_params,\n437          filters_use_distinct) = self.get_filters(request)\n438 \n439         # Then, we let every list filter modify the queryset to its liking.\n440         qs = self.root_queryset\n441         for filter_spec in self.filter_specs:\n442             new_qs = filter_spec.queryset(request, qs)\n443             if new_qs is not None:\n444                 qs = new_qs\n445 \n446         try:\n447             # Finally, we apply the remaining lookup parameters from the query\n448             # string (i.e. those that haven't already been processed by the\n449             # filters).\n450             qs = qs.filter(**remaining_lookup_params)\n451         except (SuspiciousOperation, ImproperlyConfigured):\n452             # Allow certain types of errors to be re-raised as-is so that the\n453             # caller can treat them in a special way.\n454             raise\n455         except Exception as e:\n456             # Every other error is caught with a naked except, because we don't\n457             # have any other way of validating lookup parameters. They might be\n458             # invalid if the keyword arguments are incorrect, or if the values\n459             # are not in the correct type, so we might get FieldError,\n460             # ValueError, ValidationError, or ?.\n461             raise IncorrectLookupParameters(e)\n462 \n463         if not qs.query.select_related:\n464             qs = self.apply_select_related(qs)\n465 \n466         # Set ordering.\n467         ordering = self.get_ordering(request, qs)\n468         qs = qs.order_by(*ordering)\n469 \n470         # Apply search results\n471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)\n472 \n473         # Remove duplicates from results, if necessary\n474         if filters_use_distinct | search_use_distinct:\n475             return qs.distinct()\n476         else:\n477             return qs\n",
        "intended_behavior": "Within the `get_queryset` method, adjustments should be made to respect the timezone of the user when filtering based on `date_hierarchy`. When constructing the date range filter, the start and end dates need to be localized to the user's timezone. This ensures the filtered results accurately reflect the dates relevant to the user's localized day, taking into account their timezone offset. Specifically, before applying filters generated from `date_hierarchy`, the code should ensure date boundaries are converted into the user's local timezone. This might involve integration with Django's timezone handling utilities to convert naive datetime objects to timezone-aware ones, specifically targeting the bounds used in `date_hierarchy` filtering."
    },
    {
        "rel_file_path": "django/contrib/admin/views/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/views/main.py",
        "start": 48,
        "end": 509,
        "class_name": "ChangeList",
        "method_name": null,
        "code": "48 class ChangeList:\n49     search_form_class = ChangeListSearchForm\n50 \n51     def __init__(self, request, model, list_display, list_display_links,\n52                  list_filter, date_hierarchy, search_fields, list_select_related,\n53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):\n54         self.model = model\n55         self.opts = model._meta\n56         self.lookup_opts = self.opts\n57         self.root_queryset = model_admin.get_queryset(request)\n58         self.list_display = list_display\n59         self.list_display_links = list_display_links\n60         self.list_filter = list_filter\n61         self.has_filters = None\n62         self.date_hierarchy = date_hierarchy\n63         self.search_fields = search_fields\n64         self.list_select_related = list_select_related\n65         self.list_per_page = list_per_page\n66         self.list_max_show_all = list_max_show_all\n67         self.model_admin = model_admin\n68         self.preserved_filters = model_admin.get_preserved_filters(request)\n69         self.sortable_by = sortable_by\n70 \n71         # Get search parameters from the query string.\n72         _search_form = self.search_form_class(request.GET)\n73         if not _search_form.is_valid():\n74             for error in _search_form.errors.values():\n75                 messages.error(request, ', '.join(error))\n76         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''\n77         try:\n78             self.page_num = int(request.GET.get(PAGE_VAR, 0))\n79         except ValueError:\n80             self.page_num = 0\n81         self.show_all = ALL_VAR in request.GET\n82         self.is_popup = IS_POPUP_VAR in request.GET\n83         to_field = request.GET.get(TO_FIELD_VAR)\n84         if to_field and not model_admin.to_field_allowed(request, to_field):\n85             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n86         self.to_field = to_field\n87         self.params = dict(request.GET.items())\n88         if PAGE_VAR in self.params:\n89             del self.params[PAGE_VAR]\n90         if ERROR_FLAG in self.params:\n91             del self.params[ERROR_FLAG]\n92 \n93         if self.is_popup:\n94             self.list_editable = ()\n95         else:\n96             self.list_editable = list_editable\n97         self.queryset = self.get_queryset(request)\n98         self.get_results(request)\n99         if self.is_popup:\n100             title = gettext('Select %s')\n101         elif self.model_admin.has_change_permission(request):\n102             title = gettext('Select %s to change')\n103         else:\n104             title = gettext('Select %s to view')\n105         self.title = title % self.opts.verbose_name\n106         self.pk_attname = self.lookup_opts.pk.attname\n107 \n108     def get_filters_params(self, params=None):\n109         \"\"\"\n110         Return all params except IGNORED_PARAMS.\n111         \"\"\"\n112         params = params or self.params\n113         lookup_params = params.copy()  # a dictionary of the query string\n114         # Remove all the parameters that are globally and systematically\n115         # ignored.\n116         for ignored in IGNORED_PARAMS:\n117             if ignored in lookup_params:\n118                 del lookup_params[ignored]\n119         return lookup_params\n120 \n121     def get_filters(self, request):\n122         lookup_params = self.get_filters_params()\n123         use_distinct = False\n124 \n125         for key, value in lookup_params.items():\n126             if not self.model_admin.lookup_allowed(key, value):\n127                 raise DisallowedModelAdminLookup(\"Filtering by %s not allowed\" % key)\n128 \n129         filter_specs = []\n130         for list_filter in self.list_filter:\n131             if callable(list_filter):\n132                 # This is simply a custom list filter class.\n133                 spec = list_filter(request, lookup_params, self.model, self.model_admin)\n134             else:\n135                 field_path = None\n136                 if isinstance(list_filter, (tuple, list)):\n137                     # This is a custom FieldListFilter class for a given field.\n138                     field, field_list_filter_class = list_filter\n139                 else:\n140                     # This is simply a field name, so use the default\n141                     # FieldListFilter class that has been registered for the\n142                     # type of the given field.\n143                     field, field_list_filter_class = list_filter, FieldListFilter.create\n144                 if not isinstance(field, Field):\n145                     field_path = field\n146                     field = get_fields_from_path(self.model, field_path)[-1]\n147 \n148                 lookup_params_count = len(lookup_params)\n149                 spec = field_list_filter_class(\n150                     field, request, lookup_params,\n151                     self.model, self.model_admin, field_path=field_path,\n152                 )\n153                 # field_list_filter_class removes any lookup_params it\n154                 # processes. If that happened, check if distinct() is needed to\n155                 # remove duplicate results.\n156                 if lookup_params_count > len(lookup_params):\n157                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)\n158             if spec and spec.has_output():\n159                 filter_specs.append(spec)\n160 \n161         if self.date_hierarchy:\n162             # Create bounded lookup parameters so that the query is more\n163             # efficient.\n164             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)\n165             if year is not None:\n166                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)\n167                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)\n168                 try:\n169                     from_date = datetime(\n170                         int(year),\n171                         int(month if month is not None else 1),\n172                         int(day if day is not None else 1),\n173                     )\n174                 except ValueError as e:\n175                     raise IncorrectLookupParameters(e) from e\n176                 if day:\n177                     to_date = from_date + timedelta(days=1)\n178                 elif month:\n179                     # In this branch, from_date will always be the first of a\n180                     # month, so advancing 32 days gives the next month.\n181                     to_date = (from_date + timedelta(days=32)).replace(day=1)\n182                 else:\n183                     to_date = from_date.replace(year=from_date.year + 1)\n184                 if settings.USE_TZ:\n185                     from_date = make_aware(from_date)\n186                     to_date = make_aware(to_date)\n187                 lookup_params.update({\n188                     '%s__gte' % self.date_hierarchy: from_date,\n189                     '%s__lt' % self.date_hierarchy: to_date,\n190                 })\n191 \n192         # At this point, all the parameters used by the various ListFilters\n193         # have been removed from lookup_params, which now only contains other\n194         # parameters passed via the query string. We now loop through the\n195         # remaining parameters both to ensure that all the parameters are valid\n196         # fields and to determine if at least one of them needs distinct(). If\n197         # the lookup parameters aren't real fields, then bail out.\n198         try:\n199             for key, value in lookup_params.items():\n200                 lookup_params[key] = prepare_lookup_value(key, value)\n201                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)\n202             return filter_specs, bool(filter_specs), lookup_params, use_distinct\n203         except FieldDoesNotExist as e:\n204             raise IncorrectLookupParameters(e) from e\n205 \n206     def get_query_string(self, new_params=None, remove=None):\n207         if new_params is None:\n208             new_params = {}\n209         if remove is None:\n210             remove = []\n211         p = self.params.copy()\n212         for r in remove:\n213             for k in list(p):\n214                 if k.startswith(r):\n215                     del p[k]\n216         for k, v in new_params.items():\n217             if v is None:\n218                 if k in p:\n219                     del p[k]\n220             else:\n221                 p[k] = v\n222         return '?%s' % urlencode(sorted(p.items()))\n223 \n224     def get_results(self, request):\n225         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)\n226         # Get the number of objects, with admin filters applied.\n227         result_count = paginator.count\n228 \n229         # Get the total number of objects, with no admin filters applied.\n230         if self.model_admin.show_full_result_count:\n231             full_result_count = self.root_queryset.count()\n232         else:\n233             full_result_count = None\n234         can_show_all = result_count <= self.list_max_show_all\n235         multi_page = result_count > self.list_per_page\n236 \n237         # Get the list of objects to display on this page.\n238         if (self.show_all and can_show_all) or not multi_page:\n239             result_list = self.queryset._clone()\n240         else:\n241             try:\n242                 result_list = paginator.page(self.page_num + 1).object_list\n243             except InvalidPage:\n244                 raise IncorrectLookupParameters\n245 \n246         self.result_count = result_count\n247         self.show_full_result_count = self.model_admin.show_full_result_count\n248         # Admin actions are shown if there is at least one entry\n249         # or if entries are not counted because show_full_result_count is disabled\n250         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)\n251         self.full_result_count = full_result_count\n252         self.result_list = result_list\n253         self.can_show_all = can_show_all\n254         self.multi_page = multi_page\n255         self.paginator = paginator\n256 \n257     def _get_default_ordering(self):\n258         ordering = []\n259         if self.model_admin.ordering:\n260             ordering = self.model_admin.ordering\n261         elif self.lookup_opts.ordering:\n262             ordering = self.lookup_opts.ordering\n263         return ordering\n264 \n265     def get_ordering_field(self, field_name):\n266         \"\"\"\n267         Return the proper model field name corresponding to the given\n268         field_name to use for ordering. field_name may either be the name of a\n269         proper model field or the name of a method (on the admin or model) or a\n270         callable with the 'admin_order_field' attribute. Return None if no\n271         proper model field name can be matched.\n272         \"\"\"\n273         try:\n274             field = self.lookup_opts.get_field(field_name)\n275             return field.name\n276         except FieldDoesNotExist:\n277             # See whether field_name is a name of a non-field\n278             # that allows sorting.\n279             if callable(field_name):\n280                 attr = field_name\n281             elif hasattr(self.model_admin, field_name):\n282                 attr = getattr(self.model_admin, field_name)\n283             else:\n284                 attr = getattr(self.model, field_name)\n285             if isinstance(attr, property) and hasattr(attr, 'fget'):\n286                 attr = attr.fget\n287             return getattr(attr, 'admin_order_field', None)\n288 \n289     def get_ordering(self, request, queryset):\n290         \"\"\"\n291         Return the list of ordering fields for the change list.\n292         First check the get_ordering() method in model admin, then check\n293         the object's default ordering. Then, any manually-specified ordering\n294         from the query string overrides anything. Finally, a deterministic\n295         order is guaranteed by calling _get_deterministic_ordering() with the\n296         constructed ordering.\n297         \"\"\"\n298         params = self.params\n299         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())\n300         if ORDER_VAR in params:\n301             # Clear ordering and used params\n302             ordering = []\n303             order_params = params[ORDER_VAR].split('.')\n304             for p in order_params:\n305                 try:\n306                     none, pfx, idx = p.rpartition('-')\n307                     field_name = self.list_display[int(idx)]\n308                     order_field = self.get_ordering_field(field_name)\n309                     if not order_field:\n310                         continue  # No 'admin_order_field', skip it\n311                     if isinstance(order_field, OrderBy):\n312                         if pfx == '-':\n313                             order_field = order_field.copy()\n314                             order_field.reverse_ordering()\n315                         ordering.append(order_field)\n316                     elif hasattr(order_field, 'resolve_expression'):\n317                         # order_field is an expression.\n318                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())\n319                     # reverse order if order_field has already \"-\" as prefix\n320                     elif order_field.startswith('-') and pfx == '-':\n321                         ordering.append(order_field[1:])\n322                     else:\n323                         ordering.append(pfx + order_field)\n324                 except (IndexError, ValueError):\n325                     continue  # Invalid ordering specified, skip it.\n326 \n327         # Add the given query's ordering fields, if any.\n328         ordering.extend(queryset.query.order_by)\n329 \n330         return self._get_deterministic_ordering(ordering)\n331 \n332     def _get_deterministic_ordering(self, ordering):\n333         \"\"\"\n334         Ensure a deterministic order across all database backends. Search for a\n335         single field or unique together set of fields providing a total\n336         ordering. If these are missing, augment the ordering with a descendant\n337         primary key.\n338         \"\"\"\n339         ordering = list(ordering)\n340         ordering_fields = set()\n341         total_ordering_fields = {'pk'} | {\n342             field.attname for field in self.lookup_opts.fields\n343             if field.unique and not field.null\n344         }\n345         for part in ordering:\n346             # Search for single field providing a total ordering.\n347             field_name = None\n348             if isinstance(part, str):\n349                 field_name = part.lstrip('-')\n350             elif isinstance(part, F):\n351                 field_name = part.name\n352             elif isinstance(part, OrderBy) and isinstance(part.expression, F):\n353                 field_name = part.expression.name\n354             if field_name:\n355                 # Normalize attname references by using get_field().\n356                 try:\n357                     field = self.lookup_opts.get_field(field_name)\n358                 except FieldDoesNotExist:\n359                     # Could be \"?\" for random ordering or a related field\n360                     # lookup. Skip this part of introspection for now.\n361                     continue\n362                 # Ordering by a related field name orders by the referenced\n363                 # model's ordering. Skip this part of introspection for now.\n364                 if field.remote_field and field_name == field.name:\n365                     continue\n366                 if field.attname in total_ordering_fields:\n367                     break\n368                 ordering_fields.add(field.attname)\n369         else:\n370             # No single total ordering field, try unique_together and total\n371             # unique constraints.\n372             constraint_field_names = (\n373                 *self.lookup_opts.unique_together,\n374                 *(\n375                     constraint.fields\n376                     for constraint in self.lookup_opts.total_unique_constraints\n377                 ),\n378             )\n379             for field_names in constraint_field_names:\n380                 # Normalize attname references by using get_field().\n381                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]\n382                 # Composite unique constraints containing a nullable column\n383                 # cannot ensure total ordering.\n384                 if any(field.null for field in fields):\n385                     continue\n386                 if ordering_fields.issuperset(field.attname for field in fields):\n387                     break\n388             else:\n389                 # If no set of unique fields is present in the ordering, rely\n390                 # on the primary key to provide total ordering.\n391                 ordering.append('-pk')\n392         return ordering\n393 \n394     def get_ordering_field_columns(self):\n395         \"\"\"\n396         Return a dictionary of ordering field column numbers and asc/desc.\n397         \"\"\"\n398         # We must cope with more than one column having the same underlying sort\n399         # field, so we base things on column numbers.\n400         ordering = self._get_default_ordering()\n401         ordering_fields = {}\n402         if ORDER_VAR not in self.params:\n403             # for ordering specified on ModelAdmin or model Meta, we don't know\n404             # the right column numbers absolutely, because there might be more\n405             # than one column associated with that ordering, so we guess.\n406             for field in ordering:\n407                 if isinstance(field, (Combinable, OrderBy)):\n408                     if not isinstance(field, OrderBy):\n409                         field = field.asc()\n410                     if isinstance(field.expression, F):\n411                         order_type = 'desc' if field.descending else 'asc'\n412                         field = field.expression.name\n413                     else:\n414                         continue\n415                 elif field.startswith('-'):\n416                     field = field[1:]\n417                     order_type = 'desc'\n418                 else:\n419                     order_type = 'asc'\n420                 for index, attr in enumerate(self.list_display):\n421                     if self.get_ordering_field(attr) == field:\n422                         ordering_fields[index] = order_type\n423                         break\n424         else:\n425             for p in self.params[ORDER_VAR].split('.'):\n426                 none, pfx, idx = p.rpartition('-')\n427                 try:\n428                     idx = int(idx)\n429                 except ValueError:\n430                     continue  # skip it\n431                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'\n432         return ordering_fields\n433 \n434     def get_queryset(self, request):\n435         # First, we collect all the declared list filters.\n436         (self.filter_specs, self.has_filters, remaining_lookup_params,\n437          filters_use_distinct) = self.get_filters(request)\n438 \n439         # Then, we let every list filter modify the queryset to its liking.\n440         qs = self.root_queryset\n441         for filter_spec in self.filter_specs:\n442             new_qs = filter_spec.queryset(request, qs)\n443             if new_qs is not None:\n444                 qs = new_qs\n445 \n446         try:\n447             # Finally, we apply the remaining lookup parameters from the query\n448             # string (i.e. those that haven't already been processed by the\n449             # filters).\n450             qs = qs.filter(**remaining_lookup_params)\n451         except (SuspiciousOperation, ImproperlyConfigured):\n452             # Allow certain types of errors to be re-raised as-is so that the\n453             # caller can treat them in a special way.\n454             raise\n455         except Exception as e:\n456             # Every other error is caught with a naked except, because we don't\n457             # have any other way of validating lookup parameters. They might be\n458             # invalid if the keyword arguments are incorrect, or if the values\n459             # are not in the correct type, so we might get FieldError,\n460             # ValueError, ValidationError, or ?.\n461             raise IncorrectLookupParameters(e)\n462 \n463         if not qs.query.select_related:\n464             qs = self.apply_select_related(qs)\n465 \n466         # Set ordering.\n467         ordering = self.get_ordering(request, qs)\n468         qs = qs.order_by(*ordering)\n469 \n470         # Apply search results\n471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)\n472 \n473         # Remove duplicates from results, if necessary\n474         if filters_use_distinct | search_use_distinct:\n475             return qs.distinct()\n476         else:\n477             return qs\n478 \n479     def apply_select_related(self, qs):\n480         if self.list_select_related is True:\n481             return qs.select_related()\n482 \n483         if self.list_select_related is False:\n484             if self.has_related_field_in_list_display():\n485                 return qs.select_related()\n486 \n487         if self.list_select_related:\n488             return qs.select_related(*self.list_select_related)\n489         return qs\n490 \n491     def has_related_field_in_list_display(self):\n492         for field_name in self.list_display:\n493             try:\n494                 field = self.lookup_opts.get_field(field_name)\n495             except FieldDoesNotExist:\n496                 pass\n497             else:\n498                 if isinstance(field.remote_field, ManyToOneRel):\n499                     # <FK>_id field names don't require a join.\n500                     if field_name != field.get_attname():\n501                         return True\n502         return False\n503 \n504     def url_for_result(self, result):\n505         pk = getattr(result, self.pk_attname)\n506         return reverse('admin:%s_%s_change' % (self.opts.app_label,\n507                                                self.opts.model_name),\n508                        args=(quote(pk),),\n509                        current_app=self.model_admin.admin_site.name)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/options.py",
        "start": 1669,
        "end": 1821,
        "class_name": "ModelAdmin",
        "method_name": "changelist_view",
        "code": "1669     def changelist_view(self, request, extra_context=None):\n1670         \"\"\"\n1671         The 'change list' admin view for this model.\n1672         \"\"\"\n1673         from django.contrib.admin.views.main import ERROR_FLAG\n1674         opts = self.model._meta\n1675         app_label = opts.app_label\n1676         if not self.has_view_or_change_permission(request):\n1677             raise PermissionDenied\n1678 \n1679         try:\n1680             cl = self.get_changelist_instance(request)\n1681         except IncorrectLookupParameters:\n1682             # Wacky lookup parameters were given, so redirect to the main\n1683             # changelist page, without parameters, and pass an 'invalid=1'\n1684             # parameter via the query string. If wacky parameters were given\n1685             # and the 'invalid=1' parameter was already in the query string,\n1686             # something is screwed up with the database, so display an error\n1687             # page.\n1688             if ERROR_FLAG in request.GET:\n1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {\n1690                     'title': _('Database error'),\n1691                 })\n1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')\n1693 \n1694         # If the request was POSTed, this might be a bulk action or a bulk\n1695         # edit. Try to look up an action or confirmation first, but if this\n1696         # isn't an action the POST will fall through to the bulk edit check,\n1697         # below.\n1698         action_failed = False\n1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1700 \n1701         actions = self.get_actions(request)\n1702         # Actions with no confirmation\n1703         if (actions and request.method == 'POST' and\n1704                 'index' in request.POST and '_save' not in request.POST):\n1705             if selected:\n1706                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1707                 if response:\n1708                     return response\n1709                 else:\n1710                     action_failed = True\n1711             else:\n1712                 msg = _(\"Items must be selected in order to perform \"\n1713                         \"actions on them. No items have been changed.\")\n1714                 self.message_user(request, msg, messages.WARNING)\n1715                 action_failed = True\n1716 \n1717         # Actions with confirmation\n1718         if (actions and request.method == 'POST' and\n1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and\n1720                 'index' not in request.POST and '_save' not in request.POST):\n1721             if selected:\n1722                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1723                 if response:\n1724                     return response\n1725                 else:\n1726                     action_failed = True\n1727 \n1728         if action_failed:\n1729             # Redirect back to the changelist page to avoid resubmitting the\n1730             # form if the user refreshes the browser or uses the \"No, take\n1731             # me back\" button on the action confirmation page.\n1732             return HttpResponseRedirect(request.get_full_path())\n1733 \n1734         # If we're allowing changelist editing, we need to construct a formset\n1735         # for the changelist given all the fields to be edited. Then we'll\n1736         # use the formset to validate/process POSTed data.\n1737         formset = cl.formset = None\n1738 \n1739         # Handle POSTed bulk-edit data.\n1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:\n1741             if not self.has_change_permission(request):\n1742                 raise PermissionDenied\n1743             FormSet = self.get_changelist_formset(request)\n1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())\n1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)\n1746             if formset.is_valid():\n1747                 changecount = 0\n1748                 for form in formset.forms:\n1749                     if form.has_changed():\n1750                         obj = self.save_form(request, form, change=True)\n1751                         self.save_model(request, obj, form, change=True)\n1752                         self.save_related(request, form, formsets=[], change=True)\n1753                         change_msg = self.construct_change_message(request, form, None)\n1754                         self.log_change(request, obj, change_msg)\n1755                         changecount += 1\n1756 \n1757                 if changecount:\n1758                     msg = ngettext(\n1759                         \"%(count)s %(name)s was changed successfully.\",\n1760                         \"%(count)s %(name)s were changed successfully.\",\n1761                         changecount\n1762                     ) % {\n1763                         'count': changecount,\n1764                         'name': model_ngettext(opts, changecount),\n1765                     }\n1766                     self.message_user(request, msg, messages.SUCCESS)\n1767 \n1768                 return HttpResponseRedirect(request.get_full_path())\n1769 \n1770         # Handle GET -- construct a formset for display.\n1771         elif cl.list_editable and self.has_change_permission(request):\n1772             FormSet = self.get_changelist_formset(request)\n1773             formset = cl.formset = FormSet(queryset=cl.result_list)\n1774 \n1775         # Build the list of media to be used by the formset.\n1776         if formset:\n1777             media = self.media + formset.media\n1778         else:\n1779             media = self.media\n1780 \n1781         # Build the action form and populate it with available actions.\n1782         if actions:\n1783             action_form = self.action_form(auto_id=None)\n1784             action_form.fields['action'].choices = self.get_action_choices(request)\n1785             media += action_form.media\n1786         else:\n1787             action_form = None\n1788 \n1789         selection_note_all = ngettext(\n1790             '%(total_count)s selected',\n1791             'All %(total_count)s selected',\n1792             cl.result_count\n1793         )\n1794 \n1795         context = {\n1796             **self.admin_site.each_context(request),\n1797             'module_name': str(opts.verbose_name_plural),\n1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},\n1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},\n1800             'title': cl.title,\n1801             'is_popup': cl.is_popup,\n1802             'to_field': cl.to_field,\n1803             'cl': cl,\n1804             'media': media,\n1805             'has_add_permission': self.has_add_permission(request),\n1806             'opts': cl.opts,\n1807             'action_form': action_form,\n1808             'actions_on_top': self.actions_on_top,\n1809             'actions_on_bottom': self.actions_on_bottom,\n1810             'actions_selection_counter': self.actions_selection_counter,\n1811             'preserved_filters': self.get_preserved_filters(request),\n1812             **(extra_context or {}),\n1813         }\n1814 \n1815         request.current_app = self.admin_site.name\n1816 \n1817         return TemplateResponse(request, self.change_list_template or [\n1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),\n1819             'admin/%s/change_list.html' % app_label,\n1820             'admin/change_list.html'\n1821         ], context)\n",
        "intended_behavior": "The handling of the context for `date_hierarchy` within `changelist_view` may need to be revisited to ensure that the context's date hierarchy links are generated with awareness of the user's timezone. This might not involve changes within the `changelist_view` method itself but ensuring that any data passed to it, particularly variables related to date filters, are correctly timezone-aware. The goal is to maintain the functionality of generating hierarchical date filters (year, month, day) while ensuring the boundaries of these filters reflect the user's timezone. This would likely require collaboration with how the `ChangeList` class processes `date_hierarchy` to ensure consistent timezone application throughout."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/options.py",
        "start": 541,
        "end": 1975,
        "class_name": "ModelAdmin",
        "method_name": null,
        "code": "541 class ModelAdmin(BaseModelAdmin):\n542     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n543 \n544     list_display = ('__str__',)\n545     list_display_links = ()\n546     list_filter = ()\n547     list_select_related = False\n548     list_per_page = 100\n549     list_max_show_all = 200\n550     list_editable = ()\n551     search_fields = ()\n552     date_hierarchy = None\n553     save_as = False\n554     save_as_continue = True\n555     save_on_top = False\n556     paginator = Paginator\n557     preserve_filters = True\n558     inlines = []\n559 \n560     # Custom templates (designed to be over-ridden in subclasses)\n561     add_form_template = None\n562     change_form_template = None\n563     change_list_template = None\n564     delete_confirmation_template = None\n565     delete_selected_confirmation_template = None\n566     object_history_template = None\n567     popup_response_template = None\n568 \n569     # Actions\n570     actions = []\n571     action_form = helpers.ActionForm\n572     actions_on_top = True\n573     actions_on_bottom = False\n574     actions_selection_counter = True\n575     checks_class = ModelAdminChecks\n576 \n577     def __init__(self, model, admin_site):\n578         self.model = model\n579         self.opts = model._meta\n580         self.admin_site = admin_site\n581         super().__init__()\n582 \n583     def __str__(self):\n584         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n585 \n586     def get_inline_instances(self, request, obj=None):\n587         inline_instances = []\n588         for inline_class in self.get_inlines(request, obj):\n589             inline = inline_class(self.model, self.admin_site)\n590             if request:\n591                 if not (inline.has_view_or_change_permission(request, obj) or\n592                         inline.has_add_permission(request, obj) or\n593                         inline.has_delete_permission(request, obj)):\n594                     continue\n595                 if not inline.has_add_permission(request, obj):\n596                     inline.max_num = 0\n597             inline_instances.append(inline)\n598 \n599         return inline_instances\n600 \n601     def get_urls(self):\n602         from django.urls import path\n603 \n604         def wrap(view):\n605             def wrapper(*args, **kwargs):\n606                 return self.admin_site.admin_view(view)(*args, **kwargs)\n607             wrapper.model_admin = self\n608             return update_wrapper(wrapper, view)\n609 \n610         info = self.model._meta.app_label, self.model._meta.model_name\n611 \n612         return [\n613             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),\n614             path('add/', wrap(self.add_view), name='%s_%s_add' % info),\n615             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),\n616             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),\n617             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),\n618             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),\n619             # For backwards compatibility (was the change url before 1.9)\n620             path('<path:object_id>/', wrap(RedirectView.as_view(\n621                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)\n622             ))),\n623         ]\n624 \n625     @property\n626     def urls(self):\n627         return self.get_urls()\n628 \n629     @property\n630     def media(self):\n631         extra = '' if settings.DEBUG else '.min'\n632         js = [\n633             'vendor/jquery/jquery%s.js' % extra,\n634             'jquery.init.js',\n635             'core.js',\n636             'admin/RelatedObjectLookups.js',\n637             'actions%s.js' % extra,\n638             'urlify.js',\n639             'prepopulate%s.js' % extra,\n640             'vendor/xregexp/xregexp%s.js' % extra,\n641         ]\n642         return forms.Media(js=['admin/js/%s' % url for url in js])\n643 \n644     def get_model_perms(self, request):\n645         \"\"\"\n646         Return a dict of all perms for this model. This dict has the keys\n647         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n648         for each of those actions.\n649         \"\"\"\n650         return {\n651             'add': self.has_add_permission(request),\n652             'change': self.has_change_permission(request),\n653             'delete': self.has_delete_permission(request),\n654             'view': self.has_view_permission(request),\n655         }\n656 \n657     def _get_form_for_get_fields(self, request, obj):\n658         return self.get_form(request, obj, fields=None)\n659 \n660     def get_form(self, request, obj=None, change=False, **kwargs):\n661         \"\"\"\n662         Return a Form class for use in the admin add view. This is used by\n663         add_view and change_view.\n664         \"\"\"\n665         if 'fields' in kwargs:\n666             fields = kwargs.pop('fields')\n667         else:\n668             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n669         excluded = self.get_exclude(request, obj)\n670         exclude = [] if excluded is None else list(excluded)\n671         readonly_fields = self.get_readonly_fields(request, obj)\n672         exclude.extend(readonly_fields)\n673         # Exclude all fields if it's a change form and the user doesn't have\n674         # the change permission.\n675         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):\n676             exclude.extend(fields)\n677         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n678             # Take the custom ModelForm's Meta.exclude into account only if the\n679             # ModelAdmin doesn't define its own.\n680             exclude.extend(self.form._meta.exclude)\n681         # if exclude is an empty list we pass None to be consistent with the\n682         # default on modelform_factory\n683         exclude = exclude or None\n684 \n685         # Remove declared form fields which are in readonly_fields.\n686         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)\n687         form = type(self.form.__name__, (self.form,), new_attrs)\n688 \n689         defaults = {\n690             'form': form,\n691             'fields': fields,\n692             'exclude': exclude,\n693             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n694             **kwargs,\n695         }\n696 \n697         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n698             defaults['fields'] = forms.ALL_FIELDS\n699 \n700         try:\n701             return modelform_factory(self.model, **defaults)\n702         except FieldError as e:\n703             raise FieldError(\n704                 '%s. Check fields/fieldsets/exclude attributes of class %s.'\n705                 % (e, self.__class__.__name__)\n706             )\n707 \n708     def get_changelist(self, request, **kwargs):\n709         \"\"\"\n710         Return the ChangeList class for use on the changelist page.\n711         \"\"\"\n712         from django.contrib.admin.views.main import ChangeList\n713         return ChangeList\n714 \n715     def get_changelist_instance(self, request):\n716         \"\"\"\n717         Return a `ChangeList` instance based on `request`. May raise\n718         `IncorrectLookupParameters`.\n719         \"\"\"\n720         list_display = self.get_list_display(request)\n721         list_display_links = self.get_list_display_links(request, list_display)\n722         # Add the action checkboxes if any actions are available.\n723         if self.get_actions(request):\n724             list_display = ['action_checkbox', *list_display]\n725         sortable_by = self.get_sortable_by(request)\n726         ChangeList = self.get_changelist(request)\n727         return ChangeList(\n728             request,\n729             self.model,\n730             list_display,\n731             list_display_links,\n732             self.get_list_filter(request),\n733             self.date_hierarchy,\n734             self.get_search_fields(request),\n735             self.get_list_select_related(request),\n736             self.list_per_page,\n737             self.list_max_show_all,\n738             self.list_editable,\n739             self,\n740             sortable_by,\n741         )\n742 \n743     def get_object(self, request, object_id, from_field=None):\n744         \"\"\"\n745         Return an instance matching the field and value provided, the primary\n746         key is used if no field is provided. Return ``None`` if no match is\n747         found or the object_id fails validation.\n748         \"\"\"\n749         queryset = self.get_queryset(request)\n750         model = queryset.model\n751         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)\n752         try:\n753             object_id = field.to_python(object_id)\n754             return queryset.get(**{field.name: object_id})\n755         except (model.DoesNotExist, ValidationError, ValueError):\n756             return None\n757 \n758     def get_changelist_form(self, request, **kwargs):\n759         \"\"\"\n760         Return a Form class for use in the Formset on the changelist page.\n761         \"\"\"\n762         defaults = {\n763             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n764             **kwargs,\n765         }\n766         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):\n767             defaults['fields'] = forms.ALL_FIELDS\n768 \n769         return modelform_factory(self.model, **defaults)\n770 \n771     def get_changelist_formset(self, request, **kwargs):\n772         \"\"\"\n773         Return a FormSet class for use on the changelist page if list_editable\n774         is used.\n775         \"\"\"\n776         defaults = {\n777             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n778             **kwargs,\n779         }\n780         return modelformset_factory(\n781             self.model, self.get_changelist_form(request), extra=0,\n782             fields=self.list_editable, **defaults\n783         )\n784 \n785     def get_formsets_with_inlines(self, request, obj=None):\n786         \"\"\"\n787         Yield formsets and the corresponding inlines.\n788         \"\"\"\n789         for inline in self.get_inline_instances(request, obj):\n790             yield inline.get_formset(request, obj), inline\n791 \n792     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):\n793         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n794 \n795     def log_addition(self, request, object, message):\n796         \"\"\"\n797         Log that an object has been successfully added.\n798 \n799         The default implementation creates an admin LogEntry object.\n800         \"\"\"\n801         from django.contrib.admin.models import LogEntry, ADDITION\n802         return LogEntry.objects.log_action(\n803             user_id=request.user.pk,\n804             content_type_id=get_content_type_for_model(object).pk,\n805             object_id=object.pk,\n806             object_repr=str(object),\n807             action_flag=ADDITION,\n808             change_message=message,\n809         )\n810 \n811     def log_change(self, request, object, message):\n812         \"\"\"\n813         Log that an object has been successfully changed.\n814 \n815         The default implementation creates an admin LogEntry object.\n816         \"\"\"\n817         from django.contrib.admin.models import LogEntry, CHANGE\n818         return LogEntry.objects.log_action(\n819             user_id=request.user.pk,\n820             content_type_id=get_content_type_for_model(object).pk,\n821             object_id=object.pk,\n822             object_repr=str(object),\n823             action_flag=CHANGE,\n824             change_message=message,\n825         )\n826 \n827     def log_deletion(self, request, object, object_repr):\n828         \"\"\"\n829         Log that an object will be deleted. Note that this method must be\n830         called before the deletion.\n831 \n832         The default implementation creates an admin LogEntry object.\n833         \"\"\"\n834         from django.contrib.admin.models import LogEntry, DELETION\n835         return LogEntry.objects.log_action(\n836             user_id=request.user.pk,\n837             content_type_id=get_content_type_for_model(object).pk,\n838             object_id=object.pk,\n839             object_repr=object_repr,\n840             action_flag=DELETION,\n841         )\n842 \n843     def action_checkbox(self, obj):\n844         \"\"\"\n845         A list_display column containing a checkbox widget.\n846         \"\"\"\n847         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n848     action_checkbox.short_description = mark_safe('<input type=\"checkbox\" id=\"action-toggle\">')\n849 \n850     def _get_base_actions(self):\n851         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n852         actions = []\n853 \n854         # Gather actions from the admin site first\n855         for (name, func) in self.admin_site.actions:\n856             description = getattr(func, 'short_description', name.replace('_', ' '))\n857             actions.append((func, name, description))\n858         # Add actions from this ModelAdmin.\n859         actions.extend(self.get_action(action) for action in self.actions or [])\n860         # get_action might have returned None, so filter any of those out.\n861         return filter(None, actions)\n862 \n863     def _filter_actions_by_permissions(self, request, actions):\n864         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n865         filtered_actions = []\n866         for action in actions:\n867             callable = action[0]\n868             if not hasattr(callable, 'allowed_permissions'):\n869                 filtered_actions.append(action)\n870                 continue\n871             permission_checks = (\n872                 getattr(self, 'has_%s_permission' % permission)\n873                 for permission in callable.allowed_permissions\n874             )\n875             if any(has_permission(request) for has_permission in permission_checks):\n876                 filtered_actions.append(action)\n877         return filtered_actions\n878 \n879     def get_actions(self, request):\n880         \"\"\"\n881         Return a dictionary mapping the names of all actions for this\n882         ModelAdmin to a tuple of (callable, name, description) for each action.\n883         \"\"\"\n884         # If self.actions is set to None that means actions are disabled on\n885         # this page.\n886         if self.actions is None or IS_POPUP_VAR in request.GET:\n887             return {}\n888         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n889         return {name: (func, name, desc) for func, name, desc in actions}\n890 \n891     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n892         \"\"\"\n893         Return a list of choices for use in a form object.  Each choice is a\n894         tuple (name, description).\n895         \"\"\"\n896         choices = [] + default_choices\n897         for func, name, description in self.get_actions(request).values():\n898             choice = (name, description % model_format_dict(self.opts))\n899             choices.append(choice)\n900         return choices\n901 \n902     def get_action(self, action):\n903         \"\"\"\n904         Return a given action from a parameter, which can either be a callable,\n905         or the name of a method on the ModelAdmin.  Return is a tuple of\n906         (callable, name, description).\n907         \"\"\"\n908         # If the action is a callable, just use it.\n909         if callable(action):\n910             func = action\n911             action = action.__name__\n912 \n913         # Next, look for a method. Grab it off self.__class__ to get an unbound\n914         # method instead of a bound one; this ensures that the calling\n915         # conventions are the same for functions and methods.\n916         elif hasattr(self.__class__, action):\n917             func = getattr(self.__class__, action)\n918 \n919         # Finally, look for a named method on the admin site\n920         else:\n921             try:\n922                 func = self.admin_site.get_action(action)\n923             except KeyError:\n924                 return None\n925 \n926         if hasattr(func, 'short_description'):\n927             description = func.short_description\n928         else:\n929             description = capfirst(action.replace('_', ' '))\n930         return func, action, description\n931 \n932     def get_list_display(self, request):\n933         \"\"\"\n934         Return a sequence containing the fields to be displayed on the\n935         changelist.\n936         \"\"\"\n937         return self.list_display\n938 \n939     def get_list_display_links(self, request, list_display):\n940         \"\"\"\n941         Return a sequence containing the fields to be displayed as links\n942         on the changelist. The list_display parameter is the list of fields\n943         returned by get_list_display().\n944         \"\"\"\n945         if self.list_display_links or self.list_display_links is None or not list_display:\n946             return self.list_display_links\n947         else:\n948             # Use only the first item in list_display as link\n949             return list(list_display)[:1]\n950 \n951     def get_list_filter(self, request):\n952         \"\"\"\n953         Return a sequence containing the fields to be displayed as filters in\n954         the right sidebar of the changelist page.\n955         \"\"\"\n956         return self.list_filter\n957 \n958     def get_list_select_related(self, request):\n959         \"\"\"\n960         Return a list of fields to add to the select_related() part of the\n961         changelist items query.\n962         \"\"\"\n963         return self.list_select_related\n964 \n965     def get_search_fields(self, request):\n966         \"\"\"\n967         Return a sequence containing the fields to be searched whenever\n968         somebody submits a search query.\n969         \"\"\"\n970         return self.search_fields\n971 \n972     def get_search_results(self, request, queryset, search_term):\n973         \"\"\"\n974         Return a tuple containing a queryset to implement the search\n975         and a boolean indicating if the results may contain duplicates.\n976         \"\"\"\n977         # Apply keyword searches.\n978         def construct_search(field_name):\n979             if field_name.startswith('^'):\n980                 return \"%s__istartswith\" % field_name[1:]\n981             elif field_name.startswith('='):\n982                 return \"%s__iexact\" % field_name[1:]\n983             elif field_name.startswith('@'):\n984                 return \"%s__search\" % field_name[1:]\n985             # Use field_name if it includes a lookup.\n986             opts = queryset.model._meta\n987             lookup_fields = field_name.split(LOOKUP_SEP)\n988             # Go through the fields, following all relations.\n989             prev_field = None\n990             for path_part in lookup_fields:\n991                 if path_part == 'pk':\n992                     path_part = opts.pk.name\n993                 try:\n994                     field = opts.get_field(path_part)\n995                 except FieldDoesNotExist:\n996                     # Use valid query lookups.\n997                     if prev_field and prev_field.get_lookup(path_part):\n998                         return field_name\n999                 else:\n1000                     prev_field = field\n1001                     if hasattr(field, 'get_path_info'):\n1002                         # Update opts to follow the relation.\n1003                         opts = field.get_path_info()[-1].to_opts\n1004             # Otherwise, use the field with icontains.\n1005             return \"%s__icontains\" % field_name\n1006 \n1007         use_distinct = False\n1008         search_fields = self.get_search_fields(request)\n1009         if search_fields and search_term:\n1010             orm_lookups = [construct_search(str(search_field))\n1011                            for search_field in search_fields]\n1012             for bit in search_term.split():\n1013                 or_queries = [models.Q(**{orm_lookup: bit})\n1014                               for orm_lookup in orm_lookups]\n1015                 queryset = queryset.filter(reduce(operator.or_, or_queries))\n1016             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)\n1017 \n1018         return queryset, use_distinct\n1019 \n1020     def get_preserved_filters(self, request):\n1021         \"\"\"\n1022         Return the preserved filters querystring.\n1023         \"\"\"\n1024         match = request.resolver_match\n1025         if self.preserve_filters and match:\n1026             opts = self.model._meta\n1027             current_url = '%s:%s' % (match.app_name, match.url_name)\n1028             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)\n1029             if current_url == changelist_url:\n1030                 preserved_filters = request.GET.urlencode()\n1031             else:\n1032                 preserved_filters = request.GET.get('_changelist_filters')\n1033 \n1034             if preserved_filters:\n1035                 return urlencode({'_changelist_filters': preserved_filters})\n1036         return ''\n1037 \n1038     def construct_change_message(self, request, form, formsets, add=False):\n1039         \"\"\"\n1040         Construct a JSON structure describing changes from a changed object.\n1041         \"\"\"\n1042         return construct_change_message(form, formsets, add)\n1043 \n1044     def message_user(self, request, message, level=messages.INFO, extra_tags='',\n1045                      fail_silently=False):\n1046         \"\"\"\n1047         Send a message to the user. The default implementation\n1048         posts a message using the django.contrib.messages backend.\n1049 \n1050         Exposes almost the same API as messages.add_message(), but accepts the\n1051         positional arguments in a different order to maintain backwards\n1052         compatibility. For convenience, it accepts the `level` argument as\n1053         a string rather than the usual level number.\n1054         \"\"\"\n1055         if not isinstance(level, int):\n1056             # attempt to get the level if passed a string\n1057             try:\n1058                 level = getattr(messages.constants, level.upper())\n1059             except AttributeError:\n1060                 levels = messages.constants.DEFAULT_TAGS.values()\n1061                 levels_repr = ', '.join('`%s`' % l for l in levels)\n1062                 raise ValueError(\n1063                     'Bad message level string: `%s`. Possible values are: %s'\n1064                     % (level, levels_repr)\n1065                 )\n1066 \n1067         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)\n1068 \n1069     def save_form(self, request, form, change):\n1070         \"\"\"\n1071         Given a ModelForm return an unsaved instance. ``change`` is True if\n1072         the object is being changed, and False if it's being added.\n1073         \"\"\"\n1074         return form.save(commit=False)\n1075 \n1076     def save_model(self, request, obj, form, change):\n1077         \"\"\"\n1078         Given a model instance save it to the database.\n1079         \"\"\"\n1080         obj.save()\n1081 \n1082     def delete_model(self, request, obj):\n1083         \"\"\"\n1084         Given a model instance delete it from the database.\n1085         \"\"\"\n1086         obj.delete()\n1087 \n1088     def delete_queryset(self, request, queryset):\n1089         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1090         queryset.delete()\n1091 \n1092     def save_formset(self, request, form, formset, change):\n1093         \"\"\"\n1094         Given an inline formset save it to the database.\n1095         \"\"\"\n1096         formset.save()\n1097 \n1098     def save_related(self, request, form, formsets, change):\n1099         \"\"\"\n1100         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1101         list of inline formsets and a boolean value based on whether the\n1102         parent is being added or changed, save the related objects to the\n1103         database. Note that at this point save_form() and save_model() have\n1104         already been called.\n1105         \"\"\"\n1106         form.save_m2m()\n1107         for formset in formsets:\n1108             self.save_formset(request, form, formset, change=change)\n1109 \n1110     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):\n1111         opts = self.model._meta\n1112         app_label = opts.app_label\n1113         preserved_filters = self.get_preserved_filters(request)\n1114         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)\n1115         view_on_site_url = self.get_view_on_site_url(obj)\n1116         has_editable_inline_admin_formsets = False\n1117         for inline in context['inline_admin_formsets']:\n1118             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:\n1119                 has_editable_inline_admin_formsets = True\n1120                 break\n1121         context.update({\n1122             'add': add,\n1123             'change': change,\n1124             'has_view_permission': self.has_view_permission(request, obj),\n1125             'has_add_permission': self.has_add_permission(request),\n1126             'has_change_permission': self.has_change_permission(request, obj),\n1127             'has_delete_permission': self.has_delete_permission(request, obj),\n1128             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,\n1129             'has_file_field': context['adminform'].form.is_multipart() or any(\n1130                 admin_formset.formset.is_multipart()\n1131                 for admin_formset in context['inline_admin_formsets']\n1132             ),\n1133             'has_absolute_url': view_on_site_url is not None,\n1134             'absolute_url': view_on_site_url,\n1135             'form_url': form_url,\n1136             'opts': opts,\n1137             'content_type_id': get_content_type_for_model(self.model).pk,\n1138             'save_as': self.save_as,\n1139             'save_on_top': self.save_on_top,\n1140             'to_field_var': TO_FIELD_VAR,\n1141             'is_popup_var': IS_POPUP_VAR,\n1142             'app_label': app_label,\n1143         })\n1144         if add and self.add_form_template is not None:\n1145             form_template = self.add_form_template\n1146         else:\n1147             form_template = self.change_form_template\n1148 \n1149         request.current_app = self.admin_site.name\n1150 \n1151         return TemplateResponse(request, form_template or [\n1152             \"admin/%s/%s/change_form.html\" % (app_label, opts.model_name),\n1153             \"admin/%s/change_form.html\" % app_label,\n1154             \"admin/change_form.html\"\n1155         ], context)\n1156 \n1157     def response_add(self, request, obj, post_url_continue=None):\n1158         \"\"\"\n1159         Determine the HttpResponse for the add_view stage.\n1160         \"\"\"\n1161         opts = obj._meta\n1162         preserved_filters = self.get_preserved_filters(request)\n1163         obj_url = reverse(\n1164             'admin:%s_%s_change' % (opts.app_label, opts.model_name),\n1165             args=(quote(obj.pk),),\n1166             current_app=self.admin_site.name,\n1167         )\n1168         # Add a link to the object's change form if the user can edit the obj.\n1169         if self.has_change_permission(request, obj):\n1170             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1171         else:\n1172             obj_repr = str(obj)\n1173         msg_dict = {\n1174             'name': opts.verbose_name,\n1175             'obj': obj_repr,\n1176         }\n1177         # Here, we distinguish between different save types by checking for\n1178         # the presence of keys in request.POST.\n1179 \n1180         if IS_POPUP_VAR in request.POST:\n1181             to_field = request.POST.get(TO_FIELD_VAR)\n1182             if to_field:\n1183                 attr = str(to_field)\n1184             else:\n1185                 attr = obj._meta.pk.attname\n1186             value = obj.serializable_value(attr)\n1187             popup_response_data = json.dumps({\n1188                 'value': str(value),\n1189                 'obj': str(obj),\n1190             })\n1191             return TemplateResponse(request, self.popup_response_template or [\n1192                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1193                 'admin/%s/popup_response.html' % opts.app_label,\n1194                 'admin/popup_response.html',\n1195             ], {\n1196                 'popup_response_data': popup_response_data,\n1197             })\n1198 \n1199         elif \"_continue\" in request.POST or (\n1200                 # Redirecting after \"Save as new\".\n1201                 \"_saveasnew\" in request.POST and self.save_as_continue and\n1202                 self.has_change_permission(request, obj)\n1203         ):\n1204             msg = _('The {name} \u201c{obj}\u201d was added successfully.')\n1205             if self.has_change_permission(request, obj):\n1206                 msg += ' ' + _('You may edit it again below.')\n1207             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1208             if post_url_continue is None:\n1209                 post_url_continue = obj_url\n1210             post_url_continue = add_preserved_filters(\n1211                 {'preserved_filters': preserved_filters, 'opts': opts},\n1212                 post_url_continue\n1213             )\n1214             return HttpResponseRedirect(post_url_continue)\n1215 \n1216         elif \"_addanother\" in request.POST:\n1217             msg = format_html(\n1218                 _('The {name} \u201c{obj}\u201d was added successfully. You may add another {name} below.'),\n1219                 **msg_dict\n1220             )\n1221             self.message_user(request, msg, messages.SUCCESS)\n1222             redirect_url = request.path\n1223             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1224             return HttpResponseRedirect(redirect_url)\n1225 \n1226         else:\n1227             msg = format_html(\n1228                 _('The {name} \u201c{obj}\u201d was added successfully.'),\n1229                 **msg_dict\n1230             )\n1231             self.message_user(request, msg, messages.SUCCESS)\n1232             return self.response_post_save_add(request, obj)\n1233 \n1234     def response_change(self, request, obj):\n1235         \"\"\"\n1236         Determine the HttpResponse for the change_view stage.\n1237         \"\"\"\n1238 \n1239         if IS_POPUP_VAR in request.POST:\n1240             opts = obj._meta\n1241             to_field = request.POST.get(TO_FIELD_VAR)\n1242             attr = str(to_field) if to_field else opts.pk.attname\n1243             value = request.resolver_match.kwargs['object_id']\n1244             new_value = obj.serializable_value(attr)\n1245             popup_response_data = json.dumps({\n1246                 'action': 'change',\n1247                 'value': str(value),\n1248                 'obj': str(obj),\n1249                 'new_value': str(new_value),\n1250             })\n1251             return TemplateResponse(request, self.popup_response_template or [\n1252                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1253                 'admin/%s/popup_response.html' % opts.app_label,\n1254                 'admin/popup_response.html',\n1255             ], {\n1256                 'popup_response_data': popup_response_data,\n1257             })\n1258 \n1259         opts = self.model._meta\n1260         preserved_filters = self.get_preserved_filters(request)\n1261 \n1262         msg_dict = {\n1263             'name': opts.verbose_name,\n1264             'obj': format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1265         }\n1266         if \"_continue\" in request.POST:\n1267             msg = format_html(\n1268                 _('The {name} \u201c{obj}\u201d was changed successfully. You may edit it again below.'),\n1269                 **msg_dict\n1270             )\n1271             self.message_user(request, msg, messages.SUCCESS)\n1272             redirect_url = request.path\n1273             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1274             return HttpResponseRedirect(redirect_url)\n1275 \n1276         elif \"_saveasnew\" in request.POST:\n1277             msg = format_html(\n1278                 _('The {name} \u201c{obj}\u201d was added successfully. You may edit it again below.'),\n1279                 **msg_dict\n1280             )\n1281             self.message_user(request, msg, messages.SUCCESS)\n1282             redirect_url = reverse('admin:%s_%s_change' %\n1283                                    (opts.app_label, opts.model_name),\n1284                                    args=(obj.pk,),\n1285                                    current_app=self.admin_site.name)\n1286             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1287             return HttpResponseRedirect(redirect_url)\n1288 \n1289         elif \"_addanother\" in request.POST:\n1290             msg = format_html(\n1291                 _('The {name} \u201c{obj}\u201d was changed successfully. You may add another {name} below.'),\n1292                 **msg_dict\n1293             )\n1294             self.message_user(request, msg, messages.SUCCESS)\n1295             redirect_url = reverse('admin:%s_%s_add' %\n1296                                    (opts.app_label, opts.model_name),\n1297                                    current_app=self.admin_site.name)\n1298             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1299             return HttpResponseRedirect(redirect_url)\n1300 \n1301         else:\n1302             msg = format_html(\n1303                 _('The {name} \u201c{obj}\u201d was changed successfully.'),\n1304                 **msg_dict\n1305             )\n1306             self.message_user(request, msg, messages.SUCCESS)\n1307             return self.response_post_save_change(request, obj)\n1308 \n1309     def _response_post_save(self, request, obj):\n1310         opts = self.model._meta\n1311         if self.has_view_or_change_permission(request):\n1312             post_url = reverse('admin:%s_%s_changelist' %\n1313                                (opts.app_label, opts.model_name),\n1314                                current_app=self.admin_site.name)\n1315             preserved_filters = self.get_preserved_filters(request)\n1316             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)\n1317         else:\n1318             post_url = reverse('admin:index',\n1319                                current_app=self.admin_site.name)\n1320         return HttpResponseRedirect(post_url)\n1321 \n1322     def response_post_save_add(self, request, obj):\n1323         \"\"\"\n1324         Figure out where to redirect after the 'Save' button has been pressed\n1325         when adding a new object.\n1326         \"\"\"\n1327         return self._response_post_save(request, obj)\n1328 \n1329     def response_post_save_change(self, request, obj):\n1330         \"\"\"\n1331         Figure out where to redirect after the 'Save' button has been pressed\n1332         when editing an existing object.\n1333         \"\"\"\n1334         return self._response_post_save(request, obj)\n1335 \n1336     def response_action(self, request, queryset):\n1337         \"\"\"\n1338         Handle an admin action. This is called if a request is POSTed to the\n1339         changelist; it returns an HttpResponse if the action was handled, and\n1340         None otherwise.\n1341         \"\"\"\n1342 \n1343         # There can be multiple action forms on the page (at the top\n1344         # and bottom of the change list, for example). Get the action\n1345         # whose button was pushed.\n1346         try:\n1347             action_index = int(request.POST.get('index', 0))\n1348         except ValueError:\n1349             action_index = 0\n1350 \n1351         # Construct the action form.\n1352         data = request.POST.copy()\n1353         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1354         data.pop(\"index\", None)\n1355 \n1356         # Use the action whose button was pushed\n1357         try:\n1358             data.update({'action': data.getlist('action')[action_index]})\n1359         except IndexError:\n1360             # If we didn't get an action from the chosen form that's invalid\n1361             # POST data, so by deleting action it'll fail the validation check\n1362             # below. So no need to do anything here\n1363             pass\n1364 \n1365         action_form = self.action_form(data, auto_id=None)\n1366         action_form.fields['action'].choices = self.get_action_choices(request)\n1367 \n1368         # If the form's valid we can handle the action.\n1369         if action_form.is_valid():\n1370             action = action_form.cleaned_data['action']\n1371             select_across = action_form.cleaned_data['select_across']\n1372             func = self.get_actions(request)[action][0]\n1373 \n1374             # Get the list of selected PKs. If nothing's selected, we can't\n1375             # perform an action on it, so bail. Except we want to perform\n1376             # the action explicitly on all objects.\n1377             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1378             if not selected and not select_across:\n1379                 # Reminder that something needs to be selected or nothing will happen\n1380                 msg = _(\"Items must be selected in order to perform \"\n1381                         \"actions on them. No items have been changed.\")\n1382                 self.message_user(request, msg, messages.WARNING)\n1383                 return None\n1384 \n1385             if not select_across:\n1386                 # Perform the action only on the selected objects\n1387                 queryset = queryset.filter(pk__in=selected)\n1388 \n1389             response = func(self, request, queryset)\n1390 \n1391             # Actions may return an HttpResponse-like object, which will be\n1392             # used as the response from the POST. If not, we'll be a good\n1393             # little HTTP citizen and redirect back to the changelist page.\n1394             if isinstance(response, HttpResponseBase):\n1395                 return response\n1396             else:\n1397                 return HttpResponseRedirect(request.get_full_path())\n1398         else:\n1399             msg = _(\"No action selected.\")\n1400             self.message_user(request, msg, messages.WARNING)\n1401             return None\n1402 \n1403     def response_delete(self, request, obj_display, obj_id):\n1404         \"\"\"\n1405         Determine the HttpResponse for the delete_view stage.\n1406         \"\"\"\n1407         opts = self.model._meta\n1408 \n1409         if IS_POPUP_VAR in request.POST:\n1410             popup_response_data = json.dumps({\n1411                 'action': 'delete',\n1412                 'value': str(obj_id),\n1413             })\n1414             return TemplateResponse(request, self.popup_response_template or [\n1415                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1416                 'admin/%s/popup_response.html' % opts.app_label,\n1417                 'admin/popup_response.html',\n1418             ], {\n1419                 'popup_response_data': popup_response_data,\n1420             })\n1421 \n1422         self.message_user(\n1423             request,\n1424             _('The %(name)s \u201c%(obj)s\u201d was deleted successfully.') % {\n1425                 'name': opts.verbose_name,\n1426                 'obj': obj_display,\n1427             },\n1428             messages.SUCCESS,\n1429         )\n1430 \n1431         if self.has_change_permission(request, None):\n1432             post_url = reverse(\n1433                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),\n1434                 current_app=self.admin_site.name,\n1435             )\n1436             preserved_filters = self.get_preserved_filters(request)\n1437             post_url = add_preserved_filters(\n1438                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url\n1439             )\n1440         else:\n1441             post_url = reverse('admin:index', current_app=self.admin_site.name)\n1442         return HttpResponseRedirect(post_url)\n1443 \n1444     def render_delete_form(self, request, context):\n1445         opts = self.model._meta\n1446         app_label = opts.app_label\n1447 \n1448         request.current_app = self.admin_site.name\n1449         context.update(\n1450             to_field_var=TO_FIELD_VAR,\n1451             is_popup_var=IS_POPUP_VAR,\n1452             media=self.media,\n1453         )\n1454 \n1455         return TemplateResponse(\n1456             request,\n1457             self.delete_confirmation_template or [\n1458                 \"admin/{}/{}/delete_confirmation.html\".format(app_label, opts.model_name),\n1459                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1460                 \"admin/delete_confirmation.html\",\n1461             ],\n1462             context,\n1463         )\n1464 \n1465     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):\n1466         # Edit permissions on parent model are required for editable inlines.\n1467         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)\n1468         inline_admin_formsets = []\n1469         for inline, formset in zip(inline_instances, formsets):\n1470             fieldsets = list(inline.get_fieldsets(request, obj))\n1471             readonly = list(inline.get_readonly_fields(request, obj))\n1472             if can_edit_parent:\n1473                 has_add_permission = inline.has_add_permission(request, obj)\n1474                 has_change_permission = inline.has_change_permission(request, obj)\n1475                 has_delete_permission = inline.has_delete_permission(request, obj)\n1476             else:\n1477                 # Disable all edit-permissions, and overide formset settings.\n1478                 has_add_permission = has_change_permission = has_delete_permission = False\n1479                 formset.extra = formset.max_num = 0\n1480             has_view_permission = inline.has_view_permission(request, obj)\n1481             prepopulated = dict(inline.get_prepopulated_fields(request, obj))\n1482             inline_admin_formset = helpers.InlineAdminFormSet(\n1483                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,\n1484                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,\n1485                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,\n1486             )\n1487             inline_admin_formsets.append(inline_admin_formset)\n1488         return inline_admin_formsets\n1489 \n1490     def get_changeform_initial_data(self, request):\n1491         \"\"\"\n1492         Get the initial form data from the request's GET params.\n1493         \"\"\"\n1494         initial = dict(request.GET.items())\n1495         for k in initial:\n1496             try:\n1497                 f = self.model._meta.get_field(k)\n1498             except FieldDoesNotExist:\n1499                 continue\n1500             # We have to special-case M2Ms as a list of comma-separated PKs.\n1501             if isinstance(f, models.ManyToManyField):\n1502                 initial[k] = initial[k].split(\",\")\n1503         return initial\n1504 \n1505     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):\n1506         \"\"\"\n1507         Create a message informing the user that the object doesn't exist\n1508         and return a redirect to the admin index page.\n1509         \"\"\"\n1510         msg = _('%(name)s with ID \u201c%(key)s\u201d doesn\u2019t exist. Perhaps it was deleted?') % {\n1511             'name': opts.verbose_name,\n1512             'key': unquote(object_id),\n1513         }\n1514         self.message_user(request, msg, messages.WARNING)\n1515         url = reverse('admin:index', current_app=self.admin_site.name)\n1516         return HttpResponseRedirect(url)\n1517 \n1518     @csrf_protect_m\n1519     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):\n1520         with transaction.atomic(using=router.db_for_write(self.model)):\n1521             return self._changeform_view(request, object_id, form_url, extra_context)\n1522 \n1523     def _changeform_view(self, request, object_id, form_url, extra_context):\n1524         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1525         if to_field and not self.to_field_allowed(request, to_field):\n1526             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1527 \n1528         model = self.model\n1529         opts = model._meta\n1530 \n1531         if request.method == 'POST' and '_saveasnew' in request.POST:\n1532             object_id = None\n1533 \n1534         add = object_id is None\n1535 \n1536         if add:\n1537             if not self.has_add_permission(request):\n1538                 raise PermissionDenied\n1539             obj = None\n1540 \n1541         else:\n1542             obj = self.get_object(request, unquote(object_id), to_field)\n1543 \n1544             if request.method == 'POST':\n1545                 if not self.has_change_permission(request, obj):\n1546                     raise PermissionDenied\n1547             else:\n1548                 if not self.has_view_or_change_permission(request, obj):\n1549                     raise PermissionDenied\n1550 \n1551             if obj is None:\n1552                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1553 \n1554         fieldsets = self.get_fieldsets(request, obj)\n1555         ModelForm = self.get_form(\n1556             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)\n1557         )\n1558         if request.method == 'POST':\n1559             form = ModelForm(request.POST, request.FILES, instance=obj)\n1560             form_validated = form.is_valid()\n1561             if form_validated:\n1562                 new_object = self.save_form(request, form, change=not add)\n1563             else:\n1564                 new_object = form.instance\n1565             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)\n1566             if all_valid(formsets) and form_validated:\n1567                 self.save_model(request, new_object, form, not add)\n1568                 self.save_related(request, form, formsets, not add)\n1569                 change_message = self.construct_change_message(request, form, formsets, add)\n1570                 if add:\n1571                     self.log_addition(request, new_object, change_message)\n1572                     return self.response_add(request, new_object)\n1573                 else:\n1574                     self.log_change(request, new_object, change_message)\n1575                     return self.response_change(request, new_object)\n1576             else:\n1577                 form_validated = False\n1578         else:\n1579             if add:\n1580                 initial = self.get_changeform_initial_data(request)\n1581                 form = ModelForm(initial=initial)\n1582                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)\n1583             else:\n1584                 form = ModelForm(instance=obj)\n1585                 formsets, inline_instances = self._create_formsets(request, obj, change=True)\n1586 \n1587         if not add and not self.has_change_permission(request, obj):\n1588             readonly_fields = flatten_fieldsets(fieldsets)\n1589         else:\n1590             readonly_fields = self.get_readonly_fields(request, obj)\n1591         adminForm = helpers.AdminForm(\n1592             form,\n1593             list(fieldsets),\n1594             # Clear prepopulated fields on a view-only form to avoid a crash.\n1595             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},\n1596             readonly_fields,\n1597             model_admin=self)\n1598         media = self.media + adminForm.media\n1599 \n1600         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)\n1601         for inline_formset in inline_formsets:\n1602             media = media + inline_formset.media\n1603 \n1604         if add:\n1605             title = _('Add %s')\n1606         elif self.has_change_permission(request, obj):\n1607             title = _('Change %s')\n1608         else:\n1609             title = _('View %s')\n1610         context = {\n1611             **self.admin_site.each_context(request),\n1612             'title': title % opts.verbose_name,\n1613             'adminform': adminForm,\n1614             'object_id': object_id,\n1615             'original': obj,\n1616             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1617             'to_field': to_field,\n1618             'media': media,\n1619             'inline_admin_formsets': inline_formsets,\n1620             'errors': helpers.AdminErrorList(form, formsets),\n1621             'preserved_filters': self.get_preserved_filters(request),\n1622         }\n1623 \n1624         # Hide the \"Save\" and \"Save and continue\" buttons if \"Save as New\" was\n1625         # previously chosen to prevent the interface from getting confusing.\n1626         if request.method == 'POST' and not form_validated and \"_saveasnew\" in request.POST:\n1627             context['show_save'] = False\n1628             context['show_save_and_continue'] = False\n1629             # Use the change template instead of the add template.\n1630             add = False\n1631 \n1632         context.update(extra_context or {})\n1633 \n1634         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)\n1635 \n1636     def autocomplete_view(self, request):\n1637         return AutocompleteJsonView.as_view(model_admin=self)(request)\n1638 \n1639     def add_view(self, request, form_url='', extra_context=None):\n1640         return self.changeform_view(request, None, form_url, extra_context)\n1641 \n1642     def change_view(self, request, object_id, form_url='', extra_context=None):\n1643         return self.changeform_view(request, object_id, form_url, extra_context)\n1644 \n1645     def _get_edited_object_pks(self, request, prefix):\n1646         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n1647         pk_pattern = re.compile(\n1648             r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)\n1649         )\n1650         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n1651 \n1652     def _get_list_editable_queryset(self, request, prefix):\n1653         \"\"\"\n1654         Based on POST data, return a queryset of the objects that were edited\n1655         via list_editable.\n1656         \"\"\"\n1657         object_pks = self._get_edited_object_pks(request, prefix)\n1658         queryset = self.get_queryset(request)\n1659         validate = queryset.model._meta.pk.to_python\n1660         try:\n1661             for pk in object_pks:\n1662                 validate(pk)\n1663         except ValidationError:\n1664             # Disable the optimization if the POST data was tampered with.\n1665             return queryset\n1666         return queryset.filter(pk__in=object_pks)\n1667 \n1668     @csrf_protect_m\n1669     def changelist_view(self, request, extra_context=None):\n1670         \"\"\"\n1671         The 'change list' admin view for this model.\n1672         \"\"\"\n1673         from django.contrib.admin.views.main import ERROR_FLAG\n1674         opts = self.model._meta\n1675         app_label = opts.app_label\n1676         if not self.has_view_or_change_permission(request):\n1677             raise PermissionDenied\n1678 \n1679         try:\n1680             cl = self.get_changelist_instance(request)\n1681         except IncorrectLookupParameters:\n1682             # Wacky lookup parameters were given, so redirect to the main\n1683             # changelist page, without parameters, and pass an 'invalid=1'\n1684             # parameter via the query string. If wacky parameters were given\n1685             # and the 'invalid=1' parameter was already in the query string,\n1686             # something is screwed up with the database, so display an error\n1687             # page.\n1688             if ERROR_FLAG in request.GET:\n1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {\n1690                     'title': _('Database error'),\n1691                 })\n1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')\n1693 \n1694         # If the request was POSTed, this might be a bulk action or a bulk\n1695         # edit. Try to look up an action or confirmation first, but if this\n1696         # isn't an action the POST will fall through to the bulk edit check,\n1697         # below.\n1698         action_failed = False\n1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1700 \n1701         actions = self.get_actions(request)\n1702         # Actions with no confirmation\n1703         if (actions and request.method == 'POST' and\n1704                 'index' in request.POST and '_save' not in request.POST):\n1705             if selected:\n1706                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1707                 if response:\n1708                     return response\n1709                 else:\n1710                     action_failed = True\n1711             else:\n1712                 msg = _(\"Items must be selected in order to perform \"\n1713                         \"actions on them. No items have been changed.\")\n1714                 self.message_user(request, msg, messages.WARNING)\n1715                 action_failed = True\n1716 \n1717         # Actions with confirmation\n1718         if (actions and request.method == 'POST' and\n1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and\n1720                 'index' not in request.POST and '_save' not in request.POST):\n1721             if selected:\n1722                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1723                 if response:\n1724                     return response\n1725                 else:\n1726                     action_failed = True\n1727 \n1728         if action_failed:\n1729             # Redirect back to the changelist page to avoid resubmitting the\n1730             # form if the user refreshes the browser or uses the \"No, take\n1731             # me back\" button on the action confirmation page.\n1732             return HttpResponseRedirect(request.get_full_path())\n1733 \n1734         # If we're allowing changelist editing, we need to construct a formset\n1735         # for the changelist given all the fields to be edited. Then we'll\n1736         # use the formset to validate/process POSTed data.\n1737         formset = cl.formset = None\n1738 \n1739         # Handle POSTed bulk-edit data.\n1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:\n1741             if not self.has_change_permission(request):\n1742                 raise PermissionDenied\n1743             FormSet = self.get_changelist_formset(request)\n1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())\n1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)\n1746             if formset.is_valid():\n1747                 changecount = 0\n1748                 for form in formset.forms:\n1749                     if form.has_changed():\n1750                         obj = self.save_form(request, form, change=True)\n1751                         self.save_model(request, obj, form, change=True)\n1752                         self.save_related(request, form, formsets=[], change=True)\n1753                         change_msg = self.construct_change_message(request, form, None)\n1754                         self.log_change(request, obj, change_msg)\n1755                         changecount += 1\n1756 \n1757                 if changecount:\n1758                     msg = ngettext(\n1759                         \"%(count)s %(name)s was changed successfully.\",\n1760                         \"%(count)s %(name)s were changed successfully.\",\n1761                         changecount\n1762                     ) % {\n1763                         'count': changecount,\n1764                         'name': model_ngettext(opts, changecount),\n1765                     }\n1766                     self.message_user(request, msg, messages.SUCCESS)\n1767 \n1768                 return HttpResponseRedirect(request.get_full_path())\n1769 \n1770         # Handle GET -- construct a formset for display.\n1771         elif cl.list_editable and self.has_change_permission(request):\n1772             FormSet = self.get_changelist_formset(request)\n1773             formset = cl.formset = FormSet(queryset=cl.result_list)\n1774 \n1775         # Build the list of media to be used by the formset.\n1776         if formset:\n1777             media = self.media + formset.media\n1778         else:\n1779             media = self.media\n1780 \n1781         # Build the action form and populate it with available actions.\n1782         if actions:\n1783             action_form = self.action_form(auto_id=None)\n1784             action_form.fields['action'].choices = self.get_action_choices(request)\n1785             media += action_form.media\n1786         else:\n1787             action_form = None\n1788 \n1789         selection_note_all = ngettext(\n1790             '%(total_count)s selected',\n1791             'All %(total_count)s selected',\n1792             cl.result_count\n1793         )\n1794 \n1795         context = {\n1796             **self.admin_site.each_context(request),\n1797             'module_name': str(opts.verbose_name_plural),\n1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},\n1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},\n1800             'title': cl.title,\n1801             'is_popup': cl.is_popup,\n1802             'to_field': cl.to_field,\n1803             'cl': cl,\n1804             'media': media,\n1805             'has_add_permission': self.has_add_permission(request),\n1806             'opts': cl.opts,\n1807             'action_form': action_form,\n1808             'actions_on_top': self.actions_on_top,\n1809             'actions_on_bottom': self.actions_on_bottom,\n1810             'actions_selection_counter': self.actions_selection_counter,\n1811             'preserved_filters': self.get_preserved_filters(request),\n1812             **(extra_context or {}),\n1813         }\n1814 \n1815         request.current_app = self.admin_site.name\n1816 \n1817         return TemplateResponse(request, self.change_list_template or [\n1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),\n1819             'admin/%s/change_list.html' % app_label,\n1820             'admin/change_list.html'\n1821         ], context)\n1822 \n1823     def get_deleted_objects(self, objs, request):\n1824         \"\"\"\n1825         Hook for customizing the delete process for the delete view and the\n1826         \"delete selected\" action.\n1827         \"\"\"\n1828         return get_deleted_objects(objs, request, self.admin_site)\n1829 \n1830     @csrf_protect_m\n1831     def delete_view(self, request, object_id, extra_context=None):\n1832         with transaction.atomic(using=router.db_for_write(self.model)):\n1833             return self._delete_view(request, object_id, extra_context)\n1834 \n1835     def _delete_view(self, request, object_id, extra_context):\n1836         \"The 'delete' admin view for this model.\"\n1837         opts = self.model._meta\n1838         app_label = opts.app_label\n1839 \n1840         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1841         if to_field and not self.to_field_allowed(request, to_field):\n1842             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1843 \n1844         obj = self.get_object(request, unquote(object_id), to_field)\n1845 \n1846         if not self.has_delete_permission(request, obj):\n1847             raise PermissionDenied\n1848 \n1849         if obj is None:\n1850             return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1851 \n1852         # Populate deleted_objects, a data structure of all related objects that\n1853         # will also be deleted.\n1854         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)\n1855 \n1856         if request.POST and not protected:  # The user has confirmed the deletion.\n1857             if perms_needed:\n1858                 raise PermissionDenied\n1859             obj_display = str(obj)\n1860             attr = str(to_field) if to_field else opts.pk.attname\n1861             obj_id = obj.serializable_value(attr)\n1862             self.log_deletion(request, obj, obj_display)\n1863             self.delete_model(request, obj)\n1864 \n1865             return self.response_delete(request, obj_display, obj_id)\n1866 \n1867         object_name = str(opts.verbose_name)\n1868 \n1869         if perms_needed or protected:\n1870             title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n1871         else:\n1872             title = _(\"Are you sure?\")\n1873 \n1874         context = {\n1875             **self.admin_site.each_context(request),\n1876             'title': title,\n1877             'object_name': object_name,\n1878             'object': obj,\n1879             'deleted_objects': deleted_objects,\n1880             'model_count': dict(model_count).items(),\n1881             'perms_lacking': perms_needed,\n1882             'protected': protected,\n1883             'opts': opts,\n1884             'app_label': app_label,\n1885             'preserved_filters': self.get_preserved_filters(request),\n1886             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1887             'to_field': to_field,\n1888             **(extra_context or {}),\n1889         }\n1890 \n1891         return self.render_delete_form(request, context)\n1892 \n1893     def history_view(self, request, object_id, extra_context=None):\n1894         \"The 'history' admin view for this model.\"\n1895         from django.contrib.admin.models import LogEntry\n1896         # First check if the user can see this history.\n1897         model = self.model\n1898         obj = self.get_object(request, unquote(object_id))\n1899         if obj is None:\n1900             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)\n1901 \n1902         if not self.has_view_or_change_permission(request, obj):\n1903             raise PermissionDenied\n1904 \n1905         # Then get the history for this object.\n1906         opts = model._meta\n1907         app_label = opts.app_label\n1908         action_list = LogEntry.objects.filter(\n1909             object_id=unquote(object_id),\n1910             content_type=get_content_type_for_model(model)\n1911         ).select_related().order_by('action_time')\n1912 \n1913         context = {\n1914             **self.admin_site.each_context(request),\n1915             'title': _('Change history: %s') % obj,\n1916             'action_list': action_list,\n1917             'module_name': str(capfirst(opts.verbose_name_plural)),\n1918             'object': obj,\n1919             'opts': opts,\n1920             'preserved_filters': self.get_preserved_filters(request),\n1921             **(extra_context or {}),\n1922         }\n1923 \n1924         request.current_app = self.admin_site.name\n1925 \n1926         return TemplateResponse(request, self.object_history_template or [\n1927             \"admin/%s/%s/object_history.html\" % (app_label, opts.model_name),\n1928             \"admin/%s/object_history.html\" % app_label,\n1929             \"admin/object_history.html\"\n1930         ], context)\n1931 \n1932     def _create_formsets(self, request, obj, change):\n1933         \"Helper function to generate formsets for add/change_view.\"\n1934         formsets = []\n1935         inline_instances = []\n1936         prefixes = {}\n1937         get_formsets_args = [request]\n1938         if change:\n1939             get_formsets_args.append(obj)\n1940         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n1941             prefix = FormSet.get_default_prefix()\n1942             prefixes[prefix] = prefixes.get(prefix, 0) + 1\n1943             if prefixes[prefix] != 1 or not prefix:\n1944                 prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n1945             formset_params = {\n1946                 'instance': obj,\n1947                 'prefix': prefix,\n1948                 'queryset': inline.get_queryset(request),\n1949             }\n1950             if request.method == 'POST':\n1951                 formset_params.update({\n1952                     'data': request.POST.copy(),\n1953                     'files': request.FILES,\n1954                     'save_as_new': '_saveasnew' in request.POST\n1955                 })\n1956             formset = FormSet(**formset_params)\n1957 \n1958             def user_deleted_form(request, obj, formset, index):\n1959                 \"\"\"Return whether or not the user deleted the form.\"\"\"\n1960                 return (\n1961                     inline.has_delete_permission(request, obj) and\n1962                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST\n1963                 )\n1964 \n1965             # Bypass validation of each view-only inline form (since the form's\n1966             # data won't be in request.POST), unless the form was deleted.\n1967             if not inline.has_change_permission(request, obj if change else None):\n1968                 for index, form in enumerate(formset.initial_forms):\n1969                     if user_deleted_form(request, obj, formset, index):\n1970                         continue\n1971                     form._errors = {}\n1972                     form.cleaned_data = form.initial\n1973             formsets.append(formset)\n1974             inline_instances.append(inline)\n1975         return formsets, inline_instances\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]