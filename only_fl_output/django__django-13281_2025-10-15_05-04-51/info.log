2025-10-15 05:04:52.173 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 05:04:55.530 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=557, output_tokens=12, cost=0.005930
2025-10-15 05:05:12.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=737, output_tokens=730, cost=0.029270
2025-10-15 05:05:13.712 | INFO     | registered non reproducing test 0
2025-10-15 05:05:34.405 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1832, output_tokens=923, cost=0.046010
2025-10-15 05:05:35.676 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:05:43.959 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=848, output_tokens=322, cost=0.018140
2025-10-15 05:05:43.966 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:05:46.863 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=676, output_tokens=71, cost=0.008890
2025-10-15 05:05:46.865 | DEBUG    | Extracted a valid json.
2025-10-15 05:05:46.865 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Bar\")",
        "search_class(\"Foo\")",
        "search_code(\"TestCase\")",
        "search_method_in_class(\"copy\", \"Model\")",
        "search_code(\"_state\")",
        "search_code(\"fields_cache\")"
    ],
    "bug_locations": []
}
2025-10-15 05:05:47.272 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 05:05:47.272 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 05:06:05.328 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2356, output_tokens=718, cost=0.045100
2025-10-15 05:06:05.335 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:06:15.555 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3290, output_tokens=406, cost=0.045080
2025-10-15 05:06:15.561 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:06:23.620 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=760, output_tokens=317, cost=0.017110
2025-10-15 05:06:23.621 | DEBUG    | Extracted a valid json.
2025-10-15 05:06:23.621 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/base.py",
            "class": "",
            "method": "",
            "intended_behavior": "The part of the code responsible for handling model instance copying or state management needs to be updated or examined for Django versions >= 2.0. The code should ensure that when a model instance is copied (using Python's standard copy.copy or copy.deepcopy), all relevant state data, including foreign keys (FK) and caching mechanisms (_state and fields_cache), are correctly cloned. This includes the preservation of FK relationships and cache integrity so that changes to a cloned instance do not affect the original instance. This might involve examining or adjusting how _state (especially fields_cache) is copied between instances to ensure behavior consistent with versions < 2.0, thus preserving the expected functionality while also embracing any architectural changes introduced in Django 2.x."
        },
        {
            "file": "django/db/models/fields/related_descriptors.py",
            "class": "",
            "method": "",
            "intended_behavior": "Assess and possibly modify the handling of FK fields in the context of model instance copying. Since FK relationships are a central concern in the reported issue, ensure that any copying or cloning of model instances properly updates FK references in the newly created instance without inadvertently altering the original instance's state. This might require implementing deep copy logic specific to FK fields or enhancing how Django's model layer treats FK fields during any form of instance duplication."
        }
    ]
}
2025-10-15 05:06:23.637 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import inspect
3 import warnings
4 from functools import partialmethod
5 from itertools import chain
6 
7 import django
8 from django.apps import apps
9 from django.conf import settings
10 from django.core import checks
11 from django.core.exceptions import (
12     NON_FIELD_ERRORS, FieldDoesNotExist, FieldError, MultipleObjectsReturned,
13     ObjectDoesNotExist, ValidationError,
14 )
15 from django.db import (
16     DEFAULT_DB_ALIAS, DJANGO_VERSION_PICKLE_KEY, DatabaseError, connection,
17     connections, router, transaction,
18 )
19 from django.db.models import (
20     NOT_PROVIDED, ExpressionWrapper, IntegerField, Max, Value,
21 )
22 from django.db.models.constants import LOOKUP_SEP
23 from django.db.models.constraints import CheckConstraint, UniqueConstraint
24 from django.db.models.deletion import CASCADE, Collector
25 from django.db.models.fields.related import (
26     ForeignObjectRel, OneToOneField, lazy_related_operation, resolve_relation,
27 )
28 from django.db.models.functions import Coalesce
29 from django.db.models.manager import Manager
30 from django.db.models.options import Options
31 from django.db.models.query import F, Q
32 from django.db.models.signals import (
33     class_prepared, post_init, post_save, pre_init, pre_save,
34 )
35 from django.db.models.utils import make_model_tuple
36 from django.utils.encoding import force_str
37 from django.utils.hashable import make_hashable
38 from django.utils.text import capfirst, get_text_list
39 from django.utils.translation import gettext_lazy as _
40 
41 
42 class Deferred:
43     def __repr__(self):
44         return '<Deferred field>'
45 
46     def __str__(self):
47         return '<Deferred field>'
48 
49 
50 DEFERRED = Deferred()
51 
52 
53 def subclass_exception(name, bases, module, attached_to):
54     """
55     Create exception subclass. Used by ModelBase below.
56 
57     The exception is created in a way that allows it to be pickled, assuming
58     that the returned exception class will be added as an attribute to the
59     'attached_to' class.
60     """
61     return type(name, bases, {
62         '__module__': module,
63         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
64     })
65 
66 
67 def _has_contribute_to_class(value):
68     # Only call contribute_to_class() if it's bound.
69     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
70 
71 
72 class ModelBase(type):
73     """Metaclass for all models."""
74     def __new__(cls, name, bases, attrs, **kwargs):
75         super_new = super().__new__
76 
77         # Also ensure initialization is only performed for subclasses of Model
78         # (excluding Model class itself).
79         parents = [b for b in bases if isinstance(b, ModelBase)]
80         if not parents:
81             return super_new(cls, name, bases, attrs)
82 
83         # Create the class.
84         module = attrs.pop('__module__')
85         new_attrs = {'__module__': module}
86         classcell = attrs.pop('__classcell__', None)
87         if classcell is not None:
88             new_attrs['__classcell__'] = classcell
89         attr_meta = attrs.pop('Meta', None)
90         # Pass all attrs without a (Django-specific) contribute_to_class()
91         # method to type.__new__() so that they're properly initialized
92         # (i.e. __set_name__()).
93         contributable_attrs = {}
94         for obj_name, obj in attrs.items():
95             if _has_contribute_to_class(obj):
96                 contributable_attrs[obj_name] = obj
97             else:
98                 new_attrs[obj_name] = obj
99         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
100 
101         abstract = getattr(attr_meta, 'abstract', False)
102         meta = attr_meta or getattr(new_class, 'Meta', None)
103         base_meta = getattr(new_class, '_meta', None)
104 
105         app_label = None
106 
107         # Look for an application configuration to attach the model to.
108         app_config = apps.get_containing_app_config(module)
109 
110         if getattr(meta, 'app_label', None) is None:
111             if app_config is None:
112                 if not abstract:
113                     raise RuntimeError(
114                         "Model class %s.%s doesn't declare an explicit "
115                         "app_label and isn't in an application in "
116                         "INSTALLED_APPS." % (module, name)
117                     )
118 
119             else:
120                 app_label = app_config.label
121 
122         new_class.add_to_class('_meta', Options(meta, app_label))
123         if not abstract:
124             new_class.add_to_class(
125                 'DoesNotExist',
126                 subclass_exception(
127                     'DoesNotExist',
128                     tuple(
129                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
130                     ) or (ObjectDoesNotExist,),
131                     module,
132                     attached_to=new_class))
133             new_class.add_to_class(
134                 'MultipleObjectsReturned',
135                 subclass_exception(
136                     'MultipleObjectsReturned',
137                     tuple(
138                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
139                     ) or (MultipleObjectsReturned,),
140                     module,
141                     attached_to=new_class))
142             if base_meta and not base_meta.abstract:
143                 # Non-abstract child classes inherit some attributes from their
144                 # non-abstract parent (unless an ABC comes before it in the
145                 # method resolution order).
146                 if not hasattr(meta, 'ordering'):
147                     new_class._meta.ordering = base_meta.ordering
148                 if not hasattr(meta, 'get_latest_by'):
149                     new_class._meta.get_latest_by = base_meta.get_latest_by
150 
151         is_proxy = new_class._meta.proxy
152 
153         # If the model is a proxy, ensure that the base class
154         # hasn't been swapped out.
155         if is_proxy and base_meta and base_meta.swapped:
156             raise TypeError("%s cannot proxy the swapped model '%s'." % (name, base_meta.swapped))
157 
158         # Add remaining attributes (those with a contribute_to_class() method)
159         # to the class.
160         for obj_name, obj in contributable_attrs.items():
161             new_class.add_to_class(obj_name, obj)
162 
163         # All the fields of any type declared on this model
164         new_fields = chain(
165             new_class._meta.local_fields,
166             new_class._meta.local_many_to_many,
167             new_class._meta.private_fields
168         )
169         field_names = {f.name for f in new_fields}
170 
171         # Basic setup for proxy models.
172         if is_proxy:
173             base = None
174             for parent in [kls for kls in parents if hasattr(kls, '_meta')]:
175                 if parent._meta.abstract:
176                     if parent._meta.fields:
177                         raise TypeError(
178                             "Abstract base class containing model fields not "
179                             "permitted for proxy model '%s'." % name
180                         )
181                     else:
182                         continue
183                 if base is None:
184                     base = parent
185                 elif parent._meta.concrete_model is not base._meta.concrete_model:
186                     raise TypeError("Proxy model '%s' has more than one non-abstract model base class." % name)
187             if base is None:
188                 raise TypeError("Proxy model '%s' has no non-abstract model base class." % name)
189             new_class._meta.setup_proxy(base)
190             new_class._meta.concrete_model = base._meta.concrete_model
191         else:
192             new_class._meta.concrete_model = new_class
193 
194         # Collect the parent links for multi-table inheritance.
195         parent_links = {}
196         for base in reversed([new_class] + parents):
197             # Conceptually equivalent to `if base is Model`.
198             if not hasattr(base, '_meta'):
199                 continue
200             # Skip concrete parent classes.
201             if base != new_class and not base._meta.abstract:
202                 continue
203             # Locate OneToOneField instances.
204             for field in base._meta.local_fields:
205                 if isinstance(field, OneToOneField) and field.remote_field.parent_link:
206                     related = resolve_relation(new_class, field.remote_field.model)
207                     parent_links[make_model_tuple(related)] = field
208 
209         # Track fields inherited from base models.
210         inherited_attributes = set()
211         # Do the appropriate setup for any model parents.
212         for base in new_class.mro():
213             if base not in parents or not hasattr(base, '_meta'):
214                 # Things without _meta aren't functional models, so they're
215                 # uninteresting parents.
216                 inherited_attributes.update(base.__dict__)
217                 continue
218 
219             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
220             if not base._meta.abstract:
221                 # Check for clashes between locally declared fields and those
222                 # on the base classes.
223                 for field in parent_fields:
224                     if field.name in field_names:
225                         raise FieldError(
226                             'Local field %r in class %r clashes with field of '
227                             'the same name from base class %r.' % (
228                                 field.name,
229                                 name,
230                                 base.__name__,
231                             )
232                         )
233                     else:
234                         inherited_attributes.add(field.name)
235 
236                 # Concrete classes...
237                 base = base._meta.concrete_model
238                 base_key = make_model_tuple(base)
239                 if base_key in parent_links:
240                     field = parent_links[base_key]
241                 elif not is_proxy:
242                     attr_name = '%s_ptr' % base._meta.model_name
243                     field = OneToOneField(
244                         base,
245                         on_delete=CASCADE,
246                         name=attr_name,
247                         auto_created=True,
248                         parent_link=True,
249                     )
250 
251                     if attr_name in field_names:
252                         raise FieldError(
253                             "Auto-generated field '%s' in class %r for "
254                             "parent_link to base class %r clashes with "
255                             "declared field of the same name." % (
256                                 attr_name,
257                                 name,
258                                 base.__name__,
259                             )
260                         )
261 
262                     # Only add the ptr field if it's not already present;
263                     # e.g. migrations will already have it specified
264                     if not hasattr(new_class, attr_name):
265                         new_class.add_to_class(attr_name, field)
266                 else:
267                     field = None
268                 new_class._meta.parents[base] = field
269             else:
270                 base_parents = base._meta.parents.copy()
271 
272                 # Add fields from abstract base class if it wasn't overridden.
273                 for field in parent_fields:
274                     if (field.name not in field_names and
275                             field.name not in new_class.__dict__ and
276                             field.name not in inherited_attributes):
277                         new_field = copy.deepcopy(field)
278                         new_class.add_to_class(field.name, new_field)
279                         # Replace parent links defined on this base by the new
280                         # field. It will be appropriately resolved if required.
281                         if field.one_to_one:
282                             for parent, parent_link in base_parents.items():
283                                 if field == parent_link:
284                                     base_parents[parent] = new_field
285 
286                 # Pass any non-abstract parent classes onto child.
287                 new_class._meta.parents.update(base_parents)
288 
289             # Inherit private fields (like GenericForeignKey) from the parent
290             # class
291             for field in base._meta.private_fields:
292                 if field.name in field_names:
293                     if not base._meta.abstract:
294                         raise FieldError(
295                             'Local field %r in class %r clashes with field of '
296                             'the same name from base class %r.' % (
297                                 field.name,
298                                 name,
299                                 base.__name__,
300                             )
301                         )
302                 else:
303                     field = copy.deepcopy(field)
304                     if not base._meta.abstract:
305                         field.mti_inherited = True
306                     new_class.add_to_class(field.name, field)
307 
308         # Copy indexes so that index names are unique when models extend an
309         # abstract model.
310         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
311 
312         if abstract:
313             # Abstract base models can't be instantiated and don't appear in
314             # the list of models for an app. We do the final setup for them a
315             # little differently from normal models.
316             attr_meta.abstract = False
317             new_class.Meta = attr_meta
318             return new_class
319 
320         new_class._prepare()
321         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
322         return new_class
323 
324     def add_to_class(cls, name, value):
325         if _has_contribute_to_class(value):
326             value.contribute_to_class(cls, name)
327         else:
328             setattr(cls, name, value)
329 
330     def _prepare(cls):
331         """Create some methods once self._meta has been populated."""
332         opts = cls._meta
333         opts._prepare(cls)
334 
335         if opts.order_with_respect_to:
336             cls.get_next_in_order = partialmethod(cls._get_next_or_previous_in_order, is_next=True)
337             cls.get_previous_in_order = partialmethod(cls._get_next_or_previous_in_order, is_next=False)
338 
339             # Defer creating accessors on the foreign class until it has been
340             # created and registered. If remote_field is None, we're ordering
341             # with respect to a GenericForeignKey and don't know what the
342             # foreign class is - we'll add those accessors later in
343             # contribute_to_class().
344             if opts.order_with_respect_to.remote_field:
345                 wrt = opts.order_with_respect_to
346                 remote = wrt.remote_field.model
347                 lazy_related_operation(make_foreign_order_accessors, cls, remote)
348 
349         # Give the class a docstring -- its definition.
350         if cls.__doc__ is None:
351             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
352 
353         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
354         if get_absolute_url_override:
355             setattr(cls, 'get_absolute_url', get_absolute_url_override)
356 
357         if not opts.managers:
358             if any(f.name == 'objects' for f in opts.fields):
359                 raise ValueError(
360                     "Model %s must specify a custom Manager, because it has a "
361                     "field named 'objects'." % cls.__name__
362                 )
363             manager = Manager()
364             manager.auto_created = True
365             cls.add_to_class('objects', manager)
366 
367         # Set the name of _meta.indexes. This can't be done in
368         # Options.contribute_to_class() because fields haven't been added to
369         # the model at that point.
370         for index in cls._meta.indexes:
371             if not index.name:
372                 index.set_name_with_model(cls)
373 
374         class_prepared.send(sender=cls)
375 
376     @property
377     def _base_manager(cls):
378         return cls._meta.base_manager
379 
380     @property
381     def _default_manager(cls):
382         return cls._meta.default_manager
383 
384 
385 class ModelStateFieldsCacheDescriptor:
386     def __get__(self, instance, cls=None):
387         if instance is None:
388             return self
389         res = instance.fields_cache = {}
390         return res
391 
392 
393 class ModelState:
394     """Store model instance state."""
395     db = None
396     # If true, uniqueness validation checks will consider this a new, unsaved
397     # object. Necessary for correct validation of new instances of objects with
398     # explicit (non-auto) PKs. This impacts validation only; it has no effect
399     # on the actual save.
400     adding = True
401     fields_cache = ModelStateFieldsCacheDescriptor()
402 
403 
404 class Model(metaclass=ModelBase):
405 
406     def __init__(self, *args, **kwargs):
407         # Alias some things as locals to avoid repeat global lookups
408         cls = self.__class__
409         opts = self._meta
410         _setattr = setattr
411         _DEFERRED = DEFERRED
412         if opts.abstract:
413             raise TypeError('Abstract models cannot be instantiated.')
414 
415         pre_init.send(sender=cls, args=args, kwargs=kwargs)
416 
417         # Set up the storage for instance state
418         self._state = ModelState()
419 
420         # There is a rather weird disparity here; if kwargs, it's set, then args
421         # overrides it. It should be one or the other; don't duplicate the work
422         # The reason for the kwargs check is that standard iterator passes in by
423         # args, and instantiation for iteration is 33% faster.
424         if len(args) > len(opts.concrete_fields):
425             # Daft, but matches old exception sans the err msg.
426             raise IndexError("Number of args exceeds number of fields")
427 
428         if not kwargs:
429             fields_iter = iter(opts.concrete_fields)
430             # The ordering of the zip calls matter - zip throws StopIteration
431             # when an iter throws it. So if the first iter throws it, the second
432             # is *not* consumed. We rely on this, so don't change the order
433             # without changing the logic.
434             for val, field in zip(args, fields_iter):
435                 if val is _DEFERRED:
436                     continue
437                 _setattr(self, field.attname, val)
438         else:
439             # Slower, kwargs-ready version.
440             fields_iter = iter(opts.fields)
441             for val, field in zip(args, fields_iter):
442                 if val is _DEFERRED:
443                     continue
444                 _setattr(self, field.attname, val)
445                 kwargs.pop(field.name, None)
446 
447         # Now we're left with the unprocessed fields that *must* come from
448         # keywords, or default.
449 
450         for field in fields_iter:
451             is_related_object = False
452             # Virtual field
453             if field.attname not in kwargs and field.column is None:
454                 continue
455             if kwargs:
456                 if isinstance(field.remote_field, ForeignObjectRel):
457                     try:
458                         # Assume object instance was passed in.
459                         rel_obj = kwargs.pop(field.name)
460                         is_related_object = True
461                     except KeyError:
462                         try:
463                             # Object instance wasn't passed in -- must be an ID.
464                             val = kwargs.pop(field.attname)
465                         except KeyError:
466                             val = field.get_default()
467                 else:
468                     try:
469                         val = kwargs.pop(field.attname)
470                     except KeyError:
471                         # This is done with an exception rather than the
472                         # default argument on pop because we don't want
473                         # get_default() to be evaluated, and then not used.
474                         # Refs #12057.
475                         val = field.get_default()
476             else:
477                 val = field.get_default()
478 
479             if is_related_object:
480                 # If we are passed a related instance, set it using the
481                 # field.name instead of field.attname (e.g. "user" instead of
482                 # "user_id") so that the object gets properly cached (and type
483                 # checked) by the RelatedObjectDescriptor.
484                 if rel_obj is not _DEFERRED:
485                     _setattr(self, field.name, rel_obj)
486             else:
487                 if val is not _DEFERRED:
488                     _setattr(self, field.attname, val)
489 
490         if kwargs:
491             property_names = opts._property_names
492             for prop in tuple(kwargs):
493                 try:
494                     # Any remaining kwargs must correspond to properties or
495                     # virtual fields.
496                     if prop in property_names or opts.get_field(prop):
497                         if kwargs[prop] is not _DEFERRED:
498                             _setattr(self, prop, kwargs[prop])
499                         del kwargs[prop]
500                 except (AttributeError, FieldDoesNotExist):
501                     pass
502             for kwarg in kwargs:
503                 raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
504         super().__init__()
505         post_init.send(sender=cls, instance=self)
506 
507     @classmethod
508     def from_db(cls, db, field_names, values):
509         if len(values) != len(cls._meta.concrete_fields):
510             values_iter = iter(values)
511             values = [
512                 next(values_iter) if f.attname in field_names else DEFERRED
513                 for f in cls._meta.concrete_fields
514             ]
515         new = cls(*values)
516         new._state.adding = False
517         new._state.db = db
518         return new
519 
520     def __repr__(self):
521         return '<%s: %s>' % (self.__class__.__name__, self)
522 
523     def __str__(self):
524         return '%s object (%s)' % (self.__class__.__name__, self.pk)
525 
526     def __eq__(self, other):
527         if not isinstance(other, Model):
528             return NotImplemented
529         if self._meta.concrete_model != other._meta.concrete_model:
530             return False
531         my_pk = self.pk
532         if my_pk is None:
533             return self is other
534         return my_pk == other.pk
535 
536     def __hash__(self):
537         if self.pk is None:
538             raise TypeError("Model instances without primary key value are unhashable")
539         return hash(self.pk)
540 
541     def __reduce__(self):
542         data = self.__getstate__()
543         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
544         class_id = self._meta.app_label, self._meta.object_name
545         return model_unpickle, (class_id,), data
546 
547     def __getstate__(self):
548         """Hook to allow choosing the attributes to pickle."""
549         return self.__dict__
550 
551     def __setstate__(self, state):
552         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
553         if pickled_version:
554             if pickled_version != django.__version__:
555                 warnings.warn(
556                     "Pickled model instance's Django version %s does not "
557                     "match the current version %s."
558                     % (pickled_version, django.__version__),
559                     RuntimeWarning,
560                     stacklevel=2,
561                 )
562         else:
563             warnings.warn(
564                 "Pickled model instance's Django version is not specified.",
565                 RuntimeWarning,
566                 stacklevel=2,
567             )
568         self.__dict__.update(state)
569 
570     def _get_pk_val(self, meta=None):
571         meta = meta or self._meta
572         return getattr(self, meta.pk.attname)
573 
574     def _set_pk_val(self, value):
575         for parent_link in self._meta.parents.values():
576             if parent_link and parent_link != self._meta.pk:
577                 setattr(self, parent_link.target_field.attname, value)
578         return setattr(self, self._meta.pk.attname, value)
579 
580     pk = property(_get_pk_val, _set_pk_val)
581 
582     def get_deferred_fields(self):
583         """
584         Return a set containing names of deferred fields for this instance.
585         """
586         return {
587             f.attname for f in self._meta.concrete_fields
588             if f.attname not in self.__dict__
589         }
590 
591     def refresh_from_db(self, using=None, fields=None):
592         """
593         Reload field values from the database.
594 
595         By default, the reloading happens from the database this instance was
596         loaded from, or by the read router if this instance wasn't loaded from
597         any database. The using parameter will override the default.
598 
599         Fields can be used to specify which fields to reload. The fields
600         should be an iterable of field attnames. If fields is None, then
601         all non-deferred fields are reloaded.
602 
603         When accessing deferred fields of an instance, the deferred loading
604         of the field will call this method.
605         """
606         if fields is None:
607             self._prefetched_objects_cache = {}
608         else:
609             prefetched_objects_cache = getattr(self, '_prefetched_objects_cache', ())
610             for field in fields:
611                 if field in prefetched_objects_cache:
612                     del prefetched_objects_cache[field]
613                     fields.remove(field)
614             if not fields:
615                 return
616             if any(LOOKUP_SEP in f for f in fields):
617                 raise ValueError(
618                     'Found "%s" in fields argument. Relations and transforms '
619                     'are not allowed in fields.' % LOOKUP_SEP)
620 
621         hints = {'instance': self}
622         db_instance_qs = self.__class__._base_manager.db_manager(using, hints=hints).filter(pk=self.pk)
623 
624         # Use provided fields, if not set then reload all non-deferred fields.
625         deferred_fields = self.get_deferred_fields()
626         if fields is not None:
627             fields = list(fields)
628             db_instance_qs = db_instance_qs.only(*fields)
629         elif deferred_fields:
630             fields = [f.attname for f in self._meta.concrete_fields
631                       if f.attname not in deferred_fields]
632             db_instance_qs = db_instance_qs.only(*fields)
633 
634         db_instance = db_instance_qs.get()
635         non_loaded_fields = db_instance.get_deferred_fields()
636         for field in self._meta.concrete_fields:
637             if field.attname in non_loaded_fields:
638                 # This field wasn't refreshed - skip ahead.
639                 continue
640             setattr(self, field.attname, getattr(db_instance, field.attname))
641             # Clear cached foreign keys.
642             if field.is_relation and field.is_cached(self):
643                 field.delete_cached_value(self)
644 
645         # Clear cached relations.
646         for field in self._meta.related_objects:
647             if field.is_cached(self):
648                 field.delete_cached_value(self)
649 
650         self._state.db = db_instance._state.db
651 
652     def serializable_value(self, field_name):
653         """
654         Return the value of the field name for this instance. If the field is
655         a foreign key, return the id value instead of the object. If there's
656         no Field object with this name on the model, return the model
657         attribute's value.
658 
659         Used to serialize a field's value (in the serializer, or form output,
660         for example). Normally, you would just access the attribute directly
661         and not use this method.
662         """
663         try:
664             field = self._meta.get_field(field_name)
665         except FieldDoesNotExist:
666             return getattr(self, field_name)
667         return getattr(self, field.attname)
668 
669     def save(self, force_insert=False, force_update=False, using=None,
670              update_fields=None):
671         """
672         Save the current instance. Override this in a subclass if you want to
673         control the saving process.
674 
675         The 'force_insert' and 'force_update' parameters can be used to insist
676         that the "save" must be an SQL insert or update (or equivalent for
677         non-SQL backends), respectively. Normally, they should not be set.
678         """
679         # Ensure that a model instance without a PK hasn't been assigned to
680         # a ForeignKey or OneToOneField on this model. If the field is
681         # nullable, allowing the save() would result in silent data loss.
682         for field in self._meta.concrete_fields:
683             # If the related field isn't cached, then an instance hasn't
684             # been assigned and there's no need to worry about this check.
685             if field.is_relation and field.is_cached(self):
686                 obj = getattr(self, field.name, None)
687                 if not obj:
688                     continue
689                 # A pk may have been assigned manually to a model instance not
690                 # saved to the database (or auto-generated in a case like
691                 # UUIDField), but we allow the save to proceed and rely on the
692                 # database to raise an IntegrityError if applicable. If
693                 # constraints aren't supported by the database, there's the
694                 # unavoidable risk of data corruption.
695                 if obj.pk is None:
696                     # Remove the object from a related instance cache.
697                     if not field.remote_field.multiple:
698                         field.remote_field.delete_cached_value(obj)
699                     raise ValueError(
700                         "save() prohibited to prevent data loss due to "
701                         "unsaved related object '%s'." % field.name
702                     )
703                 elif getattr(self, field.attname) is None:
704                     # Use pk from related object if it has been saved after
705                     # an assignment.
706                     setattr(self, field.attname, obj.pk)
707                 # If the relationship's pk/to_field was changed, clear the
708                 # cached relationship.
709                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):
710                     field.delete_cached_value(self)
711 
712         using = using or router.db_for_write(self.__class__, instance=self)
713         if force_insert and (force_update or update_fields):
714             raise ValueError("Cannot force both insert and updating in model saving.")
715 
716         deferred_fields = self.get_deferred_fields()
717         if update_fields is not None:
718             # If update_fields is empty, skip the save. We do also check for
719             # no-op saves later on for inheritance cases. This bailout is
720             # still needed for skipping signal sending.
721             if not update_fields:
722                 return
723 
724             update_fields = frozenset(update_fields)
725             field_names = set()
726 
727             for field in self._meta.fields:
728                 if not field.primary_key:
729                     field_names.add(field.name)
730 
731                     if field.name != field.attname:
732                         field_names.add(field.attname)
733 
734             non_model_fields = update_fields.difference(field_names)
735 
736             if non_model_fields:
737                 raise ValueError("The following fields do not exist in this "
738                                  "model or are m2m fields: %s"
739                                  % ', '.join(non_model_fields))
740 
741         # If saving to the same database, and this model is deferred, then
742         # automatically do an "update_fields" save on the loaded fields.
743         elif not force_insert and deferred_fields and using == self._state.db:
744             field_names = set()
745             for field in self._meta.concrete_fields:
746                 if not field.primary_key and not hasattr(field, 'through'):
747                     field_names.add(field.attname)
748             loaded_fields = field_names.difference(deferred_fields)
749             if loaded_fields:
750                 update_fields = frozenset(loaded_fields)
751 
752         self.save_base(using=using, force_insert=force_insert,
753                        force_update=force_update, update_fields=update_fields)
754     save.alters_data = True
755 
756     def save_base(self, raw=False, force_insert=False,
757                   force_update=False, using=None, update_fields=None):
758         """
759         Handle the parts of saving which should be done only once per save,
760         yet need to be done in raw saves, too. This includes some sanity
761         checks and signal sending.
762 
763         The 'raw' argument is telling save_base not to save any parent
764         models and not to do any changes to the values before save. This
765         is used by fixture loading.
766         """
767         using = using or router.db_for_write(self.__class__, instance=self)
768         assert not (force_insert and (force_update or update_fields))
769         assert update_fields is None or update_fields
770         cls = origin = self.__class__
771         # Skip proxies, but keep the origin as the proxy model.
772         if cls._meta.proxy:
773             cls = cls._meta.concrete_model
774         meta = cls._meta
775         if not meta.auto_created:
776             pre_save.send(
777                 sender=origin, instance=self, raw=raw, using=using,
778                 update_fields=update_fields,
779             )
780         # A transaction isn't needed if one query is issued.
781         if meta.parents:
782             context_manager = transaction.atomic(using=using, savepoint=False)
783         else:
784             context_manager = transaction.mark_for_rollback_on_error(using=using)
785         with context_manager:
786             parent_inserted = False
787             if not raw:
788                 parent_inserted = self._save_parents(cls, using, update_fields)
789             updated = self._save_table(
790                 raw, cls, force_insert or parent_inserted,
791                 force_update, using, update_fields,
792             )
793         # Store the database on which the object was saved
794         self._state.db = using
795         # Once saved, this is no longer a to-be-added instance.
796         self._state.adding = False
797 
798         # Signal that the save is complete
799         if not meta.auto_created:
800             post_save.send(
801                 sender=origin, instance=self, created=(not updated),
802                 update_fields=update_fields, raw=raw, using=using,
803             )
804 
805     save_base.alters_data = True
806 
807     def _save_parents(self, cls, using, update_fields):
808         """Save all the parents of cls using values from self."""
809         meta = cls._meta
810         inserted = False
811         for parent, field in meta.parents.items():
812             # Make sure the link fields are synced between parent and self.
813             if (field and getattr(self, parent._meta.pk.attname) is None and
814                     getattr(self, field.attname) is not None):
815                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
816             parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)
817             updated = self._save_table(
818                 cls=parent, using=using, update_fields=update_fields,
819                 force_insert=parent_inserted,
820             )
821             if not updated:
822                 inserted = True
823             # Set the parent's PK value to self.
824             if field:
825                 setattr(self, field.attname, self._get_pk_val(parent._meta))
826                 # Since we didn't have an instance of the parent handy set
827                 # attname directly, bypassing the descriptor. Invalidate
828                 # the related object cache, in case it's been accidentally
829                 # populated. A fresh instance will be re-built from the
830                 # database if necessary.
831                 if field.is_cached(self):
832                     field.delete_cached_value(self)
833         return inserted
834 
835     def _save_table(self, raw=False, cls=None, force_insert=False,
836                     force_update=False, using=None, update_fields=None):
837         """
838         Do the heavy-lifting involved in saving. Update or insert the data
839         for a single table.
840         """
841         meta = cls._meta
842         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
843 
844         if update_fields:
845             non_pks = [f for f in non_pks
846                        if f.name in update_fields or f.attname in update_fields]
847 
848         pk_val = self._get_pk_val(meta)
849         if pk_val is None:
850             pk_val = meta.pk.get_pk_value_on_save(self)
851             setattr(self, meta.pk.attname, pk_val)
852         pk_set = pk_val is not None
853         if not pk_set and (force_update or update_fields):
854             raise ValueError("Cannot force an update in save() with no primary key.")
855         updated = False
856         # Skip an UPDATE when adding an instance and primary key has a default.
857         if (
858             not raw and
859             not force_insert and
860             self._state.adding and
861             meta.pk.default and
862             meta.pk.default is not NOT_PROVIDED
863         ):
864             force_insert = True
865         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
866         if pk_set and not force_insert:
867             base_qs = cls._base_manager.using(using)
868             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
869                       for f in non_pks]
870             forced_update = update_fields or force_update
871             updated = self._do_update(base_qs, using, pk_val, values, update_fields,
872                                       forced_update)
873             if force_update and not updated:
874                 raise DatabaseError("Forced update did not affect any rows.")
875             if update_fields and not updated:
876                 raise DatabaseError("Save with update_fields did not affect any rows.")
877         if not updated:
878             if meta.order_with_respect_to:
879                 # If this is a model with an order_with_respect_to
880                 # autopopulate the _order field
881                 field = meta.order_with_respect_to
882                 filter_args = field.get_filter_kwargs_for_object(self)
883                 self._order = cls._base_manager.using(using).filter(**filter_args).aggregate(
884                     _order__max=Coalesce(
885                         ExpressionWrapper(Max('_order') + Value(1), output_field=IntegerField()),
886                         Value(0),
887                     ),
888                 )['_order__max']
889             fields = meta.local_concrete_fields
890             if not pk_set:
891                 fields = [f for f in fields if f is not meta.auto_field]
892 
893             returning_fields = meta.db_returning_fields
894             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
895             if results:
896                 for value, field in zip(results[0], returning_fields):
897                     setattr(self, field.attname, value)
898         return updated
899 
900     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
901         """
902         Try to update the model. Return True if the model was updated (if an
903         update query was done and a matching row was found in the DB).
904         """
905         filtered = base_qs.filter(pk=pk_val)
906         if not values:
907             # We can end up here when saving a model in inheritance chain where
908             # update_fields doesn't target any field in current model. In that
909             # case we just say the update succeeded. Another case ending up here
910             # is a model with just PK - in that case check that the PK still
911             # exists.
912             return update_fields is not None or filtered.exists()
913         if self._meta.select_on_save and not forced_update:
914             return (
915                 filtered.exists() and
916                 # It may happen that the object is deleted from the DB right after
917                 # this check, causing the subsequent UPDATE to return zero matching
918                 # rows. The same result can occur in some rare cases when the
919                 # database returns zero despite the UPDATE being executed
920                 # successfully (a row is matched and updated). In order to
921                 # distinguish these two cases, the object's existence in the
922                 # database is again checked for if the UPDATE query returns 0.
923                 (filtered._update(values) > 0 or filtered.exists())
924             )
925         return filtered._update(values) > 0
926 
927     def _do_insert(self, manager, using, fields, returning_fields, raw):
928         """
929         Do an INSERT. If returning_fields is defined then this method should
930         return the newly created data for the model.
931         """
932         return manager._insert(
933             [self], fields=fields, returning_fields=returning_fields,
934             using=using, raw=raw,
935         )
936 
937     def delete(self, using=None, keep_parents=False):
938         using = using or router.db_for_write(self.__class__, instance=self)
939         assert self.pk is not None, (
940             "%s object can't be deleted because its %s attribute is set to None." %
941             (self._meta.object_name, self._meta.pk.attname)
942         )
943 
944         collector = Collector(using=using)
945         collector.collect([self], keep_parents=keep_parents)
946         return collector.delete()
947 
948     delete.alters_data = True
949 
950     def _get_FIELD_display(self, field):
951         value = getattr(self, field.attname)
952         choices_dict = dict(make_hashable(field.flatchoices))
953         # force_str() to coerce lazy strings.
954         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)
955 
956     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
957         if not self.pk:
958             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
959         op = 'gt' if is_next else 'lt'
960         order = '' if is_next else '-'
961         param = getattr(self, field.attname)
962         q = Q(**{'%s__%s' % (field.name, op): param})
963         q = q | Q(**{field.name: param, 'pk__%s' % op: self.pk})
964         qs = self.__class__._default_manager.using(self._state.db).filter(**kwargs).filter(q).order_by(
965             '%s%s' % (order, field.name), '%spk' % order
966         )
967         try:
968             return qs[0]
969         except IndexError:
970             raise self.DoesNotExist("%s matching query does not exist." % self.__class__._meta.object_name)
971 
972     def _get_next_or_previous_in_order(self, is_next):
973         cachename = "__%s_order_cache" % is_next
974         if not hasattr(self, cachename):
975             op = 'gt' if is_next else 'lt'
976             order = '_order' if is_next else '-_order'
977             order_field = self._meta.order_with_respect_to
978             filter_args = order_field.get_filter_kwargs_for_object(self)
979             obj = self.__class__._default_manager.filter(**filter_args).filter(**{
980                 '_order__%s' % op: self.__class__._default_manager.values('_order').filter(**{
981                     self._meta.pk.name: self.pk
982                 })
983             }).order_by(order)[:1].get()
984             setattr(self, cachename, obj)
985         return getattr(self, cachename)
986 
987     def prepare_database_save(self, field):
988         if self.pk is None:
989             raise ValueError("Unsaved model instance %r cannot be used in an ORM query." % self)
990         return getattr(self, field.remote_field.get_related_field().attname)
991 
992     def clean(self):
993         """
994         Hook for doing any extra model-wide validation after clean() has been
995         called on every field by self.clean_fields. Any ValidationError raised
996         by this method will not be associated with a particular field; it will
997         have a special-case association with the field defined by NON_FIELD_ERRORS.
998         """
999         pass
1000 
1001     def validate_unique(self, exclude=None):
1002         """
1003         Check unique constraints on the model and raise ValidationError if any
1004         failed.
1005         """
1006         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1007 
1008         errors = self._perform_unique_checks(unique_checks)
1009         date_errors = self._perform_date_checks(date_checks)
1010 
1011         for k, v in date_errors.items():
1012             errors.setdefault(k, []).extend(v)
1013 
1014         if errors:
1015             raise ValidationError(errors)
1016 
1017     def _get_unique_checks(self, exclude=None):
1018         """
1019         Return a list of checks to perform. Since validate_unique() could be
1020         called from a ModelForm, some fields may have been excluded; we can't
1021         perform a unique check on a model that is missing fields involved
1022         in that check. Fields that did not validate should also be excluded,
1023         but they need to be passed in via the exclude argument.
1024         """
1025         if exclude is None:
1026             exclude = []
1027         unique_checks = []
1028 
1029         unique_togethers = [(self.__class__, self._meta.unique_together)]
1030         constraints = [(self.__class__, self._meta.total_unique_constraints)]
1031         for parent_class in self._meta.get_parent_list():
1032             if parent_class._meta.unique_together:
1033                 unique_togethers.append((parent_class, parent_class._meta.unique_together))
1034             if parent_class._meta.total_unique_constraints:
1035                 constraints.append(
1036                     (parent_class, parent_class._meta.total_unique_constraints)
1037                 )
1038 
1039         for model_class, unique_together in unique_togethers:
1040             for check in unique_together:
1041                 if not any(name in exclude for name in check):
1042                     # Add the check if the field isn't excluded.
1043                     unique_checks.append((model_class, tuple(check)))
1044 
1045         for model_class, model_constraints in constraints:
1046             for constraint in model_constraints:
1047                 if not any(name in exclude for name in constraint.fields):
1048                     unique_checks.append((model_class, constraint.fields))
1049 
1050         # These are checks for the unique_for_<date/year/month>.
1051         date_checks = []
1052 
1053         # Gather a list of checks for fields declared as unique and add them to
1054         # the list of checks.
1055 
1056         fields_with_class = [(self.__class__, self._meta.local_fields)]
1057         for parent_class in self._meta.get_parent_list():
1058             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1059 
1060         for model_class, fields in fields_with_class:
1061             for f in fields:
1062                 name = f.name
1063                 if name in exclude:
1064                     continue
1065                 if f.unique:
1066                     unique_checks.append((model_class, (name,)))
1067                 if f.unique_for_date and f.unique_for_date not in exclude:
1068                     date_checks.append((model_class, 'date', name, f.unique_for_date))
1069                 if f.unique_for_year and f.unique_for_year not in exclude:
1070                     date_checks.append((model_class, 'year', name, f.unique_for_year))
1071                 if f.unique_for_month and f.unique_for_month not in exclude:
1072                     date_checks.append((model_class, 'month', name, f.unique_for_month))
1073         return unique_checks, date_checks
1074 
1075     def _perform_unique_checks(self, unique_checks):
1076         errors = {}
1077 
1078         for model_class, unique_check in unique_checks:
1079             # Try to look up an existing object with the same values as this
1080             # object's values for all the unique field.
1081 
1082             lookup_kwargs = {}
1083             for field_name in unique_check:
1084                 f = self._meta.get_field(field_name)
1085                 lookup_value = getattr(self, f.attname)
1086                 # TODO: Handle multiple backends with different feature flags.
1087                 if (lookup_value is None or
1088                         (lookup_value == '' and connection.features.interprets_empty_strings_as_nulls)):
1089                     # no value, skip the lookup
1090                     continue
1091                 if f.primary_key and not self._state.adding:
1092                     # no need to check for unique primary key when editing
1093                     continue
1094                 lookup_kwargs[str(field_name)] = lookup_value
1095 
1096             # some fields were skipped, no reason to do the check
1097             if len(unique_check) != len(lookup_kwargs):
1098                 continue
1099 
1100             qs = model_class._default_manager.filter(**lookup_kwargs)
1101 
1102             # Exclude the current object from the query if we are editing an
1103             # instance (as opposed to creating a new one)
1104             # Note that we need to use the pk as defined by model_class, not
1105             # self.pk. These can be different fields because model inheritance
1106             # allows single model to have effectively multiple primary keys.
1107             # Refs #17615.
1108             model_class_pk = self._get_pk_val(model_class._meta)
1109             if not self._state.adding and model_class_pk is not None:
1110                 qs = qs.exclude(pk=model_class_pk)
1111             if qs.exists():
1112                 if len(unique_check) == 1:
1113                     key = unique_check[0]
1114                 else:
1115                     key = NON_FIELD_ERRORS
1116                 errors.setdefault(key, []).append(self.unique_error_message(model_class, unique_check))
1117 
1118         return errors
1119 
1120     def _perform_date_checks(self, date_checks):
1121         errors = {}
1122         for model_class, lookup_type, field, unique_for in date_checks:
1123             lookup_kwargs = {}
1124             # there's a ticket to add a date lookup, we can remove this special
1125             # case if that makes it's way in
1126             date = getattr(self, unique_for)
1127             if date is None:
1128                 continue
1129             if lookup_type == 'date':
1130                 lookup_kwargs['%s__day' % unique_for] = date.day
1131                 lookup_kwargs['%s__month' % unique_for] = date.month
1132                 lookup_kwargs['%s__year' % unique_for] = date.year
1133             else:
1134                 lookup_kwargs['%s__%s' % (unique_for, lookup_type)] = getattr(date, lookup_type)
1135             lookup_kwargs[field] = getattr(self, field)
1136 
1137             qs = model_class._default_manager.filter(**lookup_kwargs)
1138             # Exclude the current object from the query if we are editing an
1139             # instance (as opposed to creating a new one)
1140             if not self._state.adding and self.pk is not None:
1141                 qs = qs.exclude(pk=self.pk)
1142 
1143             if qs.exists():
1144                 errors.setdefault(field, []).append(
1145                     self.date_error_message(lookup_type, field, unique_for)
1146                 )
1147         return errors
1148 
1149     def date_error_message(self, lookup_type, field_name, unique_for):
1150         opts = self._meta
1151         field = opts.get_field(field_name)
1152         return ValidationError(
1153             message=field.error_messages['unique_for_date'],
1154             code='unique_for_date',
1155             params={
1156                 'model': self,
1157                 'model_name': capfirst(opts.verbose_name),
1158                 'lookup_type': lookup_type,
1159                 'field': field_name,
1160                 'field_label': capfirst(field.verbose_name),
1161                 'date_field': unique_for,
1162                 'date_field_label': capfirst(opts.get_field(unique_for).verbose_name),
1163             }
1164         )
1165 
1166     def unique_error_message(self, model_class, unique_check):
1167         opts = model_class._meta
1168 
1169         params = {
1170             'model': self,
1171             'model_class': model_class,
1172             'model_name': capfirst(opts.verbose_name),
1173             'unique_check': unique_check,
1174         }
1175 
1176         # A unique field
1177         if len(unique_check) == 1:
1178             field = opts.get_field(unique_check[0])
1179             params['field_label'] = capfirst(field.verbose_name)
1180             return ValidationError(
1181                 message=field.error_messages['unique'],
1182                 code='unique',
1183                 params=params,
1184             )
1185 
1186         # unique_together
1187         else:
1188             field_labels = [capfirst(opts.get_field(f).verbose_name) for f in unique_check]
1189             params['field_labels'] = get_text_list(field_labels, _('and'))
1190             return ValidationError(
1191                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1192                 code='unique_together',
1193                 params=params,
1194             )
1195 
1196     def full_clean(self, exclude=None, validate_unique=True):
1197         """
1198         Call clean_fields(), clean(), and validate_unique() on the model.
1199         Raise a ValidationError for any errors that occur.
1200         """
1201         errors = {}
1202         if exclude is None:
1203             exclude = []
1204         else:
1205             exclude = list(exclude)
1206 
1207         try:
1208             self.clean_fields(exclude=exclude)
1209         except ValidationError as e:
1210             errors = e.update_error_dict(errors)
1211 
1212         # Form.clean() is run even if other validation fails, so do the
1213         # same with Model.clean() for consistency.
1214         try:
1215             self.clean()
1216         except ValidationError as e:
1217             errors = e.update_error_dict(errors)
1218 
1219         # Run unique checks, but only for fields that passed validation.
1220         if validate_unique:
1221             for name in errors:
1222                 if name != NON_FIELD_ERRORS and name not in exclude:
1223                     exclude.append(name)
1224             try:
1225                 self.validate_unique(exclude=exclude)
1226             except ValidationError as e:
1227                 errors = e.update_error_dict(errors)
1228 
1229         if errors:
1230             raise ValidationError(errors)
1231 
1232     def clean_fields(self, exclude=None):
1233         """
1234         Clean all fields and raise a ValidationError containing a dict
1235         of all validation errors if any occur.
1236         """
1237         if exclude is None:
1238             exclude = []
1239 
1240         errors = {}
1241         for f in self._meta.fields:
1242             if f.name in exclude:
1243                 continue
1244             # Skip validation for empty fields with blank=True. The developer
1245             # is responsible for making sure they have a valid value.
1246             raw_value = getattr(self, f.attname)
1247             if f.blank and raw_value in f.empty_values:
1248                 continue
1249             try:
1250                 setattr(self, f.attname, f.clean(raw_value, self))
1251             except ValidationError as e:
1252                 errors[f.name] = e.error_list
1253 
1254         if errors:
1255             raise ValidationError(errors)
1256 
1257     @classmethod
1258     def check(cls, **kwargs):
1259         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1260         if not cls._meta.swapped:
1261             databases = kwargs.get('databases') or []
1262             errors += [
1263                 *cls._check_fields(**kwargs),
1264                 *cls._check_m2m_through_same_relationship(),
1265                 *cls._check_long_column_names(databases),
1266             ]
1267             clash_errors = (
1268                 *cls._check_id_field(),
1269                 *cls._check_field_name_clashes(),
1270                 *cls._check_model_name_db_lookup_clashes(),
1271                 *cls._check_property_name_related_field_accessor_clashes(),
1272                 *cls._check_single_primary_key(),
1273             )
1274             errors.extend(clash_errors)
1275             # If there are field name clashes, hide consequent column name
1276             # clashes.
1277             if not clash_errors:
1278                 errors.extend(cls._check_column_name_clashes())
1279             errors += [
1280                 *cls._check_index_together(),
1281                 *cls._check_unique_together(),
1282                 *cls._check_indexes(databases),
1283                 *cls._check_ordering(),
1284                 *cls._check_constraints(databases),
1285             ]
1286 
1287         return errors
1288 
1289     @classmethod
1290     def _check_swappable(cls):
1291         """Check if the swapped model exists."""
1292         errors = []
1293         if cls._meta.swapped:
1294             try:
1295                 apps.get_model(cls._meta.swapped)
1296             except ValueError:
1297                 errors.append(
1298                     checks.Error(
1299                         "'%s' is not of the form 'app_label.app_name'." % cls._meta.swappable,
1300                         id='models.E001',
1301                     )
1302                 )
1303             except LookupError:
1304                 app_label, model_name = cls._meta.swapped.split('.')
1305                 errors.append(
1306                     checks.Error(
1307                         "'%s' references '%s.%s', which has not been "
1308                         "installed, or is abstract." % (
1309                             cls._meta.swappable, app_label, model_name
1310                         ),
1311                         id='models.E002',
1312                     )
1313                 )
1314         return errors
1315 
1316     @classmethod
1317     def _check_model(cls):
1318         errors = []
1319         if cls._meta.proxy:
1320             if cls._meta.local_fields or cls._meta.local_many_to_many:
1321                 errors.append(
1322                     checks.Error(
1323                         "Proxy model '%s' contains model fields." % cls.__name__,
1324                         id='models.E017',
1325                     )
1326                 )
1327         return errors
1328 
1329     @classmethod
1330     def _check_managers(cls, **kwargs):
1331         """Perform all manager checks."""
1332         errors = []
1333         for manager in cls._meta.managers:
1334             errors.extend(manager.check(**kwargs))
1335         return errors
1336 
1337     @classmethod
1338     def _check_fields(cls, **kwargs):
1339         """Perform all field checks."""
1340         errors = []
1341         for field in cls._meta.local_fields:
1342             errors.extend(field.check(**kwargs))
1343         for field in cls._meta.local_many_to_many:
1344             errors.extend(field.check(from_model=cls, **kwargs))
1345         return errors
1346 
1347     @classmethod
1348     def _check_m2m_through_same_relationship(cls):
1349         """ Check if no relationship model is used by more than one m2m field.
1350         """
1351 
1352         errors = []
1353         seen_intermediary_signatures = []
1354 
1355         fields = cls._meta.local_many_to_many
1356 
1357         # Skip when the target model wasn't found.
1358         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1359 
1360         # Skip when the relationship model wasn't found.
1361         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1362 
1363         for f in fields:
1364             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1365             if signature in seen_intermediary_signatures:
1366                 errors.append(
1367                     checks.Error(
1368                         "The model has two identical many-to-many relations "
1369                         "through the intermediate model '%s'." %
1370                         f.remote_field.through._meta.label,
1371                         obj=cls,
1372                         id='models.E003',
1373                     )
1374                 )
1375             else:
1376                 seen_intermediary_signatures.append(signature)
1377         return errors
1378 
1379     @classmethod
1380     def _check_id_field(cls):
1381         """Check if `id` field is a primary key."""
1382         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1383         # fields is empty or consists of the invalid "id" field
1384         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1385             return [
1386                 checks.Error(
1387                     "'id' can only be used as a field name if the field also "
1388                     "sets 'primary_key=True'.",
1389                     obj=cls,
1390                     id='models.E004',
1391                 )
1392             ]
1393         else:
1394             return []
1395 
1396     @classmethod
1397     def _check_field_name_clashes(cls):
1398         """Forbid field shadowing in multi-table inheritance."""
1399         errors = []
1400         used_fields = {}  # name or attname -> field
1401 
1402         # Check that multi-inheritance doesn't cause field name shadowing.
1403         for parent in cls._meta.get_parent_list():
1404             for f in parent._meta.local_fields:
1405                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1406                 if clash:
1407                     errors.append(
1408                         checks.Error(
1409                             "The field '%s' from parent model "
1410                             "'%s' clashes with the field '%s' "
1411                             "from parent model '%s'." % (
1412                                 clash.name, clash.model._meta,
1413                                 f.name, f.model._meta
1414                             ),
1415                             obj=cls,
1416                             id='models.E005',
1417                         )
1418                     )
1419                 used_fields[f.name] = f
1420                 used_fields[f.attname] = f
1421 
1422         # Check that fields defined in the model don't clash with fields from
1423         # parents, including auto-generated fields like multi-table inheritance
1424         # child accessors.
1425         for parent in cls._meta.get_parent_list():
1426             for f in parent._meta.get_fields():
1427                 if f not in used_fields:
1428                     used_fields[f.name] = f
1429 
1430         for f in cls._meta.local_fields:
1431             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1432             # Note that we may detect clash between user-defined non-unique
1433             # field "id" and automatically added unique field "id", both
1434             # defined at the same model. This special case is considered in
1435             # _check_id_field and here we ignore it.
1436             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1437             if clash and not id_conflict:
1438                 errors.append(
1439                     checks.Error(
1440                         "The field '%s' clashes with the field '%s' "
1441                         "from model '%s'." % (
1442                             f.name, clash.name, clash.model._meta
1443                         ),
1444                         obj=f,
1445                         id='models.E006',
1446                     )
1447                 )
1448             used_fields[f.name] = f
1449             used_fields[f.attname] = f
1450 
1451         return errors
1452 
1453     @classmethod
1454     def _check_column_name_clashes(cls):
1455         # Store a list of column names which have already been used by other fields.
1456         used_column_names = []
1457         errors = []
1458 
1459         for f in cls._meta.local_fields:
1460             _, column_name = f.get_attname_column()
1461 
1462             # Ensure the column name is not already in use.
1463             if column_name and column_name in used_column_names:
1464                 errors.append(
1465                     checks.Error(
1466                         "Field '%s' has column name '%s' that is used by "
1467                         "another field." % (f.name, column_name),
1468                         hint="Specify a 'db_column' for the field.",
1469                         obj=cls,
1470                         id='models.E007'
1471                     )
1472                 )
1473             else:
1474                 used_column_names.append(column_name)
1475 
1476         return errors
1477 
1478     @classmethod
1479     def _check_model_name_db_lookup_clashes(cls):
1480         errors = []
1481         model_name = cls.__name__
1482         if model_name.startswith('_') or model_name.endswith('_'):
1483             errors.append(
1484                 checks.Error(
1485                     "The model name '%s' cannot start or end with an underscore "
1486                     "as it collides with the query lookup syntax." % model_name,
1487                     obj=cls,
1488                     id='models.E023'
1489                 )
1490             )
1491         elif LOOKUP_SEP in model_name:
1492             errors.append(
1493                 checks.Error(
1494                     "The model name '%s' cannot contain double underscores as "
1495                     "it collides with the query lookup syntax." % model_name,
1496                     obj=cls,
1497                     id='models.E024'
1498                 )
1499             )
1500         return errors
1501 
1502     @classmethod
1503     def _check_property_name_related_field_accessor_clashes(cls):
1504         errors = []
1505         property_names = cls._meta._property_names
1506         related_field_accessors = (
1507             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1508             if f.is_relation and f.related_model is not None
1509         )
1510         for accessor in related_field_accessors:
1511             if accessor in property_names:
1512                 errors.append(
1513                     checks.Error(
1514                         "The property '%s' clashes with a related field "
1515                         "accessor." % accessor,
1516                         obj=cls,
1517                         id='models.E025',
1518                     )
1519                 )
1520         return errors
1521 
1522     @classmethod
1523     def _check_single_primary_key(cls):
1524         errors = []
1525         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1526             errors.append(
1527                 checks.Error(
1528                     "The model cannot have more than one field with "
1529                     "'primary_key=True'.",
1530                     obj=cls,
1531                     id='models.E026',
1532                 )
1533             )
1534         return errors
1535 
1536     @classmethod
1537     def _check_index_together(cls):
1538         """Check the value of "index_together" option."""
1539         if not isinstance(cls._meta.index_together, (tuple, list)):
1540             return [
1541                 checks.Error(
1542                     "'index_together' must be a list or tuple.",
1543                     obj=cls,
1544                     id='models.E008',
1545                 )
1546             ]
1547 
1548         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1549             return [
1550                 checks.Error(
1551                     "All 'index_together' elements must be lists or tuples.",
1552                     obj=cls,
1553                     id='models.E009',
1554                 )
1555             ]
1556 
1557         else:
1558             errors = []
1559             for fields in cls._meta.index_together:
1560                 errors.extend(cls._check_local_fields(fields, "index_together"))
1561             return errors
1562 
1563     @classmethod
1564     def _check_unique_together(cls):
1565         """Check the value of "unique_together" option."""
1566         if not isinstance(cls._meta.unique_together, (tuple, list)):
1567             return [
1568                 checks.Error(
1569                     "'unique_together' must be a list or tuple.",
1570                     obj=cls,
1571                     id='models.E010',
1572                 )
1573             ]
1574 
1575         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1576             return [
1577                 checks.Error(
1578                     "All 'unique_together' elements must be lists or tuples.",
1579                     obj=cls,
1580                     id='models.E011',
1581                 )
1582             ]
1583 
1584         else:
1585             errors = []
1586             for fields in cls._meta.unique_together:
1587                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1588             return errors
1589 
1590     @classmethod
1591     def _check_indexes(cls, databases):
1592         """Check fields, names, and conditions of indexes."""
1593         errors = []
1594         for index in cls._meta.indexes:
1595             # Index name can't start with an underscore or a number, restricted
1596             # for cross-database compatibility with Oracle.
1597             if index.name[0] == '_' or index.name[0].isdigit():
1598                 errors.append(
1599                     checks.Error(
1600                         "The index name '%s' cannot start with an underscore "
1601                         "or a number." % index.name,
1602                         obj=cls,
1603                         id='models.E033',
1604                     ),
1605                 )
1606             if len(index.name) > index.max_name_length:
1607                 errors.append(
1608                     checks.Error(
1609                         "The index name '%s' cannot be longer than %d "
1610                         "characters." % (index.name, index.max_name_length),
1611                         obj=cls,
1612                         id='models.E034',
1613                     ),
1614                 )
1615         for db in databases:
1616             if not router.allow_migrate_model(db, cls):
1617                 continue
1618             connection = connections[db]
1619             if not (
1620                 connection.features.supports_partial_indexes or
1621                 'supports_partial_indexes' in cls._meta.required_db_features
1622             ) and any(index.condition is not None for index in cls._meta.indexes):
1623                 errors.append(
1624                     checks.Warning(
1625                         '%s does not support indexes with conditions.'
1626                         % connection.display_name,
1627                         hint=(
1628                             "Conditions will be ignored. Silence this warning "
1629                             "if you don't care about it."
1630                         ),
1631                         obj=cls,
1632                         id='models.W037',
1633                     )
1634                 )
1635             if not (
1636                 connection.features.supports_covering_indexes or
1637                 'supports_covering_indexes' in cls._meta.required_db_features
1638             ) and any(index.include for index in cls._meta.indexes):
1639                 errors.append(
1640                     checks.Warning(
1641                         '%s does not support indexes with non-key columns.'
1642                         % connection.display_name,
1643                         hint=(
1644                             "Non-key columns will be ignored. Silence this "
1645                             "warning if you don't care about it."
1646                         ),
1647                         obj=cls,
1648                         id='models.W040',
1649                     )
1650                 )
1651         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1652         fields += [include for index in cls._meta.indexes for include in index.include]
1653         errors.extend(cls._check_local_fields(fields, 'indexes'))
1654         return errors
1655 
1656     @classmethod
1657     def _check_local_fields(cls, fields, option):
1658         from django.db import models
1659 
1660         # In order to avoid hitting the relation tree prematurely, we use our
1661         # own fields_map instead of using get_field()
1662         forward_fields_map = {}
1663         for field in cls._meta._get_fields(reverse=False):
1664             forward_fields_map[field.name] = field
1665             if hasattr(field, 'attname'):
1666                 forward_fields_map[field.attname] = field
1667 
1668         errors = []
1669         for field_name in fields:
1670             try:
1671                 field = forward_fields_map[field_name]
1672             except KeyError:
1673                 errors.append(
1674                     checks.Error(
1675                         "'%s' refers to the nonexistent field '%s'." % (
1676                             option, field_name,
1677                         ),
1678                         obj=cls,
1679                         id='models.E012',
1680                     )
1681                 )
1682             else:
1683                 if isinstance(field.remote_field, models.ManyToManyRel):
1684                     errors.append(
1685                         checks.Error(
1686                             "'%s' refers to a ManyToManyField '%s', but "
1687                             "ManyToManyFields are not permitted in '%s'." % (
1688                                 option, field_name, option,
1689                             ),
1690                             obj=cls,
1691                             id='models.E013',
1692                         )
1693                     )
1694                 elif field not in cls._meta.local_fields:
1695                     errors.append(
1696                         checks.Error(
1697                             "'%s' refers to field '%s' which is not local to model '%s'."
1698                             % (option, field_name, cls._meta.object_name),
1699                             hint="This issue may be caused by multi-table inheritance.",
1700                             obj=cls,
1701                             id='models.E016',
1702                         )
1703                     )
1704         return errors
1705 
1706     @classmethod
1707     def _check_ordering(cls):
1708         """
1709         Check "ordering" option -- is it a list of strings and do all fields
1710         exist?
1711         """
1712         if cls._meta._ordering_clash:
1713             return [
1714                 checks.Error(
1715                     "'ordering' and 'order_with_respect_to' cannot be used together.",
1716                     obj=cls,
1717                     id='models.E021',
1718                 ),
1719             ]
1720 
1721         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1722             return []
1723 
1724         if not isinstance(cls._meta.ordering, (list, tuple)):
1725             return [
1726                 checks.Error(
1727                     "'ordering' must be a tuple or list (even if you want to order by only one field).",
1728                     obj=cls,
1729                     id='models.E014',
1730                 )
1731             ]
1732 
1733         errors = []
1734         fields = cls._meta.ordering
1735 
1736         # Skip expressions and '?' fields.
1737         fields = (f for f in fields if isinstance(f, str) and f != '?')
1738 
1739         # Convert "-field" to "field".
1740         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1741 
1742         # Separate related fields and non-related fields.
1743         _fields = []
1744         related_fields = []
1745         for f in fields:
1746             if LOOKUP_SEP in f:
1747                 related_fields.append(f)
1748             else:
1749                 _fields.append(f)
1750         fields = _fields
1751 
1752         # Check related fields.
1753         for field in related_fields:
1754             _cls = cls
1755             fld = None
1756             for part in field.split(LOOKUP_SEP):
1757                 try:
1758                     # pk is an alias that won't be found by opts.get_field.
1759                     if part == 'pk':
1760                         fld = _cls._meta.pk
1761                     else:
1762                         fld = _cls._meta.get_field(part)
1763                     if fld.is_relation:
1764                         _cls = fld.get_path_info()[-1].to_opts.model
1765                     else:
1766                         _cls = None
1767                 except (FieldDoesNotExist, AttributeError):
1768                     if fld is None or (
1769                         fld.get_transform(part) is None and fld.get_lookup(part) is None
1770                     ):
1771                         errors.append(
1772                             checks.Error(
1773                                 "'ordering' refers to the nonexistent field, "
1774                                 "related field, or lookup '%s'." % field,
1775                                 obj=cls,
1776                                 id='models.E015',
1777                             )
1778                         )
1779 
1780         # Skip ordering on pk. This is always a valid order_by field
1781         # but is an alias and therefore won't be found by opts.get_field.
1782         fields = {f for f in fields if f != 'pk'}
1783 
1784         # Check for invalid or nonexistent fields in ordering.
1785         invalid_fields = []
1786 
1787         # Any field name that is not present in field_names does not exist.
1788         # Also, ordering by m2m fields is not allowed.
1789         opts = cls._meta
1790         valid_fields = set(chain.from_iterable(
1791             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1792             for f in chain(opts.fields, opts.related_objects)
1793         ))
1794 
1795         invalid_fields.extend(fields - valid_fields)
1796 
1797         for invalid_field in invalid_fields:
1798             errors.append(
1799                 checks.Error(
1800                     "'ordering' refers to the nonexistent field, related "
1801                     "field, or lookup '%s'." % invalid_field,
1802                     obj=cls,
1803                     id='models.E015',
1804                 )
1805             )
1806         return errors
1807 
1808     @classmethod
1809     def _check_long_column_names(cls, databases):
1810         """
1811         Check that any auto-generated column names are shorter than the limits
1812         for each database in which the model will be created.
1813         """
1814         if not databases:
1815             return []
1816         errors = []
1817         allowed_len = None
1818         db_alias = None
1819 
1820         # Find the minimum max allowed length among all specified db_aliases.
1821         for db in databases:
1822             # skip databases where the model won't be created
1823             if not router.allow_migrate_model(db, cls):
1824                 continue
1825             connection = connections[db]
1826             max_name_length = connection.ops.max_name_length()
1827             if max_name_length is None or connection.features.truncates_names:
1828                 continue
1829             else:
1830                 if allowed_len is None:
1831                     allowed_len = max_name_length
1832                     db_alias = db
1833                 elif max_name_length < allowed_len:
1834                     allowed_len = max_name_length
1835                     db_alias = db
1836 
1837         if allowed_len is None:
1838             return errors
1839 
1840         for f in cls._meta.local_fields:
1841             _, column_name = f.get_attname_column()
1842 
1843             # Check if auto-generated name for the field is too long
1844             # for the database.
1845             if f.db_column is None and column_name is not None and len(column_name) > allowed_len:
1846                 errors.append(
1847                     checks.Error(
1848                         'Autogenerated column name too long for field "%s". '
1849                         'Maximum length is "%s" for database "%s".'
1850                         % (column_name, allowed_len, db_alias),
1851                         hint="Set the column name manually using 'db_column'.",
1852                         obj=cls,
1853                         id='models.E018',
1854                     )
1855                 )
1856 
1857         for f in cls._meta.local_many_to_many:
1858             # Skip nonexistent models.
1859             if isinstance(f.remote_field.through, str):
1860                 continue
1861 
1862             # Check if auto-generated name for the M2M field is too long
1863             # for the database.
1864             for m2m in f.remote_field.through._meta.local_fields:
1865                 _, rel_name = m2m.get_attname_column()
1866                 if m2m.db_column is None and rel_name is not None and len(rel_name) > allowed_len:
1867                     errors.append(
1868                         checks.Error(
1869                             'Autogenerated column name too long for M2M field '
1870                             '"%s". Maximum length is "%s" for database "%s".'
1871                             % (rel_name, allowed_len, db_alias),
1872                             hint=(
1873                                 "Use 'through' to create a separate model for "
1874                                 "M2M and then set column_name using 'db_column'."
1875                             ),
1876                             obj=cls,
1877                             id='models.E019',
1878                         )
1879                     )
1880 
1881         return errors
1882 
1883     @classmethod
1884     def _get_expr_references(cls, expr):
1885         if isinstance(expr, Q):
1886             for child in expr.children:
1887                 if isinstance(child, tuple):
1888                     lookup, value = child
1889                     yield tuple(lookup.split(LOOKUP_SEP))
1890                     yield from cls._get_expr_references(value)
1891                 else:
1892                     yield from cls._get_expr_references(child)
1893         elif isinstance(expr, F):
1894             yield tuple(expr.name.split(LOOKUP_SEP))
1895         elif hasattr(expr, 'get_source_expressions'):
1896             for src_expr in expr.get_source_expressions():
1897                 yield from cls._get_expr_references(src_expr)
1898 
1899     @classmethod
1900     def _check_constraints(cls, databases):
1901         errors = []
1902         for db in databases:
1903             if not router.allow_migrate_model(db, cls):
1904                 continue
1905             connection = connections[db]
1906             if not (
1907                 connection.features.supports_table_check_constraints or
1908                 'supports_table_check_constraints' in cls._meta.required_db_features
1909             ) and any(
1910                 isinstance(constraint, CheckConstraint)
1911                 for constraint in cls._meta.constraints
1912             ):
1913                 errors.append(
1914                     checks.Warning(
1915                         '%s does not support check constraints.' % connection.display_name,
1916                         hint=(
1917                             "A constraint won't be created. Silence this "
1918                             "warning if you don't care about it."
1919                         ),
1920                         obj=cls,
1921                         id='models.W027',
1922                     )
1923                 )
1924             if not (
1925                 connection.features.supports_partial_indexes or
1926                 'supports_partial_indexes' in cls._meta.required_db_features
1927             ) and any(
1928                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None
1929                 for constraint in cls._meta.constraints
1930             ):
1931                 errors.append(
1932                     checks.Warning(
1933                         '%s does not support unique constraints with '
1934                         'conditions.' % connection.display_name,
1935                         hint=(
1936                             "A constraint won't be created. Silence this "
1937                             "warning if you don't care about it."
1938                         ),
1939                         obj=cls,
1940                         id='models.W036',
1941                     )
1942                 )
1943             if not (
1944                 connection.features.supports_deferrable_unique_constraints or
1945                 'supports_deferrable_unique_constraints' in cls._meta.required_db_features
1946             ) and any(
1947                 isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None
1948                 for constraint in cls._meta.constraints
1949             ):
1950                 errors.append(
1951                     checks.Warning(
1952                         '%s does not support deferrable unique constraints.'
1953                         % connection.display_name,
1954                         hint=(
1955                             "A constraint won't be created. Silence this "
1956                             "warning if you don't care about it."
1957                         ),
1958                         obj=cls,
1959                         id='models.W038',
1960                     )
1961                 )
1962             if not (
1963                 connection.features.supports_covering_indexes or
1964                 'supports_covering_indexes' in cls._meta.required_db_features
1965             ) and any(
1966                 isinstance(constraint, UniqueConstraint) and constraint.include
1967                 for constraint in cls._meta.constraints
1968             ):
1969                 errors.append(
1970                     checks.Warning(
1971                         '%s does not support unique constraints with non-key '
1972                         'columns.' % connection.display_name,
1973                         hint=(
1974                             "A constraint won't be created. Silence this "
1975                             "warning if you don't care about it."
1976                         ),
1977                         obj=cls,
1978                         id='models.W039',
1979                     )
1980                 )
1981             fields = set(chain.from_iterable(
1982                 (*constraint.fields, *constraint.include)
1983                 for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)
1984             ))
1985             references = set()
1986             for constraint in cls._meta.constraints:
1987                 if isinstance(constraint, UniqueConstraint):
1988                     if (
1989                         connection.features.supports_partial_indexes or
1990                         'supports_partial_indexes' not in cls._meta.required_db_features
1991                     ) and isinstance(constraint.condition, Q):
1992                         references.update(cls._get_expr_references(constraint.condition))
1993                 elif isinstance(constraint, CheckConstraint):
1994                     if (
1995                         connection.features.supports_table_check_constraints or
1996                         'supports_table_check_constraints' not in cls._meta.required_db_features
1997                     ) and isinstance(constraint.check, Q):
1998                         references.update(cls._get_expr_references(constraint.check))
1999             for field_name, *lookups in references:
2000                 # pk is an alias that won't be found by opts.get_field.
2001                 if field_name != 'pk':
2002                     fields.add(field_name)
2003                 if not lookups:
2004                     # If it has no lookups it cannot result in a JOIN.
2005                     continue
2006                 try:
2007                     if field_name == 'pk':
2008                         field = cls._meta.pk
2009                     else:
2010                         field = cls._meta.get_field(field_name)
2011                     if not field.is_relation or field.many_to_many or field.one_to_many:
2012                         continue
2013                 except FieldDoesNotExist:
2014                     continue
2015                 # JOIN must happen at the first lookup.
2016                 first_lookup = lookups[0]
2017                 if (
2018                     field.get_transform(first_lookup) is None and
2019                     field.get_lookup(first_lookup) is None
2020                 ):
2021                     errors.append(
2022                         checks.Error(
2023                             "'constraints' refers to the joined field '%s'."
2024                             % LOOKUP_SEP.join([field_name] + lookups),
2025                             obj=cls,
2026                             id='models.E041',
2027                         )
2028                     )
2029             errors.extend(cls._check_local_fields(fields, 'constraints'))
2030         return errors
2031 
2032 
2033 ############################################
2034 # HELPER FUNCTIONS (CURRIED MODEL METHODS) #
2035 ############################################
2036 
2037 # ORDERING METHODS #########################
2038 
2039 def method_set_order(self, ordered_obj, id_list, using=None):
2040     if using is None:
2041         using = DEFAULT_DB_ALIAS
2042     order_wrt = ordered_obj._meta.order_with_respect_to
2043     filter_args = order_wrt.get_forward_related_filter(self)
2044     ordered_obj.objects.db_manager(using).filter(**filter_args).bulk_update([
2045         ordered_obj(pk=pk, _order=order) for order, pk in enumerate(id_list)
2046     ], ['_order'])
2047 
2048 
2049 def method_get_order(self, ordered_obj):
2050     order_wrt = ordered_obj._meta.order_with_respect_to
2051     filter_args = order_wrt.get_forward_related_filter(self)
2052     pk_name = ordered_obj._meta.pk.name
2053     return ordered_obj.objects.filter(**filter_args).values_list(pk_name, flat=True)
2054 
2055 
2056 def make_foreign_order_accessors(model, related_model):
2057     setattr(
2058         related_model,
2059         'get_%s_order' % model.__name__.lower(),
2060         partialmethod(method_get_order, model)
2061     )
2062     setattr(
2063         related_model,
2064         'set_%s_order' % model.__name__.lower(),
2065         partialmethod(method_set_order, model)
2066     )
2067 
2068 ########
2069 # MISC #
2070 ########
2071 
2072 
2073 def model_unpickle(model_id):
2074     """Used to unpickle Model subclasses with deferred fields."""
2075     if isinstance(model_id, tuple):
2076         model = apps.get_model(*model_id)
2077     else:
2078         # Backwards compat - the model was cached directly in earlier versions.
2079         model = model_id
2080     return model.__new__(model)
2081 
2082 
2083 model_unpickle.__safe_for_unpickle__ = True

</code><intended_behavior>The part of the code responsible for handling model instance copying or state management needs to be updated or examined for Django versions >= 2.0. The code should ensure that when a model instance is copied (using Python's standard copy.copy or copy.deepcopy), all relevant state data, including foreign keys (FK) and caching mechanisms (_state and fields_cache), are correctly cloned. This includes the preservation of FK relationships and cache integrity so that changes to a cloned instance do not affect the original instance. This might involve examining or adjusting how _state (especially fields_cache) is copied between instances to ensure behavior consistent with versions < 2.0, thus preserving the expected functionality while also embracing any architectural changes introduced in Django 2.x.</intended_behavior>, <file>django/db/models/fields/related_descriptors.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Accessors for related objects.
3 
4 When a field defines a relation between two models, each model class provides
5 an attribute to access related instances of the other model class (unless the
6 reverse accessor has been disabled with related_name='+').
7 
8 Accessors are implemented as descriptors in order to customize access and
9 assignment. This module defines the descriptor classes.
10 
11 Forward accessors follow foreign keys. Reverse accessors trace them back. For
12 example, with the following models::
13 
14     class Parent(Model):
15         pass
16 
17     class Child(Model):
18         parent = ForeignKey(Parent, related_name='children')
19 
20  ``child.parent`` is a forward many-to-one relation. ``parent.children`` is a
21 reverse many-to-one relation.
22 
23 There are three types of relations (many-to-one, one-to-one, and many-to-many)
24 and two directions (forward and reverse) for a total of six combinations.
25 
26 1. Related instance on the forward side of a many-to-one relation:
27    ``ForwardManyToOneDescriptor``.
28 
29    Uniqueness of foreign key values is irrelevant to accessing the related
30    instance, making the many-to-one and one-to-one cases identical as far as
31    the descriptor is concerned. The constraint is checked upstream (unicity
32    validation in forms) or downstream (unique indexes in the database).
33 
34 2. Related instance on the forward side of a one-to-one
35    relation: ``ForwardOneToOneDescriptor``.
36 
37    It avoids querying the database when accessing the parent link field in
38    a multi-table inheritance scenario.
39 
40 3. Related instance on the reverse side of a one-to-one relation:
41    ``ReverseOneToOneDescriptor``.
42 
43    One-to-one relations are asymmetrical, despite the apparent symmetry of the
44    name, because they're implemented in the database with a foreign key from
45    one table to another. As a consequence ``ReverseOneToOneDescriptor`` is
46    slightly different from ``ForwardManyToOneDescriptor``.
47 
48 4. Related objects manager for related instances on the reverse side of a
49    many-to-one relation: ``ReverseManyToOneDescriptor``.
50 
51    Unlike the previous two classes, this one provides access to a collection
52    of objects. It returns a manager rather than an instance.
53 
54 5. Related objects manager for related instances on the forward or reverse
55    sides of a many-to-many relation: ``ManyToManyDescriptor``.
56 
57    Many-to-many relations are symmetrical. The syntax of Django models
58    requires declaring them on one side but that's an implementation detail.
59    They could be declared on the other side without any change in behavior.
60    Therefore the forward and reverse descriptors can be the same.
61 
62    If you're looking for ``ForwardManyToManyDescriptor`` or
63    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.
64 """
65 
66 from django.core.exceptions import FieldError
67 from django.db import connections, router, transaction
68 from django.db.models import Q, signals
69 from django.db.models.query import QuerySet
70 from django.db.models.query_utils import DeferredAttribute
71 from django.db.models.utils import resolve_callables
72 from django.utils.functional import cached_property
73 
74 
75 class ForeignKeyDeferredAttribute(DeferredAttribute):
76     def __set__(self, instance, value):
77         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):
78             self.field.delete_cached_value(instance)
79         instance.__dict__[self.field.attname] = value
80 
81 
82 class ForwardManyToOneDescriptor:
83     """
84     Accessor to the related object on the forward side of a many-to-one or
85     one-to-one (via ForwardOneToOneDescriptor subclass) relation.
86 
87     In the example::
88 
89         class Child(Model):
90             parent = ForeignKey(Parent, related_name='children')
91 
92     ``Child.parent`` is a ``ForwardManyToOneDescriptor`` instance.
93     """
94 
95     def __init__(self, field_with_rel):
96         self.field = field_with_rel
97 
98     @cached_property
99     def RelatedObjectDoesNotExist(self):
100         # The exception can't be created at initialization time since the
101         # related model might not be resolved yet; `self.field.model` might
102         # still be a string model reference.
103         return type(
104             'RelatedObjectDoesNotExist',
105             (self.field.remote_field.model.DoesNotExist, AttributeError), {
106                 '__module__': self.field.model.__module__,
107                 '__qualname__': '%s.%s.RelatedObjectDoesNotExist' % (
108                     self.field.model.__qualname__,
109                     self.field.name,
110                 ),
111             }
112         )
113 
114     def is_cached(self, instance):
115         return self.field.is_cached(instance)
116 
117     def get_queryset(self, **hints):
118         return self.field.remote_field.model._base_manager.db_manager(hints=hints).all()
119 
120     def get_prefetch_queryset(self, instances, queryset=None):
121         if queryset is None:
122             queryset = self.get_queryset()
123         queryset._add_hints(instance=instances[0])
124 
125         rel_obj_attr = self.field.get_foreign_related_value
126         instance_attr = self.field.get_local_related_value
127         instances_dict = {instance_attr(inst): inst for inst in instances}
128         related_field = self.field.foreign_related_fields[0]
129         remote_field = self.field.remote_field
130 
131         # FIXME: This will need to be revisited when we introduce support for
132         # composite fields. In the meantime we take this practical approach to
133         # solve a regression on 1.6 when the reverse manager in hidden
134         # (related_name ends with a '+'). Refs #21410.
135         # The check for len(...) == 1 is a special case that allows the query
136         # to be join-less and smaller. Refs #21760.
137         if remote_field.is_hidden() or len(self.field.foreign_related_fields) == 1:
138             query = {'%s__in' % related_field.name: {instance_attr(inst)[0] for inst in instances}}
139         else:
140             query = {'%s__in' % self.field.related_query_name(): instances}
141         queryset = queryset.filter(**query)
142 
143         # Since we're going to assign directly in the cache,
144         # we must manage the reverse relation cache manually.
145         if not remote_field.multiple:
146             for rel_obj in queryset:
147                 instance = instances_dict[rel_obj_attr(rel_obj)]
148                 remote_field.set_cached_value(rel_obj, instance)
149         return queryset, rel_obj_attr, instance_attr, True, self.field.get_cache_name(), False
150 
151     def get_object(self, instance):
152         qs = self.get_queryset(instance=instance)
153         # Assuming the database enforces foreign keys, this won't fail.
154         return qs.get(self.field.get_reverse_related_filter(instance))
155 
156     def __get__(self, instance, cls=None):
157         """
158         Get the related instance through the forward relation.
159 
160         With the example above, when getting ``child.parent``:
161 
162         - ``self`` is the descriptor managing the ``parent`` attribute
163         - ``instance`` is the ``child`` instance
164         - ``cls`` is the ``Child`` class (we don't need it)
165         """
166         if instance is None:
167             return self
168 
169         # The related instance is loaded from the database and then cached
170         # by the field on the model instance state. It can also be pre-cached
171         # by the reverse accessor (ReverseOneToOneDescriptor).
172         try:
173             rel_obj = self.field.get_cached_value(instance)
174         except KeyError:
175             has_value = None not in self.field.get_local_related_value(instance)
176             ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None
177             if ancestor_link and ancestor_link.is_cached(instance):
178                 # An ancestor link will exist if this field is defined on a
179                 # multi-table inheritance parent of the instance's class.
180                 ancestor = ancestor_link.get_cached_value(instance)
181                 # The value might be cached on an ancestor if the instance
182                 # originated from walking down the inheritance chain.
183                 rel_obj = self.field.get_cached_value(ancestor, default=None)
184             else:
185                 rel_obj = None
186             if rel_obj is None and has_value:
187                 rel_obj = self.get_object(instance)
188                 remote_field = self.field.remote_field
189                 # If this is a one-to-one relation, set the reverse accessor
190                 # cache on the related object to the current instance to avoid
191                 # an extra SQL query if it's accessed later on.
192                 if not remote_field.multiple:
193                     remote_field.set_cached_value(rel_obj, instance)
194             self.field.set_cached_value(instance, rel_obj)
195 
196         if rel_obj is None and not self.field.null:
197             raise self.RelatedObjectDoesNotExist(
198                 "%s has no %s." % (self.field.model.__name__, self.field.name)
199             )
200         else:
201             return rel_obj
202 
203     def __set__(self, instance, value):
204         """
205         Set the related instance through the forward relation.
206 
207         With the example above, when setting ``child.parent = parent``:
208 
209         - ``self`` is the descriptor managing the ``parent`` attribute
210         - ``instance`` is the ``child`` instance
211         - ``value`` is the ``parent`` instance on the right of the equal sign
212         """
213         # An object must be an instance of the related class.
214         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):
215             raise ValueError(
216                 'Cannot assign "%r": "%s.%s" must be a "%s" instance.' % (
217                     value,
218                     instance._meta.object_name,
219                     self.field.name,
220                     self.field.remote_field.model._meta.object_name,
221                 )
222             )
223         elif value is not None:
224             if instance._state.db is None:
225                 instance._state.db = router.db_for_write(instance.__class__, instance=value)
226             if value._state.db is None:
227                 value._state.db = router.db_for_write(value.__class__, instance=instance)
228             if not router.allow_relation(value, instance):
229                 raise ValueError('Cannot assign "%r": the current database router prevents this relation.' % value)
230 
231         remote_field = self.field.remote_field
232         # If we're setting the value of a OneToOneField to None, we need to clear
233         # out the cache on any old related object. Otherwise, deleting the
234         # previously-related object will also cause this object to be deleted,
235         # which is wrong.
236         if value is None:
237             # Look up the previously-related object, which may still be available
238             # since we've not yet cleared out the related field.
239             # Use the cache directly, instead of the accessor; if we haven't
240             # populated the cache, then we don't care - we're only accessing
241             # the object to invalidate the accessor cache, so there's no
242             # need to populate the cache just to expire it again.
243             related = self.field.get_cached_value(instance, default=None)
244 
245             # If we've got an old related object, we need to clear out its
246             # cache. This cache also might not exist if the related object
247             # hasn't been accessed yet.
248             if related is not None:
249                 remote_field.set_cached_value(related, None)
250 
251             for lh_field, rh_field in self.field.related_fields:
252                 setattr(instance, lh_field.attname, None)
253 
254         # Set the values of the related field.
255         else:
256             for lh_field, rh_field in self.field.related_fields:
257                 setattr(instance, lh_field.attname, getattr(value, rh_field.attname))
258 
259         # Set the related instance cache used by __get__ to avoid an SQL query
260         # when accessing the attribute we just set.
261         self.field.set_cached_value(instance, value)
262 
263         # If this is a one-to-one relation, set the reverse accessor cache on
264         # the related object to the current instance to avoid an extra SQL
265         # query if it's accessed later on.
266         if value is not None and not remote_field.multiple:
267             remote_field.set_cached_value(value, instance)
268 
269     def __reduce__(self):
270         """
271         Pickling should return the instance attached by self.field on the
272         model, not a new copy of that descriptor. Use getattr() to retrieve
273         the instance directly from the model.
274         """
275         return getattr, (self.field.model, self.field.name)
276 
277 
278 class ForwardOneToOneDescriptor(ForwardManyToOneDescriptor):
279     """
280     Accessor to the related object on the forward side of a one-to-one relation.
281 
282     In the example::
283 
284         class Restaurant(Model):
285             place = OneToOneField(Place, related_name='restaurant')
286 
287     ``Restaurant.place`` is a ``ForwardOneToOneDescriptor`` instance.
288     """
289 
290     def get_object(self, instance):
291         if self.field.remote_field.parent_link:
292             deferred = instance.get_deferred_fields()
293             # Because it's a parent link, all the data is available in the
294             # instance, so populate the parent model with this data.
295             rel_model = self.field.remote_field.model
296             fields = [field.attname for field in rel_model._meta.concrete_fields]
297 
298             # If any of the related model's fields are deferred, fallback to
299             # fetching all fields from the related model. This avoids a query
300             # on the related model for every deferred field.
301             if not any(field in fields for field in deferred):
302                 kwargs = {field: getattr(instance, field) for field in fields}
303                 obj = rel_model(**kwargs)
304                 obj._state.adding = instance._state.adding
305                 obj._state.db = instance._state.db
306                 return obj
307         return super().get_object(instance)
308 
309     def __set__(self, instance, value):
310         super().__set__(instance, value)
311         # If the primary key is a link to a parent model and a parent instance
312         # is being set, update the value of the inherited pk(s).
313         if self.field.primary_key and self.field.remote_field.parent_link:
314             opts = instance._meta
315             # Inherited primary key fields from this object's base classes.
316             inherited_pk_fields = [
317                 field for field in opts.concrete_fields
318                 if field.primary_key and field.remote_field
319             ]
320             for field in inherited_pk_fields:
321                 rel_model_pk_name = field.remote_field.model._meta.pk.attname
322                 raw_value = getattr(value, rel_model_pk_name) if value is not None else None
323                 setattr(instance, rel_model_pk_name, raw_value)
324 
325 
326 class ReverseOneToOneDescriptor:
327     """
328     Accessor to the related object on the reverse side of a one-to-one
329     relation.
330 
331     In the example::
332 
333         class Restaurant(Model):
334             place = OneToOneField(Place, related_name='restaurant')
335 
336     ``Place.restaurant`` is a ``ReverseOneToOneDescriptor`` instance.
337     """
338 
339     def __init__(self, related):
340         # Following the example above, `related` is an instance of OneToOneRel
341         # which represents the reverse restaurant field (place.restaurant).
342         self.related = related
343 
344     @cached_property
345     def RelatedObjectDoesNotExist(self):
346         # The exception isn't created at initialization time for the sake of
347         # consistency with `ForwardManyToOneDescriptor`.
348         return type(
349             'RelatedObjectDoesNotExist',
350             (self.related.related_model.DoesNotExist, AttributeError), {
351                 '__module__': self.related.model.__module__,
352                 '__qualname__': '%s.%s.RelatedObjectDoesNotExist' % (
353                     self.related.model.__qualname__,
354                     self.related.name,
355                 )
356             },
357         )
358 
359     def is_cached(self, instance):
360         return self.related.is_cached(instance)
361 
362     def get_queryset(self, **hints):
363         return self.related.related_model._base_manager.db_manager(hints=hints).all()
364 
365     def get_prefetch_queryset(self, instances, queryset=None):
366         if queryset is None:
367             queryset = self.get_queryset()
368         queryset._add_hints(instance=instances[0])
369 
370         rel_obj_attr = self.related.field.get_local_related_value
371         instance_attr = self.related.field.get_foreign_related_value
372         instances_dict = {instance_attr(inst): inst for inst in instances}
373         query = {'%s__in' % self.related.field.name: instances}
374         queryset = queryset.filter(**query)
375 
376         # Since we're going to assign directly in the cache,
377         # we must manage the reverse relation cache manually.
378         for rel_obj in queryset:
379             instance = instances_dict[rel_obj_attr(rel_obj)]
380             self.related.field.set_cached_value(rel_obj, instance)
381         return queryset, rel_obj_attr, instance_attr, True, self.related.get_cache_name(), False
382 
383     def __get__(self, instance, cls=None):
384         """
385         Get the related instance through the reverse relation.
386 
387         With the example above, when getting ``place.restaurant``:
388 
389         - ``self`` is the descriptor managing the ``restaurant`` attribute
390         - ``instance`` is the ``place`` instance
391         - ``cls`` is the ``Place`` class (unused)
392 
393         Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.
394         """
395         if instance is None:
396             return self
397 
398         # The related instance is loaded from the database and then cached
399         # by the field on the model instance state. It can also be pre-cached
400         # by the forward accessor (ForwardManyToOneDescriptor).
401         try:
402             rel_obj = self.related.get_cached_value(instance)
403         except KeyError:
404             related_pk = instance.pk
405             if related_pk is None:
406                 rel_obj = None
407             else:
408                 filter_args = self.related.field.get_forward_related_filter(instance)
409                 try:
410                     rel_obj = self.get_queryset(instance=instance).get(**filter_args)
411                 except self.related.related_model.DoesNotExist:
412                     rel_obj = None
413                 else:
414                     # Set the forward accessor cache on the related object to
415                     # the current instance to avoid an extra SQL query if it's
416                     # accessed later on.
417                     self.related.field.set_cached_value(rel_obj, instance)
418             self.related.set_cached_value(instance, rel_obj)
419 
420         if rel_obj is None:
421             raise self.RelatedObjectDoesNotExist(
422                 "%s has no %s." % (
423                     instance.__class__.__name__,
424                     self.related.get_accessor_name()
425                 )
426             )
427         else:
428             return rel_obj
429 
430     def __set__(self, instance, value):
431         """
432         Set the related instance through the reverse relation.
433 
434         With the example above, when setting ``place.restaurant = restaurant``:
435 
436         - ``self`` is the descriptor managing the ``restaurant`` attribute
437         - ``instance`` is the ``place`` instance
438         - ``value`` is the ``restaurant`` instance on the right of the equal sign
439 
440         Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.
441         """
442         # The similarity of the code below to the code in
443         # ForwardManyToOneDescriptor is annoying, but there's a bunch
444         # of small differences that would make a common base class convoluted.
445 
446         if value is None:
447             # Update the cached related instance (if any) & clear the cache.
448             # Following the example above, this would be the cached
449             # ``restaurant`` instance (if any).
450             rel_obj = self.related.get_cached_value(instance, default=None)
451             if rel_obj is not None:
452                 # Remove the ``restaurant`` instance from the ``place``
453                 # instance cache.
454                 self.related.delete_cached_value(instance)
455                 # Set the ``place`` field on the ``restaurant``
456                 # instance to None.
457                 setattr(rel_obj, self.related.field.name, None)
458         elif not isinstance(value, self.related.related_model):
459             # An object must be an instance of the related class.
460             raise ValueError(
461                 'Cannot assign "%r": "%s.%s" must be a "%s" instance.' % (
462                     value,
463                     instance._meta.object_name,
464                     self.related.get_accessor_name(),
465                     self.related.related_model._meta.object_name,
466                 )
467             )
468         else:
469             if instance._state.db is None:
470                 instance._state.db = router.db_for_write(instance.__class__, instance=value)
471             if value._state.db is None:
472                 value._state.db = router.db_for_write(value.__class__, instance=instance)
473             if not router.allow_relation(value, instance):
474                 raise ValueError('Cannot assign "%r": the current database router prevents this relation.' % value)
475 
476             related_pk = tuple(getattr(instance, field.attname) for field in self.related.field.foreign_related_fields)
477             # Set the value of the related field to the value of the related object's related field
478             for index, field in enumerate(self.related.field.local_related_fields):
479                 setattr(value, field.attname, related_pk[index])
480 
481             # Set the related instance cache used by __get__ to avoid an SQL query
482             # when accessing the attribute we just set.
483             self.related.set_cached_value(instance, value)
484 
485             # Set the forward accessor cache on the related object to the current
486             # instance to avoid an extra SQL query if it's accessed later on.
487             self.related.field.set_cached_value(value, instance)
488 
489     def __reduce__(self):
490         # Same purpose as ForwardManyToOneDescriptor.__reduce__().
491         return getattr, (self.related.model, self.related.name)
492 
493 
494 class ReverseManyToOneDescriptor:
495     """
496     Accessor to the related objects manager on the reverse side of a
497     many-to-one relation.
498 
499     In the example::
500 
501         class Child(Model):
502             parent = ForeignKey(Parent, related_name='children')
503 
504     ``Parent.children`` is a ``ReverseManyToOneDescriptor`` instance.
505 
506     Most of the implementation is delegated to a dynamically defined manager
507     class built by ``create_forward_many_to_many_manager()`` defined below.
508     """
509 
510     def __init__(self, rel):
511         self.rel = rel
512         self.field = rel.field
513 
514     @cached_property
515     def related_manager_cls(self):
516         related_model = self.rel.related_model
517 
518         return create_reverse_many_to_one_manager(
519             related_model._default_manager.__class__,
520             self.rel,
521         )
522 
523     def __get__(self, instance, cls=None):
524         """
525         Get the related objects through the reverse relation.
526 
527         With the example above, when getting ``parent.children``:
528 
529         - ``self`` is the descriptor managing the ``children`` attribute
530         - ``instance`` is the ``parent`` instance
531         - ``cls`` is the ``Parent`` class (unused)
532         """
533         if instance is None:
534             return self
535 
536         return self.related_manager_cls(instance)
537 
538     def _get_set_deprecation_msg_params(self):
539         return (
540             'reverse side of a related set',
541             self.rel.get_accessor_name(),
542         )
543 
544     def __set__(self, instance, value):
545         raise TypeError(
546             'Direct assignment to the %s is prohibited. Use %s.set() instead.'
547             % self._get_set_deprecation_msg_params(),
548         )
549 
550 
551 def create_reverse_many_to_one_manager(superclass, rel):
552     """
553     Create a manager for the reverse side of a many-to-one relation.
554 
555     This manager subclasses another manager, generally the default manager of
556     the related model, and adds behaviors specific to many-to-one relations.
557     """
558 
559     class RelatedManager(superclass):
560         def __init__(self, instance):
561             super().__init__()
562 
563             self.instance = instance
564             self.model = rel.related_model
565             self.field = rel.field
566 
567             self.core_filters = {self.field.name: instance}
568 
569         def __call__(self, *, manager):
570             manager = getattr(self.model, manager)
571             manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)
572             return manager_class(self.instance)
573         do_not_call_in_templates = True
574 
575         def _apply_rel_filters(self, queryset):
576             """
577             Filter the queryset for the instance this manager is bound to.
578             """
579             db = self._db or router.db_for_read(self.model, instance=self.instance)
580             empty_strings_as_null = connections[db].features.interprets_empty_strings_as_nulls
581             queryset._add_hints(instance=self.instance)
582             if self._db:
583                 queryset = queryset.using(self._db)
584             queryset = queryset.filter(**self.core_filters)
585             for field in self.field.foreign_related_fields:
586                 val = getattr(self.instance, field.attname)
587                 if val is None or (val == '' and empty_strings_as_null):
588                     return queryset.none()
589             if self.field.many_to_one:
590                 # Guard against field-like objects such as GenericRelation
591                 # that abuse create_reverse_many_to_one_manager() with reverse
592                 # one-to-many relationships instead and break known related
593                 # objects assignment.
594                 try:
595                     target_field = self.field.target_field
596                 except FieldError:
597                     # The relationship has multiple target fields. Use a tuple
598                     # for related object id.
599                     rel_obj_id = tuple([
600                         getattr(self.instance, target_field.attname)
601                         for target_field in self.field.get_path_info()[-1].target_fields
602                     ])
603                 else:
604                     rel_obj_id = getattr(self.instance, target_field.attname)
605                 queryset._known_related_objects = {self.field: {rel_obj_id: self.instance}}
606             return queryset
607 
608         def _remove_prefetched_objects(self):
609             try:
610                 self.instance._prefetched_objects_cache.pop(self.field.remote_field.get_cache_name())
611             except (AttributeError, KeyError):
612                 pass  # nothing to clear from cache
613 
614         def get_queryset(self):
615             try:
616                 return self.instance._prefetched_objects_cache[self.field.remote_field.get_cache_name()]
617             except (AttributeError, KeyError):
618                 queryset = super().get_queryset()
619                 return self._apply_rel_filters(queryset)
620 
621         def get_prefetch_queryset(self, instances, queryset=None):
622             if queryset is None:
623                 queryset = super().get_queryset()
624 
625             queryset._add_hints(instance=instances[0])
626             queryset = queryset.using(queryset._db or self._db)
627 
628             rel_obj_attr = self.field.get_local_related_value
629             instance_attr = self.field.get_foreign_related_value
630             instances_dict = {instance_attr(inst): inst for inst in instances}
631             query = {'%s__in' % self.field.name: instances}
632             queryset = queryset.filter(**query)
633 
634             # Since we just bypassed this class' get_queryset(), we must manage
635             # the reverse relation manually.
636             for rel_obj in queryset:
637                 instance = instances_dict[rel_obj_attr(rel_obj)]
638                 setattr(rel_obj, self.field.name, instance)
639             cache_name = self.field.remote_field.get_cache_name()
640             return queryset, rel_obj_attr, instance_attr, False, cache_name, False
641 
642         def add(self, *objs, bulk=True):
643             self._remove_prefetched_objects()
644             db = router.db_for_write(self.model, instance=self.instance)
645 
646             def check_and_update_obj(obj):
647                 if not isinstance(obj, self.model):
648                     raise TypeError("'%s' instance expected, got %r" % (
649                         self.model._meta.object_name, obj,
650                     ))
651                 setattr(obj, self.field.name, self.instance)
652 
653             if bulk:
654                 pks = []
655                 for obj in objs:
656                     check_and_update_obj(obj)
657                     if obj._state.adding or obj._state.db != db:
658                         raise ValueError(
659                             "%r instance isn't saved. Use bulk=False or save "
660                             "the object first." % obj
661                         )
662                     pks.append(obj.pk)
663                 self.model._base_manager.using(db).filter(pk__in=pks).update(**{
664                     self.field.name: self.instance,
665                 })
666             else:
667                 with transaction.atomic(using=db, savepoint=False):
668                     for obj in objs:
669                         check_and_update_obj(obj)
670                         obj.save()
671         add.alters_data = True
672 
673         def create(self, **kwargs):
674             kwargs[self.field.name] = self.instance
675             db = router.db_for_write(self.model, instance=self.instance)
676             return super(RelatedManager, self.db_manager(db)).create(**kwargs)
677         create.alters_data = True
678 
679         def get_or_create(self, **kwargs):
680             kwargs[self.field.name] = self.instance
681             db = router.db_for_write(self.model, instance=self.instance)
682             return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)
683         get_or_create.alters_data = True
684 
685         def update_or_create(self, **kwargs):
686             kwargs[self.field.name] = self.instance
687             db = router.db_for_write(self.model, instance=self.instance)
688             return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)
689         update_or_create.alters_data = True
690 
691         # remove() and clear() are only provided if the ForeignKey can have a value of null.
692         if rel.field.null:
693             def remove(self, *objs, bulk=True):
694                 if not objs:
695                     return
696                 val = self.field.get_foreign_related_value(self.instance)
697                 old_ids = set()
698                 for obj in objs:
699                     if not isinstance(obj, self.model):
700                         raise TypeError("'%s' instance expected, got %r" % (
701                             self.model._meta.object_name, obj,
702                         ))
703                     # Is obj actually part of this descriptor set?
704                     if self.field.get_local_related_value(obj) == val:
705                         old_ids.add(obj.pk)
706                     else:
707                         raise self.field.remote_field.model.DoesNotExist(
708                             "%r is not related to %r." % (obj, self.instance)
709                         )
710                 self._clear(self.filter(pk__in=old_ids), bulk)
711             remove.alters_data = True
712 
713             def clear(self, *, bulk=True):
714                 self._clear(self, bulk)
715             clear.alters_data = True
716 
717             def _clear(self, queryset, bulk):
718                 self._remove_prefetched_objects()
719                 db = router.db_for_write(self.model, instance=self.instance)
720                 queryset = queryset.using(db)
721                 if bulk:
722                     # `QuerySet.update()` is intrinsically atomic.
723                     queryset.update(**{self.field.name: None})
724                 else:
725                     with transaction.atomic(using=db, savepoint=False):
726                         for obj in queryset:
727                             setattr(obj, self.field.name, None)
728                             obj.save(update_fields=[self.field.name])
729             _clear.alters_data = True
730 
731         def set(self, objs, *, bulk=True, clear=False):
732             # Force evaluation of `objs` in case it's a queryset whose value
733             # could be affected by `manager.clear()`. Refs #19816.
734             objs = tuple(objs)
735 
736             if self.field.null:
737                 db = router.db_for_write(self.model, instance=self.instance)
738                 with transaction.atomic(using=db, savepoint=False):
739                     if clear:
740                         self.clear(bulk=bulk)
741                         self.add(*objs, bulk=bulk)
742                     else:
743                         old_objs = set(self.using(db).all())
744                         new_objs = []
745                         for obj in objs:
746                             if obj in old_objs:
747                                 old_objs.remove(obj)
748                             else:
749                                 new_objs.append(obj)
750 
751                         self.remove(*old_objs, bulk=bulk)
752                         self.add(*new_objs, bulk=bulk)
753             else:
754                 self.add(*objs, bulk=bulk)
755         set.alters_data = True
756 
757     return RelatedManager
758 
759 
760 class ManyToManyDescriptor(ReverseManyToOneDescriptor):
761     """
762     Accessor to the related objects manager on the forward and reverse sides of
763     a many-to-many relation.
764 
765     In the example::
766 
767         class Pizza(Model):
768             toppings = ManyToManyField(Topping, related_name='pizzas')
769 
770     ``Pizza.toppings`` and ``Topping.pizzas`` are ``ManyToManyDescriptor``
771     instances.
772 
773     Most of the implementation is delegated to a dynamically defined manager
774     class built by ``create_forward_many_to_many_manager()`` defined below.
775     """
776 
777     def __init__(self, rel, reverse=False):
778         super().__init__(rel)
779 
780         self.reverse = reverse
781 
782     @property
783     def through(self):
784         # through is provided so that you have easy access to the through
785         # model (Book.authors.through) for inlines, etc. This is done as
786         # a property to ensure that the fully resolved value is returned.
787         return self.rel.through
788 
789     @cached_property
790     def related_manager_cls(self):
791         related_model = self.rel.related_model if self.reverse else self.rel.model
792 
793         return create_forward_many_to_many_manager(
794             related_model._default_manager.__class__,
795             self.rel,
796             reverse=self.reverse,
797         )
798 
799     def _get_set_deprecation_msg_params(self):
800         return (
801             '%s side of a many-to-many set' % ('reverse' if self.reverse else 'forward'),
802             self.rel.get_accessor_name() if self.reverse else self.field.name,
803         )
804 
805 
806 def create_forward_many_to_many_manager(superclass, rel, reverse):
807     """
808     Create a manager for the either side of a many-to-many relation.
809 
810     This manager subclasses another manager, generally the default manager of
811     the related model, and adds behaviors specific to many-to-many relations.
812     """
813 
814     class ManyRelatedManager(superclass):
815         def __init__(self, instance=None):
816             super().__init__()
817 
818             self.instance = instance
819 
820             if not reverse:
821                 self.model = rel.model
822                 self.query_field_name = rel.field.related_query_name()
823                 self.prefetch_cache_name = rel.field.name
824                 self.source_field_name = rel.field.m2m_field_name()
825                 self.target_field_name = rel.field.m2m_reverse_field_name()
826                 self.symmetrical = rel.symmetrical
827             else:
828                 self.model = rel.related_model
829                 self.query_field_name = rel.field.name
830                 self.prefetch_cache_name = rel.field.related_query_name()
831                 self.source_field_name = rel.field.m2m_reverse_field_name()
832                 self.target_field_name = rel.field.m2m_field_name()
833                 self.symmetrical = False
834 
835             self.through = rel.through
836             self.reverse = reverse
837 
838             self.source_field = self.through._meta.get_field(self.source_field_name)
839             self.target_field = self.through._meta.get_field(self.target_field_name)
840 
841             self.core_filters = {}
842             self.pk_field_names = {}
843             for lh_field, rh_field in self.source_field.related_fields:
844                 core_filter_key = '%s__%s' % (self.query_field_name, rh_field.name)
845                 self.core_filters[core_filter_key] = getattr(instance, rh_field.attname)
846                 self.pk_field_names[lh_field.name] = rh_field.name
847 
848             self.related_val = self.source_field.get_foreign_related_value(instance)
849             if None in self.related_val:
850                 raise ValueError('"%r" needs to have a value for field "%s" before '
851                                  'this many-to-many relationship can be used.' %
852                                  (instance, self.pk_field_names[self.source_field_name]))
853             # Even if this relation is not to pk, we require still pk value.
854             # The wish is that the instance has been already saved to DB,
855             # although having a pk value isn't a guarantee of that.
856             if instance.pk is None:
857                 raise ValueError("%r instance needs to have a primary key value before "
858                                  "a many-to-many relationship can be used." %
859                                  instance.__class__.__name__)
860 
861         def __call__(self, *, manager):
862             manager = getattr(self.model, manager)
863             manager_class = create_forward_many_to_many_manager(manager.__class__, rel, reverse)
864             return manager_class(instance=self.instance)
865         do_not_call_in_templates = True
866 
867         def _build_remove_filters(self, removed_vals):
868             filters = Q(**{self.source_field_name: self.related_val})
869             # No need to add a subquery condition if removed_vals is a QuerySet without
870             # filters.
871             removed_vals_filters = (not isinstance(removed_vals, QuerySet) or
872                                     removed_vals._has_filters())
873             if removed_vals_filters:
874                 filters &= Q(**{'%s__in' % self.target_field_name: removed_vals})
875             if self.symmetrical:
876                 symmetrical_filters = Q(**{self.target_field_name: self.related_val})
877                 if removed_vals_filters:
878                     symmetrical_filters &= Q(
879                         **{'%s__in' % self.source_field_name: removed_vals})
880                 filters |= symmetrical_filters
881             return filters
882 
883         def _apply_rel_filters(self, queryset):
884             """
885             Filter the queryset for the instance this manager is bound to.
886             """
887             queryset._add_hints(instance=self.instance)
888             if self._db:
889                 queryset = queryset.using(self._db)
890             queryset._defer_next_filter = True
891             return queryset._next_is_sticky().filter(**self.core_filters)
892 
893         def _remove_prefetched_objects(self):
894             try:
895                 self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)
896             except (AttributeError, KeyError):
897                 pass  # nothing to clear from cache
898 
899         def get_queryset(self):
900             try:
901                 return self.instance._prefetched_objects_cache[self.prefetch_cache_name]
902             except (AttributeError, KeyError):
903                 queryset = super().get_queryset()
904                 return self._apply_rel_filters(queryset)
905 
906         def get_prefetch_queryset(self, instances, queryset=None):
907             if queryset is None:
908                 queryset = super().get_queryset()
909 
910             queryset._add_hints(instance=instances[0])
911             queryset = queryset.using(queryset._db or self._db)
912 
913             query = {'%s__in' % self.query_field_name: instances}
914             queryset = queryset._next_is_sticky().filter(**query)
915 
916             # M2M: need to annotate the query in order to get the primary model
917             # that the secondary model was actually related to. We know that
918             # there will already be a join on the join table, so we can just add
919             # the select.
920 
921             # For non-autocreated 'through' models, can't assume we are
922             # dealing with PK values.
923             fk = self.through._meta.get_field(self.source_field_name)
924             join_table = fk.model._meta.db_table
925             connection = connections[queryset.db]
926             qn = connection.ops.quote_name
927             queryset = queryset.extra(select={
928                 '_prefetch_related_val_%s' % f.attname:
929                 '%s.%s' % (qn(join_table), qn(f.column)) for f in fk.local_related_fields})
930             return (
931                 queryset,
932                 lambda result: tuple(
933                     getattr(result, '_prefetch_related_val_%s' % f.attname)
934                     for f in fk.local_related_fields
935                 ),
936                 lambda inst: tuple(
937                     f.get_db_prep_value(getattr(inst, f.attname), connection)
938                     for f in fk.foreign_related_fields
939                 ),
940                 False,
941                 self.prefetch_cache_name,
942                 False,
943             )
944 
945         def add(self, *objs, through_defaults=None):
946             self._remove_prefetched_objects()
947             db = router.db_for_write(self.through, instance=self.instance)
948             with transaction.atomic(using=db, savepoint=False):
949                 self._add_items(
950                     self.source_field_name, self.target_field_name, *objs,
951                     through_defaults=through_defaults,
952                 )
953                 # If this is a symmetrical m2m relation to self, add the mirror
954                 # entry in the m2m table.
955                 if self.symmetrical:
956                     self._add_items(
957                         self.target_field_name,
958                         self.source_field_name,
959                         *objs,
960                         through_defaults=through_defaults,
961                     )
962         add.alters_data = True
963 
964         def remove(self, *objs):
965             self._remove_prefetched_objects()
966             self._remove_items(self.source_field_name, self.target_field_name, *objs)
967         remove.alters_data = True
968 
969         def clear(self):
970             db = router.db_for_write(self.through, instance=self.instance)
971             with transaction.atomic(using=db, savepoint=False):
972                 signals.m2m_changed.send(
973                     sender=self.through, action="pre_clear",
974                     instance=self.instance, reverse=self.reverse,
975                     model=self.model, pk_set=None, using=db,
976                 )
977                 self._remove_prefetched_objects()
978                 filters = self._build_remove_filters(super().get_queryset().using(db))
979                 self.through._default_manager.using(db).filter(filters).delete()
980 
981                 signals.m2m_changed.send(
982                     sender=self.through, action="post_clear",
983                     instance=self.instance, reverse=self.reverse,
984                     model=self.model, pk_set=None, using=db,
985                 )
986         clear.alters_data = True
987 
988         def set(self, objs, *, clear=False, through_defaults=None):
989             # Force evaluation of `objs` in case it's a queryset whose value
990             # could be affected by `manager.clear()`. Refs #19816.
991             objs = tuple(objs)
992 
993             db = router.db_for_write(self.through, instance=self.instance)
994             with transaction.atomic(using=db, savepoint=False):
995                 if clear:
996                     self.clear()
997                     self.add(*objs, through_defaults=through_defaults)
998                 else:
999                     old_ids = set(self.using(db).values_list(self.target_field.target_field.attname, flat=True))
1000 
1001                     new_objs = []
1002                     for obj in objs:
1003                         fk_val = (
1004                             self.target_field.get_foreign_related_value(obj)[0]
1005                             if isinstance(obj, self.model)
1006                             else self.target_field.get_prep_value(obj)
1007                         )
1008                         if fk_val in old_ids:
1009                             old_ids.remove(fk_val)
1010                         else:
1011                             new_objs.append(obj)
1012 
1013                     self.remove(*old_ids)
1014                     self.add(*new_objs, through_defaults=through_defaults)
1015         set.alters_data = True
1016 
1017         def create(self, *, through_defaults=None, **kwargs):
1018             db = router.db_for_write(self.instance.__class__, instance=self.instance)
1019             new_obj = super(ManyRelatedManager, self.db_manager(db)).create(**kwargs)
1020             self.add(new_obj, through_defaults=through_defaults)
1021             return new_obj
1022         create.alters_data = True
1023 
1024         def get_or_create(self, *, through_defaults=None, **kwargs):
1025             db = router.db_for_write(self.instance.__class__, instance=self.instance)
1026             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(**kwargs)
1027             # We only need to add() if created because if we got an object back
1028             # from get() then the relationship already exists.
1029             if created:
1030                 self.add(obj, through_defaults=through_defaults)
1031             return obj, created
1032         get_or_create.alters_data = True
1033 
1034         def update_or_create(self, *, through_defaults=None, **kwargs):
1035             db = router.db_for_write(self.instance.__class__, instance=self.instance)
1036             obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)
1037             # We only need to add() if created because if we got an object back
1038             # from get() then the relationship already exists.
1039             if created:
1040                 self.add(obj, through_defaults=through_defaults)
1041             return obj, created
1042         update_or_create.alters_data = True
1043 
1044         def _get_target_ids(self, target_field_name, objs):
1045             """
1046             Return the set of ids of `objs` that the target field references.
1047             """
1048             from django.db.models import Model
1049             target_ids = set()
1050             target_field = self.through._meta.get_field(target_field_name)
1051             for obj in objs:
1052                 if isinstance(obj, self.model):
1053                     if not router.allow_relation(obj, self.instance):
1054                         raise ValueError(
1055                             'Cannot add "%r": instance is on database "%s", '
1056                             'value is on database "%s"' %
1057                             (obj, self.instance._state.db, obj._state.db)
1058                         )
1059                     target_id = target_field.get_foreign_related_value(obj)[0]
1060                     if target_id is None:
1061                         raise ValueError(
1062                             'Cannot add "%r": the value for field "%s" is None' %
1063                             (obj, target_field_name)
1064                         )
1065                     target_ids.add(target_id)
1066                 elif isinstance(obj, Model):
1067                     raise TypeError(
1068                         "'%s' instance expected, got %r" %
1069                         (self.model._meta.object_name, obj)
1070                     )
1071                 else:
1072                     target_ids.add(target_field.get_prep_value(obj))
1073             return target_ids
1074 
1075         def _get_missing_target_ids(self, source_field_name, target_field_name, db, target_ids):
1076             """
1077             Return the subset of ids of `objs` that aren't already assigned to
1078             this relationship.
1079             """
1080             vals = self.through._default_manager.using(db).values_list(
1081                 target_field_name, flat=True
1082             ).filter(**{
1083                 source_field_name: self.related_val[0],
1084                 '%s__in' % target_field_name: target_ids,
1085             })
1086             return target_ids.difference(vals)
1087 
1088         def _get_add_plan(self, db, source_field_name):
1089             """
1090             Return a boolean triple of the way the add should be performed.
1091 
1092             The first element is whether or not bulk_create(ignore_conflicts)
1093             can be used, the second whether or not signals must be sent, and
1094             the third element is whether or not the immediate bulk insertion
1095             with conflicts ignored can be performed.
1096             """
1097             # Conflicts can be ignored when the intermediary model is
1098             # auto-created as the only possible collision is on the
1099             # (source_id, target_id) tuple. The same assertion doesn't hold for
1100             # user-defined intermediary models as they could have other fields
1101             # causing conflicts which must be surfaced.
1102             can_ignore_conflicts = (
1103                 connections[db].features.supports_ignore_conflicts and
1104                 self.through._meta.auto_created is not False
1105             )
1106             # Don't send the signal when inserting duplicate data row
1107             # for symmetrical reverse entries.
1108             must_send_signals = (self.reverse or source_field_name == self.source_field_name) and (
1109                 signals.m2m_changed.has_listeners(self.through)
1110             )
1111             # Fast addition through bulk insertion can only be performed
1112             # if no m2m_changed listeners are connected for self.through
1113             # as they require the added set of ids to be provided via
1114             # pk_set.
1115             return can_ignore_conflicts, must_send_signals, (can_ignore_conflicts and not must_send_signals)
1116 
1117         def _add_items(self, source_field_name, target_field_name, *objs, through_defaults=None):
1118             # source_field_name: the PK fieldname in join table for the source object
1119             # target_field_name: the PK fieldname in join table for the target object
1120             # *objs - objects to add. Either object instances, or primary keys of object instances.
1121             if not objs:
1122                 return
1123 
1124             through_defaults = dict(resolve_callables(through_defaults or {}))
1125             target_ids = self._get_target_ids(target_field_name, objs)
1126             db = router.db_for_write(self.through, instance=self.instance)
1127             can_ignore_conflicts, must_send_signals, can_fast_add = self._get_add_plan(db, source_field_name)
1128             if can_fast_add:
1129                 self.through._default_manager.using(db).bulk_create([
1130                     self.through(**{
1131                         '%s_id' % source_field_name: self.related_val[0],
1132                         '%s_id' % target_field_name: target_id,
1133                     })
1134                     for target_id in target_ids
1135                 ], ignore_conflicts=True)
1136                 return
1137 
1138             missing_target_ids = self._get_missing_target_ids(
1139                 source_field_name, target_field_name, db, target_ids
1140             )
1141             with transaction.atomic(using=db, savepoint=False):
1142                 if must_send_signals:
1143                     signals.m2m_changed.send(
1144                         sender=self.through, action='pre_add',
1145                         instance=self.instance, reverse=self.reverse,
1146                         model=self.model, pk_set=missing_target_ids, using=db,
1147                     )
1148                 # Add the ones that aren't there already.
1149                 self.through._default_manager.using(db).bulk_create([
1150                     self.through(**through_defaults, **{
1151                         '%s_id' % source_field_name: self.related_val[0],
1152                         '%s_id' % target_field_name: target_id,
1153                     })
1154                     for target_id in missing_target_ids
1155                 ], ignore_conflicts=can_ignore_conflicts)
1156 
1157                 if must_send_signals:
1158                     signals.m2m_changed.send(
1159                         sender=self.through, action='post_add',
1160                         instance=self.instance, reverse=self.reverse,
1161                         model=self.model, pk_set=missing_target_ids, using=db,
1162                     )
1163 
1164         def _remove_items(self, source_field_name, target_field_name, *objs):
1165             # source_field_name: the PK colname in join table for the source object
1166             # target_field_name: the PK colname in join table for the target object
1167             # *objs - objects to remove. Either object instances, or primary
1168             # keys of object instances.
1169             if not objs:
1170                 return
1171 
1172             # Check that all the objects are of the right type
1173             old_ids = set()
1174             for obj in objs:
1175                 if isinstance(obj, self.model):
1176                     fk_val = self.target_field.get_foreign_related_value(obj)[0]
1177                     old_ids.add(fk_val)
1178                 else:
1179                     old_ids.add(obj)
1180 
1181             db = router.db_for_write(self.through, instance=self.instance)
1182             with transaction.atomic(using=db, savepoint=False):
1183                 # Send a signal to the other end if need be.
1184                 signals.m2m_changed.send(
1185                     sender=self.through, action="pre_remove",
1186                     instance=self.instance, reverse=self.reverse,
1187                     model=self.model, pk_set=old_ids, using=db,
1188                 )
1189                 target_model_qs = super().get_queryset()
1190                 if target_model_qs._has_filters():
1191                     old_vals = target_model_qs.using(db).filter(**{
1192                         '%s__in' % self.target_field.target_field.attname: old_ids})
1193                 else:
1194                     old_vals = old_ids
1195                 filters = self._build_remove_filters(old_vals)
1196                 self.through._default_manager.using(db).filter(filters).delete()
1197 
1198                 signals.m2m_changed.send(
1199                     sender=self.through, action="post_remove",
1200                     instance=self.instance, reverse=self.reverse,
1201                     model=self.model, pk_set=old_ids, using=db,
1202                 )
1203 
1204     return ManyRelatedManager

</code><intended_behavior>Assess and possibly modify the handling of FK fields in the context of model instance copying. Since FK relationships are a central concern in the reported issue, ensure that any copying or cloning of model instances properly updates FK references in the newly created instance without inadvertently altering the original instance's state. This might require implementing deep copy logic specific to FK fields or enhancing how Django's model layer treats FK fields during any form of instance duplication.</intended_behavior>]
2025-10-15 05:06:23.638 | INFO     | Search completed. Bug locations: [<file>django/db/models/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import inspect
3 import warnings
4 from functools import partialmethod
5 from itertools import chain
6 
7 import django
8 from django.apps import apps
9 from django.conf import settings
10 from django.core import checks
11 from django.core.exceptions import (
12     NON_FIELD_ERRORS, FieldDoesNotExist, FieldError, MultipleObjectsReturned,
13     ObjectDoesNotExist, ValidationError,
14 )
15 from django.db import (
16     DEFAULT_DB_ALIAS, DJANGO_VERSION_PICKLE_KEY, DatabaseError, connection,
17     connections, router, transaction,
18 )
19 from django.db.models import (
20     NOT_PROVIDED, ExpressionWrapper, IntegerField, Max, Value,
21 )
22 from django.db.models.constants import LOOKUP_SEP
23 from django.db.models.constraints import CheckConstraint, UniqueConstraint
24 from django.db.models.deletion import CASCADE, Collector
25 from django.db.models.fields.related import (
26     ForeignObjectRel, OneToOneField, lazy_related_operation, resolve_relation,
27 )
28 from django.db.models.functions import Coalesce
29 from django.db.models.manager import Manager
30 from django.db.models.options import Options
31 from django.db.models.query import F, Q
32 from django.db.models.signals import (
33     class_prepared, post_init, post_save, pre_init, pre_save,
34 )
35 from django.db.models.utils import make_model_tuple
36 from django.utils.encoding import force_str
37 from django.utils.hashable import make_hashable
38 from django.utils.text import capfirst, get_text_list
39 from django.utils.translation import gettext_lazy as _
40 
41 
42 class Deferred:
43     def __repr__(self):
44         return '<Deferred field>'
45 
46     def __str__(self):
47         return '<Deferred field>'
48 
49 
50 DEFERRED = Deferred()
51 
52 
53 def subclass_exception(name, bases, module, attached_to):
54     """
55     Create exception subclass. Used by ModelBase below.
56 
57     The exception is created in a way that allows it to be pickled, assuming
58     that the returned exception class will be added as an attribute to the
59     'attached_to' class.
60     """
61     return type(name, bases, {
62         '__module__': module,
63         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
64     })
65 
66 
67 def _has_contribute_to_class(value):
68     # Only call contribute_to_class() if it's bound.
69     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
70 
71 
72 class ModelBase(type):
73     """Metaclass for all models."""
74     def __new__(cls, name, bases, attrs, **kwargs):
75         super_new = super().__new__
76 
77         # Also ensure initialization is only performed for subclasses of Model
78         # (excluding Model class itself).
79         parents = [b for b in bases if isinstance(b, ModelBase)]
80         if not parents:
81             return super_new(cls, name, bases, attrs)
82 
83         # Create the class.
84         module = attrs.pop('__module__')
85         new_attrs = {'__module__': module}
86         classcell = attrs.pop('__classcell__', None)
87         if classcell is not None:
88             new_attrs['__classcell__'] = classcell
89         attr_meta = attrs.pop('Meta', None)
90         # Pass all attrs without a (Django-specific) contribute_to_class()
91         # method to type.__new__() so that they're properly initialized
92         # (i.e. __set_name__()).
93         contributable_attrs = {}
94         for obj_name, obj in attrs.items():
95             if _has_contribute_to_class(obj):
96                 contributable_attrs[obj_name] = obj
97             else:
98                 new_attrs[obj_name] = obj
99         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
100 
101         abstract = getattr(attr_meta, 'abstract', False)
102         meta = attr_meta or getattr(new_class, 'Meta', None)
103         base_meta = getattr(new_class, '_meta', None)
104 
105         app_label = None
106 
107         # Look for an application configuration to attach the model to.
108         app_config = apps.get_containing_app_config(module)
109 
110         if getattr(meta, 'app_label', None) is None:
111             if app_config is None:
112                 if not abstract:
113                     raise RuntimeError(
114                         "Model class %s.%s doesn't declare an explicit "
115                         "app_label and isn't in an application in "
116                         "INSTALLED_APPS." % (module, name)
117                     )
118 
119             else:
120                 app_label = app_config.label
121 
122         new_class.add_to_class('_meta', Options(meta, app_label))
123         if not abstract:
124             new_class.add_to_class(
125                 'DoesNotExist',
126                 subclass_exception(
127                     'DoesNotExist',
128                     tuple(
129                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
130                     ) or (ObjectDoesNotExist,),
131                     module,
132                     attached_to=new_class))
133             new_class.add_to_class(
134                 'MultipleObjectsReturned',
135                 subclass_exception(
136                     'MultipleObjectsReturned',
137                     tuple(
138                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
139                     ) or (MultipleObjectsReturned,),
140                     module,
141                     attached_to=new_class))
142             if base_meta and not base_meta.abstract:
143                 # Non-abstract child classes inherit some attributes from their
144                 # non-abstract parent (unless an ABC comes before it in the
145                 # method resolution order).
146                 if not hasattr(meta, 'ordering'):
147                     new_class._meta.ordering = base_meta.ordering
148                 if not hasattr(meta, 'get_latest_by'):
149                     new_class._meta.get_latest_by = base_meta.get_latest_by
150 
151         is_proxy = new_class._meta.proxy
152 
153         # If the model is a proxy, ensure that the base class
154         # hasn't been swapped out.
155         if is_proxy and base_meta and base_meta.swapped:
156             raise TypeError("%s cannot proxy the swapped model '%s'." % (name, base_meta.swapped))
157 
158         # Add remaining attributes (those with a contribute_to_class() method)
159         # to the class.
160         for obj_name, obj in contributable_attrs.items():
161             new_class.add_to_class(obj_name, obj)
162 
163         # All the fields of any type declared on this model
164         new_fields = chain(
165             new_class._meta.local_fields,
166             new_class._meta.local_many_to_many,
167             new_class._meta.private_fields
168         )
169         field_names = {f.name for f in new_fields}
170 
171         # Basic setup for proxy models.
172         if is_proxy:
173             base = None
174             for parent in [kls for kls in parents if hasattr(kls, '_meta')]:
175                 if parent._meta.abstract:
176                     if parent._meta.fields:
177                         raise TypeError(
178                             "Abstract base class containing model fields not "
179                             "permitted for proxy model '%s'." % name
180                         )
181                     else:
182                         continue
183                 if base is None:
184                     base = parent
185                 elif parent._meta.concrete_model is not base._meta.concrete_model:
186                     raise TypeError("Proxy model '%s' has more than one non-abstract model base class." % name)
187             if base is None:
188                 raise TypeError("Proxy model '%s' has no non-abstract model base class." % name)
189             new_class._meta.setup_proxy(base)
190             new_class._meta.concrete_model = base._meta.concrete_model
191         else:
192             new_class._meta.concrete_model = new_class
193 
194         # Collect the parent links for multi-table inheritance.
195         parent_links = {}
196         for base in reversed([new_class] + parents):
197             # Conceptually equivalent to `if base is Model`.
198             if not hasattr(base, '_meta'):
199                 continue
200             # Skip concrete parent classes.
201             if base != new_class and not base._meta.abstract:
202                 continue
203             # Locate OneToOneField instances.
204             for field in base._meta.local_fields:
205                 if isinstance(field, OneToOneField) and field.remote_field.parent_link:
206                     related = resolve_relation(new_class, field.remote_field.model)
207                     parent_links[make_model_tuple(related)] = field
208 
209         # Track fields inherited from base models.
210         inherited_attributes = set()
211         # Do the appropriate setup for any model parents.
212         for base in new_class.mro():
213             if base not in parents or not hasattr(base, '_meta'):
214                 # Things without _meta aren't functional models, so they're
215                 # uninteresting parents.
216                 inherited_attributes.update(base.__dict__)
217                 continue
218 
219             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
220             if not base._meta.abstract:
221                 # Check for clashes between locally declared fields and those
222                 # on the base classes.
223                 for field in parent_fields:
224                     if field.name in field_names:
225                         raise FieldError(
226                             'Local field %r in class %r clashes with field of '
227                             'the same name from base class %r.' % (
228                                 field.name,
229                                 name,
230                                 base.__name__,
231                             )
232                         )
233                     else:
234                         inherited_attributes.add(field.name)
235 
236                 # Concrete classes...
237                 base = base._meta.concrete_model
238                 base_key = make_model_tuple(base)
239                 if base_key in parent_links:
240                     field = parent_links[base_key]
241                 elif not is_proxy:
242                     attr_name = '%s_ptr' % base._meta.model_name
243                     field = OneToOneField(
244                         base,
245                         on_delete=CASCADE,
246                         name=attr_name,
247                         auto_created=True,
248                         parent_link=True,
249                     )
250 
251                     if attr_name in field_names:
252                         raise FieldError(
253                             "Auto-generated field '%s' in class %r for "
254                             "parent_link to base class %r clashes with "
255                             "declared field of the same name." % (
256                                 attr_name,
257                                 name,
258                                 base.__name__,
259                             )
260                         )
261 
262                     # Only add the ptr field if it's not already present;
263                     # e.g. migrations will already have it specified
264                     if not hasattr(new_class, attr_name):
265                         new_class.add_to_class(attr_name, field)
266                 else:
267                     field = None
268                 new_class._meta.parents[base] = field
269             else:
270                 base_parents = base._meta.parents.copy()
271 
272                 # Add fields from abstract base class if it wasn't overridden.
273                 for field in parent_fields:
274                     if (field.name not in field_names and
275                             field.name not in new_class.__dict__ and
276                             field.name not in inherited_attributes):
277                         new_field = copy.deepcopy(field)
278                         new_class.add_to_class(field.name, new_field)
279                         # Replace parent links defined on this base by the new
280                         # field. It will be appropriately resolved if required.
281                         if field.one_to_one:
282                             for parent, parent_link in base_parents.items():
283                                 if field == parent_link:
284                                     base_parents[parent] = new_field
285 
286                 # Pass any non-abstract parent classes onto child.
287                 new_class._meta.parents.update(base_parents)
288 
289             # Inherit private fields (like GenericForeignKey) from the parent
290             # class
291             for field in base._meta.private_fields:
292                 if field.name in field_names:
293                     if not base._meta.abstract:
294                         raise FieldError(
295                             'Local field %r in class %r clashes with field of '
296                             'the same name from base class %r.' % (
297                                 field.name,
298                                 name,
299                                 base.__name__,
300                             )
301                         )
302                 else:
303                     field = copy.deepcopy(field)
304                     if not base._meta.abstract:
305                         field.mti_inherited = True
306                     new_class.add_to_class(field.name, field)
307 
308         # Copy indexes so that index names are unique when models extend an
309         # abstract model.
310         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
311 
312         if abstract:
313             # Abstract base models can't be instantiated and don't appear in
314             # the list of models for an app. We do the final setup for them a
315             # little differently from normal models.
316             attr_meta.abstract = False
317             new_class.Meta = attr_meta
318             return new_class
319 
320         new_class._prepare()
321         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
322         return new_class
323 
324     def add_to_class(cls, name, value):
325         if _has_contribute_to_class(value):
326             value.contribute_to_class(cls, name)
327         else:
328             setattr(cls, name, value)
329 
330     def _prepare(cls):
331         """Create some methods once self._meta has been populated."""
332         opts = cls._meta
333         opts._prepare(cls)
334 
335         if opts.order_with_respect_to:
336             cls.get_next_in_order = partialmethod(cls._get_next_or_previous_in_order, is_next=True)
337             cls.get_previous_in_order = partialmethod(cls._get_next_or_previous_in_order, is_next=False)
338 
339             # Defer creating accessors on the foreign class until it has been
340             # created and registered. If remote_field is None, we're ordering
341             # with respect to a GenericForeignKey and don't know what the
342             # foreign class is - we'll add those accessors later in
343             # contribute_to_class().
344             if opts.order_with_respect_to.remote_field:
345                 wrt = opts.order_with_respect_to
346                 remote = wrt.remote_field.model
347                 lazy_related_operation(make_foreign_order_accessors, cls, remote)
348 
349         # Give the class a docstring -- its definition.
350         if cls.__doc__ is None:
351             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
352 
353         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
354         if get_absolute_url_override:
355             setattr(cls, 'get_absolute_url', get_absolute_url_override)
356 
357         if not opts.managers:
358             if any(f.name == 'objects' for f in opts.fields):
359                 raise ValueError(
360                     "Model %s must specify a custom Manager, because it has a "
361                     "field named 'objects'." % cls.__name__
362                 )
363             manager = Manager()
364             manager.auto_created = True
365             cls.add_to_class('objects', manager)
366 
367         # Set the name of _meta.indexes. This can't be done in
368         # Options.contribute_to_class() because fields haven't been added to
369         # the model at that point.
370         for index in cls._meta.indexes:
371             if not index.name:
372                 index.set_name_with_model(cls)
373 
374         class_prepared.send(sender=cls)
375 
376     @property
377     def _base_manager(cls):
378         return cls._meta.base_manager
379 
380     @property
381     def _default_manager(cls):
382         return cls._meta.default_manager
383 
384 
385 class ModelStateFieldsCacheDescriptor:
386     def __get__(self, instance, cls=None):
387         if instance is None:
388             return self
389         res = instance.fields_cache = {}
390         return res
391 
392 
393 class ModelState:
394     """Store model instance state."""
395     db = None
396     # If true, uniqueness validation checks will consider this a new, unsaved
397     # object. Necessary for correct validation of new instances of objects with
398     # explicit (non-auto) PKs. This impacts validation only; it has no effect
399     # on the actual save.
400     adding = True
401     fields_cache = ModelStateFieldsCacheDescriptor()
402 
403 
404 class Model(metaclass=ModelBase):
405 
406     def __init__(self, *args, **kwargs):
407         # Alias some things as locals to avoid repeat global lookups
408         cls = self.__class__
409         opts = self._meta
410         _setattr = setattr
411         _DEFERRED = DEFERRED
412         if opts.abstract:
413             raise TypeError('Abstract models cannot be instantiated.')
414 
415         pre_init.send(sender=cls, args=args, kwargs=kwargs)
416 
417         # Set up the storage for instance state
418         self._state = ModelState()
419 
420         # There is a rather weird disparity here; if kwargs, it's set, then args
421         # overrides it. It should be one or the other; don't duplicate the work
422         # The reason for the kwargs check is that standard iterator passes in by
423         # args, and instantiation for iteration is 33% faster.
424         if len(args) > len(opts.concrete_fields):
425             # Daft, but matches old exception sans the err msg.
426             raise IndexError("Number of args exceeds number of fields")
427 
428         if not kwargs:
429             fields_iter = iter(opts.concrete_fields)
430             # The ordering of the zip calls matter - zip throws StopIteration
431             # when an iter throws it. So if the first iter throws it, the second
432             # is *not* consumed. We rely on this, so don't change the order
433             # without changing the logic.
434             for val, field in zip(args, fields_iter):
435                 if val is _DEFERRED:
436                     continue
437                 _setattr(self, field.attname, val)
438         else:
439             # Slower, kwargs-ready version.
440             fields_iter = iter(opts.fields)
441             for val, field in zip(args, fields_iter):
442                 if val is _DEFERRED:
443                     continue
444                 _setattr(self, field.attname, val)
445                 kwargs.pop(field.name, None)
446 
447         # Now we're left with the unprocessed fields that *must* come from
448         # keywords, or default.
449 
450         for field in fields_iter:
451             is_related_object = False
452             # Virtual field
453             if field.attname not in kwargs and field.column is None:
454                 continue
455             if kwargs:
456                 if isinstance(field.remote_field, ForeignObjectRel):
457                     try:
458                         # Assume object instance was passed in.
459                         rel_obj = kwargs.pop(field.name)
460                         is_related_object = True
461                     except KeyError:
462                         try:
463                             # Object instance wasn't passed in -- must be an ID.
464                             val = kwargs.pop(field.attname)
465                         except KeyError:
466                             val = field.get_default()
467                 else:
468                     try:
469                         val = kwargs.pop(field.attname)
470                     except KeyError:
471                         # This is done with an exception rather than the
472                         # default argument on pop because we don't want
473                         # get_default() to be evaluated, and then not used.
474                         # Refs #12057.
475                         val = field.get_default()
476             else:
477                 val = field.get_default()
478 
479             if is_related_object:
480                 # If we are passed a related instance, set it using the
481                 # field.name instead of field.attname (e.g. "user" instead of
482                 # "user_id") so that the object gets properly cached (and type
483                 # checked) by the RelatedObjectDescriptor.
484                 if rel_obj is not _DEFERRED:
485                     _setattr(self, field.name, rel_obj)
486             else:
487                 if val is not _DEFERRED:
488                     _setattr(self, field.attname, val)
489 
490         if kwargs:
491             property_names = opts._property_names
492             for prop in tuple(kwargs):
493                 try:
494                     # Any remaining kwargs must correspond to properties or
495                     # virtual fields.
496                     if prop in property_names or opts.get_field(prop):
497                         if kwargs[prop] is not _DEFERRED:
498                             _setattr(self, prop, kwargs[prop])
499                         del kwargs[prop]
500                 except (AttributeError, FieldDoesNotExist):
501                     pass
502             for kwarg in kwargs:
503                 raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
504         super().__init__()
505         post_init.send(sender=cls, instance=self)
506 
507     @classmethod
508     def from_db(cls, db, field_names, values):
509         if len(values) != len(cls._meta.concrete_fields):
510             values_iter = iter(values)
511             values = [
512                 next(values_iter) if f.attname in field_names else DEFERRED
513                 for f in cls._meta.concrete_fields
514             ]
515         new = cls(*values)
516         new._state.adding = False
517         new._state.db = db
518         return new
519 
520     def __repr__(self):
521         return '<%s: %s>' % (self.__class__.__name__, self)
522 
523     def __str__(self):
524         return '%s object (%s)' % (self.__class__.__name__, self.pk)
525 
526     def __eq__(self, other):
527         if not isinstance(other, Model):
528             return NotImplemented
529         if self._meta.concrete_model != other._meta.concrete_model:
530             return False
531         my_pk = self.pk
532         if my_pk is None:
533             return self is other
534         return my_pk == other.pk
535 
536     def __hash__(self):
537         if self.pk is None:
538             raise TypeError("Model instances without primary key value are unhashable")
539         return hash(self.pk)
540 
541     def __reduce__(self):
542         data = self.__getstate__()
543         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
544         class_id = self._meta.app_label, self._meta.object_name
545         return model_unpickle, (class_id,), data
546 
547     def __getstate__(self):
548         """Hook to allow choosing the attributes to pickle."""
549         return self.__dict__
550 
551     def __setstate__(self, state):
552         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
553         if pickled_version:
554             if pickled_version != django.__version__:
555                 warnings.warn(
556                     "Pickled model instance's Django version %s does not "
557                     "match the current version %s."
558                     % (pickled_version, django.__version__),
559                     RuntimeWarning,
560                     stacklevel=2,
561                 )
562         else:
563             warnings.warn(
564                 "Pickled model instance's Django version is not specified.",
565                 RuntimeWarning,
566                 stacklevel=2,
567             )
568         self.__dict__.update(state)
569 
570     def _get_pk_val(self, meta=None):
571         meta = meta or self._meta
572         return getattr(self, meta.pk.attname)
573 
574     def _set_pk_val(self, value):
575         for parent_link in self._meta.parents.values():
576             if parent_link and parent_link != self._meta.pk:
577                 setattr(self, parent_link.target_field.attname, value)
578         return setattr(self, self._meta.pk.attname, value)
579 
580     pk = property(_get_pk_val, _set_pk_val)
581 
582     def get_deferred_fields(self):
583         """
584         Return a set containing names of deferred fields for this instance.
585         """
586         return {
587             f.attname for f in self._meta.concrete_fields
588             if f.attname not in self.__dict__
589         }
590 
591     def refresh_from_db(self, using=None, fields=None):
592         """
593         Reload field values from the database.
594 
595         By default, the reloading happens from the database this instance was
596         loaded from, or by the read router if this instance wasn't loaded from
597         any database. The using parameter will override the default.
598 
599         Fields can be used to specify which fields to reload. The fields
600         should be an iterable of field attnames. If fields is None, then
601         all non-deferred fields are reloaded.
602 
603         When accessing deferred fields of an instance, the deferred loading
604         of the field will call this method.
605         """
606         if fields is None:
607             self._prefetched_objects_cache = {}
608         else:
609             prefetched_objects_cache = getattr(self, '_prefetched_objects_cache', ())
610             for field in fields:
611                 if field in prefetched_objects_cache:
612                     del prefetched_objects_cache[field]
613                     fields.remove(field)
614             if not fields:
615                 return
616             if any(LOOKUP_SEP in f for f in fields):
617                 raise ValueError(
618                     'Found "%s" in fields argument. Relations and transforms '
619                     'are not allowed in fields.' % LOOKUP_SEP)
620 
621         hints = {'instance': self}
622         db_instance_qs = self.__class__._base_manager.db_manager(using, hints=hints).filter(pk=self.pk)
623 
624         # Use provided fields, if not set then reload all non-deferred fields.
625         deferred_fields = self.get_deferred_fields()
626         if fields is not None:
627             fields = list(fields)
628             db_instance_qs = db_instance_qs.only(*fields)
629         elif deferred_fields:
630             fields = [f.attname for f in self._meta.concrete_fields
631                       if f.attname not in deferred_fields]
632             db_instance_qs = db_instance_qs.only(*fields)
633 
634         db_instance = db_instance_qs.get()
635         non_loaded_fields = db_instance.get_deferred_fields()
636         for field in self._meta.concrete_fields:
637             if field.attname in non_loaded_fields:
638                 # This field wasn't refreshed - skip ahead.
639                 continue
640             setattr(self, field.attname, getattr(db_instance, field.attname))
641             # Clear cached foreign keys.
642             if field.is_relation and field.is_cached(self):
643                 field.delete_cached_value(self)
644 
645         # Clear cached relations.
646         for field in self._meta.related_objects:
647             if field.is_cached(self):
648                 field.delete_cached_value(self)
649 
650         self._state.db = db_instance._state.db
651 
652     def serializable_value(self, field_name):
653         """
654         Return the value of the field name for this instance. If the field is
655         a foreign key, return the id value instead of the object. If there's
656         no Field object with this name on the model, return the model
657         attribute's value.
658 
659         Used to serialize a field's value (in the serializer, or form output,
660         for example). Normally, you would just access the attribute directly
661         and not use this method.
662         """
663         try:
664             field = self._meta.get_field(field_name)
665         except FieldDoesNotExist:
666             return getattr(self, field_name)
667         return getattr(self, field.attname)
668 
669     def save(self, force_insert=False, force_update=False, using=None,
670              update_fields=None):
671         """
672         Save the current instance. Override this in a subclass if you want to
673         control the saving process.
674 
675         The 'force_insert' and 'force_update' parameters can be used to insist
676         that the "save" must be an SQL insert or update (or equivalent for
677         non-SQL backends), respectively. Normally, they should not be set.
678         """
679         # Ensure that a model instance without a PK hasn't been assigned to
680         # a ForeignKey or OneToOneField on this model. If the field is
681         # nullable, allowing the save() would result in silent data loss.
682         for field in self._meta.concrete_fields:
683             # If the related field isn't cached, then an instance hasn't
684             # been assigned and there's no need to worry about this check.
685             if field.is_relation and field.is_cached(self):
686                 obj = getattr(self, field.name, None)
687                 if not obj:
688                     continue
689                 # A pk may have been assigned manually to a model instance not
690                 # saved to the database (or auto-generated in a case like
691                 # UUIDField), but we allow the save to proceed and rely on the
692                 # database to raise an IntegrityError if applicable. If
693                 # constraints aren't supported by the database, there's the
694                 # unavoidable risk of data corruption.
695                 if obj.pk is None:
696                     # Remove the object from a related instance cache.
697                     if not field.remote_field.multiple:
698                         field.remote_field.delete_cached_value(obj)
699                     raise ValueError(
700                         "save() prohibited to prevent data loss due to "
701                         "unsaved related object '%s'." % field.name
702                     )
703                 elif getattr(self, field.attname) is None:
704                     # Use pk from related object if it has been saved after
705                     # an assignment.
706                     setattr(self, field.attname, obj.pk)
707                 # If the relationship's pk/to_field was changed, clear the
708                 # cached relationship.
709                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):
710                     field.delete_cached_value(self)
711 
712         using = using or router.db_for_write(self.__class__, instance=self)
713         if force_insert and (force_update or update_fields):
714             raise ValueError("Cannot force both insert and updating in model saving.")
715 
716         deferred_fields = self.get_deferred_fields()
717         if update_fields is not None:
718             # If update_fields is empty, skip the save. We do also check for
719             # no-op saves later on for inheritance cases. This bailout is
720             # still needed for skipping signal sending.
721             if not update_fields:
722                 return
723 
724             update_fields = frozenset(update_fields)
725             field_names = set()
726 
727             for field in self._meta.fields:
728                 if not field.primary_key:
729                     field_names.add(field.name)
730 
731                     if field.name != field.attname:
732                         field_names.add(field.attname)
733 
734             non_model_fields = update_fields.difference(field_names)
735 
736             if non_model_fields:
737                 raise ValueError("The following fields do not exist in this "
738                                  "model or are m2m fields: %s"
739                                  % ', '.join(non_model_fields))
740 
741         # If saving to the same database, and this model is deferred, then
742         # automatically do an "update_fields" save on the loaded fields.
743         elif not force_insert and deferred_fields and using == self._state.db:
744             field_names = set()
745             for field in self._meta.concrete_fields:
746                 if not field.primary_key and not hasattr(field, 'through'):
747                     field_names.add(field.attname)
748             loaded_fields = field_names.difference(deferred_fields)
749             if loaded_fields:
750                 update_fields = frozenset(loaded_fields)
751 
752         self.save_base(using=using, force_insert=force_insert,
753                        force_update=force_update, update_fields=update_fields)
754     save.alters_data = True
755 
756     def save_base(self, raw=False, force_insert=False,
757                   force_update=False, using=None, update_fields=None):
758         """
759         Handle the parts of saving which should be done only once per save,
760         yet need to be done in raw saves, too. This includes some sanity
761         checks and signal sending.
762 
763         The 'raw' argument is telling save_base not to save any parent
764         models and not to do any changes to the values before save. This
765         is used by fixture loading.
766         """
767         using = using or router.db_for_write(self.__class__, instance=self)
768         assert not (force_insert and (force_update or update_fields))
769         assert update_fields is None or update_fields
770         cls = origin = self.__class__
771         # Skip proxies, but keep the origin as the proxy model.
772         if cls._meta.proxy:
773             cls = cls._meta.concrete_model
774         meta = cls._meta
775         if not meta.auto_created:
776             pre_save.send(
777                 sender=origin, instance=self, raw=raw, using=using,
778                 update_fields=update_fields,
779             )
780         # A transaction isn't needed if one query is issued.
781         if meta.parents:
782             context_manager = transaction.atomic(using=using, savepoint=False)
783         else:
784             context_manager = transaction.mark_for_rollback_on_error(using=using)
785         with context_manager:
786             parent_inserted = False
787             if not raw:
788                 parent_inserted = self._save_parents(cls, using, update_fields)
789             updated = self._save_table(
790                 raw, cls, force_insert or parent_inserted,
791                 force_update, using, update_fields,
792             )
793         # Store the database on which the object was saved
794         self._state.db = using
795         # Once saved, this is no longer a to-be-added instance.
796         self._state.adding = False
797 
798         # Signal that the save is complete
799         if not meta.auto_created:
800             post_save.send(
801                 sender=origin, instance=self, created=(not updated),
802                 update_fields=update_fields, raw=raw, using=using,
803             )
804 
805     save_base.alters_data = True
806 
807     def _save_parents(self, cls, using, update_fields):
808         """Save all the parents of cls using values from self."""
809         meta = cls._meta
810         inserted = False
811         for parent, field in meta.parents.items():
812             # Make sure the link fields are synced between parent and self.
813             if (field and getattr(self, parent._meta.pk.attname) is None and
814                     getattr(self, field.attname) is not None):
815                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
816             parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)
817             updated = self._save_table(
818                 cls=parent, using=using, update_fields=update_fields,
819                 force_insert=parent_inserted,
820             )
821             if not updated:
822                 inserted = True
823             # Set the parent's PK value to self.
824             if field:
825                 setattr(self, field.attname, self._get_pk_val(parent._meta))
826                 # Since we didn't have an instance of the parent handy set
827                 # attname directly, bypassing the descriptor. Invalidate
828                 # the related object cache, in case it's been accidentally
829                 # populated. A fresh instance will be re-built from the
830                 # database if necessary.
831                 if field.is_cached(self):
832                     field.delete_cached_value(self)
833         return inserted
834 
835     def _save_table(self, raw=False, cls=None, force_insert=False,
836                     force_update=False, using=None, update_fields=None):
837         """
838         Do the heavy-lifting involved in saving. Update or insert the data
839         for a single table.
840         """
841         meta = cls._meta
842         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
843 
844         if update_fields:
845             non_pks = [f for f in non_pks
846                        if f.name in update_fields or f.attname in update_fields]
847 
848         pk_val = self._get_pk_val(meta)
849         if pk_val is None:
850             pk_val = meta.pk.get_pk_value_on_save(self)
851             setattr(self, meta.pk.attname, pk_val)
852         pk_set = pk_val is not None
853         if not pk_set and (force_update or update_fields):
854             raise ValueError("Cannot force an update in save() with no primary key.")
855         updated = False
856         # Skip an UPDATE when adding an instance and primary key has a default.
857         if (
858             not raw and
859             not force_insert and
860             self._state.adding and
861             meta.pk.default and
862             meta.pk.default is not NOT_PROVIDED
863         ):
864             force_insert = True
865         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
866         if pk_set and not force_insert:
867             base_qs = cls._base_manager.using(using)
868             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
869                       for f in non_pks]
870             forced_update = update_fields or force_update
871             updated = self._do_update(base_qs, using, pk_val, values, update_fields,
872                                       forced_update)
873             if force_update and not updated:
874                 raise DatabaseError("Forced update did not affect any rows.")
875             if update_fields and not updated:
876                 raise DatabaseError("Save with update_fields did not affect any rows.")
877         if not updated:
878             if meta.order_with_respect_to:
879                 # If this is a model with an order_with_respect_to
880                 # autopopulate the _order field
881                 field = meta.order_with_respect_to
882                 filter_args = field.get_filter_kwargs_for_object(self)
883                 self._order = cls._base_manager.using(using).filter(**filter_args).aggregate(
884                     _order__max=Coalesce(
885                         ExpressionWrapper(Max('_order') + Value(1), output_field=IntegerField()),
886                         Value(0),
887                     ),
888                 )['_order__max']
889             fields = meta.local_concrete_fields
890             if not pk_set:
891                 fields = [f for f in fields if f is not meta.auto_field]
892 
893             returning_fields = meta.db_returning_fields
894             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
895             if results:
896                 for value, field in zip(results[0], returning_fields):
897                     setattr(self, field.attname, value)
898         return updated
899 
900     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
901         """
902         Try to update the model. Return True if the model was updated (if an
903         update query was done and a matching row was found in the DB).
904         """
905         filtered = base_qs.filter(pk=pk_val)
906         if not values:
907             # We can end up here when saving a model in inheritance chain where
908             # update_fields doesn't target any field in current model. In that
909             # case we just say the update succeeded. Another case ending up here
910             # is a model with just PK - in that case check that the PK still
911             # exists.
912             return update_fields is not None or filtered.exists()
913         if self._meta.select_on_save and not forced_update:
914             return (
915                 filtered.exists() and
916                 # It may happen that the object is deleted from the DB right after
917                 # this check, causing the subsequent UPDATE to return zero matching
918                 # rows. The same result can occur in some rare cases when the
919                 # database returns zero despite the UPDATE being executed
920                 # successfully (a row is matched and updated). In order to
921                 # distinguish these two cases, the object's existence in the
922                 # database is again checked for if the UPDATE query returns 0.
923                 (filtered._update(values) > 0 or filtered.exists())
924             )
925         return filtered._update(values) > 0
926 
927     def _do_insert(self, manager, using, fields, returning_fields, raw):
928         """
929         Do an INSERT. If returning_fields is defined then this method should
930         return the newly created data for the model.
931         """
932         return manager._insert(
933             [self], fields=fields, returning_fields=returning_fields,
934             using=using, raw=raw,
935         )
936 
937     def delete(self, using=None, keep_parents=False):
938         using = using or router.db_for_write(self.__class__, instance=self)
939         assert self.pk is not None, (
940             "%s object can't be deleted because its %s attribute is set to None." %
941             (self._meta.object_name, self._meta.pk.attname)
942         )
943 
944         collector = Collector(using=using)
945         collector.collect([self], keep_parents=keep_parents)
946         return collector.delete()
947 
948     delete.alters_data = True
949 
950     def _get_FIELD_display(self, field):
951         value = getattr(self, field.attname)
952         choices_dict = dict(make_hashable(field.flatchoices))
953         # force_str() to coerce lazy strings.
954         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)
955 
956     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
957         if not self.pk:
958             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
959         op = 'gt' if is_next else 'lt'
960         order = '' if is_next else '-'
961         param = getattr(self, field.attname)
962         q = Q(**{'%s__%s' % (field.name, op): param})
963         q = q | Q(**{field.name: param, 'pk__%s' % op: self.pk})
964         qs = self.__class__._default_manager.using(self._state.db).filter(**kwargs).filter(q).order_by(
965             '%s%s' % (order, field.name), '%spk' % order
966         )
967         try:
968             return qs[0]
969         except IndexError:
970             raise self.DoesNotExist("%s matching query does not exist." % self.__class__._meta.object_name)
971 
972     def _get_next_or_previous_in_order(self, is_next):
973         cachename = "__%s_order_cache" % is_next
974         if not hasattr(self, cachename):
975             op = 'gt' if is_next else 'lt'
976             order = '_order' if is_next else '-_order'
977             order_field = self._meta.order_with_respect_to
978             filter_args = order_field.get_filter_kwargs_for_object(self)
979             obj = self.__class__._default_manager.filter(**filter_args).filter(**{
980                 '_order__%s' % op: self.__class__._default_manager.values('_order').filter(**{
981                     self._meta.pk.name: self.pk
982                 })
983             }).order_by(order)[:1].get()
984             setattr(self, cachename, obj)
985         return getattr(self, cachename)
986 
987     def prepare_database_save(self, field):
988         if self.pk is None:
989             raise ValueError("Unsaved model instance %r cannot be used in an ORM query." % self)
990         return getattr(self, field.remote_field.get_related_field().attname)
991 
992     def clean(self):
993         """
994         Hook for doing any extra model-wide validation after clean() has been
995         called on every field by self.clean_fields. Any ValidationError raised
996         by this method will not be associated with a particular field; it will
997         have a special-case association with the field defined by NON_FIELD_ERRORS.
998         """
999         pass
1000 
1001     def validate_unique(self, exclude=None):
1002         """
1003         Check unique constraints on the model and raise ValidationError if any
1004         failed.
1005         """
1006         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1007 
1008         errors = self._perform_unique_checks(unique_checks)
1009         date_errors = self._perform_date_checks(date_checks)
1010 
1011         for k, v in date_errors.items():
1012             errors.setdefault(k, []).extend(v)
1013 
1014         if errors:
1015             raise ValidationError(errors)
1016 
1017     def _get_unique_checks(self, exclude=None):
1018         """
1019         Return a list of checks to perform. Since validate_unique() could be
1020         called from a ModelForm, some fields may have been excluded; we can't
1021         perform a unique check on a model that is missing fields involved
1022         in that check. Fields that did not validate should also be excluded,
1023         but they need to be passed in via the exclude argument.
1024         """
1025         if exclude is None:
1026             exclude = []
1027         unique_checks = []
1028 
1029         unique_togethers = [(self.__class__, self._meta.unique_together)]
1030         constraints = [(self.__class__, self._meta.total_unique_constraints)]
1031         for parent_class in self._meta.get_parent_list():
1032             if parent_class._meta.unique_together:
1033                 unique_togethers.append((parent_class, parent_class._meta.unique_together))
1034             if parent_class._meta.total_unique_constraints:
1035                 constraints.append(
1036                     (parent_class, parent_class._meta.total_unique_constraints)
1037                 )
1038 
1039         for model_class, unique_together in unique_togethers:
1040             for check in unique_together:
1041                 if not any(name in exclude for name in check):
1042                     # Add the check if the field isn't excluded.
1043                     unique_checks.append((model_class, tuple(check)))
1044 
1045         for model_class, model_constraints in constraints:
1046             for constraint in model_constraints:
1047                 if not any(name in exclude for name in constraint.fields):
1048                     unique_checks.append((model_class, constraint.fields))
1049 
1050         # These are checks for the unique_for_<date/year/month>.
1051         date_checks = []
1052 
1053         # Gather a list of checks for fields declared as unique and add them to
1054         # the list of checks.
1055 
1056         fields_with_class = [(self.__class__, self._meta.local_fields)]
1057         for parent_class in self._meta.get_parent_list():
1058             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1059 
1060         for model_class, fields in fields_with_class:
1061             for f in fields:
1062                 name = f.name
1063                 if name in exclude:
1064                     continue
1065                 if f.unique:
1066                     unique_checks.append((model_class, (name,)))
1067                 if f.unique_for_date and f.unique_for_date not in exclude:
1068                     date_checks.append((model_class, 'date', name, f.unique_for_date))
1069                 if f.unique_for_year and f.unique_for_year not in exclude:
1070                     date_checks.append((model_class, 'year', name, f.unique_for_year))
1071                 if f.unique_for_month and f.unique_for_month not in exclude:
1072                     date_checks.append((model_class, 'month', name, f.unique_for_month))
1073         return unique_checks, date_checks
1074 
1075     def _perform_unique_checks(self, unique_checks):
1076         errors = {}
1077 
1078         for model_class, unique_check in unique_checks:
1079             # Try to look up an existing object with the same values as this
1080             # object's values for all the unique field.
1081 
1082             lookup_kwargs = {}
1083             for field_name in unique_check:
1084                 f = self._meta.get_field(field_name)
1085                 lookup_value = getattr(self, f.attname)
1086                 # TODO: Handle multiple backends with different feature flags.
1087                 if (lookup_value is None or
1088                         (lookup_value == '' and connection.features.interprets_empty_strings_as_nulls)):
1089                     # no value, skip the lookup
1090                     continue
1091                 if f.primary_key and not self._state.adding:
1092                     # no need to check for unique primary key when editing
1093                     continue
1094                 lookup_kwargs[str(field_name)] = lookup_value
1095 
1096             # some fields were skipped, no reason to do the check
1097             if len(unique_check) != len(lookup_kwargs):
1098                 continue
1099 
1100             qs = model_class._default_manager.filter(**lookup_kwargs)
1101 
1102             # Exclude the current object from the query if we are editing an
1103             # instance (as opposed to creating a new one)
1104             # Note that we need to use the pk as defined by model_class, not
1105             # self.pk. These can be different fields because model inheritance
1106             # allows single model to have effectively multiple primary keys.
1107             # Refs #17615.
1108             model_class_pk = self._get_pk_val(model_class._meta)
1109             if not self._state.adding and model_class_pk is not None:
1110                 qs = qs.exclude(pk=model_class_pk)
1111             if qs.exists():
1112                 if len(unique_check) == 1:
1113                     key = unique_check[0]
1114                 else:
1115                     key = NON_FIELD_ERRORS
1116                 errors.setdefault(key, []).append(self.unique_error_message(model_class, unique_check))
1117 
1118         return errors
1119 
1120     def _perform_date_checks(self, date_checks):
1121         errors = {}
1122         for model_class, lookup_type, field, unique_for in date_checks:
1123             lookup_kwargs = {}
1124             # there's a ticket to add a date lookup, we can remove this special
1125             # case if that makes it's way in
1126             date = getattr(self, unique_for)
1127             if date is None:
1128                 continue
1129             if lookup_type == 'date':
1130                 lookup_kwargs['%s__day' % unique_for] = date.day
1131                 lookup_kwargs['%s__month' % unique_for] = date.month
1132                 lookup_kwargs['%s__year' % unique_for] = date.year
1133             else:
1134                 lookup_kwargs['%s__%s' % (unique_for, lookup_type)] = getattr(date, lookup_type)
1135             lookup_kwargs[field] = getattr(self, field)
1136 
1137             qs = model_class._default_manager.filter(**lookup_kwargs)
1138             # Exclude the current object from the query if we are editing an
1139             # instance (as opposed to creating a new one)
1140             if not self._state.adding and self.pk is not None:
1141                 qs = qs.exclude(pk=self.pk)
1142 
1143             if qs.exists():
1144                 errors.setdefault(field, []).append(
1145                     self.date_error_message(lookup_type, field, unique_for)
1146                 )
1147         return errors
1148 
1149     def date_error_message(self, lookup_type, field_name, unique_for):
1150         opts = self._meta
1151         field = opts.get_field(field_name)
1152         return ValidationError(
1153             message=field.error_messages['unique_for_date'],
1154             code='unique_for_date',
1155             params={
1156                 'model': self,
1157                 'model_name': capfirst(opts.verbose_name),
1158                 'lookup_type': lookup_type,
1159                 'field': field_name,
1160                 'field_label': capfirst(field.verbose_name),
1161                 'date_field': unique_for,
1162                 'date_field_label': capfirst(opts.get_field(unique_for).verbose_name),
1163             }
1164         )
1165 
1166     def unique_error_message(self, model_class, unique_check):
1167         opts = model_class._meta
1168 
1169         params = {
1170             'model': self,
1171             'model_class': model_class,
1172             'model_name': capfirst(opts.verbose_name),
1173             'unique_check': unique_check,
1174         }
1175 
1176         # A unique field
1177         if len(unique_check) == 1:
1178             field = opts.get_field(unique_check[0])
1179             params['field_label'] = capfirst(field.verbose_name)
1180             return ValidationError(
1181                 message=field.error_messages['unique'],
1182                 code='unique',
1183                 params=params,
1184             )
1185 
1186         # unique_together
1187         else:
1188             field_labels = [capfirst(opts.get_field(f).verbose_name) for f in unique_check]
1189             params['field_labels'] = get_text_list(field_labels, _('and'))
1190             return ValidationError(
1191                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1192                 code='unique_together',
1193                 params=params,
1194             )
1195 
1196     def full_clean(self, exclude=None, validate_unique=True):
1197         """
1198         Call clean_fields(), clean(), and validate_unique() on the model.
1199         Raise a ValidationError for any errors that occur.
1200         """
1201         errors = {}
1202         if exclude is None:
1203             exclude = []
1204         else:
1205             exclude = list(exclude)
1206 
1207         try:
1208             self.clean_fields(exclude=exclude)
1209         except ValidationError as e:
1210             errors = e.update_error_dict(errors)
1211 
1212         # Form.clean() is run even if other validation fails, so do the
1213         # same with Model.clean() for consistency.
1214         try:
1215             self.clean()
1216         except ValidationError as e:
1217             errors = e.update_error_dict(errors)
1218 
1219         # Run unique checks, but only for fields that passed validation.
1220         if validate_unique:
1221             for name in errors:
1222                 if name != NON_FIELD_ERRORS and name not in exclude:
1223                     exclude.append(name)
1224             try:
1225                 self.validate_unique(exclude=exclude)
1226             except ValidationError as e:
1227                 errors = e.update_error_dict(errors)
1228 
1229         if errors:
1230             raise ValidationError(errors)
1231 
1232     def clean_fields(self, exclude=None):
1233         """
1234         Clean all fields and raise a ValidationError containing a dict
1235         of all validation errors if any occur.
1236         """
1237         if exclude is None:
1238             exclude = []
1239 
1240         errors = {}
1241         for f in self._meta.fields:
1242             if f.name in exclude:
1243                 continue
1244             # Skip validation for empty fields with blank=True. The developer
1245             # is responsible for making sure they have a valid value.
1246             raw_value = getattr(self, f.attname)
1247             if f.blank and raw_value in f.empty_values:
1248                 continue
1249             try:
1250                 setattr(self, f.attname, f.clean(raw_value, self))
1251             except ValidationError as e:
1252                 errors[f.name] = e.error_list
1253 
1254         if errors:
1255             raise ValidationError(errors)
1256 
1257     @classmethod
1258     def check(cls, **kwargs):
1259         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1260         if not cls._meta.swapped:
1261             databases = kwargs.get('databases') or []
1262             errors += [
1263                 *cls._check_fields(**kwargs),
1264                 *cls._check_m2m_through_same_relationship(),
1265                 *cls._check_long_column_names(databases),
1266             ]
1267             clash_errors = (
1268                 *cls._check_id_field(),
1269                 *cls._check_field_name_clashes(),
1270                 *cls._check_model_name_db_lookup_clashes(),
1271                 *cls._check_property_name_related_field_accessor_clashes(),
1272                 *cls._check_single_primary_key(),
1273             )
1274             errors.extend(clash_errors)
1275             # If there are field name clashes, hide consequent column name
1276             # clashes.
1277             if not clash_errors:
1278                 errors.extend(cls._check_column_name_clashes())
1279             errors += [
1280                 *cls._check_index_together(),
1281                 *cls._check_unique_together(),
1282                 *cls._check_indexes(databases),
1283                 *cls._check_ordering(),
1284                 *cls._check_constraints(databases),
1285             ]
1286 
1287         return errors
1288 
1289     @classmethod
1290     def _check_swappable(cls):
1291         """Check if the swapped model exists."""
1292         errors = []
1293         if cls._meta.swapped:
1294             try:
1295                 apps.get_model(cls._meta.swapped)
1296             except ValueError:
1297                 errors.append(
1298                     checks.Error(
1299                         "'%s' is not of the form 'app_label.app_name'." % cls._meta.swappable,
1300                         id='models.E001',
1301                     )
1302                 )
1303             except LookupError:
1304                 app_label, model_name = cls._meta.swapped.split('.')
1305                 errors.append(
1306                     checks.Error(
1307                         "'%s' references '%s.%s', which has not been "
1308                         "installed, or is abstract." % (
1309                             cls._meta.swappable, app_label, model_name
1310                         ),
1311                         id='models.E002',
1312                     )
1313                 )
1314         return errors
1315 
1316     @classmethod
1317     def _check_model(cls):
1318         errors = []
1319         if cls._meta.proxy:
1320             if cls._meta.local_fields or cls._meta.local_many_to_many:
1321                 errors.append(
1322                     checks.Error(
1323                         "Proxy model '%s' contains model fields." % cls.__name__,
1324                         id='models.E017',
1325                     )
1326                 )
1327         return errors
1328 
1329     @classmethod
1330     def _check_managers(cls, **kwargs):
1331         """Perform all manager checks."""
1332         errors = []
1333         for manager in cls._meta.managers:
1334             errors.extend(manager.check(**kwargs))
1335         return errors
1336 
1337     @classmethod
1338     def _check_fields(cls, **kwargs):
1339         """Perform all field checks."""
1340         errors = []
1341         for field in cls._meta.local_fields:
1342             errors.extend(field.check(**kwargs))
1343         for field in cls._meta.local_many_to_many:
1344             errors.extend(field.check(from_model=cls, **kwargs))
1345         return errors
1346 
1347     @classmethod
1348     def _check_m2m_through_same_relationship(cls):
1349         """ Check if no relationship model is used by more than one m2m field.
1350         """
1351 
1352         errors = []
1353         seen_intermediary_signatures = []
1354 
1355         fields = cls._meta.local_many_to_many
1356 
1357         # Skip when the target model wasn't found.
1358         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1359 
1360         # Skip when the relationship model wasn't found.
1361         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1362 
1363         for f in fields:
1364             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1365             if signature in seen_intermediary_signatures:
1366                 errors.append(
1367                     checks.Error(
1368                         "The model has two identical many-to-many relations "
1369                         "through the intermediate model '%s'." %
1370                         f.remote_field.through._meta.label,
1371                         obj=cls,
1372                         id='models.E003',
1373                     )
1374                 )
1375             else:
1376                 seen_intermediary_signatures.append(signature)
1377         return errors
1378 
1379     @classmethod
1380     def _check_id_field(cls):
1381         """Check if `id` field is a primary key."""
1382         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1383         # fields is empty or consists of the invalid "id" field
1384         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1385             return [
1386                 checks.Error(
1387                     "'id' can only be used as a field name if the field also "
1388                     "sets 'primary_key=True'.",
1389                     obj=cls,
1390                     id='models.E004',
1391                 )
1392             ]
1393         else:
1394             return []
1395 
1396     @classmethod
1397     def _check_field_name_clashes(cls):
1398         """Forbid field shadowing in multi-table inheritance."""
1399         errors = []
1400         used_fields = {}  # name or attname -> field
1401 
1402         # Check that multi-inheritance doesn't cause field name shadowing.
1403         for parent in cls._meta.get_parent_list():
1404             for f in parent._meta.local_fields:
1405                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1406                 if clash:
1407                     errors.append(
1408                         checks.Error(
1409                             "The field '%s' from parent model "
1410                             "'%s' clashes with the field '%s' "
1411                             "from parent model '%s'." % (
1412                                 clash.name, clash.model._meta,
1413                                 f.name, f.model._meta
1414                             ),
1415                             obj=cls,
1416                             id='models.E005',
1417                         )
1418                     )
1419                 used_fields[f.name] = f
1420                 used_fields[f.attname] = f
1421 
1422         # Check that fields defined in the model don't clash with fields from
1423         # parents, including auto-generated fields like multi-table inheritance
1424         # child accessors.
1425         for parent in cls._meta.get_parent_list():
1426             for f in parent._meta.get_fields():
1427                 if f not in used_fields:
1428                     used_fields[f.name] = f
1429 
1430         for f in cls._meta.local_fields:
1431             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1432             # Note that we may detect clash between user-defined non-unique
1433             # field "id" and automatically added unique field "id", both
1434             # defined at the same model. This special case is considered in
1435             # _check_id_field and here we ignore it.
1436             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1437             if clash and not id_conflict:
1438                 errors.append(
1439                     checks.Error(
1440                         "The field '%s' clashes with the field '%s' "
1441                         "from model '%s'." % (
1442                             f.name, clash.name, clash.model._meta
1443                         ),
1444                         obj=f,
1445                         id='models.E006',
1446                     )
1447                 )
1448             used_fields[f.name] = f
1449             used_fields[f.attname] = f
1450 
1451         return errors
1452 
1453     @classmethod
1454     def _check_column_name_clashes(cls):
1455         # Store a list of column names which have already been used by other fields.
1456         used_column_names = []
1457         errors = []
1458 
1459         for f in cls._meta.local_fields:
1460             _, column_name = f.get_attname_column()
1461 
1462             # Ensure the column name is not already in use.
1463             if column_name and column_name in used_column_names:
1464                 errors.append(
1465                     checks.Error(
1466                         "Field '%s' has column name '%s' that is used by "
1467                         "another field." % (f.name, column_name),
1468                         hint="Specify a 'db_column' for the field.",
1469                         obj=cls,
1470                         id='models.E007'
1471                     )
1472                 )
1473             else:
1474                 used_column_names.append(column_name)
1475 
1476         return errors
1477 
1478     @classmethod
1479     def _check_model_name_db_lookup_clashes(cls):
1480         errors = []
1481         model_name = cls.__name__
1482         if model_name.startswith('_') or model_name.endswith('_'):
1483             errors.append(
1484                 checks.Error(
1485                     "The model name '%s' cannot start or end with an underscore "
1486                     "as it collides with the query lookup syntax." % model_name,
1487                     obj=cls,
1488                     id='models.E023'
1489                 )
1490             )
1491         elif LOOKUP_SEP in model_name:
1492             errors.append(
1493                 checks.Error(
1494                     "The model name '%s' cannot contain double underscores as "
1495                     "it collides with the query lookup syntax." % model_name,
1496                     obj=cls,
1497                     id='models.E024'
1498                 )
1499             )
1500         return errors
1501 
1502     @classmethod
1503     def _check_property_name_related_field_accessor_clashes(cls):
1504         errors = []
1505         property_names = cls._meta._property_names
1506         related_field_accessors = (
1507             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1508             if f.is_relation and f.related_model is not None
1509         )
1510         for accessor in related_field_accessors:
1511             if accessor in property_names:
1512                 errors.append(
1513                     checks.Error(
1514                         "The property '%s' clashes with a related field "
1515                         "accessor." % accessor,
1516                         obj=cls,
1517                         id='models.E025',
1518                     )
1519                 )
1520         return errors
1521 
1522     @classmethod
1523     def _check_single_primary_key(cls):
1524         errors = []
1525         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1526             errors.append(
1527                 checks.Error(
1528                     "The model cannot have more than one field with "
1529                     "'primary_key=True'.",
1530                     obj=cls,
1531                     id='models.E026',
1532                 )
1533             )
1534         return errors
1535 
1536     @classmethod
1537     def _check_index_together(cls):
1538         """Check the value of "index_together" option."""
1539         if not isinstance(cls._meta.index_together, (tuple, list)):
1540             return [
1541                 checks.Error(
1542                     "'index_together' must be a list or tuple.",
1543                     obj=cls,
1544                     id='models.E008',
1545                 )
1546             ]
1547 
1548         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1549             return [
1550                 checks.Error(
1551                     "All 'index_together' elements must be lists or tuples.",
1552                     obj=cls,
1553                     id='models.E009',
1554                 )
1555             ]
1556 
1557         else:
1558             errors = []
1559             for fields in cls._meta.index_together:
1560                 errors.extend(cls._check_local_fields(fields, "index_together"))
1561             return errors
1562 
1563     @classmethod
1564     def _check_unique_together(cls):
1565         """Check the value of "unique_together" option."""
1566         if not isinstance(cls._meta.unique_together, (tuple, list)):
1567             return [
1568                 checks.Error(
1569                     "'unique_together' must be a list or tuple.",
1570                     obj=cls,
1571                     id='models.E010',
1572                 )
1573             ]
1574 
1575         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1576             return [
1577                 checks.Error(
1578                     "All 'unique_together' elements must be lists or tuples.",
1579                     obj=cls,
1580                     id='models.E011',
1581                 )
1582             ]
1583 
1584         else:
1585             errors = []
1586             for fields in cls._meta.unique_together:
1587                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1588             return errors
1589 
1590     @classmethod
1591     def _check_indexes(cls, databases):
1592         """Check fields, names, and conditions of indexes."""
1593         errors = []
1594         for index in cls._meta.indexes:
1595             # Index name can't start with an underscore or a number, restricted
1596             # for cross-database compatibility with Oracle.
1597             if index.name[0] == '_' or index.name[0].isdigit():
1598                 errors.append(
1599                     checks.Error(
1600                         "The index name '%s' cannot start with an underscore "
1601                         "or a number." % index.name,
1602                         obj=cls,
1603                         id='models.E033',
1604                     ),
1605                 )
1606             if len(index.name) > index.max_name_length:
1607                 errors.append(
1608                     checks.Error(
1609                         "The index name '%s' cannot be longer than %d "
1610                         "characters." % (index.name, index.max_name_length),
1611                         obj=cls,
1612                         id='models.E034',
1613                     ),
1614                 )
1615         for db in databases:
1616             if not router.allow_migrate_model(db, cls):
1617                 continue
1618             connection = connections[db]
1619             if not (
1620                 connection.features.supports_partial_indexes or
1621                 'supports_partial_indexes' in cls._meta.required_db_features
1622             ) and any(index.condition is not None for index in cls._meta.indexes):
1623                 errors.append(
1624                     checks.Warning(
1625                         '%s does not support indexes with conditions.'
1626                         % connection.display_name,
1627                         hint=(
1628                             "Conditions will be ignored. Silence this warning "
1629                             "if you don't care about it."
1630                         ),
1631                         obj=cls,
1632                         id='models.W037',
1633                     )
1634                 )
1635             if not (
1636                 connection.features.supports_covering_indexes or
1637                 'supports_covering_indexes' in cls._meta.required_db_features
1638             ) and any(index.include for index in cls._meta.indexes):
1639                 errors.append(
1640                     checks.Warning(
1641                         '%s does not support indexes with non-key columns.'
1642                         % connection.display_name,
1643                         hint=(
1644                             "Non-key columns will be ignored. Silence this "
1645                             "warning if you don't care about it."
1646                         ),
1647                         obj=cls,
1648                         id='models.W040',
1649                     )
1650                 )
1651         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1652         fields += [include for index in cls._meta.indexes for include in index.include]
1653         errors.extend(cls._check_local_fields(fields, 'indexes'))
1654         return errors
1655 
1656     @classmethod
1657     def _check_local_fields(cls, fields, option):
1658         from django.db import models
1659 
1660         # In order to avoid hitting the relation tree prematurely, we use our
1661         # own fields_map instead of using get_field()
1662         forward_fields_map = {}
1663         for field in cls._meta._get_fields(reverse=False):
1664             forward_fields_map[field.name] = field
1665             if hasattr(field, 'attname'):
1666                 forward_fields_map[field.attname] = field
1667 
1668         errors = []
1669         for field_name in fields:
1670             try:
1671                 field = forward_fields_map[field_name]
1672             except KeyError:
1673                 errors.append(
1674                     checks.Error(
1675                         "'%s' refers to the nonexistent field '%s'." % (
1676                             option, field_name,
1677                         ),
1678                         obj=cls,
1679                         id='models.E012',
1680                     )
1681                 )
1682             else:
1683                 if isinstance(field.remote_field, models.ManyToManyRel):
1684                     errors.append(
1685                         checks.Error(
1686                             "'%s' refers to a ManyToManyField '%s', but "
1687                             "ManyToManyFields are not permitted in '%s'." % (
1688                                 option, field_name, option,
1689                             ),
1690                             obj=cls,
1691                             id='models.E013',
1692                         )
1693                     )
1694                 elif field not in cls._meta.local_fields:
1695                     errors.append(
1696                         checks.Error(
1697                             "'%s' refers to field '%s' which is not local to model '%s'."
1698                             % (option, field_name, cls._meta.object_name),
1699                             hint="This issue may be caused by multi-table inheritance.",
1700                             obj=cls,
1701                             id='models.E016',
1702                         )
1703                     )
1704         return errors
1705 
1706     @classmethod
1707     def _check_ordering(cls):
1708         """
1709         Check "ordering" option -- is it a list of strings and do all fields
1710         exist?
1711         """
1712         if cls._meta._ordering_clash:
1713             return [
1714                 checks.Error(
1715                     "'ordering' and 'order_with_respect_to' cannot be used together.",
1716                     obj=cls,
1717                     id='models.E021',
1718                 ),
1719             ]
1720 
1721         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1722             return []
1723 
1724         if not isinstance(cls._meta.ordering, (list, tuple)):
1725             return [
1726                 checks.Error(
1727                     "'ordering' must be a tuple or list (even if you want to order by only one field).",
1728                     obj=cls,
1729                     id='models.E014',
1730                 )
1731             ]
1732 
1733         errors = []
1734         fields = cls._meta.ordering
1735 
1736         # Skip expressions and '?' fields.
1737         fields = (f for f in fields if isinstance(f, str) and f != '?')
1738 
1739         # Convert "-field" to "field".
1740         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1741 
1742         # Separate related fields and non-related fields.
1743         _fields = []
1744         related_fields = []
1745         for f in fields:
1746             if LOOKUP_SEP in f:
1747                 related_fields.append(f)
1748             else:
1749                 _fields.append(f)
1750         fields = _fields
1751 
1752         # Check related fields.
1753         for field in related_fields:
1754             _cls = cls
1755             fld = None
1756             for part in field.split(LOOKUP_SEP):
1757                 try:
1758                     # pk is an alias that won't be found by opts.get_field.
1759                     if part == 'pk':
1760                         fld = _cls._meta.pk
1761                     else:
1762                         fld = _cls._meta.get_field(part)
1763                     if fld.is_relation:
1764                         _cls = fld.get_path_info()[-1].to_opts.model
1765                     else:
1766                         _cls = None
1767                 except (FieldDoesNotExist, AttributeError):
1768                     if fld is None or (
1769                         fld.get_transform(part) is None and fld.get_lookup(part) is None
1770                     ):
1771                         errors.append(
1772                             checks.Error(
1773                                 "'ordering' refers to the nonexistent field, "
1774                                 "related field, or lookup '%s'." % field,
1775                                 obj=cls,
1776                                 id='models.E015',
1777                             )
1778                         )
1779 
1780         # Skip ordering on pk. This is always a valid order_by field
1781         # but is an alias and therefore won't be found by opts.get_field.
1782         fields = {f for f in fields if f != 'pk'}
1783 
1784         # Check for invalid or nonexistent fields in ordering.
1785         invalid_fields = []
1786 
1787         # Any field name that is not present in field_names does not exist.
1788         # Also, ordering by m2m fields is not allowed.
1789         opts = cls._meta
1790         valid_fields = set(chain.from_iterable(
1791             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1792             for f in chain(opts.fields, opts.related_objects)
1793         ))
1794 
1795         invalid_fields.extend(fields - valid_fields)
1796 
1797         for invalid_field in invalid_fields:
1798             errors.append(
1799                 checks.Error(
1800                     "'ordering' refers to the nonexistent field, related "
1801                     "field, or lookup '%s'." % invalid_field,
1802                     obj=cls,
1803                     id='models.E015',
1804                 )
1805             )
1806         return errors
1807 
1808     @classmethod
1809     def _check_long_column_names(cls, databases):
1810         """
1811         Check that any auto-generated column names are shorter than the limits
1812         for each database in which the model will be created.
1813         """
1814         if not databases:
1815             return []
1816         errors = []
1817         allowed_len = None
1818         db_alias = None
1819 
1820         # Find the minimum max allowed length among all specified db_aliases.
1821         for db in databases:
1822             # skip databases where the model won't be created
1823             if not router.allow_migrate_model(db, cls):
1824                 continue
1825             connection = connections[db]
1826             max_name_length = connection.ops.max_name_length()
1827             if max_name_length is None or connection.features.truncates_names:
1828                 continue
1829             else:
1830                 if allowed_len is None:
1831                     allowed_len = max_name_length
1832                     db_alias = db
1833                 elif max_name_length < allowed_len:
1834                     allowed_len = max_name_length
1835                     db_alias = db
1836 
1837         if allowed_len is None:
1838             return errors
1839 
1840         for f in cls._meta.local_fields:
1841             _, column_name = f.get_attname_column()
1842 
1843             # Check if auto-generated name for the field is too long
1844             # for the database.
1845             if f.db_column is None and column_name is not None and len(column_name) > allowed_len:
1846                 errors.append(
1847                     checks.Error(
1848                         'Autogenerated column name too long for field "%s". '
1849                         'Maximum length is "%s" for database "%s".'
1850                         % (column_name, allowed_len, db_alias),
1851                         hint="Set the column name manually using 'db_column'.",
1852                         obj=cls,
1853                         id='models.E018',
1854                     )
1855                 )
1856 
1857         for f in cls._meta.local_many_to_many:
1858             # Skip nonexistent models.
1859             if isinstance(f.remote_field.through, str):
1860                 continue
1861 
1862             # Check if auto-generated name for the M2M field is too long
1863             # for the database.
1864             for m2m in f.remote_field.through._meta.local_fields:
1865                 _, rel_name = m2m.get_attname_column()
1866                 if m2m.db_column is None and rel_name is not None and len(rel_name) > allowed_len:
1867                     errors.append(
1868                         checks.Error(
1869                             'Autogenerated column name too long for M2M field '
1870                             '"%s". Maximum length is "%s" for database "%s".'
1871                             % (rel_name, allowed_len, db_alias),
1872                             hint=(
1873                                 "Use 'through' to create a separate model for "
1874                                 "M2M and then set column_name using 'db_column'."
1875                             ),
1876                             obj=cls,
1877                             id='models.E019',
1878                         )
1879                     )
1880 
1881         return errors
1882 
1883     @classmethod
1884     def _get_expr_references(cls, expr):
1885         if isinstance(expr, Q):
1886             for child in expr.children:
1887                 if isinstance(child, tuple):
1888                     lookup, value = child
1889                     yield tuple(lookup.split(LOOKUP_SEP))
1890                     yield from cls._get_expr_references(value)
1891                 else:
1892                     yield from cls._get_expr_references(child)
1893         elif isinstance(expr, F):
1894             yield tuple(expr.name.split(LOOKUP_SEP))
1895         elif hasattr(expr, 'get_source_expressions'):
1896             for src_expr in expr.get_source_expressions():
1897                 yield from cls._get_expr_references(src_expr)
1898 
1899     @classmethod
1900     def _check_constraints(cls, databases):
1901         errors = []
1902         for db in databases:
1903             if not router.allow_migrate_model(db, cls):
1904                 continue
1905             connection = connections[db]
1906             if not (
1907                 connection.features.supports_table_check_constraints or
1908                 'supports_table_check_constraints' in cls._meta.required_db_features
1909             ) and any(
1910                 isinstance(constraint, CheckConstraint)
1911                 for constraint in cls._meta.constraints
1912             ):
1913                 errors.append(
1914                     checks.Warning(
1915                         '%s does not support check constraints.' % connection.display_name,
1916                         hint=(
1917                             "A constraint won't be created. Silence this "
1918                             "warning if you don't care about it."
1919                         ),
1920                         obj=cls,
1921                         id='models.W027',
1922                     )
1923                 )
1924             if not (
1925                 connection.features.supports_partial_indexes or
1926                 'supports_partial_indexes' in cls._meta.required_db_features
1927             ) and any(
1928                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None
1929                 for constraint in cls._meta.constraints
1930             ):
1931                 errors.append(
1932                     checks.Warning(
1933                         '%s does not support unique constraints with '
1934                         'conditions.' % connection.display_name,
1935                         hint=(
1936                             "A constraint won't be created. Silence this "
1937                             "warning if you don't care about it."
1938                         ),
1939                         obj=cls,
1940                         id='models.W036',
1941                     )
1942                 )
1943             if not (
1944                 connection.features.supports_deferrable_unique_constraints or
1945                 'supports_deferrable_unique_constraints' in cls._meta.required_db_features
1946             ) and any(
1947                 isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None
1948                 for constraint in cls._meta.constraints
1949             ):
1950                 errors.append(
1951                     checks.Warning(
1952                         '%s does not support deferrable unique constraints.'
1953                         % connection.display_name,
1954                         hint=(
1955                             "A constraint won't be created. Silence this "
1956                             "warning if you don't care about it."
1957                         ),
1958                         obj=cls,
1959                         id='models.W038',
1960                     )
1961                 )
1962             if not (
1963                 connection.features.supports_covering_indexes or
1964                 'supports_covering_indexes' in cls._meta.required_db_features
1965             ) and any(
1966                 isinstance(constraint, UniqueConstraint) and constraint.include
1967                 for constraint in cls._meta.constraints
1968             ):
1969                 errors.append(
1970                     checks.Warning(
1971                         '%s does not support unique constraints with non-key '
1972                         'columns.' % connection.display_name,
1973                         hint=(
1974                             "A constraint won't be created. Silence this "
1975                             "warning if you don't care about it."
1976                         ),
1977                         obj=cls,
1978                         id='models.W039',
1979                     )
1980                 )
1981             fields = set(chain.from_iterable(
1982                 (*constraint.fields, *constraint.include)
1983                 for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)
1984             ))
1985             references = set()
1986             for constraint in cls._meta.constraints:
1987                 if isinstance(constraint, UniqueConstraint):
1988                     if (
1989                         connection.features.supports_partial_indexes or
1990                         'supports_partial_indexes' not in cls._meta.required_db_features
1991                     ) and isinstance(constraint.condition, Q):
1992                         references.update(cls._get_expr_references(constraint.condition))
1993                 elif isinstance(constraint, CheckConstraint):
1994                     if (
1995                         connection.features.supports_table_check_constraints or
1996                         'supports_table_check_constraints' not in cls._meta.required_db_features
1997                     ) and isinstance(constraint.check, Q):
1998                         references.update(cls._get_expr_references(constraint.check))
1999             for field_name, *lookups in references:
2000                 # pk is an alias that won't be found by opts.get_field.
2001                 if field_name != 'pk':
2002                     fields.add(field_name)
2003                 if not lookups:
2004                     # If it has no lookups it cannot result in a JOIN.
2005                     continue
2006                 try:
2007                     if field_name == 'pk':
2008                         field = cls._meta.pk
2009                     else:
2010                         field = cls._meta.get_field(field_name)
2011                     if not field.is_relation or field.many_to_many or field.one_to_many:
2012                         continue
2013                 except FieldDoesNotExist:
2014                     continue
2015                 # JOIN must happen at the first lookup.
2016                 first_lookup = lookups[0]
2017                 if (
2018                     field.get_transform(first_lookup) is None and
2019                     field.get_lookup(first_lookup) is None
2020                 ):
2021                     errors.append(
2022                         checks.Error(
2023                             "'constraints' refers to the joined field '%s'."
2024                             % LOOKUP_SEP.join([field_name] + lookups),
2025                             obj=cls,
2026                             id='models.E041',
2027                         )
2028                     )
2029             errors.extend(cls._check_local_fields(fields, 'constraints'))
2030         return errors
2031 
2032 
2033 ############################################
2034 # HELPER FUNCTIONS (CURRIED MODEL METHODS) #
2035 ############################################
2036 
2037 # ORDERING METHODS #########################
2038 
2039 def method_set_order(self, ordered_obj, id_list, using=None):
2040     if using is None:
2041         using = DEFAULT_DB_ALIAS
2042     order_wrt = ordered_obj._meta.order_with_respect_to
2043     filter_args = order_wrt.get_forward_related_filter(self)
2044     ordered_obj.objects.db_manager(using).filter(**filter_args).bulk_update([
2045         ordered_obj(pk=pk, _order=order) for order, pk in enumerate(id_list)
2046     ], ['_order'])
2047 
2048 
2049 def method_get_order(self, ordered_obj):
2050     order_wrt = ordered_obj._meta.order_with_respect_to
2051     filter_args = order_wrt.get_forward_related_filter(self)
2052     pk_name = ordered_obj._meta.pk.name
2053     return ordered_obj.objects.filter(**filter_args).values_list(pk_name, flat=True)
2054 
2055 
2056 def make_foreign_order_accessors(model, related_model):
2057     setattr(
2058         related_model,
2059         'get_%s_order' % model.__name__.lower(),
2060         partialmethod(method_get_order, model)
2061     )
2062     setattr(
2063         related_model,
2064         'set_%s_order' % model.__name__.lower(),
2065         partialmethod(method_set_order, model)
2066     )
2067 
2068 ########
2069 # MISC #
2070 ########
2071 
2072 
2073 def model_unpickle(model_id):
2074     """Used to unpickle Model subclasses with deferred fields."""
2075     if isinstance(model_id, tuple):
2076         model = apps.get_model(*model_id)
2077     else:
2078         # Backwards compat - the model was cached directly in earlier versions.
2079         model = model_id
2080     return model.__new__(model)
2081 
2082 
2083 model_unpickle.__safe_for_unpickle__ = True

</code><intended_behavior>The part of the code responsible for handling model instance copying or state management needs to be updated or examined for Django versions >= 2.0. The code should ensure that when a model instance is copied (using Python's standard copy.copy or copy.deepcopy), all relevant state data, including foreign keys (FK) and caching mechanisms (_state and fields_cache), are correctly cloned. This includes the preservation of FK relationships and cache integrity so that changes to a cloned instance do not affect the original instance. This might involve examining or adjusting how _state (especially fields_cache) is copied between instances to ensure behavior consistent with versions < 2.0, thus preserving the expected functionality while also embracing any architectural changes introduced in Django 2.x.</intended_behavior>, <file>django/db/models/fields/related_descriptors.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Accessors for related objects.
3 
4 When a field defines a relation between two models, each model class provides
5 an attribute to access related instances of the other model class (unless the
6 reverse accessor has been disabled with related_name='+').
7 
8 Accessors are implemented as descriptors in order to customize access and
9 assignment. This module defines the descriptor classes.
10 
11 Forward accessors follow foreign keys. Reverse accessors trace them back. For
12 example, with the following models::
13 
14     class Parent(Model):
15         pass
16 
17     class Child(Model):
18         parent = ForeignKey(Parent, related_name='children')
19 
20  ``child.parent`` is a forward many-to-one relation. ``parent.children`` is a
21 reverse many-to-one relation.
22 
23 There are three types of relations (many-to-one, one-to-one, and many-to-many)
24 and two directions (forward and reverse) for a total of six combinations.
25 
26 1. Related instance on the forward side of a many-to-one relation:
27    ``ForwardManyToOneDescriptor``.
28 
29    Uniqueness of foreign key values is irrelevant to accessing the related
30    instance, making the many-to-one and one-to-one cases identical as far as
31    the descriptor is concerned. The constraint is checked upstream (unicity
32    validation in forms) or downstream (unique indexes in the database).
33 
34 2. Related instance on the forward side of a one-to-one
35    relation: ``ForwardOneToOneDescriptor``.
36 
37    It avoids querying the database when accessing the parent link field in
38    a multi-table inheritance scenario.
39 
40 3. Related instance on the reverse side of a one-to-one relation:
41    ``ReverseOneToOneDescriptor``.
42 
43    One-to-one relations are asymmetrical, despite the apparent symmetry of the
44    name, because they're implemented in the database with a foreign key from
45    one table to another. As a consequence ``ReverseOneToOneDescriptor`` is
46    slightly different from ``ForwardManyToOneDescriptor``.
47 
48 4. Related objects manager for related instances on the reverse side of a
49    many-to-one relation: ``ReverseManyToOneDescriptor``.
50 
51    Unlike the previous two classes, this one provides access to a collection
52    of objects. It returns a manager rather than an instance.
53 
54 5. Related objects manager for related instances on the forward or reverse
55    sides of a many-to-many relation: ``ManyToManyDescriptor``.
56 
57    Many-to-many relations are symmetrical. The syntax of Django models
58    requires declaring them on one side but that's an implementation detail.
59    They could be declared on the other side without any change in behavior.
60    Therefore the forward and reverse descriptors can be the same.
61 
62    If you're looking for ``ForwardManyToManyDescriptor`` or
63    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.
64 """
65 
66 from django.core.exceptions import FieldError
67 from django.db import connections, router, transaction
68 from django.db.models import Q, signals
69 from django.db.models.query import QuerySet
70 from django.db.models.query_utils import DeferredAttribute
71 from django.db.models.utils import resolve_callables
72 from django.utils.functional import cached_property
73 
74 
75 class ForeignKeyDeferredAttribute(DeferredAttribute):
76     def __set__(self, instance, value):
77         if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):
78             self.field.delete_cached_value(instance)
79         instance.__dict__[self.field.attname] = value
80 
81 
82 class ForwardManyToOneDescriptor:
83     """
84     Accessor to the related object on the forward side of a many-to-one or
85     one-to-one (via ForwardOneToOneDescriptor subclass) relation.
86 
87     In the example::
88 
89         class Child(Model):
90             parent = ForeignKey(Parent, related_name='children')
91 
92     ``Child.parent`` is a ``ForwardManyToOneDescriptor`` instance.
93     """
94 
95     def __init__(self, field_with_rel):
96         self.field = field_with_rel
97 
98     @cached_property
99     def RelatedObjectDoesNotExist(self):
100         # The exception can't be created at initialization time since the
101         # related model might not be resolved yet; `self.field.model` might
102         # still be a string model reference.
103         return type(
104             'RelatedObjectDoesNotExist',
105             (self.field.remote_field.model.DoesNotExist, AttributeError), {
106                 '__module__': self.field.model.__module__,
107                 '__qualname__': '%s.%s.RelatedObjectDoesNotExist' % (
108                     self.field.model.__qualname__,
109                     self.field.name,
110                 ),
111             }
112         )
113 
114     def is_cached(self, instance):
115         return self.field.is_cached(instance)
116 
117     def get_queryset(self, **hints):
118         return self.field.remote_field.model._base_manager.db_manager(hints=hints).all()
119 
120     def get_prefetch_queryset(self, instances, queryset=None):
121         if queryset is None:
122             queryset = self.get_queryset()
123         queryset._add_hints(instance=instances[0])
124 
125         rel_obj_attr = self.field.get_foreign_related_value
126         instance_attr = self.field.get_local_related_value
127         instances_dict = {instance_attr(inst): inst for inst in instances}
128         related_field = self.field.foreign_related_fields[0]
129         remote_field = self.field.remote_field
130 
131         # FIXME: This will need to be revisited when we introduce support for
132         # composite fields. In the meantime we take this practical approach to
133         # solve a regression on 1.6 when the reverse manager in hidden
134         # (related_name ends with a '+'). Refs #21410.
135         # The check for len(...) == 1 is a special case that allows the query
136         # to be join-less and smaller. Refs #21760.
137         if remote_field.is_hidden() or len(self.field.foreign_related_fields) == 1:
138             query = {'%s__in' % related_field.name: {instance_attr(inst)[0] for inst in instances}}
139         else:
140             query = {'%s__in' % self.field.related_query_name(): instances}
141         queryset = queryset.filter(**query)
142 
143         # Since we're going to assign directly in the cache,
144         # we must manage the reverse relation cache manually.
145         if not remote_field.multiple:
146             for rel_obj in queryset:
147                 instance = instances_dict[rel_obj_attr(rel_obj)]
148                 remote_field.set_cached_value(rel_obj, instance)
149         return queryset, rel_obj_attr, instance_attr, True, self.field.get_cache_name(), False
150 
151     def get_object(self, instance):
152         qs = self.get_queryset(instance=instance)
153         # Assuming the database enforces foreign keys, this won't fail.
154         return qs.get(self.field.get_reverse_related_filter(instance))
155 
156     def __get__(self, instance, cls=None):
157         """
158         Get the related instance through the forward relation.
159 
160         With the example above, when getting ``child.parent``:
161 
162         - ``self`` is the descriptor managing the ``parent`` attribute
163         - ``instance`` is the ``child`` instance
164         - ``cls`` is the ``Child`` class (we don't need it)
165         """
166         if instance is None:
167             return self
168 
169         # The related instance is loaded from the database and then cached
170         # by the field on the model instance state. It can also be pre-cached
171         # by the reverse accessor (ReverseOneToOneDescriptor).
172         try:
173             rel_obj = self.field.get_cached_value(instance)
174         except KeyError:
175             has_value = None not in self.field.get_local_related_value(instance)
176             ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None
177             if ancestor_link and ancestor_link.is_cached(instance):
178                 # An ancestor link will exist if this field is defined on a
179                 # multi-table inheritance parent of the instance's class.
180                 ancestor = ancestor_link.get_cached_value(instance)
181                 # The value might be cached on an ancestor if the instance
182                 # originated from walking down the inheritance chain.
183                 rel_obj = self.field.get_cached_value(ancestor, default=None)
184             else:
185                 rel_obj = None
186             if rel_obj is None and has_value:
187                 rel_obj = self.get_object(instance)
188                 remote_field = self.field.remote_field
189                 # If this is a one-to-one relation, set the reverse accessor
190                 # cache on the related object to the current instance to avoid
191                 # an extra SQL query if it's accessed later on.
192                 if not remote_field.multiple:
193                     remote_field.set_cached_value(rel_obj, instance)
194             self.field.set_cached_value(instance, rel_obj)
195 
196         if rel_obj is None and not self.field.null:
197             raise self.RelatedObjectDoesNotExist(
198                 "%s has no %s." % (self.field.model.__name__, self.field.name)
199             )
200         else:
201             return rel_obj
202 
203     def __set__(self, instance, value):
204         """
205         Set the related instance through the forward relation.
206 
207         With the example above, when setting ``child.parent = parent``:
208 
209         - ``self`` is the descriptor managing the ``parent`` attribute
210         - ``instance`` is the ``child`` instance
211         - ``value`` is the ``parent`` instance on the right of the equal sign
212         """
213         # An object must be an instance of the related class.
214         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):
215             raise ValueError(
216                 'Cannot assign "%r": "%s.%s" must be a "%s" instance.' % (
217                     value,
218                     instance._meta.object_name,
219                     self.field.name,
220                     self.field.remote_field.model._meta.object_name,
221                 )
222             )
223         elif value is not None:
224             if instance._state.db is None:
225                 instance._state.db = router.db_for_write(instance.__class__, instance=value)
226             if value._state.db is None:
227                 value._state.db = router.db_for_write(value.__class__, instance=instance)
228             if not router.allow_relation(value, instance):
229                 raise ValueError('Cannot assign "%r": the current database router prevents this relation.' % value)
230 
231         remote_field = self.field.remote_field
232         # If we're setting the value of a OneToOneField to None, we need to clear
233         # out the cache on any old related object. Otherwise, deleting the
234         # previously-related object will also cause this object to be deleted,
235         # which is wrong.
236         if value is None:
237             # Look up the previously-related object, which may still be available
238             # since we've not yet cleared out the related field.
239             # Use the cache directly, instead of the accessor; if we haven't
240             # populated the cache, then we don't care - we're only accessing
241             # the object to invalidate the accessor cache, so there's no
242             # need to populate the cache just to expire it again.
243             related = self.field.get_cached_value(instance, default=None)
244 
245             # If we've got an old related object, we need to clear out its
246             # cache. This cache also might not exist if the related object
247             # hasn't been accessed yet.
248             if related is not None:
249                 remote_field.set_cached_value(related, None)
250 
251             for lh_field, rh_field in self.field.related_fields:
252                 setattr(instance, lh_field.attname, None)
253 
254         # Set the values of the related field.
255         else:
256             for lh_field, rh_field in self.field.related_fields:
257                 setattr(instance, lh_field.attname, getattr(value, rh_field.attname))
258 
259         # Set the related instance cache used by __get__ to avoid an SQL query
260         # when accessing the attribute we just set.
261         self.field.set_cached_value(instance, value)
262 
263         # If this is a one-to-one relation, set the reverse accessor cache on
264         # the related object to the current instance to avoid an extra SQL
265         # query if it's accessed later on.
266         if value is not None and not remote_field.multiple:
267             remote_field.set_cached_value(value, instance)
268 
269     def __reduce__(self):
270         """
271         Pickling should return the instance attached by self.field on the
272         model, not a new copy of that descriptor. Use getattr() to retrieve
273         the instance directly from the model.
274         """
275         return getattr, (self.field.model, self.field.name)
276 
277 
278 class ForwardOneToOneDescriptor(ForwardManyToOneDescriptor):
279     """
280     Accessor to the related object on the forward side of a one-to-one relation.
281 
282     In the example::
283 
284         class Restaurant(Model):
285             place = OneToOneField(Place, related_name='restaurant')
286 
287     ``Restaurant.place`` is a ``ForwardOneToOneDescriptor`` instance.
288     """
289 
290     def get_object(self, instance):
291         if self.field.remote_field.parent_link:
292             deferred = instance.get_deferred_fields()
293             # Because it's a parent link, all the data is available in the
294             # instance, so populate the parent model with this data.
295             rel_model = self.field.remote_field.model
296             fields = [field.attname for field in rel_model._meta.concrete_fields]
297 
298             # If any of the related model's fields are deferred, fallback to
299             # fetching all fields from the related model. This avoids a query
300             # on the related model for every deferred field.
301             if not any(field in fields for field in deferred):
302                 kwargs = {field: getattr(instance, field) for field in fields}
303                 obj = rel_model(**kwargs)
304                 obj._state.adding = instance._state.adding
305                 obj._state.db = instance._state.db
306                 return obj
307         return super().get_object(instance)
308 
309     def __set__(self, instance, value):
310         super().__set__(instance, value)
311         # If the primary key is a link to a parent model and a parent instance
312         # is being set, update the value of the inherited pk(s).
313         if self.field.primary_key and self.field.remote_field.parent_link:
314             opts = instance._meta
315             # Inherited primary key fields from this object's base classes.
316             inherited_pk_fields = [
317                 field for field in opts.concrete_fields
318                 if field.primary_key and field.remote_field
319             ]
320             for field in inherited_pk_fields:
321                 rel_model_pk_name = field.remote_field.model._meta.pk.attname
322                 raw_value = getattr(value, rel_model_pk_name) if value is not None else None
323                 setattr(instance, rel_model_pk_name, raw_value)
324 
325 
326 class ReverseOneToOneDescriptor:
327     """
328     Accessor to the related object on the reverse side of a one-to-one
329     relation.
330 
331     In the example::
332 
333         class Restaurant(Model):
334             place = OneToOneField(Place, related_name='restaurant')
335 
336     ``Place.restaurant`` is a ``ReverseOneToOneDescriptor`` instance.
337     """
338 
339     def __init__(self, related):
340         # Following the example above, `related` is an instance of OneToOneRel
341         # which represents the reverse restaurant field (place.restaurant).
342         self.related = related
343 
344     @cached_property
345     def RelatedObjectDoesNotExist(self):
346         # The exception isn't created at initialization time for the sake of
347         # consistency with `ForwardManyToOneDescriptor`.
348         return type(
349             'RelatedObjectDoesNotExist',
350             (self.related.related_model.DoesNotExist, AttributeError), {
351                 '__module__': self.related.model.__module__,
352                 '__qualname__': '%s.%s.RelatedObjectDoesNotExist' % (
353                     self.related.model.__qualname__,
354                     self.related.name,
355                 )
356             },
357         )
358 
359     def is_cached(self, instance):
360         return self.related.is_cached(instance)
361 
362     def get_queryset(self, **hints):
363         return self.related.related_model._base_manager.db_manager(hints=hints).all()
364 
365     def get_prefetch_queryset(self, instances, queryset=None):
366         if queryset is None:
367             queryset = self.get_queryset()
368         queryset._add_hints(instance=instances[0])
369 
370         rel_obj_attr = self.related.field.get_local_related_value
371         instance_attr = self.related.field.get_foreign_related_value
372         instances_dict = {instance_attr(inst): inst for inst in instances}
373         query = {'%s__in' % self.related.field.name: instances}
374         queryset = queryset.filter(**query)
375 
376         # Since we're going to assign directly in the cache,
377         # we must manage the reverse relation cache manually.
378         for rel_obj in queryset:
379             instance = instances_dict[rel_obj_attr(rel_obj)]
380             self.related.field.set_cached_value(rel_obj, instance)
381         return queryset, rel_obj_attr, instance_attr, True, self.related.get_cache_name(), False
382 
383     def __get__(self, instance, cls=None):
384         """
385         Get the related instance through the reverse relation.
386 
387         With the example above, when getting ``place.restaurant``:
388 
389         - ``self`` is the descriptor managing the ``restaurant`` attribute
390         - ``instance`` is the ``place`` instance
391         - ``cls`` is the ``Place`` class (unused)
392 
393         Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.
394         """
395         if instance is None:
396             return self
397 
398         # The related instance is loaded from the database and then cached
399         # by the field on the model instance state. It can also be pre-cached
400         # by the forward accessor (ForwardManyToOneDescriptor).
401         try:
402             rel_obj = self.related.get_cached_value(instance)
403         except KeyError:
404             related_pk = instance.pk
405             if related_pk is None:
406                 rel_obj = None
407             else:
408                 filter_args = self.related.field.get_forward_related_filter(instance)
409                 try:
410                     rel_obj = self.get_queryset(instance=instance).get(**filter_args)
411                 except self.related.related_model.DoesNotExist:
412                     rel_obj = None
413                 else:
414                     # Set the forward accessor cache on the related object to
415                     # the current instance to avoid an extra SQL query if it's
416                     # accessed later on.
417                     self.related.field.set_cached_value(rel_obj, instance)
418             self.related.set_cached_value(instance, rel_obj)
419 
420         if rel_obj is None:
421             raise self.RelatedObjectDoesNotExist(
422                 "%s has no %s." % (
423                     instance.__class__.__name__,
424                     self.related.get_accessor_name()
425                 )
426             )
427         else:
428             return rel_obj
429 
430     def __set__(self, instance, value):
431         """
432         Set the related instance through the reverse relation.
433 
434         With the example above, when setting ``place.restaurant = restaurant``:
435 
436         - ``self`` is the descriptor managing the ``restaurant`` attribute
437         - ``instance`` is the ``place`` instance
438         - ``value`` is the ``restaurant`` instance on the right of the equal sign
439 
440         Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.
441         """
442         # The similarity of the code below to the code in
443         # ForwardManyToOneDescriptor is annoying, but there's a bunch
444         # of small differences that would make a common base class convoluted.
445 
446         if value is None:
447             # Update the cached related instance (if any) & clear the cache.
448             # Following the example above, this would be the cached
449             # ``restaurant`` instance (if any).
450             rel_obj = self.related.get_cached_value(instance, default=None)
451             if rel_obj is not None:
452                 # Remove the ``restaurant`` instance from the ``place``
453                 # instance cache.
454                 self.related.delete_cached_value(instance)
455                 # Set the ``place`` field on the ``restaurant``
456                 # instance to None.
457                 setattr(rel_obj, self.related.field.name, None)
458         elif not isinstance(value, self.related.related_model):
459             # An object must be an instance of the related class.
460             raise ValueError(
461                 'Cannot assign "%r": "%s.%s" must be a "%s" instance.' % (
462                     value,
463                     instance._meta.object_name,
464                     self.related.get_accessor_name(),
465                     self.related.related_model._meta.object_name,
466                 )
467             )
468         else:
469             if instance._state.db is None:
470                 instance._state.db = router.db_for_write(instance.__class__, instance=value)
471             if value._state.db is None:
472                 value._state.db = router.db_for_write(value.__class__, instance=instance)
473             if not router.allow_relation(value, instance):
474                 raise ValueError('Cannot assign "%r": the current database router prevents this relation.' % value)
475 
476             related_pk = tuple(getattr(instance, field.attname) for field in self.related.field.foreign_related_fields)
477             # Set the value of the related field to the value of the related object's related field
478             for index, field in enumerate(self.related.field.local_related_fields):
479                 setattr(value, field.attname, related_pk[index])
480 
481             # Set the related instance cache used by __get__ to avoid an SQL query
482             # when accessing the attribute we just set.
483             self.related.set_cached_value(instance, value)
484 
485             # Set the forward accessor cache on the related object to the current
486             # instance to avoid an extra SQL query if it's accessed later on.
487             self.related.field.set_cached_value(value, instance)
488 
489     def __reduce__(self):
490         # Same purpose as ForwardManyToOneDescriptor.__reduce__().
491         return getattr, (self.related.model, self.related.name)
492 
493 
494 class ReverseManyToOneDescriptor:
495     """
496     Accessor to the related objects manager on the reverse side of a
497     many-to-one relation.
498 
499     In the example::
500 
501         class Child(Model):
502             parent = ForeignKey(Parent, related_name='children')
503 
504     ``Parent.children`` is a ``ReverseManyToOneDescriptor`` instance.
505 
506     Most of the implementation is delegated to a dynamically defined manager
507     class built by ``create_forward_many_to_many_manager()`` defined below.
508     """
509 
510     def __init__(self, rel):
511         self.rel = rel
512         self.field = rel.field
513 
514     @cached_property
515     def related_manager_cls(self):
516         related_model = self.rel.related_model
517 
518         return create_reverse_many_to_one_manager(
519             related_model._default_manager.__class__,
520             self.rel,
521         )
522 
523     def __get__(self, instance, cls=None):
524         """
525         Get the related objects through the reverse relation.
526 
527         With the example above, when getting ``parent.children``:
528 
529         - ``self`` is the descriptor managing the ``children`` attribute
530         - ``instance`` is the ``parent`` instance
531         - ``cls`` is the ``Parent`` class (unused)
532         """
533         if instance is None:
534             return self
535 
536         return self.related_manager_cls(instance)
537 
538     def _get_set_deprecation_msg_params(self):
539         return (
540             'reverse side of a related set',
541             self.rel.get_accessor_name(),
542         )
543 
544     def __set__(self, instance, value):
545         raise TypeError(
546             'Direct assignment to the %s is prohibited. Use %s.set() instead.'
547             % self._get_set_deprecation_msg_params(),
548         )
549 
550 
551 def create_reverse_many_to_one_manager(superclass, rel):
552     """
553     Create a manager for the reverse side of a many-to-one relation.
554 
555     This manager subclasses another manager, generally the default manager of
556     the related model, and adds behaviors specific to many-to-one relations.
557     """
558 
559     class RelatedManager(superclass):
560         def __init__(self, instance):
561             super().__init__()
562 
563             self.instance = instance
564             self.model = rel.related_model
565             self.field = rel.field
566 
567             self.core_filters = {self.field.name: instance}
568 
569         def __call__(self, *, manager):
570             manager = getattr(self.model, manager)
571             manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)
572             return manager_class(self.instance)
573         do_not_call_in_templates = True
574 
575         def _apply_rel_filters(self, queryset):
576             """
577             Filter the queryset for the instance this manager is bound to.
578             """
579             db = self._db or router.db_for_read(self.model, instance=self.instance)
580             empty_strings_as_null = connections[db].features.interprets_empty_strings_as_nulls
581             queryset._add_hints(instance=self.instance)
582             if self._db:
583                 queryset = queryset.using(self._db)
584             queryset = queryset.filter(**self.core_filters)
585             for field in self.field.foreign_related_fields:
586                 val = getattr(self.instance, field.attname)
587                 if val is None or (val == '' and empty_strings_as_null):
588                     return queryset.none()
589             if self.field.many_to_one:
590                 # Guard against field-like objects such as GenericRelation
591                 # that abuse create_reverse_many_to_one_manager() with reverse
592                 # one-to-many relationships instead and break known related
593                 # objects assignment.
594                 try:
595                     target_field = self.field.target_field
596                 except FieldError:
597                     # The relationship has multiple target fields. Use a tuple
598                     # for related object id.
599                     rel_obj_id = tuple([
600                         getattr(self.instance, target_field.attname)
601                         for target_field in self.field.get_path_info()[-1].target_fields
602                     ])
603                 else:
604                     rel_obj_id = getattr(self.instance, target_field.attname)
605                 queryset._known_related_objects = {self.field: {rel_obj_id: self.instance}}
606             return queryset
607 
608         def _remove_prefetched_objects(self):
609             try:
610                 self.instance._prefetched_objects_cache.pop(self.field.remote_field.get_cache_name())
611             except (AttributeError, KeyError):
612                 pass  # nothing to clear from cache
613 
614         def get_queryset(self):
615             try:
616                 return self.instance._prefetched_objects_cache[self.field.remote_field.get_cache_name()]
617             except (AttributeError, KeyError):
618                 queryset = super().get_queryset()
619                 return self._apply_rel_filters(queryset)
620 
621         def get_prefetch_queryset(self, instances, queryset=None):
622             if queryset is None:
623                 queryset = super().get_queryset()
624 
625             queryset._add_hints(instance=instances[0])
626             queryset = queryset.using(queryset._db or self._db)
627 
628             rel_obj_attr = self.field.get_local_related_value
629             instance_attr = self.field.get_foreign_related_value
630             instances_dict = {instance_attr(inst): inst for inst in instances}
631             query = {'%s__in' % self.field.name: instances}
632             queryset = queryset.filter(**query)
633 
634             # Since we just bypassed this class' get_queryset(), we must manage
635             # the reverse relation manually.
636             for rel_obj in queryset:
637                 instance = instances_dict[rel_obj_attr(rel_obj)]
638                 setattr(rel_obj, self.field.name, instance)
639             cache_name = self.field.remote_field.get_cache_name()
640             return queryset, rel_obj_attr, instance_attr, False, cache_name, False
641 
642         def add(self, *objs, bulk=True):
643             self._remove_prefetched_objects()
644             db = router.db_for_write(self.model, instance=self.instance)
645 
646             def check_and_update_obj(obj):
647                 if not isinstance(obj, self.model):
648                     raise TypeError("'%s' instance expected, got %r" % (
649                         self.model._meta.object_name, obj,
650                     ))
651                 setattr(obj, self.field.name, self.instance)
652 
653             if bulk:
654                 pks = []
655                 for obj in objs:
656                     check_and_update_obj(obj)
657                     if obj._state.adding or obj._state.db != db:
658                         raise ValueError(
659                             "%r instance isn't saved. Use bulk=False or save "
660                             "the object first." % obj
661                         )
662                     pks.append(obj.pk)
663                 self.model._base_manager.using(db).filter(pk__in=pks).update(**{
664                     self.field.name: self.instance,
665                 })
666             else:
667                 with transaction.atomic(using=db, savepoint=False):
668                     for obj in objs:
669                         check_and_update_obj(obj)
670                         obj.save()
671         add.alters_data = True
672 
673         def create(self, **kwargs):
674             kwargs[self.field.name] = self.instance
675             db = router.db_for_write(self.model, instance=self.instance)
676             return super(RelatedManager, self.db_manager(db)).create(**kwargs)
677         create.alters_data = True
678 
679         def get_or_create(self, **kwargs):
680             kwargs[self.field.name] = self.instance
681             db = router.db_for_write(self.model, instance=self.instance)
682             return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)
683         get_or_create.alters_data = True
684 
685         def update_or_create(self, **kwargs):
686             kwargs[self.field.name] = self.instance
687             db = router.db_for_write(self.model, instance=self.instance)
688             return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)
689         update_or_create.alters_data = True
690 
691         # remove() and clear() are only provided if the ForeignKey can have a value of null.
692         if rel.field.null:
693             def remove(self, *objs, bulk=True):
694                 if not objs:
695                     return
696                 val = self.field.get_foreign_related_value(self.instance)
697                 old_ids = set()
698                 for obj in objs:
699                     if not isinstance(obj, self.model):
700                         raise TypeError("'%s' instance expected, got %r" % (
701                             self.model._meta.object_name, obj,
702                         ))
703                     # Is obj actually part of this descriptor set?
704                     if self.field.get_local_related_value(obj) == val:
705                         old_ids.add(obj.pk)
706                     else:
707                         raise self.field.remote_field.model.DoesNotExist(
708                             "%r is not related to %r." % (obj, self.instance)
709                         )
710                 self._clear(self.filter(pk__in=old_ids), bulk)
711             remove.alters_data = True
712 
713             def clear(self, *, bulk=True):
714                 self._clear(self, bulk)
715             clear.alters_data = True
716 
717             def _clear(self, queryset, bulk):
718                 self._remove_prefetched_objects()
719                 db = router.db_for_write(self.model, instance=self.instance)
720                 queryset = queryset.using(db)
721                 if bulk:
722                     # `QuerySet.update()` is intrinsically atomic.
723                     queryset.update(**{self.field.name: None})
724                 else:
725                     with transaction.atomic(using=db, savepoint=False):
726                         for obj in queryset:
727                             setattr(obj, self.field.name, None)
728                             obj.save(update_fields=[self.field.name])
729             _clear.alters_data = True
730 
731         def set(self, objs, *, bulk=True, clear=False):
732             # Force evaluation of `objs` in case it's a queryset whose value
733             # could be affected by `manager.clear()`. Refs #19816.
734             objs = tuple(objs)
735 
736             if self.field.null:
737                 db = router.db_for_write(self.model, instance=self.instance)
738                 with transaction.atomic(using=db, savepoint=False):
739                     if clear:
740                         self.clear(bulk=bulk)
741                         self.add(*objs, bulk=bulk)
742                     else:
743                         old_objs = set(self.using(db).all())
744                         new_objs = []
745                         for obj in objs:
746                             if obj in old_objs:
747                                 old_objs.remove(obj)
748                             else:
749                                 new_objs.append(obj)
750 
751                         self.remove(*old_objs, bulk=bulk)
752                         self.add(*new_objs, bulk=bulk)
753             else:
754                 self.add(*objs, bulk=bulk)
755         set.alters_data = True
756 
757     return RelatedManager
758 
759 
760 class ManyToManyDescriptor(ReverseManyToOneDescriptor):
761     """
762     Accessor to the related objects manager on the forward and reverse sides of
763     a many-to-many relation.
764 
765     In the example::
766 
767         class Pizza(Model):
768             toppings = ManyToManyField(Topping, related_name='pizzas')
769 
770     ``Pizza.toppings`` and ``Topping.pizzas`` are ``ManyToManyDescriptor``
771     instances.
772 
773     Most of the implementation is delegated to a dynamically defined manager
774     class built by ``create_forward_many_to_many_manager()`` defined below.
775     """
776 
777     def __init__(self, rel, reverse=False):
778         super().__init__(rel)
779 
780         self.reverse = reverse
781 
782     @property
783     def through(self):
784         # through is provided so that you have easy access to the through
785         # model (Book.authors.through) for inlines, etc. This is done as
786         # a property to ensure that the fully resolved value is returned.
787         return self.rel.through
788 
789     @cached_property
790     def related_manager_cls(self):
791         related_model = self.rel.related_model if self.reverse else self.rel.model
792 
793         return create_forward_many_to_many_manager(
794             related_model._default_manager.__class__,
795             self.rel,
796             reverse=self.reverse,
797         )
798 
799     def _get_set_deprecation_msg_params(self):
800         return (
801             '%s side of a many-to-many set' % ('reverse' if self.reverse else 'forward'),
802             self.rel.get_accessor_name() if self.reverse else self.field.name,
803         )
804 
805 
806 def create_forward_many_to_many_manager(superclass, rel, reverse):
807     """
808     Create a manager for the either side of a many-to-many relation.
809 
810     This manager subclasses another manager, generally the default manager of
811     the related model, and adds behaviors specific to many-to-many relations.
812     """
813 
814     class ManyRelatedManager(superclass):
815         def __init__(self, instance=None):
816             super().__init__()
817 
818             self.instance = instance
819 
820             if not reverse:
821                 self.model = rel.model
822                 self.query_field_name = rel.field.related_query_name()
823                 self.prefetch_cache_name = rel.field.name
824                 self.source_field_name = rel.field.m2m_field_name()
825                 self.target_field_name = rel.field.m2m_reverse_field_name()
826                 self.symmetrical = rel.symmetrical
827             else:
828                 self.model = rel.related_model
829                 self.query_field_name = rel.field.name
830                 self.prefetch_cache_name = rel.field.related_query_name()
831                 self.source_field_name = rel.field.m2m_reverse_field_name()
832                 self.target_field_name = rel.field.m2m_field_name()
833                 self.symmetrical = False
834 
835             self.through = rel.through
836             self.reverse = reverse
837 
838             self.source_field = self.through._meta.get_field(self.source_field_name)
839             self.target_field = self.through._meta.get_field(self.target_field_name)
840 
841             self.core_filters = {}
842             self.pk_field_names = {}
843             for lh_field, rh_field in self.source_field.related_fields:
844                 core_filter_key = '%s__%s' % (self.query_field_name, rh_field.name)
845                 self.core_filters[core_filter_key] = getattr(instance, rh_field.attname)
846                 self.pk_field_names[lh_field.name] = rh_field.name
847 
848             self.related_val = self.source_field.get_foreign_related_value(instance)
849             if None in self.related_val:
850                 raise ValueError('"%r" needs to have a value for field "%s" before '
851                                  'this many-to-many relationship can be used.' %
852                                  (instance, self.pk_field_names[self.source_field_name]))
853             # Even if this relation is not to pk, we require still pk value.
854             # The wish is that the instance has been already saved to DB,
855             # although having a pk value isn't a guarantee of that.
856             if instance.pk is None:
857                 raise ValueError("%r instance needs to have a primary key value before "
858                                  "a many-to-many relationship can be used." %
859                                  instance.__class__.__name__)
860 
861         def __call__(self, *, manager):
862             manager = getattr(self.model, manager)
863             manager_class = create_forward_many_to_many_manager(manager.__class__, rel, reverse)
864             return manager_class(instance=self.instance)
865         do_not_call_in_templates = True
866 
867         def _build_remove_filters(self, removed_vals):
868             filters = Q(**{self.source_field_name: self.related_val})
869             # No need to add a subquery condition if removed_vals is a QuerySet without
870             # filters.
871             removed_vals_filters = (not isinstance(removed_vals, QuerySet) or
872                                     removed_vals._has_filters())
873             if removed_vals_filters:
874                 filters &= Q(**{'%s__in' % self.target_field_name: removed_vals})
875             if self.symmetrical:
876                 symmetrical_filters = Q(**{self.target_field_name: self.related_val})
877                 if removed_vals_filters:
878                     symmetrical_filters &= Q(
879                         **{'%s__in' % self.source_field_name: removed_vals})
880                 filters |= symmetrical_filters
881             return filters
882 
883         def _apply_rel_filters(self, queryset):
884             """
885             Filter the queryset for the instance this manager is bound to.
886             """
887             queryset._add_hints(instance=self.instance)
888             if self._db:
889                 queryset = queryset.using(self._db)
890             queryset._defer_next_filter = True
891             return queryset._next_is_sticky().filter(**self.core_filters)
892 
893         def _remove_prefetched_objects(self):
894             try:
895                 self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)
896             except (AttributeError, KeyError):
897                 pass  # nothing to clear from cache
898 
899         def get_queryset(self):
900             try:
901                 return self.instance._prefetched_objects_cache[self.prefetch_cache_name]
902             except (AttributeError, KeyError):
903                 queryset = super().get_queryset()
904                 return self._apply_rel_filters(queryset)
905 
906         def get_prefetch_queryset(self, instances, queryset=None):
907             if queryset is None:
908                 queryset = super().get_queryset()
909 
910             queryset._add_hints(instance=instances[0])
911             queryset = queryset.using(queryset._db or self._db)
912 
913             query = {'%s__in' % self.query_field_name: instances}
914             queryset = queryset._next_is_sticky().filter(**query)
915 
916             # M2M: need to annotate the query in order to get the primary model
917             # that the secondary model was actually related to. We know that
918             # there will already be a join on the join table, so we can just add
919             # the select.
920 
921             # For non-autocreated 'through' models, can't assume we are
922             # dealing with PK values.
923             fk = self.through._meta.get_field(self.source_field_name)
924             join_table = fk.model._meta.db_table
925             connection = connections[queryset.db]
926             qn = connection.ops.quote_name
927             queryset = queryset.extra(select={
928                 '_prefetch_related_val_%s' % f.attname:
929                 '%s.%s' % (qn(join_table), qn(f.column)) for f in fk.local_related_fields})
930             return (
931                 queryset,
932                 lambda result: tuple(
933                     getattr(result, '_prefetch_related_val_%s' % f.attname)
934                     for f in fk.local_related_fields
935                 ),
936                 lambda inst: tuple(
937                     f.get_db_prep_value(getattr(inst, f.attname), connection)
938                     for f in fk.foreign_related_fields
939                 ),
940                 False,
941                 self.prefetch_cache_name,
942                 False,
943             )
944 
945         def add(self, *objs, through_defaults=None):
946             self._remove_prefetched_objects()
947             db = router.db_for_write(self.through, instance=self.instance)
948             with transaction.atomic(using=db, savepoint=False):
949                 self._add_items(
950                     self.source_field_name, self.target_field_name, *objs,
951                     through_defaults=through_defaults,
952                 )
953                 # If this is a symmetrical m2m relation to self, add the mirror
954                 # entry in the m2m table.
955                 if self.symmetrical:
956                     self._add_items(
957                         self.target_field_name,
958                         self.source_field_name,
959                         *objs,
960                         through_defaults=through_defaults,
961                     )
962         add.alters_data = True
963 
964         def remove(self, *objs):
965             self._remove_prefetched_objects()
966             self._remove_items(self.source_field_name, self.target_field_name, *objs)
967         remove.alters_data = True
968 
969         def clear(self):
970             db = router.db_for_write(self.through, instance=self.instance)
971             with transaction.atomic(using=db, savepoint=False):
972                 signals.m2m_changed.send(
973                     sender=self.through, action="pre_clear",
974                     instance=self.instance, reverse=self.reverse,
975                     model=self.model, pk_set=None, using=db,
976                 )
977                 self._remove_prefetched_objects()
978                 filters = self._build_remove_filters(super().get_queryset().using(db))
979                 self.through._default_manager.using(db).filter(filters).delete()
980 
981                 signals.m2m_changed.send(
982                     sender=self.through, action="post_clear",
983                     instance=self.instance, reverse=self.reverse,
984                     model=self.model, pk_set=None, using=db,
985                 )
986         clear.alters_data = True
987 
988         def set(self, objs, *, clear=False, through_defaults=None):
989             # Force evaluation of `objs` in case it's a queryset whose value
990             # could be affected by `manager.clear()`. Refs #19816.
991             objs = tuple(objs)
992 
993             db = router.db_for_write(self.through, instance=self.instance)
994             with transaction.atomic(using=db, savepoint=False):
995                 if clear:
996                     self.clear()
997                     self.add(*objs, through_defaults=through_defaults)
998                 else:
999                     old_ids = set(self.using(db).values_list(self.target_field.target_field.attname, flat=True))
1000 
1001                     new_objs = []
1002                     for obj in objs:
1003                         fk_val = (
1004                             self.target_field.get_foreign_related_value(obj)[0]
1005                             if isinstance(obj, self.model)
1006                             else self.target_field.get_prep_value(obj)
1007                         )
1008                         if fk_val in old_ids:
1009                             old_ids.remove(fk_val)
1010                         else:
1011                             new_objs.append(obj)
1012 
1013                     self.remove(*old_ids)
1014                     self.add(*new_objs, through_defaults=through_defaults)
1015         set.alters_data = True
1016 
1017         def create(self, *, through_defaults=None, **kwargs):
1018             db = router.db_for_write(self.instance.__class__, instance=self.instance)
1019             new_obj = super(ManyRelatedManager, self.db_manager(db)).create(**kwargs)
1020             self.add(new_obj, through_defaults=through_defaults)
1021             return new_obj
1022         create.alters_data = True
1023 
1024         def get_or_create(self, *, through_defaults=None, **kwargs):
1025             db = router.db_for_write(self.instance.__class__, instance=self.instance)
1026             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(**kwargs)
1027             # We only need to add() if created because if we got an object back
1028             # from get() then the relationship already exists.
1029             if created:
1030                 self.add(obj, through_defaults=through_defaults)
1031             return obj, created
1032         get_or_create.alters_data = True
1033 
1034         def update_or_create(self, *, through_defaults=None, **kwargs):
1035             db = router.db_for_write(self.instance.__class__, instance=self.instance)
1036             obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)
1037             # We only need to add() if created because if we got an object back
1038             # from get() then the relationship already exists.
1039             if created:
1040                 self.add(obj, through_defaults=through_defaults)
1041             return obj, created
1042         update_or_create.alters_data = True
1043 
1044         def _get_target_ids(self, target_field_name, objs):
1045             """
1046             Return the set of ids of `objs` that the target field references.
1047             """
1048             from django.db.models import Model
1049             target_ids = set()
1050             target_field = self.through._meta.get_field(target_field_name)
1051             for obj in objs:
1052                 if isinstance(obj, self.model):
1053                     if not router.allow_relation(obj, self.instance):
1054                         raise ValueError(
1055                             'Cannot add "%r": instance is on database "%s", '
1056                             'value is on database "%s"' %
1057                             (obj, self.instance._state.db, obj._state.db)
1058                         )
1059                     target_id = target_field.get_foreign_related_value(obj)[0]
1060                     if target_id is None:
1061                         raise ValueError(
1062                             'Cannot add "%r": the value for field "%s" is None' %
1063                             (obj, target_field_name)
1064                         )
1065                     target_ids.add(target_id)
1066                 elif isinstance(obj, Model):
1067                     raise TypeError(
1068                         "'%s' instance expected, got %r" %
1069                         (self.model._meta.object_name, obj)
1070                     )
1071                 else:
1072                     target_ids.add(target_field.get_prep_value(obj))
1073             return target_ids
1074 
1075         def _get_missing_target_ids(self, source_field_name, target_field_name, db, target_ids):
1076             """
1077             Return the subset of ids of `objs` that aren't already assigned to
1078             this relationship.
1079             """
1080             vals = self.through._default_manager.using(db).values_list(
1081                 target_field_name, flat=True
1082             ).filter(**{
1083                 source_field_name: self.related_val[0],
1084                 '%s__in' % target_field_name: target_ids,
1085             })
1086             return target_ids.difference(vals)
1087 
1088         def _get_add_plan(self, db, source_field_name):
1089             """
1090             Return a boolean triple of the way the add should be performed.
1091 
1092             The first element is whether or not bulk_create(ignore_conflicts)
1093             can be used, the second whether or not signals must be sent, and
1094             the third element is whether or not the immediate bulk insertion
1095             with conflicts ignored can be performed.
1096             """
1097             # Conflicts can be ignored when the intermediary model is
1098             # auto-created as the only possible collision is on the
1099             # (source_id, target_id) tuple. The same assertion doesn't hold for
1100             # user-defined intermediary models as they could have other fields
1101             # causing conflicts which must be surfaced.
1102             can_ignore_conflicts = (
1103                 connections[db].features.supports_ignore_conflicts and
1104                 self.through._meta.auto_created is not False
1105             )
1106             # Don't send the signal when inserting duplicate data row
1107             # for symmetrical reverse entries.
1108             must_send_signals = (self.reverse or source_field_name == self.source_field_name) and (
1109                 signals.m2m_changed.has_listeners(self.through)
1110             )
1111             # Fast addition through bulk insertion can only be performed
1112             # if no m2m_changed listeners are connected for self.through
1113             # as they require the added set of ids to be provided via
1114             # pk_set.
1115             return can_ignore_conflicts, must_send_signals, (can_ignore_conflicts and not must_send_signals)
1116 
1117         def _add_items(self, source_field_name, target_field_name, *objs, through_defaults=None):
1118             # source_field_name: the PK fieldname in join table for the source object
1119             # target_field_name: the PK fieldname in join table for the target object
1120             # *objs - objects to add. Either object instances, or primary keys of object instances.
1121             if not objs:
1122                 return
1123 
1124             through_defaults = dict(resolve_callables(through_defaults or {}))
1125             target_ids = self._get_target_ids(target_field_name, objs)
1126             db = router.db_for_write(self.through, instance=self.instance)
1127             can_ignore_conflicts, must_send_signals, can_fast_add = self._get_add_plan(db, source_field_name)
1128             if can_fast_add:
1129                 self.through._default_manager.using(db).bulk_create([
1130                     self.through(**{
1131                         '%s_id' % source_field_name: self.related_val[0],
1132                         '%s_id' % target_field_name: target_id,
1133                     })
1134                     for target_id in target_ids
1135                 ], ignore_conflicts=True)
1136                 return
1137 
1138             missing_target_ids = self._get_missing_target_ids(
1139                 source_field_name, target_field_name, db, target_ids
1140             )
1141             with transaction.atomic(using=db, savepoint=False):
1142                 if must_send_signals:
1143                     signals.m2m_changed.send(
1144                         sender=self.through, action='pre_add',
1145                         instance=self.instance, reverse=self.reverse,
1146                         model=self.model, pk_set=missing_target_ids, using=db,
1147                     )
1148                 # Add the ones that aren't there already.
1149                 self.through._default_manager.using(db).bulk_create([
1150                     self.through(**through_defaults, **{
1151                         '%s_id' % source_field_name: self.related_val[0],
1152                         '%s_id' % target_field_name: target_id,
1153                     })
1154                     for target_id in missing_target_ids
1155                 ], ignore_conflicts=can_ignore_conflicts)
1156 
1157                 if must_send_signals:
1158                     signals.m2m_changed.send(
1159                         sender=self.through, action='post_add',
1160                         instance=self.instance, reverse=self.reverse,
1161                         model=self.model, pk_set=missing_target_ids, using=db,
1162                     )
1163 
1164         def _remove_items(self, source_field_name, target_field_name, *objs):
1165             # source_field_name: the PK colname in join table for the source object
1166             # target_field_name: the PK colname in join table for the target object
1167             # *objs - objects to remove. Either object instances, or primary
1168             # keys of object instances.
1169             if not objs:
1170                 return
1171 
1172             # Check that all the objects are of the right type
1173             old_ids = set()
1174             for obj in objs:
1175                 if isinstance(obj, self.model):
1176                     fk_val = self.target_field.get_foreign_related_value(obj)[0]
1177                     old_ids.add(fk_val)
1178                 else:
1179                     old_ids.add(obj)
1180 
1181             db = router.db_for_write(self.through, instance=self.instance)
1182             with transaction.atomic(using=db, savepoint=False):
1183                 # Send a signal to the other end if need be.
1184                 signals.m2m_changed.send(
1185                     sender=self.through, action="pre_remove",
1186                     instance=self.instance, reverse=self.reverse,
1187                     model=self.model, pk_set=old_ids, using=db,
1188                 )
1189                 target_model_qs = super().get_queryset()
1190                 if target_model_qs._has_filters():
1191                     old_vals = target_model_qs.using(db).filter(**{
1192                         '%s__in' % self.target_field.target_field.attname: old_ids})
1193                 else:
1194                     old_vals = old_ids
1195                 filters = self._build_remove_filters(old_vals)
1196                 self.through._default_manager.using(db).filter(filters).delete()
1197 
1198                 signals.m2m_changed.send(
1199                     sender=self.through, action="post_remove",
1200                     instance=self.instance, reverse=self.reverse,
1201                     model=self.model, pk_set=old_ids, using=db,
1202                 )
1203 
1204     return ManyRelatedManager

</code><intended_behavior>Assess and possibly modify the handling of FK fields in the context of model instance copying. Since FK relationships are a central concern in the reported issue, ensure that any copying or cloning of model instances properly updates FK references in the newly created instance without inadvertently altering the original instance's state. This might require implementing deep copy logic specific to FK fields or enhancing how Django's model layer treats FK fields during any form of instance duplication.</intended_behavior>]
2025-10-15 05:06:23.638 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 05:06:23.639 | INFO     | Search-only: skipping patch selection
2025-10-15 05:06:23.777 | INFO     | Task django__django-13281 completed successfully.
2025-10-15 05:06:23.778 | INFO     | No patch generated. You can try running ACR again.
