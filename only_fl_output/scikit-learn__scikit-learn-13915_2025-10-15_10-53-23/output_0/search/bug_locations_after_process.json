[
    {
        "rel_file_path": "sklearn/utils/sparsefuncs.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/utils/sparsefuncs.py",
        "start": 342,
        "end": 345,
        "class_name": null,
        "method_name": "_minor_reduce",
        "code": "342 def _minor_reduce(X, ufunc):\n343     major_index = np.flatnonzero(np.diff(X.indptr))\n344     value = ufunc.reduceat(X.data, X.indptr[major_index])\n345     return major_index, value\n",
        "intended_behavior": "This function should be able to gracefully handle `indptr` arrays of type `int64` without causing a TypeError due to unsafe casting on 32-bit systems. The intended fix should ensure that the reduce operation (`ufunc.reduceat`) accommodates `int64` indices safely. This might involve checking the system architecture (32-bit vs. 64-bit) and adjusting the operation to handle `int64` indices appropriately or ensuring that dtype casting from `int64` to `int32` (if it must happen) is done in a manner that does not lead to data loss or errors. The goal is to maintain functionality while ensuring compatibility across different system architectures."
    },
    {
        "rel_file_path": "sklearn/utils/sparsefuncs.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/utils/sparsefuncs.py",
        "start": 348,
        "end": 368,
        "class_name": null,
        "method_name": "_min_or_max_axis",
        "code": "348 def _min_or_max_axis(X, axis, min_or_max):\n349     N = X.shape[axis]\n350     if N == 0:\n351         raise ValueError(\"zero-size array to reduction operation\")\n352     M = X.shape[1 - axis]\n353     mat = X.tocsc() if axis == 0 else X.tocsr()\n354     mat.sum_duplicates()\n355     major_index, value = _minor_reduce(mat, min_or_max)\n356     not_full = np.diff(mat.indptr)[major_index] < N\n357     value[not_full] = min_or_max(value[not_full], 0)\n358     mask = value != 0\n359     major_index = np.compress(mask, major_index)\n360     value = np.compress(mask, value)\n361 \n362     if axis == 0:\n363         res = sp.coo_matrix((value, (np.zeros(len(value)), major_index)),\n364                             dtype=X.dtype, shape=(1, M))\n365     else:\n366         res = sp.coo_matrix((value, (major_index, np.zeros(len(value)))),\n367                             dtype=X.dtype, shape=(M, 1))\n368     return res.A.ravel()\n",
        "intended_behavior": "While this method directly might not throw the error, ensuring that it correctly interfaces with matrices whose `indptr` is `int64`, especially after the adjustments made in `_minor_reduce`, is crucial. This might involve ensuring that any temporary matrices or operations accommodated within this method (as part of the min/max axis computation) are fully compatible with the changes made to support `int64` `indptr`. The intended behavior is to preserve existing functionality while robustly supporting operations on large matrices, especially on 32-bit systems. The adjustments made should ensure no data type incompatibility errors arise from operations involving `indptr`."
    }
]