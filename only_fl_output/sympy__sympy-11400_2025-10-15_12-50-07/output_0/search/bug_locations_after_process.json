[
    {
        "rel_file_path": "sympy/printing/ccode.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/printing/ccode.py",
        "start": 283,
        "end": 396,
        "class_name": null,
        "method_name": "ccode",
        "code": "283 def ccode(expr, assign_to=None, **settings):\n284     \"\"\"Converts an expr to a string of c code\n285 \n286     Parameters\n287     ==========\n288 \n289     expr : Expr\n290         A sympy expression to be converted.\n291     assign_to : optional\n292         When given, the argument is used as the name of the variable to which\n293         the expression is assigned. Can be a string, ``Symbol``,\n294         ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n295         line-wrapping, or for expressions that generate multi-line statements.\n296     precision : integer, optional\n297         The precision for numbers such as pi [default=15].\n298     user_functions : dict, optional\n299         A dictionary where the keys are string representations of either\n300         ``FunctionClass`` or ``UndefinedFunction`` instances and the values\n301         are their desired C string representations. Alternatively, the\n302         dictionary value can be a list of tuples i.e. [(argument_test,\n303         cfunction_string)].  See below for examples.\n304     dereference : iterable, optional\n305         An iterable of symbols that should be dereferenced in the printed code\n306         expression. These would be values passed by address to the function.\n307         For example, if ``dereference=[a]``, the resulting code would print\n308         ``(*a)`` instead of ``a``.\n309     human : bool, optional\n310         If True, the result is a single string that may contain some constant\n311         declarations for the number symbols. If False, the same information is\n312         returned in a tuple of (symbols_to_declare, not_supported_functions,\n313         code_text). [default=True].\n314     contract: bool, optional\n315         If True, ``Indexed`` instances are assumed to obey tensor contraction\n316         rules and the corresponding nested loops over indices are generated.\n317         Setting contract=False will not generate loops, instead the user is\n318         responsible to provide values for the indices in the code.\n319         [default=True].\n320 \n321     Examples\n322     ========\n323 \n324     >>> from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function\n325     >>> x, tau = symbols(\"x, tau\")\n326     >>> ccode((2*tau)**Rational(7, 2))\n327     '8*sqrt(2)*pow(tau, 7.0L/2.0L)'\n328     >>> ccode(sin(x), assign_to=\"s\")\n329     's = sin(x);'\n330 \n331     Simple custom printing can be defined for certain types by passing a\n332     dictionary of {\"type\" : \"function\"} to the ``user_functions`` kwarg.\n333     Alternatively, the dictionary value can be a list of tuples i.e.\n334     [(argument_test, cfunction_string)].\n335 \n336     >>> custom_functions = {\n337     ...   \"ceiling\": \"CEIL\",\n338     ...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n339     ...           (lambda x: x.is_integer, \"ABS\")],\n340     ...   \"func\": \"f\"\n341     ... }\n342     >>> func = Function('func')\n343     >>> ccode(func(Abs(x) + ceiling(x)), user_functions=custom_functions)\n344     'f(fabs(x) + CEIL(x))'\n345 \n346     ``Piecewise`` expressions are converted into conditionals. If an\n347     ``assign_to`` variable is provided an if statement is created, otherwise\n348     the ternary operator is used. Note that if the ``Piecewise`` lacks a\n349     default term, represented by ``(expr, True)`` then an error will be thrown.\n350     This is to prevent generating an expression that may not evaluate to\n351     anything.\n352 \n353     >>> from sympy import Piecewise\n354     >>> expr = Piecewise((x + 1, x > 0), (x, True))\n355     >>> print(ccode(expr, tau))\n356     if (x > 0) {\n357     tau = x + 1;\n358     }\n359     else {\n360     tau = x;\n361     }\n362 \n363     Support for loops is provided through ``Indexed`` types. With\n364     ``contract=True`` these expressions will be turned into loops, whereas\n365     ``contract=False`` will just print the assignment expression that should be\n366     looped over:\n367 \n368     >>> from sympy import Eq, IndexedBase, Idx\n369     >>> len_y = 5\n370     >>> y = IndexedBase('y', shape=(len_y,))\n371     >>> t = IndexedBase('t', shape=(len_y,))\n372     >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n373     >>> i = Idx('i', len_y-1)\n374     >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n375     >>> ccode(e.rhs, assign_to=e.lhs, contract=False)\n376     'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'\n377 \n378     Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n379     must be provided to ``assign_to``. Note that any expression that can be\n380     generated normally can also exist inside a Matrix:\n381 \n382     >>> from sympy import Matrix, MatrixSymbol\n383     >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n384     >>> A = MatrixSymbol('A', 3, 1)\n385     >>> print(ccode(mat, A))\n386     A[0] = pow(x, 2);\n387     if (x > 0) {\n388        A[1] = x + 1;\n389     }\n390     else {\n391        A[1] = x;\n392     }\n393     A[2] = sin(x);\n394     \"\"\"\n395 \n396     return CCodePrinter(settings).doprint(expr, assign_to)\n",
        "intended_behavior": "The `ccode` method should be enhanced to include support for converting `sinc(x)` expressions into an equivalent C code representation. Given that `sinc(x)` can be expressed as `sin(x)/x` for `x != 0`, and `1` for `x = 0`, the method should incorporate logic similar to handling `Piecewise` expressions, as evidenced in the current implementation for other mathematical expressions. The addition should preserve all existing functionalities of the `ccode` method, only extending it to recognize and properly convert `sinc(x)` expressions. Potential approaches include either directly implementing the conversion within the method based on detected `sinc(x)` patterns or leveraging the `user_functions` argument more effectively to allow users to specify custom conversions for unsupported functions like `sinc(x)`."
    },
    {
        "rel_file_path": "sympy/functions/elementary/trigonometric.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/elementary/trigonometric.py",
        "start": 1,
        "end": 2689,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.core.add import Add\n4 from sympy.core.basic import sympify, cacheit\n5 from sympy.core.function import Function, ArgumentIndexError\n6 from sympy.core.numbers import igcdex, Rational\n7 from sympy.core.singleton import S\n8 from sympy.core.symbol import Symbol\n9 from sympy.core.logic import fuzzy_not\n10 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n11 from sympy.functions.elementary.miscellaneous import sqrt, Min, Max\n12 from sympy.functions.elementary.exponential import log, exp\n13 from sympy.functions.elementary.integers import floor\n14 from sympy.functions.elementary.hyperbolic import (acoth, asinh, atanh, cosh,\n15     coth, HyperbolicFunction, sinh, tanh)\n16 from sympy.sets.sets import FiniteSet\n17 from sympy.utilities.iterables import numbered_symbols\n18 from sympy.core.compatibility import range\n19 \n20 ###############################################################################\n21 ########################## TRIGONOMETRIC FUNCTIONS ############################\n22 ###############################################################################\n23 \n24 \n25 class TrigonometricFunction(Function):\n26     \"\"\"Base class for trigonometric functions. \"\"\"\n27 \n28     unbranched = True\n29 \n30     def _eval_is_rational(self):\n31         s = self.func(*self.args)\n32         if s.func == self.func:\n33             if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):\n34                 return False\n35         else:\n36             return s.is_rational\n37 \n38     def _eval_is_algebraic(self):\n39         s = self.func(*self.args)\n40         if s.func == self.func:\n41             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:\n42                 return False\n43             pi_coeff = _pi_coeff(self.args[0])\n44             if pi_coeff is not None and pi_coeff.is_rational:\n45                 return True\n46         else:\n47             return s.is_algebraic\n48 \n49     def _eval_expand_complex(self, deep=True, **hints):\n50         re_part, im_part = self.as_real_imag(deep=deep, **hints)\n51         return re_part + im_part*S.ImaginaryUnit\n52 \n53     def _as_real_imag(self, deep=True, **hints):\n54         if self.args[0].is_real:\n55             if deep:\n56                 hints['complex'] = False\n57                 return (self.args[0].expand(deep, **hints), S.Zero)\n58             else:\n59                 return (self.args[0], S.Zero)\n60         if deep:\n61             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n62         else:\n63             re, im = self.args[0].as_real_imag()\n64         return (re, im)\n65 \n66 \n67 def _peeloff_pi(arg):\n68     \"\"\"\n69     Split ARG into two parts, a \"rest\" and a multiple of pi/2.\n70     This assumes ARG to be an Add.\n71     The multiple of pi returned in the second position is always a Rational.\n72 \n73     Examples\n74     ========\n75 \n76     >>> from sympy.functions.elementary.trigonometric import _peeloff_pi as peel\n77     >>> from sympy import pi\n78     >>> from sympy.abc import x, y\n79     >>> peel(x + pi/2)\n80     (x, pi/2)\n81     >>> peel(x + 2*pi/3 + pi*y)\n82     (x + pi*y + pi/6, pi/2)\n83     \"\"\"\n84     for a in Add.make_args(arg):\n85         if a is S.Pi:\n86             K = S.One\n87             break\n88         elif a.is_Mul:\n89             K, p = a.as_two_terms()\n90             if p is S.Pi and K.is_Rational:\n91                 break\n92     else:\n93         return arg, S.Zero\n94 \n95     m1 = (K % S.Half) * S.Pi\n96     m2 = K*S.Pi - m1\n97     return arg - m2, m2\n98 \n99 \n100 def _pi_coeff(arg, cycles=1):\n101     \"\"\"\n102     When arg is a Number times pi (e.g. 3*pi/2) then return the Number\n103     normalized to be in the range [0, 2], else None.\n104 \n105     When an even multiple of pi is encountered, if it is multiplying\n106     something with known parity then the multiple is returned as 0 otherwise\n107     as 2.\n108 \n109     Examples\n110     ========\n111 \n112     >>> from sympy.functions.elementary.trigonometric import _pi_coeff as coeff\n113     >>> from sympy import pi, Dummy\n114     >>> from sympy.abc import x, y\n115     >>> coeff(3*x*pi)\n116     3*x\n117     >>> coeff(11*pi/7)\n118     11/7\n119     >>> coeff(-11*pi/7)\n120     3/7\n121     >>> coeff(4*pi)\n122     0\n123     >>> coeff(5*pi)\n124     1\n125     >>> coeff(5.0*pi)\n126     1\n127     >>> coeff(5.5*pi)\n128     3/2\n129     >>> coeff(2 + pi)\n130 \n131     >>> coeff(2*Dummy(integer=True)*pi)\n132     2\n133     >>> coeff(2*Dummy(even=True)*pi)\n134     0\n135     \"\"\"\n136     arg = sympify(arg)\n137     if arg is S.Pi:\n138         return S.One\n139     elif not arg:\n140         return S.Zero\n141     elif arg.is_Mul:\n142         cx = arg.coeff(S.Pi)\n143         if cx:\n144             c, x = cx.as_coeff_Mul()  # pi is not included as coeff\n145             if c.is_Float:\n146                 # recast exact binary fractions to Rationals\n147                 f = abs(c) % 1\n148                 if f != 0:\n149                     p = -int(round(log(f, 2).evalf()))\n150                     m = 2**p\n151                     cm = c*m\n152                     i = int(cm)\n153                     if i == cm:\n154                         c = Rational(i, m)\n155                         cx = c*x\n156                 else:\n157                     c = Rational(int(c))\n158                     cx = c*x\n159             if x.is_integer:\n160                 c2 = c % 2\n161                 if c2 == 1:\n162                     return x\n163                 elif not c2:\n164                     if x.is_even is not None:  # known parity\n165                         return S.Zero\n166                     return S(2)\n167                 else:\n168                     return c2*x\n169             return cx\n170 \n171 \n172 class sin(TrigonometricFunction):\n173     \"\"\"\n174     The sine function.\n175 \n176     Returns the sine of x (measured in radians).\n177 \n178     Notes\n179     =====\n180 \n181     This function will evaluate automatically in the\n182     case x/pi is some rational number [4]_.  For example,\n183     if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.\n184 \n185     Examples\n186     ========\n187 \n188     >>> from sympy import sin, pi\n189     >>> from sympy.abc import x\n190     >>> sin(x**2).diff(x)\n191     2*x*cos(x**2)\n192     >>> sin(1).diff(x)\n193     0\n194     >>> sin(pi)\n195     0\n196     >>> sin(pi/2)\n197     1\n198     >>> sin(pi/6)\n199     1/2\n200     >>> sin(pi/12)\n201     -sqrt(2)/4 + sqrt(6)/4\n202 \n203 \n204     See Also\n205     ========\n206 \n207     csc, cos, sec, tan, cot\n208     asin, acsc, acos, asec, atan, acot, atan2\n209 \n210     References\n211     ==========\n212 \n213     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n214     .. [2] http://dlmf.nist.gov/4.14\n215     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin\n216     .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html\n217     \"\"\"\n218 \n219     def fdiff(self, argindex=1):\n220         if argindex == 1:\n221             return cos(self.args[0])\n222         else:\n223             raise ArgumentIndexError(self, argindex)\n224 \n225     @classmethod\n226     def eval(cls, arg):\n227         from sympy.calculus import AccumBounds\n228         if arg.is_Number:\n229             if arg is S.NaN:\n230                 return S.NaN\n231             elif arg is S.Zero:\n232                 return S.Zero\n233             elif arg is S.Infinity or arg is S.NegativeInfinity:\n234                 return AccumBounds(-1, 1)\n235 \n236         if isinstance(arg, AccumBounds):\n237             min, max = arg.min, arg.max\n238             d = floor(min/(2*S.Pi))\n239             if min is not S.NegativeInfinity:\n240                 min = min - d*2*S.Pi\n241             if max is not S.Infinity:\n242                 max = max - d*2*S.Pi\n243             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \\\n244                     is not S.EmptySet and \\\n245                     AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,\n246                         7*S.Pi/2)) is not S.EmptySet:\n247                 return AccumBounds(-1, 1)\n248             elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \\\n249                     is not S.EmptySet:\n250                 return AccumBounds(Min(sin(min), sin(max)), 1)\n251             elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \\\n252                         is not S.EmptySet:\n253                 return AccumBounds(-1, Max(sin(min), sin(max)))\n254             else:\n255                 return AccumBounds(Min(sin(min), sin(max)),\n256                                 Max(sin(min), sin(max)))\n257 \n258         if arg.could_extract_minus_sign():\n259             return -cls(-arg)\n260 \n261         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n262         if i_coeff is not None:\n263             return S.ImaginaryUnit * sinh(i_coeff)\n264 \n265         pi_coeff = _pi_coeff(arg)\n266         if pi_coeff is not None:\n267             if pi_coeff.is_integer:\n268                 return S.Zero\n269 \n270             if (2*pi_coeff).is_integer:\n271                 if pi_coeff.is_even:\n272                     return S.Zero\n273                 elif pi_coeff.is_even is False:\n274                     return S.NegativeOne**(pi_coeff - S.Half)\n275 \n276             if not pi_coeff.is_Rational:\n277                 narg = pi_coeff*S.Pi\n278                 if narg != arg:\n279                     return cls(narg)\n280                 return None\n281 \n282             # https://github.com/sympy/sympy/issues/6048\n283             # transform a sine to a cosine, to avoid redundant code\n284             if pi_coeff.is_Rational:\n285                 x = pi_coeff % 2\n286                 if x > 1:\n287                     return -cls((x % 1)*S.Pi)\n288                 if 2*x > 1:\n289                     return cls((1 - x)*S.Pi)\n290                 narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi\n291                 result = cos(narg)\n292                 if not isinstance(result, cos):\n293                     return result\n294                 if pi_coeff*S.Pi != arg:\n295                     return cls(pi_coeff*S.Pi)\n296                 return None\n297 \n298         if arg.is_Add:\n299             x, m = _peeloff_pi(arg)\n300             if m:\n301                 return sin(m)*cos(x) + cos(m)*sin(x)\n302 \n303         if arg.func is asin:\n304             return arg.args[0]\n305 \n306         if arg.func is atan:\n307             x = arg.args[0]\n308             return x / sqrt(1 + x**2)\n309 \n310         if arg.func is atan2:\n311             y, x = arg.args\n312             return y / sqrt(x**2 + y**2)\n313 \n314         if arg.func is acos:\n315             x = arg.args[0]\n316             return sqrt(1 - x**2)\n317 \n318         if arg.func is acot:\n319             x = arg.args[0]\n320             return 1 / (sqrt(1 + 1 / x**2) * x)\n321 \n322     @staticmethod\n323     @cacheit\n324     def taylor_term(n, x, *previous_terms):\n325         if n < 0 or n % 2 == 0:\n326             return S.Zero\n327         else:\n328             x = sympify(x)\n329 \n330             if len(previous_terms) > 2:\n331                 p = previous_terms[-2]\n332                 return -p * x**2 / (n*(n - 1))\n333             else:\n334                 return (-1)**(n//2) * x**(n)/factorial(n)\n335 \n336     def _eval_rewrite_as_exp(self, arg):\n337         I = S.ImaginaryUnit\n338         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n339             arg = arg.func(arg.args[0]).rewrite(exp)\n340         return (exp(arg*I) - exp(-arg*I)) / (2*I)\n341 \n342     def _eval_rewrite_as_Pow(self, arg):\n343         if arg.func is log:\n344             I = S.ImaginaryUnit\n345             x = arg.args[0]\n346             return I*x**-I / 2 - I*x**I /2\n347 \n348     def _eval_rewrite_as_cos(self, arg):\n349         return -cos(arg + S.Pi/2)\n350 \n351     def _eval_rewrite_as_tan(self, arg):\n352         tan_half = tan(S.Half*arg)\n353         return 2*tan_half/(1 + tan_half**2)\n354 \n355     def _eval_rewrite_as_sincos(self, arg):\n356         return sin(arg)*cos(arg)/cos(arg)\n357 \n358     def _eval_rewrite_as_cot(self, arg):\n359         cot_half = cot(S.Half*arg)\n360         return 2*cot_half/(1 + cot_half**2)\n361 \n362     def _eval_rewrite_as_pow(self, arg):\n363         return self.rewrite(cos).rewrite(pow)\n364 \n365     def _eval_rewrite_as_sqrt(self, arg):\n366         return self.rewrite(cos).rewrite(sqrt)\n367 \n368     def _eval_rewrite_as_csc(self, arg):\n369         return 1/csc(arg)\n370 \n371     def _eval_conjugate(self):\n372         return self.func(self.args[0].conjugate())\n373 \n374     def as_real_imag(self, deep=True, **hints):\n375         re, im = self._as_real_imag(deep=deep, **hints)\n376         return (sin(re)*cosh(im), cos(re)*sinh(im))\n377 \n378     def _eval_expand_trig(self, **hints):\n379         from sympy import expand_mul\n380         from sympy.functions.special.polynomials import chebyshevt, chebyshevu\n381         arg = self.args[0]\n382         x = None\n383         if arg.is_Add:  # TODO, implement more if deep stuff here\n384             # TODO: Do this more efficiently for more than two terms\n385             x, y = arg.as_two_terms()\n386             sx = sin(x, evaluate=False)._eval_expand_trig()\n387             sy = sin(y, evaluate=False)._eval_expand_trig()\n388             cx = cos(x, evaluate=False)._eval_expand_trig()\n389             cy = cos(y, evaluate=False)._eval_expand_trig()\n390             return sx*cy + sy*cx\n391         else:\n392             n, x = arg.as_coeff_Mul(rational=True)\n393             if n.is_Integer:  # n will be positive because of .eval\n394                 # canonicalization\n395 \n396                 # See http://mathworld.wolfram.com/Multiple-AngleFormulas.html\n397                 if n.is_odd:\n398                     return (-1)**((n - 1)/2)*chebyshevt(n, sin(x))\n399                 else:\n400                     return expand_mul((-1)**(n/2 - 1)*cos(x)*chebyshevu(n -\n401                         1, sin(x)), deep=False)\n402             pi_coeff = _pi_coeff(arg)\n403             if pi_coeff is not None:\n404                 if pi_coeff.is_Rational:\n405                     return self.rewrite(sqrt)\n406         return sin(arg)\n407 \n408     def _eval_as_leading_term(self, x):\n409         from sympy import Order\n410         arg = self.args[0].as_leading_term(x)\n411 \n412         if x in arg.free_symbols and Order(1, x).contains(arg):\n413             return arg\n414         else:\n415             return self.func(arg)\n416 \n417     def _eval_is_real(self):\n418         return self.args[0].is_real\n419 \n420     def _eval_is_finite(self):\n421         arg = self.args[0]\n422         if arg.is_real:\n423             return True\n424 \n425 \n426 class cos(TrigonometricFunction):\n427     \"\"\"\n428     The cosine function.\n429 \n430     Returns the cosine of x (measured in radians).\n431 \n432     Notes\n433     =====\n434 \n435     See :func:`sin` for notes about automatic evaluation.\n436 \n437     Examples\n438     ========\n439 \n440     >>> from sympy import cos, pi\n441     >>> from sympy.abc import x\n442     >>> cos(x**2).diff(x)\n443     -2*x*sin(x**2)\n444     >>> cos(1).diff(x)\n445     0\n446     >>> cos(pi)\n447     -1\n448     >>> cos(pi/2)\n449     0\n450     >>> cos(2*pi/3)\n451     -1/2\n452     >>> cos(pi/12)\n453     sqrt(2)/4 + sqrt(6)/4\n454 \n455     See Also\n456     ========\n457 \n458     sin, csc, sec, tan, cot\n459     asin, acsc, acos, asec, atan, acot, atan2\n460 \n461     References\n462     ==========\n463 \n464     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n465     .. [2] http://dlmf.nist.gov/4.14\n466     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos\n467     \"\"\"\n468 \n469     def fdiff(self, argindex=1):\n470         if argindex == 1:\n471             return -sin(self.args[0])\n472         else:\n473             raise ArgumentIndexError(self, argindex)\n474 \n475     @classmethod\n476     def eval(cls, arg):\n477         from sympy.functions.special.polynomials import chebyshevt\n478         from sympy.calculus.util import AccumBounds\n479         if arg.is_Number:\n480             if arg is S.NaN:\n481                 return S.NaN\n482             elif arg is S.Zero:\n483                 return S.One\n484             elif arg is S.Infinity or arg is S.NegativeInfinity:\n485                 # In this case it is better to return AccumBounds(-1, 1)\n486                 # rather than returning S.NaN, since AccumBounds(-1, 1)\n487                 # preserves the information that sin(oo) is between\n488                 # -1 and 1, where S.NaN does not do that.\n489                 return AccumBounds(-1, 1)\n490 \n491         if isinstance(arg, AccumBounds):\n492             return sin(arg + S.Pi/2)\n493 \n494         if arg.could_extract_minus_sign():\n495             return cls(-arg)\n496 \n497         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n498         if i_coeff is not None:\n499             return cosh(i_coeff)\n500 \n501         pi_coeff = _pi_coeff(arg)\n502         if pi_coeff is not None:\n503             if pi_coeff.is_integer:\n504                 return (S.NegativeOne)**pi_coeff\n505 \n506             if (2*pi_coeff).is_integer:\n507                 if pi_coeff.is_even:\n508                     return (S.NegativeOne)**(pi_coeff/2)\n509                 elif pi_coeff.is_even is False:\n510                     return S.Zero\n511 \n512             if not pi_coeff.is_Rational:\n513                 narg = pi_coeff*S.Pi\n514                 if narg != arg:\n515                     return cls(narg)\n516                 return None\n517 \n518             # cosine formula #####################\n519             # https://github.com/sympy/sympy/issues/6048\n520             # explicit calculations are preformed for\n521             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120\n522             # Some other exact values like cos(k pi/240) can be\n523             # calculated using a partial-fraction decomposition\n524             # by calling cos( X ).rewrite(sqrt)\n525             cst_table_some = {\n526                 3: S.Half,\n527                 5: (sqrt(5) + 1)/4,\n528             }\n529             if pi_coeff.is_Rational:\n530                 q = pi_coeff.q\n531                 p = pi_coeff.p % (2*q)\n532                 if p > q:\n533                     narg = (pi_coeff - 1)*S.Pi\n534                     return -cls(narg)\n535                 if 2*p > q:\n536                     narg = (1 - pi_coeff)*S.Pi\n537                     return -cls(narg)\n538 \n539                 # If nested sqrt's are worse than un-evaluation\n540                 # you can require q to be in (1, 2, 3, 4, 6, 12)\n541                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return\n542                 # expressions with 2 or fewer sqrt nestings.\n543                 table2 = {\n544                     12: (3, 4),\n545                     20: (4, 5),\n546                     30: (5, 6),\n547                     15: (6, 10),\n548                     24: (6, 8),\n549                     40: (8, 10),\n550                     60: (20, 30),\n551                     120: (40, 60)\n552                     }\n553                 if q in table2:\n554                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]\n555                     nvala, nvalb = cls(a), cls(b)\n556                     if None == nvala or None == nvalb:\n557                         return None\n558                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)\n559 \n560                 if q > 12:\n561                     return None\n562 \n563                 if q in cst_table_some:\n564                     cts = cst_table_some[pi_coeff.q]\n565                     return chebyshevt(pi_coeff.p, cts).expand()\n566 \n567                 if 0 == q % 2:\n568                     narg = (pi_coeff*2)*S.Pi\n569                     nval = cls(narg)\n570                     if None == nval:\n571                         return None\n572                     x = (2*pi_coeff + 1)/2\n573                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))\n574                     return sign_cos*sqrt( (1 + nval)/2 )\n575             return None\n576 \n577         if arg.is_Add:\n578             x, m = _peeloff_pi(arg)\n579             if m:\n580                 return cos(m)*cos(x) - sin(m)*sin(x)\n581 \n582         if arg.func is acos:\n583             return arg.args[0]\n584 \n585         if arg.func is atan:\n586             x = arg.args[0]\n587             return 1 / sqrt(1 + x**2)\n588 \n589         if arg.func is atan2:\n590             y, x = arg.args\n591             return x / sqrt(x**2 + y**2)\n592 \n593         if arg.func is asin:\n594             x = arg.args[0]\n595             return sqrt(1 - x ** 2)\n596 \n597         if arg.func is acot:\n598             x = arg.args[0]\n599             return 1 / sqrt(1 + 1 / x**2)\n600 \n601     @staticmethod\n602     @cacheit\n603     def taylor_term(n, x, *previous_terms):\n604         if n < 0 or n % 2 == 1:\n605             return S.Zero\n606         else:\n607             x = sympify(x)\n608 \n609             if len(previous_terms) > 2:\n610                 p = previous_terms[-2]\n611                 return -p * x**2 / (n*(n - 1))\n612             else:\n613                 return (-1)**(n//2)*x**(n)/factorial(n)\n614 \n615     def _eval_rewrite_as_exp(self, arg):\n616         I = S.ImaginaryUnit\n617         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n618             arg = arg.func(arg.args[0]).rewrite(exp)\n619         return (exp(arg*I) + exp(-arg*I)) / 2\n620 \n621     def _eval_rewrite_as_Pow(self, arg):\n622         if arg.func is log:\n623             I = S.ImaginaryUnit\n624             x = arg.args[0]\n625             return x**I/2 + x**-I/2\n626 \n627     def _eval_rewrite_as_sin(self, arg):\n628         return sin(arg + S.Pi/2)\n629 \n630     def _eval_rewrite_as_tan(self, arg):\n631         tan_half = tan(S.Half*arg)**2\n632         return (1 - tan_half)/(1 + tan_half)\n633 \n634     def _eval_rewrite_as_sincos(self, arg):\n635         return sin(arg)*cos(arg)/sin(arg)\n636 \n637     def _eval_rewrite_as_cot(self, arg):\n638         cot_half = cot(S.Half*arg)**2\n639         return (cot_half - 1)/(cot_half + 1)\n640 \n641     def _eval_rewrite_as_pow(self, arg):\n642         return self._eval_rewrite_as_sqrt(arg)\n643 \n644     def _eval_rewrite_as_sqrt(self, arg):\n645         from sympy.functions.special.polynomials import chebyshevt\n646 \n647         def migcdex(x):\n648             # recursive calcuation of gcd and linear combination\n649             # for a sequence of integers.\n650             # Given  (x1, x2, x3)\n651             # Returns (y1, y1, y3, g)\n652             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0\n653             # Note, that this is only one such linear combination.\n654             if len(x) == 1:\n655                 return (1, x[0])\n656             if len(x) == 2:\n657                 return igcdex(x[0], x[-1])\n658             g = migcdex(x[1:])\n659             u, v, h = igcdex(x[0], g[-1])\n660             return tuple([u] + [v*i for i in g[0:-1] ] + [h])\n661 \n662         def ipartfrac(r, factors=None):\n663             from sympy.ntheory import factorint\n664             if isinstance(r, int):\n665                 return r\n666             if not isinstance(r, Rational):\n667                 raise TypeError(\"r is not rational\")\n668             n = r.q\n669             if 2 > r.q*r.q:\n670                 return r.q\n671 \n672             if None == factors:\n673                 a = [n//x**y for x, y in factorint(r.q).items()]\n674             else:\n675                 a = [n//x for x in factors]\n676             if len(a) == 1:\n677                 return [ r ]\n678             h = migcdex(a)\n679             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]\n680             assert r == sum(ans)\n681             return ans\n682         pi_coeff = _pi_coeff(arg)\n683         if pi_coeff is None:\n684             return None\n685 \n686         if pi_coeff.is_integer:\n687             # it was unevaluated\n688             return self.func(pi_coeff*S.Pi)\n689 \n690         if not pi_coeff.is_Rational:\n691             return None\n692 \n693         def _cospi257():\n694             \"\"\" Express cos(pi/257) explicitly as a function of radicals\n695                 Based upon the equations in\n696                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals\n697                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt\n698             \"\"\"\n699             def f1(a, b):\n700                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2\n701 \n702             def f2(a, b):\n703                 return (a - sqrt(a**2 + b))/2\n704 \n705             t1, t2 = f1(-1, 256)\n706             z1, z3 = f1(t1, 64)\n707             z2, z4 = f1(t2, 64)\n708             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))\n709             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))\n710             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))\n711             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))\n712             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))\n713             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))\n714             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))\n715             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))\n716             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))\n717             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))\n718             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))\n719             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))\n720             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))\n721             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))\n722             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))\n723             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))\n724             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))\n725             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))\n726             u1 = -f2(-v1, -4*(v2 + v3))\n727             u2 = -f2(-v4, -4*(v5 + v6))\n728             w1 = -2*f2(-u1, -4*u2)\n729             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)\n730 \n731         cst_table_some = {\n732             3: S.Half,\n733             5: (sqrt(5) + 1)/4,\n734             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +\n735                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))\n736                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),\n737             257: _cospi257()\n738             # 65537 is the only other known Fermat prime and the very\n739             # large expression is intentionally omitted from SymPy; see\n740             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt\n741         }\n742 \n743         def _fermatCoords(n):\n744             # if n can be factored in terms of Fermat primes with\n745             # multiplicity of each being 1, return those primes, else\n746             # False\n747             from sympy import chebyshevt\n748             primes = []\n749             for p_i in cst_table_some:\n750                 n, r = divmod(n, p_i)\n751                 if not r:\n752                     primes.append(p_i)\n753                     if n == 1:\n754                         return tuple(primes)\n755             return False\n756 \n757         if pi_coeff.q in cst_table_some:\n758             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])\n759             if pi_coeff.q < 257:\n760                 rv = rv.expand()\n761             return rv\n762 \n763         if not pi_coeff.q % 2:  # recursively remove factors of 2\n764             pico2 = pi_coeff*2\n765             nval = cos(pico2*S.Pi).rewrite(sqrt)\n766             x = (pico2 + 1)/2\n767             sign_cos = -1 if int(x) % 2 else 1\n768             return sign_cos*sqrt( (1 + nval)/2 )\n769 \n770         FC = _fermatCoords(pi_coeff.q)\n771         if FC:\n772             decomp = ipartfrac(pi_coeff, FC)\n773             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]\n774             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)\n775             return pcls.rewrite(sqrt)\n776         else:\n777             decomp = ipartfrac(pi_coeff)\n778             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]\n779             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)\n780             return pcls\n781 \n782     def _eval_rewrite_as_sec(self, arg):\n783         return 1/sec(arg)\n784 \n785     def _eval_conjugate(self):\n786         return self.func(self.args[0].conjugate())\n787 \n788     def as_real_imag(self, deep=True, **hints):\n789         re, im = self._as_real_imag(deep=deep, **hints)\n790         return (cos(re)*cosh(im), -sin(re)*sinh(im))\n791 \n792     def _eval_expand_trig(self, **hints):\n793         from sympy.functions.special.polynomials import chebyshevt\n794         arg = self.args[0]\n795         x = None\n796         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms\n797             x, y = arg.as_two_terms()\n798             sx = sin(x, evaluate=False)._eval_expand_trig()\n799             sy = sin(y, evaluate=False)._eval_expand_trig()\n800             cx = cos(x, evaluate=False)._eval_expand_trig()\n801             cy = cos(y, evaluate=False)._eval_expand_trig()\n802             return cx*cy - sx*sy\n803         else:\n804             coeff, terms = arg.as_coeff_Mul(rational=True)\n805             if coeff.is_Integer:\n806                 return chebyshevt(coeff, cos(terms))\n807             pi_coeff = _pi_coeff(arg)\n808             if pi_coeff is not None:\n809                 if pi_coeff.is_Rational:\n810                     return self.rewrite(sqrt)\n811         return cos(arg)\n812 \n813     def _eval_as_leading_term(self, x):\n814         from sympy import Order\n815         arg = self.args[0].as_leading_term(x)\n816 \n817         if x in arg.free_symbols and Order(1, x).contains(arg):\n818             return S.One\n819         else:\n820             return self.func(arg)\n821 \n822     def _eval_is_real(self):\n823         return self.args[0].is_real\n824 \n825     def _eval_is_finite(self):\n826         arg = self.args[0]\n827 \n828         if arg.is_real:\n829             return True\n830 \n831 \n832 class tan(TrigonometricFunction):\n833     \"\"\"\n834     The tangent function.\n835 \n836     Returns the tangent of x (measured in radians).\n837 \n838     Notes\n839     =====\n840 \n841     See :func:`sin` for notes about automatic evaluation.\n842 \n843     Examples\n844     ========\n845 \n846     >>> from sympy import tan, pi\n847     >>> from sympy.abc import x\n848     >>> tan(x**2).diff(x)\n849     2*x*(tan(x**2)**2 + 1)\n850     >>> tan(1).diff(x)\n851     0\n852     >>> tan(pi/8).expand()\n853     -1 + sqrt(2)\n854 \n855     See Also\n856     ========\n857 \n858     sin, csc, cos, sec, cot\n859     asin, acsc, acos, asec, atan, acot, atan2\n860 \n861     References\n862     ==========\n863 \n864     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n865     .. [2] http://dlmf.nist.gov/4.14\n866     .. [3] http://functions.wolfram.com/ElementaryFunctions/Tan\n867     \"\"\"\n868 \n869     def fdiff(self, argindex=1):\n870         if argindex == 1:\n871             return S.One + self**2\n872         else:\n873             raise ArgumentIndexError(self, argindex)\n874 \n875     def inverse(self, argindex=1):\n876         \"\"\"\n877         Returns the inverse of this function.\n878         \"\"\"\n879         return atan\n880 \n881     @classmethod\n882     def eval(cls, arg):\n883         from sympy.calculus.util import AccumBounds\n884         if arg.is_Number:\n885             if arg is S.NaN:\n886                 return S.NaN\n887             elif arg is S.Zero:\n888                 return S.Zero\n889             elif arg is S.Infinity or arg is S.NegativeInfinity:\n890                 return AccumBounds(S.NegativeInfinity, S.Infinity)\n891 \n892         if isinstance(arg, AccumBounds):\n893             min, max = arg.min, arg.max\n894             d = floor(min/S.Pi)\n895             if min is not S.NegativeInfinity:\n896                 min = min - d*S.Pi\n897             if max is not S.Infinity:\n898                 max = max - d*S.Pi\n899             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 3*S.Pi/2)):\n900                 return AccumBounds(S.NegativeInfinity, S.Infinity)\n901             else:\n902                 return AccumBounds(tan(min), tan(max))\n903 \n904         if arg.could_extract_minus_sign():\n905             return -cls(-arg)\n906 \n907         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n908         if i_coeff is not None:\n909             return S.ImaginaryUnit * tanh(i_coeff)\n910 \n911         pi_coeff = _pi_coeff(arg, 2)\n912         if pi_coeff is not None:\n913             if pi_coeff.is_integer:\n914                 return S.Zero\n915 \n916             if not pi_coeff.is_Rational:\n917                 narg = pi_coeff*S.Pi\n918                 if narg != arg:\n919                     return cls(narg)\n920                 return None\n921 \n922             if pi_coeff.is_Rational:\n923                 if not pi_coeff.q % 2:\n924                     narg = pi_coeff*S.Pi*2\n925                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n926                     if not isinstance(cresult, cos) \\\n927                             and not isinstance(sresult, cos):\n928                         if sresult == 0:\n929                             return S.ComplexInfinity\n930                         return (1 - cresult)/sresult\n931                 table2 = {\n932                     12: (3, 4),\n933                     20: (4, 5),\n934                     30: (5, 6),\n935                     15: (6, 10),\n936                     24: (6, 8),\n937                     40: (8, 10),\n938                     60: (20, 30),\n939                     120: (40, 60)\n940                     }\n941                 q = pi_coeff.q\n942                 p = pi_coeff.p % q\n943                 if q in table2:\n944                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])\n945                     if None == nvala or None == nvalb:\n946                         return None\n947                     return (nvala - nvalb)/(1 + nvala*nvalb)\n948                 narg = ((pi_coeff + S.Half) % 1 - S.Half)*S.Pi\n949                 # see cos() to specify which expressions should  be\n950                 # expanded automatically in terms of radicals\n951                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n952                 if not isinstance(cresult, cos) \\\n953                         and not isinstance(sresult, cos):\n954                     if cresult == 0:\n955                         return S.ComplexInfinity\n956                     return (sresult/cresult)\n957                 if narg != arg:\n958                     return cls(narg)\n959 \n960         if arg.is_Add:\n961             x, m = _peeloff_pi(arg)\n962             if m:\n963                 tanm = tan(m)\n964                 tanx = tan(x)\n965                 if tanm is S.ComplexInfinity:\n966                     return -cot(x)\n967                 return (tanm + tanx)/(1 - tanm*tanx)\n968 \n969         if arg.func is atan:\n970             return arg.args[0]\n971 \n972         if arg.func is atan2:\n973             y, x = arg.args\n974             return y/x\n975 \n976         if arg.func is asin:\n977             x = arg.args[0]\n978             return x / sqrt(1 - x**2)\n979 \n980         if arg.func is acos:\n981             x = arg.args[0]\n982             return sqrt(1 - x**2) / x\n983 \n984         if arg.func is acot:\n985             x = arg.args[0]\n986             return 1 / x\n987 \n988     @staticmethod\n989     @cacheit\n990     def taylor_term(n, x, *previous_terms):\n991         from sympy import bernoulli\n992         if n < 0 or n % 2 == 0:\n993             return S.Zero\n994         else:\n995             x = sympify(x)\n996 \n997             a, b = ((n - 1)//2), 2**(n + 1)\n998 \n999             B = bernoulli(n + 1)\n1000             F = factorial(n + 1)\n1001 \n1002             return (-1)**a * b*(b - 1) * B/F * x**n\n1003 \n1004     def _eval_nseries(self, x, n, logx):\n1005         i = self.args[0].limit(x, 0)*2/S.Pi\n1006         if i and i.is_Integer:\n1007             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)\n1008         return Function._eval_nseries(self, x, n=n, logx=logx)\n1009 \n1010     def _eval_rewrite_as_Pow(self, arg):\n1011         if arg.func is log:\n1012             I = S.ImaginaryUnit\n1013             x = arg.args[0]\n1014             return I*(x**-I - x**I)/(x**-I + x**I)\n1015 \n1016     def _eval_conjugate(self):\n1017         return self.func(self.args[0].conjugate())\n1018 \n1019     def as_real_imag(self, deep=True, **hints):\n1020         re, im = self._as_real_imag(deep=deep, **hints)\n1021         if im:\n1022             denom = cos(2*re) + cosh(2*im)\n1023             return (sin(2*re)/denom, sinh(2*im)/denom)\n1024         else:\n1025             return (self.func(re), S.Zero)\n1026 \n1027     def _eval_expand_trig(self, **hints):\n1028         from sympy import im, re\n1029         arg = self.args[0]\n1030         x = None\n1031         if arg.is_Add:\n1032             from sympy import symmetric_poly\n1033             n = len(arg.args)\n1034             TX = []\n1035             for x in arg.args:\n1036                 tx = tan(x, evaluate=False)._eval_expand_trig()\n1037                 TX.append(tx)\n1038 \n1039             Yg = numbered_symbols('Y')\n1040             Y = [ next(Yg) for i in range(n) ]\n1041 \n1042             p = [0, 0]\n1043             for i in range(n + 1):\n1044                 p[1 - i % 2] += symmetric_poly(i, Y)*(-1)**((i % 4)//2)\n1045             return (p[0]/p[1]).subs(list(zip(Y, TX)))\n1046 \n1047         else:\n1048             coeff, terms = arg.as_coeff_Mul(rational=True)\n1049             if coeff.is_Integer and coeff > 1:\n1050                 I = S.ImaginaryUnit\n1051                 z = Symbol('dummy', real=True)\n1052                 P = ((1 + I*z)**coeff).expand()\n1053                 return (im(P)/re(P)).subs([(z, tan(terms))])\n1054         return tan(arg)\n1055 \n1056     def _eval_rewrite_as_exp(self, arg):\n1057         I = S.ImaginaryUnit\n1058         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n1059             arg = arg.func(arg.args[0]).rewrite(exp)\n1060         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)\n1061         return I*(neg_exp - pos_exp)/(neg_exp + pos_exp)\n1062 \n1063     def _eval_rewrite_as_sin(self, x):\n1064         return 2*sin(x)**2/sin(2*x)\n1065 \n1066     def _eval_rewrite_as_cos(self, x):\n1067         return -cos(x + S.Pi/2)/cos(x)\n1068 \n1069     def _eval_rewrite_as_sincos(self, arg):\n1070         return sin(arg)/cos(arg)\n1071 \n1072     def _eval_rewrite_as_cot(self, arg):\n1073         return 1/cot(arg)\n1074 \n1075     def _eval_rewrite_as_pow(self, arg):\n1076         y = self.rewrite(cos).rewrite(pow)\n1077         if y.has(cos):\n1078             return None\n1079         return y\n1080 \n1081     def _eval_rewrite_as_sqrt(self, arg):\n1082         y = self.rewrite(cos).rewrite(sqrt)\n1083         if y.has(cos):\n1084             return None\n1085         return y\n1086 \n1087     def _eval_as_leading_term(self, x):\n1088         from sympy import Order\n1089         arg = self.args[0].as_leading_term(x)\n1090 \n1091         if x in arg.free_symbols and Order(1, x).contains(arg):\n1092             return arg\n1093         else:\n1094             return self.func(arg)\n1095 \n1096     def _eval_is_real(self):\n1097         return self.args[0].is_real\n1098 \n1099     def _eval_is_finite(self):\n1100         arg = self.args[0]\n1101 \n1102         if arg.is_imaginary:\n1103             return True\n1104 \n1105 \n1106 class cot(TrigonometricFunction):\n1107     \"\"\"\n1108     The cotangent function.\n1109 \n1110     Returns the cotangent of x (measured in radians).\n1111 \n1112     Notes\n1113     =====\n1114 \n1115     See :func:`sin` for notes about automatic evaluation.\n1116 \n1117     Examples\n1118     ========\n1119 \n1120     >>> from sympy import cot, pi\n1121     >>> from sympy.abc import x\n1122     >>> cot(x**2).diff(x)\n1123     2*x*(-cot(x**2)**2 - 1)\n1124     >>> cot(1).diff(x)\n1125     0\n1126     >>> cot(pi/12)\n1127     sqrt(3) + 2\n1128 \n1129     See Also\n1130     ========\n1131 \n1132     sin, csc, cos, sec, tan\n1133     asin, acsc, acos, asec, atan, acot, atan2\n1134 \n1135     References\n1136     ==========\n1137 \n1138     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n1139     .. [2] http://dlmf.nist.gov/4.14\n1140     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cot\n1141     \"\"\"\n1142 \n1143     def fdiff(self, argindex=1):\n1144         if argindex == 1:\n1145             return S.NegativeOne - self**2\n1146         else:\n1147             raise ArgumentIndexError(self, argindex)\n1148 \n1149     def inverse(self, argindex=1):\n1150         \"\"\"\n1151         Returns the inverse of this function.\n1152         \"\"\"\n1153         return acot\n1154 \n1155     @classmethod\n1156     def eval(cls, arg):\n1157         from sympy.calculus.util import AccumBounds\n1158         if arg.is_Number:\n1159             if arg is S.NaN:\n1160                 return S.NaN\n1161             if arg is S.Zero:\n1162                 return S.ComplexInfinity\n1163 \n1164         if isinstance(arg, AccumBounds):\n1165             return -tan(arg + S.Pi/2)\n1166 \n1167         if arg.could_extract_minus_sign():\n1168             return -cls(-arg)\n1169 \n1170         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1171         if i_coeff is not None:\n1172             return -S.ImaginaryUnit * coth(i_coeff)\n1173 \n1174         pi_coeff = _pi_coeff(arg, 2)\n1175         if pi_coeff is not None:\n1176             if pi_coeff.is_integer:\n1177                 return S.ComplexInfinity\n1178 \n1179             if not pi_coeff.is_Rational:\n1180                 narg = pi_coeff*S.Pi\n1181                 if narg != arg:\n1182                     return cls(narg)\n1183                 return None\n1184 \n1185             if pi_coeff.is_Rational:\n1186                 if pi_coeff.q > 2 and not pi_coeff.q % 2:\n1187                     narg = pi_coeff*S.Pi*2\n1188                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n1189                     if not isinstance(cresult, cos) \\\n1190                             and not isinstance(sresult, cos):\n1191                         return (1 + cresult)/sresult\n1192                 table2 = {\n1193                     12: (3, 4),\n1194                     20: (4, 5),\n1195                     30: (5, 6),\n1196                     15: (6, 10),\n1197                     24: (6, 8),\n1198                     40: (8, 10),\n1199                     60: (20, 30),\n1200                     120: (40, 60)\n1201                     }\n1202                 q = pi_coeff.q\n1203                 p = pi_coeff.p % q\n1204                 if q in table2:\n1205                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])\n1206                     if None == nvala or None == nvalb:\n1207                         return None\n1208                     return (1 + nvala*nvalb)/(nvalb - nvala)\n1209                 narg = (((pi_coeff + S.Half) % 1) - S.Half)*S.Pi\n1210                 # see cos() to specify which expressions should be\n1211                 # expanded automatically in terms of radicals\n1212                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n1213                 if not isinstance(cresult, cos) \\\n1214                         and not isinstance(sresult, cos):\n1215                     if sresult == 0:\n1216                         return S.ComplexInfinity\n1217                     return cresult / sresult\n1218                 if narg != arg:\n1219                     return cls(narg)\n1220 \n1221         if arg.is_Add:\n1222             x, m = _peeloff_pi(arg)\n1223             if m:\n1224                 cotm = cot(m)\n1225                 if cotm == 0:\n1226                     return -tan(x)\n1227                 cotx = cot(x)\n1228                 if cotm is S.ComplexInfinity:\n1229                     return cotx\n1230                 if cotm.is_Rational:\n1231                     return (cotm*cotx - 1) / (cotm + cotx)\n1232             return None\n1233 \n1234         if arg.func is acot:\n1235             return arg.args[0]\n1236 \n1237         if arg.func is atan:\n1238             x = arg.args[0]\n1239             return 1 / x\n1240 \n1241         if arg.func is atan2:\n1242             y, x = arg.args\n1243             return x/y\n1244 \n1245         if arg.func is asin:\n1246             x = arg.args[0]\n1247             return sqrt(1 - x**2) / x\n1248 \n1249         if arg.func is acos:\n1250             x = arg.args[0]\n1251             return x / sqrt(1 - x**2)\n1252 \n1253     @staticmethod\n1254     @cacheit\n1255     def taylor_term(n, x, *previous_terms):\n1256         from sympy import bernoulli\n1257         if n == 0:\n1258             return 1 / sympify(x)\n1259         elif n < 0 or n % 2 == 0:\n1260             return S.Zero\n1261         else:\n1262             x = sympify(x)\n1263 \n1264             B = bernoulli(n + 1)\n1265             F = factorial(n + 1)\n1266 \n1267             return (-1)**((n + 1)//2) * 2**(n + 1) * B/F * x**n\n1268 \n1269     def _eval_nseries(self, x, n, logx):\n1270         i = self.args[0].limit(x, 0)/S.Pi\n1271         if i and i.is_Integer:\n1272             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)\n1273         return self.rewrite(tan)._eval_nseries(x, n=n, logx=logx)\n1274 \n1275     def _eval_conjugate(self):\n1276         return self.func(self.args[0].conjugate())\n1277 \n1278     def as_real_imag(self, deep=True, **hints):\n1279         re, im = self._as_real_imag(deep=deep, **hints)\n1280         if im:\n1281             denom = cos(2*re) - cosh(2*im)\n1282             return (-sin(2*re)/denom, -sinh(2*im)/denom)\n1283         else:\n1284             return (self.func(re), S.Zero)\n1285 \n1286     def _eval_rewrite_as_exp(self, arg):\n1287         I = S.ImaginaryUnit\n1288         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n1289             arg = arg.func(arg.args[0]).rewrite(exp)\n1290         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)\n1291         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)\n1292 \n1293     def _eval_rewrite_as_Pow(self, arg):\n1294         if arg.func is log:\n1295             I = S.ImaginaryUnit\n1296             x = arg.args[0]\n1297             return -I*(x**-I + x**I)/(x**-I - x**I)\n1298 \n1299     def _eval_rewrite_as_sin(self, x):\n1300         return 2*sin(2*x)/sin(x)**2\n1301 \n1302     def _eval_rewrite_as_cos(self, x):\n1303         return -cos(x)/cos(x + S.Pi/2)\n1304 \n1305     def _eval_rewrite_as_sincos(self, arg):\n1306         return cos(arg)/sin(arg)\n1307 \n1308     def _eval_rewrite_as_tan(self, arg):\n1309         return 1/tan(arg)\n1310 \n1311     def _eval_rewrite_as_pow(self, arg):\n1312         y = self.rewrite(cos).rewrite(pow)\n1313         if y.has(cos):\n1314             return None\n1315         return y\n1316 \n1317     def _eval_rewrite_as_sqrt(self, arg):\n1318         y = self.rewrite(cos).rewrite(sqrt)\n1319         if y.has(cos):\n1320             return None\n1321         return y\n1322 \n1323     def _eval_as_leading_term(self, x):\n1324         from sympy import Order\n1325         arg = self.args[0].as_leading_term(x)\n1326 \n1327         if x in arg.free_symbols and Order(1, x).contains(arg):\n1328             return 1/arg\n1329         else:\n1330             return self.func(arg)\n1331 \n1332     def _eval_is_real(self):\n1333         return self.args[0].is_real\n1334 \n1335     def _eval_expand_trig(self, **hints):\n1336         from sympy import im, re\n1337         arg = self.args[0]\n1338         x = None\n1339         if arg.is_Add:\n1340             from sympy import symmetric_poly\n1341             n = len(arg.args)\n1342             CX = []\n1343             for x in arg.args:\n1344                 cx = cot(x, evaluate=False)._eval_expand_trig()\n1345                 CX.append(cx)\n1346 \n1347             Yg = numbered_symbols('Y')\n1348             Y = [ next(Yg) for i in range(n) ]\n1349 \n1350             p = [0, 0]\n1351             for i in range(n, -1, -1):\n1352                 p[(n - i) % 2] += symmetric_poly(i, Y)*(-1)**(((n - i) % 4)//2)\n1353             return (p[0]/p[1]).subs(list(zip(Y, CX)))\n1354         else:\n1355             coeff, terms = arg.as_coeff_Mul(rational=True)\n1356             if coeff.is_Integer and coeff > 1:\n1357                 I = S.ImaginaryUnit\n1358                 z = Symbol('dummy', real=True)\n1359                 P = ((z + I)**coeff).expand()\n1360                 return (re(P)/im(P)).subs([(z, cot(terms))])\n1361         return cot(arg)\n1362 \n1363     def _eval_is_finite(self):\n1364         arg = self.args[0]\n1365         if arg.is_imaginary:\n1366             return True\n1367 \n1368     def _eval_subs(self, old, new):\n1369         if self == old:\n1370             return new\n1371         arg = self.args[0]\n1372         argnew = arg.subs(old, new)\n1373         if arg != argnew and (argnew/S.Pi).is_integer:\n1374             return S.ComplexInfinity\n1375         return cot(argnew)\n1376 \n1377 \n1378 class ReciprocalTrigonometricFunction(TrigonometricFunction):\n1379     \"\"\"Base class for reciprocal functions of trigonometric functions. \"\"\"\n1380 \n1381     _reciprocal_of = None       # mandatory, to be defined in subclass\n1382 \n1383     # _is_even and _is_odd are used for correct evaluation of csc(-x), sec(-x)\n1384     # TODO refactor into TrigonometricFunction common parts of\n1385     # trigonometric functions eval() like even/odd, func(x+2*k*pi), etc.\n1386     _is_even = None  # optional, to be defined in subclass\n1387     _is_odd = None   # optional, to be defined in subclass\n1388 \n1389     @classmethod\n1390     def eval(cls, arg):\n1391         if arg.could_extract_minus_sign():\n1392             if cls._is_even:\n1393                 return cls(-arg)\n1394             if cls._is_odd:\n1395                 return -cls(-arg)\n1396 \n1397         pi_coeff = _pi_coeff(arg)\n1398         if (pi_coeff is not None\n1399             and not (2*pi_coeff).is_integer\n1400             and pi_coeff.is_Rational):\n1401                 q = pi_coeff.q\n1402                 p = pi_coeff.p % (2*q)\n1403                 if p > q:\n1404                     narg = (pi_coeff - 1)*S.Pi\n1405                     return -cls(narg)\n1406                 if 2*p > q:\n1407                     narg = (1 - pi_coeff)*S.Pi\n1408                     if cls._is_odd:\n1409                         return cls(narg)\n1410                     elif cls._is_even:\n1411                         return -cls(narg)\n1412 \n1413         t = cls._reciprocal_of.eval(arg)\n1414         if hasattr(arg, 'inverse') and arg.inverse() == cls:\n1415             return arg.args[0]\n1416         return 1/t if t != None else t\n1417 \n1418     def _call_reciprocal(self, method_name, *args, **kwargs):\n1419         # Calls method_name on _reciprocal_of\n1420         o = self._reciprocal_of(self.args[0])\n1421         return getattr(o, method_name)(*args, **kwargs)\n1422 \n1423     def _calculate_reciprocal(self, method_name, *args, **kwargs):\n1424         # If calling method_name on _reciprocal_of returns a value != None\n1425         # then return the reciprocal of that value\n1426         t = self._call_reciprocal(method_name, *args, **kwargs)\n1427         return 1/t if t != None else t\n1428 \n1429     def _rewrite_reciprocal(self, method_name, arg):\n1430         # Special handling for rewrite functions. If reciprocal rewrite returns\n1431         # unmodified expression, then return None\n1432         t = self._call_reciprocal(method_name, arg)\n1433         if t != None and t != self._reciprocal_of(arg):\n1434             return 1/t\n1435 \n1436     def fdiff(self, argindex=1):\n1437         return -self._calculate_reciprocal(\"fdiff\", argindex)/self**2\n1438 \n1439     def _eval_rewrite_as_exp(self, arg):\n1440         return self._rewrite_reciprocal(\"_eval_rewrite_as_exp\", arg)\n1441 \n1442     def _eval_rewrite_as_Pow(self, arg):\n1443         return self._rewrite_reciprocal(\"_eval_rewrite_as_Pow\", arg)\n1444 \n1445     def _eval_rewrite_as_sin(self, arg):\n1446         return self._rewrite_reciprocal(\"_eval_rewrite_as_sin\", arg)\n1447 \n1448     def _eval_rewrite_as_cos(self, arg):\n1449         return self._rewrite_reciprocal(\"_eval_rewrite_as_cos\", arg)\n1450 \n1451     def _eval_rewrite_as_tan(self, arg):\n1452         return self._rewrite_reciprocal(\"_eval_rewrite_as_tan\", arg)\n1453 \n1454     def _eval_rewrite_as_pow(self, arg):\n1455         return self._rewrite_reciprocal(\"_eval_rewrite_as_pow\", arg)\n1456 \n1457     def _eval_rewrite_as_sqrt(self, arg):\n1458         return self._rewrite_reciprocal(\"_eval_rewrite_as_sqrt\", arg)\n1459 \n1460     def _eval_conjugate(self):\n1461         return self.func(self.args[0].conjugate())\n1462 \n1463     def as_real_imag(self, deep=True, **hints):\n1464         return (1/self._reciprocal_of(self.args[0])).as_real_imag(deep,\n1465                                                                   **hints)\n1466 \n1467     def _eval_expand_trig(self, **hints):\n1468         return self._calculate_reciprocal(\"_eval_expand_trig\", **hints)\n1469 \n1470     def _eval_is_real(self):\n1471         return self._reciprocal_of(self.args[0])._eval_is_real()\n1472 \n1473     def _eval_as_leading_term(self, x):\n1474         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)\n1475 \n1476     def _eval_is_finite(self):\n1477         return (1/self._reciprocal_of(self.args[0])).is_finite\n1478 \n1479     def _eval_nseries(self, x, n, logx):\n1480         return (1/self._reciprocal_of(self.args[0]))._eval_nseries(x, n, logx)\n1481 \n1482 \n1483 class sec(ReciprocalTrigonometricFunction):\n1484     \"\"\"\n1485     The secant function.\n1486 \n1487     Returns the secant of x (measured in radians).\n1488 \n1489     Notes\n1490     =====\n1491 \n1492     See :func:`sin` for notes about automatic evaluation.\n1493 \n1494     Examples\n1495     ========\n1496 \n1497     >>> from sympy import sec\n1498     >>> from sympy.abc import x\n1499     >>> sec(x**2).diff(x)\n1500     2*x*tan(x**2)*sec(x**2)\n1501     >>> sec(1).diff(x)\n1502     0\n1503 \n1504     See Also\n1505     ========\n1506 \n1507     sin, csc, cos, tan, cot\n1508     asin, acsc, acos, asec, atan, acot, atan2\n1509 \n1510     References\n1511     ==========\n1512 \n1513     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n1514     .. [2] http://dlmf.nist.gov/4.14\n1515     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sec\n1516     \"\"\"\n1517 \n1518     _reciprocal_of = cos\n1519     _is_even = True\n1520 \n1521     def _eval_rewrite_as_cot(self, arg):\n1522         cot_half_sq = cot(arg/2)**2\n1523         return (cot_half_sq + 1)/(cot_half_sq - 1)\n1524 \n1525     def _eval_rewrite_as_cos(self, arg):\n1526         return (1/cos(arg))\n1527 \n1528     def _eval_rewrite_as_sincos(self, arg):\n1529         return sin(arg)/(cos(arg)*sin(arg))\n1530 \n1531     def fdiff(self, argindex=1):\n1532         if argindex == 1:\n1533             return tan(self.args[0])*sec(self.args[0])\n1534         else:\n1535             raise ArgumentIndexError(self, argindex)\n1536 \n1537     @staticmethod\n1538     @cacheit\n1539     def taylor_term(n, x, *previous_terms):\n1540         # Reference Formula:\n1541         # http://functions.wolfram.com/ElementaryFunctions/Sec/06/01/02/01/\n1542         from sympy.functions.combinatorial.numbers import euler\n1543         if n < 0 or n % 2 == 1:\n1544             return S.Zero\n1545         else:\n1546             x = sympify(x)\n1547             k = n//2\n1548             return (-1)**k*euler(2*k)/factorial(2*k)*x**(2*k)\n1549 \n1550 \n1551 class csc(ReciprocalTrigonometricFunction):\n1552     \"\"\"\n1553     The cosecant function.\n1554 \n1555     Returns the cosecant of x (measured in radians).\n1556 \n1557     Notes\n1558     =====\n1559 \n1560     See :func:`sin` for notes about automatic evaluation.\n1561 \n1562     Examples\n1563     ========\n1564 \n1565     >>> from sympy import csc\n1566     >>> from sympy.abc import x\n1567     >>> csc(x**2).diff(x)\n1568     -2*x*cot(x**2)*csc(x**2)\n1569     >>> csc(1).diff(x)\n1570     0\n1571 \n1572     See Also\n1573     ========\n1574 \n1575     sin, cos, sec, tan, cot\n1576     asin, acsc, acos, asec, atan, acot, atan2\n1577 \n1578     References\n1579     ==========\n1580 \n1581     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n1582     .. [2] http://dlmf.nist.gov/4.14\n1583     .. [3] http://functions.wolfram.com/ElementaryFunctions/Csc\n1584     \"\"\"\n1585 \n1586     _reciprocal_of = sin\n1587     _is_odd = True\n1588 \n1589     def _eval_rewrite_as_sin(self, arg):\n1590         return (1/sin(arg))\n1591 \n1592     def _eval_rewrite_as_sincos(self, arg):\n1593         return cos(arg)/(sin(arg)*cos(arg))\n1594 \n1595     def _eval_rewrite_as_cot(self, arg):\n1596         cot_half = cot(arg/2)\n1597         return (1 + cot_half**2)/(2*cot_half)\n1598 \n1599     def fdiff(self, argindex=1):\n1600         if argindex == 1:\n1601             return -cot(self.args[0])*csc(self.args[0])\n1602         else:\n1603             raise ArgumentIndexError(self, argindex)\n1604 \n1605     @staticmethod\n1606     @cacheit\n1607     def taylor_term(n, x, *previous_terms):\n1608         from sympy import bernoulli\n1609         if n == 0:\n1610             return 1/sympify(x)\n1611         elif n < 0 or n % 2 == 0:\n1612             return S.Zero\n1613         else:\n1614             x = sympify(x)\n1615             k = n//2 + 1\n1616             return ((-1)**(k - 1)*2*(2**(2*k - 1) - 1)*\n1617                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))\n1618 \n1619 \n1620 class sinc(TrigonometricFunction):\n1621     r\"\"\"Represents unnormalized sinc function\n1622 \n1623     Examples\n1624     ========\n1625 \n1626     >>> from sympy import sinc, oo, jn, Product, Symbol\n1627     >>> from sympy.abc import x\n1628     >>> sinc(x)\n1629     sinc(x)\n1630 \n1631     * Automated Evaluation\n1632 \n1633     >>> sinc(0)\n1634     1\n1635     >>> sinc(oo)\n1636     0\n1637 \n1638     * Differentiation\n1639 \n1640     >>> sinc(x).diff()\n1641     (x*cos(x) - sin(x))/x**2\n1642 \n1643     * Series Expansion\n1644 \n1645     >>> sinc(x).series()\n1646     1 - x**2/6 + x**4/120 + O(x**6)\n1647 \n1648     * As zero'th order spherical Bessel Function\n1649 \n1650     >>> sinc(x).rewrite(jn)\n1651     jn(0, x)\n1652 \n1653     References\n1654     ==========\n1655 \n1656     .. [1] http://en.wikipedia.org/wiki/Sinc_function\n1657 \n1658     \"\"\"\n1659 \n1660     def fdiff(self, argindex=1):\n1661         x = self.args[0]\n1662         if argindex == 1:\n1663             return (x*cos(x) - sin(x)) / x**2\n1664         else:\n1665             raise ArgumentIndexError(self, argindex)\n1666 \n1667     @classmethod\n1668     def eval(cls, arg):\n1669         if arg.is_zero:\n1670             return S.One\n1671         if arg.is_Number:\n1672             if arg in [S.Infinity, -S.Infinity]:\n1673                 return S.Zero\n1674             elif arg is S.NaN:\n1675                 return S.NaN\n1676 \n1677         if arg is S.ComplexInfinity:\n1678             return S.NaN\n1679 \n1680         if arg.could_extract_minus_sign():\n1681             return cls(-arg)\n1682 \n1683         pi_coeff = _pi_coeff(arg)\n1684         if pi_coeff is not None:\n1685             if pi_coeff.is_integer:\n1686                 if fuzzy_not(arg.is_zero):\n1687                     return S.Zero\n1688             elif (2*pi_coeff).is_integer:\n1689                 return S.NegativeOne**(pi_coeff - S.Half) / arg\n1690 \n1691     def _eval_nseries(self, x, n, logx):\n1692         x = self.args[0]\n1693         return (sin(x)/x)._eval_nseries(x, n, logx)\n1694 \n1695     def _eval_rewrite_as_jn(self, arg):\n1696         from sympy.functions.special.bessel import jn\n1697         return jn(0, arg)\n1698 \n1699     def _eval_rewrite_as_sin(self, arg):\n1700         return sin(arg) / arg\n1701 \n1702 \n1703 ###############################################################################\n1704 ########################### TRIGONOMETRIC INVERSES ############################\n1705 ###############################################################################\n1706 \n1707 \n1708 class InverseTrigonometricFunction(Function):\n1709     \"\"\"Base class for inverse trigonometric functions.\"\"\"\n1710 \n1711     pass\n1712 \n1713 \n1714 class asin(InverseTrigonometricFunction):\n1715     \"\"\"\n1716     The inverse sine function.\n1717 \n1718     Returns the arcsine of x in radians.\n1719 \n1720     Notes\n1721     =====\n1722 \n1723     asin(x) will evaluate automatically in the cases oo, -oo, 0, 1,\n1724     -1 and for some instances when the result is a rational multiple\n1725     of pi (see the eval class method).\n1726 \n1727     Examples\n1728     ========\n1729 \n1730     >>> from sympy import asin, oo, pi\n1731     >>> asin(1)\n1732     pi/2\n1733     >>> asin(-1)\n1734     -pi/2\n1735 \n1736     See Also\n1737     ========\n1738 \n1739     sin, csc, cos, sec, tan, cot\n1740     acsc, acos, asec, atan, acot, atan2\n1741 \n1742     References\n1743     ==========\n1744 \n1745     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n1746     .. [2] http://dlmf.nist.gov/4.23\n1747     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSin\n1748     \"\"\"\n1749 \n1750     def fdiff(self, argindex=1):\n1751         if argindex == 1:\n1752             return 1/sqrt(1 - self.args[0]**2)\n1753         else:\n1754             raise ArgumentIndexError(self, argindex)\n1755 \n1756     def _eval_is_rational(self):\n1757         s = self.func(*self.args)\n1758         if s.func == self.func:\n1759             if s.args[0].is_rational:\n1760                 return False\n1761         else:\n1762             return s.is_rational\n1763 \n1764     def _eval_is_positive(self):\n1765         if self.args[0].is_positive:\n1766             return (self.args[0] - 1).is_negative\n1767         if self.args[0].is_negative:\n1768             return not (self.args[0] + 1).is_positive\n1769 \n1770     @classmethod\n1771     def eval(cls, arg):\n1772         if arg.is_Number:\n1773             if arg is S.NaN:\n1774                 return S.NaN\n1775             elif arg is S.Infinity:\n1776                 return S.NegativeInfinity * S.ImaginaryUnit\n1777             elif arg is S.NegativeInfinity:\n1778                 return S.Infinity * S.ImaginaryUnit\n1779             elif arg is S.Zero:\n1780                 return S.Zero\n1781             elif arg is S.One:\n1782                 return S.Pi / 2\n1783             elif arg is S.NegativeOne:\n1784                 return -S.Pi / 2\n1785 \n1786         if arg.could_extract_minus_sign():\n1787             return -cls(-arg)\n1788 \n1789         if arg.is_number:\n1790             cst_table = {\n1791                 sqrt(3)/2: 3,\n1792                 -sqrt(3)/2: -3,\n1793                 sqrt(2)/2: 4,\n1794                 -sqrt(2)/2: -4,\n1795                 1/sqrt(2): 4,\n1796                 -1/sqrt(2): -4,\n1797                 sqrt((5 - sqrt(5))/8): 5,\n1798                 -sqrt((5 - sqrt(5))/8): -5,\n1799                 S.Half: 6,\n1800                 -S.Half: -6,\n1801                 sqrt(2 - sqrt(2))/2: 8,\n1802                 -sqrt(2 - sqrt(2))/2: -8,\n1803                 (sqrt(5) - 1)/4: 10,\n1804                 (1 - sqrt(5))/4: -10,\n1805                 (sqrt(3) - 1)/sqrt(2**3): 12,\n1806                 (1 - sqrt(3))/sqrt(2**3): -12,\n1807                 (sqrt(5) + 1)/4: S(10)/3,\n1808                 -(sqrt(5) + 1)/4: -S(10)/3\n1809             }\n1810 \n1811             if arg in cst_table:\n1812                 return S.Pi / cst_table[arg]\n1813 \n1814         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1815         if i_coeff is not None:\n1816             return S.ImaginaryUnit * asinh(i_coeff)\n1817 \n1818     @staticmethod\n1819     @cacheit\n1820     def taylor_term(n, x, *previous_terms):\n1821         if n < 0 or n % 2 == 0:\n1822             return S.Zero\n1823         else:\n1824             x = sympify(x)\n1825             if len(previous_terms) >= 2 and n > 2:\n1826                 p = previous_terms[-2]\n1827                 return p * (n - 2)**2/(n*(n - 1)) * x**2\n1828             else:\n1829                 k = (n - 1) // 2\n1830                 R = RisingFactorial(S.Half, k)\n1831                 F = factorial(k)\n1832                 return R / F * x**n / n\n1833 \n1834     def _eval_as_leading_term(self, x):\n1835         from sympy import Order\n1836         arg = self.args[0].as_leading_term(x)\n1837 \n1838         if x in arg.free_symbols and Order(1, x).contains(arg):\n1839             return arg\n1840         else:\n1841             return self.func(arg)\n1842 \n1843     def _eval_rewrite_as_acos(self, x):\n1844         return S.Pi/2 - acos(x)\n1845 \n1846     def _eval_rewrite_as_atan(self, x):\n1847         return 2*atan(x/(1 + sqrt(1 - x**2)))\n1848 \n1849     def _eval_rewrite_as_log(self, x):\n1850         return -S.ImaginaryUnit*log(S.ImaginaryUnit*x + sqrt(1 - x**2))\n1851 \n1852     def _eval_rewrite_as_acot(self, arg):\n1853         return 2*acot((1 + sqrt(1 - arg**2))/arg)\n1854 \n1855     def _eval_rewrite_as_asec(self, arg):\n1856         return S.Pi/2 - asec(1/arg)\n1857 \n1858     def _eval_rewrite_as_acsc(self, arg):\n1859         return acsc(1/arg)\n1860 \n1861     def _eval_is_real(self):\n1862         x = self.args[0]\n1863         return x.is_real and (1 - abs(x)).is_nonnegative\n1864 \n1865     def inverse(self, argindex=1):\n1866         \"\"\"\n1867         Returns the inverse of this function.\n1868         \"\"\"\n1869         return sin\n1870 \n1871 \n1872 class acos(InverseTrigonometricFunction):\n1873     \"\"\"\n1874     The inverse cosine function.\n1875 \n1876     Returns the arc cosine of x (measured in radians).\n1877 \n1878     Notes\n1879     =====\n1880 \n1881     ``acos(x)`` will evaluate automatically in the cases\n1882     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.\n1883 \n1884     ``acos(zoo)`` evaluates to ``zoo``\n1885     (see note in :py:class`sympy.functions.elementary.trigonometric.asec`)\n1886 \n1887     Examples\n1888     ========\n1889 \n1890     >>> from sympy import acos, oo, pi\n1891     >>> acos(1)\n1892     0\n1893     >>> acos(0)\n1894     pi/2\n1895     >>> acos(oo)\n1896     oo*I\n1897 \n1898     See Also\n1899     ========\n1900 \n1901     sin, csc, cos, sec, tan, cot\n1902     asin, acsc, asec, atan, acot, atan2\n1903 \n1904     References\n1905     ==========\n1906 \n1907     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n1908     .. [2] http://dlmf.nist.gov/4.23\n1909     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCos\n1910     \"\"\"\n1911 \n1912     def fdiff(self, argindex=1):\n1913         if argindex == 1:\n1914             return -1/sqrt(1 - self.args[0]**2)\n1915         else:\n1916             raise ArgumentIndexError(self, argindex)\n1917 \n1918     def _eval_is_rational(self):\n1919         s = self.func(*self.args)\n1920         if s.func == self.func:\n1921             if s.args[0].is_rational:\n1922                 return False\n1923         else:\n1924             return s.is_rational\n1925 \n1926     def _eval_is_positive(self):\n1927         x = self.args[0]\n1928         return (1 - abs(x)).is_nonnegative\n1929 \n1930     @classmethod\n1931     def eval(cls, arg):\n1932         if arg.is_Number:\n1933             if arg is S.NaN:\n1934                 return S.NaN\n1935             elif arg is S.Infinity:\n1936                 return S.Infinity * S.ImaginaryUnit\n1937             elif arg is S.NegativeInfinity:\n1938                 return S.NegativeInfinity * S.ImaginaryUnit\n1939             elif arg is S.Zero:\n1940                 return S.Pi / 2\n1941             elif arg is S.One:\n1942                 return S.Zero\n1943             elif arg is S.NegativeOne:\n1944                 return S.Pi\n1945 \n1946         if arg is S.ComplexInfinity:\n1947             return S.ComplexInfinity\n1948 \n1949         if arg.is_number:\n1950             cst_table = {\n1951                 S.Half: S.Pi/3,\n1952                 -S.Half: 2*S.Pi/3,\n1953                 sqrt(2)/2: S.Pi/4,\n1954                 -sqrt(2)/2: 3*S.Pi/4,\n1955                 1/sqrt(2): S.Pi/4,\n1956                 -1/sqrt(2): 3*S.Pi/4,\n1957                 sqrt(3)/2: S.Pi/6,\n1958                 -sqrt(3)/2: 5*S.Pi/6,\n1959             }\n1960 \n1961             if arg in cst_table:\n1962                 return cst_table[arg]\n1963 \n1964     @staticmethod\n1965     @cacheit\n1966     def taylor_term(n, x, *previous_terms):\n1967         if n == 0:\n1968             return S.Pi / 2\n1969         elif n < 0 or n % 2 == 0:\n1970             return S.Zero\n1971         else:\n1972             x = sympify(x)\n1973             if len(previous_terms) >= 2 and n > 2:\n1974                 p = previous_terms[-2]\n1975                 return p * (n - 2)**2/(n*(n - 1)) * x**2\n1976             else:\n1977                 k = (n - 1) // 2\n1978                 R = RisingFactorial(S.Half, k)\n1979                 F = factorial(k)\n1980                 return -R / F * x**n / n\n1981 \n1982     def _eval_as_leading_term(self, x):\n1983         from sympy import Order\n1984         arg = self.args[0].as_leading_term(x)\n1985 \n1986         if x in arg.free_symbols and Order(1, x).contains(arg):\n1987             return arg\n1988         else:\n1989             return self.func(arg)\n1990 \n1991     def _eval_is_real(self):\n1992         x = self.args[0]\n1993         return x.is_real and (1 - abs(x)).is_nonnegative\n1994 \n1995     def _eval_rewrite_as_log(self, x):\n1996         return S.Pi/2 + S.ImaginaryUnit * \\\n1997             log(S.ImaginaryUnit * x + sqrt(1 - x**2))\n1998 \n1999     def _eval_rewrite_as_asin(self, x):\n2000         return S.Pi/2 - asin(x)\n2001 \n2002     def _eval_rewrite_as_atan(self, x):\n2003         return atan(sqrt(1 - x**2)/x) + (S.Pi/2)*(1 - x*sqrt(1/x**2))\n2004 \n2005     def inverse(self, argindex=1):\n2006         \"\"\"\n2007         Returns the inverse of this function.\n2008         \"\"\"\n2009         return cos\n2010 \n2011     def _eval_rewrite_as_acot(self, arg):\n2012         return S.Pi/2 - 2*acot((1 + sqrt(1 - arg**2))/arg)\n2013 \n2014     def _eval_rewrite_as_asec(self, arg):\n2015         return asec(1/arg)\n2016 \n2017     def _eval_rewrite_as_acsc(self, arg):\n2018         return S.Pi/2 - acsc(1/arg)\n2019 \n2020     def _eval_conjugate(self):\n2021         z = self.args[0]\n2022         r = self.func(self.args[0].conjugate())\n2023         if z.is_real is False:\n2024             return r\n2025         elif z.is_real and (z + 1).is_nonnegative and (z - 1).is_nonpositive:\n2026             return r\n2027 \n2028 \n2029 class atan(InverseTrigonometricFunction):\n2030     \"\"\"\n2031     The inverse tangent function.\n2032 \n2033     Returns the arc tangent of x (measured in radians).\n2034 \n2035     Notes\n2036     =====\n2037 \n2038     atan(x) will evaluate automatically in the cases\n2039     oo, -oo, 0, 1, -1.\n2040 \n2041     Examples\n2042     ========\n2043 \n2044     >>> from sympy import atan, oo, pi\n2045     >>> atan(0)\n2046     0\n2047     >>> atan(1)\n2048     pi/4\n2049     >>> atan(oo)\n2050     pi/2\n2051 \n2052     See Also\n2053     ========\n2054 \n2055     sin, csc, cos, sec, tan, cot\n2056     asin, acsc, acos, asec, acot, atan2\n2057 \n2058     References\n2059     ==========\n2060 \n2061     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2062     .. [2] http://dlmf.nist.gov/4.23\n2063     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan\n2064     \"\"\"\n2065 \n2066     def fdiff(self, argindex=1):\n2067         if argindex == 1:\n2068             return 1/(1 + self.args[0]**2)\n2069         else:\n2070             raise ArgumentIndexError(self, argindex)\n2071 \n2072     def _eval_is_rational(self):\n2073         s = self.func(*self.args)\n2074         if s.func == self.func:\n2075             if s.args[0].is_rational:\n2076                 return False\n2077         else:\n2078             return s.is_rational\n2079 \n2080     def _eval_is_positive(self):\n2081         return self.args[0].is_positive\n2082 \n2083     def _eval_is_nonnegative(self):\n2084         return self.args[0].is_nonnegative\n2085 \n2086     @classmethod\n2087     def eval(cls, arg):\n2088         if arg.is_Number:\n2089             if arg is S.NaN:\n2090                 return S.NaN\n2091             elif arg is S.Infinity:\n2092                 return S.Pi / 2\n2093             elif arg is S.NegativeInfinity:\n2094                 return -S.Pi / 2\n2095             elif arg is S.Zero:\n2096                 return S.Zero\n2097             elif arg is S.One:\n2098                 return S.Pi / 4\n2099             elif arg is S.NegativeOne:\n2100                 return -S.Pi / 4\n2101         if arg.could_extract_minus_sign():\n2102             return -cls(-arg)\n2103 \n2104         if arg.is_number:\n2105             cst_table = {\n2106                 sqrt(3)/3: 6,\n2107                 -sqrt(3)/3: -6,\n2108                 1/sqrt(3): 6,\n2109                 -1/sqrt(3): -6,\n2110                 sqrt(3): 3,\n2111                 -sqrt(3): -3,\n2112                 (1 + sqrt(2)): S(8)/3,\n2113                 -(1 + sqrt(2)): S(8)/3,\n2114                 (sqrt(2) - 1): 8,\n2115                 (1 - sqrt(2)): -8,\n2116                 sqrt((5 + 2*sqrt(5))): S(5)/2,\n2117                 -sqrt((5 + 2*sqrt(5))): -S(5)/2,\n2118                 (2 - sqrt(3)): 12,\n2119                 -(2 - sqrt(3)): -12\n2120             }\n2121 \n2122             if arg in cst_table:\n2123                 return S.Pi / cst_table[arg]\n2124 \n2125         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n2126         if i_coeff is not None:\n2127             return S.ImaginaryUnit * atanh(i_coeff)\n2128 \n2129     @staticmethod\n2130     @cacheit\n2131     def taylor_term(n, x, *previous_terms):\n2132         if n < 0 or n % 2 == 0:\n2133             return S.Zero\n2134         else:\n2135             x = sympify(x)\n2136             return (-1)**((n - 1)//2) * x**n / n\n2137 \n2138     def _eval_as_leading_term(self, x):\n2139         from sympy import Order\n2140         arg = self.args[0].as_leading_term(x)\n2141 \n2142         if x in arg.free_symbols and Order(1, x).contains(arg):\n2143             return arg\n2144         else:\n2145             return self.func(arg)\n2146 \n2147     def _eval_is_real(self):\n2148         return self.args[0].is_real\n2149 \n2150     def _eval_rewrite_as_log(self, x):\n2151         return S.ImaginaryUnit/2 * (log(\n2152             (S(1) - S.ImaginaryUnit * x)/(S(1) + S.ImaginaryUnit * x)))\n2153 \n2154     def _eval_aseries(self, n, args0, x, logx):\n2155         if args0[0] == S.Infinity:\n2156             return (S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)\n2157         elif args0[0] == S.NegativeInfinity:\n2158             return (-S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)\n2159         else:\n2160             return super(atan, self)._eval_aseries(n, args0, x, logx)\n2161 \n2162     def inverse(self, argindex=1):\n2163         \"\"\"\n2164         Returns the inverse of this function.\n2165         \"\"\"\n2166         return tan\n2167 \n2168     def _eval_rewrite_as_asin(self, arg):\n2169         return sqrt(arg**2)/arg*(S.Pi/2 - asin(1/sqrt(1 + arg**2)))\n2170 \n2171     def _eval_rewrite_as_acos(self, arg):\n2172         return sqrt(arg**2)/arg*acos(1/sqrt(1 + arg**2))\n2173 \n2174     def _eval_rewrite_as_acot(self, arg):\n2175         return acot(1/arg)\n2176 \n2177     def _eval_rewrite_as_asec(self, arg):\n2178         return sqrt(arg**2)/arg*asec(sqrt(1 + arg**2))\n2179 \n2180     def _eval_rewrite_as_acsc(self, arg):\n2181         return sqrt(arg**2)/arg*(S.Pi/2 - acsc(sqrt(1 + arg**2)))\n2182 \n2183 \n2184 class acot(InverseTrigonometricFunction):\n2185     \"\"\"\n2186     The inverse cotangent function.\n2187 \n2188     Returns the arc cotangent of x (measured in radians).\n2189 \n2190     See Also\n2191     ========\n2192 \n2193     sin, csc, cos, sec, tan, cot\n2194     asin, acsc, acos, asec, atan, atan2\n2195 \n2196     References\n2197     ==========\n2198 \n2199     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2200     .. [2] http://dlmf.nist.gov/4.23\n2201     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCot\n2202     \"\"\"\n2203 \n2204     def fdiff(self, argindex=1):\n2205         if argindex == 1:\n2206             return -1 / (1 + self.args[0]**2)\n2207         else:\n2208             raise ArgumentIndexError(self, argindex)\n2209 \n2210     def _eval_is_rational(self):\n2211         s = self.func(*self.args)\n2212         if s.func == self.func:\n2213             if s.args[0].is_rational:\n2214                 return False\n2215         else:\n2216             return s.is_rational\n2217 \n2218     def _eval_is_positive(self):\n2219         return self.args[0].is_real\n2220 \n2221     @classmethod\n2222     def eval(cls, arg):\n2223         if arg.is_Number:\n2224             if arg is S.NaN:\n2225                 return S.NaN\n2226             elif arg is S.Infinity:\n2227                 return S.Zero\n2228             elif arg is S.NegativeInfinity:\n2229                 return S.Zero\n2230             elif arg is S.Zero:\n2231                 return S.Pi/ 2\n2232             elif arg is S.One:\n2233                 return S.Pi / 4\n2234             elif arg is S.NegativeOne:\n2235                 return -S.Pi / 4\n2236 \n2237         if arg.could_extract_minus_sign():\n2238             return -cls(-arg)\n2239 \n2240         if arg.is_number:\n2241             cst_table = {\n2242                 sqrt(3)/3: 3,\n2243                 -sqrt(3)/3: -3,\n2244                 1/sqrt(3): 3,\n2245                 -1/sqrt(3): -3,\n2246                 sqrt(3): 6,\n2247                 -sqrt(3): -6,\n2248                 (1 + sqrt(2)): 8,\n2249                 -(1 + sqrt(2)): -8,\n2250                 (1 - sqrt(2)): -S(8)/3,\n2251                 (sqrt(2) - 1): S(8)/3,\n2252                 sqrt(5 + 2*sqrt(5)): 10,\n2253                 -sqrt(5 + 2*sqrt(5)): -10,\n2254                 (2 + sqrt(3)): 12,\n2255                 -(2 + sqrt(3)): -12,\n2256                 (2 - sqrt(3)): S(12)/5,\n2257                 -(2 - sqrt(3)): -S(12)/5,\n2258             }\n2259 \n2260             if arg in cst_table:\n2261                 return S.Pi / cst_table[arg]\n2262 \n2263         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n2264         if i_coeff is not None:\n2265             return -S.ImaginaryUnit * acoth(i_coeff)\n2266 \n2267     @staticmethod\n2268     @cacheit\n2269     def taylor_term(n, x, *previous_terms):\n2270         if n == 0:\n2271             return S.Pi / 2  # FIX THIS\n2272         elif n < 0 or n % 2 == 0:\n2273             return S.Zero\n2274         else:\n2275             x = sympify(x)\n2276             return (-1)**((n + 1)//2) * x**n / n\n2277 \n2278     def _eval_as_leading_term(self, x):\n2279         from sympy import Order\n2280         arg = self.args[0].as_leading_term(x)\n2281 \n2282         if x in arg.free_symbols and Order(1, x).contains(arg):\n2283             return arg\n2284         else:\n2285             return self.func(arg)\n2286 \n2287     def _eval_is_real(self):\n2288         return self.args[0].is_real\n2289 \n2290     def _eval_aseries(self, n, args0, x, logx):\n2291         if args0[0] == S.Infinity:\n2292             return (S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)\n2293         elif args0[0] == S.NegativeInfinity:\n2294             return (3*S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)\n2295         else:\n2296             return super(atan, self)._eval_aseries(n, args0, x, logx)\n2297 \n2298     def _eval_rewrite_as_log(self, x):\n2299         return S.ImaginaryUnit/2 * \\\n2300             (log((x - S.ImaginaryUnit)/(x + S.ImaginaryUnit)))\n2301 \n2302     def inverse(self, argindex=1):\n2303         \"\"\"\n2304         Returns the inverse of this function.\n2305         \"\"\"\n2306         return cot\n2307 \n2308     def _eval_rewrite_as_asin(self, arg):\n2309         return (arg*sqrt(1/arg**2)*\n2310                 (S.Pi/2 - asin(sqrt(-arg**2)/sqrt(-arg**2 - 1))))\n2311 \n2312     def _eval_rewrite_as_acos(self, arg):\n2313         return arg*sqrt(1/arg**2)*acos(sqrt(-arg**2)/sqrt(-arg**2 - 1))\n2314 \n2315     def _eval_rewrite_as_atan(self, arg):\n2316         return atan(1/arg)\n2317 \n2318     def _eval_rewrite_as_asec(self, arg):\n2319         return arg*sqrt(1/arg**2)*asec(sqrt((1 + arg**2)/arg**2))\n2320 \n2321     def _eval_rewrite_as_acsc(self, arg):\n2322         return arg*sqrt(1/arg**2)*(S.Pi/2 - acsc(sqrt((1 + arg**2)/arg**2)))\n2323 \n2324 \n2325 class asec(InverseTrigonometricFunction):\n2326     \"\"\"\n2327     The inverse secant function.\n2328 \n2329     Returns the arc secant of x (measured in radians).\n2330 \n2331     Notes\n2332     =====\n2333 \n2334     ``asec(x)`` will evaluate automatically in the cases\n2335     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.\n2336 \n2337     ``asec(x)`` has branch cut in the interval [-1, 1]. For complex arguments,\n2338     it can be defined [4]_ as\n2339 \n2340     .. math::\n2341         sec^{-1}(z) = -i*(log(\\sqrt{1 - z^2} + 1) / z)\n2342 \n2343     At ``x = 0``, for positive branch cut, the limit evaluates to ``zoo``. For\n2344     negative branch cut, the limit\n2345 \n2346     .. math::\n2347         \\lim_{z \\to 0}-i*(log(-\\sqrt{1 - z^2} + 1) / z)\n2348 \n2349     simplifies to :math:`-i*log(z/2 + O(z^3))` which ultimately evaluates to\n2350     ``zoo``.\n2351 \n2352     As ``asex(x)`` = ``asec(1/x)``, a similar argument can be given for\n2353     ``acos(x)``.\n2354 \n2355     Examples\n2356     ========\n2357 \n2358     >>> from sympy import asec, oo, pi\n2359     >>> asec(1)\n2360     0\n2361     >>> asec(-1)\n2362     pi\n2363 \n2364     See Also\n2365     ========\n2366 \n2367     sin, csc, cos, sec, tan, cot\n2368     asin, acsc, acos, atan, acot, atan2\n2369 \n2370     References\n2371     ==========\n2372 \n2373     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2374     .. [2] http://dlmf.nist.gov/4.23\n2375     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSec\n2376     .. [4] http://refrence.wolfram.com/language/ref/ArcSec.html\n2377     \"\"\"\n2378 \n2379     @classmethod\n2380     def eval(cls, arg):\n2381         if arg.is_zero:\n2382             return S.ComplexInfinity\n2383         if arg.is_Number:\n2384             if arg is S.NaN:\n2385                 return S.NaN\n2386             elif arg is S.One:\n2387                 return S.Zero\n2388             elif arg is S.NegativeOne:\n2389                 return S.Pi\n2390         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:\n2391             return S.Pi/2\n2392 \n2393     def fdiff(self, argindex=1):\n2394         if argindex == 1:\n2395             return 1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))\n2396         else:\n2397             raise ArgumentIndexError(self, argindex)\n2398 \n2399     def inverse(self, argindex=1):\n2400         \"\"\"\n2401         Returns the inverse of this function.\n2402         \"\"\"\n2403         return sec\n2404 \n2405     def _eval_as_leading_term(self, x):\n2406         from sympy import Order\n2407         arg = self.args[0].as_leading_term(x)\n2408         if Order(1,x).contains(arg):\n2409             return log(arg)\n2410         else:\n2411             return self.func(arg)\n2412 \n2413     def _eval_is_real(self):\n2414         x = self.args[0]\n2415         if x.is_real is False:\n2416             return False\n2417         return (x - 1).is_nonnegative or (-x - 1).is_nonnegative\n2418 \n2419     def _eval_rewrite_as_log(self, arg):\n2420         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))\n2421 \n2422     def _eval_rewrite_as_asin(self, arg):\n2423         return S.Pi/2 - asin(1/arg)\n2424 \n2425     def _eval_rewrite_as_acos(self, arg):\n2426         return acos(1/arg)\n2427 \n2428     def _eval_rewrite_as_atan(self, arg):\n2429         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*atan(arg + sqrt(arg**2 - 1)))\n2430 \n2431     def _eval_rewrite_as_acot(self, arg):\n2432         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*acot(arg - sqrt(arg**2 - 1)))\n2433 \n2434     def _eval_rewrite_as_acsc(self, arg):\n2435         return S.Pi/2 - acsc(arg)\n2436 \n2437 \n2438 class acsc(InverseTrigonometricFunction):\n2439     \"\"\"\n2440     The inverse cosecant function.\n2441 \n2442     Returns the arc cosecant of x (measured in radians).\n2443 \n2444     Notes\n2445     =====\n2446 \n2447     acsc(x) will evaluate automatically in the cases\n2448     oo, -oo, 0, 1, -1.\n2449 \n2450     Examples\n2451     ========\n2452 \n2453     >>> from sympy import acsc, oo, pi\n2454     >>> acsc(1)\n2455     pi/2\n2456     >>> acsc(-1)\n2457     -pi/2\n2458 \n2459     See Also\n2460     ========\n2461 \n2462     sin, csc, cos, sec, tan, cot\n2463     asin, acos, asec, atan, acot, atan2\n2464 \n2465     References\n2466     ==========\n2467 \n2468     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2469     .. [2] http://dlmf.nist.gov/4.23\n2470     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsc\n2471     \"\"\"\n2472 \n2473     @classmethod\n2474     def eval(cls, arg):\n2475         if arg.is_Number:\n2476             if arg is S.NaN:\n2477                 return S.NaN\n2478             elif arg is S.One:\n2479                 return S.Pi/2\n2480             elif arg is S.NegativeOne:\n2481                 return -S.Pi/2\n2482         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:\n2483             return S.Zero\n2484 \n2485     def fdiff(self, argindex=1):\n2486         if argindex == 1:\n2487             return -1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))\n2488         else:\n2489             raise ArgumentIndexError(self, argindex)\n2490 \n2491     def inverse(self, argindex=1):\n2492         \"\"\"\n2493         Returns the inverse of this function.\n2494         \"\"\"\n2495         return csc\n2496 \n2497     def _eval_as_leading_term(self, x):\n2498         from sympy import Order\n2499         arg = self.args[0].as_leading_term(x)\n2500         if Order(1,x).contains(arg):\n2501             return log(arg)\n2502         else:\n2503             return self.func(arg)\n2504 \n2505     def _eval_rewrite_as_log(self, arg):\n2506         return -S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))\n2507 \n2508     def _eval_rewrite_as_asin(self, arg):\n2509         return asin(1/arg)\n2510 \n2511     def _eval_rewrite_as_acos(self, arg):\n2512         return S.Pi/2 - acos(1/arg)\n2513 \n2514     def _eval_rewrite_as_atan(self, arg):\n2515         return sqrt(arg**2)/arg*(S.Pi/2 - atan(sqrt(arg**2 - 1)))\n2516 \n2517     def _eval_rewrite_as_acot(self, arg):\n2518         return sqrt(arg**2)/arg*(S.Pi/2 - acot(1/sqrt(arg**2 - 1)))\n2519 \n2520     def _eval_rewrite_as_asec(self, arg):\n2521         return S.Pi/2 - asec(arg)\n2522 \n2523 \n2524 class atan2(InverseTrigonometricFunction):\n2525     r\"\"\"\n2526     The function ``atan2(y, x)`` computes `\\operatorname{atan}(y/x)` taking\n2527     two arguments `y` and `x`.  Signs of both `y` and `x` are considered to\n2528     determine the appropriate quadrant of `\\operatorname{atan}(y/x)`.\n2529     The range is `(-\\pi, \\pi]`. The complete definition reads as follows:\n2530 \n2531     .. math::\n2532 \n2533         \\operatorname{atan2}(y, x) =\n2534         \\begin{cases}\n2535           \\arctan\\left(\\frac y x\\right) & \\qquad x > 0 \\\\\n2536           \\arctan\\left(\\frac y x\\right) + \\pi& \\qquad y \\ge 0 , x < 0 \\\\\n2537           \\arctan\\left(\\frac y x\\right) - \\pi& \\qquad y < 0 , x < 0 \\\\\n2538           +\\frac{\\pi}{2} & \\qquad y > 0 , x = 0 \\\\\n2539           -\\frac{\\pi}{2} & \\qquad y < 0 , x = 0 \\\\\n2540           \\text{undefined} & \\qquad y = 0, x = 0\n2541         \\end{cases}\n2542 \n2543     Attention: Note the role reversal of both arguments. The `y`-coordinate\n2544     is the first argument and the `x`-coordinate the second.\n2545 \n2546     Examples\n2547     ========\n2548 \n2549     Going counter-clock wise around the origin we find the\n2550     following angles:\n2551 \n2552     >>> from sympy import atan2\n2553     >>> atan2(0, 1)\n2554     0\n2555     >>> atan2(1, 1)\n2556     pi/4\n2557     >>> atan2(1, 0)\n2558     pi/2\n2559     >>> atan2(1, -1)\n2560     3*pi/4\n2561     >>> atan2(0, -1)\n2562     pi\n2563     >>> atan2(-1, -1)\n2564     -3*pi/4\n2565     >>> atan2(-1, 0)\n2566     -pi/2\n2567     >>> atan2(-1, 1)\n2568     -pi/4\n2569 \n2570     which are all correct. Compare this to the results of the ordinary\n2571     `\\operatorname{atan}` function for the point `(x, y) = (-1, 1)`\n2572 \n2573     >>> from sympy import atan, S\n2574     >>> atan(S(1) / -1)\n2575     -pi/4\n2576     >>> atan2(1, -1)\n2577     3*pi/4\n2578 \n2579     where only the `\\operatorname{atan2}` function reurns what we expect.\n2580     We can differentiate the function with respect to both arguments:\n2581 \n2582     >>> from sympy import diff\n2583     >>> from sympy.abc import x, y\n2584     >>> diff(atan2(y, x), x)\n2585     -y/(x**2 + y**2)\n2586 \n2587     >>> diff(atan2(y, x), y)\n2588     x/(x**2 + y**2)\n2589 \n2590     We can express the `\\operatorname{atan2}` function in terms of\n2591     complex logarithms:\n2592 \n2593     >>> from sympy import log\n2594     >>> atan2(y, x).rewrite(log)\n2595     -I*log((x + I*y)/sqrt(x**2 + y**2))\n2596 \n2597     and in terms of `\\operatorname(atan)`:\n2598 \n2599     >>> from sympy import atan\n2600     >>> atan2(y, x).rewrite(atan)\n2601     2*atan(y/(x + sqrt(x**2 + y**2)))\n2602 \n2603     but note that this form is undefined on the negative real axis.\n2604 \n2605     See Also\n2606     ========\n2607 \n2608     sin, csc, cos, sec, tan, cot\n2609     asin, acsc, acos, asec, atan, acot\n2610 \n2611     References\n2612     ==========\n2613 \n2614     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2615     .. [2] http://en.wikipedia.org/wiki/Atan2\n2616     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan2\n2617     \"\"\"\n2618 \n2619     @classmethod\n2620     def eval(cls, y, x):\n2621         from sympy import Heaviside, im, re\n2622         if x is S.NegativeInfinity:\n2623             if y.is_zero:\n2624                 # Special case y = 0 because we define Heaviside(0) = 1/2\n2625                 return S.Pi\n2626             return 2*S.Pi*(Heaviside(re(y))) - S.Pi\n2627         elif x is S.Infinity:\n2628             return S.Zero\n2629         elif x.is_imaginary and y.is_imaginary and x.is_number and y.is_number:\n2630             x = im(x)\n2631             y = im(y)\n2632 \n2633         if x.is_real and y.is_real:\n2634             if x.is_positive:\n2635                 return atan(y / x)\n2636             elif x.is_negative:\n2637                 if y.is_negative:\n2638                     return atan(y / x) - S.Pi\n2639                 elif y.is_nonnegative:\n2640                     return atan(y / x) + S.Pi\n2641             elif x.is_zero:\n2642                 if y.is_positive:\n2643                     return S.Pi/2\n2644                 elif y.is_negative:\n2645                     return -S.Pi/2\n2646                 elif y.is_zero:\n2647                     return S.NaN\n2648         if y.is_zero and x.is_real and fuzzy_not(x.is_zero):\n2649             return S.Pi * (S.One - Heaviside(x))\n2650         if x.is_number and y.is_number:\n2651             return -S.ImaginaryUnit*log(\n2652                 (x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))\n2653 \n2654     def _eval_rewrite_as_log(self, y, x):\n2655         return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y) / sqrt(x**2 + y**2))\n2656 \n2657     def _eval_rewrite_as_atan(self, y, x):\n2658         return 2*atan(y / (sqrt(x**2 + y**2) + x))\n2659 \n2660     def _eval_rewrite_as_arg(self, y, x):\n2661         from sympy import arg\n2662         if x.is_real and y.is_real:\n2663             return arg(x + y*S.ImaginaryUnit)\n2664         I = S.ImaginaryUnit\n2665         n = x + I*y\n2666         d = x**2 + y**2\n2667         return arg(n/sqrt(d)) - I*log(abs(n)/sqrt(abs(d)))\n2668 \n2669     def _eval_is_real(self):\n2670         return self.args[0].is_real and self.args[1].is_real\n2671 \n2672     def _eval_conjugate(self):\n2673         return self.func(self.args[0].conjugate(), self.args[1].conjugate())\n2674 \n2675     def fdiff(self, argindex):\n2676         y, x = self.args\n2677         if argindex == 1:\n2678             # Diff wrt y\n2679             return x/(x**2 + y**2)\n2680         elif argindex == 2:\n2681             # Diff wrt x\n2682             return -y/(x**2 + y**2)\n2683         else:\n2684             raise ArgumentIndexError(self, argindex)\n2685 \n2686     def _eval_evalf(self, prec):\n2687         y, x = self.args\n2688         if x.is_real and y.is_real:\n2689             super(atan2, self)._eval_evalf(prec)\n",
        "intended_behavior": "Although not directly buggy, this file might need a review or update to ensure that the definition and handling of `sinc(x)` within SymPy are conducive to conversion to C code via `ccode`. Specifically, the documentation or meta-information of `sinc(x)` could include hints or properties that `ccode` can utilize to recognize and convert `sinc(x)` expressions more effectively. Enhancing how `sinc(x)` is represented in the context of SymPy's elementary trigonometric functions could aid in its conversion to C code, ensuring a seamless process when such expressions are encountered by `ccode`. If `sinc(x)` is treated specially in terms of symbolic manipulation or simplification, such properties should be documented or coded in a way that `ccode` (or any code-printing routine) can easily translate it into the target language's idioms or library function calls, if available, or into a manually specified piecewise expression otherwise. This may imply refining the symbolic properties of `sinc(x)` to ensure they align with the expectations and capabilities of the code conversion routines."
    }
]