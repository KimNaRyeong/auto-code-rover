2025-10-15 14:33:33.355 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 14:33:44.314 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=178, output_tokens=12, cost=0.002140
2025-10-15 14:33:44.315 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 14:33:44.318 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:33:50.476 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=467, output_tokens=171, cost=0.009800
2025-10-15 14:33:50.478 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:33:55.413 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=525, output_tokens=46, cost=0.006630
2025-10-15 14:33:55.413 | DEBUG    | Extracted a valid json.
2025-10-15 14:33:55.413 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"Schur_Number\")",
        "search_code(\"Schur_Number\")",
        "search_code(\"sum-free sets\")"
    ],
    "bug_locations": []
}
2025-10-15 14:33:55.459 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:33:55.459 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:34:05.501 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=815, output_tokens=373, cost=0.019340
2025-10-15 14:34:05.510 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:34:22.758 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1404, output_tokens=638, cost=0.033180
2025-10-15 14:34:22.769 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:34:23.988 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=14, cost=0.010340
2025-10-15 14:34:23.989 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-15 14:34:23.989 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-15 14:34:25.321 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=14, cost=0.010340
2025-10-15 14:34:25.322 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-15 14:34:25.322 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-15 14:34:26.998 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=14, cost=0.010340
2025-10-15 14:34:26.999 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-15 14:34:27.000 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-15 14:34:28.283 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=14, cost=0.010340
2025-10-15 14:34:28.284 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-15 14:34:28.284 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-15 14:34:29.782 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=14, cost=0.010340
2025-10-15 14:34:29.783 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-15 14:34:29.783 | DEBUG    | Agent proxy return the following json: None
2025-10-15 14:34:29.783 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-15 14:34:29.784 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-15 14:34:29.784 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:34:50.730 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2069, output_tokens=526, cost=0.036470
2025-10-15 14:34:50.740 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:34:57.434 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=880, output_tokens=207, cost=0.015010
2025-10-15 14:34:57.435 | DEBUG    | Extracted a valid json.
2025-10-15 14:34:57.436 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "SchurNumber.py",
            "class": "SchurNumberCalculator",
            "method": "calculate",
            "intended_behavior": "The class `SchurNumberCalculator` should include a method named `calculate` responsible for calculating the Schur Number for a given `k`. This method would implement the logic to partition the interval [1,n] into `k` sum-free sets and determine the largest value of `n` for which this is possible."
        },
        {
            "file": "SchurNumber.py",
            "method": "calculate_schur_number",
            "intended_behavior": "A method named `calculate_schur_number` should be added to a suitable utility file. This method would accept an integer `k` and return the largest integer `n` for which the interval [1,n] can be partitioned into `k` sum-free sets."
        }
    ]
}
2025-10-15 14:34:57.442 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-15 14:34:57.442 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-15 14:34:57.442 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:35:01.704 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2629, output_tokens=119, cost=0.029860
2025-10-15 14:35:01.708 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:35:04.616 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=473, output_tokens=50, cost=0.006230
2025-10-15 14:35:04.618 | DEBUG    | Extracted a valid json.
2025-10-15 14:35:04.618 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MathUtils\")",
        "search_method(\"partition\")",
        "search_code(\"prime number\")",
        "search_code(\"test\")"
    ],
    "bug_locations": []
}
2025-10-15 14:35:12.525 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:35:12.525 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:35:34.360 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8166, output_tokens=687, cost=0.102270
2025-10-15 14:35:34.371 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:35:51.704 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9069, output_tokens=581, cost=0.108120
2025-10-15 14:35:51.714 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:35:59.015 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=935, output_tokens=262, cost=0.017210
2025-10-15 14:35:59.016 | DEBUG    | Extracted a valid json.
2025-10-15 14:35:59.016 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/ntheory/generate.py",
            "class": "",
            "method": "calculate_schur_number",
            "intended_behavior": "This method calculates the Schur number S(k) for a given integer k, which is the largest number n such that the interval [1,n] can be partitioned into k sum-free sets."
        },
        {
            "file": "test_schur_number.py",
            "class": "",
            "method": "test_calculate_schur_number_small_k",
            "intended_behavior": "To cover cases for small values of k."
        },
        {
            "file": "test_schur_number.py",
            "class": "",
            "method": "test_calculate_schur_number_large_k",
            "intended_behavior": "To explore the performance and correctness for larger values of k."
        },
        {
            "file": "test_schur_number.py",
            "class": "",
            "method": "test_calculate_schur_number_edge_cases",
            "intended_behavior": "To handle edge cases, ensuring the method gracefully handles or rejects these cases."
        }
    ]
}
2025-10-15 14:35:59.021 | DEBUG    | Bug location extracted successfully: [<file>sympy/ntheory/generate.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Generating and counting primes.
3 
4 """
5 from __future__ import print_function, division
6 
7 import random
8 from bisect import bisect
9 from itertools import count
10 # Using arrays for sieving instead of lists greatly reduces
11 # memory consumption
12 from array import array as _array
13 
14 from sympy import Function, S
15 from sympy.core.compatibility import as_int
16 from .primetest import isprime
17 
18 
19 def _azeros(n):
20     return _array('l', [0]*n)
21 
22 
23 def _aset(*v):
24     return _array('l', v)
25 
26 
27 def _arange(a, b):
28     return _array('l', range(a, b))
29 
30 
31 class Sieve:
32     """An infinite list of prime numbers, implemented as a dynamically
33     growing sieve of Eratosthenes. When a lookup is requested involving
34     an odd number that has not been sieved, the sieve is automatically
35     extended up to that number.
36 
37     Examples
38     ========
39 
40     >>> from sympy import sieve
41     >>> sieve._reset() # this line for doctest only
42     >>> 25 in sieve
43     False
44     >>> sieve._list
45     array('l', [2, 3, 5, 7, 11, 13, 17, 19, 23])
46     """
47 
48     # data shared (and updated) by all Sieve instances
49     def __init__(self):
50         self._n = 6
51         self._list = _aset(2, 3, 5, 7, 11, 13) # primes
52         self._tlist = _aset(0, 1, 1, 2, 2, 4) # totient
53         self._mlist = _aset(0, 1, -1, -1, 0, -1) # mobius
54         assert all(len(i) == self._n for i in (self._list, self._tlist, self._mlist))
55 
56     def __repr__(self):
57         return ("<%s sieve (%i): %i, %i, %i, ... %i, %i\n"
58              "%s sieve (%i): %i, %i, %i, ... %i, %i\n"
59              "%s sieve (%i): %i, %i, %i, ... %i, %i>") % (
60              'prime', len(self._list),
61                  self._list[0], self._list[1], self._list[2],
62                  self._list[-2], self._list[-1],
63              'totient', len(self._tlist),
64                  self._tlist[0], self._tlist[1],
65                  self._tlist[2], self._tlist[-2], self._tlist[-1],
66              'mobius', len(self._mlist),
67                  self._mlist[0], self._mlist[1],
68                  self._mlist[2], self._mlist[-2], self._mlist[-1])
69 
70     def _reset(self, prime=None, totient=None, mobius=None):
71         """Reset all caches (default). To reset one or more set the
72             desired keyword to True."""
73         if all(i is None for i in (prime, totient, mobius)):
74             prime = totient = mobius = True
75         if prime:
76             self._list = self._list[:self._n]
77         if totient:
78             self._tlist = self._tlist[:self._n]
79         if mobius:
80             self._mlist = self._mlist[:self._n]
81 
82     def extend(self, n):
83         """Grow the sieve to cover all primes <= n (a real number).
84 
85         Examples
86         ========
87 
88         >>> from sympy import sieve
89         >>> sieve._reset() # this line for doctest only
90         >>> sieve.extend(30)
91         >>> sieve[10] == 29
92         True
93         """
94         n = int(n)
95         if n <= self._list[-1]:
96             return
97 
98         # We need to sieve against all bases up to sqrt(n).
99         # This is a recursive call that will do nothing if there are enough
100         # known bases already.
101         maxbase = int(n**0.5) + 1
102         self.extend(maxbase)
103 
104         # Create a new sieve starting from sqrt(n)
105         begin = self._list[-1] + 1
106         newsieve = _arange(begin, n + 1)
107 
108         # Now eliminate all multiples of primes in [2, sqrt(n)]
109         for p in self.primerange(2, maxbase):
110             # Start counting at a multiple of p, offsetting
111             # the index to account for the new sieve's base index
112             startindex = (-begin) % p
113             for i in range(startindex, len(newsieve), p):
114                 newsieve[i] = 0
115 
116         # Merge the sieves
117         self._list += _array('l', [x for x in newsieve if x])
118 
119     def extend_to_no(self, i):
120         """Extend to include the ith prime number.
121 
122         Parameters
123         ==========
124 
125         i : integer
126 
127         Examples
128         ========
129 
130         >>> from sympy import sieve
131         >>> sieve._reset() # this line for doctest only
132         >>> sieve.extend_to_no(9)
133         >>> sieve._list
134         array('l', [2, 3, 5, 7, 11, 13, 17, 19, 23])
135 
136         Notes
137         =====
138 
139         The list is extended by 50% if it is too short, so it is
140         likely that it will be longer than requested.
141         """
142         i = as_int(i)
143         while len(self._list) < i:
144             self.extend(int(self._list[-1] * 1.5))
145 
146     def primerange(self, a, b):
147         """Generate all prime numbers in the range [a, b).
148 
149         Examples
150         ========
151 
152         >>> from sympy import sieve
153         >>> print([i for i in sieve.primerange(7, 18)])
154         [7, 11, 13, 17]
155         """
156         from sympy.functions.elementary.integers import ceiling
157 
158         # wrapping ceiling in as_int will raise an error if there was a problem
159         # determining whether the expression was exactly an integer or not
160         a = max(2, as_int(ceiling(a)))
161         b = as_int(ceiling(b))
162         if a >= b:
163             return
164         self.extend(b)
165         i = self.search(a)[1]
166         maxi = len(self._list) + 1
167         while i < maxi:
168             p = self._list[i - 1]
169             if p < b:
170                 yield p
171                 i += 1
172             else:
173                 return
174 
175     def totientrange(self, a, b):
176         """Generate all totient numbers for the range [a, b).
177 
178         Examples
179         ========
180 
181         >>> from sympy import sieve
182         >>> print([i for i in sieve.totientrange(7, 18)])
183         [6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16]
184         """
185         from sympy.functions.elementary.integers import ceiling
186 
187         # wrapping ceiling in as_int will raise an error if there was a problem
188         # determining whether the expression was exactly an integer or not
189         a = max(1, as_int(ceiling(a)))
190         b = as_int(ceiling(b))
191         n = len(self._tlist)
192         if a >= b:
193             return
194         elif b <= n:
195             for i in range(a, b):
196                 yield self._tlist[i]
197         else:
198             self._tlist += _arange(n, b)
199             for i in range(1, n):
200                 ti = self._tlist[i]
201                 startindex = (n + i - 1) // i * i
202                 for j in range(startindex, b, i):
203                     self._tlist[j] -= ti
204                 if i >= a:
205                     yield ti
206 
207             for i in range(n, b):
208                 ti = self._tlist[i]
209                 for j in range(2 * i, b, i):
210                     self._tlist[j] -= ti
211                 if i >= a:
212                     yield ti
213 
214     def mobiusrange(self, a, b):
215         """Generate all mobius numbers for the range [a, b).
216 
217         Parameters
218         ==========
219 
220         a : integer
221             First number in range
222 
223         b : integer
224             First number outside of range
225 
226         Examples
227         ========
228 
229         >>> from sympy import sieve
230         >>> print([i for i in sieve.mobiusrange(7, 18)])
231         [-1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1]
232         """
233         from sympy.functions.elementary.integers import ceiling
234 
235         # wrapping ceiling in as_int will raise an error if there was a problem
236         # determining whether the expression was exactly an integer or not
237         a = max(1, as_int(ceiling(a)))
238         b = as_int(ceiling(b))
239         n = len(self._mlist)
240         if a >= b:
241             return
242         elif b <= n:
243             for i in range(a, b):
244                 yield self._mlist[i]
245         else:
246             self._mlist += _azeros(b - n)
247             for i in range(1, n):
248                 mi = self._mlist[i]
249                 startindex = (n + i - 1) // i * i
250                 for j in range(startindex, b, i):
251                     self._mlist[j] -= mi
252                 if i >= a:
253                     yield mi
254 
255             for i in range(n, b):
256                 mi = self._mlist[i]
257                 for j in range(2 * i, b, i):
258                     self._mlist[j] -= mi
259                 if i >= a:
260                     yield mi
261 
262     def search(self, n):
263         """Return the indices i, j of the primes that bound n.
264 
265         If n is prime then i == j.
266 
267         Although n can be an expression, if ceiling cannot convert
268         it to an integer then an n error will be raised.
269 
270         Examples
271         ========
272 
273         >>> from sympy import sieve
274         >>> sieve.search(25)
275         (9, 10)
276         >>> sieve.search(23)
277         (9, 9)
278         """
279         from sympy.functions.elementary.integers import ceiling
280 
281         # wrapping ceiling in as_int will raise an error if there was a problem
282         # determining whether the expression was exactly an integer or not
283         test = as_int(ceiling(n))
284         n = as_int(n)
285         if n < 2:
286             raise ValueError("n should be >= 2 but got: %s" % n)
287         if n > self._list[-1]:
288             self.extend(n)
289         b = bisect(self._list, n)
290         if self._list[b - 1] == test:
291             return b, b
292         else:
293             return b, b + 1
294 
295     def __contains__(self, n):
296         try:
297             n = as_int(n)
298             assert n >= 2
299         except (ValueError, AssertionError):
300             return False
301         if n % 2 == 0:
302             return n == 2
303         a, b = self.search(n)
304         return a == b
305 
306     def __iter__(self):
307         for n in count(1):
308             yield self[n]
309 
310     def __getitem__(self, n):
311         """Return the nth prime number"""
312         if isinstance(n, slice):
313             self.extend_to_no(n.stop)
314             # Python 2.7 slices have 0 instead of None for start, so
315             # we can't default to 1.
316             start = n.start if n.start is not None else 0
317             if start < 1:
318                 # sieve[:5] would be empty (starting at -1), let's
319                 # just be explicit and raise.
320                 raise IndexError("Sieve indices start at 1.")
321             return self._list[start - 1:n.stop - 1:n.step]
322         else:
323             if n < 1:
324                 # offset is one, so forbid explicit access to sieve[0]
325                 # (would surprisingly return the last one).
326                 raise IndexError("Sieve indices start at 1.")
327             n = as_int(n)
328             self.extend_to_no(n)
329             return self._list[n - 1]
330 
331 # Generate a global object for repeated use in trial division etc
332 sieve = Sieve()
333 
334 
335 def prime(nth):
336     """ Return the nth prime, with the primes indexed as prime(1) = 2,
337         prime(2) = 3, etc.... The nth prime is approximately n*log(n).
338 
339         Logarithmic integral of x is a pretty nice approximation for number of
340         primes <= x, i.e.
341         li(x) ~ pi(x)
342         In fact, for the numbers we are concerned about( x<1e11 ),
343         li(x) - pi(x) < 50000
344 
345         Also,
346         li(x) > pi(x) can be safely assumed for the numbers which
347         can be evaluated by this function.
348 
349         Here, we find the least integer m such that li(m) > n using binary search.
350         Now pi(m-1) < li(m-1) <= n,
351 
352         We find pi(m - 1) using primepi function.
353 
354         Starting from m, we have to find n - pi(m-1) more primes.
355 
356         For the inputs this implementation can handle, we will have to test
357         primality for at max about 10**5 numbers, to get our answer.
358 
359         Examples
360         ========
361 
362         >>> from sympy import prime
363         >>> prime(10)
364         29
365         >>> prime(1)
366         2
367         >>> prime(100000)
368         1299709
369 
370         See Also
371         ========
372 
373         sympy.ntheory.primetest.isprime : Test if n is prime
374         primerange : Generate all primes in a given range
375         primepi : Return the number of primes less than or equal to n
376 
377         References
378         ==========
379 
380         .. [1] https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29
381         .. [2] https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number
382         .. [3] https://en.wikipedia.org/wiki/Skewes%27_number
383     """
384     n = as_int(nth)
385     if n < 1:
386         raise ValueError("nth must be a positive integer; prime(1) == 2")
387     if n <= len(sieve._list):
388         return sieve[n]
389 
390     from sympy.functions.special.error_functions import li
391     from sympy.functions.elementary.exponential import log
392 
393     a = 2 # Lower bound for binary search
394     b = int(n*(log(n) + log(log(n)))) # Upper bound for the search.
395 
396     while a < b:
397         mid = (a + b) >> 1
398         if li(mid) > n:
399             b = mid
400         else:
401             a = mid + 1
402     n_primes = primepi(a - 1)
403     while n_primes < n:
404         if isprime(a):
405             n_primes += 1
406         a += 1
407     return a - 1
408 
409 
410 class primepi(Function):
411     """ Represents the prime counting function pi(n) = the number
412         of prime numbers less than or equal to n.
413 
414         Algorithm Description:
415 
416         In sieve method, we remove all multiples of prime p
417         except p itself.
418 
419         Let phi(i,j) be the number of integers 2 <= k <= i
420         which remain after sieving from primes less than
421         or equal to j.
422         Clearly, pi(n) = phi(n, sqrt(n))
423 
424         If j is not a prime,
425         phi(i,j) = phi(i, j - 1)
426 
427         if j is a prime,
428         We remove all numbers(except j) whose
429         smallest prime factor is j.
430 
431         Let x= j*a be such a number, where 2 <= a<= i / j
432         Now, after sieving from primes <= j - 1,
433         a must remain
434         (because x, and hence a has no prime factor <= j - 1)
435         Clearly, there are phi(i / j, j - 1) such a
436         which remain on sieving from primes <= j - 1
437 
438         Now, if a is a prime less than equal to j - 1,
439         x= j*a has smallest prime factor = a, and
440         has already been removed(by sieving from a).
441         So, we don't need to remove it again.
442         (Note: there will be pi(j - 1) such x)
443 
444         Thus, number of x, that will be removed are:
445         phi(i / j, j - 1) - phi(j - 1, j - 1)
446         (Note that pi(j - 1) = phi(j - 1, j - 1))
447 
448         => phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j - 1)
449 
450         So,following recursion is used and implemented as dp:
451 
452         phi(a, b) = phi(a, b - 1), if b is not a prime
453         phi(a, b) = phi(a, b-1)-phi(a / b, b-1) + phi(b-1, b-1), if b is prime
454 
455         Clearly a is always of the form floor(n / k),
456         which can take at most 2*sqrt(n) values.
457         Two arrays arr1,arr2 are maintained
458         arr1[i] = phi(i, j),
459         arr2[i] = phi(n // i, j)
460 
461         Finally the answer is arr2[1]
462 
463         Examples
464         ========
465 
466         >>> from sympy import primepi
467         >>> primepi(25)
468         9
469 
470         See Also
471         ========
472 
473         sympy.ntheory.primetest.isprime : Test if n is prime
474         primerange : Generate all primes in a given range
475         prime : Return the nth prime
476     """
477     @classmethod
478     def eval(cls, n):
479         if n is S.Infinity:
480             return S.Infinity
481         if n is S.NegativeInfinity:
482             return S.Zero
483 
484         try:
485             n = int(n)
486         except TypeError:
487             if n.is_real == False or n is S.NaN:
488                 raise ValueError("n must be real")
489             return
490 
491         if n < 2:
492             return S.Zero
493         if n <= sieve._list[-1]:
494             return S(sieve.search(n)[0])
495         lim = int(n ** 0.5)
496         lim -= 1
497         lim = max(lim, 0)
498         while lim * lim <= n:
499             lim += 1
500         lim -= 1
501         arr1 = [0] * (lim + 1)
502         arr2 = [0] * (lim + 1)
503         for i in range(1, lim + 1):
504             arr1[i] = i - 1
505             arr2[i] = n // i - 1
506         for i in range(2, lim + 1):
507             # Presently, arr1[k]=phi(k,i - 1),
508             # arr2[k] = phi(n // k,i - 1)
509             if arr1[i] == arr1[i - 1]:
510                 continue
511             p = arr1[i - 1]
512             for j in range(1, min(n // (i * i), lim) + 1):
513                 st = i * j
514                 if st <= lim:
515                     arr2[j] -= arr2[st] - p
516                 else:
517                     arr2[j] -= arr1[n // st] - p
518             lim2 = min(lim, i * i - 1)
519             for j in range(lim, lim2, -1):
520                 arr1[j] -= arr1[j // i] - p
521         return S(arr2[1])
522 
523 
524 def nextprime(n, ith=1):
525     """ Return the ith prime greater than n.
526 
527         i must be an integer.
528 
529         Notes
530         =====
531 
532         Potential primes are located at 6*j +/- 1. This
533         property is used during searching.
534 
535         >>> from sympy import nextprime
536         >>> [(i, nextprime(i)) for i in range(10, 15)]
537         [(10, 11), (11, 13), (12, 13), (13, 17), (14, 17)]
538         >>> nextprime(2, ith=2) # the 2nd prime after 2
539         5
540 
541         See Also
542         ========
543 
544         prevprime : Return the largest prime smaller than n
545         primerange : Generate all primes in a given range
546 
547     """
548     n = int(n)
549     i = as_int(ith)
550     if i > 1:
551         pr = n
552         j = 1
553         while 1:
554             pr = nextprime(pr)
555             j += 1
556             if j > i:
557                 break
558         return pr
559 
560     if n < 2:
561         return 2
562     if n < 7:
563         return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]
564     if n <= sieve._list[-2]:
565         l, u = sieve.search(n)
566         if l == u:
567             return sieve[u + 1]
568         else:
569             return sieve[u]
570     nn = 6*(n//6)
571     if nn == n:
572         n += 1
573         if isprime(n):
574             return n
575         n += 4
576     elif n - nn == 5:
577         n += 2
578         if isprime(n):
579             return n
580         n += 4
581     else:
582         n = nn + 5
583     while 1:
584         if isprime(n):
585             return n
586         n += 2
587         if isprime(n):
588             return n
589         n += 4
590 
591 
592 def prevprime(n):
593     """ Return the largest prime smaller than n.
594 
595         Notes
596         =====
597 
598         Potential primes are located at 6*j +/- 1. This
599         property is used during searching.
600 
601         >>> from sympy import prevprime
602         >>> [(i, prevprime(i)) for i in range(10, 15)]
603         [(10, 7), (11, 7), (12, 11), (13, 11), (14, 13)]
604 
605         See Also
606         ========
607 
608         nextprime : Return the ith prime greater than n
609         primerange : Generates all primes in a given range
610     """
611     from sympy.functions.elementary.integers import ceiling
612 
613     # wrapping ceiling in as_int will raise an error if there was a problem
614     # determining whether the expression was exactly an integer or not
615     n = as_int(ceiling(n))
616     if n < 3:
617         raise ValueError("no preceding primes")
618     if n < 8:
619         return {3: 2, 4: 3, 5: 3, 6: 5, 7: 5}[n]
620     if n <= sieve._list[-1]:
621         l, u = sieve.search(n)
622         if l == u:
623             return sieve[l-1]
624         else:
625             return sieve[l]
626     nn = 6*(n//6)
627     if n - nn <= 1:
628         n = nn - 1
629         if isprime(n):
630             return n
631         n -= 4
632     else:
633         n = nn + 1
634     while 1:
635         if isprime(n):
636             return n
637         n -= 2
638         if isprime(n):
639             return n
640         n -= 4
641 
642 
643 def primerange(a, b):
644     """ Generate a list of all prime numbers in the range [a, b).
645 
646         If the range exists in the default sieve, the values will
647         be returned from there; otherwise values will be returned
648         but will not modify the sieve.
649 
650         Examples
651         ========
652 
653         >>> from sympy import primerange, sieve
654         >>> print([i for i in primerange(1, 30)])
655         [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
656 
657         The Sieve method, primerange, is generally faster but it will
658         occupy more memory as the sieve stores values. The default
659         instance of Sieve, named sieve, can be used:
660 
661         >>> list(sieve.primerange(1, 30))
662         [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
663 
664         Notes
665         =====
666 
667         Some famous conjectures about the occurrence of primes in a given
668         range are [1]:
669 
670         - Twin primes: though often not, the following will give 2 primes
671                     an infinite number of times:
672                         primerange(6*n - 1, 6*n + 2)
673         - Legendre's: the following always yields at least one prime
674                         primerange(n**2, (n+1)**2+1)
675         - Bertrand's (proven): there is always a prime in the range
676                         primerange(n, 2*n)
677         - Brocard's: there are at least four primes in the range
678                         primerange(prime(n)**2, prime(n+1)**2)
679 
680         The average gap between primes is log(n) [2]; the gap between
681         primes can be arbitrarily large since sequences of composite
682         numbers are arbitrarily large, e.g. the numbers in the sequence
683         n! + 2, n! + 3 ... n! + n are all composite.
684 
685         See Also
686         ========
687 
688         nextprime : Return the ith prime greater than n
689         prevprime : Return the largest prime smaller than n
690         randprime : Returns a random prime in a given range
691         primorial : Returns the product of primes based on condition
692         Sieve.primerange : return range from already computed primes
693                            or extend the sieve to contain the requested
694                            range.
695 
696         References
697         ==========
698 
699         .. [1] https://en.wikipedia.org/wiki/Prime_number
700         .. [2] http://primes.utm.edu/notes/gaps.html
701     """
702     from sympy.functions.elementary.integers import ceiling
703 
704     if a >= b:
705         return
706     # if we already have the range, return it
707     if b <= sieve._list[-1]:
708         for i in sieve.primerange(a, b):
709             yield i
710         return
711     # otherwise compute, without storing, the desired range.
712 
713     # wrapping ceiling in as_int will raise an error if there was a problem
714     # determining whether the expression was exactly an integer or not
715     a = as_int(ceiling(a)) - 1
716     b = as_int(ceiling(b))
717     while 1:
718         a = nextprime(a)
719         if a < b:
720             yield a
721         else:
722             return
723 
724 
725 def randprime(a, b):
726     """ Return a random prime number in the range [a, b).
727 
728         Bertrand's postulate assures that
729         randprime(a, 2*a) will always succeed for a > 1.
730 
731         Examples
732         ========
733 
734         >>> from sympy import randprime, isprime
735         >>> randprime(1, 30) #doctest: +SKIP
736         13
737         >>> isprime(randprime(1, 30))
738         True
739 
740         See Also
741         ========
742 
743         primerange : Generate all primes in a given range
744 
745         References
746         ==========
747 
748         .. [1] https://en.wikipedia.org/wiki/Bertrand's_postulate
749 
750     """
751     if a >= b:
752         return
753     a, b = map(int, (a, b))
754     n = random.randint(a - 1, b)
755     p = nextprime(n)
756     if p >= b:
757         p = prevprime(b)
758     if p < a:
759         raise ValueError("no primes exist in the specified range")
760     return p
761 
762 
763 def primorial(n, nth=True):
764     """
765     Returns the product of the first n primes (default) or
766     the primes less than or equal to n (when ``nth=False``).
767 
768     Examples
769     ========
770 
771     >>> from sympy.ntheory.generate import primorial, randprime, primerange
772     >>> from sympy import factorint, Mul, primefactors, sqrt
773     >>> primorial(4) # the first 4 primes are 2, 3, 5, 7
774     210
775     >>> primorial(4, nth=False) # primes <= 4 are 2 and 3
776     6
777     >>> primorial(1)
778     2
779     >>> primorial(1, nth=False)
780     1
781     >>> primorial(sqrt(101), nth=False)
782     210
783 
784     One can argue that the primes are infinite since if you take
785     a set of primes and multiply them together (e.g. the primorial) and
786     then add or subtract 1, the result cannot be divided by any of the
787     original factors, hence either 1 or more new primes must divide this
788     product of primes.
789 
790     In this case, the number itself is a new prime:
791 
792     >>> factorint(primorial(4) + 1)
793     {211: 1}
794 
795     In this case two new primes are the factors:
796 
797     >>> factorint(primorial(4) - 1)
798     {11: 1, 19: 1}
799 
800     Here, some primes smaller and larger than the primes multiplied together
801     are obtained:
802 
803     >>> p = list(primerange(10, 20))
804     >>> sorted(set(primefactors(Mul(*p) + 1)).difference(set(p)))
805     [2, 5, 31, 149]
806 
807     See Also
808     ========
809 
810     primerange : Generate all primes in a given range
811 
812     """
813     if nth:
814         n = as_int(n)
815     else:
816         n = int(n)
817     if n < 1:
818         raise ValueError("primorial argument must be >= 1")
819     p = 1
820     if nth:
821         for i in range(1, n + 1):
822             p *= prime(i)
823     else:
824         for i in primerange(2, n + 1):
825             p *= i
826     return p
827 
828 
829 def cycle_length(f, x0, nmax=None, values=False):
830     """For a given iterated sequence, return a generator that gives
831     the length of the iterated cycle (lambda) and the length of terms
832     before the cycle begins (mu); if ``values`` is True then the
833     terms of the sequence will be returned instead. The sequence is
834     started with value ``x0``.
835 
836     Note: more than the first lambda + mu terms may be returned and this
837     is the cost of cycle detection with Brent's method; there are, however,
838     generally less terms calculated than would have been calculated if the
839     proper ending point were determined, e.g. by using Floyd's method.
840 
841     >>> from sympy.ntheory.generate import cycle_length
842 
843     This will yield successive values of i <-- func(i):
844 
845         >>> def iter(func, i):
846         ...     while 1:
847         ...         ii = func(i)
848         ...         yield ii
849         ...         i = ii
850         ...
851 
852     A function is defined:
853 
854         >>> func = lambda i: (i**2 + 1) % 51
855 
856     and given a seed of 4 and the mu and lambda terms calculated:
857 
858         >>> next(cycle_length(func, 4))
859         (6, 2)
860 
861     We can see what is meant by looking at the output:
862 
863         >>> n = cycle_length(func, 4, values=True)
864         >>> list(ni for ni in n)
865         [17, 35, 2, 5, 26, 14, 44, 50, 2, 5, 26, 14]
866 
867     There are 6 repeating values after the first 2.
868 
869     If a sequence is suspected of being longer than you might wish, ``nmax``
870     can be used to exit early (and mu will be returned as None):
871 
872         >>> next(cycle_length(func, 4, nmax = 4))
873         (4, None)
874         >>> [ni for ni in cycle_length(func, 4, nmax = 4, values=True)]
875         [17, 35, 2, 5]
876 
877     Code modified from:
878         https://en.wikipedia.org/wiki/Cycle_detection.
879     """
880 
881     nmax = int(nmax or 0)
882 
883     # main phase: search successive powers of two
884     power = lam = 1
885     tortoise, hare = x0, f(x0)  # f(x0) is the element/node next to x0.
886     i = 0
887     while tortoise != hare and (not nmax or i < nmax):
888         i += 1
889         if power == lam:   # time to start a new power of two?
890             tortoise = hare
891             power *= 2
892             lam = 0
893         if values:
894             yield hare
895         hare = f(hare)
896         lam += 1
897     if nmax and i == nmax:
898         if values:
899             return
900         else:
901             yield nmax, None
902             return
903     if not values:
904         # Find the position of the first repetition of length lambda
905         mu = 0
906         tortoise = hare = x0
907         for i in range(lam):
908             hare = f(hare)
909         while tortoise != hare:
910             tortoise = f(tortoise)
911             hare = f(hare)
912             mu += 1
913         if mu:
914             mu -= 1
915         yield lam, mu
916 
917 
918 def composite(nth):
919     """ Return the nth composite number, with the composite numbers indexed as
920         composite(1) = 4, composite(2) = 6, etc....
921 
922         Examples
923         ========
924 
925         >>> from sympy import composite
926         >>> composite(36)
927         52
928         >>> composite(1)
929         4
930         >>> composite(17737)
931         20000
932 
933         See Also
934         ========
935 
936         sympy.ntheory.primetest.isprime : Test if n is prime
937         primerange : Generate all primes in a given range
938         primepi : Return the number of primes less than or equal to n
939         prime : Return the nth prime
940         compositepi : Return the number of positive composite numbers less than or equal to n
941     """
942     n = as_int(nth)
943     if n < 1:
944         raise ValueError("nth must be a positive integer; composite(1) == 4")
945     composite_arr = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18]
946     if n <= 10:
947         return composite_arr[n - 1]
948 
949     a, b = 4, sieve._list[-1]
950     if n <= b - primepi(b) - 1:
951         while a < b - 1:
952             mid = (a + b) >> 1
953             if mid - primepi(mid) - 1 > n:
954                 b = mid
955             else:
956                 a = mid
957         if isprime(a):
958             a -= 1
959         return a
960 
961     from sympy.functions.special.error_functions import li
962     from sympy.functions.elementary.exponential import log
963 
964     a = 4 # Lower bound for binary search
965     b = int(n*(log(n) + log(log(n)))) # Upper bound for the search.
966 
967     while a < b:
968         mid = (a + b) >> 1
969         if mid - li(mid) - 1 > n:
970             b = mid
971         else:
972             a = mid + 1
973 
974     n_composites = a - primepi(a) - 1
975     while n_composites > n:
976         if not isprime(a):
977             n_composites -= 1
978         a -= 1
979     if isprime(a):
980         a -= 1
981     return a
982 
983 
984 def compositepi(n):
985     """ Return the number of positive composite numbers less than or equal to n.
986         The first positive composite is 4, i.e. compositepi(4) = 1.
987 
988         Examples
989         ========
990 
991         >>> from sympy import compositepi
992         >>> compositepi(25)
993         15
994         >>> compositepi(1000)
995         831
996 
997         See Also
998         ========
999 
1000         sympy.ntheory.primetest.isprime : Test if n is prime
1001         primerange : Generate all primes in a given range
1002         prime : Return the nth prime
1003         primepi : Return the number of primes less than or equal to n
1004         composite : Return the nth composite number
1005     """
1006     n = int(n)
1007     if n < 4:
1008         return 0
1009     return n - primepi(n) - 1

</code><intended_behavior>This method calculates the Schur number S(k) for a given integer k, which is the largest number n such that the interval [1,n] can be partitioned into k sum-free sets.</intended_behavior>]
2025-10-15 14:35:59.021 | INFO     | Search completed. Bug locations: [<file>sympy/ntheory/generate.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Generating and counting primes.
3 
4 """
5 from __future__ import print_function, division
6 
7 import random
8 from bisect import bisect
9 from itertools import count
10 # Using arrays for sieving instead of lists greatly reduces
11 # memory consumption
12 from array import array as _array
13 
14 from sympy import Function, S
15 from sympy.core.compatibility import as_int
16 from .primetest import isprime
17 
18 
19 def _azeros(n):
20     return _array('l', [0]*n)
21 
22 
23 def _aset(*v):
24     return _array('l', v)
25 
26 
27 def _arange(a, b):
28     return _array('l', range(a, b))
29 
30 
31 class Sieve:
32     """An infinite list of prime numbers, implemented as a dynamically
33     growing sieve of Eratosthenes. When a lookup is requested involving
34     an odd number that has not been sieved, the sieve is automatically
35     extended up to that number.
36 
37     Examples
38     ========
39 
40     >>> from sympy import sieve
41     >>> sieve._reset() # this line for doctest only
42     >>> 25 in sieve
43     False
44     >>> sieve._list
45     array('l', [2, 3, 5, 7, 11, 13, 17, 19, 23])
46     """
47 
48     # data shared (and updated) by all Sieve instances
49     def __init__(self):
50         self._n = 6
51         self._list = _aset(2, 3, 5, 7, 11, 13) # primes
52         self._tlist = _aset(0, 1, 1, 2, 2, 4) # totient
53         self._mlist = _aset(0, 1, -1, -1, 0, -1) # mobius
54         assert all(len(i) == self._n for i in (self._list, self._tlist, self._mlist))
55 
56     def __repr__(self):
57         return ("<%s sieve (%i): %i, %i, %i, ... %i, %i\n"
58              "%s sieve (%i): %i, %i, %i, ... %i, %i\n"
59              "%s sieve (%i): %i, %i, %i, ... %i, %i>") % (
60              'prime', len(self._list),
61                  self._list[0], self._list[1], self._list[2],
62                  self._list[-2], self._list[-1],
63              'totient', len(self._tlist),
64                  self._tlist[0], self._tlist[1],
65                  self._tlist[2], self._tlist[-2], self._tlist[-1],
66              'mobius', len(self._mlist),
67                  self._mlist[0], self._mlist[1],
68                  self._mlist[2], self._mlist[-2], self._mlist[-1])
69 
70     def _reset(self, prime=None, totient=None, mobius=None):
71         """Reset all caches (default). To reset one or more set the
72             desired keyword to True."""
73         if all(i is None for i in (prime, totient, mobius)):
74             prime = totient = mobius = True
75         if prime:
76             self._list = self._list[:self._n]
77         if totient:
78             self._tlist = self._tlist[:self._n]
79         if mobius:
80             self._mlist = self._mlist[:self._n]
81 
82     def extend(self, n):
83         """Grow the sieve to cover all primes <= n (a real number).
84 
85         Examples
86         ========
87 
88         >>> from sympy import sieve
89         >>> sieve._reset() # this line for doctest only
90         >>> sieve.extend(30)
91         >>> sieve[10] == 29
92         True
93         """
94         n = int(n)
95         if n <= self._list[-1]:
96             return
97 
98         # We need to sieve against all bases up to sqrt(n).
99         # This is a recursive call that will do nothing if there are enough
100         # known bases already.
101         maxbase = int(n**0.5) + 1
102         self.extend(maxbase)
103 
104         # Create a new sieve starting from sqrt(n)
105         begin = self._list[-1] + 1
106         newsieve = _arange(begin, n + 1)
107 
108         # Now eliminate all multiples of primes in [2, sqrt(n)]
109         for p in self.primerange(2, maxbase):
110             # Start counting at a multiple of p, offsetting
111             # the index to account for the new sieve's base index
112             startindex = (-begin) % p
113             for i in range(startindex, len(newsieve), p):
114                 newsieve[i] = 0
115 
116         # Merge the sieves
117         self._list += _array('l', [x for x in newsieve if x])
118 
119     def extend_to_no(self, i):
120         """Extend to include the ith prime number.
121 
122         Parameters
123         ==========
124 
125         i : integer
126 
127         Examples
128         ========
129 
130         >>> from sympy import sieve
131         >>> sieve._reset() # this line for doctest only
132         >>> sieve.extend_to_no(9)
133         >>> sieve._list
134         array('l', [2, 3, 5, 7, 11, 13, 17, 19, 23])
135 
136         Notes
137         =====
138 
139         The list is extended by 50% if it is too short, so it is
140         likely that it will be longer than requested.
141         """
142         i = as_int(i)
143         while len(self._list) < i:
144             self.extend(int(self._list[-1] * 1.5))
145 
146     def primerange(self, a, b):
147         """Generate all prime numbers in the range [a, b).
148 
149         Examples
150         ========
151 
152         >>> from sympy import sieve
153         >>> print([i for i in sieve.primerange(7, 18)])
154         [7, 11, 13, 17]
155         """
156         from sympy.functions.elementary.integers import ceiling
157 
158         # wrapping ceiling in as_int will raise an error if there was a problem
159         # determining whether the expression was exactly an integer or not
160         a = max(2, as_int(ceiling(a)))
161         b = as_int(ceiling(b))
162         if a >= b:
163             return
164         self.extend(b)
165         i = self.search(a)[1]
166         maxi = len(self._list) + 1
167         while i < maxi:
168             p = self._list[i - 1]
169             if p < b:
170                 yield p
171                 i += 1
172             else:
173                 return
174 
175     def totientrange(self, a, b):
176         """Generate all totient numbers for the range [a, b).
177 
178         Examples
179         ========
180 
181         >>> from sympy import sieve
182         >>> print([i for i in sieve.totientrange(7, 18)])
183         [6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16]
184         """
185         from sympy.functions.elementary.integers import ceiling
186 
187         # wrapping ceiling in as_int will raise an error if there was a problem
188         # determining whether the expression was exactly an integer or not
189         a = max(1, as_int(ceiling(a)))
190         b = as_int(ceiling(b))
191         n = len(self._tlist)
192         if a >= b:
193             return
194         elif b <= n:
195             for i in range(a, b):
196                 yield self._tlist[i]
197         else:
198             self._tlist += _arange(n, b)
199             for i in range(1, n):
200                 ti = self._tlist[i]
201                 startindex = (n + i - 1) // i * i
202                 for j in range(startindex, b, i):
203                     self._tlist[j] -= ti
204                 if i >= a:
205                     yield ti
206 
207             for i in range(n, b):
208                 ti = self._tlist[i]
209                 for j in range(2 * i, b, i):
210                     self._tlist[j] -= ti
211                 if i >= a:
212                     yield ti
213 
214     def mobiusrange(self, a, b):
215         """Generate all mobius numbers for the range [a, b).
216 
217         Parameters
218         ==========
219 
220         a : integer
221             First number in range
222 
223         b : integer
224             First number outside of range
225 
226         Examples
227         ========
228 
229         >>> from sympy import sieve
230         >>> print([i for i in sieve.mobiusrange(7, 18)])
231         [-1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1]
232         """
233         from sympy.functions.elementary.integers import ceiling
234 
235         # wrapping ceiling in as_int will raise an error if there was a problem
236         # determining whether the expression was exactly an integer or not
237         a = max(1, as_int(ceiling(a)))
238         b = as_int(ceiling(b))
239         n = len(self._mlist)
240         if a >= b:
241             return
242         elif b <= n:
243             for i in range(a, b):
244                 yield self._mlist[i]
245         else:
246             self._mlist += _azeros(b - n)
247             for i in range(1, n):
248                 mi = self._mlist[i]
249                 startindex = (n + i - 1) // i * i
250                 for j in range(startindex, b, i):
251                     self._mlist[j] -= mi
252                 if i >= a:
253                     yield mi
254 
255             for i in range(n, b):
256                 mi = self._mlist[i]
257                 for j in range(2 * i, b, i):
258                     self._mlist[j] -= mi
259                 if i >= a:
260                     yield mi
261 
262     def search(self, n):
263         """Return the indices i, j of the primes that bound n.
264 
265         If n is prime then i == j.
266 
267         Although n can be an expression, if ceiling cannot convert
268         it to an integer then an n error will be raised.
269 
270         Examples
271         ========
272 
273         >>> from sympy import sieve
274         >>> sieve.search(25)
275         (9, 10)
276         >>> sieve.search(23)
277         (9, 9)
278         """
279         from sympy.functions.elementary.integers import ceiling
280 
281         # wrapping ceiling in as_int will raise an error if there was a problem
282         # determining whether the expression was exactly an integer or not
283         test = as_int(ceiling(n))
284         n = as_int(n)
285         if n < 2:
286             raise ValueError("n should be >= 2 but got: %s" % n)
287         if n > self._list[-1]:
288             self.extend(n)
289         b = bisect(self._list, n)
290         if self._list[b - 1] == test:
291             return b, b
292         else:
293             return b, b + 1
294 
295     def __contains__(self, n):
296         try:
297             n = as_int(n)
298             assert n >= 2
299         except (ValueError, AssertionError):
300             return False
301         if n % 2 == 0:
302             return n == 2
303         a, b = self.search(n)
304         return a == b
305 
306     def __iter__(self):
307         for n in count(1):
308             yield self[n]
309 
310     def __getitem__(self, n):
311         """Return the nth prime number"""
312         if isinstance(n, slice):
313             self.extend_to_no(n.stop)
314             # Python 2.7 slices have 0 instead of None for start, so
315             # we can't default to 1.
316             start = n.start if n.start is not None else 0
317             if start < 1:
318                 # sieve[:5] would be empty (starting at -1), let's
319                 # just be explicit and raise.
320                 raise IndexError("Sieve indices start at 1.")
321             return self._list[start - 1:n.stop - 1:n.step]
322         else:
323             if n < 1:
324                 # offset is one, so forbid explicit access to sieve[0]
325                 # (would surprisingly return the last one).
326                 raise IndexError("Sieve indices start at 1.")
327             n = as_int(n)
328             self.extend_to_no(n)
329             return self._list[n - 1]
330 
331 # Generate a global object for repeated use in trial division etc
332 sieve = Sieve()
333 
334 
335 def prime(nth):
336     """ Return the nth prime, with the primes indexed as prime(1) = 2,
337         prime(2) = 3, etc.... The nth prime is approximately n*log(n).
338 
339         Logarithmic integral of x is a pretty nice approximation for number of
340         primes <= x, i.e.
341         li(x) ~ pi(x)
342         In fact, for the numbers we are concerned about( x<1e11 ),
343         li(x) - pi(x) < 50000
344 
345         Also,
346         li(x) > pi(x) can be safely assumed for the numbers which
347         can be evaluated by this function.
348 
349         Here, we find the least integer m such that li(m) > n using binary search.
350         Now pi(m-1) < li(m-1) <= n,
351 
352         We find pi(m - 1) using primepi function.
353 
354         Starting from m, we have to find n - pi(m-1) more primes.
355 
356         For the inputs this implementation can handle, we will have to test
357         primality for at max about 10**5 numbers, to get our answer.
358 
359         Examples
360         ========
361 
362         >>> from sympy import prime
363         >>> prime(10)
364         29
365         >>> prime(1)
366         2
367         >>> prime(100000)
368         1299709
369 
370         See Also
371         ========
372 
373         sympy.ntheory.primetest.isprime : Test if n is prime
374         primerange : Generate all primes in a given range
375         primepi : Return the number of primes less than or equal to n
376 
377         References
378         ==========
379 
380         .. [1] https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29
381         .. [2] https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number
382         .. [3] https://en.wikipedia.org/wiki/Skewes%27_number
383     """
384     n = as_int(nth)
385     if n < 1:
386         raise ValueError("nth must be a positive integer; prime(1) == 2")
387     if n <= len(sieve._list):
388         return sieve[n]
389 
390     from sympy.functions.special.error_functions import li
391     from sympy.functions.elementary.exponential import log
392 
393     a = 2 # Lower bound for binary search
394     b = int(n*(log(n) + log(log(n)))) # Upper bound for the search.
395 
396     while a < b:
397         mid = (a + b) >> 1
398         if li(mid) > n:
399             b = mid
400         else:
401             a = mid + 1
402     n_primes = primepi(a - 1)
403     while n_primes < n:
404         if isprime(a):
405             n_primes += 1
406         a += 1
407     return a - 1
408 
409 
410 class primepi(Function):
411     """ Represents the prime counting function pi(n) = the number
412         of prime numbers less than or equal to n.
413 
414         Algorithm Description:
415 
416         In sieve method, we remove all multiples of prime p
417         except p itself.
418 
419         Let phi(i,j) be the number of integers 2 <= k <= i
420         which remain after sieving from primes less than
421         or equal to j.
422         Clearly, pi(n) = phi(n, sqrt(n))
423 
424         If j is not a prime,
425         phi(i,j) = phi(i, j - 1)
426 
427         if j is a prime,
428         We remove all numbers(except j) whose
429         smallest prime factor is j.
430 
431         Let x= j*a be such a number, where 2 <= a<= i / j
432         Now, after sieving from primes <= j - 1,
433         a must remain
434         (because x, and hence a has no prime factor <= j - 1)
435         Clearly, there are phi(i / j, j - 1) such a
436         which remain on sieving from primes <= j - 1
437 
438         Now, if a is a prime less than equal to j - 1,
439         x= j*a has smallest prime factor = a, and
440         has already been removed(by sieving from a).
441         So, we don't need to remove it again.
442         (Note: there will be pi(j - 1) such x)
443 
444         Thus, number of x, that will be removed are:
445         phi(i / j, j - 1) - phi(j - 1, j - 1)
446         (Note that pi(j - 1) = phi(j - 1, j - 1))
447 
448         => phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j - 1)
449 
450         So,following recursion is used and implemented as dp:
451 
452         phi(a, b) = phi(a, b - 1), if b is not a prime
453         phi(a, b) = phi(a, b-1)-phi(a / b, b-1) + phi(b-1, b-1), if b is prime
454 
455         Clearly a is always of the form floor(n / k),
456         which can take at most 2*sqrt(n) values.
457         Two arrays arr1,arr2 are maintained
458         arr1[i] = phi(i, j),
459         arr2[i] = phi(n // i, j)
460 
461         Finally the answer is arr2[1]
462 
463         Examples
464         ========
465 
466         >>> from sympy import primepi
467         >>> primepi(25)
468         9
469 
470         See Also
471         ========
472 
473         sympy.ntheory.primetest.isprime : Test if n is prime
474         primerange : Generate all primes in a given range
475         prime : Return the nth prime
476     """
477     @classmethod
478     def eval(cls, n):
479         if n is S.Infinity:
480             return S.Infinity
481         if n is S.NegativeInfinity:
482             return S.Zero
483 
484         try:
485             n = int(n)
486         except TypeError:
487             if n.is_real == False or n is S.NaN:
488                 raise ValueError("n must be real")
489             return
490 
491         if n < 2:
492             return S.Zero
493         if n <= sieve._list[-1]:
494             return S(sieve.search(n)[0])
495         lim = int(n ** 0.5)
496         lim -= 1
497         lim = max(lim, 0)
498         while lim * lim <= n:
499             lim += 1
500         lim -= 1
501         arr1 = [0] * (lim + 1)
502         arr2 = [0] * (lim + 1)
503         for i in range(1, lim + 1):
504             arr1[i] = i - 1
505             arr2[i] = n // i - 1
506         for i in range(2, lim + 1):
507             # Presently, arr1[k]=phi(k,i - 1),
508             # arr2[k] = phi(n // k,i - 1)
509             if arr1[i] == arr1[i - 1]:
510                 continue
511             p = arr1[i - 1]
512             for j in range(1, min(n // (i * i), lim) + 1):
513                 st = i * j
514                 if st <= lim:
515                     arr2[j] -= arr2[st] - p
516                 else:
517                     arr2[j] -= arr1[n // st] - p
518             lim2 = min(lim, i * i - 1)
519             for j in range(lim, lim2, -1):
520                 arr1[j] -= arr1[j // i] - p
521         return S(arr2[1])
522 
523 
524 def nextprime(n, ith=1):
525     """ Return the ith prime greater than n.
526 
527         i must be an integer.
528 
529         Notes
530         =====
531 
532         Potential primes are located at 6*j +/- 1. This
533         property is used during searching.
534 
535         >>> from sympy import nextprime
536         >>> [(i, nextprime(i)) for i in range(10, 15)]
537         [(10, 11), (11, 13), (12, 13), (13, 17), (14, 17)]
538         >>> nextprime(2, ith=2) # the 2nd prime after 2
539         5
540 
541         See Also
542         ========
543 
544         prevprime : Return the largest prime smaller than n
545         primerange : Generate all primes in a given range
546 
547     """
548     n = int(n)
549     i = as_int(ith)
550     if i > 1:
551         pr = n
552         j = 1
553         while 1:
554             pr = nextprime(pr)
555             j += 1
556             if j > i:
557                 break
558         return pr
559 
560     if n < 2:
561         return 2
562     if n < 7:
563         return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]
564     if n <= sieve._list[-2]:
565         l, u = sieve.search(n)
566         if l == u:
567             return sieve[u + 1]
568         else:
569             return sieve[u]
570     nn = 6*(n//6)
571     if nn == n:
572         n += 1
573         if isprime(n):
574             return n
575         n += 4
576     elif n - nn == 5:
577         n += 2
578         if isprime(n):
579             return n
580         n += 4
581     else:
582         n = nn + 5
583     while 1:
584         if isprime(n):
585             return n
586         n += 2
587         if isprime(n):
588             return n
589         n += 4
590 
591 
592 def prevprime(n):
593     """ Return the largest prime smaller than n.
594 
595         Notes
596         =====
597 
598         Potential primes are located at 6*j +/- 1. This
599         property is used during searching.
600 
601         >>> from sympy import prevprime
602         >>> [(i, prevprime(i)) for i in range(10, 15)]
603         [(10, 7), (11, 7), (12, 11), (13, 11), (14, 13)]
604 
605         See Also
606         ========
607 
608         nextprime : Return the ith prime greater than n
609         primerange : Generates all primes in a given range
610     """
611     from sympy.functions.elementary.integers import ceiling
612 
613     # wrapping ceiling in as_int will raise an error if there was a problem
614     # determining whether the expression was exactly an integer or not
615     n = as_int(ceiling(n))
616     if n < 3:
617         raise ValueError("no preceding primes")
618     if n < 8:
619         return {3: 2, 4: 3, 5: 3, 6: 5, 7: 5}[n]
620     if n <= sieve._list[-1]:
621         l, u = sieve.search(n)
622         if l == u:
623             return sieve[l-1]
624         else:
625             return sieve[l]
626     nn = 6*(n//6)
627     if n - nn <= 1:
628         n = nn - 1
629         if isprime(n):
630             return n
631         n -= 4
632     else:
633         n = nn + 1
634     while 1:
635         if isprime(n):
636             return n
637         n -= 2
638         if isprime(n):
639             return n
640         n -= 4
641 
642 
643 def primerange(a, b):
644     """ Generate a list of all prime numbers in the range [a, b).
645 
646         If the range exists in the default sieve, the values will
647         be returned from there; otherwise values will be returned
648         but will not modify the sieve.
649 
650         Examples
651         ========
652 
653         >>> from sympy import primerange, sieve
654         >>> print([i for i in primerange(1, 30)])
655         [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
656 
657         The Sieve method, primerange, is generally faster but it will
658         occupy more memory as the sieve stores values. The default
659         instance of Sieve, named sieve, can be used:
660 
661         >>> list(sieve.primerange(1, 30))
662         [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
663 
664         Notes
665         =====
666 
667         Some famous conjectures about the occurrence of primes in a given
668         range are [1]:
669 
670         - Twin primes: though often not, the following will give 2 primes
671                     an infinite number of times:
672                         primerange(6*n - 1, 6*n + 2)
673         - Legendre's: the following always yields at least one prime
674                         primerange(n**2, (n+1)**2+1)
675         - Bertrand's (proven): there is always a prime in the range
676                         primerange(n, 2*n)
677         - Brocard's: there are at least four primes in the range
678                         primerange(prime(n)**2, prime(n+1)**2)
679 
680         The average gap between primes is log(n) [2]; the gap between
681         primes can be arbitrarily large since sequences of composite
682         numbers are arbitrarily large, e.g. the numbers in the sequence
683         n! + 2, n! + 3 ... n! + n are all composite.
684 
685         See Also
686         ========
687 
688         nextprime : Return the ith prime greater than n
689         prevprime : Return the largest prime smaller than n
690         randprime : Returns a random prime in a given range
691         primorial : Returns the product of primes based on condition
692         Sieve.primerange : return range from already computed primes
693                            or extend the sieve to contain the requested
694                            range.
695 
696         References
697         ==========
698 
699         .. [1] https://en.wikipedia.org/wiki/Prime_number
700         .. [2] http://primes.utm.edu/notes/gaps.html
701     """
702     from sympy.functions.elementary.integers import ceiling
703 
704     if a >= b:
705         return
706     # if we already have the range, return it
707     if b <= sieve._list[-1]:
708         for i in sieve.primerange(a, b):
709             yield i
710         return
711     # otherwise compute, without storing, the desired range.
712 
713     # wrapping ceiling in as_int will raise an error if there was a problem
714     # determining whether the expression was exactly an integer or not
715     a = as_int(ceiling(a)) - 1
716     b = as_int(ceiling(b))
717     while 1:
718         a = nextprime(a)
719         if a < b:
720             yield a
721         else:
722             return
723 
724 
725 def randprime(a, b):
726     """ Return a random prime number in the range [a, b).
727 
728         Bertrand's postulate assures that
729         randprime(a, 2*a) will always succeed for a > 1.
730 
731         Examples
732         ========
733 
734         >>> from sympy import randprime, isprime
735         >>> randprime(1, 30) #doctest: +SKIP
736         13
737         >>> isprime(randprime(1, 30))
738         True
739 
740         See Also
741         ========
742 
743         primerange : Generate all primes in a given range
744 
745         References
746         ==========
747 
748         .. [1] https://en.wikipedia.org/wiki/Bertrand's_postulate
749 
750     """
751     if a >= b:
752         return
753     a, b = map(int, (a, b))
754     n = random.randint(a - 1, b)
755     p = nextprime(n)
756     if p >= b:
757         p = prevprime(b)
758     if p < a:
759         raise ValueError("no primes exist in the specified range")
760     return p
761 
762 
763 def primorial(n, nth=True):
764     """
765     Returns the product of the first n primes (default) or
766     the primes less than or equal to n (when ``nth=False``).
767 
768     Examples
769     ========
770 
771     >>> from sympy.ntheory.generate import primorial, randprime, primerange
772     >>> from sympy import factorint, Mul, primefactors, sqrt
773     >>> primorial(4) # the first 4 primes are 2, 3, 5, 7
774     210
775     >>> primorial(4, nth=False) # primes <= 4 are 2 and 3
776     6
777     >>> primorial(1)
778     2
779     >>> primorial(1, nth=False)
780     1
781     >>> primorial(sqrt(101), nth=False)
782     210
783 
784     One can argue that the primes are infinite since if you take
785     a set of primes and multiply them together (e.g. the primorial) and
786     then add or subtract 1, the result cannot be divided by any of the
787     original factors, hence either 1 or more new primes must divide this
788     product of primes.
789 
790     In this case, the number itself is a new prime:
791 
792     >>> factorint(primorial(4) + 1)
793     {211: 1}
794 
795     In this case two new primes are the factors:
796 
797     >>> factorint(primorial(4) - 1)
798     {11: 1, 19: 1}
799 
800     Here, some primes smaller and larger than the primes multiplied together
801     are obtained:
802 
803     >>> p = list(primerange(10, 20))
804     >>> sorted(set(primefactors(Mul(*p) + 1)).difference(set(p)))
805     [2, 5, 31, 149]
806 
807     See Also
808     ========
809 
810     primerange : Generate all primes in a given range
811 
812     """
813     if nth:
814         n = as_int(n)
815     else:
816         n = int(n)
817     if n < 1:
818         raise ValueError("primorial argument must be >= 1")
819     p = 1
820     if nth:
821         for i in range(1, n + 1):
822             p *= prime(i)
823     else:
824         for i in primerange(2, n + 1):
825             p *= i
826     return p
827 
828 
829 def cycle_length(f, x0, nmax=None, values=False):
830     """For a given iterated sequence, return a generator that gives
831     the length of the iterated cycle (lambda) and the length of terms
832     before the cycle begins (mu); if ``values`` is True then the
833     terms of the sequence will be returned instead. The sequence is
834     started with value ``x0``.
835 
836     Note: more than the first lambda + mu terms may be returned and this
837     is the cost of cycle detection with Brent's method; there are, however,
838     generally less terms calculated than would have been calculated if the
839     proper ending point were determined, e.g. by using Floyd's method.
840 
841     >>> from sympy.ntheory.generate import cycle_length
842 
843     This will yield successive values of i <-- func(i):
844 
845         >>> def iter(func, i):
846         ...     while 1:
847         ...         ii = func(i)
848         ...         yield ii
849         ...         i = ii
850         ...
851 
852     A function is defined:
853 
854         >>> func = lambda i: (i**2 + 1) % 51
855 
856     and given a seed of 4 and the mu and lambda terms calculated:
857 
858         >>> next(cycle_length(func, 4))
859         (6, 2)
860 
861     We can see what is meant by looking at the output:
862 
863         >>> n = cycle_length(func, 4, values=True)
864         >>> list(ni for ni in n)
865         [17, 35, 2, 5, 26, 14, 44, 50, 2, 5, 26, 14]
866 
867     There are 6 repeating values after the first 2.
868 
869     If a sequence is suspected of being longer than you might wish, ``nmax``
870     can be used to exit early (and mu will be returned as None):
871 
872         >>> next(cycle_length(func, 4, nmax = 4))
873         (4, None)
874         >>> [ni for ni in cycle_length(func, 4, nmax = 4, values=True)]
875         [17, 35, 2, 5]
876 
877     Code modified from:
878         https://en.wikipedia.org/wiki/Cycle_detection.
879     """
880 
881     nmax = int(nmax or 0)
882 
883     # main phase: search successive powers of two
884     power = lam = 1
885     tortoise, hare = x0, f(x0)  # f(x0) is the element/node next to x0.
886     i = 0
887     while tortoise != hare and (not nmax or i < nmax):
888         i += 1
889         if power == lam:   # time to start a new power of two?
890             tortoise = hare
891             power *= 2
892             lam = 0
893         if values:
894             yield hare
895         hare = f(hare)
896         lam += 1
897     if nmax and i == nmax:
898         if values:
899             return
900         else:
901             yield nmax, None
902             return
903     if not values:
904         # Find the position of the first repetition of length lambda
905         mu = 0
906         tortoise = hare = x0
907         for i in range(lam):
908             hare = f(hare)
909         while tortoise != hare:
910             tortoise = f(tortoise)
911             hare = f(hare)
912             mu += 1
913         if mu:
914             mu -= 1
915         yield lam, mu
916 
917 
918 def composite(nth):
919     """ Return the nth composite number, with the composite numbers indexed as
920         composite(1) = 4, composite(2) = 6, etc....
921 
922         Examples
923         ========
924 
925         >>> from sympy import composite
926         >>> composite(36)
927         52
928         >>> composite(1)
929         4
930         >>> composite(17737)
931         20000
932 
933         See Also
934         ========
935 
936         sympy.ntheory.primetest.isprime : Test if n is prime
937         primerange : Generate all primes in a given range
938         primepi : Return the number of primes less than or equal to n
939         prime : Return the nth prime
940         compositepi : Return the number of positive composite numbers less than or equal to n
941     """
942     n = as_int(nth)
943     if n < 1:
944         raise ValueError("nth must be a positive integer; composite(1) == 4")
945     composite_arr = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18]
946     if n <= 10:
947         return composite_arr[n - 1]
948 
949     a, b = 4, sieve._list[-1]
950     if n <= b - primepi(b) - 1:
951         while a < b - 1:
952             mid = (a + b) >> 1
953             if mid - primepi(mid) - 1 > n:
954                 b = mid
955             else:
956                 a = mid
957         if isprime(a):
958             a -= 1
959         return a
960 
961     from sympy.functions.special.error_functions import li
962     from sympy.functions.elementary.exponential import log
963 
964     a = 4 # Lower bound for binary search
965     b = int(n*(log(n) + log(log(n)))) # Upper bound for the search.
966 
967     while a < b:
968         mid = (a + b) >> 1
969         if mid - li(mid) - 1 > n:
970             b = mid
971         else:
972             a = mid + 1
973 
974     n_composites = a - primepi(a) - 1
975     while n_composites > n:
976         if not isprime(a):
977             n_composites -= 1
978         a -= 1
979     if isprime(a):
980         a -= 1
981     return a
982 
983 
984 def compositepi(n):
985     """ Return the number of positive composite numbers less than or equal to n.
986         The first positive composite is 4, i.e. compositepi(4) = 1.
987 
988         Examples
989         ========
990 
991         >>> from sympy import compositepi
992         >>> compositepi(25)
993         15
994         >>> compositepi(1000)
995         831
996 
997         See Also
998         ========
999 
1000         sympy.ntheory.primetest.isprime : Test if n is prime
1001         primerange : Generate all primes in a given range
1002         prime : Return the nth prime
1003         primepi : Return the number of primes less than or equal to n
1004         composite : Return the nth composite number
1005     """
1006     n = int(n)
1007     if n < 4:
1008         return 0
1009     return n - primepi(n) - 1

</code><intended_behavior>This method calculates the Schur number S(k) for a given integer k, which is the largest number n such that the interval [1,n] can be partitioned into k sum-free sets.</intended_behavior>]
2025-10-15 14:35:59.021 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 14:35:59.021 | INFO     | Search-only: skipping patch selection
2025-10-15 14:35:59.107 | INFO     | Task sympy__sympy-18667 completed successfully.
2025-10-15 14:35:59.108 | INFO     | No patch generated. You can try running ACR again.
