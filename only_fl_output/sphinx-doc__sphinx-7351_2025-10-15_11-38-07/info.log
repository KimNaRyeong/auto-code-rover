2025-10-15 11:38:07.239 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 11:38:11.860 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=382, output_tokens=12, cost=0.004180
2025-10-15 11:38:29.658 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=562, output_tokens=651, cost=0.025150
2025-10-15 11:38:47.102 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=562, output_tokens=817, cost=0.030130
2025-10-15 11:38:48.099 | INFO     | registered non reproducing test 1
2025-10-15 11:39:08.809 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1922, output_tokens=815, cost=0.043670
2025-10-15 11:39:09.815 | INFO     | registered non reproducing test 2
2025-10-15 11:39:09.815 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 11:39:09.821 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:39:20.568 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=461, cost=0.020670
2025-10-15 11:39:20.576 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:39:24.070 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=815, output_tokens=74, cost=0.010370
2025-10-15 11:39:24.072 | DEBUG    | Extracted a valid json.
2025-10-15 11:39:24.072 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\".. toctree::\")",
        "search_class(\"MySTParser\")",
        "search_code(\"config\")",
        "search_code(\"file extension preference\")",
        "search_method(\"build_process\")",
        "search_method(\"select_file\")"
    ],
    "bug_locations": []
}
2025-10-15 11:39:24.679 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 11:39:24.680 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 11:39:41.050 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3076, output_tokens=653, cost=0.050350
2025-10-15 11:39:41.057 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:39:52.523 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3945, output_tokens=488, cost=0.054090
2025-10-15 11:39:52.527 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:40:00.428 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=842, output_tokens=294, cost=0.017240
2025-10-15 11:40:00.429 | DEBUG    | Extracted a valid json.
2025-10-15 11:40:00.429 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/environment/adapters/toctree.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file and its methods, particularly those processing the toctree entries, should include logic to handle file priorities based on their extensions when multiple files with the same name exist. An ideal enhancement would be a configuration option allowing users to specify the order of preference for file extensions. In the absence of such a specification, the system should log a warning when deciding which file to include, promoting transparency in the file selection process."
        },
        {
            "file": "sphinx/config.py",
            "class": "Config",
            "method": "",
            "intended_behavior": "Enhance the Config class to support new configuration options that allow specifying the order of preference for file extensions. This would directly address the user's need to influence Sphinx’s behavior regarding file selection when similar filenames exist with different extensions."
        },
        {
            "file": "sphinx/registry.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the method responsible for registering new parsers, such as .md parsers, correctly respects the file extension preferences specified in the configuration. This might involve adjusting how Sphinx prioritizes file extensions when multiple parsers are capable of processing a given file."
        }
    ]
}
2025-10-15 11:40:00.435 | DEBUG    | Bug location extracted successfully: [<file>sphinx/environment/adapters/toctree.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.adapters.toctree
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Toctree adapter for sphinx.environment.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Iterable, List
12 from typing import cast
13 
14 from docutils import nodes
15 from docutils.nodes import Element, Node
16 
17 from sphinx import addnodes
18 from sphinx.locale import __
19 from sphinx.util import url_re, logging
20 from sphinx.util.matching import Matcher
21 from sphinx.util.nodes import clean_astext, process_only_nodes
22 
23 if False:
24     # For type annotation
25     from sphinx.builders import Builder
26     from sphinx.environment import BuildEnvironment
27 
28 
29 logger = logging.getLogger(__name__)
30 
31 
32 class TocTree:
33     def __init__(self, env: "BuildEnvironment") -> None:
34         self.env = env
35 
36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:
37         """Note a TOC tree directive in a document and gather information about
38         file relations from it.
39         """
40         if toctreenode['glob']:
41             self.env.glob_toctrees.add(docname)
42         if toctreenode.get('numbered'):
43             self.env.numbered_toctrees.add(docname)
44         includefiles = toctreenode['includefiles']
45         for includefile in includefiles:
46             # note that if the included file is rebuilt, this one must be
47             # too (since the TOC of the included file could have changed)
48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)
49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)
50 
51     def resolve(self, docname: str, builder: "Builder", toctree: addnodes.toctree,
52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,
53                 collapse: bool = False, includehidden: bool = False) -> Element:
54         """Resolve a *toctree* node into individual bullet lists with titles
55         as items, returning None (if no containing titles are found) or
56         a new node.
57 
58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,
59         to the value of the *maxdepth* option on the *toctree* node.
60         If *titles_only* is True, only toplevel document titles will be in the
61         resulting tree.
62         If *collapse* is True, all branches not containing docname will
63         be collapsed.
64         """
65         if toctree.get('hidden', False) and not includehidden:
66             return None
67 
68         # For reading the following two helper function, it is useful to keep
69         # in mind the node structure of a toctree (using HTML-like node names
70         # for brevity):
71         #
72         # <ul>
73         #   <li>
74         #     <p><a></p>
75         #     <p><a></p>
76         #     ...
77         #     <ul>
78         #       ...
79         #     </ul>
80         #   </li>
81         # </ul>
82         #
83         # The transformation is made in two passes in order to avoid
84         # interactions between marking and pruning the tree (see bug #1046).
85 
86         toctree_ancestors = self.get_toctree_ancestors(docname)
87         excluded = Matcher(self.env.config.exclude_patterns)
88 
89         def _toctree_add_classes(node: Element, depth: int) -> None:
90             """Add 'toctree-l%d' and 'current' classes to the toctree."""
91             for subnode in node.children:
92                 if isinstance(subnode, (addnodes.compact_paragraph,
93                                         nodes.list_item)):
94                     # for <p> and <li>, indicate the depth level and recurse
95                     subnode['classes'].append('toctree-l%d' % (depth - 1))
96                     _toctree_add_classes(subnode, depth)
97                 elif isinstance(subnode, nodes.bullet_list):
98                     # for <ul>, just recurse
99                     _toctree_add_classes(subnode, depth + 1)
100                 elif isinstance(subnode, nodes.reference):
101                     # for <a>, identify which entries point to the current
102                     # document and therefore may not be collapsed
103                     if subnode['refuri'] == docname:
104                         if not subnode['anchorname']:
105                             # give the whole branch a 'current' class
106                             # (useful for styling it differently)
107                             branchnode = subnode  # type: Element
108                             while branchnode:
109                                 branchnode['classes'].append('current')
110                                 branchnode = branchnode.parent
111                         # mark the list_item as "on current page"
112                         if subnode.parent.parent.get('iscurrent'):
113                             # but only if it's not already done
114                             return
115                         while subnode:
116                             subnode['iscurrent'] = True
117                             subnode = subnode.parent
118 
119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],
120                                   separate: bool = False, subtree: bool = False
121                                   ) -> List[Element]:
122             """Return TOC entries for a toctree node."""
123             refs = [(e[0], e[1]) for e in toctreenode['entries']]
124             entries = []  # type: List[Element]
125             for (title, ref) in refs:
126                 try:
127                     refdoc = None
128                     if url_re.match(ref):
129                         if title is None:
130                             title = ref
131                         reference = nodes.reference('', '', internal=False,
132                                                     refuri=ref, anchorname='',
133                                                     *[nodes.Text(title)])
134                         para = addnodes.compact_paragraph('', '', reference)
135                         item = nodes.list_item('', para)
136                         toc = nodes.bullet_list('', item)
137                     elif ref == 'self':
138                         # 'self' refers to the document from which this
139                         # toctree originates
140                         ref = toctreenode['parent']
141                         if not title:
142                             title = clean_astext(self.env.titles[ref])
143                         reference = nodes.reference('', '', internal=True,
144                                                     refuri=ref,
145                                                     anchorname='',
146                                                     *[nodes.Text(title)])
147                         para = addnodes.compact_paragraph('', '', reference)
148                         item = nodes.list_item('', para)
149                         # don't show subitems
150                         toc = nodes.bullet_list('', item)
151                     else:
152                         if ref in parents:
153                             logger.warning(__('circular toctree references '
154                                               'detected, ignoring: %s <- %s'),
155                                            ref, ' <- '.join(parents),
156                                            location=ref)
157                             continue
158                         refdoc = ref
159                         toc = self.env.tocs[ref].deepcopy()
160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)
161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):
162                             self._toctree_prune(toc, 2, maxdepth, collapse)
163                         process_only_nodes(toc, builder.tags)
164                         if title and toc.children and len(toc.children) == 1:
165                             child = toc.children[0]
166                             for refnode in child.traverse(nodes.reference):
167                                 if refnode['refuri'] == ref and \
168                                    not refnode['anchorname']:
169                                     refnode.children = [nodes.Text(title)]
170                     if not toc.children:
171                         # empty toc means: no titles will show up in the toctree
172                         logger.warning(__('toctree contains reference to document %r that '
173                                           'doesn\'t have a title: no link will be generated'),
174                                        ref, location=toctreenode)
175                 except KeyError:
176                     # this is raised if the included file does not exist
177                     if excluded(self.env.doc2path(ref, None)):
178                         message = __('toctree contains reference to excluded document %r')
179                     else:
180                         message = __('toctree contains reference to nonexisting document %r')
181 
182                     logger.warning(message, ref, location=toctreenode)
183                 else:
184                     # if titles_only is given, only keep the main title and
185                     # sub-toctrees
186                     if titles_only:
187                         # children of toc are:
188                         # - list_item + compact_paragraph + (reference and subtoc)
189                         # - only + subtoc
190                         # - toctree
191                         children = cast(Iterable[nodes.Element], toc)
192 
193                         # delete everything but the toplevel title(s)
194                         # and toctrees
195                         for toplevel in children:
196                             # nodes with length 1 don't have any children anyway
197                             if len(toplevel) > 1:
198                                 subtrees = toplevel.traverse(addnodes.toctree)
199                                 if subtrees:
200                                     toplevel[1][:] = subtrees  # type: ignore
201                                 else:
202                                     toplevel.pop(1)
203                     # resolve all sub-toctrees
204                     for subtocnode in toc.traverse(addnodes.toctree):
205                         if not (subtocnode.get('hidden', False) and
206                                 not includehidden):
207                             i = subtocnode.parent.index(subtocnode) + 1
208                             for entry in _entries_from_toctree(
209                                     subtocnode, [refdoc] + parents,
210                                     subtree=True):
211                                 subtocnode.parent.insert(i, entry)
212                                 i += 1
213                             subtocnode.parent.remove(subtocnode)
214                     if separate:
215                         entries.append(toc)
216                     else:
217                         children = cast(Iterable[nodes.Element], toc)
218                         entries.extend(children)
219             if not subtree and not separate:
220                 ret = nodes.bullet_list()
221                 ret += entries
222                 return [ret]
223             return entries
224 
225         maxdepth = maxdepth or toctree.get('maxdepth', -1)
226         if not titles_only and toctree.get('titlesonly', False):
227             titles_only = True
228         if not includehidden and toctree.get('includehidden', False):
229             includehidden = True
230 
231         # NOTE: previously, this was separate=True, but that leads to artificial
232         # separation when two or more toctree entries form a logical unit, so
233         # separating mode is no longer used -- it's kept here for history's sake
234         tocentries = _entries_from_toctree(toctree, [], separate=False)
235         if not tocentries:
236             return None
237 
238         newnode = addnodes.compact_paragraph('', '')
239         caption = toctree.attributes.get('caption')
240         if caption:
241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])
242             caption_node.line = toctree.line
243             caption_node.source = toctree.source
244             caption_node.rawsource = toctree['rawcaption']
245             if hasattr(toctree, 'uid'):
246                 # move uid to caption_node to translate it
247                 caption_node.uid = toctree.uid  # type: ignore
248                 del toctree.uid  # type: ignore
249             newnode += caption_node
250         newnode.extend(tocentries)
251         newnode['toctree'] = True
252 
253         # prune the tree to maxdepth, also set toc depth and current classes
254         _toctree_add_classes(newnode, 1)
255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)
256 
257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found
258             return None
259 
260         # set the target paths in the toctrees (they are not known at TOC
261         # generation time)
262         for refnode in newnode.traverse(nodes.reference):
263             if not url_re.match(refnode['refuri']):
264                 refnode['refuri'] = builder.get_relative_uri(
265                     docname, refnode['refuri']) + refnode['anchorname']
266         return newnode
267 
268     def get_toctree_ancestors(self, docname: str) -> List[str]:
269         parent = {}
270         for p, children in self.env.toctree_includes.items():
271             for child in children:
272                 parent[child] = p
273         ancestors = []  # type: List[str]
274         d = docname
275         while d in parent and d not in ancestors:
276             ancestors.append(d)
277             d = parent[d]
278         return ancestors
279 
280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False
281                        ) -> None:
282         """Utility: Cut a TOC at a specified depth."""
283         for subnode in node.children[:]:
284             if isinstance(subnode, (addnodes.compact_paragraph,
285                                     nodes.list_item)):
286                 # for <p> and <li>, just recurse
287                 self._toctree_prune(subnode, depth, maxdepth, collapse)
288             elif isinstance(subnode, nodes.bullet_list):
289                 # for <ul>, determine if the depth is too large or if the
290                 # entry is to be collapsed
291                 if maxdepth > 0 and depth > maxdepth:
292                     subnode.parent.replace(subnode, [])
293                 else:
294                     # cull sub-entries whose parents aren't 'current'
295                     if (collapse and depth > 1 and
296                             'iscurrent' not in subnode.parent):
297                         subnode.parent.remove(subnode)
298                     else:
299                         # recurse on visible children
300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)
301 
302     def get_toc_for(self, docname: str, builder: "Builder") -> Node:
303         """Return a TOC nodetree -- for use on the same page only!"""
304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)
305         try:
306             toc = self.env.tocs[docname].deepcopy()
307             self._toctree_prune(toc, 2, tocdepth)
308         except KeyError:
309             # the document does not exist anymore: return a dummy node that
310             # renders to nothing
311             return nodes.paragraph()
312         process_only_nodes(toc, builder.tags)
313         for node in toc.traverse(nodes.reference):
314             node['refuri'] = node['anchorname'] or '#'
315         return toc
316 
317     def get_toctree_for(self, docname: str, builder: "Builder", collapse: bool,
318                         **kwargs: Any) -> Element:
319         """Return the global TOC nodetree."""
320         doctree = self.env.get_doctree(self.env.config.master_doc)
321         toctrees = []  # type: List[Element]
322         if 'includehidden' not in kwargs:
323             kwargs['includehidden'] = True
324         if 'maxdepth' not in kwargs:
325             kwargs['maxdepth'] = 0
326         kwargs['collapse'] = collapse
327         for toctreenode in doctree.traverse(addnodes.toctree):
328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)
329             if toctree:
330                 toctrees.append(toctree)
331         if not toctrees:
332             return None
333         result = toctrees[0]
334         for toctree in toctrees[1:]:
335             result.extend(toctree.children)
336         return result

</code><intended_behavior>This file and its methods, particularly those processing the toctree entries, should include logic to handle file priorities based on their extensions when multiple files with the same name exist. An ideal enhancement would be a configuration option allowing users to specify the order of preference for file extensions. In the absence of such a specification, the system should log a warning when deciding which file to include, promoting transparency in the file selection process.</intended_behavior>, <file>sphinx/config.py</file>
<class>Config</class>
<method>None</method>
<code>
81 class Config:
82     """Configuration file abstraction.
83 
84     The config object makes the values of all config values available as
85     attributes.
86 
87     It is exposed via the :py:attr:`sphinx.application.Application.config` and
88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
89     to get the value of :confval:`language`, use either ``app.config.language``
90     or ``env.config.language``.
91     """
92 
93     # the values are: (default, what needs to be rebuilt if changed)
94 
95     # If you add a value here, don't forget to include it in the
96     # quickstart.py file template as well as in the docs!
97 
98     config_values = {
99         # general options
100         'project': ('Python', 'env', []),
101         'author': ('unknown', 'env', []),
102         'copyright': ('', 'html', []),
103         'version': ('', 'env', []),
104         'release': ('', 'env', []),
105         'today': ('', 'env', []),
106         # the real default is locale-dependent
107         'today_fmt': (None, 'env', [str]),
108 
109         'language': (None, 'env', [str]),
110         'locale_dirs': (['locales'], 'env', []),
111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
112 
113         'master_doc': ('index', 'env', []),
114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
115         'source_encoding': ('utf-8-sig', 'env', []),
116         'source_parsers': ({}, 'env', []),
117         'exclude_patterns': ([], 'env', []),
118         'default_role': (None, 'env', [str]),
119         'add_function_parentheses': (True, 'env', []),
120         'add_module_names': (True, 'env', []),
121         'trim_footnote_reference_space': (False, 'env', []),
122         'show_authors': (False, 'env', []),
123         'pygments_style': (None, 'html', [str]),
124         'highlight_language': ('default', 'env', []),
125         'highlight_options': ({}, 'env', []),
126         'templates_path': ([], 'html', []),
127         'template_bridge': (None, 'html', [str]),
128         'keep_warnings': (False, 'env', []),
129         'suppress_warnings': ([], 'env', []),
130         'modindex_common_prefix': ([], 'html', []),
131         'rst_epilog': (None, 'env', [str]),
132         'rst_prolog': (None, 'env', [str]),
133         'trim_doctest_flags': (True, 'env', []),
134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore
135         'needs_sphinx': (None, None, [str]),
136         'needs_extensions': ({}, None, []),
137         'manpages_url': (None, 'env', []),
138         'nitpicky': (False, None, []),
139         'nitpick_ignore': ([], None, []),
140         'numfig': (False, 'env', []),
141         'numfig_secnum_depth': (1, 'env', []),
142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
143 
144         'math_number_all': (False, 'env', []),
145         'math_eqref_format': (None, 'env', [str]),
146         'math_numfig': (True, 'env', []),
147         'tls_verify': (True, 'env', []),
148         'tls_cacerts': (None, 'env', []),
149         'user_agent': (None, 'env', [str]),
150         'smartquotes': (True, 'env', []),
151         'smartquotes_action': ('qDe', 'env', []),
152         'smartquotes_excludes': ({'languages': ['ja'],
153                                   'builders': ['man', 'text']},
154                                  'env', []),
155     }  # type: Dict[str, Tuple]
156 
157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
158         self.overrides = dict(overrides)
159         self.values = Config.config_values.copy()
160         self._raw_config = config
161         self.setup = config.get('setup', None)  # type: Callable
162 
163         if 'extensions' in self.overrides:
164             if isinstance(self.overrides['extensions'], str):
165                 config['extensions'] = self.overrides.pop('extensions').split(',')
166             else:
167                 config['extensions'] = self.overrides.pop('extensions')
168         self.extensions = config.get('extensions', [])  # type: List[str]
169 
170     @classmethod
171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         namespace = eval_config_file(filename, tags)
175         return cls(namespace, overrides or {})
176 
177     def convert_overrides(self, name: str, value: Any) -> Any:
178         if not isinstance(value, str):
179             return value
180         else:
181             defvalue = self.values[name][0]
182             if self.values[name][2] == Any:
183                 return value
184             elif type(defvalue) is bool or self.values[name][2] == [bool]:
185                 if value == '0':
186                     # given falsy string from command line option
187                     return False
188                 else:
189                     return bool(value)
190             elif isinstance(defvalue, dict):
191                 raise ValueError(__('cannot override dictionary config setting %r, '
192                                     'ignoring (use %r to set individual elements)') %
193                                  (name, name + '.key=value'))
194             elif isinstance(defvalue, list):
195                 return value.split(',')
196             elif isinstance(defvalue, int):
197                 try:
198                     return int(value)
199                 except ValueError:
200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
201                                      (value, name))
202             elif hasattr(defvalue, '__call__'):
203                 return value
204             elif defvalue is not None and not isinstance(defvalue, str):
205                 raise ValueError(__('cannot override config setting %r with unsupported '
206                                     'type, ignoring') % name)
207             else:
208                 return value
209 
210     def pre_init_values(self) -> None:
211         """
212         Initialize some limited config variables before initialize i18n and loading extensions
213         """
214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
215         for name in variables:
216             try:
217                 if name in self.overrides:
218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
219                 elif name in self._raw_config:
220                     self.__dict__[name] = self._raw_config[name]
221             except ValueError as exc:
222                 logger.warning("%s", exc)
223 
224     def init_values(self) -> None:
225         config = self._raw_config
226         for valname, value in self.overrides.items():
227             try:
228                 if '.' in valname:
229                     realvalname, key = valname.split('.', 1)
230                     config.setdefault(realvalname, {})[key] = value
231                     continue
232                 elif valname not in self.values:
233                     logger.warning(__('unknown config value %r in override, ignoring'),
234                                    valname)
235                     continue
236                 if isinstance(value, str):
237                     config[valname] = self.convert_overrides(valname, value)
238                 else:
239                     config[valname] = value
240             except ValueError as exc:
241                 logger.warning("%s", exc)
242         for name in config:
243             if name in self.values:
244                 self.__dict__[name] = config[name]
245 
246     def __getattr__(self, name: str) -> Any:
247         if name.startswith('_'):
248             raise AttributeError(name)
249         if name not in self.values:
250             raise AttributeError(__('No such config value: %s') % name)
251         default = self.values[name][0]
252         if hasattr(default, '__call__'):
253             return default(self)
254         return default
255 
256     def __getitem__(self, name: str) -> str:
257         return getattr(self, name)
258 
259     def __setitem__(self, name: str, value: Any) -> None:
260         setattr(self, name, value)
261 
262     def __delitem__(self, name: str) -> None:
263         delattr(self, name)
264 
265     def __contains__(self, name: str) -> bool:
266         return name in self.values
267 
268     def __iter__(self) -> Generator[ConfigValue, None, None]:
269         for name, value in self.values.items():
270             yield ConfigValue(name, getattr(self, name), value[1])
271 
272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
273         if name in self.values:
274             raise ExtensionError(__('Config value %r already present') % name)
275         else:
276             self.values[name] = (default, rebuild, types)
277 
278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
279         if isinstance(rebuild, str):
280             rebuild = [rebuild]
281         return (value for value in self if value.rebuild in rebuild)
282 
283     def __getstate__(self) -> Dict:
284         """Obtains serializable data for pickling."""
285         # remove potentially pickling-problematic values from config
286         __dict__ = {}
287         for key, value in self.__dict__.items():
288             if key.startswith('_') or not is_serializable(value):
289                 pass
290             else:
291                 __dict__[key] = value
292 
293         # create a picklable copy of values list
294         __dict__['values'] = {}
295         for key, value in self.values.items():
296             real_value = getattr(self, key)
297             if not is_serializable(real_value):
298                 # omit unserializable value
299                 real_value = None
300 
301             # types column is also omitted
302             __dict__['values'][key] = (real_value, value[1], None)
303 
304         return __dict__
305 
306     def __setstate__(self, state: Dict) -> None:
307         self.__dict__.update(state)

</code><intended_behavior>Enhance the Config class to support new configuration options that allow specifying the order of preference for file extensions. This would directly address the user's need to influence Sphinx’s behavior regarding file selection when similar filenames exist with different extensions.</intended_behavior>, <file>sphinx/registry.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.registry
3     ~~~~~~~~~~~~~~~
4 
5     Sphinx component registry.
6 
7     :copyright: Copyright 2007-2016 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import traceback
12 from importlib import import_module
13 from types import MethodType
14 from typing import Any, Callable, Dict, Iterator, List, Tuple, Union
15 
16 from docutils import nodes
17 from docutils.io import Input
18 from docutils.nodes import Element, Node, TextElement
19 from docutils.parsers import Parser
20 from docutils.parsers.rst import Directive
21 from docutils.transforms import Transform
22 from pkg_resources import iter_entry_points
23 
24 from sphinx.builders import Builder
25 from sphinx.config import Config
26 from sphinx.domains import Domain, Index, ObjType
27 from sphinx.domains.std import GenericObject, Target
28 from sphinx.environment import BuildEnvironment
29 from sphinx.errors import ExtensionError, SphinxError, VersionRequirementError
30 from sphinx.extension import Extension
31 from sphinx.locale import __
32 from sphinx.parsers import Parser as SphinxParser
33 from sphinx.roles import XRefRole
34 from sphinx.util import logging
35 from sphinx.util.logging import prefixed_warnings
36 from sphinx.util.typing import RoleFunction, TitleGetter
37 
38 if False:
39     # For type annotation
40     from typing import Type  # for python3.5.1
41     from sphinx.application import Sphinx
42     from sphinx.ext.autodoc import Documenter
43 
44 logger = logging.getLogger(__name__)
45 
46 # list of deprecated extensions. Keys are extension name.
47 # Values are Sphinx version that merge the extension.
48 EXTENSION_BLACKLIST = {
49     "sphinxjp.themecore": "1.2"
50 }
51 
52 
53 class SphinxComponentRegistry:
54     def __init__(self) -> None:
55         #: special attrgetter for autodoc; class object -> attrgetter
56         self.autodoc_attrgettrs = {}    # type: Dict[Type, Callable[[Any, str, Any], Any]]
57 
58         #: builders; a dict of builder name -> bulider class
59         self.builders = {}              # type: Dict[str, Type[Builder]]
60 
61         #: autodoc documenters; a dict of documenter name -> documenter class
62         self.documenters = {}           # type: Dict[str, Type[Documenter]]
63 
64         #: css_files; a list of tuple of filename and attributes
65         self.css_files = []             # type: List[Tuple[str, Dict[str, str]]]
66 
67         #: domains; a dict of domain name -> domain class
68         self.domains = {}               # type: Dict[str, Type[Domain]]
69 
70         #: additional directives for domains
71         #: a dict of domain name -> dict of directive name -> directive
72         self.domain_directives = {}     # type: Dict[str, Dict[str, Any]]
73 
74         #: additional indices for domains
75         #: a dict of domain name -> list of index class
76         self.domain_indices = {}        # type: Dict[str, List[Type[Index]]]
77 
78         #: additional object types for domains
79         #: a dict of domain name -> dict of objtype name -> objtype
80         self.domain_object_types = {}   # type: Dict[str, Dict[str, ObjType]]
81 
82         #: additional roles for domains
83         #: a dict of domain name -> dict of role name -> role impl.
84         self.domain_roles = {}          # type: Dict[str, Dict[str, Union[RoleFunction, XRefRole]]]  # NOQA
85 
86         #: additional enumerable nodes
87         #: a dict of node class -> tuple of figtype and title_getter function
88         self.enumerable_nodes = {}      # type: Dict[Type[Node], Tuple[str, TitleGetter]]
89 
90         #: HTML inline and block math renderers
91         #: a dict of name -> tuple of visit function and depart function
92         self.html_inline_math_renderers = {}    # type: Dict[str, Tuple[Callable, Callable]]
93         self.html_block_math_renderers = {}     # type: Dict[str, Tuple[Callable, Callable]]
94 
95         #: js_files; list of JS paths or URLs
96         self.js_files = []              # type: List[Tuple[str, Dict[str, str]]]
97 
98         #: LaTeX packages; list of package names and its options
99         self.latex_packages = []        # type: List[Tuple[str, str]]
100 
101         #: post transforms; list of transforms
102         self.post_transforms = []       # type: List[Type[Transform]]
103 
104         #: source paresrs; file type -> parser class
105         self.source_parsers = {}        # type: Dict[str, Type[Parser]]
106 
107         #: source inputs; file type -> input class
108         self.source_inputs = {}         # type: Dict[str, Type[Input]]
109 
110         #: source suffix: suffix -> file type
111         self.source_suffix = {}         # type: Dict[str, str]
112 
113         #: custom translators; builder name -> translator class
114         self.translators = {}           # type: Dict[str, Type[nodes.NodeVisitor]]
115 
116         #: custom handlers for translators
117         #: a dict of builder name -> dict of node name -> visitor and departure functions
118         self.translation_handlers = {}  # type: Dict[str, Dict[str, Tuple[Callable, Callable]]]
119 
120         #: additional transforms; list of transforms
121         self.transforms = []            # type: List[Type[Transform]]
122 
123     def add_builder(self, builder: "Type[Builder]", override: bool = False) -> None:
124         logger.debug('[app] adding builder: %r', builder)
125         if not hasattr(builder, 'name'):
126             raise ExtensionError(__('Builder class %s has no "name" attribute') % builder)
127         if builder.name in self.builders and not override:
128             raise ExtensionError(__('Builder %r already exists (in module %s)') %
129                                  (builder.name, self.builders[builder.name].__module__))
130         self.builders[builder.name] = builder
131 
132     def preload_builder(self, app: "Sphinx", name: str) -> None:
133         if name is None:
134             return
135 
136         if name not in self.builders:
137             entry_points = iter_entry_points('sphinx.builders', name)
138             try:
139                 entry_point = next(entry_points)
140             except StopIteration:
141                 raise SphinxError(__('Builder name %s not registered or available'
142                                      ' through entry point') % name)
143 
144             self.load_extension(app, entry_point.module_name)
145 
146     def create_builder(self, app: "Sphinx", name: str) -> Builder:
147         if name not in self.builders:
148             raise SphinxError(__('Builder name %s not registered') % name)
149 
150         return self.builders[name](app)
151 
152     def add_domain(self, domain: "Type[Domain]", override: bool = False) -> None:
153         logger.debug('[app] adding domain: %r', domain)
154         if domain.name in self.domains and not override:
155             raise ExtensionError(__('domain %s already registered') % domain.name)
156         self.domains[domain.name] = domain
157 
158     def has_domain(self, domain: str) -> bool:
159         return domain in self.domains
160 
161     def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:
162         for DomainClass in self.domains.values():
163             domain = DomainClass(env)
164 
165             # transplant components added by extensions
166             domain.directives.update(self.domain_directives.get(domain.name, {}))
167             domain.roles.update(self.domain_roles.get(domain.name, {}))
168             domain.indices.extend(self.domain_indices.get(domain.name, []))
169             for name, objtype in self.domain_object_types.get(domain.name, {}).items():
170                 domain.add_object_type(name, objtype)
171 
172             yield domain
173 
174     def add_directive_to_domain(self, domain: str, name: str,
175                                 cls: "Type[Directive]", override: bool = False) -> None:
176         logger.debug('[app] adding directive to domain: %r', (domain, name, cls))
177         if domain not in self.domains:
178             raise ExtensionError(__('domain %s not yet registered') % domain)
179 
180         directives = self.domain_directives.setdefault(domain, {})
181         if name in directives and not override:
182             raise ExtensionError(__('The %r directive is already registered to domain %s') %
183                                  (name, domain))
184         directives[name] = cls
185 
186     def add_role_to_domain(self, domain: str, name: str,
187                            role: Union[RoleFunction, XRefRole], override: bool = False
188                            ) -> None:
189         logger.debug('[app] adding role to domain: %r', (domain, name, role))
190         if domain not in self.domains:
191             raise ExtensionError(__('domain %s not yet registered') % domain)
192         roles = self.domain_roles.setdefault(domain, {})
193         if name in roles and not override:
194             raise ExtensionError(__('The %r role is already registered to domain %s') %
195                                  (name, domain))
196         roles[name] = role
197 
198     def add_index_to_domain(self, domain: str, index: "Type[Index]",
199                             override: bool = False) -> None:
200         logger.debug('[app] adding index to domain: %r', (domain, index))
201         if domain not in self.domains:
202             raise ExtensionError(__('domain %s not yet registered') % domain)
203         indices = self.domain_indices.setdefault(domain, [])
204         if index in indices and not override:
205             raise ExtensionError(__('The %r index is already registered to domain %s') %
206                                  (index.name, domain))
207         indices.append(index)
208 
209     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
210                         parse_node: Callable = None, ref_nodeclass: "Type[TextElement]" = None,
211                         objname: str = '', doc_field_types: List = [], override: bool = False
212                         ) -> None:
213         logger.debug('[app] adding object type: %r',
214                      (directivename, rolename, indextemplate, parse_node,
215                       ref_nodeclass, objname, doc_field_types))
216 
217         # create a subclass of GenericObject as the new directive
218         directive = type(directivename,
219                          (GenericObject, object),
220                          {'indextemplate': indextemplate,
221                           'parse_node': staticmethod(parse_node),
222                           'doc_field_types': doc_field_types})
223 
224         self.add_directive_to_domain('std', directivename, directive)
225         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
226 
227         object_types = self.domain_object_types.setdefault('std', {})
228         if directivename in object_types and not override:
229             raise ExtensionError(__('The %r object_type is already registered') %
230                                  directivename)
231         object_types[directivename] = ObjType(objname or directivename, rolename)
232 
233     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
234                           ref_nodeclass: "Type[TextElement]" = None, objname: str = '',
235                           override: bool = False) -> None:
236         logger.debug('[app] adding crossref type: %r',
237                      (directivename, rolename, indextemplate, ref_nodeclass, objname))
238 
239         # create a subclass of Target as the new directive
240         directive = type(directivename,
241                          (Target, object),
242                          {'indextemplate': indextemplate})
243 
244         self.add_directive_to_domain('std', directivename, directive)
245         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
246 
247         object_types = self.domain_object_types.setdefault('std', {})
248         if directivename in object_types and not override:
249             raise ExtensionError(__('The %r crossref_type is already registered') %
250                                  directivename)
251         object_types[directivename] = ObjType(objname or directivename, rolename)
252 
253     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
254         logger.debug('[app] adding source_suffix: %r, %r', suffix, filetype)
255         if suffix in self.source_suffix and not override:
256             raise ExtensionError(__('source_suffix %r is already registered') % suffix)
257         else:
258             self.source_suffix[suffix] = filetype
259 
260     def add_source_parser(self, parser: "Type[Parser]", **kwargs: Any) -> None:
261         logger.debug('[app] adding search source_parser: %r', parser)
262 
263         # create a map from filetype to parser
264         for filetype in parser.supported:
265             if filetype in self.source_parsers and not kwargs.get('override'):
266                 raise ExtensionError(__('source_parser for %r is already registered') %
267                                      filetype)
268             else:
269                 self.source_parsers[filetype] = parser
270 
271     def get_source_parser(self, filetype: str) -> "Type[Parser]":
272         try:
273             return self.source_parsers[filetype]
274         except KeyError:
275             raise SphinxError(__('Source parser for %s not registered') % filetype)
276 
277     def get_source_parsers(self) -> Dict[str, "Type[Parser]"]:
278         return self.source_parsers
279 
280     def create_source_parser(self, app: "Sphinx", filename: str) -> Parser:
281         parser_class = self.get_source_parser(filename)
282         parser = parser_class()
283         if isinstance(parser, SphinxParser):
284             parser.set_application(app)
285         return parser
286 
287     def get_source_input(self, filetype: str) -> "Type[Input]":
288         try:
289             return self.source_inputs[filetype]
290         except KeyError:
291             try:
292                 # use special source_input for unknown filetype
293                 return self.source_inputs['*']
294             except KeyError:
295                 return None
296 
297     def add_translator(self, name: str, translator: "Type[nodes.NodeVisitor]",
298                        override: bool = False) -> None:
299         logger.debug('[app] Change of translator for the %s builder.', name)
300         if name in self.translators and not override:
301             raise ExtensionError(__('Translator for %r already exists') % name)
302         self.translators[name] = translator
303 
304     def add_translation_handlers(self, node: "Type[Element]",
305                                  **kwargs: Tuple[Callable, Callable]) -> None:
306         logger.debug('[app] adding translation_handlers: %r, %r', node, kwargs)
307         for builder_name, handlers in kwargs.items():
308             translation_handlers = self.translation_handlers.setdefault(builder_name, {})
309             try:
310                 visit, depart = handlers  # unpack once for assertion
311                 translation_handlers[node.__name__] = (visit, depart)
312             except ValueError:
313                 raise ExtensionError(__('kwargs for add_node() must be a (visit, depart) '
314                                         'function tuple: %r=%r') % (builder_name, handlers))
315 
316     def get_translator_class(self, builder: Builder) -> "Type[nodes.NodeVisitor]":
317         return self.translators.get(builder.name,
318                                     builder.default_translator_class)
319 
320     def create_translator(self, builder: Builder, *args: Any) -> nodes.NodeVisitor:
321         translator_class = self.get_translator_class(builder)
322         assert translator_class, "translator not found for %s" % builder.name
323         translator = translator_class(*args)
324 
325         # transplant handlers for custom nodes to translator instance
326         handlers = self.translation_handlers.get(builder.name, None)
327         if handlers is None:
328             # retry with builder.format
329             handlers = self.translation_handlers.get(builder.format, {})
330 
331         for name, (visit, depart) in handlers.items():
332             setattr(translator, 'visit_' + name, MethodType(visit, translator))
333             if depart:
334                 setattr(translator, 'depart_' + name, MethodType(depart, translator))
335 
336         return translator
337 
338     def add_transform(self, transform: "Type[Transform]") -> None:
339         logger.debug('[app] adding transform: %r', transform)
340         self.transforms.append(transform)
341 
342     def get_transforms(self) -> List["Type[Transform]"]:
343         return self.transforms
344 
345     def add_post_transform(self, transform: "Type[Transform]") -> None:
346         logger.debug('[app] adding post transform: %r', transform)
347         self.post_transforms.append(transform)
348 
349     def get_post_transforms(self) -> List["Type[Transform]"]:
350         return self.post_transforms
351 
352     def add_documenter(self, objtype: str, documenter: "Type[Documenter]") -> None:
353         self.documenters[objtype] = documenter
354 
355     def add_autodoc_attrgetter(self, typ: "Type",
356                                attrgetter: Callable[[Any, str, Any], Any]) -> None:
357         self.autodoc_attrgettrs[typ] = attrgetter
358 
359     def add_css_files(self, filename: str, **attributes: str) -> None:
360         self.css_files.append((filename, attributes))
361 
362     def add_js_file(self, filename: str, **attributes: str) -> None:
363         logger.debug('[app] adding js_file: %r, %r', filename, attributes)
364         self.js_files.append((filename, attributes))
365 
366     def add_latex_package(self, name: str, options: str) -> None:
367         logger.debug('[app] adding latex package: %r', name)
368         self.latex_packages.append((name, options))
369 
370     def add_enumerable_node(self, node: "Type[Node]", figtype: str,
371                             title_getter: TitleGetter = None, override: bool = False) -> None:
372         logger.debug('[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter)
373         if node in self.enumerable_nodes and not override:
374             raise ExtensionError(__('enumerable_node %r already registered') % node)
375         self.enumerable_nodes[node] = (figtype, title_getter)
376 
377     def add_html_math_renderer(self, name: str,
378                                inline_renderers: Tuple[Callable, Callable],
379                                block_renderers: Tuple[Callable, Callable]) -> None:
380         logger.debug('[app] adding html_math_renderer: %s, %r, %r',
381                      name, inline_renderers, block_renderers)
382         if name in self.html_inline_math_renderers:
383             raise ExtensionError(__('math renderer %s is already registred') % name)
384 
385         self.html_inline_math_renderers[name] = inline_renderers
386         self.html_block_math_renderers[name] = block_renderers
387 
388     def load_extension(self, app: "Sphinx", extname: str) -> None:
389         """Load a Sphinx extension."""
390         if extname in app.extensions:  # alread loaded
391             return
392         if extname in EXTENSION_BLACKLIST:
393             logger.warning(__('the extension %r was already merged with Sphinx since '
394                               'version %s; this extension is ignored.'),
395                            extname, EXTENSION_BLACKLIST[extname])
396             return
397 
398         # update loading context
399         prefix = __('while setting up extension %s:') % extname
400         with prefixed_warnings(prefix):
401             try:
402                 mod = import_module(extname)
403             except ImportError as err:
404                 logger.verbose(__('Original exception:\n') + traceback.format_exc())
405                 raise ExtensionError(__('Could not import extension %s') % extname, err)
406 
407             setup = getattr(mod, 'setup', None)
408             if setup is None:
409                 logger.warning(__('extension %r has no setup() function; is it really '
410                                   'a Sphinx extension module?'), extname)
411                 metadata = {}  # type: Dict[str, Any]
412             else:
413                 try:
414                     metadata = setup(app)
415                 except VersionRequirementError as err:
416                     # add the extension name to the version required
417                     raise VersionRequirementError(
418                         __('The %s extension used by this project needs at least '
419                            'Sphinx v%s; it therefore cannot be built with this '
420                            'version.') % (extname, err)
421                     )
422 
423             if metadata is None:
424                 metadata = {}
425             elif not isinstance(metadata, dict):
426                 logger.warning(__('extension %r returned an unsupported object from '
427                                   'its setup() function; it should return None or a '
428                                   'metadata dictionary'), extname)
429                 metadata = {}
430 
431             app.extensions[extname] = Extension(extname, mod, **metadata)
432 
433     def get_envversion(self, app: "Sphinx") -> Dict[str, str]:
434         from sphinx.environment import ENV_VERSION
435         envversion = {ext.name: ext.metadata['env_version'] for ext in app.extensions.values()
436                       if ext.metadata.get('env_version')}
437         envversion['sphinx'] = ENV_VERSION
438         return envversion
439 
440 
441 def merge_source_suffix(app: "Sphinx", config: Config) -> None:
442     """Merge source_suffix which specified by user and added by extensions."""
443     for suffix, filetype in app.registry.source_suffix.items():
444         if suffix not in app.config.source_suffix:
445             app.config.source_suffix[suffix] = filetype
446         elif app.config.source_suffix[suffix] is None:
447             # filetype is not specified (default filetype).
448             # So it overrides default filetype by extensions setting.
449             app.config.source_suffix[suffix] = filetype
450 
451     # copy config.source_suffix to registry
452     app.registry.source_suffix = app.config.source_suffix
453 
454 
455 def setup(app: "Sphinx") -> Dict[str, Any]:
456     app.connect('config-inited', merge_source_suffix)
457 
458     return {
459         'version': 'builtin',
460         'parallel_read_safe': True,
461         'parallel_write_safe': True,
462     }

</code><intended_behavior>Ensure that the method responsible for registering new parsers, such as .md parsers, correctly respects the file extension preferences specified in the configuration. This might involve adjusting how Sphinx prioritizes file extensions when multiple parsers are capable of processing a given file.</intended_behavior>]
2025-10-15 11:40:00.435 | INFO     | Search completed. Bug locations: [<file>sphinx/environment/adapters/toctree.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.adapters.toctree
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Toctree adapter for sphinx.environment.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Iterable, List
12 from typing import cast
13 
14 from docutils import nodes
15 from docutils.nodes import Element, Node
16 
17 from sphinx import addnodes
18 from sphinx.locale import __
19 from sphinx.util import url_re, logging
20 from sphinx.util.matching import Matcher
21 from sphinx.util.nodes import clean_astext, process_only_nodes
22 
23 if False:
24     # For type annotation
25     from sphinx.builders import Builder
26     from sphinx.environment import BuildEnvironment
27 
28 
29 logger = logging.getLogger(__name__)
30 
31 
32 class TocTree:
33     def __init__(self, env: "BuildEnvironment") -> None:
34         self.env = env
35 
36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:
37         """Note a TOC tree directive in a document and gather information about
38         file relations from it.
39         """
40         if toctreenode['glob']:
41             self.env.glob_toctrees.add(docname)
42         if toctreenode.get('numbered'):
43             self.env.numbered_toctrees.add(docname)
44         includefiles = toctreenode['includefiles']
45         for includefile in includefiles:
46             # note that if the included file is rebuilt, this one must be
47             # too (since the TOC of the included file could have changed)
48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)
49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)
50 
51     def resolve(self, docname: str, builder: "Builder", toctree: addnodes.toctree,
52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,
53                 collapse: bool = False, includehidden: bool = False) -> Element:
54         """Resolve a *toctree* node into individual bullet lists with titles
55         as items, returning None (if no containing titles are found) or
56         a new node.
57 
58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,
59         to the value of the *maxdepth* option on the *toctree* node.
60         If *titles_only* is True, only toplevel document titles will be in the
61         resulting tree.
62         If *collapse* is True, all branches not containing docname will
63         be collapsed.
64         """
65         if toctree.get('hidden', False) and not includehidden:
66             return None
67 
68         # For reading the following two helper function, it is useful to keep
69         # in mind the node structure of a toctree (using HTML-like node names
70         # for brevity):
71         #
72         # <ul>
73         #   <li>
74         #     <p><a></p>
75         #     <p><a></p>
76         #     ...
77         #     <ul>
78         #       ...
79         #     </ul>
80         #   </li>
81         # </ul>
82         #
83         # The transformation is made in two passes in order to avoid
84         # interactions between marking and pruning the tree (see bug #1046).
85 
86         toctree_ancestors = self.get_toctree_ancestors(docname)
87         excluded = Matcher(self.env.config.exclude_patterns)
88 
89         def _toctree_add_classes(node: Element, depth: int) -> None:
90             """Add 'toctree-l%d' and 'current' classes to the toctree."""
91             for subnode in node.children:
92                 if isinstance(subnode, (addnodes.compact_paragraph,
93                                         nodes.list_item)):
94                     # for <p> and <li>, indicate the depth level and recurse
95                     subnode['classes'].append('toctree-l%d' % (depth - 1))
96                     _toctree_add_classes(subnode, depth)
97                 elif isinstance(subnode, nodes.bullet_list):
98                     # for <ul>, just recurse
99                     _toctree_add_classes(subnode, depth + 1)
100                 elif isinstance(subnode, nodes.reference):
101                     # for <a>, identify which entries point to the current
102                     # document and therefore may not be collapsed
103                     if subnode['refuri'] == docname:
104                         if not subnode['anchorname']:
105                             # give the whole branch a 'current' class
106                             # (useful for styling it differently)
107                             branchnode = subnode  # type: Element
108                             while branchnode:
109                                 branchnode['classes'].append('current')
110                                 branchnode = branchnode.parent
111                         # mark the list_item as "on current page"
112                         if subnode.parent.parent.get('iscurrent'):
113                             # but only if it's not already done
114                             return
115                         while subnode:
116                             subnode['iscurrent'] = True
117                             subnode = subnode.parent
118 
119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],
120                                   separate: bool = False, subtree: bool = False
121                                   ) -> List[Element]:
122             """Return TOC entries for a toctree node."""
123             refs = [(e[0], e[1]) for e in toctreenode['entries']]
124             entries = []  # type: List[Element]
125             for (title, ref) in refs:
126                 try:
127                     refdoc = None
128                     if url_re.match(ref):
129                         if title is None:
130                             title = ref
131                         reference = nodes.reference('', '', internal=False,
132                                                     refuri=ref, anchorname='',
133                                                     *[nodes.Text(title)])
134                         para = addnodes.compact_paragraph('', '', reference)
135                         item = nodes.list_item('', para)
136                         toc = nodes.bullet_list('', item)
137                     elif ref == 'self':
138                         # 'self' refers to the document from which this
139                         # toctree originates
140                         ref = toctreenode['parent']
141                         if not title:
142                             title = clean_astext(self.env.titles[ref])
143                         reference = nodes.reference('', '', internal=True,
144                                                     refuri=ref,
145                                                     anchorname='',
146                                                     *[nodes.Text(title)])
147                         para = addnodes.compact_paragraph('', '', reference)
148                         item = nodes.list_item('', para)
149                         # don't show subitems
150                         toc = nodes.bullet_list('', item)
151                     else:
152                         if ref in parents:
153                             logger.warning(__('circular toctree references '
154                                               'detected, ignoring: %s <- %s'),
155                                            ref, ' <- '.join(parents),
156                                            location=ref)
157                             continue
158                         refdoc = ref
159                         toc = self.env.tocs[ref].deepcopy()
160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)
161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):
162                             self._toctree_prune(toc, 2, maxdepth, collapse)
163                         process_only_nodes(toc, builder.tags)
164                         if title and toc.children and len(toc.children) == 1:
165                             child = toc.children[0]
166                             for refnode in child.traverse(nodes.reference):
167                                 if refnode['refuri'] == ref and \
168                                    not refnode['anchorname']:
169                                     refnode.children = [nodes.Text(title)]
170                     if not toc.children:
171                         # empty toc means: no titles will show up in the toctree
172                         logger.warning(__('toctree contains reference to document %r that '
173                                           'doesn\'t have a title: no link will be generated'),
174                                        ref, location=toctreenode)
175                 except KeyError:
176                     # this is raised if the included file does not exist
177                     if excluded(self.env.doc2path(ref, None)):
178                         message = __('toctree contains reference to excluded document %r')
179                     else:
180                         message = __('toctree contains reference to nonexisting document %r')
181 
182                     logger.warning(message, ref, location=toctreenode)
183                 else:
184                     # if titles_only is given, only keep the main title and
185                     # sub-toctrees
186                     if titles_only:
187                         # children of toc are:
188                         # - list_item + compact_paragraph + (reference and subtoc)
189                         # - only + subtoc
190                         # - toctree
191                         children = cast(Iterable[nodes.Element], toc)
192 
193                         # delete everything but the toplevel title(s)
194                         # and toctrees
195                         for toplevel in children:
196                             # nodes with length 1 don't have any children anyway
197                             if len(toplevel) > 1:
198                                 subtrees = toplevel.traverse(addnodes.toctree)
199                                 if subtrees:
200                                     toplevel[1][:] = subtrees  # type: ignore
201                                 else:
202                                     toplevel.pop(1)
203                     # resolve all sub-toctrees
204                     for subtocnode in toc.traverse(addnodes.toctree):
205                         if not (subtocnode.get('hidden', False) and
206                                 not includehidden):
207                             i = subtocnode.parent.index(subtocnode) + 1
208                             for entry in _entries_from_toctree(
209                                     subtocnode, [refdoc] + parents,
210                                     subtree=True):
211                                 subtocnode.parent.insert(i, entry)
212                                 i += 1
213                             subtocnode.parent.remove(subtocnode)
214                     if separate:
215                         entries.append(toc)
216                     else:
217                         children = cast(Iterable[nodes.Element], toc)
218                         entries.extend(children)
219             if not subtree and not separate:
220                 ret = nodes.bullet_list()
221                 ret += entries
222                 return [ret]
223             return entries
224 
225         maxdepth = maxdepth or toctree.get('maxdepth', -1)
226         if not titles_only and toctree.get('titlesonly', False):
227             titles_only = True
228         if not includehidden and toctree.get('includehidden', False):
229             includehidden = True
230 
231         # NOTE: previously, this was separate=True, but that leads to artificial
232         # separation when two or more toctree entries form a logical unit, so
233         # separating mode is no longer used -- it's kept here for history's sake
234         tocentries = _entries_from_toctree(toctree, [], separate=False)
235         if not tocentries:
236             return None
237 
238         newnode = addnodes.compact_paragraph('', '')
239         caption = toctree.attributes.get('caption')
240         if caption:
241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])
242             caption_node.line = toctree.line
243             caption_node.source = toctree.source
244             caption_node.rawsource = toctree['rawcaption']
245             if hasattr(toctree, 'uid'):
246                 # move uid to caption_node to translate it
247                 caption_node.uid = toctree.uid  # type: ignore
248                 del toctree.uid  # type: ignore
249             newnode += caption_node
250         newnode.extend(tocentries)
251         newnode['toctree'] = True
252 
253         # prune the tree to maxdepth, also set toc depth and current classes
254         _toctree_add_classes(newnode, 1)
255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)
256 
257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found
258             return None
259 
260         # set the target paths in the toctrees (they are not known at TOC
261         # generation time)
262         for refnode in newnode.traverse(nodes.reference):
263             if not url_re.match(refnode['refuri']):
264                 refnode['refuri'] = builder.get_relative_uri(
265                     docname, refnode['refuri']) + refnode['anchorname']
266         return newnode
267 
268     def get_toctree_ancestors(self, docname: str) -> List[str]:
269         parent = {}
270         for p, children in self.env.toctree_includes.items():
271             for child in children:
272                 parent[child] = p
273         ancestors = []  # type: List[str]
274         d = docname
275         while d in parent and d not in ancestors:
276             ancestors.append(d)
277             d = parent[d]
278         return ancestors
279 
280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False
281                        ) -> None:
282         """Utility: Cut a TOC at a specified depth."""
283         for subnode in node.children[:]:
284             if isinstance(subnode, (addnodes.compact_paragraph,
285                                     nodes.list_item)):
286                 # for <p> and <li>, just recurse
287                 self._toctree_prune(subnode, depth, maxdepth, collapse)
288             elif isinstance(subnode, nodes.bullet_list):
289                 # for <ul>, determine if the depth is too large or if the
290                 # entry is to be collapsed
291                 if maxdepth > 0 and depth > maxdepth:
292                     subnode.parent.replace(subnode, [])
293                 else:
294                     # cull sub-entries whose parents aren't 'current'
295                     if (collapse and depth > 1 and
296                             'iscurrent' not in subnode.parent):
297                         subnode.parent.remove(subnode)
298                     else:
299                         # recurse on visible children
300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)
301 
302     def get_toc_for(self, docname: str, builder: "Builder") -> Node:
303         """Return a TOC nodetree -- for use on the same page only!"""
304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)
305         try:
306             toc = self.env.tocs[docname].deepcopy()
307             self._toctree_prune(toc, 2, tocdepth)
308         except KeyError:
309             # the document does not exist anymore: return a dummy node that
310             # renders to nothing
311             return nodes.paragraph()
312         process_only_nodes(toc, builder.tags)
313         for node in toc.traverse(nodes.reference):
314             node['refuri'] = node['anchorname'] or '#'
315         return toc
316 
317     def get_toctree_for(self, docname: str, builder: "Builder", collapse: bool,
318                         **kwargs: Any) -> Element:
319         """Return the global TOC nodetree."""
320         doctree = self.env.get_doctree(self.env.config.master_doc)
321         toctrees = []  # type: List[Element]
322         if 'includehidden' not in kwargs:
323             kwargs['includehidden'] = True
324         if 'maxdepth' not in kwargs:
325             kwargs['maxdepth'] = 0
326         kwargs['collapse'] = collapse
327         for toctreenode in doctree.traverse(addnodes.toctree):
328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)
329             if toctree:
330                 toctrees.append(toctree)
331         if not toctrees:
332             return None
333         result = toctrees[0]
334         for toctree in toctrees[1:]:
335             result.extend(toctree.children)
336         return result

</code><intended_behavior>This file and its methods, particularly those processing the toctree entries, should include logic to handle file priorities based on their extensions when multiple files with the same name exist. An ideal enhancement would be a configuration option allowing users to specify the order of preference for file extensions. In the absence of such a specification, the system should log a warning when deciding which file to include, promoting transparency in the file selection process.</intended_behavior>, <file>sphinx/config.py</file>
<class>Config</class>
<method>None</method>
<code>
81 class Config:
82     """Configuration file abstraction.
83 
84     The config object makes the values of all config values available as
85     attributes.
86 
87     It is exposed via the :py:attr:`sphinx.application.Application.config` and
88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
89     to get the value of :confval:`language`, use either ``app.config.language``
90     or ``env.config.language``.
91     """
92 
93     # the values are: (default, what needs to be rebuilt if changed)
94 
95     # If you add a value here, don't forget to include it in the
96     # quickstart.py file template as well as in the docs!
97 
98     config_values = {
99         # general options
100         'project': ('Python', 'env', []),
101         'author': ('unknown', 'env', []),
102         'copyright': ('', 'html', []),
103         'version': ('', 'env', []),
104         'release': ('', 'env', []),
105         'today': ('', 'env', []),
106         # the real default is locale-dependent
107         'today_fmt': (None, 'env', [str]),
108 
109         'language': (None, 'env', [str]),
110         'locale_dirs': (['locales'], 'env', []),
111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
112 
113         'master_doc': ('index', 'env', []),
114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
115         'source_encoding': ('utf-8-sig', 'env', []),
116         'source_parsers': ({}, 'env', []),
117         'exclude_patterns': ([], 'env', []),
118         'default_role': (None, 'env', [str]),
119         'add_function_parentheses': (True, 'env', []),
120         'add_module_names': (True, 'env', []),
121         'trim_footnote_reference_space': (False, 'env', []),
122         'show_authors': (False, 'env', []),
123         'pygments_style': (None, 'html', [str]),
124         'highlight_language': ('default', 'env', []),
125         'highlight_options': ({}, 'env', []),
126         'templates_path': ([], 'html', []),
127         'template_bridge': (None, 'html', [str]),
128         'keep_warnings': (False, 'env', []),
129         'suppress_warnings': ([], 'env', []),
130         'modindex_common_prefix': ([], 'html', []),
131         'rst_epilog': (None, 'env', [str]),
132         'rst_prolog': (None, 'env', [str]),
133         'trim_doctest_flags': (True, 'env', []),
134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore
135         'needs_sphinx': (None, None, [str]),
136         'needs_extensions': ({}, None, []),
137         'manpages_url': (None, 'env', []),
138         'nitpicky': (False, None, []),
139         'nitpick_ignore': ([], None, []),
140         'numfig': (False, 'env', []),
141         'numfig_secnum_depth': (1, 'env', []),
142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
143 
144         'math_number_all': (False, 'env', []),
145         'math_eqref_format': (None, 'env', [str]),
146         'math_numfig': (True, 'env', []),
147         'tls_verify': (True, 'env', []),
148         'tls_cacerts': (None, 'env', []),
149         'user_agent': (None, 'env', [str]),
150         'smartquotes': (True, 'env', []),
151         'smartquotes_action': ('qDe', 'env', []),
152         'smartquotes_excludes': ({'languages': ['ja'],
153                                   'builders': ['man', 'text']},
154                                  'env', []),
155     }  # type: Dict[str, Tuple]
156 
157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
158         self.overrides = dict(overrides)
159         self.values = Config.config_values.copy()
160         self._raw_config = config
161         self.setup = config.get('setup', None)  # type: Callable
162 
163         if 'extensions' in self.overrides:
164             if isinstance(self.overrides['extensions'], str):
165                 config['extensions'] = self.overrides.pop('extensions').split(',')
166             else:
167                 config['extensions'] = self.overrides.pop('extensions')
168         self.extensions = config.get('extensions', [])  # type: List[str]
169 
170     @classmethod
171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         namespace = eval_config_file(filename, tags)
175         return cls(namespace, overrides or {})
176 
177     def convert_overrides(self, name: str, value: Any) -> Any:
178         if not isinstance(value, str):
179             return value
180         else:
181             defvalue = self.values[name][0]
182             if self.values[name][2] == Any:
183                 return value
184             elif type(defvalue) is bool or self.values[name][2] == [bool]:
185                 if value == '0':
186                     # given falsy string from command line option
187                     return False
188                 else:
189                     return bool(value)
190             elif isinstance(defvalue, dict):
191                 raise ValueError(__('cannot override dictionary config setting %r, '
192                                     'ignoring (use %r to set individual elements)') %
193                                  (name, name + '.key=value'))
194             elif isinstance(defvalue, list):
195                 return value.split(',')
196             elif isinstance(defvalue, int):
197                 try:
198                     return int(value)
199                 except ValueError:
200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
201                                      (value, name))
202             elif hasattr(defvalue, '__call__'):
203                 return value
204             elif defvalue is not None and not isinstance(defvalue, str):
205                 raise ValueError(__('cannot override config setting %r with unsupported '
206                                     'type, ignoring') % name)
207             else:
208                 return value
209 
210     def pre_init_values(self) -> None:
211         """
212         Initialize some limited config variables before initialize i18n and loading extensions
213         """
214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
215         for name in variables:
216             try:
217                 if name in self.overrides:
218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
219                 elif name in self._raw_config:
220                     self.__dict__[name] = self._raw_config[name]
221             except ValueError as exc:
222                 logger.warning("%s", exc)
223 
224     def init_values(self) -> None:
225         config = self._raw_config
226         for valname, value in self.overrides.items():
227             try:
228                 if '.' in valname:
229                     realvalname, key = valname.split('.', 1)
230                     config.setdefault(realvalname, {})[key] = value
231                     continue
232                 elif valname not in self.values:
233                     logger.warning(__('unknown config value %r in override, ignoring'),
234                                    valname)
235                     continue
236                 if isinstance(value, str):
237                     config[valname] = self.convert_overrides(valname, value)
238                 else:
239                     config[valname] = value
240             except ValueError as exc:
241                 logger.warning("%s", exc)
242         for name in config:
243             if name in self.values:
244                 self.__dict__[name] = config[name]
245 
246     def __getattr__(self, name: str) -> Any:
247         if name.startswith('_'):
248             raise AttributeError(name)
249         if name not in self.values:
250             raise AttributeError(__('No such config value: %s') % name)
251         default = self.values[name][0]
252         if hasattr(default, '__call__'):
253             return default(self)
254         return default
255 
256     def __getitem__(self, name: str) -> str:
257         return getattr(self, name)
258 
259     def __setitem__(self, name: str, value: Any) -> None:
260         setattr(self, name, value)
261 
262     def __delitem__(self, name: str) -> None:
263         delattr(self, name)
264 
265     def __contains__(self, name: str) -> bool:
266         return name in self.values
267 
268     def __iter__(self) -> Generator[ConfigValue, None, None]:
269         for name, value in self.values.items():
270             yield ConfigValue(name, getattr(self, name), value[1])
271 
272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
273         if name in self.values:
274             raise ExtensionError(__('Config value %r already present') % name)
275         else:
276             self.values[name] = (default, rebuild, types)
277 
278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
279         if isinstance(rebuild, str):
280             rebuild = [rebuild]
281         return (value for value in self if value.rebuild in rebuild)
282 
283     def __getstate__(self) -> Dict:
284         """Obtains serializable data for pickling."""
285         # remove potentially pickling-problematic values from config
286         __dict__ = {}
287         for key, value in self.__dict__.items():
288             if key.startswith('_') or not is_serializable(value):
289                 pass
290             else:
291                 __dict__[key] = value
292 
293         # create a picklable copy of values list
294         __dict__['values'] = {}
295         for key, value in self.values.items():
296             real_value = getattr(self, key)
297             if not is_serializable(real_value):
298                 # omit unserializable value
299                 real_value = None
300 
301             # types column is also omitted
302             __dict__['values'][key] = (real_value, value[1], None)
303 
304         return __dict__
305 
306     def __setstate__(self, state: Dict) -> None:
307         self.__dict__.update(state)

</code><intended_behavior>Enhance the Config class to support new configuration options that allow specifying the order of preference for file extensions. This would directly address the user's need to influence Sphinx’s behavior regarding file selection when similar filenames exist with different extensions.</intended_behavior>, <file>sphinx/registry.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.registry
3     ~~~~~~~~~~~~~~~
4 
5     Sphinx component registry.
6 
7     :copyright: Copyright 2007-2016 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import traceback
12 from importlib import import_module
13 from types import MethodType
14 from typing import Any, Callable, Dict, Iterator, List, Tuple, Union
15 
16 from docutils import nodes
17 from docutils.io import Input
18 from docutils.nodes import Element, Node, TextElement
19 from docutils.parsers import Parser
20 from docutils.parsers.rst import Directive
21 from docutils.transforms import Transform
22 from pkg_resources import iter_entry_points
23 
24 from sphinx.builders import Builder
25 from sphinx.config import Config
26 from sphinx.domains import Domain, Index, ObjType
27 from sphinx.domains.std import GenericObject, Target
28 from sphinx.environment import BuildEnvironment
29 from sphinx.errors import ExtensionError, SphinxError, VersionRequirementError
30 from sphinx.extension import Extension
31 from sphinx.locale import __
32 from sphinx.parsers import Parser as SphinxParser
33 from sphinx.roles import XRefRole
34 from sphinx.util import logging
35 from sphinx.util.logging import prefixed_warnings
36 from sphinx.util.typing import RoleFunction, TitleGetter
37 
38 if False:
39     # For type annotation
40     from typing import Type  # for python3.5.1
41     from sphinx.application import Sphinx
42     from sphinx.ext.autodoc import Documenter
43 
44 logger = logging.getLogger(__name__)
45 
46 # list of deprecated extensions. Keys are extension name.
47 # Values are Sphinx version that merge the extension.
48 EXTENSION_BLACKLIST = {
49     "sphinxjp.themecore": "1.2"
50 }
51 
52 
53 class SphinxComponentRegistry:
54     def __init__(self) -> None:
55         #: special attrgetter for autodoc; class object -> attrgetter
56         self.autodoc_attrgettrs = {}    # type: Dict[Type, Callable[[Any, str, Any], Any]]
57 
58         #: builders; a dict of builder name -> bulider class
59         self.builders = {}              # type: Dict[str, Type[Builder]]
60 
61         #: autodoc documenters; a dict of documenter name -> documenter class
62         self.documenters = {}           # type: Dict[str, Type[Documenter]]
63 
64         #: css_files; a list of tuple of filename and attributes
65         self.css_files = []             # type: List[Tuple[str, Dict[str, str]]]
66 
67         #: domains; a dict of domain name -> domain class
68         self.domains = {}               # type: Dict[str, Type[Domain]]
69 
70         #: additional directives for domains
71         #: a dict of domain name -> dict of directive name -> directive
72         self.domain_directives = {}     # type: Dict[str, Dict[str, Any]]
73 
74         #: additional indices for domains
75         #: a dict of domain name -> list of index class
76         self.domain_indices = {}        # type: Dict[str, List[Type[Index]]]
77 
78         #: additional object types for domains
79         #: a dict of domain name -> dict of objtype name -> objtype
80         self.domain_object_types = {}   # type: Dict[str, Dict[str, ObjType]]
81 
82         #: additional roles for domains
83         #: a dict of domain name -> dict of role name -> role impl.
84         self.domain_roles = {}          # type: Dict[str, Dict[str, Union[RoleFunction, XRefRole]]]  # NOQA
85 
86         #: additional enumerable nodes
87         #: a dict of node class -> tuple of figtype and title_getter function
88         self.enumerable_nodes = {}      # type: Dict[Type[Node], Tuple[str, TitleGetter]]
89 
90         #: HTML inline and block math renderers
91         #: a dict of name -> tuple of visit function and depart function
92         self.html_inline_math_renderers = {}    # type: Dict[str, Tuple[Callable, Callable]]
93         self.html_block_math_renderers = {}     # type: Dict[str, Tuple[Callable, Callable]]
94 
95         #: js_files; list of JS paths or URLs
96         self.js_files = []              # type: List[Tuple[str, Dict[str, str]]]
97 
98         #: LaTeX packages; list of package names and its options
99         self.latex_packages = []        # type: List[Tuple[str, str]]
100 
101         #: post transforms; list of transforms
102         self.post_transforms = []       # type: List[Type[Transform]]
103 
104         #: source paresrs; file type -> parser class
105         self.source_parsers = {}        # type: Dict[str, Type[Parser]]
106 
107         #: source inputs; file type -> input class
108         self.source_inputs = {}         # type: Dict[str, Type[Input]]
109 
110         #: source suffix: suffix -> file type
111         self.source_suffix = {}         # type: Dict[str, str]
112 
113         #: custom translators; builder name -> translator class
114         self.translators = {}           # type: Dict[str, Type[nodes.NodeVisitor]]
115 
116         #: custom handlers for translators
117         #: a dict of builder name -> dict of node name -> visitor and departure functions
118         self.translation_handlers = {}  # type: Dict[str, Dict[str, Tuple[Callable, Callable]]]
119 
120         #: additional transforms; list of transforms
121         self.transforms = []            # type: List[Type[Transform]]
122 
123     def add_builder(self, builder: "Type[Builder]", override: bool = False) -> None:
124         logger.debug('[app] adding builder: %r', builder)
125         if not hasattr(builder, 'name'):
126             raise ExtensionError(__('Builder class %s has no "name" attribute') % builder)
127         if builder.name in self.builders and not override:
128             raise ExtensionError(__('Builder %r already exists (in module %s)') %
129                                  (builder.name, self.builders[builder.name].__module__))
130         self.builders[builder.name] = builder
131 
132     def preload_builder(self, app: "Sphinx", name: str) -> None:
133         if name is None:
134             return
135 
136         if name not in self.builders:
137             entry_points = iter_entry_points('sphinx.builders', name)
138             try:
139                 entry_point = next(entry_points)
140             except StopIteration:
141                 raise SphinxError(__('Builder name %s not registered or available'
142                                      ' through entry point') % name)
143 
144             self.load_extension(app, entry_point.module_name)
145 
146     def create_builder(self, app: "Sphinx", name: str) -> Builder:
147         if name not in self.builders:
148             raise SphinxError(__('Builder name %s not registered') % name)
149 
150         return self.builders[name](app)
151 
152     def add_domain(self, domain: "Type[Domain]", override: bool = False) -> None:
153         logger.debug('[app] adding domain: %r', domain)
154         if domain.name in self.domains and not override:
155             raise ExtensionError(__('domain %s already registered') % domain.name)
156         self.domains[domain.name] = domain
157 
158     def has_domain(self, domain: str) -> bool:
159         return domain in self.domains
160 
161     def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:
162         for DomainClass in self.domains.values():
163             domain = DomainClass(env)
164 
165             # transplant components added by extensions
166             domain.directives.update(self.domain_directives.get(domain.name, {}))
167             domain.roles.update(self.domain_roles.get(domain.name, {}))
168             domain.indices.extend(self.domain_indices.get(domain.name, []))
169             for name, objtype in self.domain_object_types.get(domain.name, {}).items():
170                 domain.add_object_type(name, objtype)
171 
172             yield domain
173 
174     def add_directive_to_domain(self, domain: str, name: str,
175                                 cls: "Type[Directive]", override: bool = False) -> None:
176         logger.debug('[app] adding directive to domain: %r', (domain, name, cls))
177         if domain not in self.domains:
178             raise ExtensionError(__('domain %s not yet registered') % domain)
179 
180         directives = self.domain_directives.setdefault(domain, {})
181         if name in directives and not override:
182             raise ExtensionError(__('The %r directive is already registered to domain %s') %
183                                  (name, domain))
184         directives[name] = cls
185 
186     def add_role_to_domain(self, domain: str, name: str,
187                            role: Union[RoleFunction, XRefRole], override: bool = False
188                            ) -> None:
189         logger.debug('[app] adding role to domain: %r', (domain, name, role))
190         if domain not in self.domains:
191             raise ExtensionError(__('domain %s not yet registered') % domain)
192         roles = self.domain_roles.setdefault(domain, {})
193         if name in roles and not override:
194             raise ExtensionError(__('The %r role is already registered to domain %s') %
195                                  (name, domain))
196         roles[name] = role
197 
198     def add_index_to_domain(self, domain: str, index: "Type[Index]",
199                             override: bool = False) -> None:
200         logger.debug('[app] adding index to domain: %r', (domain, index))
201         if domain not in self.domains:
202             raise ExtensionError(__('domain %s not yet registered') % domain)
203         indices = self.domain_indices.setdefault(domain, [])
204         if index in indices and not override:
205             raise ExtensionError(__('The %r index is already registered to domain %s') %
206                                  (index.name, domain))
207         indices.append(index)
208 
209     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
210                         parse_node: Callable = None, ref_nodeclass: "Type[TextElement]" = None,
211                         objname: str = '', doc_field_types: List = [], override: bool = False
212                         ) -> None:
213         logger.debug('[app] adding object type: %r',
214                      (directivename, rolename, indextemplate, parse_node,
215                       ref_nodeclass, objname, doc_field_types))
216 
217         # create a subclass of GenericObject as the new directive
218         directive = type(directivename,
219                          (GenericObject, object),
220                          {'indextemplate': indextemplate,
221                           'parse_node': staticmethod(parse_node),
222                           'doc_field_types': doc_field_types})
223 
224         self.add_directive_to_domain('std', directivename, directive)
225         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
226 
227         object_types = self.domain_object_types.setdefault('std', {})
228         if directivename in object_types and not override:
229             raise ExtensionError(__('The %r object_type is already registered') %
230                                  directivename)
231         object_types[directivename] = ObjType(objname or directivename, rolename)
232 
233     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
234                           ref_nodeclass: "Type[TextElement]" = None, objname: str = '',
235                           override: bool = False) -> None:
236         logger.debug('[app] adding crossref type: %r',
237                      (directivename, rolename, indextemplate, ref_nodeclass, objname))
238 
239         # create a subclass of Target as the new directive
240         directive = type(directivename,
241                          (Target, object),
242                          {'indextemplate': indextemplate})
243 
244         self.add_directive_to_domain('std', directivename, directive)
245         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
246 
247         object_types = self.domain_object_types.setdefault('std', {})
248         if directivename in object_types and not override:
249             raise ExtensionError(__('The %r crossref_type is already registered') %
250                                  directivename)
251         object_types[directivename] = ObjType(objname or directivename, rolename)
252 
253     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
254         logger.debug('[app] adding source_suffix: %r, %r', suffix, filetype)
255         if suffix in self.source_suffix and not override:
256             raise ExtensionError(__('source_suffix %r is already registered') % suffix)
257         else:
258             self.source_suffix[suffix] = filetype
259 
260     def add_source_parser(self, parser: "Type[Parser]", **kwargs: Any) -> None:
261         logger.debug('[app] adding search source_parser: %r', parser)
262 
263         # create a map from filetype to parser
264         for filetype in parser.supported:
265             if filetype in self.source_parsers and not kwargs.get('override'):
266                 raise ExtensionError(__('source_parser for %r is already registered') %
267                                      filetype)
268             else:
269                 self.source_parsers[filetype] = parser
270 
271     def get_source_parser(self, filetype: str) -> "Type[Parser]":
272         try:
273             return self.source_parsers[filetype]
274         except KeyError:
275             raise SphinxError(__('Source parser for %s not registered') % filetype)
276 
277     def get_source_parsers(self) -> Dict[str, "Type[Parser]"]:
278         return self.source_parsers
279 
280     def create_source_parser(self, app: "Sphinx", filename: str) -> Parser:
281         parser_class = self.get_source_parser(filename)
282         parser = parser_class()
283         if isinstance(parser, SphinxParser):
284             parser.set_application(app)
285         return parser
286 
287     def get_source_input(self, filetype: str) -> "Type[Input]":
288         try:
289             return self.source_inputs[filetype]
290         except KeyError:
291             try:
292                 # use special source_input for unknown filetype
293                 return self.source_inputs['*']
294             except KeyError:
295                 return None
296 
297     def add_translator(self, name: str, translator: "Type[nodes.NodeVisitor]",
298                        override: bool = False) -> None:
299         logger.debug('[app] Change of translator for the %s builder.', name)
300         if name in self.translators and not override:
301             raise ExtensionError(__('Translator for %r already exists') % name)
302         self.translators[name] = translator
303 
304     def add_translation_handlers(self, node: "Type[Element]",
305                                  **kwargs: Tuple[Callable, Callable]) -> None:
306         logger.debug('[app] adding translation_handlers: %r, %r', node, kwargs)
307         for builder_name, handlers in kwargs.items():
308             translation_handlers = self.translation_handlers.setdefault(builder_name, {})
309             try:
310                 visit, depart = handlers  # unpack once for assertion
311                 translation_handlers[node.__name__] = (visit, depart)
312             except ValueError:
313                 raise ExtensionError(__('kwargs for add_node() must be a (visit, depart) '
314                                         'function tuple: %r=%r') % (builder_name, handlers))
315 
316     def get_translator_class(self, builder: Builder) -> "Type[nodes.NodeVisitor]":
317         return self.translators.get(builder.name,
318                                     builder.default_translator_class)
319 
320     def create_translator(self, builder: Builder, *args: Any) -> nodes.NodeVisitor:
321         translator_class = self.get_translator_class(builder)
322         assert translator_class, "translator not found for %s" % builder.name
323         translator = translator_class(*args)
324 
325         # transplant handlers for custom nodes to translator instance
326         handlers = self.translation_handlers.get(builder.name, None)
327         if handlers is None:
328             # retry with builder.format
329             handlers = self.translation_handlers.get(builder.format, {})
330 
331         for name, (visit, depart) in handlers.items():
332             setattr(translator, 'visit_' + name, MethodType(visit, translator))
333             if depart:
334                 setattr(translator, 'depart_' + name, MethodType(depart, translator))
335 
336         return translator
337 
338     def add_transform(self, transform: "Type[Transform]") -> None:
339         logger.debug('[app] adding transform: %r', transform)
340         self.transforms.append(transform)
341 
342     def get_transforms(self) -> List["Type[Transform]"]:
343         return self.transforms
344 
345     def add_post_transform(self, transform: "Type[Transform]") -> None:
346         logger.debug('[app] adding post transform: %r', transform)
347         self.post_transforms.append(transform)
348 
349     def get_post_transforms(self) -> List["Type[Transform]"]:
350         return self.post_transforms
351 
352     def add_documenter(self, objtype: str, documenter: "Type[Documenter]") -> None:
353         self.documenters[objtype] = documenter
354 
355     def add_autodoc_attrgetter(self, typ: "Type",
356                                attrgetter: Callable[[Any, str, Any], Any]) -> None:
357         self.autodoc_attrgettrs[typ] = attrgetter
358 
359     def add_css_files(self, filename: str, **attributes: str) -> None:
360         self.css_files.append((filename, attributes))
361 
362     def add_js_file(self, filename: str, **attributes: str) -> None:
363         logger.debug('[app] adding js_file: %r, %r', filename, attributes)
364         self.js_files.append((filename, attributes))
365 
366     def add_latex_package(self, name: str, options: str) -> None:
367         logger.debug('[app] adding latex package: %r', name)
368         self.latex_packages.append((name, options))
369 
370     def add_enumerable_node(self, node: "Type[Node]", figtype: str,
371                             title_getter: TitleGetter = None, override: bool = False) -> None:
372         logger.debug('[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter)
373         if node in self.enumerable_nodes and not override:
374             raise ExtensionError(__('enumerable_node %r already registered') % node)
375         self.enumerable_nodes[node] = (figtype, title_getter)
376 
377     def add_html_math_renderer(self, name: str,
378                                inline_renderers: Tuple[Callable, Callable],
379                                block_renderers: Tuple[Callable, Callable]) -> None:
380         logger.debug('[app] adding html_math_renderer: %s, %r, %r',
381                      name, inline_renderers, block_renderers)
382         if name in self.html_inline_math_renderers:
383             raise ExtensionError(__('math renderer %s is already registred') % name)
384 
385         self.html_inline_math_renderers[name] = inline_renderers
386         self.html_block_math_renderers[name] = block_renderers
387 
388     def load_extension(self, app: "Sphinx", extname: str) -> None:
389         """Load a Sphinx extension."""
390         if extname in app.extensions:  # alread loaded
391             return
392         if extname in EXTENSION_BLACKLIST:
393             logger.warning(__('the extension %r was already merged with Sphinx since '
394                               'version %s; this extension is ignored.'),
395                            extname, EXTENSION_BLACKLIST[extname])
396             return
397 
398         # update loading context
399         prefix = __('while setting up extension %s:') % extname
400         with prefixed_warnings(prefix):
401             try:
402                 mod = import_module(extname)
403             except ImportError as err:
404                 logger.verbose(__('Original exception:\n') + traceback.format_exc())
405                 raise ExtensionError(__('Could not import extension %s') % extname, err)
406 
407             setup = getattr(mod, 'setup', None)
408             if setup is None:
409                 logger.warning(__('extension %r has no setup() function; is it really '
410                                   'a Sphinx extension module?'), extname)
411                 metadata = {}  # type: Dict[str, Any]
412             else:
413                 try:
414                     metadata = setup(app)
415                 except VersionRequirementError as err:
416                     # add the extension name to the version required
417                     raise VersionRequirementError(
418                         __('The %s extension used by this project needs at least '
419                            'Sphinx v%s; it therefore cannot be built with this '
420                            'version.') % (extname, err)
421                     )
422 
423             if metadata is None:
424                 metadata = {}
425             elif not isinstance(metadata, dict):
426                 logger.warning(__('extension %r returned an unsupported object from '
427                                   'its setup() function; it should return None or a '
428                                   'metadata dictionary'), extname)
429                 metadata = {}
430 
431             app.extensions[extname] = Extension(extname, mod, **metadata)
432 
433     def get_envversion(self, app: "Sphinx") -> Dict[str, str]:
434         from sphinx.environment import ENV_VERSION
435         envversion = {ext.name: ext.metadata['env_version'] for ext in app.extensions.values()
436                       if ext.metadata.get('env_version')}
437         envversion['sphinx'] = ENV_VERSION
438         return envversion
439 
440 
441 def merge_source_suffix(app: "Sphinx", config: Config) -> None:
442     """Merge source_suffix which specified by user and added by extensions."""
443     for suffix, filetype in app.registry.source_suffix.items():
444         if suffix not in app.config.source_suffix:
445             app.config.source_suffix[suffix] = filetype
446         elif app.config.source_suffix[suffix] is None:
447             # filetype is not specified (default filetype).
448             # So it overrides default filetype by extensions setting.
449             app.config.source_suffix[suffix] = filetype
450 
451     # copy config.source_suffix to registry
452     app.registry.source_suffix = app.config.source_suffix
453 
454 
455 def setup(app: "Sphinx") -> Dict[str, Any]:
456     app.connect('config-inited', merge_source_suffix)
457 
458     return {
459         'version': 'builtin',
460         'parallel_read_safe': True,
461         'parallel_write_safe': True,
462     }

</code><intended_behavior>Ensure that the method responsible for registering new parsers, such as .md parsers, correctly respects the file extension preferences specified in the configuration. This might involve adjusting how Sphinx prioritizes file extensions when multiple parsers are capable of processing a given file.</intended_behavior>]
2025-10-15 11:40:00.436 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 11:40:00.436 | INFO     | Search-only: skipping patch selection
2025-10-15 11:40:00.506 | INFO     | Task sphinx-doc__sphinx-7351 completed successfully.
2025-10-15 11:40:00.507 | INFO     | No patch generated. You can try running ACR again.
