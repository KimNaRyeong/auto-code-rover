diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -1103,6 +1103,16 @@ class CommaSeparatedIntegerField(CharField):
     }
 
 
+def _to_naive(value):
+    if timezone.is_aware(value):
+        value = timezone.make_naive(value, timezone.utc)
+    return value
+
+
+def _get_naive_now():
+    return _to_naive(timezone.now())
+
+
 class DateTimeCheckMixin:
 
     def check(self, **kwargs):
@@ -1134,6 +1144,42 @@ def _check_mutually_exclusive_options(self):
     def _check_fix_default_value(self):
         return []
 
+    # Concrete subclasses use this in their implementations of
+    # _check_fix_default_value().
+    def _check_if_value_fixed(self, value, now=None):
+        """
+        Check if the given value appears to have been provided as a "fixed"
+        time value, and include a warning in the returned list if it does. The
+        value argument must be a date object or aware/naive datetime object. If
+        now is provided, it must be a naive datetime object.
+        """
+        if now is None:
+            now = _get_naive_now()
+        offset = datetime.timedelta(seconds=10)
+        lower = now - offset
+        upper = now + offset
+        if isinstance(value, datetime.datetime):
+            value = _to_naive(value)
+        else:
+            assert isinstance(value, datetime.date)
+            lower = lower.date()
+            upper = upper.date()
+        if lower <= value <= upper:
+            return [
+                checks.Warning(
+                    'Fixed default value provided.',
+                    hint=(
+                        'It seems you set a fixed date / time / datetime '
+                        'value as default for this field. This may not be '
+                        'what you want. If you want to have the current date '
+                        'as default, use `django.utils.timezone.now`'
+                    ),
+                    obj=self,
+                    id='fields.W161',
+                )
+            ]
+        return []
+
 
 class DateField(DateTimeCheckMixin, Field):
     empty_strings_allowed = False
@@ -1161,37 +1207,16 @@ def _check_fix_default_value(self):
         if not self.has_default():
             return []
 
-        now = timezone.now()
-        if not timezone.is_naive(now):
-            now = timezone.make_naive(now, timezone.utc)
         value = self.default
         if isinstance(value, datetime.datetime):
-            if not timezone.is_naive(value):
-                value = timezone.make_naive(value, timezone.utc)
-            value = value.date()
+            value = _to_naive(value).date()
         elif isinstance(value, datetime.date):
-            # Nothing to do, as dates don't have tz information
             pass
         else:
             # No explicit date / datetime value -- no checks necessary
             return []
-        offset = datetime.timedelta(days=1)
-        lower = (now - offset).date()
-        upper = (now + offset).date()
-        if lower <= value <= upper:
-            return [
-                checks.Warning(
-                    'Fixed default value provided.',
-                    hint='It seems you set a fixed date / time / datetime '
-                         'value as default for this field. This may not be '
-                         'what you want. If you want to have the current date '
-                         'as default, use `django.utils.timezone.now`',
-                    obj=self,
-                    id='fields.W161',
-                )
-            ]
-
-        return []
+        # At this point, value is a date object.
+        return self._check_if_value_fixed(value)
 
     def deconstruct(self):
         name, path, args, kwargs = super().deconstruct()
@@ -1301,39 +1326,10 @@ def _check_fix_default_value(self):
         if not self.has_default():
             return []
 
-        now = timezone.now()
-        if not timezone.is_naive(now):
-            now = timezone.make_naive(now, timezone.utc)
         value = self.default
-        if isinstance(value, datetime.datetime):
-            second_offset = datetime.timedelta(seconds=10)
-            lower = now - second_offset
-            upper = now + second_offset
-            if timezone.is_aware(value):
-                value = timezone.make_naive(value, timezone.utc)
-        elif isinstance(value, datetime.date):
-            second_offset = datetime.timedelta(seconds=10)
-            lower = now - second_offset
-            lower = datetime.datetime(lower.year, lower.month, lower.day)
-            upper = now + second_offset
-            upper = datetime.datetime(upper.year, upper.month, upper.day)
-            value = datetime.datetime(value.year, value.month, value.day)
-        else:
-            # No explicit date / datetime value -- no checks necessary
-            return []
-        if lower <= value <= upper:
-            return [
-                checks.Warning(
-                    'Fixed default value provided.',
-                    hint='It seems you set a fixed date / time / datetime '
-                         'value as default for this field. This may not be '
-                         'what you want. If you want to have the current date '
-                         'as default, use `django.utils.timezone.now`',
-                    obj=self,
-                    id='fields.W161',
-                )
-            ]
-
+        if isinstance(value, (datetime.datetime, datetime.date)):
+            return self._check_if_value_fixed(value)
+        # No explicit date / datetime value -- no checks necessary.
         return []
 
     def get_internal_type(self):
@@ -2197,40 +2193,19 @@ def _check_fix_default_value(self):
         if not self.has_default():
             return []
 
-        now = timezone.now()
-        if not timezone.is_naive(now):
-            now = timezone.make_naive(now, timezone.utc)
         value = self.default
         if isinstance(value, datetime.datetime):
-            second_offset = datetime.timedelta(seconds=10)
-            lower = now - second_offset
-            upper = now + second_offset
-            if timezone.is_aware(value):
-                value = timezone.make_naive(value, timezone.utc)
+            now = None
         elif isinstance(value, datetime.time):
-            second_offset = datetime.timedelta(seconds=10)
-            lower = now - second_offset
-            upper = now + second_offset
+            now = _get_naive_now()
+            # This will not use the right date in the race condition where now
+            # is just before the date change and value is just past 0:00.
             value = datetime.datetime.combine(now.date(), value)
-            if timezone.is_aware(value):
-                value = timezone.make_naive(value, timezone.utc).time()
         else:
             # No explicit time / datetime value -- no checks necessary
             return []
-        if lower <= value <= upper:
-            return [
-                checks.Warning(
-                    'Fixed default value provided.',
-                    hint='It seems you set a fixed date / time / datetime '
-                         'value as default for this field. This may not be '
-                         'what you want. If you want to have the current date '
-                         'as default, use `django.utils.timezone.now`',
-                    obj=self,
-                    id='fields.W161',
-                )
-            ]
-
-        return []
+        # At this point, value is a datetime object.
+        return self._check_if_value_fixed(value, now=now)
 
     def deconstruct(self):
         name, path, args, kwargs = super().deconstruct()
