[
    {
        "rel_file_path": "django/contrib/auth/migrations/0011_update_proxy_permissions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/migrations/0011_update_proxy_permissions.py",
        "start": 18,
        "end": 50,
        "class_name": null,
        "method_name": "update_proxy_model_permissions",
        "code": "18 def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n19     \"\"\"\n20     Update the content_type of proxy model permissions to use the ContentType\n21     of the proxy model.\n22     \"\"\"\n23     style = color_style()\n24     Permission = apps.get_model('auth', 'Permission')\n25     ContentType = apps.get_model('contenttypes', 'ContentType')\n26     for Model in apps.get_models():\n27         opts = Model._meta\n28         if not opts.proxy:\n29             continue\n30         proxy_default_permissions_codenames = [\n31             '%s_%s' % (action, opts.model_name)\n32             for action in opts.default_permissions\n33         ]\n34         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n35         for codename, name in opts.permissions:\n36             permissions_query = permissions_query | Q(codename=codename, name=name)\n37         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n38         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n39         old_content_type = proxy_content_type if reverse else concrete_content_type\n40         new_content_type = concrete_content_type if reverse else proxy_content_type\n41         try:\n42             with transaction.atomic():\n43                 Permission.objects.filter(\n44                     permissions_query,\n45                     content_type=old_content_type,\n46                 ).update(content_type=new_content_type)\n47         except IntegrityError:\n48             old = '{}_{}'.format(old_content_type.app_label, old_content_type.model)\n49             new = '{}_{}'.format(new_content_type.app_label, new_content_type.model)\n50             sys.stdout.write(style.WARNING(WARNING.format(old=old, new=new, query=permissions_query)))\n",
        "intended_behavior": "This code block should target the correct database for operations on the Permission model in a multi-database setup. Django's database routing logic should be leveraged to determine the appropriate database for executing these operations, or the database should be explicitly specified if Django's default behavior does not select the correct one. An approach could involve using Django's database routing mechanisms to explicitly specify the database alias in .using(alias) for the Permission.objects.filter(...) query to ensure it is executed against the intended database. Preserve existing functionality by ensuring that Permission objects related to proxy models are correctly updated, irrespective of the database configuration. This means the patch must not affect single database setups or multi-database setups where a default database is correctly specified and used."
    },
    {
        "rel_file_path": "django/db/transaction.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/transaction.py",
        "start": 285,
        "end": 292,
        "class_name": null,
        "method_name": "atomic",
        "code": "285 def atomic(using=None, savepoint=True):\n286     # Bare decorator: @atomic -- although the first argument is called\n287     # `using`, it's actually the function being decorated.\n288     if callable(using):\n289         return Atomic(DEFAULT_DB_ALIAS, savepoint)(using)\n290     # Decorator: @atomic(...) or context manager: with atomic(...): ...\n291     else:\n292         return Atomic(using, savepoint)\n",
        "intended_behavior": "While the atomic function itself is not faulty, enhancing its documentation or supporting mechanisms to highlight considerations or recommended practices for multi-database transactions in migrations might be beneficial. Specifically, elucidate on the usage of using parameter to enforce atomic blocks on a specific database in a multi-database setup, especially in the context of migrations which might not straightforwardly deduce the correct database. This enhancement aims to improve developer awareness and prevent misuse or confusion in similar scenarios, though it directly does not alter the functionality."
    }
]