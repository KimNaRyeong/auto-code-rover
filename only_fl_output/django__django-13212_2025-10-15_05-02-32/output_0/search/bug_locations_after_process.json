[
    {
        "rel_file_path": "django/core/validators.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/validators.py",
        "start": 1,
        "end": 560,
        "class_name": null,
        "method_name": null,
        "code": "1 import ipaddress\n2 import re\n3 import warnings\n4 from pathlib import Path\n5 from urllib.parse import urlsplit, urlunsplit\n6 \n7 from django.core.exceptions import ValidationError\n8 from django.utils.deconstruct import deconstructible\n9 from django.utils.deprecation import RemovedInDjango41Warning\n10 from django.utils.encoding import punycode\n11 from django.utils.ipv6 import is_valid_ipv6_address\n12 from django.utils.regex_helper import _lazy_re_compile\n13 from django.utils.translation import gettext_lazy as _, ngettext_lazy\n14 \n15 # These values, if given to validate(), will trigger the self.required check.\n16 EMPTY_VALUES = (None, '', [], (), {})\n17 \n18 \n19 @deconstructible\n20 class RegexValidator:\n21     regex = ''\n22     message = _('Enter a valid value.')\n23     code = 'invalid'\n24     inverse_match = False\n25     flags = 0\n26 \n27     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):\n28         if regex is not None:\n29             self.regex = regex\n30         if message is not None:\n31             self.message = message\n32         if code is not None:\n33             self.code = code\n34         if inverse_match is not None:\n35             self.inverse_match = inverse_match\n36         if flags is not None:\n37             self.flags = flags\n38         if self.flags and not isinstance(self.regex, str):\n39             raise TypeError(\"If the flags are set, regex must be a regular expression string.\")\n40 \n41         self.regex = _lazy_re_compile(self.regex, self.flags)\n42 \n43     def __call__(self, value):\n44         \"\"\"\n45         Validate that the input contains (or does *not* contain, if\n46         inverse_match is True) a match for the regular expression.\n47         \"\"\"\n48         regex_matches = self.regex.search(str(value))\n49         invalid_input = regex_matches if self.inverse_match else not regex_matches\n50         if invalid_input:\n51             raise ValidationError(self.message, code=self.code)\n52 \n53     def __eq__(self, other):\n54         return (\n55             isinstance(other, RegexValidator) and\n56             self.regex.pattern == other.regex.pattern and\n57             self.regex.flags == other.regex.flags and\n58             (self.message == other.message) and\n59             (self.code == other.code) and\n60             (self.inverse_match == other.inverse_match)\n61         )\n62 \n63 \n64 @deconstructible\n65 class URLValidator(RegexValidator):\n66     ul = '\\u00a1-\\uffff'  # Unicode letters range (must not be a raw string).\n67 \n68     # IP patterns\n69     ipv4_re = r'(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}'\n70     ipv6_re = r'\\[[0-9a-f:.]+\\]'  # (simple regex, validated later)\n71 \n72     # Host patterns\n73     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'\n74     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1\n75     domain_re = r'(?:\\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'\n76     tld_re = (\n77         r'\\.'                                # dot\n78         r'(?!-)'                             # can't start with a dash\n79         r'(?:[a-z' + ul + '-]{2,63}'         # domain label\n80         r'|xn--[a-z0-9]{1,59})'              # or punycode label\n81         r'(?<!-)'                            # can't end with a dash\n82         r'\\.?'                               # may have a trailing dot\n83     )\n84     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n85 \n86     regex = _lazy_re_compile(\n87         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately\n88         r'(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?'  # user:pass authentication\n89         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n90         r'(?::\\d{2,5})?'  # port\n91         r'(?:[/?#][^\\s]*)?'  # resource path\n92         r'\\Z', re.IGNORECASE)\n93     message = _('Enter a valid URL.')\n94     schemes = ['http', 'https', 'ftp', 'ftps']\n95 \n96     def __init__(self, schemes=None, **kwargs):\n97         super().__init__(**kwargs)\n98         if schemes is not None:\n99             self.schemes = schemes\n100 \n101     def __call__(self, value):\n102         if not isinstance(value, str):\n103             raise ValidationError(self.message, code=self.code)\n104         # Check if the scheme is valid.\n105         scheme = value.split('://')[0].lower()\n106         if scheme not in self.schemes:\n107             raise ValidationError(self.message, code=self.code)\n108 \n109         # Then check full URL\n110         try:\n111             super().__call__(value)\n112         except ValidationError as e:\n113             # Trivial case failed. Try for possible IDN domain\n114             if value:\n115                 try:\n116                     scheme, netloc, path, query, fragment = urlsplit(value)\n117                 except ValueError:  # for example, \"Invalid IPv6 URL\"\n118                     raise ValidationError(self.message, code=self.code)\n119                 try:\n120                     netloc = punycode(netloc)  # IDN -> ACE\n121                 except UnicodeError:  # invalid domain part\n122                     raise e\n123                 url = urlunsplit((scheme, netloc, path, query, fragment))\n124                 super().__call__(url)\n125             else:\n126                 raise\n127         else:\n128             # Now verify IPv6 in the netloc part\n129             host_match = re.search(r'^\\[(.+)\\](?::\\d{2,5})?$', urlsplit(value).netloc)\n130             if host_match:\n131                 potential_ip = host_match[1]\n132                 try:\n133                     validate_ipv6_address(potential_ip)\n134                 except ValidationError:\n135                     raise ValidationError(self.message, code=self.code)\n136 \n137         # The maximum length of a full host name is 253 characters per RFC 1034\n138         # section 3.1. It's defined to be 255 bytes or less, but this includes\n139         # one byte for the length of the name and one byte for the trailing dot\n140         # that's used to indicate absolute names in DNS.\n141         if len(urlsplit(value).netloc) > 253:\n142             raise ValidationError(self.message, code=self.code)\n143 \n144 \n145 integer_validator = RegexValidator(\n146     _lazy_re_compile(r'^-?\\d+\\Z'),\n147     message=_('Enter a valid integer.'),\n148     code='invalid',\n149 )\n150 \n151 \n152 def validate_integer(value):\n153     return integer_validator(value)\n154 \n155 \n156 @deconstructible\n157 class EmailValidator:\n158     message = _('Enter a valid email address.')\n159     code = 'invalid'\n160     user_regex = _lazy_re_compile(\n161         r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\\Z\"  # dot-atom\n162         r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"\\Z)',  # quoted-string\n163         re.IGNORECASE)\n164     domain_regex = _lazy_re_compile(\n165         # max length for domain name labels is 63 characters per RFC 1034\n166         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\\Z',\n167         re.IGNORECASE)\n168     literal_regex = _lazy_re_compile(\n169         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)\n170         r'\\[([A-f0-9:.]+)\\]\\Z',\n171         re.IGNORECASE)\n172     domain_allowlist = ['localhost']\n173 \n174     @property\n175     def domain_whitelist(self):\n176         warnings.warn(\n177             'The domain_whitelist attribute is deprecated in favor of '\n178             'domain_allowlist.',\n179             RemovedInDjango41Warning,\n180             stacklevel=2,\n181         )\n182         return self.domain_allowlist\n183 \n184     @domain_whitelist.setter\n185     def domain_whitelist(self, allowlist):\n186         warnings.warn(\n187             'The domain_whitelist attribute is deprecated in favor of '\n188             'domain_allowlist.',\n189             RemovedInDjango41Warning,\n190             stacklevel=2,\n191         )\n192         self.domain_allowlist = allowlist\n193 \n194     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):\n195         if whitelist is not None:\n196             allowlist = whitelist\n197             warnings.warn(\n198                 'The whitelist argument is deprecated in favor of allowlist.',\n199                 RemovedInDjango41Warning,\n200                 stacklevel=2,\n201             )\n202         if message is not None:\n203             self.message = message\n204         if code is not None:\n205             self.code = code\n206         if allowlist is not None:\n207             self.domain_allowlist = allowlist\n208 \n209     def __call__(self, value):\n210         if not value or '@' not in value:\n211             raise ValidationError(self.message, code=self.code)\n212 \n213         user_part, domain_part = value.rsplit('@', 1)\n214 \n215         if not self.user_regex.match(user_part):\n216             raise ValidationError(self.message, code=self.code)\n217 \n218         if (domain_part not in self.domain_allowlist and\n219                 not self.validate_domain_part(domain_part)):\n220             # Try for possible IDN domain-part\n221             try:\n222                 domain_part = punycode(domain_part)\n223             except UnicodeError:\n224                 pass\n225             else:\n226                 if self.validate_domain_part(domain_part):\n227                     return\n228             raise ValidationError(self.message, code=self.code)\n229 \n230     def validate_domain_part(self, domain_part):\n231         if self.domain_regex.match(domain_part):\n232             return True\n233 \n234         literal_match = self.literal_regex.match(domain_part)\n235         if literal_match:\n236             ip_address = literal_match[1]\n237             try:\n238                 validate_ipv46_address(ip_address)\n239                 return True\n240             except ValidationError:\n241                 pass\n242         return False\n243 \n244     def __eq__(self, other):\n245         return (\n246             isinstance(other, EmailValidator) and\n247             (self.domain_allowlist == other.domain_allowlist) and\n248             (self.message == other.message) and\n249             (self.code == other.code)\n250         )\n251 \n252 \n253 validate_email = EmailValidator()\n254 \n255 slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\\Z')\n256 validate_slug = RegexValidator(\n257     slug_re,\n258     # Translators: \"letters\" means latin letters: a-z and A-Z.\n259     _('Enter a valid \u201cslug\u201d consisting of letters, numbers, underscores or hyphens.'),\n260     'invalid'\n261 )\n262 \n263 slug_unicode_re = _lazy_re_compile(r'^[-\\w]+\\Z')\n264 validate_unicode_slug = RegexValidator(\n265     slug_unicode_re,\n266     _('Enter a valid \u201cslug\u201d consisting of Unicode letters, numbers, underscores, or hyphens.'),\n267     'invalid'\n268 )\n269 \n270 \n271 def validate_ipv4_address(value):\n272     try:\n273         ipaddress.IPv4Address(value)\n274     except ValueError:\n275         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')\n276 \n277 \n278 def validate_ipv6_address(value):\n279     if not is_valid_ipv6_address(value):\n280         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')\n281 \n282 \n283 def validate_ipv46_address(value):\n284     try:\n285         validate_ipv4_address(value)\n286     except ValidationError:\n287         try:\n288             validate_ipv6_address(value)\n289         except ValidationError:\n290             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')\n291 \n292 \n293 ip_address_validator_map = {\n294     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),\n295     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),\n296     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),\n297 }\n298 \n299 \n300 def ip_address_validators(protocol, unpack_ipv4):\n301     \"\"\"\n302     Depending on the given parameters, return the appropriate validators for\n303     the GenericIPAddressField.\n304     \"\"\"\n305     if protocol != 'both' and unpack_ipv4:\n306         raise ValueError(\n307             \"You can only use `unpack_ipv4` if `protocol` is set to 'both'\")\n308     try:\n309         return ip_address_validator_map[protocol.lower()]\n310     except KeyError:\n311         raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"\n312                          % (protocol, list(ip_address_validator_map)))\n313 \n314 \n315 def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):\n316     regexp = _lazy_re_compile(r'^%(neg)s\\d+(?:%(sep)s%(neg)s\\d+)*\\Z' % {\n317         'neg': '(-)?' if allow_negative else '',\n318         'sep': re.escape(sep),\n319     })\n320     return RegexValidator(regexp, message=message, code=code)\n321 \n322 \n323 validate_comma_separated_integer_list = int_list_validator(\n324     message=_('Enter only digits separated by commas.'),\n325 )\n326 \n327 \n328 @deconstructible\n329 class BaseValidator:\n330     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')\n331     code = 'limit_value'\n332 \n333     def __init__(self, limit_value, message=None):\n334         self.limit_value = limit_value\n335         if message:\n336             self.message = message\n337 \n338     def __call__(self, value):\n339         cleaned = self.clean(value)\n340         limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value\n341         params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}\n342         if self.compare(cleaned, limit_value):\n343             raise ValidationError(self.message, code=self.code, params=params)\n344 \n345     def __eq__(self, other):\n346         if not isinstance(other, self.__class__):\n347             return NotImplemented\n348         return (\n349             self.limit_value == other.limit_value and\n350             self.message == other.message and\n351             self.code == other.code\n352         )\n353 \n354     def compare(self, a, b):\n355         return a is not b\n356 \n357     def clean(self, x):\n358         return x\n359 \n360 \n361 @deconstructible\n362 class MaxValueValidator(BaseValidator):\n363     message = _('Ensure this value is less than or equal to %(limit_value)s.')\n364     code = 'max_value'\n365 \n366     def compare(self, a, b):\n367         return a > b\n368 \n369 \n370 @deconstructible\n371 class MinValueValidator(BaseValidator):\n372     message = _('Ensure this value is greater than or equal to %(limit_value)s.')\n373     code = 'min_value'\n374 \n375     def compare(self, a, b):\n376         return a < b\n377 \n378 \n379 @deconstructible\n380 class MinLengthValidator(BaseValidator):\n381     message = ngettext_lazy(\n382         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',\n383         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',\n384         'limit_value')\n385     code = 'min_length'\n386 \n387     def compare(self, a, b):\n388         return a < b\n389 \n390     def clean(self, x):\n391         return len(x)\n392 \n393 \n394 @deconstructible\n395 class MaxLengthValidator(BaseValidator):\n396     message = ngettext_lazy(\n397         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',\n398         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',\n399         'limit_value')\n400     code = 'max_length'\n401 \n402     def compare(self, a, b):\n403         return a > b\n404 \n405     def clean(self, x):\n406         return len(x)\n407 \n408 \n409 @deconstructible\n410 class DecimalValidator:\n411     \"\"\"\n412     Validate that the input does not exceed the maximum number of digits\n413     expected, otherwise raise ValidationError.\n414     \"\"\"\n415     messages = {\n416         'invalid': _('Enter a number.'),\n417         'max_digits': ngettext_lazy(\n418             'Ensure that there are no more than %(max)s digit in total.',\n419             'Ensure that there are no more than %(max)s digits in total.',\n420             'max'\n421         ),\n422         'max_decimal_places': ngettext_lazy(\n423             'Ensure that there are no more than %(max)s decimal place.',\n424             'Ensure that there are no more than %(max)s decimal places.',\n425             'max'\n426         ),\n427         'max_whole_digits': ngettext_lazy(\n428             'Ensure that there are no more than %(max)s digit before the decimal point.',\n429             'Ensure that there are no more than %(max)s digits before the decimal point.',\n430             'max'\n431         ),\n432     }\n433 \n434     def __init__(self, max_digits, decimal_places):\n435         self.max_digits = max_digits\n436         self.decimal_places = decimal_places\n437 \n438     def __call__(self, value):\n439         digit_tuple, exponent = value.as_tuple()[1:]\n440         if exponent in {'F', 'n', 'N'}:\n441             raise ValidationError(self.messages['invalid'])\n442         if exponent >= 0:\n443             # A positive exponent adds that many trailing zeros.\n444             digits = len(digit_tuple) + exponent\n445             decimals = 0\n446         else:\n447             # If the absolute value of the negative exponent is larger than the\n448             # number of digits, then it's the same as the number of digits,\n449             # because it'll consume all of the digits in digit_tuple and then\n450             # add abs(exponent) - len(digit_tuple) leading zeros after the\n451             # decimal point.\n452             if abs(exponent) > len(digit_tuple):\n453                 digits = decimals = abs(exponent)\n454             else:\n455                 digits = len(digit_tuple)\n456                 decimals = abs(exponent)\n457         whole_digits = digits - decimals\n458 \n459         if self.max_digits is not None and digits > self.max_digits:\n460             raise ValidationError(\n461                 self.messages['max_digits'],\n462                 code='max_digits',\n463                 params={'max': self.max_digits},\n464             )\n465         if self.decimal_places is not None and decimals > self.decimal_places:\n466             raise ValidationError(\n467                 self.messages['max_decimal_places'],\n468                 code='max_decimal_places',\n469                 params={'max': self.decimal_places},\n470             )\n471         if (self.max_digits is not None and self.decimal_places is not None and\n472                 whole_digits > (self.max_digits - self.decimal_places)):\n473             raise ValidationError(\n474                 self.messages['max_whole_digits'],\n475                 code='max_whole_digits',\n476                 params={'max': (self.max_digits - self.decimal_places)},\n477             )\n478 \n479     def __eq__(self, other):\n480         return (\n481             isinstance(other, self.__class__) and\n482             self.max_digits == other.max_digits and\n483             self.decimal_places == other.decimal_places\n484         )\n485 \n486 \n487 @deconstructible\n488 class FileExtensionValidator:\n489     message = _(\n490         'File extension \u201c%(extension)s\u201d is not allowed. '\n491         'Allowed extensions are: %(allowed_extensions)s.'\n492     )\n493     code = 'invalid_extension'\n494 \n495     def __init__(self, allowed_extensions=None, message=None, code=None):\n496         if allowed_extensions is not None:\n497             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]\n498         self.allowed_extensions = allowed_extensions\n499         if message is not None:\n500             self.message = message\n501         if code is not None:\n502             self.code = code\n503 \n504     def __call__(self, value):\n505         extension = Path(value.name).suffix[1:].lower()\n506         if self.allowed_extensions is not None and extension not in self.allowed_extensions:\n507             raise ValidationError(\n508                 self.message,\n509                 code=self.code,\n510                 params={\n511                     'extension': extension,\n512                     'allowed_extensions': ', '.join(self.allowed_extensions)\n513                 }\n514             )\n515 \n516     def __eq__(self, other):\n517         return (\n518             isinstance(other, self.__class__) and\n519             self.allowed_extensions == other.allowed_extensions and\n520             self.message == other.message and\n521             self.code == other.code\n522         )\n523 \n524 \n525 def get_available_image_extensions():\n526     try:\n527         from PIL import Image\n528     except ImportError:\n529         return []\n530     else:\n531         Image.init()\n532         return [ext.lower()[1:] for ext in Image.EXTENSION]\n533 \n534 \n535 def validate_image_file_extension(value):\n536     return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)\n537 \n538 \n539 @deconstructible\n540 class ProhibitNullCharactersValidator:\n541     \"\"\"Validate that the string doesn't contain the null character.\"\"\"\n542     message = _('Null characters are not allowed.')\n543     code = 'null_characters_not_allowed'\n544 \n545     def __init__(self, message=None, code=None):\n546         if message is not None:\n547             self.message = message\n548         if code is not None:\n549             self.code = code\n550 \n551     def __call__(self, value):\n552         if '\\x00' in str(value):\n553             raise ValidationError(self.message, code=self.code)\n554 \n555     def __eq__(self, other):\n556         return (\n557             isinstance(other, self.__class__) and\n558             self.message == other.message and\n559             self.code == other.code\n560         )\n",
        "intended_behavior": "This file likely contains the core logic for built-in validators used across Django. To resolve the issue, validators in this file should be enhanced to support custom error messages that can include the provided value. The mechanism for raising a `ValidationError` should be adjusted or extended to interpolate the provided value into the error message. This might involve modifying how `ValidationError` is instantiated by each validator to accept and insert the provided value into the error message, possibly through a placeholder mechanism or formatting method. The existing functionality for validation should be preserved, with the enhancement that error messages can now dynamically include the provided value that failed validation."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/forms/fields.py",
        "start": 47,
        "end": 207,
        "class_name": "Field",
        "method_name": null,
        "code": "47 class Field:\n48     widget = TextInput  # Default widget to use when rendering this type of Field.\n49     hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\n50     default_validators = []  # Default set of validators\n51     # Add an 'invalid' entry to default_error_message if you want a specific\n52     # field error message not raised by the field validators.\n53     default_error_messages = {\n54         'required': _('This field is required.'),\n55     }\n56     empty_values = list(validators.EMPTY_VALUES)\n57 \n58     def __init__(self, *, required=True, widget=None, label=None, initial=None,\n59                  help_text='', error_messages=None, show_hidden_initial=False,\n60                  validators=(), localize=False, disabled=False, label_suffix=None):\n61         # required -- Boolean that specifies whether the field is required.\n62         #             True by default.\n63         # widget -- A Widget class, or instance of a Widget class, that should\n64         #           be used for this Field when displaying it. Each Field has a\n65         #           default Widget that it'll use if you don't specify this. In\n66         #           most cases, the default widget is TextInput.\n67         # label -- A verbose name for this field, for use in displaying this\n68         #          field in a form. By default, Django will use a \"pretty\"\n69         #          version of the form field name, if the Field is part of a\n70         #          Form.\n71         # initial -- A value to use in this Field's initial display. This value\n72         #            is *not* used as a fallback if data isn't given.\n73         # help_text -- An optional string to use as \"help text\" for this Field.\n74         # error_messages -- An optional dictionary to override the default\n75         #                   messages that the field will raise.\n76         # show_hidden_initial -- Boolean that specifies if it is needed to render a\n77         #                        hidden widget with initial value after widget.\n78         # validators -- List of additional validators to use\n79         # localize -- Boolean that specifies if the field should be localized.\n80         # disabled -- Boolean that specifies whether the field is disabled, that\n81         #             is its widget is shown in the form but not editable.\n82         # label_suffix -- Suffix to be added to the label. Overrides\n83         #                 form's label_suffix.\n84         self.required, self.label, self.initial = required, label, initial\n85         self.show_hidden_initial = show_hidden_initial\n86         self.help_text = help_text\n87         self.disabled = disabled\n88         self.label_suffix = label_suffix\n89         widget = widget or self.widget\n90         if isinstance(widget, type):\n91             widget = widget()\n92         else:\n93             widget = copy.deepcopy(widget)\n94 \n95         # Trigger the localization machinery if needed.\n96         self.localize = localize\n97         if self.localize:\n98             widget.is_localized = True\n99 \n100         # Let the widget know whether it should display as required.\n101         widget.is_required = self.required\n102 \n103         # Hook into self.widget_attrs() for any Field-specific HTML attributes.\n104         extra_attrs = self.widget_attrs(widget)\n105         if extra_attrs:\n106             widget.attrs.update(extra_attrs)\n107 \n108         self.widget = widget\n109 \n110         messages = {}\n111         for c in reversed(self.__class__.__mro__):\n112             messages.update(getattr(c, 'default_error_messages', {}))\n113         messages.update(error_messages or {})\n114         self.error_messages = messages\n115 \n116         self.validators = [*self.default_validators, *validators]\n117 \n118         super().__init__()\n119 \n120     def prepare_value(self, value):\n121         return value\n122 \n123     def to_python(self, value):\n124         return value\n125 \n126     def validate(self, value):\n127         if value in self.empty_values and self.required:\n128             raise ValidationError(self.error_messages['required'], code='required')\n129 \n130     def run_validators(self, value):\n131         if value in self.empty_values:\n132             return\n133         errors = []\n134         for v in self.validators:\n135             try:\n136                 v(value)\n137             except ValidationError as e:\n138                 if hasattr(e, 'code') and e.code in self.error_messages:\n139                     e.message = self.error_messages[e.code]\n140                 errors.extend(e.error_list)\n141         if errors:\n142             raise ValidationError(errors)\n143 \n144     def clean(self, value):\n145         \"\"\"\n146         Validate the given value and return its \"cleaned\" value as an\n147         appropriate Python object. Raise ValidationError for any errors.\n148         \"\"\"\n149         value = self.to_python(value)\n150         self.validate(value)\n151         self.run_validators(value)\n152         return value\n153 \n154     def bound_data(self, data, initial):\n155         \"\"\"\n156         Return the value that should be shown for this field on render of a\n157         bound form, given the submitted POST data for the field and the initial\n158         data, if any.\n159 \n160         For most fields, this will simply be data; FileFields need to handle it\n161         a bit differently.\n162         \"\"\"\n163         if self.disabled:\n164             return initial\n165         return data\n166 \n167     def widget_attrs(self, widget):\n168         \"\"\"\n169         Given a Widget instance (*not* a Widget class), return a dictionary of\n170         any HTML attributes that should be added to the Widget, based on this\n171         Field.\n172         \"\"\"\n173         return {}\n174 \n175     def has_changed(self, initial, data):\n176         \"\"\"Return True if data differs from initial.\"\"\"\n177         # Always return False if the field is disabled since self.bound_data\n178         # always uses the initial value in this case.\n179         if self.disabled:\n180             return False\n181         try:\n182             data = self.to_python(data)\n183             if hasattr(self, '_coerce'):\n184                 return self._coerce(data) != self._coerce(initial)\n185         except ValidationError:\n186             return True\n187         # For purposes of seeing whether something has changed, None is\n188         # the same as an empty string, if the data or initial value we get\n189         # is None, replace it with ''.\n190         initial_value = initial if initial is not None else ''\n191         data_value = data if data is not None else ''\n192         return initial_value != data_value\n193 \n194     def get_bound_field(self, form, field_name):\n195         \"\"\"\n196         Return a BoundField instance that will be used when accessing the form\n197         field in a template.\n198         \"\"\"\n199         return BoundField(form, self, field_name)\n200 \n201     def __deepcopy__(self, memo):\n202         result = copy.copy(self)\n203         memo[id(self)] = result\n204         result.widget = copy.deepcopy(self.widget, memo)\n205         result.error_messages = self.error_messages.copy()\n206         result.validators = self.validators[:]\n207         return result\n",
        "intended_behavior": "For form fields, especially those handling user inputs like email, customization of the `ValidationError` messages to include the input values requires adjustments at the field level. Methods responsible for field-specific validation within this class should be reviewed to ensure they can support including the provided value in any raised error messages. This might mean adjusting how these methods construct `ValidationError` instances or how they define error messages. The goal is to enable the use of placeholders or dynamic strings that can include the provided value, thus making error messages more informative. This should be done in a way that maintains backward compatibility and doesn't break existing custom validators or error message customizations."
    }
]