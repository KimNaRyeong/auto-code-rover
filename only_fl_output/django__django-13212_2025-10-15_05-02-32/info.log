2025-10-15 05:02:32.582 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 05:02:36.843 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=178, output_tokens=12, cost=0.002140
2025-10-15 05:02:36.844 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 05:02:36.848 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:02:43.448 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=487, output_tokens=245, cost=0.012220
2025-10-15 05:02:43.451 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:02:46.885 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=599, output_tokens=41, cost=0.007220
2025-10-15 05:02:46.886 | DEBUG    | Extracted a valid json.
2025-10-15 05:02:46.886 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ValidationError\")",
        "search_code(\"validators\")",
        "search_method(\"validate_email\")"
    ],
    "bug_locations": []
}
2025-10-15 05:02:47.265 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 05:02:47.266 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 05:03:04.782 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2072, output_tokens=763, cost=0.043610
2025-10-15 05:03:04.790 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:03:13.971 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3051, output_tokens=359, cost=0.041280
2025-10-15 05:03:13.974 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:03:23.692 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=713, output_tokens=336, cost=0.017210
2025-10-15 05:03:23.693 | DEBUG    | Extracted a valid json.
2025-10-15 05:03:23.693 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/validators.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely contains the core logic for built-in validators used across Django. To resolve the issue, validators in this file should be enhanced to support custom error messages that can include the provided value. The mechanism for raising a `ValidationError` should be adjusted or extended to interpolate the provided value into the error message. This might involve modifying how `ValidationError` is instantiated by each validator to accept and insert the provided value into the error message, possibly through a placeholder mechanism or formatting method. The existing functionality for validation should be preserved, with the enhancement that error messages can now dynamically include the provided value that failed validation."
        },
        {
            "file": "django/forms/fields.py",
            "class": "Field",
            "method": "various validation methods",
            "intended_behavior": "For form fields, especially those handling user inputs like email, customization of the `ValidationError` messages to include the input values requires adjustments at the field level. Methods responsible for field-specific validation within this class should be reviewed to ensure they can support including the provided value in any raised error messages. This might mean adjusting how these methods construct `ValidationError` instances or how they define error messages. The goal is to enable the use of placeholders or dynamic strings that can include the provided value, thus making error messages more informative. This should be done in a way that maintains backward compatibility and doesn't break existing custom validators or error message customizations."
        }
    ]
}
2025-10-15 05:03:23.701 | DEBUG    | Bug location extracted successfully: [<file>django/core/validators.py</file>
<class>None</class>
<method>None</method>
<code>
1 import ipaddress
2 import re
3 import warnings
4 from pathlib import Path
5 from urllib.parse import urlsplit, urlunsplit
6 
7 from django.core.exceptions import ValidationError
8 from django.utils.deconstruct import deconstructible
9 from django.utils.deprecation import RemovedInDjango41Warning
10 from django.utils.encoding import punycode
11 from django.utils.ipv6 import is_valid_ipv6_address
12 from django.utils.regex_helper import _lazy_re_compile
13 from django.utils.translation import gettext_lazy as _, ngettext_lazy
14 
15 # These values, if given to validate(), will trigger the self.required check.
16 EMPTY_VALUES = (None, '', [], (), {})
17 
18 
19 @deconstructible
20 class RegexValidator:
21     regex = ''
22     message = _('Enter a valid value.')
23     code = 'invalid'
24     inverse_match = False
25     flags = 0
26 
27     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):
28         if regex is not None:
29             self.regex = regex
30         if message is not None:
31             self.message = message
32         if code is not None:
33             self.code = code
34         if inverse_match is not None:
35             self.inverse_match = inverse_match
36         if flags is not None:
37             self.flags = flags
38         if self.flags and not isinstance(self.regex, str):
39             raise TypeError("If the flags are set, regex must be a regular expression string.")
40 
41         self.regex = _lazy_re_compile(self.regex, self.flags)
42 
43     def __call__(self, value):
44         """
45         Validate that the input contains (or does *not* contain, if
46         inverse_match is True) a match for the regular expression.
47         """
48         regex_matches = self.regex.search(str(value))
49         invalid_input = regex_matches if self.inverse_match else not regex_matches
50         if invalid_input:
51             raise ValidationError(self.message, code=self.code)
52 
53     def __eq__(self, other):
54         return (
55             isinstance(other, RegexValidator) and
56             self.regex.pattern == other.regex.pattern and
57             self.regex.flags == other.regex.flags and
58             (self.message == other.message) and
59             (self.code == other.code) and
60             (self.inverse_match == other.inverse_match)
61         )
62 
63 
64 @deconstructible
65 class URLValidator(RegexValidator):
66     ul = '\u00a1-\uffff'  # Unicode letters range (must not be a raw string).
67 
68     # IP patterns
69     ipv4_re = r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'
70     ipv6_re = r'\[[0-9a-f:.]+\]'  # (simple regex, validated later)
71 
72     # Host patterns
73     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'
74     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1
75     domain_re = r'(?:\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'
76     tld_re = (
77         r'\.'                                # dot
78         r'(?!-)'                             # can't start with a dash
79         r'(?:[a-z' + ul + '-]{2,63}'         # domain label
80         r'|xn--[a-z0-9]{1,59})'              # or punycode label
81         r'(?<!-)'                            # can't end with a dash
82         r'\.?'                               # may have a trailing dot
83     )
84     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
85 
86     regex = _lazy_re_compile(
87         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately
88         r'(?:[^\s:@/]+(?::[^\s:@/]*)?@)?'  # user:pass authentication
89         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
90         r'(?::\d{2,5})?'  # port
91         r'(?:[/?#][^\s]*)?'  # resource path
92         r'\Z', re.IGNORECASE)
93     message = _('Enter a valid URL.')
94     schemes = ['http', 'https', 'ftp', 'ftps']
95 
96     def __init__(self, schemes=None, **kwargs):
97         super().__init__(**kwargs)
98         if schemes is not None:
99             self.schemes = schemes
100 
101     def __call__(self, value):
102         if not isinstance(value, str):
103             raise ValidationError(self.message, code=self.code)
104         # Check if the scheme is valid.
105         scheme = value.split('://')[0].lower()
106         if scheme not in self.schemes:
107             raise ValidationError(self.message, code=self.code)
108 
109         # Then check full URL
110         try:
111             super().__call__(value)
112         except ValidationError as e:
113             # Trivial case failed. Try for possible IDN domain
114             if value:
115                 try:
116                     scheme, netloc, path, query, fragment = urlsplit(value)
117                 except ValueError:  # for example, "Invalid IPv6 URL"
118                     raise ValidationError(self.message, code=self.code)
119                 try:
120                     netloc = punycode(netloc)  # IDN -> ACE
121                 except UnicodeError:  # invalid domain part
122                     raise e
123                 url = urlunsplit((scheme, netloc, path, query, fragment))
124                 super().__call__(url)
125             else:
126                 raise
127         else:
128             # Now verify IPv6 in the netloc part
129             host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)
130             if host_match:
131                 potential_ip = host_match[1]
132                 try:
133                     validate_ipv6_address(potential_ip)
134                 except ValidationError:
135                     raise ValidationError(self.message, code=self.code)
136 
137         # The maximum length of a full host name is 253 characters per RFC 1034
138         # section 3.1. It's defined to be 255 bytes or less, but this includes
139         # one byte for the length of the name and one byte for the trailing dot
140         # that's used to indicate absolute names in DNS.
141         if len(urlsplit(value).netloc) > 253:
142             raise ValidationError(self.message, code=self.code)
143 
144 
145 integer_validator = RegexValidator(
146     _lazy_re_compile(r'^-?\d+\Z'),
147     message=_('Enter a valid integer.'),
148     code='invalid',
149 )
150 
151 
152 def validate_integer(value):
153     return integer_validator(value)
154 
155 
156 @deconstructible
157 class EmailValidator:
158     message = _('Enter a valid email address.')
159     code = 'invalid'
160     user_regex = _lazy_re_compile(
161         r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
162         r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
163         re.IGNORECASE)
164     domain_regex = _lazy_re_compile(
165         # max length for domain name labels is 63 characters per RFC 1034
166         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\Z',
167         re.IGNORECASE)
168     literal_regex = _lazy_re_compile(
169         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)
170         r'\[([A-f0-9:.]+)\]\Z',
171         re.IGNORECASE)
172     domain_allowlist = ['localhost']
173 
174     @property
175     def domain_whitelist(self):
176         warnings.warn(
177             'The domain_whitelist attribute is deprecated in favor of '
178             'domain_allowlist.',
179             RemovedInDjango41Warning,
180             stacklevel=2,
181         )
182         return self.domain_allowlist
183 
184     @domain_whitelist.setter
185     def domain_whitelist(self, allowlist):
186         warnings.warn(
187             'The domain_whitelist attribute is deprecated in favor of '
188             'domain_allowlist.',
189             RemovedInDjango41Warning,
190             stacklevel=2,
191         )
192         self.domain_allowlist = allowlist
193 
194     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):
195         if whitelist is not None:
196             allowlist = whitelist
197             warnings.warn(
198                 'The whitelist argument is deprecated in favor of allowlist.',
199                 RemovedInDjango41Warning,
200                 stacklevel=2,
201             )
202         if message is not None:
203             self.message = message
204         if code is not None:
205             self.code = code
206         if allowlist is not None:
207             self.domain_allowlist = allowlist
208 
209     def __call__(self, value):
210         if not value or '@' not in value:
211             raise ValidationError(self.message, code=self.code)
212 
213         user_part, domain_part = value.rsplit('@', 1)
214 
215         if not self.user_regex.match(user_part):
216             raise ValidationError(self.message, code=self.code)
217 
218         if (domain_part not in self.domain_allowlist and
219                 not self.validate_domain_part(domain_part)):
220             # Try for possible IDN domain-part
221             try:
222                 domain_part = punycode(domain_part)
223             except UnicodeError:
224                 pass
225             else:
226                 if self.validate_domain_part(domain_part):
227                     return
228             raise ValidationError(self.message, code=self.code)
229 
230     def validate_domain_part(self, domain_part):
231         if self.domain_regex.match(domain_part):
232             return True
233 
234         literal_match = self.literal_regex.match(domain_part)
235         if literal_match:
236             ip_address = literal_match[1]
237             try:
238                 validate_ipv46_address(ip_address)
239                 return True
240             except ValidationError:
241                 pass
242         return False
243 
244     def __eq__(self, other):
245         return (
246             isinstance(other, EmailValidator) and
247             (self.domain_allowlist == other.domain_allowlist) and
248             (self.message == other.message) and
249             (self.code == other.code)
250         )
251 
252 
253 validate_email = EmailValidator()
254 
255 slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\Z')
256 validate_slug = RegexValidator(
257     slug_re,
258     # Translators: "letters" means latin letters: a-z and A-Z.
259     _('Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.'),
260     'invalid'
261 )
262 
263 slug_unicode_re = _lazy_re_compile(r'^[-\w]+\Z')
264 validate_unicode_slug = RegexValidator(
265     slug_unicode_re,
266     _('Enter a valid “slug” consisting of Unicode letters, numbers, underscores, or hyphens.'),
267     'invalid'
268 )
269 
270 
271 def validate_ipv4_address(value):
272     try:
273         ipaddress.IPv4Address(value)
274     except ValueError:
275         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')
276 
277 
278 def validate_ipv6_address(value):
279     if not is_valid_ipv6_address(value):
280         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')
281 
282 
283 def validate_ipv46_address(value):
284     try:
285         validate_ipv4_address(value)
286     except ValidationError:
287         try:
288             validate_ipv6_address(value)
289         except ValidationError:
290             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')
291 
292 
293 ip_address_validator_map = {
294     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),
295     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),
296     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),
297 }
298 
299 
300 def ip_address_validators(protocol, unpack_ipv4):
301     """
302     Depending on the given parameters, return the appropriate validators for
303     the GenericIPAddressField.
304     """
305     if protocol != 'both' and unpack_ipv4:
306         raise ValueError(
307             "You can only use `unpack_ipv4` if `protocol` is set to 'both'")
308     try:
309         return ip_address_validator_map[protocol.lower()]
310     except KeyError:
311         raise ValueError("The protocol '%s' is unknown. Supported: %s"
312                          % (protocol, list(ip_address_validator_map)))
313 
314 
315 def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):
316     regexp = _lazy_re_compile(r'^%(neg)s\d+(?:%(sep)s%(neg)s\d+)*\Z' % {
317         'neg': '(-)?' if allow_negative else '',
318         'sep': re.escape(sep),
319     })
320     return RegexValidator(regexp, message=message, code=code)
321 
322 
323 validate_comma_separated_integer_list = int_list_validator(
324     message=_('Enter only digits separated by commas.'),
325 )
326 
327 
328 @deconstructible
329 class BaseValidator:
330     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')
331     code = 'limit_value'
332 
333     def __init__(self, limit_value, message=None):
334         self.limit_value = limit_value
335         if message:
336             self.message = message
337 
338     def __call__(self, value):
339         cleaned = self.clean(value)
340         limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value
341         params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}
342         if self.compare(cleaned, limit_value):
343             raise ValidationError(self.message, code=self.code, params=params)
344 
345     def __eq__(self, other):
346         if not isinstance(other, self.__class__):
347             return NotImplemented
348         return (
349             self.limit_value == other.limit_value and
350             self.message == other.message and
351             self.code == other.code
352         )
353 
354     def compare(self, a, b):
355         return a is not b
356 
357     def clean(self, x):
358         return x
359 
360 
361 @deconstructible
362 class MaxValueValidator(BaseValidator):
363     message = _('Ensure this value is less than or equal to %(limit_value)s.')
364     code = 'max_value'
365 
366     def compare(self, a, b):
367         return a > b
368 
369 
370 @deconstructible
371 class MinValueValidator(BaseValidator):
372     message = _('Ensure this value is greater than or equal to %(limit_value)s.')
373     code = 'min_value'
374 
375     def compare(self, a, b):
376         return a < b
377 
378 
379 @deconstructible
380 class MinLengthValidator(BaseValidator):
381     message = ngettext_lazy(
382         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',
383         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',
384         'limit_value')
385     code = 'min_length'
386 
387     def compare(self, a, b):
388         return a < b
389 
390     def clean(self, x):
391         return len(x)
392 
393 
394 @deconstructible
395 class MaxLengthValidator(BaseValidator):
396     message = ngettext_lazy(
397         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',
398         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',
399         'limit_value')
400     code = 'max_length'
401 
402     def compare(self, a, b):
403         return a > b
404 
405     def clean(self, x):
406         return len(x)
407 
408 
409 @deconstructible
410 class DecimalValidator:
411     """
412     Validate that the input does not exceed the maximum number of digits
413     expected, otherwise raise ValidationError.
414     """
415     messages = {
416         'invalid': _('Enter a number.'),
417         'max_digits': ngettext_lazy(
418             'Ensure that there are no more than %(max)s digit in total.',
419             'Ensure that there are no more than %(max)s digits in total.',
420             'max'
421         ),
422         'max_decimal_places': ngettext_lazy(
423             'Ensure that there are no more than %(max)s decimal place.',
424             'Ensure that there are no more than %(max)s decimal places.',
425             'max'
426         ),
427         'max_whole_digits': ngettext_lazy(
428             'Ensure that there are no more than %(max)s digit before the decimal point.',
429             'Ensure that there are no more than %(max)s digits before the decimal point.',
430             'max'
431         ),
432     }
433 
434     def __init__(self, max_digits, decimal_places):
435         self.max_digits = max_digits
436         self.decimal_places = decimal_places
437 
438     def __call__(self, value):
439         digit_tuple, exponent = value.as_tuple()[1:]
440         if exponent in {'F', 'n', 'N'}:
441             raise ValidationError(self.messages['invalid'])
442         if exponent >= 0:
443             # A positive exponent adds that many trailing zeros.
444             digits = len(digit_tuple) + exponent
445             decimals = 0
446         else:
447             # If the absolute value of the negative exponent is larger than the
448             # number of digits, then it's the same as the number of digits,
449             # because it'll consume all of the digits in digit_tuple and then
450             # add abs(exponent) - len(digit_tuple) leading zeros after the
451             # decimal point.
452             if abs(exponent) > len(digit_tuple):
453                 digits = decimals = abs(exponent)
454             else:
455                 digits = len(digit_tuple)
456                 decimals = abs(exponent)
457         whole_digits = digits - decimals
458 
459         if self.max_digits is not None and digits > self.max_digits:
460             raise ValidationError(
461                 self.messages['max_digits'],
462                 code='max_digits',
463                 params={'max': self.max_digits},
464             )
465         if self.decimal_places is not None and decimals > self.decimal_places:
466             raise ValidationError(
467                 self.messages['max_decimal_places'],
468                 code='max_decimal_places',
469                 params={'max': self.decimal_places},
470             )
471         if (self.max_digits is not None and self.decimal_places is not None and
472                 whole_digits > (self.max_digits - self.decimal_places)):
473             raise ValidationError(
474                 self.messages['max_whole_digits'],
475                 code='max_whole_digits',
476                 params={'max': (self.max_digits - self.decimal_places)},
477             )
478 
479     def __eq__(self, other):
480         return (
481             isinstance(other, self.__class__) and
482             self.max_digits == other.max_digits and
483             self.decimal_places == other.decimal_places
484         )
485 
486 
487 @deconstructible
488 class FileExtensionValidator:
489     message = _(
490         'File extension “%(extension)s” is not allowed. '
491         'Allowed extensions are: %(allowed_extensions)s.'
492     )
493     code = 'invalid_extension'
494 
495     def __init__(self, allowed_extensions=None, message=None, code=None):
496         if allowed_extensions is not None:
497             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]
498         self.allowed_extensions = allowed_extensions
499         if message is not None:
500             self.message = message
501         if code is not None:
502             self.code = code
503 
504     def __call__(self, value):
505         extension = Path(value.name).suffix[1:].lower()
506         if self.allowed_extensions is not None and extension not in self.allowed_extensions:
507             raise ValidationError(
508                 self.message,
509                 code=self.code,
510                 params={
511                     'extension': extension,
512                     'allowed_extensions': ', '.join(self.allowed_extensions)
513                 }
514             )
515 
516     def __eq__(self, other):
517         return (
518             isinstance(other, self.__class__) and
519             self.allowed_extensions == other.allowed_extensions and
520             self.message == other.message and
521             self.code == other.code
522         )
523 
524 
525 def get_available_image_extensions():
526     try:
527         from PIL import Image
528     except ImportError:
529         return []
530     else:
531         Image.init()
532         return [ext.lower()[1:] for ext in Image.EXTENSION]
533 
534 
535 def validate_image_file_extension(value):
536     return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)
537 
538 
539 @deconstructible
540 class ProhibitNullCharactersValidator:
541     """Validate that the string doesn't contain the null character."""
542     message = _('Null characters are not allowed.')
543     code = 'null_characters_not_allowed'
544 
545     def __init__(self, message=None, code=None):
546         if message is not None:
547             self.message = message
548         if code is not None:
549             self.code = code
550 
551     def __call__(self, value):
552         if '\x00' in str(value):
553             raise ValidationError(self.message, code=self.code)
554 
555     def __eq__(self, other):
556         return (
557             isinstance(other, self.__class__) and
558             self.message == other.message and
559             self.code == other.code
560         )

</code><intended_behavior>This file likely contains the core logic for built-in validators used across Django. To resolve the issue, validators in this file should be enhanced to support custom error messages that can include the provided value. The mechanism for raising a `ValidationError` should be adjusted or extended to interpolate the provided value into the error message. This might involve modifying how `ValidationError` is instantiated by each validator to accept and insert the provided value into the error message, possibly through a placeholder mechanism or formatting method. The existing functionality for validation should be preserved, with the enhancement that error messages can now dynamically include the provided value that failed validation.</intended_behavior>, <file>django/forms/fields.py</file>
<class>Field</class>
<method>None</method>
<code>
47 class Field:
48     widget = TextInput  # Default widget to use when rendering this type of Field.
49     hidden_widget = HiddenInput  # Default widget to use when rendering this as "hidden".
50     default_validators = []  # Default set of validators
51     # Add an 'invalid' entry to default_error_message if you want a specific
52     # field error message not raised by the field validators.
53     default_error_messages = {
54         'required': _('This field is required.'),
55     }
56     empty_values = list(validators.EMPTY_VALUES)
57 
58     def __init__(self, *, required=True, widget=None, label=None, initial=None,
59                  help_text='', error_messages=None, show_hidden_initial=False,
60                  validators=(), localize=False, disabled=False, label_suffix=None):
61         # required -- Boolean that specifies whether the field is required.
62         #             True by default.
63         # widget -- A Widget class, or instance of a Widget class, that should
64         #           be used for this Field when displaying it. Each Field has a
65         #           default Widget that it'll use if you don't specify this. In
66         #           most cases, the default widget is TextInput.
67         # label -- A verbose name for this field, for use in displaying this
68         #          field in a form. By default, Django will use a "pretty"
69         #          version of the form field name, if the Field is part of a
70         #          Form.
71         # initial -- A value to use in this Field's initial display. This value
72         #            is *not* used as a fallback if data isn't given.
73         # help_text -- An optional string to use as "help text" for this Field.
74         # error_messages -- An optional dictionary to override the default
75         #                   messages that the field will raise.
76         # show_hidden_initial -- Boolean that specifies if it is needed to render a
77         #                        hidden widget with initial value after widget.
78         # validators -- List of additional validators to use
79         # localize -- Boolean that specifies if the field should be localized.
80         # disabled -- Boolean that specifies whether the field is disabled, that
81         #             is its widget is shown in the form but not editable.
82         # label_suffix -- Suffix to be added to the label. Overrides
83         #                 form's label_suffix.
84         self.required, self.label, self.initial = required, label, initial
85         self.show_hidden_initial = show_hidden_initial
86         self.help_text = help_text
87         self.disabled = disabled
88         self.label_suffix = label_suffix
89         widget = widget or self.widget
90         if isinstance(widget, type):
91             widget = widget()
92         else:
93             widget = copy.deepcopy(widget)
94 
95         # Trigger the localization machinery if needed.
96         self.localize = localize
97         if self.localize:
98             widget.is_localized = True
99 
100         # Let the widget know whether it should display as required.
101         widget.is_required = self.required
102 
103         # Hook into self.widget_attrs() for any Field-specific HTML attributes.
104         extra_attrs = self.widget_attrs(widget)
105         if extra_attrs:
106             widget.attrs.update(extra_attrs)
107 
108         self.widget = widget
109 
110         messages = {}
111         for c in reversed(self.__class__.__mro__):
112             messages.update(getattr(c, 'default_error_messages', {}))
113         messages.update(error_messages or {})
114         self.error_messages = messages
115 
116         self.validators = [*self.default_validators, *validators]
117 
118         super().__init__()
119 
120     def prepare_value(self, value):
121         return value
122 
123     def to_python(self, value):
124         return value
125 
126     def validate(self, value):
127         if value in self.empty_values and self.required:
128             raise ValidationError(self.error_messages['required'], code='required')
129 
130     def run_validators(self, value):
131         if value in self.empty_values:
132             return
133         errors = []
134         for v in self.validators:
135             try:
136                 v(value)
137             except ValidationError as e:
138                 if hasattr(e, 'code') and e.code in self.error_messages:
139                     e.message = self.error_messages[e.code]
140                 errors.extend(e.error_list)
141         if errors:
142             raise ValidationError(errors)
143 
144     def clean(self, value):
145         """
146         Validate the given value and return its "cleaned" value as an
147         appropriate Python object. Raise ValidationError for any errors.
148         """
149         value = self.to_python(value)
150         self.validate(value)
151         self.run_validators(value)
152         return value
153 
154     def bound_data(self, data, initial):
155         """
156         Return the value that should be shown for this field on render of a
157         bound form, given the submitted POST data for the field and the initial
158         data, if any.
159 
160         For most fields, this will simply be data; FileFields need to handle it
161         a bit differently.
162         """
163         if self.disabled:
164             return initial
165         return data
166 
167     def widget_attrs(self, widget):
168         """
169         Given a Widget instance (*not* a Widget class), return a dictionary of
170         any HTML attributes that should be added to the Widget, based on this
171         Field.
172         """
173         return {}
174 
175     def has_changed(self, initial, data):
176         """Return True if data differs from initial."""
177         # Always return False if the field is disabled since self.bound_data
178         # always uses the initial value in this case.
179         if self.disabled:
180             return False
181         try:
182             data = self.to_python(data)
183             if hasattr(self, '_coerce'):
184                 return self._coerce(data) != self._coerce(initial)
185         except ValidationError:
186             return True
187         # For purposes of seeing whether something has changed, None is
188         # the same as an empty string, if the data or initial value we get
189         # is None, replace it with ''.
190         initial_value = initial if initial is not None else ''
191         data_value = data if data is not None else ''
192         return initial_value != data_value
193 
194     def get_bound_field(self, form, field_name):
195         """
196         Return a BoundField instance that will be used when accessing the form
197         field in a template.
198         """
199         return BoundField(form, self, field_name)
200 
201     def __deepcopy__(self, memo):
202         result = copy.copy(self)
203         memo[id(self)] = result
204         result.widget = copy.deepcopy(self.widget, memo)
205         result.error_messages = self.error_messages.copy()
206         result.validators = self.validators[:]
207         return result

</code><intended_behavior>For form fields, especially those handling user inputs like email, customization of the `ValidationError` messages to include the input values requires adjustments at the field level. Methods responsible for field-specific validation within this class should be reviewed to ensure they can support including the provided value in any raised error messages. This might mean adjusting how these methods construct `ValidationError` instances or how they define error messages. The goal is to enable the use of placeholders or dynamic strings that can include the provided value, thus making error messages more informative. This should be done in a way that maintains backward compatibility and doesn't break existing custom validators or error message customizations.</intended_behavior>]
2025-10-15 05:03:23.702 | INFO     | Search completed. Bug locations: [<file>django/core/validators.py</file>
<class>None</class>
<method>None</method>
<code>
1 import ipaddress
2 import re
3 import warnings
4 from pathlib import Path
5 from urllib.parse import urlsplit, urlunsplit
6 
7 from django.core.exceptions import ValidationError
8 from django.utils.deconstruct import deconstructible
9 from django.utils.deprecation import RemovedInDjango41Warning
10 from django.utils.encoding import punycode
11 from django.utils.ipv6 import is_valid_ipv6_address
12 from django.utils.regex_helper import _lazy_re_compile
13 from django.utils.translation import gettext_lazy as _, ngettext_lazy
14 
15 # These values, if given to validate(), will trigger the self.required check.
16 EMPTY_VALUES = (None, '', [], (), {})
17 
18 
19 @deconstructible
20 class RegexValidator:
21     regex = ''
22     message = _('Enter a valid value.')
23     code = 'invalid'
24     inverse_match = False
25     flags = 0
26 
27     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):
28         if regex is not None:
29             self.regex = regex
30         if message is not None:
31             self.message = message
32         if code is not None:
33             self.code = code
34         if inverse_match is not None:
35             self.inverse_match = inverse_match
36         if flags is not None:
37             self.flags = flags
38         if self.flags and not isinstance(self.regex, str):
39             raise TypeError("If the flags are set, regex must be a regular expression string.")
40 
41         self.regex = _lazy_re_compile(self.regex, self.flags)
42 
43     def __call__(self, value):
44         """
45         Validate that the input contains (or does *not* contain, if
46         inverse_match is True) a match for the regular expression.
47         """
48         regex_matches = self.regex.search(str(value))
49         invalid_input = regex_matches if self.inverse_match else not regex_matches
50         if invalid_input:
51             raise ValidationError(self.message, code=self.code)
52 
53     def __eq__(self, other):
54         return (
55             isinstance(other, RegexValidator) and
56             self.regex.pattern == other.regex.pattern and
57             self.regex.flags == other.regex.flags and
58             (self.message == other.message) and
59             (self.code == other.code) and
60             (self.inverse_match == other.inverse_match)
61         )
62 
63 
64 @deconstructible
65 class URLValidator(RegexValidator):
66     ul = '\u00a1-\uffff'  # Unicode letters range (must not be a raw string).
67 
68     # IP patterns
69     ipv4_re = r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'
70     ipv6_re = r'\[[0-9a-f:.]+\]'  # (simple regex, validated later)
71 
72     # Host patterns
73     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'
74     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1
75     domain_re = r'(?:\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'
76     tld_re = (
77         r'\.'                                # dot
78         r'(?!-)'                             # can't start with a dash
79         r'(?:[a-z' + ul + '-]{2,63}'         # domain label
80         r'|xn--[a-z0-9]{1,59})'              # or punycode label
81         r'(?<!-)'                            # can't end with a dash
82         r'\.?'                               # may have a trailing dot
83     )
84     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
85 
86     regex = _lazy_re_compile(
87         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately
88         r'(?:[^\s:@/]+(?::[^\s:@/]*)?@)?'  # user:pass authentication
89         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
90         r'(?::\d{2,5})?'  # port
91         r'(?:[/?#][^\s]*)?'  # resource path
92         r'\Z', re.IGNORECASE)
93     message = _('Enter a valid URL.')
94     schemes = ['http', 'https', 'ftp', 'ftps']
95 
96     def __init__(self, schemes=None, **kwargs):
97         super().__init__(**kwargs)
98         if schemes is not None:
99             self.schemes = schemes
100 
101     def __call__(self, value):
102         if not isinstance(value, str):
103             raise ValidationError(self.message, code=self.code)
104         # Check if the scheme is valid.
105         scheme = value.split('://')[0].lower()
106         if scheme not in self.schemes:
107             raise ValidationError(self.message, code=self.code)
108 
109         # Then check full URL
110         try:
111             super().__call__(value)
112         except ValidationError as e:
113             # Trivial case failed. Try for possible IDN domain
114             if value:
115                 try:
116                     scheme, netloc, path, query, fragment = urlsplit(value)
117                 except ValueError:  # for example, "Invalid IPv6 URL"
118                     raise ValidationError(self.message, code=self.code)
119                 try:
120                     netloc = punycode(netloc)  # IDN -> ACE
121                 except UnicodeError:  # invalid domain part
122                     raise e
123                 url = urlunsplit((scheme, netloc, path, query, fragment))
124                 super().__call__(url)
125             else:
126                 raise
127         else:
128             # Now verify IPv6 in the netloc part
129             host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)
130             if host_match:
131                 potential_ip = host_match[1]
132                 try:
133                     validate_ipv6_address(potential_ip)
134                 except ValidationError:
135                     raise ValidationError(self.message, code=self.code)
136 
137         # The maximum length of a full host name is 253 characters per RFC 1034
138         # section 3.1. It's defined to be 255 bytes or less, but this includes
139         # one byte for the length of the name and one byte for the trailing dot
140         # that's used to indicate absolute names in DNS.
141         if len(urlsplit(value).netloc) > 253:
142             raise ValidationError(self.message, code=self.code)
143 
144 
145 integer_validator = RegexValidator(
146     _lazy_re_compile(r'^-?\d+\Z'),
147     message=_('Enter a valid integer.'),
148     code='invalid',
149 )
150 
151 
152 def validate_integer(value):
153     return integer_validator(value)
154 
155 
156 @deconstructible
157 class EmailValidator:
158     message = _('Enter a valid email address.')
159     code = 'invalid'
160     user_regex = _lazy_re_compile(
161         r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
162         r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
163         re.IGNORECASE)
164     domain_regex = _lazy_re_compile(
165         # max length for domain name labels is 63 characters per RFC 1034
166         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\Z',
167         re.IGNORECASE)
168     literal_regex = _lazy_re_compile(
169         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)
170         r'\[([A-f0-9:.]+)\]\Z',
171         re.IGNORECASE)
172     domain_allowlist = ['localhost']
173 
174     @property
175     def domain_whitelist(self):
176         warnings.warn(
177             'The domain_whitelist attribute is deprecated in favor of '
178             'domain_allowlist.',
179             RemovedInDjango41Warning,
180             stacklevel=2,
181         )
182         return self.domain_allowlist
183 
184     @domain_whitelist.setter
185     def domain_whitelist(self, allowlist):
186         warnings.warn(
187             'The domain_whitelist attribute is deprecated in favor of '
188             'domain_allowlist.',
189             RemovedInDjango41Warning,
190             stacklevel=2,
191         )
192         self.domain_allowlist = allowlist
193 
194     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):
195         if whitelist is not None:
196             allowlist = whitelist
197             warnings.warn(
198                 'The whitelist argument is deprecated in favor of allowlist.',
199                 RemovedInDjango41Warning,
200                 stacklevel=2,
201             )
202         if message is not None:
203             self.message = message
204         if code is not None:
205             self.code = code
206         if allowlist is not None:
207             self.domain_allowlist = allowlist
208 
209     def __call__(self, value):
210         if not value or '@' not in value:
211             raise ValidationError(self.message, code=self.code)
212 
213         user_part, domain_part = value.rsplit('@', 1)
214 
215         if not self.user_regex.match(user_part):
216             raise ValidationError(self.message, code=self.code)
217 
218         if (domain_part not in self.domain_allowlist and
219                 not self.validate_domain_part(domain_part)):
220             # Try for possible IDN domain-part
221             try:
222                 domain_part = punycode(domain_part)
223             except UnicodeError:
224                 pass
225             else:
226                 if self.validate_domain_part(domain_part):
227                     return
228             raise ValidationError(self.message, code=self.code)
229 
230     def validate_domain_part(self, domain_part):
231         if self.domain_regex.match(domain_part):
232             return True
233 
234         literal_match = self.literal_regex.match(domain_part)
235         if literal_match:
236             ip_address = literal_match[1]
237             try:
238                 validate_ipv46_address(ip_address)
239                 return True
240             except ValidationError:
241                 pass
242         return False
243 
244     def __eq__(self, other):
245         return (
246             isinstance(other, EmailValidator) and
247             (self.domain_allowlist == other.domain_allowlist) and
248             (self.message == other.message) and
249             (self.code == other.code)
250         )
251 
252 
253 validate_email = EmailValidator()
254 
255 slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\Z')
256 validate_slug = RegexValidator(
257     slug_re,
258     # Translators: "letters" means latin letters: a-z and A-Z.
259     _('Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.'),
260     'invalid'
261 )
262 
263 slug_unicode_re = _lazy_re_compile(r'^[-\w]+\Z')
264 validate_unicode_slug = RegexValidator(
265     slug_unicode_re,
266     _('Enter a valid “slug” consisting of Unicode letters, numbers, underscores, or hyphens.'),
267     'invalid'
268 )
269 
270 
271 def validate_ipv4_address(value):
272     try:
273         ipaddress.IPv4Address(value)
274     except ValueError:
275         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')
276 
277 
278 def validate_ipv6_address(value):
279     if not is_valid_ipv6_address(value):
280         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')
281 
282 
283 def validate_ipv46_address(value):
284     try:
285         validate_ipv4_address(value)
286     except ValidationError:
287         try:
288             validate_ipv6_address(value)
289         except ValidationError:
290             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')
291 
292 
293 ip_address_validator_map = {
294     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),
295     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),
296     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),
297 }
298 
299 
300 def ip_address_validators(protocol, unpack_ipv4):
301     """
302     Depending on the given parameters, return the appropriate validators for
303     the GenericIPAddressField.
304     """
305     if protocol != 'both' and unpack_ipv4:
306         raise ValueError(
307             "You can only use `unpack_ipv4` if `protocol` is set to 'both'")
308     try:
309         return ip_address_validator_map[protocol.lower()]
310     except KeyError:
311         raise ValueError("The protocol '%s' is unknown. Supported: %s"
312                          % (protocol, list(ip_address_validator_map)))
313 
314 
315 def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):
316     regexp = _lazy_re_compile(r'^%(neg)s\d+(?:%(sep)s%(neg)s\d+)*\Z' % {
317         'neg': '(-)?' if allow_negative else '',
318         'sep': re.escape(sep),
319     })
320     return RegexValidator(regexp, message=message, code=code)
321 
322 
323 validate_comma_separated_integer_list = int_list_validator(
324     message=_('Enter only digits separated by commas.'),
325 )
326 
327 
328 @deconstructible
329 class BaseValidator:
330     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')
331     code = 'limit_value'
332 
333     def __init__(self, limit_value, message=None):
334         self.limit_value = limit_value
335         if message:
336             self.message = message
337 
338     def __call__(self, value):
339         cleaned = self.clean(value)
340         limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value
341         params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}
342         if self.compare(cleaned, limit_value):
343             raise ValidationError(self.message, code=self.code, params=params)
344 
345     def __eq__(self, other):
346         if not isinstance(other, self.__class__):
347             return NotImplemented
348         return (
349             self.limit_value == other.limit_value and
350             self.message == other.message and
351             self.code == other.code
352         )
353 
354     def compare(self, a, b):
355         return a is not b
356 
357     def clean(self, x):
358         return x
359 
360 
361 @deconstructible
362 class MaxValueValidator(BaseValidator):
363     message = _('Ensure this value is less than or equal to %(limit_value)s.')
364     code = 'max_value'
365 
366     def compare(self, a, b):
367         return a > b
368 
369 
370 @deconstructible
371 class MinValueValidator(BaseValidator):
372     message = _('Ensure this value is greater than or equal to %(limit_value)s.')
373     code = 'min_value'
374 
375     def compare(self, a, b):
376         return a < b
377 
378 
379 @deconstructible
380 class MinLengthValidator(BaseValidator):
381     message = ngettext_lazy(
382         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',
383         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',
384         'limit_value')
385     code = 'min_length'
386 
387     def compare(self, a, b):
388         return a < b
389 
390     def clean(self, x):
391         return len(x)
392 
393 
394 @deconstructible
395 class MaxLengthValidator(BaseValidator):
396     message = ngettext_lazy(
397         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',
398         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',
399         'limit_value')
400     code = 'max_length'
401 
402     def compare(self, a, b):
403         return a > b
404 
405     def clean(self, x):
406         return len(x)
407 
408 
409 @deconstructible
410 class DecimalValidator:
411     """
412     Validate that the input does not exceed the maximum number of digits
413     expected, otherwise raise ValidationError.
414     """
415     messages = {
416         'invalid': _('Enter a number.'),
417         'max_digits': ngettext_lazy(
418             'Ensure that there are no more than %(max)s digit in total.',
419             'Ensure that there are no more than %(max)s digits in total.',
420             'max'
421         ),
422         'max_decimal_places': ngettext_lazy(
423             'Ensure that there are no more than %(max)s decimal place.',
424             'Ensure that there are no more than %(max)s decimal places.',
425             'max'
426         ),
427         'max_whole_digits': ngettext_lazy(
428             'Ensure that there are no more than %(max)s digit before the decimal point.',
429             'Ensure that there are no more than %(max)s digits before the decimal point.',
430             'max'
431         ),
432     }
433 
434     def __init__(self, max_digits, decimal_places):
435         self.max_digits = max_digits
436         self.decimal_places = decimal_places
437 
438     def __call__(self, value):
439         digit_tuple, exponent = value.as_tuple()[1:]
440         if exponent in {'F', 'n', 'N'}:
441             raise ValidationError(self.messages['invalid'])
442         if exponent >= 0:
443             # A positive exponent adds that many trailing zeros.
444             digits = len(digit_tuple) + exponent
445             decimals = 0
446         else:
447             # If the absolute value of the negative exponent is larger than the
448             # number of digits, then it's the same as the number of digits,
449             # because it'll consume all of the digits in digit_tuple and then
450             # add abs(exponent) - len(digit_tuple) leading zeros after the
451             # decimal point.
452             if abs(exponent) > len(digit_tuple):
453                 digits = decimals = abs(exponent)
454             else:
455                 digits = len(digit_tuple)
456                 decimals = abs(exponent)
457         whole_digits = digits - decimals
458 
459         if self.max_digits is not None and digits > self.max_digits:
460             raise ValidationError(
461                 self.messages['max_digits'],
462                 code='max_digits',
463                 params={'max': self.max_digits},
464             )
465         if self.decimal_places is not None and decimals > self.decimal_places:
466             raise ValidationError(
467                 self.messages['max_decimal_places'],
468                 code='max_decimal_places',
469                 params={'max': self.decimal_places},
470             )
471         if (self.max_digits is not None and self.decimal_places is not None and
472                 whole_digits > (self.max_digits - self.decimal_places)):
473             raise ValidationError(
474                 self.messages['max_whole_digits'],
475                 code='max_whole_digits',
476                 params={'max': (self.max_digits - self.decimal_places)},
477             )
478 
479     def __eq__(self, other):
480         return (
481             isinstance(other, self.__class__) and
482             self.max_digits == other.max_digits and
483             self.decimal_places == other.decimal_places
484         )
485 
486 
487 @deconstructible
488 class FileExtensionValidator:
489     message = _(
490         'File extension “%(extension)s” is not allowed. '
491         'Allowed extensions are: %(allowed_extensions)s.'
492     )
493     code = 'invalid_extension'
494 
495     def __init__(self, allowed_extensions=None, message=None, code=None):
496         if allowed_extensions is not None:
497             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]
498         self.allowed_extensions = allowed_extensions
499         if message is not None:
500             self.message = message
501         if code is not None:
502             self.code = code
503 
504     def __call__(self, value):
505         extension = Path(value.name).suffix[1:].lower()
506         if self.allowed_extensions is not None and extension not in self.allowed_extensions:
507             raise ValidationError(
508                 self.message,
509                 code=self.code,
510                 params={
511                     'extension': extension,
512                     'allowed_extensions': ', '.join(self.allowed_extensions)
513                 }
514             )
515 
516     def __eq__(self, other):
517         return (
518             isinstance(other, self.__class__) and
519             self.allowed_extensions == other.allowed_extensions and
520             self.message == other.message and
521             self.code == other.code
522         )
523 
524 
525 def get_available_image_extensions():
526     try:
527         from PIL import Image
528     except ImportError:
529         return []
530     else:
531         Image.init()
532         return [ext.lower()[1:] for ext in Image.EXTENSION]
533 
534 
535 def validate_image_file_extension(value):
536     return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)
537 
538 
539 @deconstructible
540 class ProhibitNullCharactersValidator:
541     """Validate that the string doesn't contain the null character."""
542     message = _('Null characters are not allowed.')
543     code = 'null_characters_not_allowed'
544 
545     def __init__(self, message=None, code=None):
546         if message is not None:
547             self.message = message
548         if code is not None:
549             self.code = code
550 
551     def __call__(self, value):
552         if '\x00' in str(value):
553             raise ValidationError(self.message, code=self.code)
554 
555     def __eq__(self, other):
556         return (
557             isinstance(other, self.__class__) and
558             self.message == other.message and
559             self.code == other.code
560         )

</code><intended_behavior>This file likely contains the core logic for built-in validators used across Django. To resolve the issue, validators in this file should be enhanced to support custom error messages that can include the provided value. The mechanism for raising a `ValidationError` should be adjusted or extended to interpolate the provided value into the error message. This might involve modifying how `ValidationError` is instantiated by each validator to accept and insert the provided value into the error message, possibly through a placeholder mechanism or formatting method. The existing functionality for validation should be preserved, with the enhancement that error messages can now dynamically include the provided value that failed validation.</intended_behavior>, <file>django/forms/fields.py</file>
<class>Field</class>
<method>None</method>
<code>
47 class Field:
48     widget = TextInput  # Default widget to use when rendering this type of Field.
49     hidden_widget = HiddenInput  # Default widget to use when rendering this as "hidden".
50     default_validators = []  # Default set of validators
51     # Add an 'invalid' entry to default_error_message if you want a specific
52     # field error message not raised by the field validators.
53     default_error_messages = {
54         'required': _('This field is required.'),
55     }
56     empty_values = list(validators.EMPTY_VALUES)
57 
58     def __init__(self, *, required=True, widget=None, label=None, initial=None,
59                  help_text='', error_messages=None, show_hidden_initial=False,
60                  validators=(), localize=False, disabled=False, label_suffix=None):
61         # required -- Boolean that specifies whether the field is required.
62         #             True by default.
63         # widget -- A Widget class, or instance of a Widget class, that should
64         #           be used for this Field when displaying it. Each Field has a
65         #           default Widget that it'll use if you don't specify this. In
66         #           most cases, the default widget is TextInput.
67         # label -- A verbose name for this field, for use in displaying this
68         #          field in a form. By default, Django will use a "pretty"
69         #          version of the form field name, if the Field is part of a
70         #          Form.
71         # initial -- A value to use in this Field's initial display. This value
72         #            is *not* used as a fallback if data isn't given.
73         # help_text -- An optional string to use as "help text" for this Field.
74         # error_messages -- An optional dictionary to override the default
75         #                   messages that the field will raise.
76         # show_hidden_initial -- Boolean that specifies if it is needed to render a
77         #                        hidden widget with initial value after widget.
78         # validators -- List of additional validators to use
79         # localize -- Boolean that specifies if the field should be localized.
80         # disabled -- Boolean that specifies whether the field is disabled, that
81         #             is its widget is shown in the form but not editable.
82         # label_suffix -- Suffix to be added to the label. Overrides
83         #                 form's label_suffix.
84         self.required, self.label, self.initial = required, label, initial
85         self.show_hidden_initial = show_hidden_initial
86         self.help_text = help_text
87         self.disabled = disabled
88         self.label_suffix = label_suffix
89         widget = widget or self.widget
90         if isinstance(widget, type):
91             widget = widget()
92         else:
93             widget = copy.deepcopy(widget)
94 
95         # Trigger the localization machinery if needed.
96         self.localize = localize
97         if self.localize:
98             widget.is_localized = True
99 
100         # Let the widget know whether it should display as required.
101         widget.is_required = self.required
102 
103         # Hook into self.widget_attrs() for any Field-specific HTML attributes.
104         extra_attrs = self.widget_attrs(widget)
105         if extra_attrs:
106             widget.attrs.update(extra_attrs)
107 
108         self.widget = widget
109 
110         messages = {}
111         for c in reversed(self.__class__.__mro__):
112             messages.update(getattr(c, 'default_error_messages', {}))
113         messages.update(error_messages or {})
114         self.error_messages = messages
115 
116         self.validators = [*self.default_validators, *validators]
117 
118         super().__init__()
119 
120     def prepare_value(self, value):
121         return value
122 
123     def to_python(self, value):
124         return value
125 
126     def validate(self, value):
127         if value in self.empty_values and self.required:
128             raise ValidationError(self.error_messages['required'], code='required')
129 
130     def run_validators(self, value):
131         if value in self.empty_values:
132             return
133         errors = []
134         for v in self.validators:
135             try:
136                 v(value)
137             except ValidationError as e:
138                 if hasattr(e, 'code') and e.code in self.error_messages:
139                     e.message = self.error_messages[e.code]
140                 errors.extend(e.error_list)
141         if errors:
142             raise ValidationError(errors)
143 
144     def clean(self, value):
145         """
146         Validate the given value and return its "cleaned" value as an
147         appropriate Python object. Raise ValidationError for any errors.
148         """
149         value = self.to_python(value)
150         self.validate(value)
151         self.run_validators(value)
152         return value
153 
154     def bound_data(self, data, initial):
155         """
156         Return the value that should be shown for this field on render of a
157         bound form, given the submitted POST data for the field and the initial
158         data, if any.
159 
160         For most fields, this will simply be data; FileFields need to handle it
161         a bit differently.
162         """
163         if self.disabled:
164             return initial
165         return data
166 
167     def widget_attrs(self, widget):
168         """
169         Given a Widget instance (*not* a Widget class), return a dictionary of
170         any HTML attributes that should be added to the Widget, based on this
171         Field.
172         """
173         return {}
174 
175     def has_changed(self, initial, data):
176         """Return True if data differs from initial."""
177         # Always return False if the field is disabled since self.bound_data
178         # always uses the initial value in this case.
179         if self.disabled:
180             return False
181         try:
182             data = self.to_python(data)
183             if hasattr(self, '_coerce'):
184                 return self._coerce(data) != self._coerce(initial)
185         except ValidationError:
186             return True
187         # For purposes of seeing whether something has changed, None is
188         # the same as an empty string, if the data or initial value we get
189         # is None, replace it with ''.
190         initial_value = initial if initial is not None else ''
191         data_value = data if data is not None else ''
192         return initial_value != data_value
193 
194     def get_bound_field(self, form, field_name):
195         """
196         Return a BoundField instance that will be used when accessing the form
197         field in a template.
198         """
199         return BoundField(form, self, field_name)
200 
201     def __deepcopy__(self, memo):
202         result = copy.copy(self)
203         memo[id(self)] = result
204         result.widget = copy.deepcopy(self.widget, memo)
205         result.error_messages = self.error_messages.copy()
206         result.validators = self.validators[:]
207         return result

</code><intended_behavior>For form fields, especially those handling user inputs like email, customization of the `ValidationError` messages to include the input values requires adjustments at the field level. Methods responsible for field-specific validation within this class should be reviewed to ensure they can support including the provided value in any raised error messages. This might mean adjusting how these methods construct `ValidationError` instances or how they define error messages. The goal is to enable the use of placeholders or dynamic strings that can include the provided value, thus making error messages more informative. This should be done in a way that maintains backward compatibility and doesn't break existing custom validators or error message customizations.</intended_behavior>]
2025-10-15 05:03:23.702 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 05:03:23.702 | INFO     | Search-only: skipping patch selection
2025-10-15 05:03:23.853 | INFO     | Task django__django-13212 completed successfully.
2025-10-15 05:03:23.854 | INFO     | No patch generated. You can try running ACR again.
