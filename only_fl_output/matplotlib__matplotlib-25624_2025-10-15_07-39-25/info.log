2025-10-15 07:39:25.585 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:39:29.895 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=223, output_tokens=12, cost=0.002590
2025-10-15 07:39:42.918 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=403, output_tokens=549, cost=0.020500
2025-10-15 07:39:44.318 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:39:52.544 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=252, cost=0.012840
2025-10-15 07:39:52.549 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:39:56.000 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=606, output_tokens=31, cost=0.006990
2025-10-15 07:39:56.001 | DEBUG    | Extracted a valid json.
2025-10-15 07:39:56.001 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"tight_layout\")", "search_code(\"figure.autolayout\")"],
    "bug_locations": []
}
2025-10-15 07:39:56.062 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:39:56.062 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:40:17.885 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1098, output_tokens=699, cost=0.031950
2025-10-15 07:40:17.897 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:40:29.512 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2013, output_tokens=386, cost=0.031710
2025-10-15 07:40:29.521 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:40:38.927 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=740, output_tokens=336, cost=0.017480
2025-10-15 07:40:38.928 | DEBUG    | Extracted a valid json.
2025-10-15 07:40:38.929 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "tight_layout",
            "intended_behavior": "This method should be modified to check if `figure.autolayout` is set to `True` and either incorporate the `kwargs` from `tight_layout` into the automatic layout calculations or provide a clear warning to the user that `tight_layout` parameters will be ignored due to `figure.autolayout` being enabled. This adjustment ensures that there is no silent failure or unexpected behavior when users attempt to use `tight_layout` with `figure.autolayout` set to `True`. The existing functionality of automatically adjusting the layout when `autolayout` is enabled should be preserved, but an additional check or mechanism should be added to respect or acknowledge `tight_layout` kwargs when also used."
        },
        {
            "file": "lib/matplotlib/figure.py",
            "class": "",
            "method": "",
            "intended_behavior": "Any method or function within this file that reads or modifies the `figure.autolayout` setting needs to be reviewed to ensure it correctly handles situations where both `autolayout` and `tight_layout` are used. If `tight_layout` is called, the code should respect the explicit user request to adjust layout parameters manually, which may involve temporarily disabling `autolayout` or merging the settings with `tight_layout` kwargs. The balance between automatic and manual layout adjustments needs to be clear to users, either through documentation or runtime messages."
        }
    ]
}
2025-10-15 07:40:38.946 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>tight_layout</method>
<code>
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>This method should be modified to check if `figure.autolayout` is set to `True` and either incorporate the `kwargs` from `tight_layout` into the automatic layout calculations or provide a clear warning to the user that `tight_layout` parameters will be ignored due to `figure.autolayout` being enabled. This adjustment ensures that there is no silent failure or unexpected behavior when users attempt to use `tight_layout` with `figure.autolayout` set to `True`. The existing functionality of automatically adjusting the layout when `autolayout` is enabled should be preserved, but an additional check or mechanism should be added to respect or acknowledge `tight_layout` kwargs when also used.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2329 class Figure(FigureBase):
2330     """
2331     The top level container for all the plot elements.
2332 
2333     Attributes
2334     ----------
2335     patch
2336         The `.Rectangle` instance representing the figure background patch.
2337 
2338     suppressComposite
2339         For multiple images, the figure will make composite images
2340         depending on the renderer option_image_nocomposite function.  If
2341         *suppressComposite* is a boolean, this will override the renderer.
2342     """
2343     # Remove the self._fig_callbacks properties on figure and subfigure
2344     # after the deprecation expires.
2345     callbacks = _api.deprecated(
2346         "3.6", alternative=("the 'resize_event' signal in "
2347                             "Figure.canvas.callbacks")
2348         )(property(lambda self: self._fig_callbacks))
2349 
2350     def __str__(self):
2351         return "Figure(%gx%g)" % tuple(self.bbox.size)
2352 
2353     def __repr__(self):
2354         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2355             clsname=self.__class__.__name__,
2356             h=self.bbox.size[0], w=self.bbox.size[1],
2357             naxes=len(self.axes),
2358         )
2359 
2360     def __init__(self,
2361                  figsize=None,
2362                  dpi=None,
2363                  *,
2364                  facecolor=None,
2365                  edgecolor=None,
2366                  linewidth=0.0,
2367                  frameon=None,
2368                  subplotpars=None,  # rc figure.subplot.*
2369                  tight_layout=None,  # rc figure.autolayout
2370                  constrained_layout=None,  # rc figure.constrained_layout.use
2371                  layout=None,
2372                  **kwargs
2373                  ):
2374         """
2375         Parameters
2376         ----------
2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2378             Figure dimension ``(width, height)`` in inches.
2379 
2380         dpi : float, default: :rc:`figure.dpi`
2381             Dots per inch.
2382 
2383         facecolor : default: :rc:`figure.facecolor`
2384             The figure patch facecolor.
2385 
2386         edgecolor : default: :rc:`figure.edgecolor`
2387             The figure patch edge color.
2388 
2389         linewidth : float
2390             The linewidth of the frame (i.e. the edge linewidth of the figure
2391             patch).
2392 
2393         frameon : bool, default: :rc:`figure.frameon`
2394             If ``False``, suppress drawing the figure background patch.
2395 
2396         subplotpars : `SubplotParams`
2397             Subplot parameters. If not given, the default subplot
2398             parameters :rc:`figure.subplot.*` are used.
2399 
2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2402 
2403             .. admonition:: Discouraged
2404 
2405                 The use of this parameter is discouraged. Please use
2406                 ``layout='tight'`` instead for the common case of
2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2408 
2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2410             This is equal to ``layout='constrained'``.
2411 
2412             .. admonition:: Discouraged
2413 
2414                 The use of this parameter is discouraged. Please use
2415                 ``layout='constrained'`` instead.
2416 
2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2418 None}, default: None
2419             The layout mechanism for positioning of plot elements to avoid
2420             overlapping Axes decorations (labels, ticks, etc). Note that
2421             layout managers can have significant performance penalties.
2422 
2423             - 'constrained': The constrained layout solver adjusts axes sizes
2424               to avoid overlapping axes decorations.  Can handle complex plot
2425               layouts and colorbars, and is thus recommended.
2426 
2427               See :ref:`constrainedlayout_guide`
2428               for examples.
2429 
2430             - 'compressed': uses the same algorithm as 'constrained', but
2431               removes extra space between fixed-aspect-ratio Axes.  Best for
2432               simple grids of axes.
2433 
2434             - 'tight': Use the tight layout mechanism. This is a relatively
2435               simple algorithm that adjusts the subplot parameters so that
2436               decorations do not overlap. See `.Figure.set_tight_layout` for
2437               further details.
2438 
2439             - 'none': Do not use a layout engine.
2440 
2441             - A `.LayoutEngine` instance. Builtin layout classes are
2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2443               accessible by 'constrained' and 'tight'.  Passing an instance
2444               allows third parties to provide their own layout engine.
2445 
2446             If not given, fall back to using the parameters *tight_layout* and
2447             *constrained_layout*, including their config defaults
2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2449 
2450         Other Parameters
2451         ----------------
2452         **kwargs : `.Figure` properties, optional
2453 
2454             %(Figure:kwdoc)s
2455         """
2456         super().__init__(**kwargs)
2457         self._layout_engine = None
2458 
2459         if layout is not None:
2460             if (tight_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2463                     "be used together. Please use 'layout' only.")
2464             if (constrained_layout is not None):
2465                 _api.warn_external(
2466                     "The Figure parameters 'layout' and 'constrained_layout' "
2467                     "cannot be used together. Please use 'layout' only.")
2468             self.set_layout_engine(layout=layout)
2469         elif tight_layout is not None:
2470             if constrained_layout is not None:
2471                 _api.warn_external(
2472                     "The Figure parameters 'tight_layout' and "
2473                     "'constrained_layout' cannot be used together. Please use "
2474                     "'layout' parameter")
2475             self.set_layout_engine(layout='tight')
2476             if isinstance(tight_layout, dict):
2477                 self.get_layout_engine().set(**tight_layout)
2478         elif constrained_layout is not None:
2479             if isinstance(constrained_layout, dict):
2480                 self.set_layout_engine(layout='constrained')
2481                 self.get_layout_engine().set(**constrained_layout)
2482             elif constrained_layout:
2483                 self.set_layout_engine(layout='constrained')
2484 
2485         else:
2486             # everything is None, so use default:
2487             self.set_layout_engine(layout=layout)
2488 
2489         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2490         # Callbacks traditionally associated with the canvas (and exposed with
2491         # a proxy property), but that actually need to be on the figure for
2492         # pickling.
2493         self._canvas_callbacks = cbook.CallbackRegistry(
2494             signals=FigureCanvasBase.events)
2495         connect = self._canvas_callbacks._connect_picklable
2496         self._mouse_key_ids = [
2497             connect('key_press_event', backend_bases._key_handler),
2498             connect('key_release_event', backend_bases._key_handler),
2499             connect('key_release_event', backend_bases._key_handler),
2500             connect('button_press_event', backend_bases._mouse_handler),
2501             connect('button_release_event', backend_bases._mouse_handler),
2502             connect('scroll_event', backend_bases._mouse_handler),
2503             connect('motion_notify_event', backend_bases._mouse_handler),
2504         ]
2505         self._button_pick_id = connect('button_press_event', self.pick)
2506         self._scroll_pick_id = connect('scroll_event', self.pick)
2507 
2508         if figsize is None:
2509             figsize = mpl.rcParams['figure.figsize']
2510         if dpi is None:
2511             dpi = mpl.rcParams['figure.dpi']
2512         if facecolor is None:
2513             facecolor = mpl.rcParams['figure.facecolor']
2514         if edgecolor is None:
2515             edgecolor = mpl.rcParams['figure.edgecolor']
2516         if frameon is None:
2517             frameon = mpl.rcParams['figure.frameon']
2518 
2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2520             raise ValueError('figure size must be positive finite not '
2521                              f'{figsize}')
2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2523 
2524         self.dpi_scale_trans = Affine2D().scale(dpi)
2525         # do not use property as it will trigger
2526         self._dpi = dpi
2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2528         self.figbbox = self.bbox
2529         self.transFigure = BboxTransformTo(self.bbox)
2530         self.transSubfigure = self.transFigure
2531 
2532         self.patch = Rectangle(
2533             xy=(0, 0), width=1, height=1, visible=frameon,
2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2535             # Don't let the figure patch influence bbox calculation.
2536             in_layout=False)
2537         self._set_artist_props(self.patch)
2538         self.patch.set_antialiased(False)
2539 
2540         FigureCanvasBase(self)  # Set self.canvas.
2541 
2542         if subplotpars is None:
2543             subplotpars = SubplotParams()
2544 
2545         self.subplotpars = subplotpars
2546 
2547         self._axstack = _AxesStack()  # track all figure axes and current axes
2548         self.clear()
2549 
2550     def pick(self, mouseevent):
2551         if not self.canvas.widgetlock.locked():
2552             super().pick(mouseevent)
2553 
2554     def _check_layout_engines_compat(self, old, new):
2555         """
2556         Helper for set_layout engine
2557 
2558         If the figure has used the old engine and added a colorbar then the
2559         value of colorbar_gridspec must be the same on the new engine.
2560         """
2561         if old is None or new is None:
2562             return True
2563         if old.colorbar_gridspec == new.colorbar_gridspec:
2564             return True
2565         # colorbar layout different, so check if any colorbars are on the
2566         # figure...
2567         for ax in self.axes:
2568             if hasattr(ax, '_colorbar'):
2569                 # colorbars list themselves as a colorbar.
2570                 return False
2571         return True
2572 
2573     def set_layout_engine(self, layout=None, **kwargs):
2574         """
2575         Set the layout engine for this figure.
2576 
2577         Parameters
2578         ----------
2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2580 `LayoutEngine` or None
2581 
2582             - 'constrained' will use `~.ConstrainedLayoutEngine`
2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2584               a correction that attempts to make a good layout for fixed-aspect
2585               ratio Axes.
2586             - 'tight' uses `~.TightLayoutEngine`
2587             - 'none' removes layout engine.
2588 
2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2590             (which if `True` behaves as if 'tight' was passed) and
2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2592             'constrained' was passed).  If both are `True`,
2593             :rc:`figure.autolayout` takes priority.
2594 
2595             Users and libraries can define their own layout engines and pass
2596             the instance directly as well.
2597 
2598         kwargs: dict
2599             The keyword arguments are passed to the layout engine to set things
2600             like padding and margin sizes.  Only used if *layout* is a string.
2601 
2602         """
2603         if layout is None:
2604             if mpl.rcParams['figure.autolayout']:
2605                 layout = 'tight'
2606             elif mpl.rcParams['figure.constrained_layout.use']:
2607                 layout = 'constrained'
2608             else:
2609                 self._layout_engine = None
2610                 return
2611         if layout == 'tight':
2612             new_layout_engine = TightLayoutEngine(**kwargs)
2613         elif layout == 'constrained':
2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2615         elif layout == 'compressed':
2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2617                                                         **kwargs)
2618         elif layout == 'none':
2619             if self._layout_engine is not None:
2620                 new_layout_engine = PlaceHolderLayoutEngine(
2621                     self._layout_engine.adjust_compatible,
2622                     self._layout_engine.colorbar_gridspec
2623                 )
2624             else:
2625                 new_layout_engine = None
2626         elif isinstance(layout, LayoutEngine):
2627             new_layout_engine = layout
2628         else:
2629             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2630 
2631         if self._check_layout_engines_compat(self._layout_engine,
2632                                              new_layout_engine):
2633             self._layout_engine = new_layout_engine
2634         else:
2635             raise RuntimeError('Colorbar layout of new layout engine not '
2636                                'compatible with old engine, and a colorbar '
2637                                'has been created.  Engine not changed.')
2638 
2639     def get_layout_engine(self):
2640         return self._layout_engine
2641 
2642     # TODO: I'd like to dynamically add the _repr_html_ method
2643     # to the figure in the right context, but then IPython doesn't
2644     # use it, for some reason.
2645 
2646     def _repr_html_(self):
2647         # We can't use "isinstance" here, because then we'd end up importing
2648         # webagg unconditionally.
2649         if 'WebAgg' in type(self.canvas).__name__:
2650             from matplotlib.backends import backend_webagg
2651             return backend_webagg.ipython_inline_display(self)
2652 
2653     def show(self, warn=True):
2654         """
2655         If using a GUI backend with pyplot, display the figure window.
2656 
2657         If the figure was not created using `~.pyplot.figure`, it will lack
2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2659         AttributeError.
2660 
2661         .. warning::
2662 
2663             This does not manage an GUI event loop. Consequently, the figure
2664             may only be shown briefly or not shown at all if you or your
2665             environment are not managing an event loop.
2666 
2667             Use cases for `.Figure.show` include running this from a GUI
2668             application (where there is persistently an event loop running) or
2669             from a shell, like IPython, that install an input hook to allow the
2670             interactive shell to accept input while the figure is also being
2671             shown and interactive.  Some, but not all, GUI toolkits will
2672             register an input hook on import.  See :ref:`cp_integration` for
2673             more details.
2674 
2675             If you're in a shell without input hook integration or executing a
2676             python script, you should use `matplotlib.pyplot.show` with
2677             ``block=True`` instead, which takes care of starting and running
2678             the event loop for you.
2679 
2680         Parameters
2681         ----------
2682         warn : bool, default: True
2683             If ``True`` and we are not running headless (i.e. on Linux with an
2684             unset DISPLAY), issue warning when called on a non-GUI backend.
2685 
2686         """
2687         if self.canvas.manager is None:
2688             raise AttributeError(
2689                 "Figure.show works only for figures managed by pyplot, "
2690                 "normally created by pyplot.figure()")
2691         try:
2692             self.canvas.manager.show()
2693         except NonGuiException as exc:
2694             if warn:
2695                 _api.warn_external(str(exc))
2696 
2697     @property
2698     def axes(self):
2699         """
2700         List of Axes in the Figure. You can access and modify the Axes in the
2701         Figure through this list.
2702 
2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2705 
2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2707         equivalent.
2708         """
2709         return self._axstack.as_list()
2710 
2711     get_axes = axes.fget
2712 
2713     def _get_renderer(self):
2714         if hasattr(self.canvas, 'get_renderer'):
2715             return self.canvas.get_renderer()
2716         else:
2717             return _get_renderer(self)
2718 
2719     def _get_dpi(self):
2720         return self._dpi
2721 
2722     def _set_dpi(self, dpi, forward=True):
2723         """
2724         Parameters
2725         ----------
2726         dpi : float
2727 
2728         forward : bool
2729             Passed on to `~.Figure.set_size_inches`
2730         """
2731         if dpi == self._dpi:
2732             # We don't want to cause undue events in backends.
2733             return
2734         self._dpi = dpi
2735         self.dpi_scale_trans.clear().scale(dpi)
2736         w, h = self.get_size_inches()
2737         self.set_size_inches(w, h, forward=forward)
2738         self._fig_callbacks.process('dpi_changed', self)
2739 
2740     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2741 
2742     def get_tight_layout(self):
2743         """Return whether `.tight_layout` is called when drawing."""
2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2745 
2746     @_api.deprecated("3.6", alternative="set_layout_engine",
2747                      pending=True)
2748     def set_tight_layout(self, tight):
2749         """
2750         [*Discouraged*] Set whether and how `.tight_layout` is called when
2751         drawing.
2752 
2753         .. admonition:: Discouraged
2754 
2755             This method is discouraged in favor of `~.set_layout_engine`.
2756 
2757         Parameters
2758         ----------
2759         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2760             If a bool, sets whether to call `.tight_layout` upon drawing.
2761             If ``None``, use :rc:`figure.autolayout` instead.
2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2763             default paddings.
2764         """
2765         if tight is None:
2766             tight = mpl.rcParams['figure.autolayout']
2767         _tight = 'tight' if bool(tight) else 'none'
2768         _tight_parameters = tight if isinstance(tight, dict) else {}
2769         self.set_layout_engine(_tight, **_tight_parameters)
2770         self.stale = True
2771 
2772     def get_constrained_layout(self):
2773         """
2774         Return whether constrained layout is being used.
2775 
2776         See :ref:`constrainedlayout_guide`.
2777         """
2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2779 
2780     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2781                      pending=True)
2782     def set_constrained_layout(self, constrained):
2783         """
2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2785         drawing.
2786 
2787         If None, :rc:`figure.constrained_layout.use` value will be used.
2788 
2789         When providing a dict containing the keys ``w_pad``, ``h_pad``
2790         the default ``constrained_layout`` paddings will be
2791         overridden.  These pads are in inches and default to 3.0/72.0.
2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2793 
2794         .. admonition:: Discouraged
2795 
2796             This method is discouraged in favor of `~.set_layout_engine`.
2797 
2798         Parameters
2799         ----------
2800         constrained : bool or dict or None
2801         """
2802         if constrained is None:
2803             constrained = mpl.rcParams['figure.constrained_layout.use']
2804         _constrained = 'constrained' if bool(constrained) else 'none'
2805         _parameters = constrained if isinstance(constrained, dict) else {}
2806         self.set_layout_engine(_constrained, **_parameters)
2807         self.stale = True
2808 
2809     @_api.deprecated(
2810          "3.6", alternative="figure.get_layout_engine().set()",
2811          pending=True)
2812     def set_constrained_layout_pads(self, **kwargs):
2813         """
2814         Set padding for ``constrained_layout``.
2815 
2816         Tip: The parameters can be passed from a dictionary by using
2817         ``fig.set_constrained_layout(**pad_dict)``.
2818 
2819         See :ref:`constrainedlayout_guide`.
2820 
2821         Parameters
2822         ----------
2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2824             Width padding in inches.  This is the pad around Axes
2825             and is meant to make sure there is enough room for fonts to
2826             look good.  Defaults to 3 pts = 0.04167 inches
2827 
2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2829             Height padding in inches. Defaults to 3 pts.
2830 
2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2832             Width padding between subplots, expressed as a fraction of the
2833             subplot width.  The total padding ends up being w_pad + wspace.
2834 
2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2836             Height padding between subplots, expressed as a fraction of the
2837             subplot width. The total padding ends up being h_pad + hspace.
2838 
2839         """
2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2841             self.get_layout_engine().set(**kwargs)
2842 
2843     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2844                      pending=True)
2845     def get_constrained_layout_pads(self, relative=False):
2846         """
2847         Get padding for ``constrained_layout``.
2848 
2849         Returns a list of ``w_pad, h_pad`` in inches and
2850         ``wspace`` and ``hspace`` as fractions of the subplot.
2851         All values are None if ``constrained_layout`` is not used.
2852 
2853         See :ref:`constrainedlayout_guide`.
2854 
2855         Parameters
2856         ----------
2857         relative : bool
2858             If `True`, then convert from inches to figure relative.
2859         """
2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2861             return None, None, None, None
2862         info = self.get_layout_engine().get_info()
2863         w_pad = info['w_pad']
2864         h_pad = info['h_pad']
2865         wspace = info['wspace']
2866         hspace = info['hspace']
2867 
2868         if relative and (w_pad is not None or h_pad is not None):
2869             renderer = self._get_renderer()
2870             dpi = renderer.dpi
2871             w_pad = w_pad * dpi / renderer.width
2872             h_pad = h_pad * dpi / renderer.height
2873 
2874         return w_pad, h_pad, wspace, hspace
2875 
2876     def set_canvas(self, canvas):
2877         """
2878         Set the canvas that contains the figure
2879 
2880         Parameters
2881         ----------
2882         canvas : FigureCanvas
2883         """
2884         self.canvas = canvas
2885 
2886     @_docstring.interpd
2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2889         """
2890         Add a non-resampled image to the figure.
2891 
2892         The image is attached to the lower or upper left corner depending on
2893         *origin*.
2894 
2895         Parameters
2896         ----------
2897         X
2898             The image data. This is an array of one of the following shapes:
2899 
2900             - (M, N): an image with scalar data.  Color-mapping is controlled
2901               by *cmap*, *norm*, *vmin*, and *vmax*.
2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2904               i.e. including transparency.
2905 
2906         xo, yo : int
2907             The *x*/*y* image offset in pixels.
2908 
2909         alpha : None or float
2910             The alpha blending value.
2911 
2912         %(cmap_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(norm_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         %(vmin_vmax_doc)s
2921 
2922             This parameter is ignored if *X* is RGB(A).
2923 
2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2925             Indicates where the [0, 0] index of the array is in the upper left
2926             or lower left corner of the axes.
2927 
2928         resize : bool
2929             If *True*, resize the figure to match the given image size.
2930 
2931         Returns
2932         -------
2933         `matplotlib.image.FigureImage`
2934 
2935         Other Parameters
2936         ----------------
2937         **kwargs
2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2939 
2940         Notes
2941         -----
2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2943         which will be resampled to fit the current Axes.  If you want
2944         a resampled image to fill the entire figure, you can define an
2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2946 
2947         Examples
2948         --------
2949         ::
2950 
2951             f = plt.figure()
2952             nx = int(f.get_figwidth() * f.dpi)
2953             ny = int(f.get_figheight() * f.dpi)
2954             data = np.random.random((ny, nx))
2955             f.figimage(data)
2956             plt.show()
2957         """
2958         if resize:
2959             dpi = self.get_dpi()
2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2961             self.set_size_inches(figsize, forward=True)
2962 
2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2964                                 offsetx=xo, offsety=yo,
2965                                 origin=origin, **kwargs)
2966         im.stale_callback = _stale_figure_callback
2967 
2968         im.set_array(X)
2969         im.set_alpha(alpha)
2970         if norm is None:
2971             im.set_clim(vmin, vmax)
2972         self.images.append(im)
2973         im._remove_method = self.images.remove
2974         self.stale = True
2975         return im
2976 
2977     def set_size_inches(self, w, h=None, forward=True):
2978         """
2979         Set the figure size in inches.
2980 
2981         Call signatures::
2982 
2983              fig.set_size_inches(w, h)  # OR
2984              fig.set_size_inches((w, h))
2985 
2986         Parameters
2987         ----------
2988         w : (float, float) or float
2989             Width and height in inches (if height not specified as a separate
2990             argument) or width.
2991         h : float
2992             Height in inches.
2993         forward : bool, default: True
2994             If ``True``, the canvas size is automatically updated, e.g.,
2995             you can resize the figure window from the shell.
2996 
2997         See Also
2998         --------
2999         matplotlib.figure.Figure.get_size_inches
3000         matplotlib.figure.Figure.set_figwidth
3001         matplotlib.figure.Figure.set_figheight
3002 
3003         Notes
3004         -----
3005         To transform from pixels to inches divide by `Figure.dpi`.
3006         """
3007         if h is None:  # Got called with a single pair as argument.
3008             w, h = w
3009         size = np.array([w, h])
3010         if not np.isfinite(size).all() or (size < 0).any():
3011             raise ValueError(f'figure size must be positive finite not {size}')
3012         self.bbox_inches.p1 = size
3013         if forward:
3014             manager = self.canvas.manager
3015             if manager is not None:
3016                 manager.resize(*(size * self.dpi).astype(int))
3017         self.stale = True
3018 
3019     def get_size_inches(self):
3020         """
3021         Return the current size of the figure in inches.
3022 
3023         Returns
3024         -------
3025         ndarray
3026            The size (width, height) of the figure in inches.
3027 
3028         See Also
3029         --------
3030         matplotlib.figure.Figure.set_size_inches
3031         matplotlib.figure.Figure.get_figwidth
3032         matplotlib.figure.Figure.get_figheight
3033 
3034         Notes
3035         -----
3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3037         """
3038         return np.array(self.bbox_inches.p1)
3039 
3040     def get_figwidth(self):
3041         """Return the figure width in inches."""
3042         return self.bbox_inches.width
3043 
3044     def get_figheight(self):
3045         """Return the figure height in inches."""
3046         return self.bbox_inches.height
3047 
3048     def get_dpi(self):
3049         """Return the resolution in dots per inch as a float."""
3050         return self.dpi
3051 
3052     def set_dpi(self, val):
3053         """
3054         Set the resolution of the figure in dots-per-inch.
3055 
3056         Parameters
3057         ----------
3058         val : float
3059         """
3060         self.dpi = val
3061         self.stale = True
3062 
3063     def set_figwidth(self, val, forward=True):
3064         """
3065         Set the width of the figure in inches.
3066 
3067         Parameters
3068         ----------
3069         val : float
3070         forward : bool
3071             See `set_size_inches`.
3072 
3073         See Also
3074         --------
3075         matplotlib.figure.Figure.set_figheight
3076         matplotlib.figure.Figure.set_size_inches
3077         """
3078         self.set_size_inches(val, self.get_figheight(), forward=forward)
3079 
3080     def set_figheight(self, val, forward=True):
3081         """
3082         Set the height of the figure in inches.
3083 
3084         Parameters
3085         ----------
3086         val : float
3087         forward : bool
3088             See `set_size_inches`.
3089 
3090         See Also
3091         --------
3092         matplotlib.figure.Figure.set_figwidth
3093         matplotlib.figure.Figure.set_size_inches
3094         """
3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3096 
3097     def clear(self, keep_observers=False):
3098         # docstring inherited
3099         super().clear(keep_observers=keep_observers)
3100         # FigureBase.clear does not clear toolbars, as
3101         # only Figure can have toolbars
3102         toolbar = self.canvas.toolbar
3103         if toolbar is not None:
3104             toolbar.update()
3105 
3106     @_finalize_rasterization
3107     @allow_rasterization
3108     def draw(self, renderer):
3109         # docstring inherited
3110 
3111         # draw the figure bounding box, perhaps none for white figure
3112         if not self.get_visible():
3113             return
3114 
3115         artists = self._get_draw_artists(renderer)
3116         try:
3117             renderer.open_group('figure', gid=self.get_gid())
3118             if self.axes and self.get_layout_engine() is not None:
3119                 try:
3120                     self.get_layout_engine().execute(self)
3121                 except ValueError:
3122                     pass
3123                     # ValueError can occur when resizing a window.
3124 
3125             self.patch.draw(renderer)
3126             mimage._draw_list_compositing_images(
3127                 renderer, self, artists, self.suppressComposite)
3128 
3129             for sfig in self.subfigs:
3130                 sfig.draw(renderer)
3131 
3132             renderer.close_group('figure')
3133         finally:
3134             self.stale = False
3135 
3136         DrawEvent("draw_event", self.canvas, renderer)._process()
3137 
3138     def draw_without_rendering(self):
3139         """
3140         Draw the figure with no output.  Useful to get the final size of
3141         artists that require a draw before their size is known (e.g. text).
3142         """
3143         renderer = _get_renderer(self)
3144         with renderer._draw_disabled():
3145             self.draw(renderer)
3146 
3147     def draw_artist(self, a):
3148         """
3149         Draw `.Artist` *a* only.
3150         """
3151         a.draw(self.canvas.get_renderer())
3152 
3153     def __getstate__(self):
3154         state = super().__getstate__()
3155 
3156         # The canvas cannot currently be pickled, but this has the benefit
3157         # of meaning that a figure can be detached from one canvas, and
3158         # re-attached to another.
3159         state.pop("canvas")
3160 
3161         # discard any changes to the dpi due to pixel ratio changes
3162         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3163 
3164         # add version information to the state
3165         state['__mpl_version__'] = mpl.__version__
3166 
3167         # check whether the figure manager (if any) is registered with pyplot
3168         from matplotlib import _pylab_helpers
3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3170             state['_restore_to_pylab'] = True
3171         return state
3172 
3173     def __setstate__(self, state):
3174         version = state.pop('__mpl_version__')
3175         restore_to_pylab = state.pop('_restore_to_pylab', False)
3176 
3177         if version != mpl.__version__:
3178             _api.warn_external(
3179                 f"This figure was saved with matplotlib version {version} and "
3180                 f"is unlikely to function correctly.")
3181 
3182         self.__dict__ = state
3183 
3184         # re-initialise some of the unstored state information
3185         FigureCanvasBase(self)  # Set self.canvas.
3186 
3187         if restore_to_pylab:
3188             # lazy import to avoid circularity
3189             import matplotlib.pyplot as plt
3190             import matplotlib._pylab_helpers as pylab_helpers
3191             allnums = plt.get_fignums()
3192             num = max(allnums) + 1 if allnums else 1
3193             backend = plt._get_backend_mod()
3194             mgr = backend.new_figure_manager_given_figure(num, self)
3195             pylab_helpers.Gcf._set_new_active_manager(mgr)
3196             plt.draw_if_interactive()
3197 
3198         self.stale = True
3199 
3200     def add_axobserver(self, func):
3201         """Whenever the Axes state change, ``func(self)`` will be called."""
3202         # Connect a wrapper lambda and not func itself, to avoid it being
3203         # weakref-collected.
3204         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3205 
3206     def savefig(self, fname, *, transparent=None, **kwargs):
3207         """
3208         Save the current figure.
3209 
3210         Call signature::
3211 
3212           savefig(fname, *, dpi='figure', format=None, metadata=None,
3213                   bbox_inches=None, pad_inches=0.1,
3214                   facecolor='auto', edgecolor='auto',
3215                   backend=None, **kwargs
3216                  )
3217 
3218         The available output formats depend on the backend being used.
3219 
3220         Parameters
3221         ----------
3222         fname : str or path-like or binary file-like
3223             A path, or a Python file-like object, or
3224             possibly some backend-dependent object such as
3225             `matplotlib.backends.backend_pdf.PdfPages`.
3226 
3227             If *format* is set, it determines the output format, and the file
3228             is saved as *fname*.  Note that *fname* is used verbatim, and there
3229             is no attempt to make the extension, if any, of *fname* match
3230             *format*, and no extension is appended.
3231 
3232             If *format* is not set, then the format is inferred from the
3233             extension of *fname*, if there is one.  If *format* is not
3234             set and *fname* has no extension, then the file is saved with
3235             :rc:`savefig.format` and the appropriate extension is appended to
3236             *fname*.
3237 
3238         Other Parameters
3239         ----------------
3240         dpi : float or 'figure', default: :rc:`savefig.dpi`
3241             The resolution in dots per inch.  If 'figure', use the figure's
3242             dpi value.
3243 
3244         format : str
3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3246             this is unset is documented under *fname*.
3247 
3248         metadata : dict, optional
3249             Key/value pairs to store in the image metadata. The supported keys
3250             and defaults depend on the image format and backend:
3251 
3252             - 'png' with Agg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasAgg.print_png`.
3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3255               `~.backend_pdf.PdfPages`.
3256             - 'svg' with svg backend: See the parameter ``metadata`` of
3257               `~.FigureCanvasSVG.print_svg`.
3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3259 
3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
3261             embedding metadata.
3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include
3263             embedding EXIF metadata in the future.
3264 
3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3266             Bounding box in inches: only the given portion of the figure is
3267             saved.  If 'tight', try to figure out the tight bbox of the figure.
3268 
3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3270             Amount of padding in inches around the figure when bbox_inches is
3271             'tight'. If 'layout' use the padding from the constrained or
3272             compressed layout engine; ignored if one of those engines is not in
3273             use.
3274 
3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3276             The facecolor of the figure.  If 'auto', use the current figure
3277             facecolor.
3278 
3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3280             The edgecolor of the figure.  If 'auto', use the current figure
3281             edgecolor.
3282 
3283         backend : str, optional
3284             Use a non-default backend to render the file, e.g. to render a
3285             png file with the "cairo" backend rather than the default "agg",
3286             or a pdf file with the "pgf" backend rather than the default
3287             "pdf".  Note that the default backend is normally sufficient.  See
3288             :ref:`the-builtin-backends` for a list of valid backends for each
3289             file format.  Custom backends can be referenced as "module://...".
3290 
3291         orientation : {'landscape', 'portrait'}
3292             Currently only supported by the postscript backend.
3293 
3294         papertype : str
3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3296             'a10', 'b0' through 'b10'. Only supported for postscript
3297             output.
3298 
3299         transparent : bool
3300             If *True*, the Axes patches will all be transparent; the
3301             Figure patch will also be transparent unless *facecolor*
3302             and/or *edgecolor* are specified via kwargs.
3303 
3304             If *False* has no effect and the color of the Axes and
3305             Figure patches are unchanged (unless the Figure patch
3306             is specified via the *facecolor* and/or *edgecolor* keyword
3307             arguments in which case those colors are used).
3308 
3309             The transparency of these patches will be restored to their
3310             original values upon exit of this function.
3311 
3312             This is useful, for example, for displaying
3313             a plot on top of a colored background on a web page.
3314 
3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3316             A list of extra artists that will be considered when the
3317             tight bbox is calculated.
3318 
3319         pil_kwargs : dict, optional
3320             Additional keyword arguments that are passed to
3321             `PIL.Image.Image.save` when saving the figure.
3322 
3323         """
3324 
3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3326         if transparent is None:
3327             transparent = mpl.rcParams['savefig.transparent']
3328 
3329         with ExitStack() as stack:
3330             if transparent:
3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3332                     exit_stack.enter_context(
3333                         subfig.patch._cm_set(
3334                             facecolor="none", edgecolor="none"))
3335                     for ax in subfig.axes:
3336                         exit_stack.enter_context(
3337                             ax.patch._cm_set(
3338                                 facecolor="none", edgecolor="none"))
3339                     for sub_subfig in subfig.subfigs:
3340                         _recursively_make_subfig_transparent(
3341                             exit_stack, sub_subfig)
3342 
3343                 def _recursively_make_axes_transparent(exit_stack, ax):
3344                     exit_stack.enter_context(
3345                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3346                     for child_ax in ax.child_axes:
3347                         exit_stack.enter_context(
3348                             child_ax.patch._cm_set(
3349                                 facecolor="none", edgecolor="none"))
3350                     for child_childax in ax.child_axes:
3351                         _recursively_make_axes_transparent(
3352                             exit_stack, child_childax)
3353 
3354                 kwargs.setdefault('facecolor', 'none')
3355                 kwargs.setdefault('edgecolor', 'none')
3356                 # set subfigure to appear transparent in printed image
3357                 for subfig in self.subfigs:
3358                     _recursively_make_subfig_transparent(stack, subfig)
3359                 # set axes to be transparent
3360                 for ax in self.axes:
3361                     _recursively_make_axes_transparent(stack, ax)
3362             self.canvas.print_figure(fname, **kwargs)
3363 
3364     def ginput(self, n=1, timeout=30, show_clicks=True,
3365                mouse_add=MouseButton.LEFT,
3366                mouse_pop=MouseButton.RIGHT,
3367                mouse_stop=MouseButton.MIDDLE):
3368         """
3369         Blocking call to interact with a figure.
3370 
3371         Wait until the user clicks *n* times on the figure, and return the
3372         coordinates of each click in a list.
3373 
3374         There are three possible interactions:
3375 
3376         - Add a point.
3377         - Remove the most recently added point.
3378         - Stop the interaction and return the points added so far.
3379 
3380         The actions are assigned to mouse buttons via the arguments
3381         *mouse_add*, *mouse_pop* and *mouse_stop*.
3382 
3383         Parameters
3384         ----------
3385         n : int, default: 1
3386             Number of mouse clicks to accumulate. If negative, accumulate
3387             clicks until the input is terminated manually.
3388         timeout : float, default: 30 seconds
3389             Number of seconds to wait before timing out. If zero or negative
3390             will never time out.
3391         show_clicks : bool, default: True
3392             If True, show a red cross at the location of each click.
3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3394             Mouse button used to add points.
3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3396             Mouse button used to remove the most recently added point.
3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3398             Mouse button used to stop input.
3399 
3400         Returns
3401         -------
3402         list of tuples
3403             A list of the clicked (x, y) coordinates.
3404 
3405         Notes
3406         -----
3407         The keyboard can also be used to select points in case your mouse
3408         does not have one or more of the buttons.  The delete and backspace
3409         keys act like right-clicking (i.e., remove last point), the enter key
3410         terminates input and any other key (not already used by the window
3411         manager) selects a point.
3412         """
3413         clicks = []
3414         marks = []
3415 
3416         def handler(event):
3417             is_button = event.name == "button_press_event"
3418             is_key = event.name == "key_press_event"
3419             # Quit (even if not in infinite mode; this is consistent with
3420             # MATLAB and sometimes quite useful, but will require the user to
3421             # test how many points were actually returned before using data).
3422             if (is_button and event.button == mouse_stop
3423                     or is_key and event.key in ["escape", "enter"]):
3424                 self.canvas.stop_event_loop()
3425             # Pop last click.
3426             elif (is_button and event.button == mouse_pop
3427                   or is_key and event.key in ["backspace", "delete"]):
3428                 if clicks:
3429                     clicks.pop()
3430                     if show_clicks:
3431                         marks.pop().remove()
3432                         self.canvas.draw()
3433             # Add new click.
3434             elif (is_button and event.button == mouse_add
3435                   # On macOS/gtk, some keys return None.
3436                   or is_key and event.key is not None):
3437                 if event.inaxes:
3438                     clicks.append((event.xdata, event.ydata))
3439                     _log.info("input %i: %f, %f",
3440                               len(clicks), event.xdata, event.ydata)
3441                     if show_clicks:
3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3443                                                 marker="+", color="r")
3444                         event.inaxes.add_line(line)
3445                         marks.append(line)
3446                         self.canvas.draw()
3447             if len(clicks) == n and n > 0:
3448                 self.canvas.stop_event_loop()
3449 
3450         _blocking_input.blocking_input_loop(
3451             self, ["button_press_event", "key_press_event"], timeout, handler)
3452 
3453         # Cleanup.
3454         for mark in marks:
3455             mark.remove()
3456         self.canvas.draw()
3457 
3458         return clicks
3459 
3460     def waitforbuttonpress(self, timeout=-1):
3461         """
3462         Blocking call to interact with the figure.
3463 
3464         Wait for user input and return True if a key was pressed, False if a
3465         mouse button was pressed and None if no input was given within
3466         *timeout* seconds.  Negative values deactivate *timeout*.
3467         """
3468         event = None
3469 
3470         def handler(ev):
3471             nonlocal event
3472             event = ev
3473             self.canvas.stop_event_loop()
3474 
3475         _blocking_input.blocking_input_loop(
3476             self, ["button_press_event", "key_press_event"], timeout, handler)
3477 
3478         return None if event is None else event.name == "key_press_event"
3479 
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 `matplotlib.figure` implements the following classes:
3 
4 `Figure`
5     Top level `~matplotlib.artist.Artist`, which holds all plot elements.
6     Many methods are implemented in `FigureBase`.
7 
8 `SubFigure`
9     A logical figure inside a figure, usually added to a figure (or parent
10     `SubFigure`) with `Figure.add_subfigure` or `Figure.subfigures` methods
11     (provisional API v3.4).
12 
13 `SubplotParams`
14     Control the default spacing between subplots.
15 
16 Figures are typically created using pyplot methods `~.pyplot.figure`,
17 `~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.
18 
19 .. plot::
20     :include-source:
21 
22     fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',
23                            layout='constrained')
24     fig.suptitle('Figure')
25     ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')
26 
27 Some situations call for directly instantiating a `~.figure.Figure` class,
28 usually inside an application of some sort (see :ref:`user_interfaces` for a
29 list of examples) .  More information about Figures can be found at
30 :ref:`figure_explanation`.
31 """
32 
33 from contextlib import ExitStack
34 import inspect
35 import itertools
36 import logging
37 from numbers import Integral
38 
39 import numpy as np
40 
41 import matplotlib as mpl
42 from matplotlib import _blocking_input, backend_bases, _docstring, projections
43 from matplotlib.artist import (
44     Artist, allow_rasterization, _finalize_rasterization)
45 from matplotlib.backend_bases import (
46     DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)
47 import matplotlib._api as _api
48 import matplotlib.cbook as cbook
49 import matplotlib.colorbar as cbar
50 import matplotlib.image as mimage
51 
52 from matplotlib.axes import Axes
53 from matplotlib.gridspec import GridSpec
54 from matplotlib.layout_engine import (
55     ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,
56     PlaceHolderLayoutEngine
57 )
58 import matplotlib.legend as mlegend
59 from matplotlib.patches import Rectangle
60 from matplotlib.text import Text
61 from matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,
62                                    TransformedBbox)
63 
64 _log = logging.getLogger(__name__)
65 
66 
67 def _stale_figure_callback(self, val):
68     if self.figure:
69         self.figure.stale = val
70 
71 
72 class _AxesStack:
73     """
74     Helper class to track axes in a figure.
75 
76     Axes are tracked both in the order in which they have been added
77     (``self._axes`` insertion/iteration order) and in the separate "gca" stack
78     (which is the index to which they map in the ``self._axes`` dict).
79     """
80 
81     def __init__(self):
82         self._axes = {}  # Mapping of axes to "gca" order.
83         self._counter = itertools.count()
84 
85     def as_list(self):
86         """List the axes that have been added to the figure."""
87         return [*self._axes]  # This relies on dict preserving order.
88 
89     def remove(self, a):
90         """Remove the axes from the stack."""
91         self._axes.pop(a)
92 
93     def bubble(self, a):
94         """Move an axes, which must already exist in the stack, to the top."""
95         if a not in self._axes:
96             raise ValueError("Axes has not been added yet")
97         self._axes[a] = next(self._counter)
98 
99     def add(self, a):
100         """Add an axes to the stack, ignoring it if already present."""
101         if a not in self._axes:
102             self._axes[a] = next(self._counter)
103 
104     def current(self):
105         """Return the active axes, or None if the stack is empty."""
106         return max(self._axes, key=self._axes.__getitem__, default=None)
107 
108 
109 class SubplotParams:
110     """
111     A class to hold the parameters for a subplot.
112     """
113 
114     def __init__(self, left=None, bottom=None, right=None, top=None,
115                  wspace=None, hspace=None):
116         """
117         Defaults are given by :rc:`figure.subplot.[name]`.
118 
119         Parameters
120         ----------
121         left : float
122             The position of the left edge of the subplots,
123             as a fraction of the figure width.
124         right : float
125             The position of the right edge of the subplots,
126             as a fraction of the figure width.
127         bottom : float
128             The position of the bottom edge of the subplots,
129             as a fraction of the figure height.
130         top : float
131             The position of the top edge of the subplots,
132             as a fraction of the figure height.
133         wspace : float
134             The width of the padding between subplots,
135             as a fraction of the average Axes width.
136         hspace : float
137             The height of the padding between subplots,
138             as a fraction of the average Axes height.
139         """
140         for key in ["left", "bottom", "right", "top", "wspace", "hspace"]:
141             setattr(self, key, mpl.rcParams[f"figure.subplot.{key}"])
142         self.update(left, bottom, right, top, wspace, hspace)
143 
144     def update(self, left=None, bottom=None, right=None, top=None,
145                wspace=None, hspace=None):
146         """
147         Update the dimensions of the passed parameters. *None* means unchanged.
148         """
149         if ((left if left is not None else self.left)
150                 >= (right if right is not None else self.right)):
151             raise ValueError('left cannot be >= right')
152         if ((bottom if bottom is not None else self.bottom)
153                 >= (top if top is not None else self.top)):
154             raise ValueError('bottom cannot be >= top')
155         if left is not None:
156             self.left = left
157         if right is not None:
158             self.right = right
159         if bottom is not None:
160             self.bottom = bottom
161         if top is not None:
162             self.top = top
163         if wspace is not None:
164             self.wspace = wspace
165         if hspace is not None:
166             self.hspace = hspace
167 
168 
169 class FigureBase(Artist):
170     """
171     Base class for `.Figure` and `.SubFigure` containing the methods that add
172     artists to the figure or subfigure, create Axes, etc.
173     """
174     def __init__(self, **kwargs):
175         super().__init__()
176         # remove the non-figure artist _axes property
177         # as it makes no sense for a figure to be _in_ an Axes
178         # this is used by the property methods in the artist base class
179         # which are over-ridden in this class
180         del self._axes
181 
182         self._suptitle = None
183         self._supxlabel = None
184         self._supylabel = None
185 
186         # groupers to keep track of x and y labels we want to align.
187         # see self.align_xlabels and self.align_ylabels and
188         # axis._get_tick_boxes_siblings
189         self._align_label_groups = {"x": cbook.Grouper(), "y": cbook.Grouper()}
190 
191         self.figure = self
192         self._localaxes = []  # track all axes
193         self.artists = []
194         self.lines = []
195         self.patches = []
196         self.texts = []
197         self.images = []
198         self.legends = []
199         self.subfigs = []
200         self.stale = True
201         self.suppressComposite = None
202         self.set(**kwargs)
203 
204     def _get_draw_artists(self, renderer):
205         """Also runs apply_aspect"""
206         artists = self.get_children()
207         for sfig in self.subfigs:
208             artists.remove(sfig)
209             childa = sfig.get_children()
210             for child in childa:
211                 if child in artists:
212                     artists.remove(child)
213 
214         artists.remove(self.patch)
215         artists = sorted(
216             (artist for artist in artists if not artist.get_animated()),
217             key=lambda artist: artist.get_zorder())
218         for ax in self._localaxes:
219             locator = ax.get_axes_locator()
220             ax.apply_aspect(locator(ax, renderer) if locator else None)
221 
222             for child in ax.get_children():
223                 if hasattr(child, 'apply_aspect'):
224                     locator = child.get_axes_locator()
225                     child.apply_aspect(
226                         locator(child, renderer) if locator else None)
227         return artists
228 
229     def autofmt_xdate(
230             self, bottom=0.2, rotation=30, ha='right', which='major'):
231         """
232         Date ticklabels often overlap, so it is useful to rotate them
233         and right align them.  Also, a common use case is a number of
234         subplots with shared x-axis where the x-axis is date data.  The
235         ticklabels are often long, and it helps to rotate them on the
236         bottom subplot and turn them off on other subplots, as well as
237         turn off xlabels.
238 
239         Parameters
240         ----------
241         bottom : float, default: 0.2
242             The bottom of the subplots for `subplots_adjust`.
243         rotation : float, default: 30 degrees
244             The rotation angle of the xtick labels in degrees.
245         ha : {'left', 'center', 'right'}, default: 'right'
246             The horizontal alignment of the xticklabels.
247         which : {'major', 'minor', 'both'}, default: 'major'
248             Selects which ticklabels to rotate.
249         """
250         _api.check_in_list(['major', 'minor', 'both'], which=which)
251         allsubplots = all(ax.get_subplotspec() for ax in self.axes)
252         if len(self.axes) == 1:
253             for label in self.axes[0].get_xticklabels(which=which):
254                 label.set_ha(ha)
255                 label.set_rotation(rotation)
256         else:
257             if allsubplots:
258                 for ax in self.get_axes():
259                     if ax.get_subplotspec().is_last_row():
260                         for label in ax.get_xticklabels(which=which):
261                             label.set_ha(ha)
262                             label.set_rotation(rotation)
263                     else:
264                         for label in ax.get_xticklabels(which=which):
265                             label.set_visible(False)
266                         ax.set_xlabel('')
267 
268         if allsubplots:
269             self.subplots_adjust(bottom=bottom)
270         self.stale = True
271 
272     def get_children(self):
273         """Get a list of artists contained in the figure."""
274         return [self.patch,
275                 *self.artists,
276                 *self._localaxes,
277                 *self.lines,
278                 *self.patches,
279                 *self.texts,
280                 *self.images,
281                 *self.legends,
282                 *self.subfigs]
283 
284     def contains(self, mouseevent):
285         """
286         Test whether the mouse event occurred on the figure.
287 
288         Returns
289         -------
290             bool, {}
291         """
292         if self._different_canvas(mouseevent):
293             return False, {}
294         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
295         return inside, {}
296 
297     def get_window_extent(self, renderer=None):
298         # docstring inherited
299         return self.bbox
300 
301     def _suplabels(self, t, info, **kwargs):
302         """
303         Add a centered %(name)s to the figure.
304 
305         Parameters
306         ----------
307         t : str
308             The %(name)s text.
309         x : float, default: %(x0)s
310             The x location of the text in figure coordinates.
311         y : float, default: %(y0)s
312             The y location of the text in figure coordinates.
313         horizontalalignment, ha : {'center', 'left', 'right'}, default: %(ha)s
314             The horizontal alignment of the text relative to (*x*, *y*).
315         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
316 default: %(va)s
317             The vertical alignment of the text relative to (*x*, *y*).
318         fontsize, size : default: :rc:`figure.%(rc)ssize`
319             The font size of the text. See `.Text.set_size` for possible
320             values.
321         fontweight, weight : default: :rc:`figure.%(rc)sweight`
322             The font weight of the text. See `.Text.set_weight` for possible
323             values.
324 
325         Returns
326         -------
327         text
328             The `.Text` instance of the %(name)s.
329 
330         Other Parameters
331         ----------------
332         fontproperties : None or dict, optional
333             A dict of font properties. If *fontproperties* is given the
334             default values for font size and weight are taken from the
335             `.FontProperties` defaults. :rc:`figure.%(rc)ssize` and
336             :rc:`figure.%(rc)sweight` are ignored in this case.
337 
338         **kwargs
339             Additional kwargs are `matplotlib.text.Text` properties.
340         """
341 
342         suplab = getattr(self, info['name'])
343 
344         x = kwargs.pop('x', None)
345         y = kwargs.pop('y', None)
346         if info['name'] in ['_supxlabel', '_suptitle']:
347             autopos = y is None
348         elif info['name'] == '_supylabel':
349             autopos = x is None
350         if x is None:
351             x = info['x0']
352         if y is None:
353             y = info['y0']
354 
355         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
356             kwargs['horizontalalignment'] = info['ha']
357         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
358             kwargs['verticalalignment'] = info['va']
359         if 'rotation' not in kwargs:
360             kwargs['rotation'] = info['rotation']
361 
362         if 'fontproperties' not in kwargs:
363             if 'fontsize' not in kwargs and 'size' not in kwargs:
364                 kwargs['size'] = mpl.rcParams[info['size']]
365             if 'fontweight' not in kwargs and 'weight' not in kwargs:
366                 kwargs['weight'] = mpl.rcParams[info['weight']]
367 
368         sup = self.text(x, y, t, **kwargs)
369         if suplab is not None:
370             suplab.set_text(t)
371             suplab.set_position((x, y))
372             suplab.update_from(sup)
373             sup.remove()
374         else:
375             suplab = sup
376         suplab._autopos = autopos
377         setattr(self, info['name'], suplab)
378         self.stale = True
379         return suplab
380 
381     @_docstring.Substitution(x0=0.5, y0=0.98, name='suptitle', ha='center',
382                              va='top', rc='title')
383     @_docstring.copy(_suplabels)
384     def suptitle(self, t, **kwargs):
385         # docstring from _suplabels...
386         info = {'name': '_suptitle', 'x0': 0.5, 'y0': 0.98,
387                 'ha': 'center', 'va': 'top', 'rotation': 0,
388                 'size': 'figure.titlesize', 'weight': 'figure.titleweight'}
389         return self._suplabels(t, info, **kwargs)
390 
391     @_docstring.Substitution(x0=0.5, y0=0.01, name='supxlabel', ha='center',
392                              va='bottom', rc='label')
393     @_docstring.copy(_suplabels)
394     def supxlabel(self, t, **kwargs):
395         # docstring from _suplabels...
396         info = {'name': '_supxlabel', 'x0': 0.5, 'y0': 0.01,
397                 'ha': 'center', 'va': 'bottom', 'rotation': 0,
398                 'size': 'figure.labelsize', 'weight': 'figure.labelweight'}
399         return self._suplabels(t, info, **kwargs)
400 
401     @_docstring.Substitution(x0=0.02, y0=0.5, name='supylabel', ha='left',
402                              va='center', rc='label')
403     @_docstring.copy(_suplabels)
404     def supylabel(self, t, **kwargs):
405         # docstring from _suplabels...
406         info = {'name': '_supylabel', 'x0': 0.02, 'y0': 0.5,
407                 'ha': 'left', 'va': 'center', 'rotation': 'vertical',
408                 'rotation_mode': 'anchor', 'size': 'figure.labelsize',
409                 'weight': 'figure.labelweight'}
410         return self._suplabels(t, info, **kwargs)
411 
412     def get_edgecolor(self):
413         """Get the edge color of the Figure rectangle."""
414         return self.patch.get_edgecolor()
415 
416     def get_facecolor(self):
417         """Get the face color of the Figure rectangle."""
418         return self.patch.get_facecolor()
419 
420     def get_frameon(self):
421         """
422         Return the figure's background patch visibility, i.e.
423         whether the figure background will be drawn. Equivalent to
424         ``Figure.patch.get_visible()``.
425         """
426         return self.patch.get_visible()
427 
428     def set_linewidth(self, linewidth):
429         """
430         Set the line width of the Figure rectangle.
431 
432         Parameters
433         ----------
434         linewidth : number
435         """
436         self.patch.set_linewidth(linewidth)
437 
438     def get_linewidth(self):
439         """
440         Get the line width of the Figure rectangle.
441         """
442         return self.patch.get_linewidth()
443 
444     def set_edgecolor(self, color):
445         """
446         Set the edge color of the Figure rectangle.
447 
448         Parameters
449         ----------
450         color : color
451         """
452         self.patch.set_edgecolor(color)
453 
454     def set_facecolor(self, color):
455         """
456         Set the face color of the Figure rectangle.
457 
458         Parameters
459         ----------
460         color : color
461         """
462         self.patch.set_facecolor(color)
463 
464     def set_frameon(self, b):
465         """
466         Set the figure's background patch visibility, i.e.
467         whether the figure background will be drawn. Equivalent to
468         ``Figure.patch.set_visible()``.
469 
470         Parameters
471         ----------
472         b : bool
473         """
474         self.patch.set_visible(b)
475         self.stale = True
476 
477     frameon = property(get_frameon, set_frameon)
478 
479     def add_artist(self, artist, clip=False):
480         """
481         Add an `.Artist` to the figure.
482 
483         Usually artists are added to `~.axes.Axes` objects using
484         `.Axes.add_artist`; this method can be used in the rare cases where
485         one needs to add artists directly to the figure instead.
486 
487         Parameters
488         ----------
489         artist : `~matplotlib.artist.Artist`
490             The artist to add to the figure. If the added artist has no
491             transform previously set, its transform will be set to
492             ``figure.transSubfigure``.
493         clip : bool, default: False
494             Whether the added artist should be clipped by the figure patch.
495 
496         Returns
497         -------
498         `~matplotlib.artist.Artist`
499             The added artist.
500         """
501         artist.set_figure(self)
502         self.artists.append(artist)
503         artist._remove_method = self.artists.remove
504 
505         if not artist.is_transform_set():
506             artist.set_transform(self.transSubfigure)
507 
508         if clip and artist.get_clip_path() is None:
509             artist.set_clip_path(self.patch)
510 
511         self.stale = True
512         return artist
513 
514     @_docstring.dedent_interpd
515     def add_axes(self, *args, **kwargs):
516         """
517         Add an `~.axes.Axes` to the figure.
518 
519         Call signatures::
520 
521             add_axes(rect, projection=None, polar=False, **kwargs)
522             add_axes(ax)
523 
524         Parameters
525         ----------
526         rect : tuple (left, bottom, width, height)
527             The dimensions (left, bottom, width, height) of the new
528             `~.axes.Axes`. All quantities are in fractions of figure width and
529             height.
530 
531         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
532 'polar', 'rectilinear', str}, optional
533             The projection type of the `~.axes.Axes`. *str* is the name of
534             a custom projection, see `~matplotlib.projections`. The default
535             None results in a 'rectilinear' projection.
536 
537         polar : bool, default: False
538             If True, equivalent to projection='polar'.
539 
540         axes_class : subclass type of `~.axes.Axes`, optional
541             The `.axes.Axes` subclass that is instantiated.  This parameter
542             is incompatible with *projection* and *polar*.  See
543             :ref:`axisartist_users-guide-index` for examples.
544 
545         sharex, sharey : `~.axes.Axes`, optional
546             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
547             The axis will have the same limits, ticks, and scale as the axis
548             of the shared axes.
549 
550         label : str
551             A label for the returned Axes.
552 
553         Returns
554         -------
555         `~.axes.Axes`, or a subclass of `~.axes.Axes`
556             The returned axes class depends on the projection used. It is
557             `~.axes.Axes` if rectilinear projection is used and
558             `.projections.polar.PolarAxes` if polar projection is used.
559 
560         Other Parameters
561         ----------------
562         **kwargs
563             This method also takes the keyword arguments for
564             the returned Axes class. The keyword arguments for the
565             rectilinear Axes class `~.axes.Axes` can be found in
566             the following table but there might also be other keyword
567             arguments if another projection is used, see the actual Axes
568             class.
569 
570             %(Axes:kwdoc)s
571 
572         Notes
573         -----
574         In rare circumstances, `.add_axes` may be called with a single
575         argument, an Axes instance already created in the present figure but
576         not in the figure's list of Axes.
577 
578         See Also
579         --------
580         .Figure.add_subplot
581         .pyplot.subplot
582         .pyplot.axes
583         .Figure.subplots
584         .pyplot.subplots
585 
586         Examples
587         --------
588         Some simple examples::
589 
590             rect = l, b, w, h
591             fig = plt.figure()
592             fig.add_axes(rect)
593             fig.add_axes(rect, frameon=False, facecolor='g')
594             fig.add_axes(rect, polar=True)
595             ax = fig.add_axes(rect, projection='polar')
596             fig.delaxes(ax)
597             fig.add_axes(ax)
598         """
599 
600         if not len(args) and 'rect' not in kwargs:
601             raise TypeError(
602                 "add_axes() missing 1 required positional argument: 'rect'")
603         elif 'rect' in kwargs:
604             if len(args):
605                 raise TypeError(
606                     "add_axes() got multiple values for argument 'rect'")
607             args = (kwargs.pop('rect'), )
608 
609         if isinstance(args[0], Axes):
610             a = args[0]
611             key = a._projection_init
612             if a.get_figure() is not self:
613                 raise ValueError(
614                     "The Axes must have been created in the present figure")
615         else:
616             rect = args[0]
617             if not np.isfinite(rect).all():
618                 raise ValueError('all entries in rect must be finite '
619                                  f'not {rect}')
620             projection_class, pkw = self._process_projection_requirements(
621                 *args, **kwargs)
622 
623             # create the new axes using the axes class given
624             a = projection_class(self, rect, **pkw)
625             key = (projection_class, pkw)
626         return self._add_axes_internal(a, key)
627 
628     @_docstring.dedent_interpd
629     def add_subplot(self, *args, **kwargs):
630         """
631         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
632 
633         Call signatures::
634 
635            add_subplot(nrows, ncols, index, **kwargs)
636            add_subplot(pos, **kwargs)
637            add_subplot(ax)
638            add_subplot()
639 
640         Parameters
641         ----------
642         *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
643             The position of the subplot described by one of
644 
645             - Three integers (*nrows*, *ncols*, *index*). The subplot will
646               take the *index* position on a grid with *nrows* rows and
647               *ncols* columns. *index* starts at 1 in the upper left corner
648               and increases to the right.  *index* can also be a two-tuple
649               specifying the (*first*, *last*) indices (1-based, and including
650               *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``
651               makes a subplot that spans the upper 2/3 of the figure.
652             - A 3-digit integer. The digits are interpreted as if given
653               separately as three single-digit integers, i.e.
654               ``fig.add_subplot(235)`` is the same as
655               ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
656               if there are no more than 9 subplots.
657             - A `.SubplotSpec`.
658 
659             In rare circumstances, `.add_subplot` may be called with a single
660             argument, a subplot Axes instance already created in the
661             present figure but not in the figure's list of Axes.
662 
663         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
664 'polar', 'rectilinear', str}, optional
665             The projection type of the subplot (`~.axes.Axes`). *str* is the
666             name of a custom projection, see `~matplotlib.projections`. The
667             default None results in a 'rectilinear' projection.
668 
669         polar : bool, default: False
670             If True, equivalent to projection='polar'.
671 
672         axes_class : subclass type of `~.axes.Axes`, optional
673             The `.axes.Axes` subclass that is instantiated.  This parameter
674             is incompatible with *projection* and *polar*.  See
675             :ref:`axisartist_users-guide-index` for examples.
676 
677         sharex, sharey : `~.axes.Axes`, optional
678             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
679             The axis will have the same limits, ticks, and scale as the axis
680             of the shared axes.
681 
682         label : str
683             A label for the returned Axes.
684 
685         Returns
686         -------
687         `~.axes.Axes`
688 
689             The Axes of the subplot. The returned Axes can actually be an
690             instance of a subclass, such as `.projections.polar.PolarAxes` for
691             polar projections.
692 
693         Other Parameters
694         ----------------
695         **kwargs
696             This method also takes the keyword arguments for the returned Axes
697             base class; except for the *figure* argument. The keyword arguments
698             for the rectilinear base class `~.axes.Axes` can be found in
699             the following table but there might also be other keyword
700             arguments if another projection is used.
701 
702             %(Axes:kwdoc)s
703 
704         See Also
705         --------
706         .Figure.add_axes
707         .pyplot.subplot
708         .pyplot.axes
709         .Figure.subplots
710         .pyplot.subplots
711 
712         Examples
713         --------
714         ::
715 
716             fig = plt.figure()
717 
718             fig.add_subplot(231)
719             ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general
720 
721             fig.add_subplot(232, frameon=False)  # subplot with no frame
722             fig.add_subplot(233, projection='polar')  # polar subplot
723             fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1
724             fig.add_subplot(235, facecolor="red")  # red subplot
725 
726             ax1.remove()  # delete ax1 from the figure
727             fig.add_subplot(ax1)  # add ax1 back to the figure
728         """
729         if 'figure' in kwargs:
730             # Axes itself allows for a 'figure' kwarg, but since we want to
731             # bind the created Axes to self, it is not allowed here.
732             raise _api.kwarg_error("add_subplot", "figure")
733 
734         if (len(args) == 1
735                 and isinstance(args[0], mpl.axes._base._AxesBase)
736                 and args[0].get_subplotspec()):
737             ax = args[0]
738             key = ax._projection_init
739             if ax.get_figure() is not self:
740                 raise ValueError("The Axes must have been created in "
741                                  "the present figure")
742         else:
743             if not args:
744                 args = (1, 1, 1)
745             # Normalize correct ijk values to (i, j, k) here so that
746             # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will
747             # trigger errors later (via SubplotSpec._from_subplot_args).
748             if (len(args) == 1 and isinstance(args[0], Integral)
749                     and 100 <= args[0] <= 999):
750                 args = tuple(map(int, str(args[0])))
751             projection_class, pkw = self._process_projection_requirements(
752                 *args, **kwargs)
753             ax = projection_class(self, *args, **pkw)
754             key = (projection_class, pkw)
755         return self._add_axes_internal(ax, key)
756 
757     def _add_axes_internal(self, ax, key):
758         """Private helper for `add_axes` and `add_subplot`."""
759         self._axstack.add(ax)
760         if ax not in self._localaxes:
761             self._localaxes.append(ax)
762         self.sca(ax)
763         ax._remove_method = self.delaxes
764         # this is to support plt.subplot's re-selection logic
765         ax._projection_init = key
766         self.stale = True
767         ax.stale_callback = _stale_figure_callback
768         return ax
769 
770     def subplots(self, nrows=1, ncols=1, *, sharex=False, sharey=False,
771                  squeeze=True, width_ratios=None, height_ratios=None,
772                  subplot_kw=None, gridspec_kw=None):
773         """
774         Add a set of subplots to this figure.
775 
776         This utility wrapper makes it convenient to create common layouts of
777         subplots in a single call.
778 
779         Parameters
780         ----------
781         nrows, ncols : int, default: 1
782             Number of rows/columns of the subplot grid.
783 
784         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
785             Controls sharing of x-axis (*sharex*) or y-axis (*sharey*):
786 
787             - True or 'all': x- or y-axis will be shared among all subplots.
788             - False or 'none': each subplot x- or y-axis will be independent.
789             - 'row': each subplot row will share an x- or y-axis.
790             - 'col': each subplot column will share an x- or y-axis.
791 
792             When subplots have a shared x-axis along a column, only the x tick
793             labels of the bottom subplot are created. Similarly, when subplots
794             have a shared y-axis along a row, only the y tick labels of the
795             first column subplot are created. To later turn other subplots'
796             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
797 
798             When subplots have a shared axis that has units, calling
799             `.Axis.set_units` will update each axis with the new units.
800 
801         squeeze : bool, default: True
802             - If True, extra dimensions are squeezed out from the returned
803               array of Axes:
804 
805               - if only one subplot is constructed (nrows=ncols=1), the
806                 resulting single Axes object is returned as a scalar.
807               - for Nx1 or 1xM subplots, the returned object is a 1D numpy
808                 object array of Axes objects.
809               - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
810 
811             - If False, no squeezing at all is done: the returned Axes object
812               is always a 2D array containing Axes instances, even if it ends
813               up being 1x1.
814 
815         width_ratios : array-like of length *ncols*, optional
816             Defines the relative widths of the columns. Each column gets a
817             relative width of ``width_ratios[i] / sum(width_ratios)``.
818             If not given, all columns will have the same width.  Equivalent
819             to ``gridspec_kw={'width_ratios': [...]}``.
820 
821         height_ratios : array-like of length *nrows*, optional
822             Defines the relative heights of the rows. Each row gets a
823             relative height of ``height_ratios[i] / sum(height_ratios)``.
824             If not given, all rows will have the same height. Equivalent
825             to ``gridspec_kw={'height_ratios': [...]}``.
826 
827         subplot_kw : dict, optional
828             Dict with keywords passed to the `.Figure.add_subplot` call used to
829             create each subplot.
830 
831         gridspec_kw : dict, optional
832             Dict with keywords passed to the
833             `~matplotlib.gridspec.GridSpec` constructor used to create
834             the grid the subplots are placed on.
835 
836         Returns
837         -------
838         `~.axes.Axes` or array of Axes
839             Either a single `~matplotlib.axes.Axes` object or an array of Axes
840             objects if more than one subplot was created. The dimensions of the
841             resulting array can be controlled with the *squeeze* keyword, see
842             above.
843 
844         See Also
845         --------
846         .pyplot.subplots
847         .Figure.add_subplot
848         .pyplot.subplot
849 
850         Examples
851         --------
852         ::
853 
854             # First create some toy data:
855             x = np.linspace(0, 2*np.pi, 400)
856             y = np.sin(x**2)
857 
858             # Create a figure
859             plt.figure()
860 
861             # Create a subplot
862             ax = fig.subplots()
863             ax.plot(x, y)
864             ax.set_title('Simple plot')
865 
866             # Create two subplots and unpack the output array immediately
867             ax1, ax2 = fig.subplots(1, 2, sharey=True)
868             ax1.plot(x, y)
869             ax1.set_title('Sharing Y axis')
870             ax2.scatter(x, y)
871 
872             # Create four polar Axes and access them through the returned array
873             axes = fig.subplots(2, 2, subplot_kw=dict(projection='polar'))
874             axes[0, 0].plot(x, y)
875             axes[1, 1].scatter(x, y)
876 
877             # Share an X-axis with each column of subplots
878             fig.subplots(2, 2, sharex='col')
879 
880             # Share a Y-axis with each row of subplots
881             fig.subplots(2, 2, sharey='row')
882 
883             # Share both X- and Y-axes with all subplots
884             fig.subplots(2, 2, sharex='all', sharey='all')
885 
886             # Note that this is the same as
887             fig.subplots(2, 2, sharex=True, sharey=True)
888         """
889         gridspec_kw = dict(gridspec_kw or {})
890         if height_ratios is not None:
891             if 'height_ratios' in gridspec_kw:
892                 raise ValueError("'height_ratios' must not be defined both as "
893                                  "parameter and as key in 'gridspec_kw'")
894             gridspec_kw['height_ratios'] = height_ratios
895         if width_ratios is not None:
896             if 'width_ratios' in gridspec_kw:
897                 raise ValueError("'width_ratios' must not be defined both as "
898                                  "parameter and as key in 'gridspec_kw'")
899             gridspec_kw['width_ratios'] = width_ratios
900 
901         gs = self.add_gridspec(nrows, ncols, figure=self, **gridspec_kw)
902         axs = gs.subplots(sharex=sharex, sharey=sharey, squeeze=squeeze,
903                           subplot_kw=subplot_kw)
904         return axs
905 
906     def delaxes(self, ax):
907         """
908         Remove the `~.axes.Axes` *ax* from the figure; update the current Axes.
909         """
910 
911         def _reset_locators_and_formatters(axis):
912             # Set the formatters and locators to be associated with axis
913             # (where previously they may have been associated with another
914             # Axis instance)
915             axis.get_major_formatter().set_axis(axis)
916             axis.get_major_locator().set_axis(axis)
917             axis.get_minor_formatter().set_axis(axis)
918             axis.get_minor_locator().set_axis(axis)
919 
920         def _break_share_link(ax, grouper):
921             siblings = grouper.get_siblings(ax)
922             if len(siblings) > 1:
923                 grouper.remove(ax)
924                 for last_ax in siblings:
925                     if ax is not last_ax:
926                         return last_ax
927             return None
928 
929         self._axstack.remove(ax)
930         self._axobservers.process("_axes_change_event", self)
931         self.stale = True
932         self._localaxes.remove(ax)
933         self.canvas.release_mouse(ax)
934 
935         # Break link between any shared axes
936         for name in ax._axis_names:
937             last_ax = _break_share_link(ax, ax._shared_axes[name])
938             if last_ax is not None:
939                 _reset_locators_and_formatters(last_ax._axis_map[name])
940 
941         # Break link between any twinned axes
942         _break_share_link(ax, ax._twinned_axes)
943 
944     def clear(self, keep_observers=False):
945         """
946         Clear the figure.
947 
948         Parameters
949         ----------
950         keep_observers : bool, default: False
951             Set *keep_observers* to True if, for example,
952             a gui widget is tracking the Axes in the figure.
953         """
954         self.suppressComposite = None
955 
956         # first clear the axes in any subfigures
957         for subfig in self.subfigs:
958             subfig.clear(keep_observers=keep_observers)
959         self.subfigs = []
960 
961         for ax in tuple(self.axes):  # Iterate over the copy.
962             ax.clear()
963             self.delaxes(ax)  # Remove ax from self._axstack.
964 
965         self.artists = []
966         self.lines = []
967         self.patches = []
968         self.texts = []
969         self.images = []
970         self.legends = []
971         if not keep_observers:
972             self._axobservers = cbook.CallbackRegistry()
973         self._suptitle = None
974         self._supxlabel = None
975         self._supylabel = None
976 
977         self.stale = True
978 
979     # synonym for `clear`.
980     def clf(self, keep_observers=False):
981         """
982         [*Discouraged*] Alias for the `clear()` method.
983 
984         .. admonition:: Discouraged
985 
986             The use of ``clf()`` is discouraged. Use ``clear()`` instead.
987 
988         Parameters
989         ----------
990         keep_observers : bool, default: False
991             Set *keep_observers* to True if, for example,
992             a gui widget is tracking the Axes in the figure.
993         """
994         return self.clear(keep_observers=keep_observers)
995 
996     # Note: the docstring below is modified with replace for the pyplot
997     # version of this function because the method name differs (plt.figlegend)
998     # the replacements are:
999     #    " legend(" -> " figlegend(" for the signatures
1000     #    "fig.legend(" -> "plt.figlegend" for the code examples
1001     #    "ax.plot" -> "plt.plot" for consistency in using pyplot when able
1002     @_docstring.dedent_interpd
1003     def legend(self, *args, **kwargs):
1004         """
1005         Place a legend on the figure.
1006 
1007         Call signatures::
1008 
1009             legend()
1010             legend(handles, labels)
1011             legend(handles=handles)
1012             legend(labels)
1013 
1014         The call signatures correspond to the following different ways to use
1015         this method:
1016 
1017         **1. Automatic detection of elements to be shown in the legend**
1018 
1019         The elements to be added to the legend are automatically determined,
1020         when you do not pass in any extra arguments.
1021 
1022         In this case, the labels are taken from the artist. You can specify
1023         them either at artist creation or by calling the
1024         :meth:`~.Artist.set_label` method on the artist::
1025 
1026             ax.plot([1, 2, 3], label='Inline label')
1027             fig.legend()
1028 
1029         or::
1030 
1031             line, = ax.plot([1, 2, 3])
1032             line.set_label('Label via method')
1033             fig.legend()
1034 
1035         Specific lines can be excluded from the automatic legend element
1036         selection by defining a label starting with an underscore.
1037         This is default for all artists, so calling `.Figure.legend` without
1038         any arguments and without setting the labels manually will result in
1039         no legend being drawn.
1040 
1041 
1042         **2. Explicitly listing the artists and labels in the legend**
1043 
1044         For full control of which artists have a legend entry, it is possible
1045         to pass an iterable of legend artists followed by an iterable of
1046         legend labels respectively::
1047 
1048             fig.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
1049 
1050 
1051         **3. Explicitly listing the artists in the legend**
1052 
1053         This is similar to 2, but the labels are taken from the artists'
1054         label properties. Example::
1055 
1056             line1, = ax1.plot([1, 2, 3], label='label1')
1057             line2, = ax2.plot([1, 2, 3], label='label2')
1058             fig.legend(handles=[line1, line2])
1059 
1060 
1061         **4. Labeling existing plot elements**
1062 
1063         .. admonition:: Discouraged
1064 
1065             This call signature is discouraged, because the relation between
1066             plot elements and labels is only implicit by their order and can
1067             easily be mixed up.
1068 
1069         To make a legend for all artists on all Axes, call this function with
1070         an iterable of strings, one for each legend item. For example::
1071 
1072             fig, (ax1, ax2) = plt.subplots(1, 2)
1073             ax1.plot([1, 3, 5], color='blue')
1074             ax2.plot([2, 4, 6], color='red')
1075             fig.legend(['the blues', 'the reds'])
1076 
1077 
1078         Parameters
1079         ----------
1080         handles : list of `.Artist`, optional
1081             A list of Artists (lines, patches) to be added to the legend.
1082             Use this together with *labels*, if you need full control on what
1083             is shown in the legend and the automatic mechanism described above
1084             is not sufficient.
1085 
1086             The length of handles and labels should be the same in this
1087             case. If they are not, they are truncated to the smaller length.
1088 
1089         labels : list of str, optional
1090             A list of labels to show next to the artists.
1091             Use this together with *handles*, if you need full control on what
1092             is shown in the legend and the automatic mechanism described above
1093             is not sufficient.
1094 
1095         Returns
1096         -------
1097         `~matplotlib.legend.Legend`
1098 
1099         Other Parameters
1100         ----------------
1101         %(_legend_kw_figure)s
1102 
1103         See Also
1104         --------
1105         .Axes.legend
1106 
1107         Notes
1108         -----
1109         Some artists are not supported by this function.  See
1110         :ref:`legend_guide` for details.
1111         """
1112 
1113         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1114                 self.axes,
1115                 *args,
1116                 **kwargs)
1117         # check for third arg
1118         if len(extra_args):
1119             # _api.warn_deprecated(
1120             #     "2.1",
1121             #     message="Figure.legend will accept no more than two "
1122             #     "positional arguments in the future.  Use "
1123             #     "'fig.legend(handles, labels, loc=location)' "
1124             #     "instead.")
1125             # kwargs['loc'] = extra_args[0]
1126             # extra_args = extra_args[1:]
1127             pass
1128         transform = kwargs.pop('bbox_transform', self.transSubfigure)
1129         # explicitly set the bbox transform if the user hasn't.
1130         l = mlegend.Legend(self, handles, labels, *extra_args,
1131                            bbox_transform=transform, **kwargs)
1132         self.legends.append(l)
1133         l._remove_method = self.legends.remove
1134         self.stale = True
1135         return l
1136 
1137     @_docstring.dedent_interpd
1138     def text(self, x, y, s, fontdict=None, **kwargs):
1139         """
1140         Add text to figure.
1141 
1142         Parameters
1143         ----------
1144         x, y : float
1145             The position to place the text. By default, this is in figure
1146             coordinates, floats in [0, 1]. The coordinate system can be changed
1147             using the *transform* keyword.
1148 
1149         s : str
1150             The text string.
1151 
1152         fontdict : dict, optional
1153             A dictionary to override the default text properties. If not given,
1154             the defaults are determined by :rc:`font.*`. Properties passed as
1155             *kwargs* override the corresponding ones given in *fontdict*.
1156 
1157         Returns
1158         -------
1159         `~.text.Text`
1160 
1161         Other Parameters
1162         ----------------
1163         **kwargs : `~matplotlib.text.Text` properties
1164             Other miscellaneous text parameters.
1165 
1166             %(Text:kwdoc)s
1167 
1168         See Also
1169         --------
1170         .Axes.text
1171         .pyplot.text
1172         """
1173         effective_kwargs = {
1174             'transform': self.transSubfigure,
1175             **(fontdict if fontdict is not None else {}),
1176             **kwargs,
1177         }
1178         text = Text(x=x, y=y, text=s, **effective_kwargs)
1179         text.set_figure(self)
1180         text.stale_callback = _stale_figure_callback
1181 
1182         self.texts.append(text)
1183         text._remove_method = self.texts.remove
1184         self.stale = True
1185         return text
1186 
1187     @_docstring.dedent_interpd
1188     def colorbar(
1189             self, mappable, cax=None, ax=None, use_gridspec=True, **kwargs):
1190         """
1191         Add a colorbar to a plot.
1192 
1193         Parameters
1194         ----------
1195         mappable
1196             The `matplotlib.cm.ScalarMappable` (i.e., `.AxesImage`,
1197             `.ContourSet`, etc.) described by this colorbar.  This argument is
1198             mandatory for the `.Figure.colorbar` method but optional for the
1199             `.pyplot.colorbar` function, which sets the default to the current
1200             image.
1201 
1202             Note that one can create a `.ScalarMappable` "on-the-fly" to
1203             generate colorbars not attached to a previously drawn artist, e.g.
1204             ::
1205 
1206                 fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
1207 
1208         cax : `~matplotlib.axes.Axes`, optional
1209             Axes into which the colorbar will be drawn.
1210 
1211         ax : `~.axes.Axes` or iterable or `numpy.ndarray` of Axes, optional
1212             One or more parent axes from which space for a new colorbar axes
1213             will be stolen, if *cax* is None.  This has no effect if *cax* is
1214             set.
1215 
1216         use_gridspec : bool, optional
1217             If *cax* is ``None``, a new *cax* is created as an instance of
1218             Axes.  If *ax* is positioned with a subplotspec and *use_gridspec*
1219             is ``True``, then *cax* is also positioned with a subplotspec.
1220 
1221         Returns
1222         -------
1223         colorbar : `~matplotlib.colorbar.Colorbar`
1224 
1225         Other Parameters
1226         ----------------
1227         %(_make_axes_kw_doc)s
1228         %(_colormap_kw_doc)s
1229 
1230         Notes
1231         -----
1232         If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is
1233         included automatically.
1234 
1235         The *shrink* kwarg provides a simple way to scale the colorbar with
1236         respect to the axes. Note that if *cax* is specified, it determines the
1237         size of the colorbar, and *shrink* and *aspect* are ignored.
1238 
1239         For more precise control, you can manually specify the positions of the
1240         axes objects in which the mappable and the colorbar are drawn.  In this
1241         case, do not use any of the axes properties kwargs.
1242 
1243         It is known that some vector graphics viewers (svg and pdf) render
1244         white gaps between segments of the colorbar.  This is due to bugs in
1245         the viewers, not Matplotlib.  As a workaround, the colorbar can be
1246         rendered with overlapping segments::
1247 
1248             cbar = colorbar()
1249             cbar.solids.set_edgecolor("face")
1250             draw()
1251 
1252         However, this has negative consequences in other circumstances, e.g.
1253         with semi-transparent images (alpha < 1) and colorbar extensions;
1254         therefore, this workaround is not used by default (see issue #1188).
1255         """
1256 
1257         if ax is None:
1258             ax = getattr(mappable, "axes", None)
1259 
1260         if (self.get_layout_engine() is not None and
1261                 not self.get_layout_engine().colorbar_gridspec):
1262             use_gridspec = False
1263         if cax is None:
1264             if ax is None:
1265                 raise ValueError(
1266                     'Unable to determine Axes to steal space for Colorbar. '
1267                     'Either provide the *cax* argument to use as the Axes for '
1268                     'the Colorbar, provide the *ax* argument to steal space '
1269                     'from it, or add *mappable* to an Axes.')
1270             current_ax = self.gca()
1271             if (use_gridspec
1272                     and isinstance(ax, mpl.axes._base._AxesBase)
1273                     and ax.get_subplotspec()):
1274                 cax, kwargs = cbar.make_axes_gridspec(ax, **kwargs)
1275             else:
1276                 cax, kwargs = cbar.make_axes(ax, **kwargs)
1277             # make_axes calls add_{axes,subplot} which changes gca; undo that.
1278             self.sca(current_ax)
1279             cax.grid(visible=False, which='both', axis='both')
1280 
1281         NON_COLORBAR_KEYS = [  # remove kws that cannot be passed to Colorbar
1282             'fraction', 'pad', 'shrink', 'aspect', 'anchor', 'panchor']
1283         cb = cbar.Colorbar(cax, mappable, **{
1284             k: v for k, v in kwargs.items() if k not in NON_COLORBAR_KEYS})
1285         self.stale = True
1286         return cb
1287 
1288     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
1289                         wspace=None, hspace=None):
1290         """
1291         Adjust the subplot layout parameters.
1292 
1293         Unset parameters are left unmodified; initial values are given by
1294         :rc:`figure.subplot.[name]`.
1295 
1296         Parameters
1297         ----------
1298         left : float, optional
1299             The position of the left edge of the subplots,
1300             as a fraction of the figure width.
1301         right : float, optional
1302             The position of the right edge of the subplots,
1303             as a fraction of the figure width.
1304         bottom : float, optional
1305             The position of the bottom edge of the subplots,
1306             as a fraction of the figure height.
1307         top : float, optional
1308             The position of the top edge of the subplots,
1309             as a fraction of the figure height.
1310         wspace : float, optional
1311             The width of the padding between subplots,
1312             as a fraction of the average Axes width.
1313         hspace : float, optional
1314             The height of the padding between subplots,
1315             as a fraction of the average Axes height.
1316         """
1317         if (self.get_layout_engine() is not None and
1318                 not self.get_layout_engine().adjust_compatible):
1319             _api.warn_external(
1320                 "This figure was using a layout engine that is "
1321                 "incompatible with subplots_adjust and/or tight_layout; "
1322                 "not calling subplots_adjust.")
1323             return
1324         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
1325         for ax in self.axes:
1326             if ax.get_subplotspec() is not None:
1327                 ax._set_position(ax.get_subplotspec().get_position(self))
1328         self.stale = True
1329 
1330     def align_xlabels(self, axs=None):
1331         """
1332         Align the xlabels of subplots in the same subplot column if label
1333         alignment is being done automatically (i.e. the label position is
1334         not manually set).
1335 
1336         Alignment persists for draw events after this is called.
1337 
1338         If a label is on the bottom, it is aligned with labels on Axes that
1339         also have their label on the bottom and that have the same
1340         bottom-most subplot row.  If the label is on the top,
1341         it is aligned with labels on Axes with the same top-most row.
1342 
1343         Parameters
1344         ----------
1345         axs : list of `~matplotlib.axes.Axes`
1346             Optional list of (or `~numpy.ndarray`) `~matplotlib.axes.Axes`
1347             to align the xlabels.
1348             Default is to align all Axes on the figure.
1349 
1350         See Also
1351         --------
1352         matplotlib.figure.Figure.align_ylabels
1353         matplotlib.figure.Figure.align_labels
1354 
1355         Notes
1356         -----
1357         This assumes that ``axs`` are from the same `.GridSpec`, so that
1358         their `.SubplotSpec` positions correspond to figure positions.
1359 
1360         Examples
1361         --------
1362         Example with rotated xtick labels::
1363 
1364             fig, axs = plt.subplots(1, 2)
1365             for tick in axs[0].get_xticklabels():
1366                 tick.set_rotation(55)
1367             axs[0].set_xlabel('XLabel 0')
1368             axs[1].set_xlabel('XLabel 1')
1369             fig.align_xlabels()
1370         """
1371         if axs is None:
1372             axs = self.axes
1373         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1374         for ax in axs:
1375             _log.debug(' Working on: %s', ax.get_xlabel())
1376             rowspan = ax.get_subplotspec().rowspan
1377             pos = ax.xaxis.get_label_position()  # top or bottom
1378             # Search through other axes for label positions that are same as
1379             # this one and that share the appropriate row number.
1380             # Add to a grouper associated with each axes of siblings.
1381             # This list is inspected in `axis.draw` by
1382             # `axis._update_label_position`.
1383             for axc in axs:
1384                 if axc.xaxis.get_label_position() == pos:
1385                     rowspanc = axc.get_subplotspec().rowspan
1386                     if (pos == 'top' and rowspan.start == rowspanc.start or
1387                             pos == 'bottom' and rowspan.stop == rowspanc.stop):
1388                         # grouper for groups of xlabels to align
1389                         self._align_label_groups['x'].join(ax, axc)
1390 
1391     def align_ylabels(self, axs=None):
1392         """
1393         Align the ylabels of subplots in the same subplot column if label
1394         alignment is being done automatically (i.e. the label position is
1395         not manually set).
1396 
1397         Alignment persists for draw events after this is called.
1398 
1399         If a label is on the left, it is aligned with labels on Axes that
1400         also have their label on the left and that have the same
1401         left-most subplot column.  If the label is on the right,
1402         it is aligned with labels on Axes with the same right-most column.
1403 
1404         Parameters
1405         ----------
1406         axs : list of `~matplotlib.axes.Axes`
1407             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1408             to align the ylabels.
1409             Default is to align all Axes on the figure.
1410 
1411         See Also
1412         --------
1413         matplotlib.figure.Figure.align_xlabels
1414         matplotlib.figure.Figure.align_labels
1415 
1416         Notes
1417         -----
1418         This assumes that ``axs`` are from the same `.GridSpec`, so that
1419         their `.SubplotSpec` positions correspond to figure positions.
1420 
1421         Examples
1422         --------
1423         Example with large yticks labels::
1424 
1425             fig, axs = plt.subplots(2, 1)
1426             axs[0].plot(np.arange(0, 1000, 50))
1427             axs[0].set_ylabel('YLabel 0')
1428             axs[1].set_ylabel('YLabel 1')
1429             fig.align_ylabels()
1430         """
1431         if axs is None:
1432             axs = self.axes
1433         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1434         for ax in axs:
1435             _log.debug(' Working on: %s', ax.get_ylabel())
1436             colspan = ax.get_subplotspec().colspan
1437             pos = ax.yaxis.get_label_position()  # left or right
1438             # Search through other axes for label positions that are same as
1439             # this one and that share the appropriate column number.
1440             # Add to a list associated with each axes of siblings.
1441             # This list is inspected in `axis.draw` by
1442             # `axis._update_label_position`.
1443             for axc in axs:
1444                 if axc.yaxis.get_label_position() == pos:
1445                     colspanc = axc.get_subplotspec().colspan
1446                     if (pos == 'left' and colspan.start == colspanc.start or
1447                             pos == 'right' and colspan.stop == colspanc.stop):
1448                         # grouper for groups of ylabels to align
1449                         self._align_label_groups['y'].join(ax, axc)
1450 
1451     def align_labels(self, axs=None):
1452         """
1453         Align the xlabels and ylabels of subplots with the same subplots
1454         row or column (respectively) if label alignment is being
1455         done automatically (i.e. the label position is not manually set).
1456 
1457         Alignment persists for draw events after this is called.
1458 
1459         Parameters
1460         ----------
1461         axs : list of `~matplotlib.axes.Axes`
1462             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1463             to align the labels.
1464             Default is to align all Axes on the figure.
1465 
1466         See Also
1467         --------
1468         matplotlib.figure.Figure.align_xlabels
1469 
1470         matplotlib.figure.Figure.align_ylabels
1471         """
1472         self.align_xlabels(axs=axs)
1473         self.align_ylabels(axs=axs)
1474 
1475     def add_gridspec(self, nrows=1, ncols=1, **kwargs):
1476         """
1477         Return a `.GridSpec` that has this figure as a parent.  This allows
1478         complex layout of Axes in the figure.
1479 
1480         Parameters
1481         ----------
1482         nrows : int, default: 1
1483             Number of rows in grid.
1484 
1485         ncols : int, default: 1
1486             Number of columns in grid.
1487 
1488         Returns
1489         -------
1490         `.GridSpec`
1491 
1492         Other Parameters
1493         ----------------
1494         **kwargs
1495             Keyword arguments are passed to `.GridSpec`.
1496 
1497         See Also
1498         --------
1499         matplotlib.pyplot.subplots
1500 
1501         Examples
1502         --------
1503         Adding a subplot that spans two rows::
1504 
1505             fig = plt.figure()
1506             gs = fig.add_gridspec(2, 2)
1507             ax1 = fig.add_subplot(gs[0, 0])
1508             ax2 = fig.add_subplot(gs[1, 0])
1509             # spans two rows:
1510             ax3 = fig.add_subplot(gs[:, 1])
1511 
1512         """
1513 
1514         _ = kwargs.pop('figure', None)  # pop in case user has added this...
1515         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
1516         return gs
1517 
1518     def subfigures(self, nrows=1, ncols=1, squeeze=True,
1519                    wspace=None, hspace=None,
1520                    width_ratios=None, height_ratios=None,
1521                    **kwargs):
1522         """
1523         Add a set of subfigures to this figure or subfigure.
1524 
1525         A subfigure has the same artist methods as a figure, and is logically
1526         the same as a figure, but cannot print itself.
1527         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.
1528 
1529         Parameters
1530         ----------
1531         nrows, ncols : int, default: 1
1532             Number of rows/columns of the subfigure grid.
1533 
1534         squeeze : bool, default: True
1535             If True, extra dimensions are squeezed out from the returned
1536             array of subfigures.
1537 
1538         wspace, hspace : float, default: None
1539             The amount of width/height reserved for space between subfigures,
1540             expressed as a fraction of the average subfigure width/height.
1541             If not given, the values will be inferred from a figure or
1542             rcParams when necessary.
1543 
1544         width_ratios : array-like of length *ncols*, optional
1545             Defines the relative widths of the columns. Each column gets a
1546             relative width of ``width_ratios[i] / sum(width_ratios)``.
1547             If not given, all columns will have the same width.
1548 
1549         height_ratios : array-like of length *nrows*, optional
1550             Defines the relative heights of the rows. Each row gets a
1551             relative height of ``height_ratios[i] / sum(height_ratios)``.
1552             If not given, all rows will have the same height.
1553         """
1554         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,
1555                       wspace=wspace, hspace=hspace,
1556                       width_ratios=width_ratios,
1557                       height_ratios=height_ratios)
1558 
1559         sfarr = np.empty((nrows, ncols), dtype=object)
1560         for i in range(ncols):
1561             for j in range(nrows):
1562                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)
1563 
1564         if squeeze:
1565             # Discarding unneeded dimensions that equal 1.  If we only have one
1566             # subfigure, just return it instead of a 1-element array.
1567             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()
1568         else:
1569             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1570             return sfarr
1571 
1572     def add_subfigure(self, subplotspec, **kwargs):
1573         """
1574         Add a `.SubFigure` to the figure as part of a subplot arrangement.
1575 
1576         Parameters
1577         ----------
1578         subplotspec : `.gridspec.SubplotSpec`
1579             Defines the region in a parent gridspec where the subfigure will
1580             be placed.
1581 
1582         Returns
1583         -------
1584         `.SubFigure`
1585 
1586         Other Parameters
1587         ----------------
1588         **kwargs
1589             Are passed to the `.SubFigure` object.
1590 
1591         See Also
1592         --------
1593         .Figure.subfigures
1594         """
1595         sf = SubFigure(self, subplotspec, **kwargs)
1596         self.subfigs += [sf]
1597         return sf
1598 
1599     def sca(self, a):
1600         """Set the current Axes to be *a* and return *a*."""
1601         self._axstack.bubble(a)
1602         self._axobservers.process("_axes_change_event", self)
1603         return a
1604 
1605     def gca(self):
1606         """
1607         Get the current Axes.
1608 
1609         If there is currently no Axes on this Figure, a new one is created
1610         using `.Figure.add_subplot`.  (To test whether there is currently an
1611         Axes on a Figure, check whether ``figure.axes`` is empty.  To test
1612         whether there is currently a Figure on the pyplot figure stack, check
1613         whether `.pyplot.get_fignums()` is empty.)
1614         """
1615         ax = self._axstack.current()
1616         return ax if ax is not None else self.add_subplot()
1617 
1618     def _gci(self):
1619         # Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.
1620         """
1621         Get the current colorable artist.
1622 
1623         Specifically, returns the current `.ScalarMappable` instance (`.Image`
1624         created by `imshow` or `figimage`, `.Collection` created by `pcolor` or
1625         `scatter`, etc.), or *None* if no such instance has been defined.
1626 
1627         The current image is an attribute of the current Axes, or the nearest
1628         earlier Axes in the current figure that contains an image.
1629 
1630         Notes
1631         -----
1632         Historically, the only colorable artists were images; hence the name
1633         ``gci`` (get current image).
1634         """
1635         # Look first for an image in the current Axes.
1636         ax = self._axstack.current()
1637         if ax is None:
1638             return None
1639         im = ax._gci()
1640         if im is not None:
1641             return im
1642         # If there is no image in the current Axes, search for
1643         # one in a previously created Axes.  Whether this makes
1644         # sense is debatable, but it is the documented behavior.
1645         for ax in reversed(self.axes):
1646             im = ax._gci()
1647             if im is not None:
1648                 return im
1649         return None
1650 
1651     def _process_projection_requirements(
1652             self, *args, axes_class=None, polar=False, projection=None,
1653             **kwargs):
1654         """
1655         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1656 
1657             (axes_proj_class, proj_class_kwargs)
1658 
1659         which can be used for new Axes initialization/identification.
1660         """
1661         if axes_class is not None:
1662             if polar or projection is not None:
1663                 raise ValueError(
1664                     "Cannot combine 'axes_class' and 'projection' or 'polar'")
1665             projection_class = axes_class
1666         else:
1667 
1668             if polar:
1669                 if projection is not None and projection != 'polar':
1670                     raise ValueError(
1671                         f"polar={polar}, yet projection={projection!r}. "
1672                         "Only one of these arguments should be supplied."
1673                     )
1674                 projection = 'polar'
1675 
1676             if isinstance(projection, str) or projection is None:
1677                 projection_class = projections.get_projection_class(projection)
1678             elif hasattr(projection, '_as_mpl_axes'):
1679                 projection_class, extra_kwargs = projection._as_mpl_axes()
1680                 kwargs.update(**extra_kwargs)
1681             else:
1682                 raise TypeError(
1683                     f"projection must be a string, None or implement a "
1684                     f"_as_mpl_axes method, not {projection!r}")
1685         return projection_class, kwargs
1686 
1687     def get_default_bbox_extra_artists(self):
1688         bbox_artists = [artist for artist in self.get_children()
1689                         if (artist.get_visible() and artist.get_in_layout())]
1690         for ax in self.axes:
1691             if ax.get_visible():
1692                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
1693         return bbox_artists
1694 
1695     @_api.make_keyword_only("3.8", "bbox_extra_artists")
1696     def get_tightbbox(self, renderer=None, bbox_extra_artists=None):
1697         """
1698         Return a (tight) bounding box of the figure *in inches*.
1699 
1700         Note that `.FigureBase` differs from all other artists, which return
1701         their `.Bbox` in pixels.
1702 
1703         Artists that have ``artist.set_in_layout(False)`` are not included
1704         in the bbox.
1705 
1706         Parameters
1707         ----------
1708         renderer : `.RendererBase` subclass
1709             Renderer that will be used to draw the figures (i.e.
1710             ``fig.canvas.get_renderer()``)
1711 
1712         bbox_extra_artists : list of `.Artist` or ``None``
1713             List of artists to include in the tight bounding box.  If
1714             ``None`` (default), then all artist children of each Axes are
1715             included in the tight bounding box.
1716 
1717         Returns
1718         -------
1719         `.BboxBase`
1720             containing the bounding box (in figure inches).
1721         """
1722 
1723         if renderer is None:
1724             renderer = self.figure._get_renderer()
1725 
1726         bb = []
1727         if bbox_extra_artists is None:
1728             artists = self.get_default_bbox_extra_artists()
1729         else:
1730             artists = bbox_extra_artists
1731 
1732         for a in artists:
1733             bbox = a.get_tightbbox(renderer)
1734             if bbox is not None:
1735                 bb.append(bbox)
1736 
1737         for ax in self.axes:
1738             if ax.get_visible():
1739                 # some axes don't take the bbox_extra_artists kwarg so we
1740                 # need this conditional....
1741                 try:
1742                     bbox = ax.get_tightbbox(
1743                         renderer, bbox_extra_artists=bbox_extra_artists)
1744                 except TypeError:
1745                     bbox = ax.get_tightbbox(renderer)
1746                 bb.append(bbox)
1747         bb = [b for b in bb
1748               if (np.isfinite(b.width) and np.isfinite(b.height)
1749                   and (b.width != 0 or b.height != 0))]
1750 
1751         isfigure = hasattr(self, 'bbox_inches')
1752         if len(bb) == 0:
1753             if isfigure:
1754                 return self.bbox_inches
1755             else:
1756                 # subfigures do not have bbox_inches, but do have a bbox
1757                 bb = [self.bbox]
1758 
1759         _bbox = Bbox.union(bb)
1760 
1761         if isfigure:
1762             # transform from pixels to inches...
1763             _bbox = TransformedBbox(_bbox, self.dpi_scale_trans.inverted())
1764 
1765         return _bbox
1766 
1767     @staticmethod
1768     def _norm_per_subplot_kw(per_subplot_kw):
1769         expanded = {}
1770         for k, v in per_subplot_kw.items():
1771             if isinstance(k, tuple):
1772                 for sub_key in k:
1773                     if sub_key in expanded:
1774                         raise ValueError(
1775                             f'The key {sub_key!r} appears multiple times.'
1776                             )
1777                     expanded[sub_key] = v
1778             else:
1779                 if k in expanded:
1780                     raise ValueError(
1781                         f'The key {k!r} appears multiple times.'
1782                     )
1783                 expanded[k] = v
1784         return expanded
1785 
1786     @staticmethod
1787     def _normalize_grid_string(layout):
1788         if '\n' not in layout:
1789             # single-line string
1790             return [list(ln) for ln in layout.split(';')]
1791         else:
1792             # multi-line string
1793             layout = inspect.cleandoc(layout)
1794             return [list(ln) for ln in layout.strip('\n').split('\n')]
1795 
1796     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1797                        width_ratios=None, height_ratios=None,
1798                        empty_sentinel='.',
1799                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1800         """
1801         Build a layout of Axes based on ASCII art or nested lists.
1802 
1803         This is a helper function to build complex GridSpec layouts visually.
1804 
1805         See :ref:`mosaic`
1806         for an example and full API documentation
1807 
1808         Parameters
1809         ----------
1810         mosaic : list of list of {hashable or nested} or str
1811 
1812             A visual layout of how you want your Axes to be arranged
1813             labeled as strings.  For example ::
1814 
1815                x = [['A panel', 'A panel', 'edge'],
1816                     ['C panel', '.',       'edge']]
1817 
1818             produces 4 Axes:
1819 
1820             - 'A panel' which is 1 row high and spans the first two columns
1821             - 'edge' which is 2 rows high and is on the right edge
1822             - 'C panel' which in 1 row and 1 column wide in the bottom left
1823             - a blank space 1 row and 1 column wide in the bottom center
1824 
1825             Any of the entries in the layout can be a list of lists
1826             of the same form to create nested layouts.
1827 
1828             If input is a str, then it can either be a multi-line string of
1829             the form ::
1830 
1831               '''
1832               AAE
1833               C.E
1834               '''
1835 
1836             where each character is a column and each line is a row. Or it
1837             can be a single-line string where rows are separated by ``;``::
1838 
1839               'AB;CC'
1840 
1841             The string notation allows only single character Axes labels and
1842             does not support nesting but is very terse.
1843 
1844             The Axes identifiers may be `str` or a non-iterable hashable
1845             object (e.g. `tuple` s may not be used).
1846 
1847         sharex, sharey : bool, default: False
1848             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1849             among all subplots.  In that case, tick label visibility and axis
1850             units behave as for `subplots`.  If False, each subplot's x- or
1851             y-axis will be independent.
1852 
1853         width_ratios : array-like of length *ncols*, optional
1854             Defines the relative widths of the columns. Each column gets a
1855             relative width of ``width_ratios[i] / sum(width_ratios)``.
1856             If not given, all columns will have the same width.  Equivalent
1857             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1858             layouts, this argument applies only to the outer layout.
1859 
1860         height_ratios : array-like of length *nrows*, optional
1861             Defines the relative heights of the rows. Each row gets a
1862             relative height of ``height_ratios[i] / sum(height_ratios)``.
1863             If not given, all rows will have the same height. Equivalent
1864             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1865             layouts, this argument applies only to the outer layout.
1866 
1867         subplot_kw : dict, optional
1868             Dictionary with keywords passed to the `.Figure.add_subplot` call
1869             used to create each subplot.  These values may be overridden by
1870             values in *per_subplot_kw*.
1871 
1872         per_subplot_kw : dict, optional
1873             A dictionary mapping the Axes identifiers or tuples of identifiers
1874             to a dictionary of keyword arguments to be passed to the
1875             `.Figure.add_subplot` call used to create each subplot.  The values
1876             in these dictionaries have precedence over the values in
1877             *subplot_kw*.
1878 
1879             If *mosaic* is a string, and thus all keys are single characters,
1880             it is possible to use a single string instead of a tuple as keys;
1881             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1882 
1883             .. versionadded:: 3.7
1884 
1885         gridspec_kw : dict, optional
1886             Dictionary with keywords passed to the `.GridSpec` constructor used
1887             to create the grid the subplots are placed on. In the case of
1888             nested layouts, this argument applies only to the outer layout.
1889             For more complex layouts, users should use `.Figure.subfigures`
1890             to create the nesting.
1891 
1892         empty_sentinel : object, optional
1893             Entry in the layout to mean "leave this space empty".  Defaults
1894             to ``'.'``. Note, if *layout* is a string, it is processed via
1895             `inspect.cleandoc` to remove leading white space, which may
1896             interfere with using white-space as the empty sentinel.
1897 
1898         Returns
1899         -------
1900         dict[label, Axes]
1901            A dictionary mapping the labels to the Axes objects.  The order of
1902            the axes is left-to-right and top-to-bottom of their position in the
1903            total layout.
1904 
1905         """
1906         subplot_kw = subplot_kw or {}
1907         gridspec_kw = dict(gridspec_kw or {})
1908         per_subplot_kw = per_subplot_kw or {}
1909 
1910         if height_ratios is not None:
1911             if 'height_ratios' in gridspec_kw:
1912                 raise ValueError("'height_ratios' must not be defined both as "
1913                                  "parameter and as key in 'gridspec_kw'")
1914             gridspec_kw['height_ratios'] = height_ratios
1915         if width_ratios is not None:
1916             if 'width_ratios' in gridspec_kw:
1917                 raise ValueError("'width_ratios' must not be defined both as "
1918                                  "parameter and as key in 'gridspec_kw'")
1919             gridspec_kw['width_ratios'] = width_ratios
1920 
1921         # special-case string input
1922         if isinstance(mosaic, str):
1923             mosaic = self._normalize_grid_string(mosaic)
1924             per_subplot_kw = {
1925                 tuple(k): v for k, v in per_subplot_kw.items()
1926             }
1927 
1928         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1929 
1930         # Only accept strict bools to allow a possible future API expansion.
1931         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1932 
1933         def _make_array(inp):
1934             """
1935             Convert input into 2D array
1936 
1937             We need to have this internal function rather than
1938             ``np.asarray(..., dtype=object)`` so that a list of lists
1939             of lists does not get converted to an array of dimension > 2.
1940 
1941             Returns
1942             -------
1943             2D object array
1944             """
1945             r0, *rest = inp
1946             if isinstance(r0, str):
1947                 raise ValueError('List mosaic specification must be 2D')
1948             for j, r in enumerate(rest, start=1):
1949                 if isinstance(r, str):
1950                     raise ValueError('List mosaic specification must be 2D')
1951                 if len(r0) != len(r):
1952                     raise ValueError(
1953                         "All of the rows must be the same length, however "
1954                         f"the first row ({r0!r}) has length {len(r0)} "
1955                         f"and row {j} ({r!r}) has length {len(r)}."
1956                     )
1957             out = np.zeros((len(inp), len(r0)), dtype=object)
1958             for j, r in enumerate(inp):
1959                 for k, v in enumerate(r):
1960                     out[j, k] = v
1961             return out
1962 
1963         def _identify_keys_and_nested(mosaic):
1964             """
1965             Given a 2D object array, identify unique IDs and nested mosaics
1966 
1967             Parameters
1968             ----------
1969             mosaic : 2D object array
1970 
1971             Returns
1972             -------
1973             unique_ids : tuple
1974                 The unique non-sub mosaic entries in this mosaic
1975             nested : dict[tuple[int, int], 2D object array]
1976             """
1977             # make sure we preserve the user supplied order
1978             unique_ids = cbook._OrderedSet()
1979             nested = {}
1980             for j, row in enumerate(mosaic):
1981                 for k, v in enumerate(row):
1982                     if v == empty_sentinel:
1983                         continue
1984                     elif not cbook.is_scalar_or_string(v):
1985                         nested[(j, k)] = _make_array(v)
1986                     else:
1987                         unique_ids.add(v)
1988 
1989             return tuple(unique_ids), nested
1990 
1991         def _do_layout(gs, mosaic, unique_ids, nested):
1992             """
1993             Recursively do the mosaic.
1994 
1995             Parameters
1996             ----------
1997             gs : GridSpec
1998             mosaic : 2D object array
1999                 The input converted to a 2D array for this level.
2000             unique_ids : tuple
2001                 The identified scalar labels at this level of nesting.
2002             nested : dict[tuple[int, int]], 2D object array
2003                 The identified nested mosaics, if any.
2004 
2005             Returns
2006             -------
2007             dict[label, Axes]
2008                 A flat dict of all of the Axes created.
2009             """
2010             output = dict()
2011 
2012             # we need to merge together the Axes at this level and the axes
2013             # in the (recursively) nested sub-mosaics so that we can add
2014             # them to the figure in the "natural" order if you were to
2015             # ravel in c-order all of the Axes that will be created
2016             #
2017             # This will stash the upper left index of each object (axes or
2018             # nested mosaic) at this level
2019             this_level = dict()
2020 
2021             # go through the unique keys,
2022             for name in unique_ids:
2023                 # sort out where each axes starts/ends
2024                 indx = np.argwhere(mosaic == name)
2025                 start_row, start_col = np.min(indx, axis=0)
2026                 end_row, end_col = np.max(indx, axis=0) + 1
2027                 # and construct the slice object
2028                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2029                 # some light error checking
2030                 if (mosaic[slc] != name).any():
2031                     raise ValueError(
2032                         f"While trying to layout\n{mosaic!r}\n"
2033                         f"we found that the label {name!r} specifies a "
2034                         "non-rectangular or non-contiguous area.")
2035                 # and stash this slice for later
2036                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2037 
2038             # do the same thing for the nested mosaics (simpler because these
2039             # can not be spans yet!)
2040             for (j, k), nested_mosaic in nested.items():
2041                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2042 
2043             # now go through the things in this level and add them
2044             # in order left-to-right top-to-bottom
2045             for key in sorted(this_level):
2046                 name, arg, method = this_level[key]
2047                 # we are doing some hokey function dispatch here based
2048                 # on the 'method' string stashed above to sort out if this
2049                 # element is an Axes or a nested mosaic.
2050                 if method == 'axes':
2051                     slc = arg
2052                     # add a single axes
2053                     if name in output:
2054                         raise ValueError(f"There are duplicate keys {name} "
2055                                          f"in the layout\n{mosaic!r}")
2056                     ax = self.add_subplot(
2057                         gs[slc], **{
2058                             'label': str(name),
2059                             **subplot_kw,
2060                             **per_subplot_kw.get(name, {})
2061                         }
2062                     )
2063                     output[name] = ax
2064                 elif method == 'nested':
2065                     nested_mosaic = arg
2066                     j, k = key
2067                     # recursively add the nested mosaic
2068                     rows, cols = nested_mosaic.shape
2069                     nested_output = _do_layout(
2070                         gs[j, k].subgridspec(rows, cols),
2071                         nested_mosaic,
2072                         *_identify_keys_and_nested(nested_mosaic)
2073                     )
2074                     overlap = set(output) & set(nested_output)
2075                     if overlap:
2076                         raise ValueError(
2077                             f"There are duplicate keys {overlap} "
2078                             f"between the outer layout\n{mosaic!r}\n"
2079                             f"and the nested layout\n{nested_mosaic}"
2080                         )
2081                     output.update(nested_output)
2082                 else:
2083                     raise RuntimeError("This should never happen")
2084             return output
2085 
2086         mosaic = _make_array(mosaic)
2087         rows, cols = mosaic.shape
2088         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2089         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2090         ax0 = next(iter(ret.values()))
2091         for ax in ret.values():
2092             if sharex:
2093                 ax.sharex(ax0)
2094                 ax._label_outer_xaxis(check_patch=True)
2095             if sharey:
2096                 ax.sharey(ax0)
2097                 ax._label_outer_yaxis(check_patch=True)
2098         if extra := set(per_subplot_kw) - set(ret):
2099             raise ValueError(
2100                 f"The keys {extra} are in *per_subplot_kw* "
2101                 "but not in the mosaic."
2102             )
2103         return ret
2104 
2105     def _set_artist_props(self, a):
2106         if a != self:
2107             a.set_figure(self)
2108         a.stale_callback = _stale_figure_callback
2109         a.set_transform(self.transSubfigure)
2110 
2111 
2112 @_docstring.interpd
2113 class SubFigure(FigureBase):
2114     """
2115     Logical figure that can be placed inside a figure.
2116 
2117     Typically instantiated using `.Figure.add_subfigure` or
2118     `.SubFigure.add_subfigure`, or `.SubFigure.subfigures`.  A subfigure has
2119     the same methods as a figure except for those particularly tied to the size
2120     or dpi of the figure, and is confined to a prescribed region of the figure.
2121     For example the following puts two subfigures side-by-side::
2122 
2123         fig = plt.figure()
2124         sfigs = fig.subfigures(1, 2)
2125         axsL = sfigs[0].subplots(1, 2)
2126         axsR = sfigs[1].subplots(2, 1)
2127 
2128     See :doc:`/gallery/subplots_axes_and_figures/subfigures`
2129     """
2130     callbacks = _api.deprecated(
2131             "3.6", alternative=("the 'resize_event' signal in "
2132                                 "Figure.canvas.callbacks")
2133             )(property(lambda self: self._fig_callbacks))
2134 
2135     def __init__(self, parent, subplotspec, *,
2136                  facecolor=None,
2137                  edgecolor=None,
2138                  linewidth=0.0,
2139                  frameon=None,
2140                  **kwargs):
2141         """
2142         Parameters
2143         ----------
2144         parent : `.Figure` or `.SubFigure`
2145             Figure or subfigure that contains the SubFigure.  SubFigures
2146             can be nested.
2147 
2148         subplotspec : `.gridspec.SubplotSpec`
2149             Defines the region in a parent gridspec where the subfigure will
2150             be placed.
2151 
2152         facecolor : default: ``"none"``
2153             The figure patch face color; transparent by default.
2154 
2155         edgecolor : default: :rc:`figure.edgecolor`
2156             The figure patch edge color.
2157 
2158         linewidth : float
2159             The linewidth of the frame (i.e. the edge linewidth of the figure
2160             patch).
2161 
2162         frameon : bool, default: :rc:`figure.frameon`
2163             If ``False``, suppress drawing the figure background patch.
2164 
2165         Other Parameters
2166         ----------------
2167         **kwargs : `.SubFigure` properties, optional
2168 
2169             %(SubFigure:kwdoc)s
2170         """
2171         super().__init__(**kwargs)
2172         if facecolor is None:
2173             facecolor = "none"
2174         if edgecolor is None:
2175             edgecolor = mpl.rcParams['figure.edgecolor']
2176         if frameon is None:
2177             frameon = mpl.rcParams['figure.frameon']
2178 
2179         self._subplotspec = subplotspec
2180         self._parent = parent
2181         self.figure = parent.figure
2182         self._fig_callbacks = parent._fig_callbacks
2183 
2184         # subfigures use the parent axstack
2185         self._axstack = parent._axstack
2186         self.subplotpars = parent.subplotpars
2187         self.dpi_scale_trans = parent.dpi_scale_trans
2188         self._axobservers = parent._axobservers
2189         self.canvas = parent.canvas
2190         self.transFigure = parent.transFigure
2191         self.bbox_relative = None
2192         self._redo_transform_rel_fig()
2193         self.figbbox = self._parent.figbbox
2194         self.bbox = TransformedBbox(self.bbox_relative,
2195                                     self._parent.transSubfigure)
2196         self.transSubfigure = BboxTransformTo(self.bbox)
2197 
2198         self.patch = Rectangle(
2199             xy=(0, 0), width=1, height=1, visible=frameon,
2200             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2201             # Don't let the figure patch influence bbox calculation.
2202             in_layout=False, transform=self.transSubfigure)
2203         self._set_artist_props(self.patch)
2204         self.patch.set_antialiased(False)
2205 
2206     @property
2207     def dpi(self):
2208         return self._parent.dpi
2209 
2210     @dpi.setter
2211     def dpi(self, value):
2212         self._parent.dpi = value
2213 
2214     def get_dpi(self):
2215         """
2216         Return the resolution of the parent figure in dots-per-inch as a float.
2217         """
2218         return self._parent.dpi
2219 
2220     def set_dpi(self, val):
2221         """
2222         Set the resolution of parent figure in dots-per-inch.
2223 
2224         Parameters
2225         ----------
2226         val : float
2227         """
2228         self._parent.dpi = val
2229         self.stale = True
2230 
2231     def _get_renderer(self):
2232         return self._parent._get_renderer()
2233 
2234     def _redo_transform_rel_fig(self, bbox=None):
2235         """
2236         Make the transSubfigure bbox relative to Figure transform.
2237 
2238         Parameters
2239         ----------
2240         bbox : bbox or None
2241             If not None, then the bbox is used for relative bounding box.
2242             Otherwise, it is calculated from the subplotspec.
2243         """
2244         if bbox is not None:
2245             self.bbox_relative.p0 = bbox.p0
2246             self.bbox_relative.p1 = bbox.p1
2247             return
2248         # need to figure out *where* this subplotspec is.
2249         gs = self._subplotspec.get_gridspec()
2250         wr = np.asarray(gs.get_width_ratios())
2251         hr = np.asarray(gs.get_height_ratios())
2252         dx = wr[self._subplotspec.colspan].sum() / wr.sum()
2253         dy = hr[self._subplotspec.rowspan].sum() / hr.sum()
2254         x0 = wr[:self._subplotspec.colspan.start].sum() / wr.sum()
2255         y0 = 1 - hr[:self._subplotspec.rowspan.stop].sum() / hr.sum()
2256         if self.bbox_relative is None:
2257             self.bbox_relative = Bbox.from_bounds(x0, y0, dx, dy)
2258         else:
2259             self.bbox_relative.p0 = (x0, y0)
2260             self.bbox_relative.p1 = (x0 + dx, y0 + dy)
2261 
2262     def get_constrained_layout(self):
2263         """
2264         Return whether constrained layout is being used.
2265 
2266         See :ref:`constrainedlayout_guide`.
2267         """
2268         return self._parent.get_constrained_layout()
2269 
2270     def get_constrained_layout_pads(self, relative=False):
2271         """
2272         Get padding for ``constrained_layout``.
2273 
2274         Returns a list of ``w_pad, h_pad`` in inches and
2275         ``wspace`` and ``hspace`` as fractions of the subplot.
2276 
2277         See :ref:`constrainedlayout_guide`.
2278 
2279         Parameters
2280         ----------
2281         relative : bool
2282             If `True`, then convert from inches to figure relative.
2283         """
2284         return self._parent.get_constrained_layout_pads(relative=relative)
2285 
2286     def get_layout_engine(self):
2287         return self._parent.get_layout_engine()
2288 
2289     @property
2290     def axes(self):
2291         """
2292         List of Axes in the SubFigure.  You can access and modify the Axes
2293         in the SubFigure through this list.
2294 
2295         Modifying this list has no effect. Instead, use `~.SubFigure.add_axes`,
2296         `~.SubFigure.add_subplot` or `~.SubFigure.delaxes` to add or remove an
2297         Axes.
2298 
2299         Note: The `.SubFigure.axes` property and `~.SubFigure.get_axes` method
2300         are equivalent.
2301         """
2302         return self._localaxes[:]
2303 
2304     get_axes = axes.fget
2305 
2306     def draw(self, renderer):
2307         # docstring inherited
2308 
2309         # draw the figure bounding box, perhaps none for white figure
2310         if not self.get_visible():
2311             return
2312 
2313         artists = self._get_draw_artists(renderer)
2314 
2315         try:
2316             renderer.open_group('subfigure', gid=self.get_gid())
2317             self.patch.draw(renderer)
2318             mimage._draw_list_compositing_images(
2319                 renderer, self, artists, self.figure.suppressComposite)
2320             for sfig in self.subfigs:
2321                 sfig.draw(renderer)
2322             renderer.close_group('subfigure')
2323 
2324         finally:
2325             self.stale = False
2326 
2327 
2328 @_docstring.interpd
2329 class Figure(FigureBase):
2330     """
2331     The top level container for all the plot elements.
2332 
2333     Attributes
2334     ----------
2335     patch
2336         The `.Rectangle` instance representing the figure background patch.
2337 
2338     suppressComposite
2339         For multiple images, the figure will make composite images
2340         depending on the renderer option_image_nocomposite function.  If
2341         *suppressComposite* is a boolean, this will override the renderer.
2342     """
2343     # Remove the self._fig_callbacks properties on figure and subfigure
2344     # after the deprecation expires.
2345     callbacks = _api.deprecated(
2346         "3.6", alternative=("the 'resize_event' signal in "
2347                             "Figure.canvas.callbacks")
2348         )(property(lambda self: self._fig_callbacks))
2349 
2350     def __str__(self):
2351         return "Figure(%gx%g)" % tuple(self.bbox.size)
2352 
2353     def __repr__(self):
2354         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2355             clsname=self.__class__.__name__,
2356             h=self.bbox.size[0], w=self.bbox.size[1],
2357             naxes=len(self.axes),
2358         )
2359 
2360     def __init__(self,
2361                  figsize=None,
2362                  dpi=None,
2363                  *,
2364                  facecolor=None,
2365                  edgecolor=None,
2366                  linewidth=0.0,
2367                  frameon=None,
2368                  subplotpars=None,  # rc figure.subplot.*
2369                  tight_layout=None,  # rc figure.autolayout
2370                  constrained_layout=None,  # rc figure.constrained_layout.use
2371                  layout=None,
2372                  **kwargs
2373                  ):
2374         """
2375         Parameters
2376         ----------
2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2378             Figure dimension ``(width, height)`` in inches.
2379 
2380         dpi : float, default: :rc:`figure.dpi`
2381             Dots per inch.
2382 
2383         facecolor : default: :rc:`figure.facecolor`
2384             The figure patch facecolor.
2385 
2386         edgecolor : default: :rc:`figure.edgecolor`
2387             The figure patch edge color.
2388 
2389         linewidth : float
2390             The linewidth of the frame (i.e. the edge linewidth of the figure
2391             patch).
2392 
2393         frameon : bool, default: :rc:`figure.frameon`
2394             If ``False``, suppress drawing the figure background patch.
2395 
2396         subplotpars : `SubplotParams`
2397             Subplot parameters. If not given, the default subplot
2398             parameters :rc:`figure.subplot.*` are used.
2399 
2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2402 
2403             .. admonition:: Discouraged
2404 
2405                 The use of this parameter is discouraged. Please use
2406                 ``layout='tight'`` instead for the common case of
2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2408 
2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2410             This is equal to ``layout='constrained'``.
2411 
2412             .. admonition:: Discouraged
2413 
2414                 The use of this parameter is discouraged. Please use
2415                 ``layout='constrained'`` instead.
2416 
2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2418 None}, default: None
2419             The layout mechanism for positioning of plot elements to avoid
2420             overlapping Axes decorations (labels, ticks, etc). Note that
2421             layout managers can have significant performance penalties.
2422 
2423             - 'constrained': The constrained layout solver adjusts axes sizes
2424               to avoid overlapping axes decorations.  Can handle complex plot
2425               layouts and colorbars, and is thus recommended.
2426 
2427               See :ref:`constrainedlayout_guide`
2428               for examples.
2429 
2430             - 'compressed': uses the same algorithm as 'constrained', but
2431               removes extra space between fixed-aspect-ratio Axes.  Best for
2432               simple grids of axes.
2433 
2434             - 'tight': Use the tight layout mechanism. This is a relatively
2435               simple algorithm that adjusts the subplot parameters so that
2436               decorations do not overlap. See `.Figure.set_tight_layout` for
2437               further details.
2438 
2439             - 'none': Do not use a layout engine.
2440 
2441             - A `.LayoutEngine` instance. Builtin layout classes are
2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2443               accessible by 'constrained' and 'tight'.  Passing an instance
2444               allows third parties to provide their own layout engine.
2445 
2446             If not given, fall back to using the parameters *tight_layout* and
2447             *constrained_layout*, including their config defaults
2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2449 
2450         Other Parameters
2451         ----------------
2452         **kwargs : `.Figure` properties, optional
2453 
2454             %(Figure:kwdoc)s
2455         """
2456         super().__init__(**kwargs)
2457         self._layout_engine = None
2458 
2459         if layout is not None:
2460             if (tight_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2463                     "be used together. Please use 'layout' only.")
2464             if (constrained_layout is not None):
2465                 _api.warn_external(
2466                     "The Figure parameters 'layout' and 'constrained_layout' "
2467                     "cannot be used together. Please use 'layout' only.")
2468             self.set_layout_engine(layout=layout)
2469         elif tight_layout is not None:
2470             if constrained_layout is not None:
2471                 _api.warn_external(
2472                     "The Figure parameters 'tight_layout' and "
2473                     "'constrained_layout' cannot be used together. Please use "
2474                     "'layout' parameter")
2475             self.set_layout_engine(layout='tight')
2476             if isinstance(tight_layout, dict):
2477                 self.get_layout_engine().set(**tight_layout)
2478         elif constrained_layout is not None:
2479             if isinstance(constrained_layout, dict):
2480                 self.set_layout_engine(layout='constrained')
2481                 self.get_layout_engine().set(**constrained_layout)
2482             elif constrained_layout:
2483                 self.set_layout_engine(layout='constrained')
2484 
2485         else:
2486             # everything is None, so use default:
2487             self.set_layout_engine(layout=layout)
2488 
2489         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2490         # Callbacks traditionally associated with the canvas (and exposed with
2491         # a proxy property), but that actually need to be on the figure for
2492         # pickling.
2493         self._canvas_callbacks = cbook.CallbackRegistry(
2494             signals=FigureCanvasBase.events)
2495         connect = self._canvas_callbacks._connect_picklable
2496         self._mouse_key_ids = [
2497             connect('key_press_event', backend_bases._key_handler),
2498             connect('key_release_event', backend_bases._key_handler),
2499             connect('key_release_event', backend_bases._key_handler),
2500             connect('button_press_event', backend_bases._mouse_handler),
2501             connect('button_release_event', backend_bases._mouse_handler),
2502             connect('scroll_event', backend_bases._mouse_handler),
2503             connect('motion_notify_event', backend_bases._mouse_handler),
2504         ]
2505         self._button_pick_id = connect('button_press_event', self.pick)
2506         self._scroll_pick_id = connect('scroll_event', self.pick)
2507 
2508         if figsize is None:
2509             figsize = mpl.rcParams['figure.figsize']
2510         if dpi is None:
2511             dpi = mpl.rcParams['figure.dpi']
2512         if facecolor is None:
2513             facecolor = mpl.rcParams['figure.facecolor']
2514         if edgecolor is None:
2515             edgecolor = mpl.rcParams['figure.edgecolor']
2516         if frameon is None:
2517             frameon = mpl.rcParams['figure.frameon']
2518 
2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2520             raise ValueError('figure size must be positive finite not '
2521                              f'{figsize}')
2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2523 
2524         self.dpi_scale_trans = Affine2D().scale(dpi)
2525         # do not use property as it will trigger
2526         self._dpi = dpi
2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2528         self.figbbox = self.bbox
2529         self.transFigure = BboxTransformTo(self.bbox)
2530         self.transSubfigure = self.transFigure
2531 
2532         self.patch = Rectangle(
2533             xy=(0, 0), width=1, height=1, visible=frameon,
2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2535             # Don't let the figure patch influence bbox calculation.
2536             in_layout=False)
2537         self._set_artist_props(self.patch)
2538         self.patch.set_antialiased(False)
2539 
2540         FigureCanvasBase(self)  # Set self.canvas.
2541 
2542         if subplotpars is None:
2543             subplotpars = SubplotParams()
2544 
2545         self.subplotpars = subplotpars
2546 
2547         self._axstack = _AxesStack()  # track all figure axes and current axes
2548         self.clear()
2549 
2550     def pick(self, mouseevent):
2551         if not self.canvas.widgetlock.locked():
2552             super().pick(mouseevent)
2553 
2554     def _check_layout_engines_compat(self, old, new):
2555         """
2556         Helper for set_layout engine
2557 
2558         If the figure has used the old engine and added a colorbar then the
2559         value of colorbar_gridspec must be the same on the new engine.
2560         """
2561         if old is None or new is None:
2562             return True
2563         if old.colorbar_gridspec == new.colorbar_gridspec:
2564             return True
2565         # colorbar layout different, so check if any colorbars are on the
2566         # figure...
2567         for ax in self.axes:
2568             if hasattr(ax, '_colorbar'):
2569                 # colorbars list themselves as a colorbar.
2570                 return False
2571         return True
2572 
2573     def set_layout_engine(self, layout=None, **kwargs):
2574         """
2575         Set the layout engine for this figure.
2576 
2577         Parameters
2578         ----------
2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2580 `LayoutEngine` or None
2581 
2582             - 'constrained' will use `~.ConstrainedLayoutEngine`
2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2584               a correction that attempts to make a good layout for fixed-aspect
2585               ratio Axes.
2586             - 'tight' uses `~.TightLayoutEngine`
2587             - 'none' removes layout engine.
2588 
2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2590             (which if `True` behaves as if 'tight' was passed) and
2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2592             'constrained' was passed).  If both are `True`,
2593             :rc:`figure.autolayout` takes priority.
2594 
2595             Users and libraries can define their own layout engines and pass
2596             the instance directly as well.
2597 
2598         kwargs: dict
2599             The keyword arguments are passed to the layout engine to set things
2600             like padding and margin sizes.  Only used if *layout* is a string.
2601 
2602         """
2603         if layout is None:
2604             if mpl.rcParams['figure.autolayout']:
2605                 layout = 'tight'
2606             elif mpl.rcParams['figure.constrained_layout.use']:
2607                 layout = 'constrained'
2608             else:
2609                 self._layout_engine = None
2610                 return
2611         if layout == 'tight':
2612             new_layout_engine = TightLayoutEngine(**kwargs)
2613         elif layout == 'constrained':
2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2615         elif layout == 'compressed':
2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2617                                                         **kwargs)
2618         elif layout == 'none':
2619             if self._layout_engine is not None:
2620                 new_layout_engine = PlaceHolderLayoutEngine(
2621                     self._layout_engine.adjust_compatible,
2622                     self._layout_engine.colorbar_gridspec
2623                 )
2624             else:
2625                 new_layout_engine = None
2626         elif isinstance(layout, LayoutEngine):
2627             new_layout_engine = layout
2628         else:
2629             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2630 
2631         if self._check_layout_engines_compat(self._layout_engine,
2632                                              new_layout_engine):
2633             self._layout_engine = new_layout_engine
2634         else:
2635             raise RuntimeError('Colorbar layout of new layout engine not '
2636                                'compatible with old engine, and a colorbar '
2637                                'has been created.  Engine not changed.')
2638 
2639     def get_layout_engine(self):
2640         return self._layout_engine
2641 
2642     # TODO: I'd like to dynamically add the _repr_html_ method
2643     # to the figure in the right context, but then IPython doesn't
2644     # use it, for some reason.
2645 
2646     def _repr_html_(self):
2647         # We can't use "isinstance" here, because then we'd end up importing
2648         # webagg unconditionally.
2649         if 'WebAgg' in type(self.canvas).__name__:
2650             from matplotlib.backends import backend_webagg
2651             return backend_webagg.ipython_inline_display(self)
2652 
2653     def show(self, warn=True):
2654         """
2655         If using a GUI backend with pyplot, display the figure window.
2656 
2657         If the figure was not created using `~.pyplot.figure`, it will lack
2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2659         AttributeError.
2660 
2661         .. warning::
2662 
2663             This does not manage an GUI event loop. Consequently, the figure
2664             may only be shown briefly or not shown at all if you or your
2665             environment are not managing an event loop.
2666 
2667             Use cases for `.Figure.show` include running this from a GUI
2668             application (where there is persistently an event loop running) or
2669             from a shell, like IPython, that install an input hook to allow the
2670             interactive shell to accept input while the figure is also being
2671             shown and interactive.  Some, but not all, GUI toolkits will
2672             register an input hook on import.  See :ref:`cp_integration` for
2673             more details.
2674 
2675             If you're in a shell without input hook integration or executing a
2676             python script, you should use `matplotlib.pyplot.show` with
2677             ``block=True`` instead, which takes care of starting and running
2678             the event loop for you.
2679 
2680         Parameters
2681         ----------
2682         warn : bool, default: True
2683             If ``True`` and we are not running headless (i.e. on Linux with an
2684             unset DISPLAY), issue warning when called on a non-GUI backend.
2685 
2686         """
2687         if self.canvas.manager is None:
2688             raise AttributeError(
2689                 "Figure.show works only for figures managed by pyplot, "
2690                 "normally created by pyplot.figure()")
2691         try:
2692             self.canvas.manager.show()
2693         except NonGuiException as exc:
2694             if warn:
2695                 _api.warn_external(str(exc))
2696 
2697     @property
2698     def axes(self):
2699         """
2700         List of Axes in the Figure. You can access and modify the Axes in the
2701         Figure through this list.
2702 
2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2705 
2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2707         equivalent.
2708         """
2709         return self._axstack.as_list()
2710 
2711     get_axes = axes.fget
2712 
2713     def _get_renderer(self):
2714         if hasattr(self.canvas, 'get_renderer'):
2715             return self.canvas.get_renderer()
2716         else:
2717             return _get_renderer(self)
2718 
2719     def _get_dpi(self):
2720         return self._dpi
2721 
2722     def _set_dpi(self, dpi, forward=True):
2723         """
2724         Parameters
2725         ----------
2726         dpi : float
2727 
2728         forward : bool
2729             Passed on to `~.Figure.set_size_inches`
2730         """
2731         if dpi == self._dpi:
2732             # We don't want to cause undue events in backends.
2733             return
2734         self._dpi = dpi
2735         self.dpi_scale_trans.clear().scale(dpi)
2736         w, h = self.get_size_inches()
2737         self.set_size_inches(w, h, forward=forward)
2738         self._fig_callbacks.process('dpi_changed', self)
2739 
2740     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2741 
2742     def get_tight_layout(self):
2743         """Return whether `.tight_layout` is called when drawing."""
2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2745 
2746     @_api.deprecated("3.6", alternative="set_layout_engine",
2747                      pending=True)
2748     def set_tight_layout(self, tight):
2749         """
2750         [*Discouraged*] Set whether and how `.tight_layout` is called when
2751         drawing.
2752 
2753         .. admonition:: Discouraged
2754 
2755             This method is discouraged in favor of `~.set_layout_engine`.
2756 
2757         Parameters
2758         ----------
2759         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2760             If a bool, sets whether to call `.tight_layout` upon drawing.
2761             If ``None``, use :rc:`figure.autolayout` instead.
2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2763             default paddings.
2764         """
2765         if tight is None:
2766             tight = mpl.rcParams['figure.autolayout']
2767         _tight = 'tight' if bool(tight) else 'none'
2768         _tight_parameters = tight if isinstance(tight, dict) else {}
2769         self.set_layout_engine(_tight, **_tight_parameters)
2770         self.stale = True
2771 
2772     def get_constrained_layout(self):
2773         """
2774         Return whether constrained layout is being used.
2775 
2776         See :ref:`constrainedlayout_guide`.
2777         """
2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2779 
2780     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2781                      pending=True)
2782     def set_constrained_layout(self, constrained):
2783         """
2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2785         drawing.
2786 
2787         If None, :rc:`figure.constrained_layout.use` value will be used.
2788 
2789         When providing a dict containing the keys ``w_pad``, ``h_pad``
2790         the default ``constrained_layout`` paddings will be
2791         overridden.  These pads are in inches and default to 3.0/72.0.
2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2793 
2794         .. admonition:: Discouraged
2795 
2796             This method is discouraged in favor of `~.set_layout_engine`.
2797 
2798         Parameters
2799         ----------
2800         constrained : bool or dict or None
2801         """
2802         if constrained is None:
2803             constrained = mpl.rcParams['figure.constrained_layout.use']
2804         _constrained = 'constrained' if bool(constrained) else 'none'
2805         _parameters = constrained if isinstance(constrained, dict) else {}
2806         self.set_layout_engine(_constrained, **_parameters)
2807         self.stale = True
2808 
2809     @_api.deprecated(
2810          "3.6", alternative="figure.get_layout_engine().set()",
2811          pending=True)
2812     def set_constrained_layout_pads(self, **kwargs):
2813         """
2814         Set padding for ``constrained_layout``.
2815 
2816         Tip: The parameters can be passed from a dictionary by using
2817         ``fig.set_constrained_layout(**pad_dict)``.
2818 
2819         See :ref:`constrainedlayout_guide`.
2820 
2821         Parameters
2822         ----------
2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2824             Width padding in inches.  This is the pad around Axes
2825             and is meant to make sure there is enough room for fonts to
2826             look good.  Defaults to 3 pts = 0.04167 inches
2827 
2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2829             Height padding in inches. Defaults to 3 pts.
2830 
2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2832             Width padding between subplots, expressed as a fraction of the
2833             subplot width.  The total padding ends up being w_pad + wspace.
2834 
2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2836             Height padding between subplots, expressed as a fraction of the
2837             subplot width. The total padding ends up being h_pad + hspace.
2838 
2839         """
2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2841             self.get_layout_engine().set(**kwargs)
2842 
2843     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2844                      pending=True)
2845     def get_constrained_layout_pads(self, relative=False):
2846         """
2847         Get padding for ``constrained_layout``.
2848 
2849         Returns a list of ``w_pad, h_pad`` in inches and
2850         ``wspace`` and ``hspace`` as fractions of the subplot.
2851         All values are None if ``constrained_layout`` is not used.
2852 
2853         See :ref:`constrainedlayout_guide`.
2854 
2855         Parameters
2856         ----------
2857         relative : bool
2858             If `True`, then convert from inches to figure relative.
2859         """
2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2861             return None, None, None, None
2862         info = self.get_layout_engine().get_info()
2863         w_pad = info['w_pad']
2864         h_pad = info['h_pad']
2865         wspace = info['wspace']
2866         hspace = info['hspace']
2867 
2868         if relative and (w_pad is not None or h_pad is not None):
2869             renderer = self._get_renderer()
2870             dpi = renderer.dpi
2871             w_pad = w_pad * dpi / renderer.width
2872             h_pad = h_pad * dpi / renderer.height
2873 
2874         return w_pad, h_pad, wspace, hspace
2875 
2876     def set_canvas(self, canvas):
2877         """
2878         Set the canvas that contains the figure
2879 
2880         Parameters
2881         ----------
2882         canvas : FigureCanvas
2883         """
2884         self.canvas = canvas
2885 
2886     @_docstring.interpd
2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2889         """
2890         Add a non-resampled image to the figure.
2891 
2892         The image is attached to the lower or upper left corner depending on
2893         *origin*.
2894 
2895         Parameters
2896         ----------
2897         X
2898             The image data. This is an array of one of the following shapes:
2899 
2900             - (M, N): an image with scalar data.  Color-mapping is controlled
2901               by *cmap*, *norm*, *vmin*, and *vmax*.
2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2904               i.e. including transparency.
2905 
2906         xo, yo : int
2907             The *x*/*y* image offset in pixels.
2908 
2909         alpha : None or float
2910             The alpha blending value.
2911 
2912         %(cmap_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(norm_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         %(vmin_vmax_doc)s
2921 
2922             This parameter is ignored if *X* is RGB(A).
2923 
2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2925             Indicates where the [0, 0] index of the array is in the upper left
2926             or lower left corner of the axes.
2927 
2928         resize : bool
2929             If *True*, resize the figure to match the given image size.
2930 
2931         Returns
2932         -------
2933         `matplotlib.image.FigureImage`
2934 
2935         Other Parameters
2936         ----------------
2937         **kwargs
2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2939 
2940         Notes
2941         -----
2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2943         which will be resampled to fit the current Axes.  If you want
2944         a resampled image to fill the entire figure, you can define an
2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2946 
2947         Examples
2948         --------
2949         ::
2950 
2951             f = plt.figure()
2952             nx = int(f.get_figwidth() * f.dpi)
2953             ny = int(f.get_figheight() * f.dpi)
2954             data = np.random.random((ny, nx))
2955             f.figimage(data)
2956             plt.show()
2957         """
2958         if resize:
2959             dpi = self.get_dpi()
2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2961             self.set_size_inches(figsize, forward=True)
2962 
2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2964                                 offsetx=xo, offsety=yo,
2965                                 origin=origin, **kwargs)
2966         im.stale_callback = _stale_figure_callback
2967 
2968         im.set_array(X)
2969         im.set_alpha(alpha)
2970         if norm is None:
2971             im.set_clim(vmin, vmax)
2972         self.images.append(im)
2973         im._remove_method = self.images.remove
2974         self.stale = True
2975         return im
2976 
2977     def set_size_inches(self, w, h=None, forward=True):
2978         """
2979         Set the figure size in inches.
2980 
2981         Call signatures::
2982 
2983              fig.set_size_inches(w, h)  # OR
2984              fig.set_size_inches((w, h))
2985 
2986         Parameters
2987         ----------
2988         w : (float, float) or float
2989             Width and height in inches (if height not specified as a separate
2990             argument) or width.
2991         h : float
2992             Height in inches.
2993         forward : bool, default: True
2994             If ``True``, the canvas size is automatically updated, e.g.,
2995             you can resize the figure window from the shell.
2996 
2997         See Also
2998         --------
2999         matplotlib.figure.Figure.get_size_inches
3000         matplotlib.figure.Figure.set_figwidth
3001         matplotlib.figure.Figure.set_figheight
3002 
3003         Notes
3004         -----
3005         To transform from pixels to inches divide by `Figure.dpi`.
3006         """
3007         if h is None:  # Got called with a single pair as argument.
3008             w, h = w
3009         size = np.array([w, h])
3010         if not np.isfinite(size).all() or (size < 0).any():
3011             raise ValueError(f'figure size must be positive finite not {size}')
3012         self.bbox_inches.p1 = size
3013         if forward:
3014             manager = self.canvas.manager
3015             if manager is not None:
3016                 manager.resize(*(size * self.dpi).astype(int))
3017         self.stale = True
3018 
3019     def get_size_inches(self):
3020         """
3021         Return the current size of the figure in inches.
3022 
3023         Returns
3024         -------
3025         ndarray
3026            The size (width, height) of the figure in inches.
3027 
3028         See Also
3029         --------
3030         matplotlib.figure.Figure.set_size_inches
3031         matplotlib.figure.Figure.get_figwidth
3032         matplotlib.figure.Figure.get_figheight
3033 
3034         Notes
3035         -----
3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3037         """
3038         return np.array(self.bbox_inches.p1)
3039 
3040     def get_figwidth(self):
3041         """Return the figure width in inches."""
3042         return self.bbox_inches.width
3043 
3044     def get_figheight(self):
3045         """Return the figure height in inches."""
3046         return self.bbox_inches.height
3047 
3048     def get_dpi(self):
3049         """Return the resolution in dots per inch as a float."""
3050         return self.dpi
3051 
3052     def set_dpi(self, val):
3053         """
3054         Set the resolution of the figure in dots-per-inch.
3055 
3056         Parameters
3057         ----------
3058         val : float
3059         """
3060         self.dpi = val
3061         self.stale = True
3062 
3063     def set_figwidth(self, val, forward=True):
3064         """
3065         Set the width of the figure in inches.
3066 
3067         Parameters
3068         ----------
3069         val : float
3070         forward : bool
3071             See `set_size_inches`.
3072 
3073         See Also
3074         --------
3075         matplotlib.figure.Figure.set_figheight
3076         matplotlib.figure.Figure.set_size_inches
3077         """
3078         self.set_size_inches(val, self.get_figheight(), forward=forward)
3079 
3080     def set_figheight(self, val, forward=True):
3081         """
3082         Set the height of the figure in inches.
3083 
3084         Parameters
3085         ----------
3086         val : float
3087         forward : bool
3088             See `set_size_inches`.
3089 
3090         See Also
3091         --------
3092         matplotlib.figure.Figure.set_figwidth
3093         matplotlib.figure.Figure.set_size_inches
3094         """
3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3096 
3097     def clear(self, keep_observers=False):
3098         # docstring inherited
3099         super().clear(keep_observers=keep_observers)
3100         # FigureBase.clear does not clear toolbars, as
3101         # only Figure can have toolbars
3102         toolbar = self.canvas.toolbar
3103         if toolbar is not None:
3104             toolbar.update()
3105 
3106     @_finalize_rasterization
3107     @allow_rasterization
3108     def draw(self, renderer):
3109         # docstring inherited
3110 
3111         # draw the figure bounding box, perhaps none for white figure
3112         if not self.get_visible():
3113             return
3114 
3115         artists = self._get_draw_artists(renderer)
3116         try:
3117             renderer.open_group('figure', gid=self.get_gid())
3118             if self.axes and self.get_layout_engine() is not None:
3119                 try:
3120                     self.get_layout_engine().execute(self)
3121                 except ValueError:
3122                     pass
3123                     # ValueError can occur when resizing a window.
3124 
3125             self.patch.draw(renderer)
3126             mimage._draw_list_compositing_images(
3127                 renderer, self, artists, self.suppressComposite)
3128 
3129             for sfig in self.subfigs:
3130                 sfig.draw(renderer)
3131 
3132             renderer.close_group('figure')
3133         finally:
3134             self.stale = False
3135 
3136         DrawEvent("draw_event", self.canvas, renderer)._process()
3137 
3138     def draw_without_rendering(self):
3139         """
3140         Draw the figure with no output.  Useful to get the final size of
3141         artists that require a draw before their size is known (e.g. text).
3142         """
3143         renderer = _get_renderer(self)
3144         with renderer._draw_disabled():
3145             self.draw(renderer)
3146 
3147     def draw_artist(self, a):
3148         """
3149         Draw `.Artist` *a* only.
3150         """
3151         a.draw(self.canvas.get_renderer())
3152 
3153     def __getstate__(self):
3154         state = super().__getstate__()
3155 
3156         # The canvas cannot currently be pickled, but this has the benefit
3157         # of meaning that a figure can be detached from one canvas, and
3158         # re-attached to another.
3159         state.pop("canvas")
3160 
3161         # discard any changes to the dpi due to pixel ratio changes
3162         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3163 
3164         # add version information to the state
3165         state['__mpl_version__'] = mpl.__version__
3166 
3167         # check whether the figure manager (if any) is registered with pyplot
3168         from matplotlib import _pylab_helpers
3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3170             state['_restore_to_pylab'] = True
3171         return state
3172 
3173     def __setstate__(self, state):
3174         version = state.pop('__mpl_version__')
3175         restore_to_pylab = state.pop('_restore_to_pylab', False)
3176 
3177         if version != mpl.__version__:
3178             _api.warn_external(
3179                 f"This figure was saved with matplotlib version {version} and "
3180                 f"is unlikely to function correctly.")
3181 
3182         self.__dict__ = state
3183 
3184         # re-initialise some of the unstored state information
3185         FigureCanvasBase(self)  # Set self.canvas.
3186 
3187         if restore_to_pylab:
3188             # lazy import to avoid circularity
3189             import matplotlib.pyplot as plt
3190             import matplotlib._pylab_helpers as pylab_helpers
3191             allnums = plt.get_fignums()
3192             num = max(allnums) + 1 if allnums else 1
3193             backend = plt._get_backend_mod()
3194             mgr = backend.new_figure_manager_given_figure(num, self)
3195             pylab_helpers.Gcf._set_new_active_manager(mgr)
3196             plt.draw_if_interactive()
3197 
3198         self.stale = True
3199 
3200     def add_axobserver(self, func):
3201         """Whenever the Axes state change, ``func(self)`` will be called."""
3202         # Connect a wrapper lambda and not func itself, to avoid it being
3203         # weakref-collected.
3204         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3205 
3206     def savefig(self, fname, *, transparent=None, **kwargs):
3207         """
3208         Save the current figure.
3209 
3210         Call signature::
3211 
3212           savefig(fname, *, dpi='figure', format=None, metadata=None,
3213                   bbox_inches=None, pad_inches=0.1,
3214                   facecolor='auto', edgecolor='auto',
3215                   backend=None, **kwargs
3216                  )
3217 
3218         The available output formats depend on the backend being used.
3219 
3220         Parameters
3221         ----------
3222         fname : str or path-like or binary file-like
3223             A path, or a Python file-like object, or
3224             possibly some backend-dependent object such as
3225             `matplotlib.backends.backend_pdf.PdfPages`.
3226 
3227             If *format* is set, it determines the output format, and the file
3228             is saved as *fname*.  Note that *fname* is used verbatim, and there
3229             is no attempt to make the extension, if any, of *fname* match
3230             *format*, and no extension is appended.
3231 
3232             If *format* is not set, then the format is inferred from the
3233             extension of *fname*, if there is one.  If *format* is not
3234             set and *fname* has no extension, then the file is saved with
3235             :rc:`savefig.format` and the appropriate extension is appended to
3236             *fname*.
3237 
3238         Other Parameters
3239         ----------------
3240         dpi : float or 'figure', default: :rc:`savefig.dpi`
3241             The resolution in dots per inch.  If 'figure', use the figure's
3242             dpi value.
3243 
3244         format : str
3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3246             this is unset is documented under *fname*.
3247 
3248         metadata : dict, optional
3249             Key/value pairs to store in the image metadata. The supported keys
3250             and defaults depend on the image format and backend:
3251 
3252             - 'png' with Agg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasAgg.print_png`.
3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3255               `~.backend_pdf.PdfPages`.
3256             - 'svg' with svg backend: See the parameter ``metadata`` of
3257               `~.FigureCanvasSVG.print_svg`.
3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3259 
3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
3261             embedding metadata.
3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include
3263             embedding EXIF metadata in the future.
3264 
3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3266             Bounding box in inches: only the given portion of the figure is
3267             saved.  If 'tight', try to figure out the tight bbox of the figure.
3268 
3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3270             Amount of padding in inches around the figure when bbox_inches is
3271             'tight'. If 'layout' use the padding from the constrained or
3272             compressed layout engine; ignored if one of those engines is not in
3273             use.
3274 
3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3276             The facecolor of the figure.  If 'auto', use the current figure
3277             facecolor.
3278 
3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3280             The edgecolor of the figure.  If 'auto', use the current figure
3281             edgecolor.
3282 
3283         backend : str, optional
3284             Use a non-default backend to render the file, e.g. to render a
3285             png file with the "cairo" backend rather than the default "agg",
3286             or a pdf file with the "pgf" backend rather than the default
3287             "pdf".  Note that the default backend is normally sufficient.  See
3288             :ref:`the-builtin-backends` for a list of valid backends for each
3289             file format.  Custom backends can be referenced as "module://...".
3290 
3291         orientation : {'landscape', 'portrait'}
3292             Currently only supported by the postscript backend.
3293 
3294         papertype : str
3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3296             'a10', 'b0' through 'b10'. Only supported for postscript
3297             output.
3298 
3299         transparent : bool
3300             If *True*, the Axes patches will all be transparent; the
3301             Figure patch will also be transparent unless *facecolor*
3302             and/or *edgecolor* are specified via kwargs.
3303 
3304             If *False* has no effect and the color of the Axes and
3305             Figure patches are unchanged (unless the Figure patch
3306             is specified via the *facecolor* and/or *edgecolor* keyword
3307             arguments in which case those colors are used).
3308 
3309             The transparency of these patches will be restored to their
3310             original values upon exit of this function.
3311 
3312             This is useful, for example, for displaying
3313             a plot on top of a colored background on a web page.
3314 
3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3316             A list of extra artists that will be considered when the
3317             tight bbox is calculated.
3318 
3319         pil_kwargs : dict, optional
3320             Additional keyword arguments that are passed to
3321             `PIL.Image.Image.save` when saving the figure.
3322 
3323         """
3324 
3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3326         if transparent is None:
3327             transparent = mpl.rcParams['savefig.transparent']
3328 
3329         with ExitStack() as stack:
3330             if transparent:
3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3332                     exit_stack.enter_context(
3333                         subfig.patch._cm_set(
3334                             facecolor="none", edgecolor="none"))
3335                     for ax in subfig.axes:
3336                         exit_stack.enter_context(
3337                             ax.patch._cm_set(
3338                                 facecolor="none", edgecolor="none"))
3339                     for sub_subfig in subfig.subfigs:
3340                         _recursively_make_subfig_transparent(
3341                             exit_stack, sub_subfig)
3342 
3343                 def _recursively_make_axes_transparent(exit_stack, ax):
3344                     exit_stack.enter_context(
3345                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3346                     for child_ax in ax.child_axes:
3347                         exit_stack.enter_context(
3348                             child_ax.patch._cm_set(
3349                                 facecolor="none", edgecolor="none"))
3350                     for child_childax in ax.child_axes:
3351                         _recursively_make_axes_transparent(
3352                             exit_stack, child_childax)
3353 
3354                 kwargs.setdefault('facecolor', 'none')
3355                 kwargs.setdefault('edgecolor', 'none')
3356                 # set subfigure to appear transparent in printed image
3357                 for subfig in self.subfigs:
3358                     _recursively_make_subfig_transparent(stack, subfig)
3359                 # set axes to be transparent
3360                 for ax in self.axes:
3361                     _recursively_make_axes_transparent(stack, ax)
3362             self.canvas.print_figure(fname, **kwargs)
3363 
3364     def ginput(self, n=1, timeout=30, show_clicks=True,
3365                mouse_add=MouseButton.LEFT,
3366                mouse_pop=MouseButton.RIGHT,
3367                mouse_stop=MouseButton.MIDDLE):
3368         """
3369         Blocking call to interact with a figure.
3370 
3371         Wait until the user clicks *n* times on the figure, and return the
3372         coordinates of each click in a list.
3373 
3374         There are three possible interactions:
3375 
3376         - Add a point.
3377         - Remove the most recently added point.
3378         - Stop the interaction and return the points added so far.
3379 
3380         The actions are assigned to mouse buttons via the arguments
3381         *mouse_add*, *mouse_pop* and *mouse_stop*.
3382 
3383         Parameters
3384         ----------
3385         n : int, default: 1
3386             Number of mouse clicks to accumulate. If negative, accumulate
3387             clicks until the input is terminated manually.
3388         timeout : float, default: 30 seconds
3389             Number of seconds to wait before timing out. If zero or negative
3390             will never time out.
3391         show_clicks : bool, default: True
3392             If True, show a red cross at the location of each click.
3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3394             Mouse button used to add points.
3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3396             Mouse button used to remove the most recently added point.
3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3398             Mouse button used to stop input.
3399 
3400         Returns
3401         -------
3402         list of tuples
3403             A list of the clicked (x, y) coordinates.
3404 
3405         Notes
3406         -----
3407         The keyboard can also be used to select points in case your mouse
3408         does not have one or more of the buttons.  The delete and backspace
3409         keys act like right-clicking (i.e., remove last point), the enter key
3410         terminates input and any other key (not already used by the window
3411         manager) selects a point.
3412         """
3413         clicks = []
3414         marks = []
3415 
3416         def handler(event):
3417             is_button = event.name == "button_press_event"
3418             is_key = event.name == "key_press_event"
3419             # Quit (even if not in infinite mode; this is consistent with
3420             # MATLAB and sometimes quite useful, but will require the user to
3421             # test how many points were actually returned before using data).
3422             if (is_button and event.button == mouse_stop
3423                     or is_key and event.key in ["escape", "enter"]):
3424                 self.canvas.stop_event_loop()
3425             # Pop last click.
3426             elif (is_button and event.button == mouse_pop
3427                   or is_key and event.key in ["backspace", "delete"]):
3428                 if clicks:
3429                     clicks.pop()
3430                     if show_clicks:
3431                         marks.pop().remove()
3432                         self.canvas.draw()
3433             # Add new click.
3434             elif (is_button and event.button == mouse_add
3435                   # On macOS/gtk, some keys return None.
3436                   or is_key and event.key is not None):
3437                 if event.inaxes:
3438                     clicks.append((event.xdata, event.ydata))
3439                     _log.info("input %i: %f, %f",
3440                               len(clicks), event.xdata, event.ydata)
3441                     if show_clicks:
3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3443                                                 marker="+", color="r")
3444                         event.inaxes.add_line(line)
3445                         marks.append(line)
3446                         self.canvas.draw()
3447             if len(clicks) == n and n > 0:
3448                 self.canvas.stop_event_loop()
3449 
3450         _blocking_input.blocking_input_loop(
3451             self, ["button_press_event", "key_press_event"], timeout, handler)
3452 
3453         # Cleanup.
3454         for mark in marks:
3455             mark.remove()
3456         self.canvas.draw()
3457 
3458         return clicks
3459 
3460     def waitforbuttonpress(self, timeout=-1):
3461         """
3462         Blocking call to interact with the figure.
3463 
3464         Wait for user input and return True if a key was pressed, False if a
3465         mouse button was pressed and None if no input was given within
3466         *timeout* seconds.  Negative values deactivate *timeout*.
3467         """
3468         event = None
3469 
3470         def handler(ev):
3471             nonlocal event
3472             event = ev
3473             self.canvas.stop_event_loop()
3474 
3475         _blocking_input.blocking_input_loop(
3476             self, ["button_press_event", "key_press_event"], timeout, handler)
3477 
3478         return None if event is None else event.name == "key_press_event"
3479 
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)
3519 
3520 
3521 def figaspect(arg):
3522     """
3523     Calculate the width and height for a figure with a specified aspect ratio.
3524 
3525     While the height is taken from :rc:`figure.figsize`, the width is
3526     adjusted to match the desired aspect ratio. Additionally, it is ensured
3527     that the width is in the range [4., 16.] and the height is in the range
3528     [2., 16.]. If necessary, the default height is adjusted to ensure this.
3529 
3530     Parameters
3531     ----------
3532     arg : float or 2D array
3533         If a float, this defines the aspect ratio (i.e. the ratio height /
3534         width).
3535         In case of an array the aspect ratio is number of rows / number of
3536         columns, so that the array could be fitted in the figure undistorted.
3537 
3538     Returns
3539     -------
3540     width, height : float
3541         The figure size in inches.
3542 
3543     Notes
3544     -----
3545     If you want to create an Axes within the figure, that still preserves the
3546     aspect ratio, be sure to create it with equal width and height. See
3547     examples below.
3548 
3549     Thanks to Fernando Perez for this function.
3550 
3551     Examples
3552     --------
3553     Make a figure twice as tall as it is wide::
3554 
3555         w, h = figaspect(2.)
3556         fig = Figure(figsize=(w, h))
3557         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
3558         ax.imshow(A, **kwargs)
3559 
3560     Make a figure with the proper aspect for an array::
3561 
3562         A = rand(5, 3)
3563         w, h = figaspect(A)
3564         fig = Figure(figsize=(w, h))
3565         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
3566         ax.imshow(A, **kwargs)
3567     """
3568 
3569     isarray = hasattr(arg, 'shape') and not np.isscalar(arg)
3570 
3571     # min/max sizes to respect when autoscaling.  If John likes the idea, they
3572     # could become rc parameters, for now they're hardwired.
3573     figsize_min = np.array((4.0, 2.0))  # min length for width/height
3574     figsize_max = np.array((16.0, 16.0))  # max length for width/height
3575 
3576     # Extract the aspect ratio of the array
3577     if isarray:
3578         nr, nc = arg.shape[:2]
3579         arr_ratio = nr / nc
3580     else:
3581         arr_ratio = arg
3582 
3583     # Height of user figure defaults
3584     fig_height = mpl.rcParams['figure.figsize'][1]
3585 
3586     # New size for the figure, keeping the aspect ratio of the caller
3587     newsize = np.array((fig_height / arr_ratio, fig_height))
3588 
3589     # Sanity checks, don't drop either dimension below figsize_min
3590     newsize /= min(1.0, *(newsize / figsize_min))
3591 
3592     # Avoid humongous windows as well
3593     newsize /= max(1.0, *(newsize / figsize_max))
3594 
3595     # Finally, if we have a really funky aspect ratio, break it but respect
3596     # the min/max dimensions (we don't want figures 10 feet tall!)
3597     newsize = np.clip(newsize, figsize_min, figsize_max)
3598     return newsize

</code><intended_behavior>Any method or function within this file that reads or modifies the `figure.autolayout` setting needs to be reviewed to ensure it correctly handles situations where both `autolayout` and `tight_layout` are used. If `tight_layout` is called, the code should respect the explicit user request to adjust layout parameters manually, which may involve temporarily disabling `autolayout` or merging the settings with `tight_layout` kwargs. The balance between automatic and manual layout adjustments needs to be clear to users, either through documentation or runtime messages.</intended_behavior>]
2025-10-15 07:40:38.947 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>tight_layout</method>
<code>
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>This method should be modified to check if `figure.autolayout` is set to `True` and either incorporate the `kwargs` from `tight_layout` into the automatic layout calculations or provide a clear warning to the user that `tight_layout` parameters will be ignored due to `figure.autolayout` being enabled. This adjustment ensures that there is no silent failure or unexpected behavior when users attempt to use `tight_layout` with `figure.autolayout` set to `True`. The existing functionality of automatically adjusting the layout when `autolayout` is enabled should be preserved, but an additional check or mechanism should be added to respect or acknowledge `tight_layout` kwargs when also used.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2329 class Figure(FigureBase):
2330     """
2331     The top level container for all the plot elements.
2332 
2333     Attributes
2334     ----------
2335     patch
2336         The `.Rectangle` instance representing the figure background patch.
2337 
2338     suppressComposite
2339         For multiple images, the figure will make composite images
2340         depending on the renderer option_image_nocomposite function.  If
2341         *suppressComposite* is a boolean, this will override the renderer.
2342     """
2343     # Remove the self._fig_callbacks properties on figure and subfigure
2344     # after the deprecation expires.
2345     callbacks = _api.deprecated(
2346         "3.6", alternative=("the 'resize_event' signal in "
2347                             "Figure.canvas.callbacks")
2348         )(property(lambda self: self._fig_callbacks))
2349 
2350     def __str__(self):
2351         return "Figure(%gx%g)" % tuple(self.bbox.size)
2352 
2353     def __repr__(self):
2354         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2355             clsname=self.__class__.__name__,
2356             h=self.bbox.size[0], w=self.bbox.size[1],
2357             naxes=len(self.axes),
2358         )
2359 
2360     def __init__(self,
2361                  figsize=None,
2362                  dpi=None,
2363                  *,
2364                  facecolor=None,
2365                  edgecolor=None,
2366                  linewidth=0.0,
2367                  frameon=None,
2368                  subplotpars=None,  # rc figure.subplot.*
2369                  tight_layout=None,  # rc figure.autolayout
2370                  constrained_layout=None,  # rc figure.constrained_layout.use
2371                  layout=None,
2372                  **kwargs
2373                  ):
2374         """
2375         Parameters
2376         ----------
2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2378             Figure dimension ``(width, height)`` in inches.
2379 
2380         dpi : float, default: :rc:`figure.dpi`
2381             Dots per inch.
2382 
2383         facecolor : default: :rc:`figure.facecolor`
2384             The figure patch facecolor.
2385 
2386         edgecolor : default: :rc:`figure.edgecolor`
2387             The figure patch edge color.
2388 
2389         linewidth : float
2390             The linewidth of the frame (i.e. the edge linewidth of the figure
2391             patch).
2392 
2393         frameon : bool, default: :rc:`figure.frameon`
2394             If ``False``, suppress drawing the figure background patch.
2395 
2396         subplotpars : `SubplotParams`
2397             Subplot parameters. If not given, the default subplot
2398             parameters :rc:`figure.subplot.*` are used.
2399 
2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2402 
2403             .. admonition:: Discouraged
2404 
2405                 The use of this parameter is discouraged. Please use
2406                 ``layout='tight'`` instead for the common case of
2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2408 
2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2410             This is equal to ``layout='constrained'``.
2411 
2412             .. admonition:: Discouraged
2413 
2414                 The use of this parameter is discouraged. Please use
2415                 ``layout='constrained'`` instead.
2416 
2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2418 None}, default: None
2419             The layout mechanism for positioning of plot elements to avoid
2420             overlapping Axes decorations (labels, ticks, etc). Note that
2421             layout managers can have significant performance penalties.
2422 
2423             - 'constrained': The constrained layout solver adjusts axes sizes
2424               to avoid overlapping axes decorations.  Can handle complex plot
2425               layouts and colorbars, and is thus recommended.
2426 
2427               See :ref:`constrainedlayout_guide`
2428               for examples.
2429 
2430             - 'compressed': uses the same algorithm as 'constrained', but
2431               removes extra space between fixed-aspect-ratio Axes.  Best for
2432               simple grids of axes.
2433 
2434             - 'tight': Use the tight layout mechanism. This is a relatively
2435               simple algorithm that adjusts the subplot parameters so that
2436               decorations do not overlap. See `.Figure.set_tight_layout` for
2437               further details.
2438 
2439             - 'none': Do not use a layout engine.
2440 
2441             - A `.LayoutEngine` instance. Builtin layout classes are
2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2443               accessible by 'constrained' and 'tight'.  Passing an instance
2444               allows third parties to provide their own layout engine.
2445 
2446             If not given, fall back to using the parameters *tight_layout* and
2447             *constrained_layout*, including their config defaults
2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2449 
2450         Other Parameters
2451         ----------------
2452         **kwargs : `.Figure` properties, optional
2453 
2454             %(Figure:kwdoc)s
2455         """
2456         super().__init__(**kwargs)
2457         self._layout_engine = None
2458 
2459         if layout is not None:
2460             if (tight_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2463                     "be used together. Please use 'layout' only.")
2464             if (constrained_layout is not None):
2465                 _api.warn_external(
2466                     "The Figure parameters 'layout' and 'constrained_layout' "
2467                     "cannot be used together. Please use 'layout' only.")
2468             self.set_layout_engine(layout=layout)
2469         elif tight_layout is not None:
2470             if constrained_layout is not None:
2471                 _api.warn_external(
2472                     "The Figure parameters 'tight_layout' and "
2473                     "'constrained_layout' cannot be used together. Please use "
2474                     "'layout' parameter")
2475             self.set_layout_engine(layout='tight')
2476             if isinstance(tight_layout, dict):
2477                 self.get_layout_engine().set(**tight_layout)
2478         elif constrained_layout is not None:
2479             if isinstance(constrained_layout, dict):
2480                 self.set_layout_engine(layout='constrained')
2481                 self.get_layout_engine().set(**constrained_layout)
2482             elif constrained_layout:
2483                 self.set_layout_engine(layout='constrained')
2484 
2485         else:
2486             # everything is None, so use default:
2487             self.set_layout_engine(layout=layout)
2488 
2489         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2490         # Callbacks traditionally associated with the canvas (and exposed with
2491         # a proxy property), but that actually need to be on the figure for
2492         # pickling.
2493         self._canvas_callbacks = cbook.CallbackRegistry(
2494             signals=FigureCanvasBase.events)
2495         connect = self._canvas_callbacks._connect_picklable
2496         self._mouse_key_ids = [
2497             connect('key_press_event', backend_bases._key_handler),
2498             connect('key_release_event', backend_bases._key_handler),
2499             connect('key_release_event', backend_bases._key_handler),
2500             connect('button_press_event', backend_bases._mouse_handler),
2501             connect('button_release_event', backend_bases._mouse_handler),
2502             connect('scroll_event', backend_bases._mouse_handler),
2503             connect('motion_notify_event', backend_bases._mouse_handler),
2504         ]
2505         self._button_pick_id = connect('button_press_event', self.pick)
2506         self._scroll_pick_id = connect('scroll_event', self.pick)
2507 
2508         if figsize is None:
2509             figsize = mpl.rcParams['figure.figsize']
2510         if dpi is None:
2511             dpi = mpl.rcParams['figure.dpi']
2512         if facecolor is None:
2513             facecolor = mpl.rcParams['figure.facecolor']
2514         if edgecolor is None:
2515             edgecolor = mpl.rcParams['figure.edgecolor']
2516         if frameon is None:
2517             frameon = mpl.rcParams['figure.frameon']
2518 
2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2520             raise ValueError('figure size must be positive finite not '
2521                              f'{figsize}')
2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2523 
2524         self.dpi_scale_trans = Affine2D().scale(dpi)
2525         # do not use property as it will trigger
2526         self._dpi = dpi
2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2528         self.figbbox = self.bbox
2529         self.transFigure = BboxTransformTo(self.bbox)
2530         self.transSubfigure = self.transFigure
2531 
2532         self.patch = Rectangle(
2533             xy=(0, 0), width=1, height=1, visible=frameon,
2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2535             # Don't let the figure patch influence bbox calculation.
2536             in_layout=False)
2537         self._set_artist_props(self.patch)
2538         self.patch.set_antialiased(False)
2539 
2540         FigureCanvasBase(self)  # Set self.canvas.
2541 
2542         if subplotpars is None:
2543             subplotpars = SubplotParams()
2544 
2545         self.subplotpars = subplotpars
2546 
2547         self._axstack = _AxesStack()  # track all figure axes and current axes
2548         self.clear()
2549 
2550     def pick(self, mouseevent):
2551         if not self.canvas.widgetlock.locked():
2552             super().pick(mouseevent)
2553 
2554     def _check_layout_engines_compat(self, old, new):
2555         """
2556         Helper for set_layout engine
2557 
2558         If the figure has used the old engine and added a colorbar then the
2559         value of colorbar_gridspec must be the same on the new engine.
2560         """
2561         if old is None or new is None:
2562             return True
2563         if old.colorbar_gridspec == new.colorbar_gridspec:
2564             return True
2565         # colorbar layout different, so check if any colorbars are on the
2566         # figure...
2567         for ax in self.axes:
2568             if hasattr(ax, '_colorbar'):
2569                 # colorbars list themselves as a colorbar.
2570                 return False
2571         return True
2572 
2573     def set_layout_engine(self, layout=None, **kwargs):
2574         """
2575         Set the layout engine for this figure.
2576 
2577         Parameters
2578         ----------
2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2580 `LayoutEngine` or None
2581 
2582             - 'constrained' will use `~.ConstrainedLayoutEngine`
2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2584               a correction that attempts to make a good layout for fixed-aspect
2585               ratio Axes.
2586             - 'tight' uses `~.TightLayoutEngine`
2587             - 'none' removes layout engine.
2588 
2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2590             (which if `True` behaves as if 'tight' was passed) and
2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2592             'constrained' was passed).  If both are `True`,
2593             :rc:`figure.autolayout` takes priority.
2594 
2595             Users and libraries can define their own layout engines and pass
2596             the instance directly as well.
2597 
2598         kwargs: dict
2599             The keyword arguments are passed to the layout engine to set things
2600             like padding and margin sizes.  Only used if *layout* is a string.
2601 
2602         """
2603         if layout is None:
2604             if mpl.rcParams['figure.autolayout']:
2605                 layout = 'tight'
2606             elif mpl.rcParams['figure.constrained_layout.use']:
2607                 layout = 'constrained'
2608             else:
2609                 self._layout_engine = None
2610                 return
2611         if layout == 'tight':
2612             new_layout_engine = TightLayoutEngine(**kwargs)
2613         elif layout == 'constrained':
2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2615         elif layout == 'compressed':
2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2617                                                         **kwargs)
2618         elif layout == 'none':
2619             if self._layout_engine is not None:
2620                 new_layout_engine = PlaceHolderLayoutEngine(
2621                     self._layout_engine.adjust_compatible,
2622                     self._layout_engine.colorbar_gridspec
2623                 )
2624             else:
2625                 new_layout_engine = None
2626         elif isinstance(layout, LayoutEngine):
2627             new_layout_engine = layout
2628         else:
2629             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2630 
2631         if self._check_layout_engines_compat(self._layout_engine,
2632                                              new_layout_engine):
2633             self._layout_engine = new_layout_engine
2634         else:
2635             raise RuntimeError('Colorbar layout of new layout engine not '
2636                                'compatible with old engine, and a colorbar '
2637                                'has been created.  Engine not changed.')
2638 
2639     def get_layout_engine(self):
2640         return self._layout_engine
2641 
2642     # TODO: I'd like to dynamically add the _repr_html_ method
2643     # to the figure in the right context, but then IPython doesn't
2644     # use it, for some reason.
2645 
2646     def _repr_html_(self):
2647         # We can't use "isinstance" here, because then we'd end up importing
2648         # webagg unconditionally.
2649         if 'WebAgg' in type(self.canvas).__name__:
2650             from matplotlib.backends import backend_webagg
2651             return backend_webagg.ipython_inline_display(self)
2652 
2653     def show(self, warn=True):
2654         """
2655         If using a GUI backend with pyplot, display the figure window.
2656 
2657         If the figure was not created using `~.pyplot.figure`, it will lack
2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2659         AttributeError.
2660 
2661         .. warning::
2662 
2663             This does not manage an GUI event loop. Consequently, the figure
2664             may only be shown briefly or not shown at all if you or your
2665             environment are not managing an event loop.
2666 
2667             Use cases for `.Figure.show` include running this from a GUI
2668             application (where there is persistently an event loop running) or
2669             from a shell, like IPython, that install an input hook to allow the
2670             interactive shell to accept input while the figure is also being
2671             shown and interactive.  Some, but not all, GUI toolkits will
2672             register an input hook on import.  See :ref:`cp_integration` for
2673             more details.
2674 
2675             If you're in a shell without input hook integration or executing a
2676             python script, you should use `matplotlib.pyplot.show` with
2677             ``block=True`` instead, which takes care of starting and running
2678             the event loop for you.
2679 
2680         Parameters
2681         ----------
2682         warn : bool, default: True
2683             If ``True`` and we are not running headless (i.e. on Linux with an
2684             unset DISPLAY), issue warning when called on a non-GUI backend.
2685 
2686         """
2687         if self.canvas.manager is None:
2688             raise AttributeError(
2689                 "Figure.show works only for figures managed by pyplot, "
2690                 "normally created by pyplot.figure()")
2691         try:
2692             self.canvas.manager.show()
2693         except NonGuiException as exc:
2694             if warn:
2695                 _api.warn_external(str(exc))
2696 
2697     @property
2698     def axes(self):
2699         """
2700         List of Axes in the Figure. You can access and modify the Axes in the
2701         Figure through this list.
2702 
2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2705 
2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2707         equivalent.
2708         """
2709         return self._axstack.as_list()
2710 
2711     get_axes = axes.fget
2712 
2713     def _get_renderer(self):
2714         if hasattr(self.canvas, 'get_renderer'):
2715             return self.canvas.get_renderer()
2716         else:
2717             return _get_renderer(self)
2718 
2719     def _get_dpi(self):
2720         return self._dpi
2721 
2722     def _set_dpi(self, dpi, forward=True):
2723         """
2724         Parameters
2725         ----------
2726         dpi : float
2727 
2728         forward : bool
2729             Passed on to `~.Figure.set_size_inches`
2730         """
2731         if dpi == self._dpi:
2732             # We don't want to cause undue events in backends.
2733             return
2734         self._dpi = dpi
2735         self.dpi_scale_trans.clear().scale(dpi)
2736         w, h = self.get_size_inches()
2737         self.set_size_inches(w, h, forward=forward)
2738         self._fig_callbacks.process('dpi_changed', self)
2739 
2740     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2741 
2742     def get_tight_layout(self):
2743         """Return whether `.tight_layout` is called when drawing."""
2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2745 
2746     @_api.deprecated("3.6", alternative="set_layout_engine",
2747                      pending=True)
2748     def set_tight_layout(self, tight):
2749         """
2750         [*Discouraged*] Set whether and how `.tight_layout` is called when
2751         drawing.
2752 
2753         .. admonition:: Discouraged
2754 
2755             This method is discouraged in favor of `~.set_layout_engine`.
2756 
2757         Parameters
2758         ----------
2759         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2760             If a bool, sets whether to call `.tight_layout` upon drawing.
2761             If ``None``, use :rc:`figure.autolayout` instead.
2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2763             default paddings.
2764         """
2765         if tight is None:
2766             tight = mpl.rcParams['figure.autolayout']
2767         _tight = 'tight' if bool(tight) else 'none'
2768         _tight_parameters = tight if isinstance(tight, dict) else {}
2769         self.set_layout_engine(_tight, **_tight_parameters)
2770         self.stale = True
2771 
2772     def get_constrained_layout(self):
2773         """
2774         Return whether constrained layout is being used.
2775 
2776         See :ref:`constrainedlayout_guide`.
2777         """
2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2779 
2780     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2781                      pending=True)
2782     def set_constrained_layout(self, constrained):
2783         """
2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2785         drawing.
2786 
2787         If None, :rc:`figure.constrained_layout.use` value will be used.
2788 
2789         When providing a dict containing the keys ``w_pad``, ``h_pad``
2790         the default ``constrained_layout`` paddings will be
2791         overridden.  These pads are in inches and default to 3.0/72.0.
2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2793 
2794         .. admonition:: Discouraged
2795 
2796             This method is discouraged in favor of `~.set_layout_engine`.
2797 
2798         Parameters
2799         ----------
2800         constrained : bool or dict or None
2801         """
2802         if constrained is None:
2803             constrained = mpl.rcParams['figure.constrained_layout.use']
2804         _constrained = 'constrained' if bool(constrained) else 'none'
2805         _parameters = constrained if isinstance(constrained, dict) else {}
2806         self.set_layout_engine(_constrained, **_parameters)
2807         self.stale = True
2808 
2809     @_api.deprecated(
2810          "3.6", alternative="figure.get_layout_engine().set()",
2811          pending=True)
2812     def set_constrained_layout_pads(self, **kwargs):
2813         """
2814         Set padding for ``constrained_layout``.
2815 
2816         Tip: The parameters can be passed from a dictionary by using
2817         ``fig.set_constrained_layout(**pad_dict)``.
2818 
2819         See :ref:`constrainedlayout_guide`.
2820 
2821         Parameters
2822         ----------
2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2824             Width padding in inches.  This is the pad around Axes
2825             and is meant to make sure there is enough room for fonts to
2826             look good.  Defaults to 3 pts = 0.04167 inches
2827 
2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2829             Height padding in inches. Defaults to 3 pts.
2830 
2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2832             Width padding between subplots, expressed as a fraction of the
2833             subplot width.  The total padding ends up being w_pad + wspace.
2834 
2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2836             Height padding between subplots, expressed as a fraction of the
2837             subplot width. The total padding ends up being h_pad + hspace.
2838 
2839         """
2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2841             self.get_layout_engine().set(**kwargs)
2842 
2843     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2844                      pending=True)
2845     def get_constrained_layout_pads(self, relative=False):
2846         """
2847         Get padding for ``constrained_layout``.
2848 
2849         Returns a list of ``w_pad, h_pad`` in inches and
2850         ``wspace`` and ``hspace`` as fractions of the subplot.
2851         All values are None if ``constrained_layout`` is not used.
2852 
2853         See :ref:`constrainedlayout_guide`.
2854 
2855         Parameters
2856         ----------
2857         relative : bool
2858             If `True`, then convert from inches to figure relative.
2859         """
2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2861             return None, None, None, None
2862         info = self.get_layout_engine().get_info()
2863         w_pad = info['w_pad']
2864         h_pad = info['h_pad']
2865         wspace = info['wspace']
2866         hspace = info['hspace']
2867 
2868         if relative and (w_pad is not None or h_pad is not None):
2869             renderer = self._get_renderer()
2870             dpi = renderer.dpi
2871             w_pad = w_pad * dpi / renderer.width
2872             h_pad = h_pad * dpi / renderer.height
2873 
2874         return w_pad, h_pad, wspace, hspace
2875 
2876     def set_canvas(self, canvas):
2877         """
2878         Set the canvas that contains the figure
2879 
2880         Parameters
2881         ----------
2882         canvas : FigureCanvas
2883         """
2884         self.canvas = canvas
2885 
2886     @_docstring.interpd
2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2889         """
2890         Add a non-resampled image to the figure.
2891 
2892         The image is attached to the lower or upper left corner depending on
2893         *origin*.
2894 
2895         Parameters
2896         ----------
2897         X
2898             The image data. This is an array of one of the following shapes:
2899 
2900             - (M, N): an image with scalar data.  Color-mapping is controlled
2901               by *cmap*, *norm*, *vmin*, and *vmax*.
2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2904               i.e. including transparency.
2905 
2906         xo, yo : int
2907             The *x*/*y* image offset in pixels.
2908 
2909         alpha : None or float
2910             The alpha blending value.
2911 
2912         %(cmap_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(norm_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         %(vmin_vmax_doc)s
2921 
2922             This parameter is ignored if *X* is RGB(A).
2923 
2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2925             Indicates where the [0, 0] index of the array is in the upper left
2926             or lower left corner of the axes.
2927 
2928         resize : bool
2929             If *True*, resize the figure to match the given image size.
2930 
2931         Returns
2932         -------
2933         `matplotlib.image.FigureImage`
2934 
2935         Other Parameters
2936         ----------------
2937         **kwargs
2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2939 
2940         Notes
2941         -----
2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2943         which will be resampled to fit the current Axes.  If you want
2944         a resampled image to fill the entire figure, you can define an
2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2946 
2947         Examples
2948         --------
2949         ::
2950 
2951             f = plt.figure()
2952             nx = int(f.get_figwidth() * f.dpi)
2953             ny = int(f.get_figheight() * f.dpi)
2954             data = np.random.random((ny, nx))
2955             f.figimage(data)
2956             plt.show()
2957         """
2958         if resize:
2959             dpi = self.get_dpi()
2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2961             self.set_size_inches(figsize, forward=True)
2962 
2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2964                                 offsetx=xo, offsety=yo,
2965                                 origin=origin, **kwargs)
2966         im.stale_callback = _stale_figure_callback
2967 
2968         im.set_array(X)
2969         im.set_alpha(alpha)
2970         if norm is None:
2971             im.set_clim(vmin, vmax)
2972         self.images.append(im)
2973         im._remove_method = self.images.remove
2974         self.stale = True
2975         return im
2976 
2977     def set_size_inches(self, w, h=None, forward=True):
2978         """
2979         Set the figure size in inches.
2980 
2981         Call signatures::
2982 
2983              fig.set_size_inches(w, h)  # OR
2984              fig.set_size_inches((w, h))
2985 
2986         Parameters
2987         ----------
2988         w : (float, float) or float
2989             Width and height in inches (if height not specified as a separate
2990             argument) or width.
2991         h : float
2992             Height in inches.
2993         forward : bool, default: True
2994             If ``True``, the canvas size is automatically updated, e.g.,
2995             you can resize the figure window from the shell.
2996 
2997         See Also
2998         --------
2999         matplotlib.figure.Figure.get_size_inches
3000         matplotlib.figure.Figure.set_figwidth
3001         matplotlib.figure.Figure.set_figheight
3002 
3003         Notes
3004         -----
3005         To transform from pixels to inches divide by `Figure.dpi`.
3006         """
3007         if h is None:  # Got called with a single pair as argument.
3008             w, h = w
3009         size = np.array([w, h])
3010         if not np.isfinite(size).all() or (size < 0).any():
3011             raise ValueError(f'figure size must be positive finite not {size}')
3012         self.bbox_inches.p1 = size
3013         if forward:
3014             manager = self.canvas.manager
3015             if manager is not None:
3016                 manager.resize(*(size * self.dpi).astype(int))
3017         self.stale = True
3018 
3019     def get_size_inches(self):
3020         """
3021         Return the current size of the figure in inches.
3022 
3023         Returns
3024         -------
3025         ndarray
3026            The size (width, height) of the figure in inches.
3027 
3028         See Also
3029         --------
3030         matplotlib.figure.Figure.set_size_inches
3031         matplotlib.figure.Figure.get_figwidth
3032         matplotlib.figure.Figure.get_figheight
3033 
3034         Notes
3035         -----
3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3037         """
3038         return np.array(self.bbox_inches.p1)
3039 
3040     def get_figwidth(self):
3041         """Return the figure width in inches."""
3042         return self.bbox_inches.width
3043 
3044     def get_figheight(self):
3045         """Return the figure height in inches."""
3046         return self.bbox_inches.height
3047 
3048     def get_dpi(self):
3049         """Return the resolution in dots per inch as a float."""
3050         return self.dpi
3051 
3052     def set_dpi(self, val):
3053         """
3054         Set the resolution of the figure in dots-per-inch.
3055 
3056         Parameters
3057         ----------
3058         val : float
3059         """
3060         self.dpi = val
3061         self.stale = True
3062 
3063     def set_figwidth(self, val, forward=True):
3064         """
3065         Set the width of the figure in inches.
3066 
3067         Parameters
3068         ----------
3069         val : float
3070         forward : bool
3071             See `set_size_inches`.
3072 
3073         See Also
3074         --------
3075         matplotlib.figure.Figure.set_figheight
3076         matplotlib.figure.Figure.set_size_inches
3077         """
3078         self.set_size_inches(val, self.get_figheight(), forward=forward)
3079 
3080     def set_figheight(self, val, forward=True):
3081         """
3082         Set the height of the figure in inches.
3083 
3084         Parameters
3085         ----------
3086         val : float
3087         forward : bool
3088             See `set_size_inches`.
3089 
3090         See Also
3091         --------
3092         matplotlib.figure.Figure.set_figwidth
3093         matplotlib.figure.Figure.set_size_inches
3094         """
3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3096 
3097     def clear(self, keep_observers=False):
3098         # docstring inherited
3099         super().clear(keep_observers=keep_observers)
3100         # FigureBase.clear does not clear toolbars, as
3101         # only Figure can have toolbars
3102         toolbar = self.canvas.toolbar
3103         if toolbar is not None:
3104             toolbar.update()
3105 
3106     @_finalize_rasterization
3107     @allow_rasterization
3108     def draw(self, renderer):
3109         # docstring inherited
3110 
3111         # draw the figure bounding box, perhaps none for white figure
3112         if not self.get_visible():
3113             return
3114 
3115         artists = self._get_draw_artists(renderer)
3116         try:
3117             renderer.open_group('figure', gid=self.get_gid())
3118             if self.axes and self.get_layout_engine() is not None:
3119                 try:
3120                     self.get_layout_engine().execute(self)
3121                 except ValueError:
3122                     pass
3123                     # ValueError can occur when resizing a window.
3124 
3125             self.patch.draw(renderer)
3126             mimage._draw_list_compositing_images(
3127                 renderer, self, artists, self.suppressComposite)
3128 
3129             for sfig in self.subfigs:
3130                 sfig.draw(renderer)
3131 
3132             renderer.close_group('figure')
3133         finally:
3134             self.stale = False
3135 
3136         DrawEvent("draw_event", self.canvas, renderer)._process()
3137 
3138     def draw_without_rendering(self):
3139         """
3140         Draw the figure with no output.  Useful to get the final size of
3141         artists that require a draw before their size is known (e.g. text).
3142         """
3143         renderer = _get_renderer(self)
3144         with renderer._draw_disabled():
3145             self.draw(renderer)
3146 
3147     def draw_artist(self, a):
3148         """
3149         Draw `.Artist` *a* only.
3150         """
3151         a.draw(self.canvas.get_renderer())
3152 
3153     def __getstate__(self):
3154         state = super().__getstate__()
3155 
3156         # The canvas cannot currently be pickled, but this has the benefit
3157         # of meaning that a figure can be detached from one canvas, and
3158         # re-attached to another.
3159         state.pop("canvas")
3160 
3161         # discard any changes to the dpi due to pixel ratio changes
3162         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3163 
3164         # add version information to the state
3165         state['__mpl_version__'] = mpl.__version__
3166 
3167         # check whether the figure manager (if any) is registered with pyplot
3168         from matplotlib import _pylab_helpers
3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3170             state['_restore_to_pylab'] = True
3171         return state
3172 
3173     def __setstate__(self, state):
3174         version = state.pop('__mpl_version__')
3175         restore_to_pylab = state.pop('_restore_to_pylab', False)
3176 
3177         if version != mpl.__version__:
3178             _api.warn_external(
3179                 f"This figure was saved with matplotlib version {version} and "
3180                 f"is unlikely to function correctly.")
3181 
3182         self.__dict__ = state
3183 
3184         # re-initialise some of the unstored state information
3185         FigureCanvasBase(self)  # Set self.canvas.
3186 
3187         if restore_to_pylab:
3188             # lazy import to avoid circularity
3189             import matplotlib.pyplot as plt
3190             import matplotlib._pylab_helpers as pylab_helpers
3191             allnums = plt.get_fignums()
3192             num = max(allnums) + 1 if allnums else 1
3193             backend = plt._get_backend_mod()
3194             mgr = backend.new_figure_manager_given_figure(num, self)
3195             pylab_helpers.Gcf._set_new_active_manager(mgr)
3196             plt.draw_if_interactive()
3197 
3198         self.stale = True
3199 
3200     def add_axobserver(self, func):
3201         """Whenever the Axes state change, ``func(self)`` will be called."""
3202         # Connect a wrapper lambda and not func itself, to avoid it being
3203         # weakref-collected.
3204         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3205 
3206     def savefig(self, fname, *, transparent=None, **kwargs):
3207         """
3208         Save the current figure.
3209 
3210         Call signature::
3211 
3212           savefig(fname, *, dpi='figure', format=None, metadata=None,
3213                   bbox_inches=None, pad_inches=0.1,
3214                   facecolor='auto', edgecolor='auto',
3215                   backend=None, **kwargs
3216                  )
3217 
3218         The available output formats depend on the backend being used.
3219 
3220         Parameters
3221         ----------
3222         fname : str or path-like or binary file-like
3223             A path, or a Python file-like object, or
3224             possibly some backend-dependent object such as
3225             `matplotlib.backends.backend_pdf.PdfPages`.
3226 
3227             If *format* is set, it determines the output format, and the file
3228             is saved as *fname*.  Note that *fname* is used verbatim, and there
3229             is no attempt to make the extension, if any, of *fname* match
3230             *format*, and no extension is appended.
3231 
3232             If *format* is not set, then the format is inferred from the
3233             extension of *fname*, if there is one.  If *format* is not
3234             set and *fname* has no extension, then the file is saved with
3235             :rc:`savefig.format` and the appropriate extension is appended to
3236             *fname*.
3237 
3238         Other Parameters
3239         ----------------
3240         dpi : float or 'figure', default: :rc:`savefig.dpi`
3241             The resolution in dots per inch.  If 'figure', use the figure's
3242             dpi value.
3243 
3244         format : str
3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3246             this is unset is documented under *fname*.
3247 
3248         metadata : dict, optional
3249             Key/value pairs to store in the image metadata. The supported keys
3250             and defaults depend on the image format and backend:
3251 
3252             - 'png' with Agg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasAgg.print_png`.
3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3255               `~.backend_pdf.PdfPages`.
3256             - 'svg' with svg backend: See the parameter ``metadata`` of
3257               `~.FigureCanvasSVG.print_svg`.
3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3259 
3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
3261             embedding metadata.
3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include
3263             embedding EXIF metadata in the future.
3264 
3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3266             Bounding box in inches: only the given portion of the figure is
3267             saved.  If 'tight', try to figure out the tight bbox of the figure.
3268 
3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3270             Amount of padding in inches around the figure when bbox_inches is
3271             'tight'. If 'layout' use the padding from the constrained or
3272             compressed layout engine; ignored if one of those engines is not in
3273             use.
3274 
3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3276             The facecolor of the figure.  If 'auto', use the current figure
3277             facecolor.
3278 
3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3280             The edgecolor of the figure.  If 'auto', use the current figure
3281             edgecolor.
3282 
3283         backend : str, optional
3284             Use a non-default backend to render the file, e.g. to render a
3285             png file with the "cairo" backend rather than the default "agg",
3286             or a pdf file with the "pgf" backend rather than the default
3287             "pdf".  Note that the default backend is normally sufficient.  See
3288             :ref:`the-builtin-backends` for a list of valid backends for each
3289             file format.  Custom backends can be referenced as "module://...".
3290 
3291         orientation : {'landscape', 'portrait'}
3292             Currently only supported by the postscript backend.
3293 
3294         papertype : str
3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3296             'a10', 'b0' through 'b10'. Only supported for postscript
3297             output.
3298 
3299         transparent : bool
3300             If *True*, the Axes patches will all be transparent; the
3301             Figure patch will also be transparent unless *facecolor*
3302             and/or *edgecolor* are specified via kwargs.
3303 
3304             If *False* has no effect and the color of the Axes and
3305             Figure patches are unchanged (unless the Figure patch
3306             is specified via the *facecolor* and/or *edgecolor* keyword
3307             arguments in which case those colors are used).
3308 
3309             The transparency of these patches will be restored to their
3310             original values upon exit of this function.
3311 
3312             This is useful, for example, for displaying
3313             a plot on top of a colored background on a web page.
3314 
3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3316             A list of extra artists that will be considered when the
3317             tight bbox is calculated.
3318 
3319         pil_kwargs : dict, optional
3320             Additional keyword arguments that are passed to
3321             `PIL.Image.Image.save` when saving the figure.
3322 
3323         """
3324 
3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3326         if transparent is None:
3327             transparent = mpl.rcParams['savefig.transparent']
3328 
3329         with ExitStack() as stack:
3330             if transparent:
3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3332                     exit_stack.enter_context(
3333                         subfig.patch._cm_set(
3334                             facecolor="none", edgecolor="none"))
3335                     for ax in subfig.axes:
3336                         exit_stack.enter_context(
3337                             ax.patch._cm_set(
3338                                 facecolor="none", edgecolor="none"))
3339                     for sub_subfig in subfig.subfigs:
3340                         _recursively_make_subfig_transparent(
3341                             exit_stack, sub_subfig)
3342 
3343                 def _recursively_make_axes_transparent(exit_stack, ax):
3344                     exit_stack.enter_context(
3345                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3346                     for child_ax in ax.child_axes:
3347                         exit_stack.enter_context(
3348                             child_ax.patch._cm_set(
3349                                 facecolor="none", edgecolor="none"))
3350                     for child_childax in ax.child_axes:
3351                         _recursively_make_axes_transparent(
3352                             exit_stack, child_childax)
3353 
3354                 kwargs.setdefault('facecolor', 'none')
3355                 kwargs.setdefault('edgecolor', 'none')
3356                 # set subfigure to appear transparent in printed image
3357                 for subfig in self.subfigs:
3358                     _recursively_make_subfig_transparent(stack, subfig)
3359                 # set axes to be transparent
3360                 for ax in self.axes:
3361                     _recursively_make_axes_transparent(stack, ax)
3362             self.canvas.print_figure(fname, **kwargs)
3363 
3364     def ginput(self, n=1, timeout=30, show_clicks=True,
3365                mouse_add=MouseButton.LEFT,
3366                mouse_pop=MouseButton.RIGHT,
3367                mouse_stop=MouseButton.MIDDLE):
3368         """
3369         Blocking call to interact with a figure.
3370 
3371         Wait until the user clicks *n* times on the figure, and return the
3372         coordinates of each click in a list.
3373 
3374         There are three possible interactions:
3375 
3376         - Add a point.
3377         - Remove the most recently added point.
3378         - Stop the interaction and return the points added so far.
3379 
3380         The actions are assigned to mouse buttons via the arguments
3381         *mouse_add*, *mouse_pop* and *mouse_stop*.
3382 
3383         Parameters
3384         ----------
3385         n : int, default: 1
3386             Number of mouse clicks to accumulate. If negative, accumulate
3387             clicks until the input is terminated manually.
3388         timeout : float, default: 30 seconds
3389             Number of seconds to wait before timing out. If zero or negative
3390             will never time out.
3391         show_clicks : bool, default: True
3392             If True, show a red cross at the location of each click.
3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3394             Mouse button used to add points.
3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3396             Mouse button used to remove the most recently added point.
3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3398             Mouse button used to stop input.
3399 
3400         Returns
3401         -------
3402         list of tuples
3403             A list of the clicked (x, y) coordinates.
3404 
3405         Notes
3406         -----
3407         The keyboard can also be used to select points in case your mouse
3408         does not have one or more of the buttons.  The delete and backspace
3409         keys act like right-clicking (i.e., remove last point), the enter key
3410         terminates input and any other key (not already used by the window
3411         manager) selects a point.
3412         """
3413         clicks = []
3414         marks = []
3415 
3416         def handler(event):
3417             is_button = event.name == "button_press_event"
3418             is_key = event.name == "key_press_event"
3419             # Quit (even if not in infinite mode; this is consistent with
3420             # MATLAB and sometimes quite useful, but will require the user to
3421             # test how many points were actually returned before using data).
3422             if (is_button and event.button == mouse_stop
3423                     or is_key and event.key in ["escape", "enter"]):
3424                 self.canvas.stop_event_loop()
3425             # Pop last click.
3426             elif (is_button and event.button == mouse_pop
3427                   or is_key and event.key in ["backspace", "delete"]):
3428                 if clicks:
3429                     clicks.pop()
3430                     if show_clicks:
3431                         marks.pop().remove()
3432                         self.canvas.draw()
3433             # Add new click.
3434             elif (is_button and event.button == mouse_add
3435                   # On macOS/gtk, some keys return None.
3436                   or is_key and event.key is not None):
3437                 if event.inaxes:
3438                     clicks.append((event.xdata, event.ydata))
3439                     _log.info("input %i: %f, %f",
3440                               len(clicks), event.xdata, event.ydata)
3441                     if show_clicks:
3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3443                                                 marker="+", color="r")
3444                         event.inaxes.add_line(line)
3445                         marks.append(line)
3446                         self.canvas.draw()
3447             if len(clicks) == n and n > 0:
3448                 self.canvas.stop_event_loop()
3449 
3450         _blocking_input.blocking_input_loop(
3451             self, ["button_press_event", "key_press_event"], timeout, handler)
3452 
3453         # Cleanup.
3454         for mark in marks:
3455             mark.remove()
3456         self.canvas.draw()
3457 
3458         return clicks
3459 
3460     def waitforbuttonpress(self, timeout=-1):
3461         """
3462         Blocking call to interact with the figure.
3463 
3464         Wait for user input and return True if a key was pressed, False if a
3465         mouse button was pressed and None if no input was given within
3466         *timeout* seconds.  Negative values deactivate *timeout*.
3467         """
3468         event = None
3469 
3470         def handler(ev):
3471             nonlocal event
3472             event = ev
3473             self.canvas.stop_event_loop()
3474 
3475         _blocking_input.blocking_input_loop(
3476             self, ["button_press_event", "key_press_event"], timeout, handler)
3477 
3478         return None if event is None else event.name == "key_press_event"
3479 
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 `matplotlib.figure` implements the following classes:
3 
4 `Figure`
5     Top level `~matplotlib.artist.Artist`, which holds all plot elements.
6     Many methods are implemented in `FigureBase`.
7 
8 `SubFigure`
9     A logical figure inside a figure, usually added to a figure (or parent
10     `SubFigure`) with `Figure.add_subfigure` or `Figure.subfigures` methods
11     (provisional API v3.4).
12 
13 `SubplotParams`
14     Control the default spacing between subplots.
15 
16 Figures are typically created using pyplot methods `~.pyplot.figure`,
17 `~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.
18 
19 .. plot::
20     :include-source:
21 
22     fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',
23                            layout='constrained')
24     fig.suptitle('Figure')
25     ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')
26 
27 Some situations call for directly instantiating a `~.figure.Figure` class,
28 usually inside an application of some sort (see :ref:`user_interfaces` for a
29 list of examples) .  More information about Figures can be found at
30 :ref:`figure_explanation`.
31 """
32 
33 from contextlib import ExitStack
34 import inspect
35 import itertools
36 import logging
37 from numbers import Integral
38 
39 import numpy as np
40 
41 import matplotlib as mpl
42 from matplotlib import _blocking_input, backend_bases, _docstring, projections
43 from matplotlib.artist import (
44     Artist, allow_rasterization, _finalize_rasterization)
45 from matplotlib.backend_bases import (
46     DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)
47 import matplotlib._api as _api
48 import matplotlib.cbook as cbook
49 import matplotlib.colorbar as cbar
50 import matplotlib.image as mimage
51 
52 from matplotlib.axes import Axes
53 from matplotlib.gridspec import GridSpec
54 from matplotlib.layout_engine import (
55     ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,
56     PlaceHolderLayoutEngine
57 )
58 import matplotlib.legend as mlegend
59 from matplotlib.patches import Rectangle
60 from matplotlib.text import Text
61 from matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,
62                                    TransformedBbox)
63 
64 _log = logging.getLogger(__name__)
65 
66 
67 def _stale_figure_callback(self, val):
68     if self.figure:
69         self.figure.stale = val
70 
71 
72 class _AxesStack:
73     """
74     Helper class to track axes in a figure.
75 
76     Axes are tracked both in the order in which they have been added
77     (``self._axes`` insertion/iteration order) and in the separate "gca" stack
78     (which is the index to which they map in the ``self._axes`` dict).
79     """
80 
81     def __init__(self):
82         self._axes = {}  # Mapping of axes to "gca" order.
83         self._counter = itertools.count()
84 
85     def as_list(self):
86         """List the axes that have been added to the figure."""
87         return [*self._axes]  # This relies on dict preserving order.
88 
89     def remove(self, a):
90         """Remove the axes from the stack."""
91         self._axes.pop(a)
92 
93     def bubble(self, a):
94         """Move an axes, which must already exist in the stack, to the top."""
95         if a not in self._axes:
96             raise ValueError("Axes has not been added yet")
97         self._axes[a] = next(self._counter)
98 
99     def add(self, a):
100         """Add an axes to the stack, ignoring it if already present."""
101         if a not in self._axes:
102             self._axes[a] = next(self._counter)
103 
104     def current(self):
105         """Return the active axes, or None if the stack is empty."""
106         return max(self._axes, key=self._axes.__getitem__, default=None)
107 
108 
109 class SubplotParams:
110     """
111     A class to hold the parameters for a subplot.
112     """
113 
114     def __init__(self, left=None, bottom=None, right=None, top=None,
115                  wspace=None, hspace=None):
116         """
117         Defaults are given by :rc:`figure.subplot.[name]`.
118 
119         Parameters
120         ----------
121         left : float
122             The position of the left edge of the subplots,
123             as a fraction of the figure width.
124         right : float
125             The position of the right edge of the subplots,
126             as a fraction of the figure width.
127         bottom : float
128             The position of the bottom edge of the subplots,
129             as a fraction of the figure height.
130         top : float
131             The position of the top edge of the subplots,
132             as a fraction of the figure height.
133         wspace : float
134             The width of the padding between subplots,
135             as a fraction of the average Axes width.
136         hspace : float
137             The height of the padding between subplots,
138             as a fraction of the average Axes height.
139         """
140         for key in ["left", "bottom", "right", "top", "wspace", "hspace"]:
141             setattr(self, key, mpl.rcParams[f"figure.subplot.{key}"])
142         self.update(left, bottom, right, top, wspace, hspace)
143 
144     def update(self, left=None, bottom=None, right=None, top=None,
145                wspace=None, hspace=None):
146         """
147         Update the dimensions of the passed parameters. *None* means unchanged.
148         """
149         if ((left if left is not None else self.left)
150                 >= (right if right is not None else self.right)):
151             raise ValueError('left cannot be >= right')
152         if ((bottom if bottom is not None else self.bottom)
153                 >= (top if top is not None else self.top)):
154             raise ValueError('bottom cannot be >= top')
155         if left is not None:
156             self.left = left
157         if right is not None:
158             self.right = right
159         if bottom is not None:
160             self.bottom = bottom
161         if top is not None:
162             self.top = top
163         if wspace is not None:
164             self.wspace = wspace
165         if hspace is not None:
166             self.hspace = hspace
167 
168 
169 class FigureBase(Artist):
170     """
171     Base class for `.Figure` and `.SubFigure` containing the methods that add
172     artists to the figure or subfigure, create Axes, etc.
173     """
174     def __init__(self, **kwargs):
175         super().__init__()
176         # remove the non-figure artist _axes property
177         # as it makes no sense for a figure to be _in_ an Axes
178         # this is used by the property methods in the artist base class
179         # which are over-ridden in this class
180         del self._axes
181 
182         self._suptitle = None
183         self._supxlabel = None
184         self._supylabel = None
185 
186         # groupers to keep track of x and y labels we want to align.
187         # see self.align_xlabels and self.align_ylabels and
188         # axis._get_tick_boxes_siblings
189         self._align_label_groups = {"x": cbook.Grouper(), "y": cbook.Grouper()}
190 
191         self.figure = self
192         self._localaxes = []  # track all axes
193         self.artists = []
194         self.lines = []
195         self.patches = []
196         self.texts = []
197         self.images = []
198         self.legends = []
199         self.subfigs = []
200         self.stale = True
201         self.suppressComposite = None
202         self.set(**kwargs)
203 
204     def _get_draw_artists(self, renderer):
205         """Also runs apply_aspect"""
206         artists = self.get_children()
207         for sfig in self.subfigs:
208             artists.remove(sfig)
209             childa = sfig.get_children()
210             for child in childa:
211                 if child in artists:
212                     artists.remove(child)
213 
214         artists.remove(self.patch)
215         artists = sorted(
216             (artist for artist in artists if not artist.get_animated()),
217             key=lambda artist: artist.get_zorder())
218         for ax in self._localaxes:
219             locator = ax.get_axes_locator()
220             ax.apply_aspect(locator(ax, renderer) if locator else None)
221 
222             for child in ax.get_children():
223                 if hasattr(child, 'apply_aspect'):
224                     locator = child.get_axes_locator()
225                     child.apply_aspect(
226                         locator(child, renderer) if locator else None)
227         return artists
228 
229     def autofmt_xdate(
230             self, bottom=0.2, rotation=30, ha='right', which='major'):
231         """
232         Date ticklabels often overlap, so it is useful to rotate them
233         and right align them.  Also, a common use case is a number of
234         subplots with shared x-axis where the x-axis is date data.  The
235         ticklabels are often long, and it helps to rotate them on the
236         bottom subplot and turn them off on other subplots, as well as
237         turn off xlabels.
238 
239         Parameters
240         ----------
241         bottom : float, default: 0.2
242             The bottom of the subplots for `subplots_adjust`.
243         rotation : float, default: 30 degrees
244             The rotation angle of the xtick labels in degrees.
245         ha : {'left', 'center', 'right'}, default: 'right'
246             The horizontal alignment of the xticklabels.
247         which : {'major', 'minor', 'both'}, default: 'major'
248             Selects which ticklabels to rotate.
249         """
250         _api.check_in_list(['major', 'minor', 'both'], which=which)
251         allsubplots = all(ax.get_subplotspec() for ax in self.axes)
252         if len(self.axes) == 1:
253             for label in self.axes[0].get_xticklabels(which=which):
254                 label.set_ha(ha)
255                 label.set_rotation(rotation)
256         else:
257             if allsubplots:
258                 for ax in self.get_axes():
259                     if ax.get_subplotspec().is_last_row():
260                         for label in ax.get_xticklabels(which=which):
261                             label.set_ha(ha)
262                             label.set_rotation(rotation)
263                     else:
264                         for label in ax.get_xticklabels(which=which):
265                             label.set_visible(False)
266                         ax.set_xlabel('')
267 
268         if allsubplots:
269             self.subplots_adjust(bottom=bottom)
270         self.stale = True
271 
272     def get_children(self):
273         """Get a list of artists contained in the figure."""
274         return [self.patch,
275                 *self.artists,
276                 *self._localaxes,
277                 *self.lines,
278                 *self.patches,
279                 *self.texts,
280                 *self.images,
281                 *self.legends,
282                 *self.subfigs]
283 
284     def contains(self, mouseevent):
285         """
286         Test whether the mouse event occurred on the figure.
287 
288         Returns
289         -------
290             bool, {}
291         """
292         if self._different_canvas(mouseevent):
293             return False, {}
294         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
295         return inside, {}
296 
297     def get_window_extent(self, renderer=None):
298         # docstring inherited
299         return self.bbox
300 
301     def _suplabels(self, t, info, **kwargs):
302         """
303         Add a centered %(name)s to the figure.
304 
305         Parameters
306         ----------
307         t : str
308             The %(name)s text.
309         x : float, default: %(x0)s
310             The x location of the text in figure coordinates.
311         y : float, default: %(y0)s
312             The y location of the text in figure coordinates.
313         horizontalalignment, ha : {'center', 'left', 'right'}, default: %(ha)s
314             The horizontal alignment of the text relative to (*x*, *y*).
315         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
316 default: %(va)s
317             The vertical alignment of the text relative to (*x*, *y*).
318         fontsize, size : default: :rc:`figure.%(rc)ssize`
319             The font size of the text. See `.Text.set_size` for possible
320             values.
321         fontweight, weight : default: :rc:`figure.%(rc)sweight`
322             The font weight of the text. See `.Text.set_weight` for possible
323             values.
324 
325         Returns
326         -------
327         text
328             The `.Text` instance of the %(name)s.
329 
330         Other Parameters
331         ----------------
332         fontproperties : None or dict, optional
333             A dict of font properties. If *fontproperties* is given the
334             default values for font size and weight are taken from the
335             `.FontProperties` defaults. :rc:`figure.%(rc)ssize` and
336             :rc:`figure.%(rc)sweight` are ignored in this case.
337 
338         **kwargs
339             Additional kwargs are `matplotlib.text.Text` properties.
340         """
341 
342         suplab = getattr(self, info['name'])
343 
344         x = kwargs.pop('x', None)
345         y = kwargs.pop('y', None)
346         if info['name'] in ['_supxlabel', '_suptitle']:
347             autopos = y is None
348         elif info['name'] == '_supylabel':
349             autopos = x is None
350         if x is None:
351             x = info['x0']
352         if y is None:
353             y = info['y0']
354 
355         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
356             kwargs['horizontalalignment'] = info['ha']
357         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
358             kwargs['verticalalignment'] = info['va']
359         if 'rotation' not in kwargs:
360             kwargs['rotation'] = info['rotation']
361 
362         if 'fontproperties' not in kwargs:
363             if 'fontsize' not in kwargs and 'size' not in kwargs:
364                 kwargs['size'] = mpl.rcParams[info['size']]
365             if 'fontweight' not in kwargs and 'weight' not in kwargs:
366                 kwargs['weight'] = mpl.rcParams[info['weight']]
367 
368         sup = self.text(x, y, t, **kwargs)
369         if suplab is not None:
370             suplab.set_text(t)
371             suplab.set_position((x, y))
372             suplab.update_from(sup)
373             sup.remove()
374         else:
375             suplab = sup
376         suplab._autopos = autopos
377         setattr(self, info['name'], suplab)
378         self.stale = True
379         return suplab
380 
381     @_docstring.Substitution(x0=0.5, y0=0.98, name='suptitle', ha='center',
382                              va='top', rc='title')
383     @_docstring.copy(_suplabels)
384     def suptitle(self, t, **kwargs):
385         # docstring from _suplabels...
386         info = {'name': '_suptitle', 'x0': 0.5, 'y0': 0.98,
387                 'ha': 'center', 'va': 'top', 'rotation': 0,
388                 'size': 'figure.titlesize', 'weight': 'figure.titleweight'}
389         return self._suplabels(t, info, **kwargs)
390 
391     @_docstring.Substitution(x0=0.5, y0=0.01, name='supxlabel', ha='center',
392                              va='bottom', rc='label')
393     @_docstring.copy(_suplabels)
394     def supxlabel(self, t, **kwargs):
395         # docstring from _suplabels...
396         info = {'name': '_supxlabel', 'x0': 0.5, 'y0': 0.01,
397                 'ha': 'center', 'va': 'bottom', 'rotation': 0,
398                 'size': 'figure.labelsize', 'weight': 'figure.labelweight'}
399         return self._suplabels(t, info, **kwargs)
400 
401     @_docstring.Substitution(x0=0.02, y0=0.5, name='supylabel', ha='left',
402                              va='center', rc='label')
403     @_docstring.copy(_suplabels)
404     def supylabel(self, t, **kwargs):
405         # docstring from _suplabels...
406         info = {'name': '_supylabel', 'x0': 0.02, 'y0': 0.5,
407                 'ha': 'left', 'va': 'center', 'rotation': 'vertical',
408                 'rotation_mode': 'anchor', 'size': 'figure.labelsize',
409                 'weight': 'figure.labelweight'}
410         return self._suplabels(t, info, **kwargs)
411 
412     def get_edgecolor(self):
413         """Get the edge color of the Figure rectangle."""
414         return self.patch.get_edgecolor()
415 
416     def get_facecolor(self):
417         """Get the face color of the Figure rectangle."""
418         return self.patch.get_facecolor()
419 
420     def get_frameon(self):
421         """
422         Return the figure's background patch visibility, i.e.
423         whether the figure background will be drawn. Equivalent to
424         ``Figure.patch.get_visible()``.
425         """
426         return self.patch.get_visible()
427 
428     def set_linewidth(self, linewidth):
429         """
430         Set the line width of the Figure rectangle.
431 
432         Parameters
433         ----------
434         linewidth : number
435         """
436         self.patch.set_linewidth(linewidth)
437 
438     def get_linewidth(self):
439         """
440         Get the line width of the Figure rectangle.
441         """
442         return self.patch.get_linewidth()
443 
444     def set_edgecolor(self, color):
445         """
446         Set the edge color of the Figure rectangle.
447 
448         Parameters
449         ----------
450         color : color
451         """
452         self.patch.set_edgecolor(color)
453 
454     def set_facecolor(self, color):
455         """
456         Set the face color of the Figure rectangle.
457 
458         Parameters
459         ----------
460         color : color
461         """
462         self.patch.set_facecolor(color)
463 
464     def set_frameon(self, b):
465         """
466         Set the figure's background patch visibility, i.e.
467         whether the figure background will be drawn. Equivalent to
468         ``Figure.patch.set_visible()``.
469 
470         Parameters
471         ----------
472         b : bool
473         """
474         self.patch.set_visible(b)
475         self.stale = True
476 
477     frameon = property(get_frameon, set_frameon)
478 
479     def add_artist(self, artist, clip=False):
480         """
481         Add an `.Artist` to the figure.
482 
483         Usually artists are added to `~.axes.Axes` objects using
484         `.Axes.add_artist`; this method can be used in the rare cases where
485         one needs to add artists directly to the figure instead.
486 
487         Parameters
488         ----------
489         artist : `~matplotlib.artist.Artist`
490             The artist to add to the figure. If the added artist has no
491             transform previously set, its transform will be set to
492             ``figure.transSubfigure``.
493         clip : bool, default: False
494             Whether the added artist should be clipped by the figure patch.
495 
496         Returns
497         -------
498         `~matplotlib.artist.Artist`
499             The added artist.
500         """
501         artist.set_figure(self)
502         self.artists.append(artist)
503         artist._remove_method = self.artists.remove
504 
505         if not artist.is_transform_set():
506             artist.set_transform(self.transSubfigure)
507 
508         if clip and artist.get_clip_path() is None:
509             artist.set_clip_path(self.patch)
510 
511         self.stale = True
512         return artist
513 
514     @_docstring.dedent_interpd
515     def add_axes(self, *args, **kwargs):
516         """
517         Add an `~.axes.Axes` to the figure.
518 
519         Call signatures::
520 
521             add_axes(rect, projection=None, polar=False, **kwargs)
522             add_axes(ax)
523 
524         Parameters
525         ----------
526         rect : tuple (left, bottom, width, height)
527             The dimensions (left, bottom, width, height) of the new
528             `~.axes.Axes`. All quantities are in fractions of figure width and
529             height.
530 
531         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
532 'polar', 'rectilinear', str}, optional
533             The projection type of the `~.axes.Axes`. *str* is the name of
534             a custom projection, see `~matplotlib.projections`. The default
535             None results in a 'rectilinear' projection.
536 
537         polar : bool, default: False
538             If True, equivalent to projection='polar'.
539 
540         axes_class : subclass type of `~.axes.Axes`, optional
541             The `.axes.Axes` subclass that is instantiated.  This parameter
542             is incompatible with *projection* and *polar*.  See
543             :ref:`axisartist_users-guide-index` for examples.
544 
545         sharex, sharey : `~.axes.Axes`, optional
546             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
547             The axis will have the same limits, ticks, and scale as the axis
548             of the shared axes.
549 
550         label : str
551             A label for the returned Axes.
552 
553         Returns
554         -------
555         `~.axes.Axes`, or a subclass of `~.axes.Axes`
556             The returned axes class depends on the projection used. It is
557             `~.axes.Axes` if rectilinear projection is used and
558             `.projections.polar.PolarAxes` if polar projection is used.
559 
560         Other Parameters
561         ----------------
562         **kwargs
563             This method also takes the keyword arguments for
564             the returned Axes class. The keyword arguments for the
565             rectilinear Axes class `~.axes.Axes` can be found in
566             the following table but there might also be other keyword
567             arguments if another projection is used, see the actual Axes
568             class.
569 
570             %(Axes:kwdoc)s
571 
572         Notes
573         -----
574         In rare circumstances, `.add_axes` may be called with a single
575         argument, an Axes instance already created in the present figure but
576         not in the figure's list of Axes.
577 
578         See Also
579         --------
580         .Figure.add_subplot
581         .pyplot.subplot
582         .pyplot.axes
583         .Figure.subplots
584         .pyplot.subplots
585 
586         Examples
587         --------
588         Some simple examples::
589 
590             rect = l, b, w, h
591             fig = plt.figure()
592             fig.add_axes(rect)
593             fig.add_axes(rect, frameon=False, facecolor='g')
594             fig.add_axes(rect, polar=True)
595             ax = fig.add_axes(rect, projection='polar')
596             fig.delaxes(ax)
597             fig.add_axes(ax)
598         """
599 
600         if not len(args) and 'rect' not in kwargs:
601             raise TypeError(
602                 "add_axes() missing 1 required positional argument: 'rect'")
603         elif 'rect' in kwargs:
604             if len(args):
605                 raise TypeError(
606                     "add_axes() got multiple values for argument 'rect'")
607             args = (kwargs.pop('rect'), )
608 
609         if isinstance(args[0], Axes):
610             a = args[0]
611             key = a._projection_init
612             if a.get_figure() is not self:
613                 raise ValueError(
614                     "The Axes must have been created in the present figure")
615         else:
616             rect = args[0]
617             if not np.isfinite(rect).all():
618                 raise ValueError('all entries in rect must be finite '
619                                  f'not {rect}')
620             projection_class, pkw = self._process_projection_requirements(
621                 *args, **kwargs)
622 
623             # create the new axes using the axes class given
624             a = projection_class(self, rect, **pkw)
625             key = (projection_class, pkw)
626         return self._add_axes_internal(a, key)
627 
628     @_docstring.dedent_interpd
629     def add_subplot(self, *args, **kwargs):
630         """
631         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
632 
633         Call signatures::
634 
635            add_subplot(nrows, ncols, index, **kwargs)
636            add_subplot(pos, **kwargs)
637            add_subplot(ax)
638            add_subplot()
639 
640         Parameters
641         ----------
642         *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
643             The position of the subplot described by one of
644 
645             - Three integers (*nrows*, *ncols*, *index*). The subplot will
646               take the *index* position on a grid with *nrows* rows and
647               *ncols* columns. *index* starts at 1 in the upper left corner
648               and increases to the right.  *index* can also be a two-tuple
649               specifying the (*first*, *last*) indices (1-based, and including
650               *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``
651               makes a subplot that spans the upper 2/3 of the figure.
652             - A 3-digit integer. The digits are interpreted as if given
653               separately as three single-digit integers, i.e.
654               ``fig.add_subplot(235)`` is the same as
655               ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
656               if there are no more than 9 subplots.
657             - A `.SubplotSpec`.
658 
659             In rare circumstances, `.add_subplot` may be called with a single
660             argument, a subplot Axes instance already created in the
661             present figure but not in the figure's list of Axes.
662 
663         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
664 'polar', 'rectilinear', str}, optional
665             The projection type of the subplot (`~.axes.Axes`). *str* is the
666             name of a custom projection, see `~matplotlib.projections`. The
667             default None results in a 'rectilinear' projection.
668 
669         polar : bool, default: False
670             If True, equivalent to projection='polar'.
671 
672         axes_class : subclass type of `~.axes.Axes`, optional
673             The `.axes.Axes` subclass that is instantiated.  This parameter
674             is incompatible with *projection* and *polar*.  See
675             :ref:`axisartist_users-guide-index` for examples.
676 
677         sharex, sharey : `~.axes.Axes`, optional
678             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
679             The axis will have the same limits, ticks, and scale as the axis
680             of the shared axes.
681 
682         label : str
683             A label for the returned Axes.
684 
685         Returns
686         -------
687         `~.axes.Axes`
688 
689             The Axes of the subplot. The returned Axes can actually be an
690             instance of a subclass, such as `.projections.polar.PolarAxes` for
691             polar projections.
692 
693         Other Parameters
694         ----------------
695         **kwargs
696             This method also takes the keyword arguments for the returned Axes
697             base class; except for the *figure* argument. The keyword arguments
698             for the rectilinear base class `~.axes.Axes` can be found in
699             the following table but there might also be other keyword
700             arguments if another projection is used.
701 
702             %(Axes:kwdoc)s
703 
704         See Also
705         --------
706         .Figure.add_axes
707         .pyplot.subplot
708         .pyplot.axes
709         .Figure.subplots
710         .pyplot.subplots
711 
712         Examples
713         --------
714         ::
715 
716             fig = plt.figure()
717 
718             fig.add_subplot(231)
719             ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general
720 
721             fig.add_subplot(232, frameon=False)  # subplot with no frame
722             fig.add_subplot(233, projection='polar')  # polar subplot
723             fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1
724             fig.add_subplot(235, facecolor="red")  # red subplot
725 
726             ax1.remove()  # delete ax1 from the figure
727             fig.add_subplot(ax1)  # add ax1 back to the figure
728         """
729         if 'figure' in kwargs:
730             # Axes itself allows for a 'figure' kwarg, but since we want to
731             # bind the created Axes to self, it is not allowed here.
732             raise _api.kwarg_error("add_subplot", "figure")
733 
734         if (len(args) == 1
735                 and isinstance(args[0], mpl.axes._base._AxesBase)
736                 and args[0].get_subplotspec()):
737             ax = args[0]
738             key = ax._projection_init
739             if ax.get_figure() is not self:
740                 raise ValueError("The Axes must have been created in "
741                                  "the present figure")
742         else:
743             if not args:
744                 args = (1, 1, 1)
745             # Normalize correct ijk values to (i, j, k) here so that
746             # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will
747             # trigger errors later (via SubplotSpec._from_subplot_args).
748             if (len(args) == 1 and isinstance(args[0], Integral)
749                     and 100 <= args[0] <= 999):
750                 args = tuple(map(int, str(args[0])))
751             projection_class, pkw = self._process_projection_requirements(
752                 *args, **kwargs)
753             ax = projection_class(self, *args, **pkw)
754             key = (projection_class, pkw)
755         return self._add_axes_internal(ax, key)
756 
757     def _add_axes_internal(self, ax, key):
758         """Private helper for `add_axes` and `add_subplot`."""
759         self._axstack.add(ax)
760         if ax not in self._localaxes:
761             self._localaxes.append(ax)
762         self.sca(ax)
763         ax._remove_method = self.delaxes
764         # this is to support plt.subplot's re-selection logic
765         ax._projection_init = key
766         self.stale = True
767         ax.stale_callback = _stale_figure_callback
768         return ax
769 
770     def subplots(self, nrows=1, ncols=1, *, sharex=False, sharey=False,
771                  squeeze=True, width_ratios=None, height_ratios=None,
772                  subplot_kw=None, gridspec_kw=None):
773         """
774         Add a set of subplots to this figure.
775 
776         This utility wrapper makes it convenient to create common layouts of
777         subplots in a single call.
778 
779         Parameters
780         ----------
781         nrows, ncols : int, default: 1
782             Number of rows/columns of the subplot grid.
783 
784         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
785             Controls sharing of x-axis (*sharex*) or y-axis (*sharey*):
786 
787             - True or 'all': x- or y-axis will be shared among all subplots.
788             - False or 'none': each subplot x- or y-axis will be independent.
789             - 'row': each subplot row will share an x- or y-axis.
790             - 'col': each subplot column will share an x- or y-axis.
791 
792             When subplots have a shared x-axis along a column, only the x tick
793             labels of the bottom subplot are created. Similarly, when subplots
794             have a shared y-axis along a row, only the y tick labels of the
795             first column subplot are created. To later turn other subplots'
796             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
797 
798             When subplots have a shared axis that has units, calling
799             `.Axis.set_units` will update each axis with the new units.
800 
801         squeeze : bool, default: True
802             - If True, extra dimensions are squeezed out from the returned
803               array of Axes:
804 
805               - if only one subplot is constructed (nrows=ncols=1), the
806                 resulting single Axes object is returned as a scalar.
807               - for Nx1 or 1xM subplots, the returned object is a 1D numpy
808                 object array of Axes objects.
809               - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
810 
811             - If False, no squeezing at all is done: the returned Axes object
812               is always a 2D array containing Axes instances, even if it ends
813               up being 1x1.
814 
815         width_ratios : array-like of length *ncols*, optional
816             Defines the relative widths of the columns. Each column gets a
817             relative width of ``width_ratios[i] / sum(width_ratios)``.
818             If not given, all columns will have the same width.  Equivalent
819             to ``gridspec_kw={'width_ratios': [...]}``.
820 
821         height_ratios : array-like of length *nrows*, optional
822             Defines the relative heights of the rows. Each row gets a
823             relative height of ``height_ratios[i] / sum(height_ratios)``.
824             If not given, all rows will have the same height. Equivalent
825             to ``gridspec_kw={'height_ratios': [...]}``.
826 
827         subplot_kw : dict, optional
828             Dict with keywords passed to the `.Figure.add_subplot` call used to
829             create each subplot.
830 
831         gridspec_kw : dict, optional
832             Dict with keywords passed to the
833             `~matplotlib.gridspec.GridSpec` constructor used to create
834             the grid the subplots are placed on.
835 
836         Returns
837         -------
838         `~.axes.Axes` or array of Axes
839             Either a single `~matplotlib.axes.Axes` object or an array of Axes
840             objects if more than one subplot was created. The dimensions of the
841             resulting array can be controlled with the *squeeze* keyword, see
842             above.
843 
844         See Also
845         --------
846         .pyplot.subplots
847         .Figure.add_subplot
848         .pyplot.subplot
849 
850         Examples
851         --------
852         ::
853 
854             # First create some toy data:
855             x = np.linspace(0, 2*np.pi, 400)
856             y = np.sin(x**2)
857 
858             # Create a figure
859             plt.figure()
860 
861             # Create a subplot
862             ax = fig.subplots()
863             ax.plot(x, y)
864             ax.set_title('Simple plot')
865 
866             # Create two subplots and unpack the output array immediately
867             ax1, ax2 = fig.subplots(1, 2, sharey=True)
868             ax1.plot(x, y)
869             ax1.set_title('Sharing Y axis')
870             ax2.scatter(x, y)
871 
872             # Create four polar Axes and access them through the returned array
873             axes = fig.subplots(2, 2, subplot_kw=dict(projection='polar'))
874             axes[0, 0].plot(x, y)
875             axes[1, 1].scatter(x, y)
876 
877             # Share an X-axis with each column of subplots
878             fig.subplots(2, 2, sharex='col')
879 
880             # Share a Y-axis with each row of subplots
881             fig.subplots(2, 2, sharey='row')
882 
883             # Share both X- and Y-axes with all subplots
884             fig.subplots(2, 2, sharex='all', sharey='all')
885 
886             # Note that this is the same as
887             fig.subplots(2, 2, sharex=True, sharey=True)
888         """
889         gridspec_kw = dict(gridspec_kw or {})
890         if height_ratios is not None:
891             if 'height_ratios' in gridspec_kw:
892                 raise ValueError("'height_ratios' must not be defined both as "
893                                  "parameter and as key in 'gridspec_kw'")
894             gridspec_kw['height_ratios'] = height_ratios
895         if width_ratios is not None:
896             if 'width_ratios' in gridspec_kw:
897                 raise ValueError("'width_ratios' must not be defined both as "
898                                  "parameter and as key in 'gridspec_kw'")
899             gridspec_kw['width_ratios'] = width_ratios
900 
901         gs = self.add_gridspec(nrows, ncols, figure=self, **gridspec_kw)
902         axs = gs.subplots(sharex=sharex, sharey=sharey, squeeze=squeeze,
903                           subplot_kw=subplot_kw)
904         return axs
905 
906     def delaxes(self, ax):
907         """
908         Remove the `~.axes.Axes` *ax* from the figure; update the current Axes.
909         """
910 
911         def _reset_locators_and_formatters(axis):
912             # Set the formatters and locators to be associated with axis
913             # (where previously they may have been associated with another
914             # Axis instance)
915             axis.get_major_formatter().set_axis(axis)
916             axis.get_major_locator().set_axis(axis)
917             axis.get_minor_formatter().set_axis(axis)
918             axis.get_minor_locator().set_axis(axis)
919 
920         def _break_share_link(ax, grouper):
921             siblings = grouper.get_siblings(ax)
922             if len(siblings) > 1:
923                 grouper.remove(ax)
924                 for last_ax in siblings:
925                     if ax is not last_ax:
926                         return last_ax
927             return None
928 
929         self._axstack.remove(ax)
930         self._axobservers.process("_axes_change_event", self)
931         self.stale = True
932         self._localaxes.remove(ax)
933         self.canvas.release_mouse(ax)
934 
935         # Break link between any shared axes
936         for name in ax._axis_names:
937             last_ax = _break_share_link(ax, ax._shared_axes[name])
938             if last_ax is not None:
939                 _reset_locators_and_formatters(last_ax._axis_map[name])
940 
941         # Break link between any twinned axes
942         _break_share_link(ax, ax._twinned_axes)
943 
944     def clear(self, keep_observers=False):
945         """
946         Clear the figure.
947 
948         Parameters
949         ----------
950         keep_observers : bool, default: False
951             Set *keep_observers* to True if, for example,
952             a gui widget is tracking the Axes in the figure.
953         """
954         self.suppressComposite = None
955 
956         # first clear the axes in any subfigures
957         for subfig in self.subfigs:
958             subfig.clear(keep_observers=keep_observers)
959         self.subfigs = []
960 
961         for ax in tuple(self.axes):  # Iterate over the copy.
962             ax.clear()
963             self.delaxes(ax)  # Remove ax from self._axstack.
964 
965         self.artists = []
966         self.lines = []
967         self.patches = []
968         self.texts = []
969         self.images = []
970         self.legends = []
971         if not keep_observers:
972             self._axobservers = cbook.CallbackRegistry()
973         self._suptitle = None
974         self._supxlabel = None
975         self._supylabel = None
976 
977         self.stale = True
978 
979     # synonym for `clear`.
980     def clf(self, keep_observers=False):
981         """
982         [*Discouraged*] Alias for the `clear()` method.
983 
984         .. admonition:: Discouraged
985 
986             The use of ``clf()`` is discouraged. Use ``clear()`` instead.
987 
988         Parameters
989         ----------
990         keep_observers : bool, default: False
991             Set *keep_observers* to True if, for example,
992             a gui widget is tracking the Axes in the figure.
993         """
994         return self.clear(keep_observers=keep_observers)
995 
996     # Note: the docstring below is modified with replace for the pyplot
997     # version of this function because the method name differs (plt.figlegend)
998     # the replacements are:
999     #    " legend(" -> " figlegend(" for the signatures
1000     #    "fig.legend(" -> "plt.figlegend" for the code examples
1001     #    "ax.plot" -> "plt.plot" for consistency in using pyplot when able
1002     @_docstring.dedent_interpd
1003     def legend(self, *args, **kwargs):
1004         """
1005         Place a legend on the figure.
1006 
1007         Call signatures::
1008 
1009             legend()
1010             legend(handles, labels)
1011             legend(handles=handles)
1012             legend(labels)
1013 
1014         The call signatures correspond to the following different ways to use
1015         this method:
1016 
1017         **1. Automatic detection of elements to be shown in the legend**
1018 
1019         The elements to be added to the legend are automatically determined,
1020         when you do not pass in any extra arguments.
1021 
1022         In this case, the labels are taken from the artist. You can specify
1023         them either at artist creation or by calling the
1024         :meth:`~.Artist.set_label` method on the artist::
1025 
1026             ax.plot([1, 2, 3], label='Inline label')
1027             fig.legend()
1028 
1029         or::
1030 
1031             line, = ax.plot([1, 2, 3])
1032             line.set_label('Label via method')
1033             fig.legend()
1034 
1035         Specific lines can be excluded from the automatic legend element
1036         selection by defining a label starting with an underscore.
1037         This is default for all artists, so calling `.Figure.legend` without
1038         any arguments and without setting the labels manually will result in
1039         no legend being drawn.
1040 
1041 
1042         **2. Explicitly listing the artists and labels in the legend**
1043 
1044         For full control of which artists have a legend entry, it is possible
1045         to pass an iterable of legend artists followed by an iterable of
1046         legend labels respectively::
1047 
1048             fig.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
1049 
1050 
1051         **3. Explicitly listing the artists in the legend**
1052 
1053         This is similar to 2, but the labels are taken from the artists'
1054         label properties. Example::
1055 
1056             line1, = ax1.plot([1, 2, 3], label='label1')
1057             line2, = ax2.plot([1, 2, 3], label='label2')
1058             fig.legend(handles=[line1, line2])
1059 
1060 
1061         **4. Labeling existing plot elements**
1062 
1063         .. admonition:: Discouraged
1064 
1065             This call signature is discouraged, because the relation between
1066             plot elements and labels is only implicit by their order and can
1067             easily be mixed up.
1068 
1069         To make a legend for all artists on all Axes, call this function with
1070         an iterable of strings, one for each legend item. For example::
1071 
1072             fig, (ax1, ax2) = plt.subplots(1, 2)
1073             ax1.plot([1, 3, 5], color='blue')
1074             ax2.plot([2, 4, 6], color='red')
1075             fig.legend(['the blues', 'the reds'])
1076 
1077 
1078         Parameters
1079         ----------
1080         handles : list of `.Artist`, optional
1081             A list of Artists (lines, patches) to be added to the legend.
1082             Use this together with *labels*, if you need full control on what
1083             is shown in the legend and the automatic mechanism described above
1084             is not sufficient.
1085 
1086             The length of handles and labels should be the same in this
1087             case. If they are not, they are truncated to the smaller length.
1088 
1089         labels : list of str, optional
1090             A list of labels to show next to the artists.
1091             Use this together with *handles*, if you need full control on what
1092             is shown in the legend and the automatic mechanism described above
1093             is not sufficient.
1094 
1095         Returns
1096         -------
1097         `~matplotlib.legend.Legend`
1098 
1099         Other Parameters
1100         ----------------
1101         %(_legend_kw_figure)s
1102 
1103         See Also
1104         --------
1105         .Axes.legend
1106 
1107         Notes
1108         -----
1109         Some artists are not supported by this function.  See
1110         :ref:`legend_guide` for details.
1111         """
1112 
1113         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1114                 self.axes,
1115                 *args,
1116                 **kwargs)
1117         # check for third arg
1118         if len(extra_args):
1119             # _api.warn_deprecated(
1120             #     "2.1",
1121             #     message="Figure.legend will accept no more than two "
1122             #     "positional arguments in the future.  Use "
1123             #     "'fig.legend(handles, labels, loc=location)' "
1124             #     "instead.")
1125             # kwargs['loc'] = extra_args[0]
1126             # extra_args = extra_args[1:]
1127             pass
1128         transform = kwargs.pop('bbox_transform', self.transSubfigure)
1129         # explicitly set the bbox transform if the user hasn't.
1130         l = mlegend.Legend(self, handles, labels, *extra_args,
1131                            bbox_transform=transform, **kwargs)
1132         self.legends.append(l)
1133         l._remove_method = self.legends.remove
1134         self.stale = True
1135         return l
1136 
1137     @_docstring.dedent_interpd
1138     def text(self, x, y, s, fontdict=None, **kwargs):
1139         """
1140         Add text to figure.
1141 
1142         Parameters
1143         ----------
1144         x, y : float
1145             The position to place the text. By default, this is in figure
1146             coordinates, floats in [0, 1]. The coordinate system can be changed
1147             using the *transform* keyword.
1148 
1149         s : str
1150             The text string.
1151 
1152         fontdict : dict, optional
1153             A dictionary to override the default text properties. If not given,
1154             the defaults are determined by :rc:`font.*`. Properties passed as
1155             *kwargs* override the corresponding ones given in *fontdict*.
1156 
1157         Returns
1158         -------
1159         `~.text.Text`
1160 
1161         Other Parameters
1162         ----------------
1163         **kwargs : `~matplotlib.text.Text` properties
1164             Other miscellaneous text parameters.
1165 
1166             %(Text:kwdoc)s
1167 
1168         See Also
1169         --------
1170         .Axes.text
1171         .pyplot.text
1172         """
1173         effective_kwargs = {
1174             'transform': self.transSubfigure,
1175             **(fontdict if fontdict is not None else {}),
1176             **kwargs,
1177         }
1178         text = Text(x=x, y=y, text=s, **effective_kwargs)
1179         text.set_figure(self)
1180         text.stale_callback = _stale_figure_callback
1181 
1182         self.texts.append(text)
1183         text._remove_method = self.texts.remove
1184         self.stale = True
1185         return text
1186 
1187     @_docstring.dedent_interpd
1188     def colorbar(
1189             self, mappable, cax=None, ax=None, use_gridspec=True, **kwargs):
1190         """
1191         Add a colorbar to a plot.
1192 
1193         Parameters
1194         ----------
1195         mappable
1196             The `matplotlib.cm.ScalarMappable` (i.e., `.AxesImage`,
1197             `.ContourSet`, etc.) described by this colorbar.  This argument is
1198             mandatory for the `.Figure.colorbar` method but optional for the
1199             `.pyplot.colorbar` function, which sets the default to the current
1200             image.
1201 
1202             Note that one can create a `.ScalarMappable` "on-the-fly" to
1203             generate colorbars not attached to a previously drawn artist, e.g.
1204             ::
1205 
1206                 fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
1207 
1208         cax : `~matplotlib.axes.Axes`, optional
1209             Axes into which the colorbar will be drawn.
1210 
1211         ax : `~.axes.Axes` or iterable or `numpy.ndarray` of Axes, optional
1212             One or more parent axes from which space for a new colorbar axes
1213             will be stolen, if *cax* is None.  This has no effect if *cax* is
1214             set.
1215 
1216         use_gridspec : bool, optional
1217             If *cax* is ``None``, a new *cax* is created as an instance of
1218             Axes.  If *ax* is positioned with a subplotspec and *use_gridspec*
1219             is ``True``, then *cax* is also positioned with a subplotspec.
1220 
1221         Returns
1222         -------
1223         colorbar : `~matplotlib.colorbar.Colorbar`
1224 
1225         Other Parameters
1226         ----------------
1227         %(_make_axes_kw_doc)s
1228         %(_colormap_kw_doc)s
1229 
1230         Notes
1231         -----
1232         If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is
1233         included automatically.
1234 
1235         The *shrink* kwarg provides a simple way to scale the colorbar with
1236         respect to the axes. Note that if *cax* is specified, it determines the
1237         size of the colorbar, and *shrink* and *aspect* are ignored.
1238 
1239         For more precise control, you can manually specify the positions of the
1240         axes objects in which the mappable and the colorbar are drawn.  In this
1241         case, do not use any of the axes properties kwargs.
1242 
1243         It is known that some vector graphics viewers (svg and pdf) render
1244         white gaps between segments of the colorbar.  This is due to bugs in
1245         the viewers, not Matplotlib.  As a workaround, the colorbar can be
1246         rendered with overlapping segments::
1247 
1248             cbar = colorbar()
1249             cbar.solids.set_edgecolor("face")
1250             draw()
1251 
1252         However, this has negative consequences in other circumstances, e.g.
1253         with semi-transparent images (alpha < 1) and colorbar extensions;
1254         therefore, this workaround is not used by default (see issue #1188).
1255         """
1256 
1257         if ax is None:
1258             ax = getattr(mappable, "axes", None)
1259 
1260         if (self.get_layout_engine() is not None and
1261                 not self.get_layout_engine().colorbar_gridspec):
1262             use_gridspec = False
1263         if cax is None:
1264             if ax is None:
1265                 raise ValueError(
1266                     'Unable to determine Axes to steal space for Colorbar. '
1267                     'Either provide the *cax* argument to use as the Axes for '
1268                     'the Colorbar, provide the *ax* argument to steal space '
1269                     'from it, or add *mappable* to an Axes.')
1270             current_ax = self.gca()
1271             if (use_gridspec
1272                     and isinstance(ax, mpl.axes._base._AxesBase)
1273                     and ax.get_subplotspec()):
1274                 cax, kwargs = cbar.make_axes_gridspec(ax, **kwargs)
1275             else:
1276                 cax, kwargs = cbar.make_axes(ax, **kwargs)
1277             # make_axes calls add_{axes,subplot} which changes gca; undo that.
1278             self.sca(current_ax)
1279             cax.grid(visible=False, which='both', axis='both')
1280 
1281         NON_COLORBAR_KEYS = [  # remove kws that cannot be passed to Colorbar
1282             'fraction', 'pad', 'shrink', 'aspect', 'anchor', 'panchor']
1283         cb = cbar.Colorbar(cax, mappable, **{
1284             k: v for k, v in kwargs.items() if k not in NON_COLORBAR_KEYS})
1285         self.stale = True
1286         return cb
1287 
1288     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
1289                         wspace=None, hspace=None):
1290         """
1291         Adjust the subplot layout parameters.
1292 
1293         Unset parameters are left unmodified; initial values are given by
1294         :rc:`figure.subplot.[name]`.
1295 
1296         Parameters
1297         ----------
1298         left : float, optional
1299             The position of the left edge of the subplots,
1300             as a fraction of the figure width.
1301         right : float, optional
1302             The position of the right edge of the subplots,
1303             as a fraction of the figure width.
1304         bottom : float, optional
1305             The position of the bottom edge of the subplots,
1306             as a fraction of the figure height.
1307         top : float, optional
1308             The position of the top edge of the subplots,
1309             as a fraction of the figure height.
1310         wspace : float, optional
1311             The width of the padding between subplots,
1312             as a fraction of the average Axes width.
1313         hspace : float, optional
1314             The height of the padding between subplots,
1315             as a fraction of the average Axes height.
1316         """
1317         if (self.get_layout_engine() is not None and
1318                 not self.get_layout_engine().adjust_compatible):
1319             _api.warn_external(
1320                 "This figure was using a layout engine that is "
1321                 "incompatible with subplots_adjust and/or tight_layout; "
1322                 "not calling subplots_adjust.")
1323             return
1324         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
1325         for ax in self.axes:
1326             if ax.get_subplotspec() is not None:
1327                 ax._set_position(ax.get_subplotspec().get_position(self))
1328         self.stale = True
1329 
1330     def align_xlabels(self, axs=None):
1331         """
1332         Align the xlabels of subplots in the same subplot column if label
1333         alignment is being done automatically (i.e. the label position is
1334         not manually set).
1335 
1336         Alignment persists for draw events after this is called.
1337 
1338         If a label is on the bottom, it is aligned with labels on Axes that
1339         also have their label on the bottom and that have the same
1340         bottom-most subplot row.  If the label is on the top,
1341         it is aligned with labels on Axes with the same top-most row.
1342 
1343         Parameters
1344         ----------
1345         axs : list of `~matplotlib.axes.Axes`
1346             Optional list of (or `~numpy.ndarray`) `~matplotlib.axes.Axes`
1347             to align the xlabels.
1348             Default is to align all Axes on the figure.
1349 
1350         See Also
1351         --------
1352         matplotlib.figure.Figure.align_ylabels
1353         matplotlib.figure.Figure.align_labels
1354 
1355         Notes
1356         -----
1357         This assumes that ``axs`` are from the same `.GridSpec`, so that
1358         their `.SubplotSpec` positions correspond to figure positions.
1359 
1360         Examples
1361         --------
1362         Example with rotated xtick labels::
1363 
1364             fig, axs = plt.subplots(1, 2)
1365             for tick in axs[0].get_xticklabels():
1366                 tick.set_rotation(55)
1367             axs[0].set_xlabel('XLabel 0')
1368             axs[1].set_xlabel('XLabel 1')
1369             fig.align_xlabels()
1370         """
1371         if axs is None:
1372             axs = self.axes
1373         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1374         for ax in axs:
1375             _log.debug(' Working on: %s', ax.get_xlabel())
1376             rowspan = ax.get_subplotspec().rowspan
1377             pos = ax.xaxis.get_label_position()  # top or bottom
1378             # Search through other axes for label positions that are same as
1379             # this one and that share the appropriate row number.
1380             # Add to a grouper associated with each axes of siblings.
1381             # This list is inspected in `axis.draw` by
1382             # `axis._update_label_position`.
1383             for axc in axs:
1384                 if axc.xaxis.get_label_position() == pos:
1385                     rowspanc = axc.get_subplotspec().rowspan
1386                     if (pos == 'top' and rowspan.start == rowspanc.start or
1387                             pos == 'bottom' and rowspan.stop == rowspanc.stop):
1388                         # grouper for groups of xlabels to align
1389                         self._align_label_groups['x'].join(ax, axc)
1390 
1391     def align_ylabels(self, axs=None):
1392         """
1393         Align the ylabels of subplots in the same subplot column if label
1394         alignment is being done automatically (i.e. the label position is
1395         not manually set).
1396 
1397         Alignment persists for draw events after this is called.
1398 
1399         If a label is on the left, it is aligned with labels on Axes that
1400         also have their label on the left and that have the same
1401         left-most subplot column.  If the label is on the right,
1402         it is aligned with labels on Axes with the same right-most column.
1403 
1404         Parameters
1405         ----------
1406         axs : list of `~matplotlib.axes.Axes`
1407             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1408             to align the ylabels.
1409             Default is to align all Axes on the figure.
1410 
1411         See Also
1412         --------
1413         matplotlib.figure.Figure.align_xlabels
1414         matplotlib.figure.Figure.align_labels
1415 
1416         Notes
1417         -----
1418         This assumes that ``axs`` are from the same `.GridSpec`, so that
1419         their `.SubplotSpec` positions correspond to figure positions.
1420 
1421         Examples
1422         --------
1423         Example with large yticks labels::
1424 
1425             fig, axs = plt.subplots(2, 1)
1426             axs[0].plot(np.arange(0, 1000, 50))
1427             axs[0].set_ylabel('YLabel 0')
1428             axs[1].set_ylabel('YLabel 1')
1429             fig.align_ylabels()
1430         """
1431         if axs is None:
1432             axs = self.axes
1433         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1434         for ax in axs:
1435             _log.debug(' Working on: %s', ax.get_ylabel())
1436             colspan = ax.get_subplotspec().colspan
1437             pos = ax.yaxis.get_label_position()  # left or right
1438             # Search through other axes for label positions that are same as
1439             # this one and that share the appropriate column number.
1440             # Add to a list associated with each axes of siblings.
1441             # This list is inspected in `axis.draw` by
1442             # `axis._update_label_position`.
1443             for axc in axs:
1444                 if axc.yaxis.get_label_position() == pos:
1445                     colspanc = axc.get_subplotspec().colspan
1446                     if (pos == 'left' and colspan.start == colspanc.start or
1447                             pos == 'right' and colspan.stop == colspanc.stop):
1448                         # grouper for groups of ylabels to align
1449                         self._align_label_groups['y'].join(ax, axc)
1450 
1451     def align_labels(self, axs=None):
1452         """
1453         Align the xlabels and ylabels of subplots with the same subplots
1454         row or column (respectively) if label alignment is being
1455         done automatically (i.e. the label position is not manually set).
1456 
1457         Alignment persists for draw events after this is called.
1458 
1459         Parameters
1460         ----------
1461         axs : list of `~matplotlib.axes.Axes`
1462             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1463             to align the labels.
1464             Default is to align all Axes on the figure.
1465 
1466         See Also
1467         --------
1468         matplotlib.figure.Figure.align_xlabels
1469 
1470         matplotlib.figure.Figure.align_ylabels
1471         """
1472         self.align_xlabels(axs=axs)
1473         self.align_ylabels(axs=axs)
1474 
1475     def add_gridspec(self, nrows=1, ncols=1, **kwargs):
1476         """
1477         Return a `.GridSpec` that has this figure as a parent.  This allows
1478         complex layout of Axes in the figure.
1479 
1480         Parameters
1481         ----------
1482         nrows : int, default: 1
1483             Number of rows in grid.
1484 
1485         ncols : int, default: 1
1486             Number of columns in grid.
1487 
1488         Returns
1489         -------
1490         `.GridSpec`
1491 
1492         Other Parameters
1493         ----------------
1494         **kwargs
1495             Keyword arguments are passed to `.GridSpec`.
1496 
1497         See Also
1498         --------
1499         matplotlib.pyplot.subplots
1500 
1501         Examples
1502         --------
1503         Adding a subplot that spans two rows::
1504 
1505             fig = plt.figure()
1506             gs = fig.add_gridspec(2, 2)
1507             ax1 = fig.add_subplot(gs[0, 0])
1508             ax2 = fig.add_subplot(gs[1, 0])
1509             # spans two rows:
1510             ax3 = fig.add_subplot(gs[:, 1])
1511 
1512         """
1513 
1514         _ = kwargs.pop('figure', None)  # pop in case user has added this...
1515         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
1516         return gs
1517 
1518     def subfigures(self, nrows=1, ncols=1, squeeze=True,
1519                    wspace=None, hspace=None,
1520                    width_ratios=None, height_ratios=None,
1521                    **kwargs):
1522         """
1523         Add a set of subfigures to this figure or subfigure.
1524 
1525         A subfigure has the same artist methods as a figure, and is logically
1526         the same as a figure, but cannot print itself.
1527         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.
1528 
1529         Parameters
1530         ----------
1531         nrows, ncols : int, default: 1
1532             Number of rows/columns of the subfigure grid.
1533 
1534         squeeze : bool, default: True
1535             If True, extra dimensions are squeezed out from the returned
1536             array of subfigures.
1537 
1538         wspace, hspace : float, default: None
1539             The amount of width/height reserved for space between subfigures,
1540             expressed as a fraction of the average subfigure width/height.
1541             If not given, the values will be inferred from a figure or
1542             rcParams when necessary.
1543 
1544         width_ratios : array-like of length *ncols*, optional
1545             Defines the relative widths of the columns. Each column gets a
1546             relative width of ``width_ratios[i] / sum(width_ratios)``.
1547             If not given, all columns will have the same width.
1548 
1549         height_ratios : array-like of length *nrows*, optional
1550             Defines the relative heights of the rows. Each row gets a
1551             relative height of ``height_ratios[i] / sum(height_ratios)``.
1552             If not given, all rows will have the same height.
1553         """
1554         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,
1555                       wspace=wspace, hspace=hspace,
1556                       width_ratios=width_ratios,
1557                       height_ratios=height_ratios)
1558 
1559         sfarr = np.empty((nrows, ncols), dtype=object)
1560         for i in range(ncols):
1561             for j in range(nrows):
1562                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)
1563 
1564         if squeeze:
1565             # Discarding unneeded dimensions that equal 1.  If we only have one
1566             # subfigure, just return it instead of a 1-element array.
1567             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()
1568         else:
1569             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1570             return sfarr
1571 
1572     def add_subfigure(self, subplotspec, **kwargs):
1573         """
1574         Add a `.SubFigure` to the figure as part of a subplot arrangement.
1575 
1576         Parameters
1577         ----------
1578         subplotspec : `.gridspec.SubplotSpec`
1579             Defines the region in a parent gridspec where the subfigure will
1580             be placed.
1581 
1582         Returns
1583         -------
1584         `.SubFigure`
1585 
1586         Other Parameters
1587         ----------------
1588         **kwargs
1589             Are passed to the `.SubFigure` object.
1590 
1591         See Also
1592         --------
1593         .Figure.subfigures
1594         """
1595         sf = SubFigure(self, subplotspec, **kwargs)
1596         self.subfigs += [sf]
1597         return sf
1598 
1599     def sca(self, a):
1600         """Set the current Axes to be *a* and return *a*."""
1601         self._axstack.bubble(a)
1602         self._axobservers.process("_axes_change_event", self)
1603         return a
1604 
1605     def gca(self):
1606         """
1607         Get the current Axes.
1608 
1609         If there is currently no Axes on this Figure, a new one is created
1610         using `.Figure.add_subplot`.  (To test whether there is currently an
1611         Axes on a Figure, check whether ``figure.axes`` is empty.  To test
1612         whether there is currently a Figure on the pyplot figure stack, check
1613         whether `.pyplot.get_fignums()` is empty.)
1614         """
1615         ax = self._axstack.current()
1616         return ax if ax is not None else self.add_subplot()
1617 
1618     def _gci(self):
1619         # Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.
1620         """
1621         Get the current colorable artist.
1622 
1623         Specifically, returns the current `.ScalarMappable` instance (`.Image`
1624         created by `imshow` or `figimage`, `.Collection` created by `pcolor` or
1625         `scatter`, etc.), or *None* if no such instance has been defined.
1626 
1627         The current image is an attribute of the current Axes, or the nearest
1628         earlier Axes in the current figure that contains an image.
1629 
1630         Notes
1631         -----
1632         Historically, the only colorable artists were images; hence the name
1633         ``gci`` (get current image).
1634         """
1635         # Look first for an image in the current Axes.
1636         ax = self._axstack.current()
1637         if ax is None:
1638             return None
1639         im = ax._gci()
1640         if im is not None:
1641             return im
1642         # If there is no image in the current Axes, search for
1643         # one in a previously created Axes.  Whether this makes
1644         # sense is debatable, but it is the documented behavior.
1645         for ax in reversed(self.axes):
1646             im = ax._gci()
1647             if im is not None:
1648                 return im
1649         return None
1650 
1651     def _process_projection_requirements(
1652             self, *args, axes_class=None, polar=False, projection=None,
1653             **kwargs):
1654         """
1655         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1656 
1657             (axes_proj_class, proj_class_kwargs)
1658 
1659         which can be used for new Axes initialization/identification.
1660         """
1661         if axes_class is not None:
1662             if polar or projection is not None:
1663                 raise ValueError(
1664                     "Cannot combine 'axes_class' and 'projection' or 'polar'")
1665             projection_class = axes_class
1666         else:
1667 
1668             if polar:
1669                 if projection is not None and projection != 'polar':
1670                     raise ValueError(
1671                         f"polar={polar}, yet projection={projection!r}. "
1672                         "Only one of these arguments should be supplied."
1673                     )
1674                 projection = 'polar'
1675 
1676             if isinstance(projection, str) or projection is None:
1677                 projection_class = projections.get_projection_class(projection)
1678             elif hasattr(projection, '_as_mpl_axes'):
1679                 projection_class, extra_kwargs = projection._as_mpl_axes()
1680                 kwargs.update(**extra_kwargs)
1681             else:
1682                 raise TypeError(
1683                     f"projection must be a string, None or implement a "
1684                     f"_as_mpl_axes method, not {projection!r}")
1685         return projection_class, kwargs
1686 
1687     def get_default_bbox_extra_artists(self):
1688         bbox_artists = [artist for artist in self.get_children()
1689                         if (artist.get_visible() and artist.get_in_layout())]
1690         for ax in self.axes:
1691             if ax.get_visible():
1692                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
1693         return bbox_artists
1694 
1695     @_api.make_keyword_only("3.8", "bbox_extra_artists")
1696     def get_tightbbox(self, renderer=None, bbox_extra_artists=None):
1697         """
1698         Return a (tight) bounding box of the figure *in inches*.
1699 
1700         Note that `.FigureBase` differs from all other artists, which return
1701         their `.Bbox` in pixels.
1702 
1703         Artists that have ``artist.set_in_layout(False)`` are not included
1704         in the bbox.
1705 
1706         Parameters
1707         ----------
1708         renderer : `.RendererBase` subclass
1709             Renderer that will be used to draw the figures (i.e.
1710             ``fig.canvas.get_renderer()``)
1711 
1712         bbox_extra_artists : list of `.Artist` or ``None``
1713             List of artists to include in the tight bounding box.  If
1714             ``None`` (default), then all artist children of each Axes are
1715             included in the tight bounding box.
1716 
1717         Returns
1718         -------
1719         `.BboxBase`
1720             containing the bounding box (in figure inches).
1721         """
1722 
1723         if renderer is None:
1724             renderer = self.figure._get_renderer()
1725 
1726         bb = []
1727         if bbox_extra_artists is None:
1728             artists = self.get_default_bbox_extra_artists()
1729         else:
1730             artists = bbox_extra_artists
1731 
1732         for a in artists:
1733             bbox = a.get_tightbbox(renderer)
1734             if bbox is not None:
1735                 bb.append(bbox)
1736 
1737         for ax in self.axes:
1738             if ax.get_visible():
1739                 # some axes don't take the bbox_extra_artists kwarg so we
1740                 # need this conditional....
1741                 try:
1742                     bbox = ax.get_tightbbox(
1743                         renderer, bbox_extra_artists=bbox_extra_artists)
1744                 except TypeError:
1745                     bbox = ax.get_tightbbox(renderer)
1746                 bb.append(bbox)
1747         bb = [b for b in bb
1748               if (np.isfinite(b.width) and np.isfinite(b.height)
1749                   and (b.width != 0 or b.height != 0))]
1750 
1751         isfigure = hasattr(self, 'bbox_inches')
1752         if len(bb) == 0:
1753             if isfigure:
1754                 return self.bbox_inches
1755             else:
1756                 # subfigures do not have bbox_inches, but do have a bbox
1757                 bb = [self.bbox]
1758 
1759         _bbox = Bbox.union(bb)
1760 
1761         if isfigure:
1762             # transform from pixels to inches...
1763             _bbox = TransformedBbox(_bbox, self.dpi_scale_trans.inverted())
1764 
1765         return _bbox
1766 
1767     @staticmethod
1768     def _norm_per_subplot_kw(per_subplot_kw):
1769         expanded = {}
1770         for k, v in per_subplot_kw.items():
1771             if isinstance(k, tuple):
1772                 for sub_key in k:
1773                     if sub_key in expanded:
1774                         raise ValueError(
1775                             f'The key {sub_key!r} appears multiple times.'
1776                             )
1777                     expanded[sub_key] = v
1778             else:
1779                 if k in expanded:
1780                     raise ValueError(
1781                         f'The key {k!r} appears multiple times.'
1782                     )
1783                 expanded[k] = v
1784         return expanded
1785 
1786     @staticmethod
1787     def _normalize_grid_string(layout):
1788         if '\n' not in layout:
1789             # single-line string
1790             return [list(ln) for ln in layout.split(';')]
1791         else:
1792             # multi-line string
1793             layout = inspect.cleandoc(layout)
1794             return [list(ln) for ln in layout.strip('\n').split('\n')]
1795 
1796     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1797                        width_ratios=None, height_ratios=None,
1798                        empty_sentinel='.',
1799                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1800         """
1801         Build a layout of Axes based on ASCII art or nested lists.
1802 
1803         This is a helper function to build complex GridSpec layouts visually.
1804 
1805         See :ref:`mosaic`
1806         for an example and full API documentation
1807 
1808         Parameters
1809         ----------
1810         mosaic : list of list of {hashable or nested} or str
1811 
1812             A visual layout of how you want your Axes to be arranged
1813             labeled as strings.  For example ::
1814 
1815                x = [['A panel', 'A panel', 'edge'],
1816                     ['C panel', '.',       'edge']]
1817 
1818             produces 4 Axes:
1819 
1820             - 'A panel' which is 1 row high and spans the first two columns
1821             - 'edge' which is 2 rows high and is on the right edge
1822             - 'C panel' which in 1 row and 1 column wide in the bottom left
1823             - a blank space 1 row and 1 column wide in the bottom center
1824 
1825             Any of the entries in the layout can be a list of lists
1826             of the same form to create nested layouts.
1827 
1828             If input is a str, then it can either be a multi-line string of
1829             the form ::
1830 
1831               '''
1832               AAE
1833               C.E
1834               '''
1835 
1836             where each character is a column and each line is a row. Or it
1837             can be a single-line string where rows are separated by ``;``::
1838 
1839               'AB;CC'
1840 
1841             The string notation allows only single character Axes labels and
1842             does not support nesting but is very terse.
1843 
1844             The Axes identifiers may be `str` or a non-iterable hashable
1845             object (e.g. `tuple` s may not be used).
1846 
1847         sharex, sharey : bool, default: False
1848             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1849             among all subplots.  In that case, tick label visibility and axis
1850             units behave as for `subplots`.  If False, each subplot's x- or
1851             y-axis will be independent.
1852 
1853         width_ratios : array-like of length *ncols*, optional
1854             Defines the relative widths of the columns. Each column gets a
1855             relative width of ``width_ratios[i] / sum(width_ratios)``.
1856             If not given, all columns will have the same width.  Equivalent
1857             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1858             layouts, this argument applies only to the outer layout.
1859 
1860         height_ratios : array-like of length *nrows*, optional
1861             Defines the relative heights of the rows. Each row gets a
1862             relative height of ``height_ratios[i] / sum(height_ratios)``.
1863             If not given, all rows will have the same height. Equivalent
1864             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1865             layouts, this argument applies only to the outer layout.
1866 
1867         subplot_kw : dict, optional
1868             Dictionary with keywords passed to the `.Figure.add_subplot` call
1869             used to create each subplot.  These values may be overridden by
1870             values in *per_subplot_kw*.
1871 
1872         per_subplot_kw : dict, optional
1873             A dictionary mapping the Axes identifiers or tuples of identifiers
1874             to a dictionary of keyword arguments to be passed to the
1875             `.Figure.add_subplot` call used to create each subplot.  The values
1876             in these dictionaries have precedence over the values in
1877             *subplot_kw*.
1878 
1879             If *mosaic* is a string, and thus all keys are single characters,
1880             it is possible to use a single string instead of a tuple as keys;
1881             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1882 
1883             .. versionadded:: 3.7
1884 
1885         gridspec_kw : dict, optional
1886             Dictionary with keywords passed to the `.GridSpec` constructor used
1887             to create the grid the subplots are placed on. In the case of
1888             nested layouts, this argument applies only to the outer layout.
1889             For more complex layouts, users should use `.Figure.subfigures`
1890             to create the nesting.
1891 
1892         empty_sentinel : object, optional
1893             Entry in the layout to mean "leave this space empty".  Defaults
1894             to ``'.'``. Note, if *layout* is a string, it is processed via
1895             `inspect.cleandoc` to remove leading white space, which may
1896             interfere with using white-space as the empty sentinel.
1897 
1898         Returns
1899         -------
1900         dict[label, Axes]
1901            A dictionary mapping the labels to the Axes objects.  The order of
1902            the axes is left-to-right and top-to-bottom of their position in the
1903            total layout.
1904 
1905         """
1906         subplot_kw = subplot_kw or {}
1907         gridspec_kw = dict(gridspec_kw or {})
1908         per_subplot_kw = per_subplot_kw or {}
1909 
1910         if height_ratios is not None:
1911             if 'height_ratios' in gridspec_kw:
1912                 raise ValueError("'height_ratios' must not be defined both as "
1913                                  "parameter and as key in 'gridspec_kw'")
1914             gridspec_kw['height_ratios'] = height_ratios
1915         if width_ratios is not None:
1916             if 'width_ratios' in gridspec_kw:
1917                 raise ValueError("'width_ratios' must not be defined both as "
1918                                  "parameter and as key in 'gridspec_kw'")
1919             gridspec_kw['width_ratios'] = width_ratios
1920 
1921         # special-case string input
1922         if isinstance(mosaic, str):
1923             mosaic = self._normalize_grid_string(mosaic)
1924             per_subplot_kw = {
1925                 tuple(k): v for k, v in per_subplot_kw.items()
1926             }
1927 
1928         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1929 
1930         # Only accept strict bools to allow a possible future API expansion.
1931         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1932 
1933         def _make_array(inp):
1934             """
1935             Convert input into 2D array
1936 
1937             We need to have this internal function rather than
1938             ``np.asarray(..., dtype=object)`` so that a list of lists
1939             of lists does not get converted to an array of dimension > 2.
1940 
1941             Returns
1942             -------
1943             2D object array
1944             """
1945             r0, *rest = inp
1946             if isinstance(r0, str):
1947                 raise ValueError('List mosaic specification must be 2D')
1948             for j, r in enumerate(rest, start=1):
1949                 if isinstance(r, str):
1950                     raise ValueError('List mosaic specification must be 2D')
1951                 if len(r0) != len(r):
1952                     raise ValueError(
1953                         "All of the rows must be the same length, however "
1954                         f"the first row ({r0!r}) has length {len(r0)} "
1955                         f"and row {j} ({r!r}) has length {len(r)}."
1956                     )
1957             out = np.zeros((len(inp), len(r0)), dtype=object)
1958             for j, r in enumerate(inp):
1959                 for k, v in enumerate(r):
1960                     out[j, k] = v
1961             return out
1962 
1963         def _identify_keys_and_nested(mosaic):
1964             """
1965             Given a 2D object array, identify unique IDs and nested mosaics
1966 
1967             Parameters
1968             ----------
1969             mosaic : 2D object array
1970 
1971             Returns
1972             -------
1973             unique_ids : tuple
1974                 The unique non-sub mosaic entries in this mosaic
1975             nested : dict[tuple[int, int], 2D object array]
1976             """
1977             # make sure we preserve the user supplied order
1978             unique_ids = cbook._OrderedSet()
1979             nested = {}
1980             for j, row in enumerate(mosaic):
1981                 for k, v in enumerate(row):
1982                     if v == empty_sentinel:
1983                         continue
1984                     elif not cbook.is_scalar_or_string(v):
1985                         nested[(j, k)] = _make_array(v)
1986                     else:
1987                         unique_ids.add(v)
1988 
1989             return tuple(unique_ids), nested
1990 
1991         def _do_layout(gs, mosaic, unique_ids, nested):
1992             """
1993             Recursively do the mosaic.
1994 
1995             Parameters
1996             ----------
1997             gs : GridSpec
1998             mosaic : 2D object array
1999                 The input converted to a 2D array for this level.
2000             unique_ids : tuple
2001                 The identified scalar labels at this level of nesting.
2002             nested : dict[tuple[int, int]], 2D object array
2003                 The identified nested mosaics, if any.
2004 
2005             Returns
2006             -------
2007             dict[label, Axes]
2008                 A flat dict of all of the Axes created.
2009             """
2010             output = dict()
2011 
2012             # we need to merge together the Axes at this level and the axes
2013             # in the (recursively) nested sub-mosaics so that we can add
2014             # them to the figure in the "natural" order if you were to
2015             # ravel in c-order all of the Axes that will be created
2016             #
2017             # This will stash the upper left index of each object (axes or
2018             # nested mosaic) at this level
2019             this_level = dict()
2020 
2021             # go through the unique keys,
2022             for name in unique_ids:
2023                 # sort out where each axes starts/ends
2024                 indx = np.argwhere(mosaic == name)
2025                 start_row, start_col = np.min(indx, axis=0)
2026                 end_row, end_col = np.max(indx, axis=0) + 1
2027                 # and construct the slice object
2028                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2029                 # some light error checking
2030                 if (mosaic[slc] != name).any():
2031                     raise ValueError(
2032                         f"While trying to layout\n{mosaic!r}\n"
2033                         f"we found that the label {name!r} specifies a "
2034                         "non-rectangular or non-contiguous area.")
2035                 # and stash this slice for later
2036                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2037 
2038             # do the same thing for the nested mosaics (simpler because these
2039             # can not be spans yet!)
2040             for (j, k), nested_mosaic in nested.items():
2041                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2042 
2043             # now go through the things in this level and add them
2044             # in order left-to-right top-to-bottom
2045             for key in sorted(this_level):
2046                 name, arg, method = this_level[key]
2047                 # we are doing some hokey function dispatch here based
2048                 # on the 'method' string stashed above to sort out if this
2049                 # element is an Axes or a nested mosaic.
2050                 if method == 'axes':
2051                     slc = arg
2052                     # add a single axes
2053                     if name in output:
2054                         raise ValueError(f"There are duplicate keys {name} "
2055                                          f"in the layout\n{mosaic!r}")
2056                     ax = self.add_subplot(
2057                         gs[slc], **{
2058                             'label': str(name),
2059                             **subplot_kw,
2060                             **per_subplot_kw.get(name, {})
2061                         }
2062                     )
2063                     output[name] = ax
2064                 elif method == 'nested':
2065                     nested_mosaic = arg
2066                     j, k = key
2067                     # recursively add the nested mosaic
2068                     rows, cols = nested_mosaic.shape
2069                     nested_output = _do_layout(
2070                         gs[j, k].subgridspec(rows, cols),
2071                         nested_mosaic,
2072                         *_identify_keys_and_nested(nested_mosaic)
2073                     )
2074                     overlap = set(output) & set(nested_output)
2075                     if overlap:
2076                         raise ValueError(
2077                             f"There are duplicate keys {overlap} "
2078                             f"between the outer layout\n{mosaic!r}\n"
2079                             f"and the nested layout\n{nested_mosaic}"
2080                         )
2081                     output.update(nested_output)
2082                 else:
2083                     raise RuntimeError("This should never happen")
2084             return output
2085 
2086         mosaic = _make_array(mosaic)
2087         rows, cols = mosaic.shape
2088         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2089         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2090         ax0 = next(iter(ret.values()))
2091         for ax in ret.values():
2092             if sharex:
2093                 ax.sharex(ax0)
2094                 ax._label_outer_xaxis(check_patch=True)
2095             if sharey:
2096                 ax.sharey(ax0)
2097                 ax._label_outer_yaxis(check_patch=True)
2098         if extra := set(per_subplot_kw) - set(ret):
2099             raise ValueError(
2100                 f"The keys {extra} are in *per_subplot_kw* "
2101                 "but not in the mosaic."
2102             )
2103         return ret
2104 
2105     def _set_artist_props(self, a):
2106         if a != self:
2107             a.set_figure(self)
2108         a.stale_callback = _stale_figure_callback
2109         a.set_transform(self.transSubfigure)
2110 
2111 
2112 @_docstring.interpd
2113 class SubFigure(FigureBase):
2114     """
2115     Logical figure that can be placed inside a figure.
2116 
2117     Typically instantiated using `.Figure.add_subfigure` or
2118     `.SubFigure.add_subfigure`, or `.SubFigure.subfigures`.  A subfigure has
2119     the same methods as a figure except for those particularly tied to the size
2120     or dpi of the figure, and is confined to a prescribed region of the figure.
2121     For example the following puts two subfigures side-by-side::
2122 
2123         fig = plt.figure()
2124         sfigs = fig.subfigures(1, 2)
2125         axsL = sfigs[0].subplots(1, 2)
2126         axsR = sfigs[1].subplots(2, 1)
2127 
2128     See :doc:`/gallery/subplots_axes_and_figures/subfigures`
2129     """
2130     callbacks = _api.deprecated(
2131             "3.6", alternative=("the 'resize_event' signal in "
2132                                 "Figure.canvas.callbacks")
2133             )(property(lambda self: self._fig_callbacks))
2134 
2135     def __init__(self, parent, subplotspec, *,
2136                  facecolor=None,
2137                  edgecolor=None,
2138                  linewidth=0.0,
2139                  frameon=None,
2140                  **kwargs):
2141         """
2142         Parameters
2143         ----------
2144         parent : `.Figure` or `.SubFigure`
2145             Figure or subfigure that contains the SubFigure.  SubFigures
2146             can be nested.
2147 
2148         subplotspec : `.gridspec.SubplotSpec`
2149             Defines the region in a parent gridspec where the subfigure will
2150             be placed.
2151 
2152         facecolor : default: ``"none"``
2153             The figure patch face color; transparent by default.
2154 
2155         edgecolor : default: :rc:`figure.edgecolor`
2156             The figure patch edge color.
2157 
2158         linewidth : float
2159             The linewidth of the frame (i.e. the edge linewidth of the figure
2160             patch).
2161 
2162         frameon : bool, default: :rc:`figure.frameon`
2163             If ``False``, suppress drawing the figure background patch.
2164 
2165         Other Parameters
2166         ----------------
2167         **kwargs : `.SubFigure` properties, optional
2168 
2169             %(SubFigure:kwdoc)s
2170         """
2171         super().__init__(**kwargs)
2172         if facecolor is None:
2173             facecolor = "none"
2174         if edgecolor is None:
2175             edgecolor = mpl.rcParams['figure.edgecolor']
2176         if frameon is None:
2177             frameon = mpl.rcParams['figure.frameon']
2178 
2179         self._subplotspec = subplotspec
2180         self._parent = parent
2181         self.figure = parent.figure
2182         self._fig_callbacks = parent._fig_callbacks
2183 
2184         # subfigures use the parent axstack
2185         self._axstack = parent._axstack
2186         self.subplotpars = parent.subplotpars
2187         self.dpi_scale_trans = parent.dpi_scale_trans
2188         self._axobservers = parent._axobservers
2189         self.canvas = parent.canvas
2190         self.transFigure = parent.transFigure
2191         self.bbox_relative = None
2192         self._redo_transform_rel_fig()
2193         self.figbbox = self._parent.figbbox
2194         self.bbox = TransformedBbox(self.bbox_relative,
2195                                     self._parent.transSubfigure)
2196         self.transSubfigure = BboxTransformTo(self.bbox)
2197 
2198         self.patch = Rectangle(
2199             xy=(0, 0), width=1, height=1, visible=frameon,
2200             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2201             # Don't let the figure patch influence bbox calculation.
2202             in_layout=False, transform=self.transSubfigure)
2203         self._set_artist_props(self.patch)
2204         self.patch.set_antialiased(False)
2205 
2206     @property
2207     def dpi(self):
2208         return self._parent.dpi
2209 
2210     @dpi.setter
2211     def dpi(self, value):
2212         self._parent.dpi = value
2213 
2214     def get_dpi(self):
2215         """
2216         Return the resolution of the parent figure in dots-per-inch as a float.
2217         """
2218         return self._parent.dpi
2219 
2220     def set_dpi(self, val):
2221         """
2222         Set the resolution of parent figure in dots-per-inch.
2223 
2224         Parameters
2225         ----------
2226         val : float
2227         """
2228         self._parent.dpi = val
2229         self.stale = True
2230 
2231     def _get_renderer(self):
2232         return self._parent._get_renderer()
2233 
2234     def _redo_transform_rel_fig(self, bbox=None):
2235         """
2236         Make the transSubfigure bbox relative to Figure transform.
2237 
2238         Parameters
2239         ----------
2240         bbox : bbox or None
2241             If not None, then the bbox is used for relative bounding box.
2242             Otherwise, it is calculated from the subplotspec.
2243         """
2244         if bbox is not None:
2245             self.bbox_relative.p0 = bbox.p0
2246             self.bbox_relative.p1 = bbox.p1
2247             return
2248         # need to figure out *where* this subplotspec is.
2249         gs = self._subplotspec.get_gridspec()
2250         wr = np.asarray(gs.get_width_ratios())
2251         hr = np.asarray(gs.get_height_ratios())
2252         dx = wr[self._subplotspec.colspan].sum() / wr.sum()
2253         dy = hr[self._subplotspec.rowspan].sum() / hr.sum()
2254         x0 = wr[:self._subplotspec.colspan.start].sum() / wr.sum()
2255         y0 = 1 - hr[:self._subplotspec.rowspan.stop].sum() / hr.sum()
2256         if self.bbox_relative is None:
2257             self.bbox_relative = Bbox.from_bounds(x0, y0, dx, dy)
2258         else:
2259             self.bbox_relative.p0 = (x0, y0)
2260             self.bbox_relative.p1 = (x0 + dx, y0 + dy)
2261 
2262     def get_constrained_layout(self):
2263         """
2264         Return whether constrained layout is being used.
2265 
2266         See :ref:`constrainedlayout_guide`.
2267         """
2268         return self._parent.get_constrained_layout()
2269 
2270     def get_constrained_layout_pads(self, relative=False):
2271         """
2272         Get padding for ``constrained_layout``.
2273 
2274         Returns a list of ``w_pad, h_pad`` in inches and
2275         ``wspace`` and ``hspace`` as fractions of the subplot.
2276 
2277         See :ref:`constrainedlayout_guide`.
2278 
2279         Parameters
2280         ----------
2281         relative : bool
2282             If `True`, then convert from inches to figure relative.
2283         """
2284         return self._parent.get_constrained_layout_pads(relative=relative)
2285 
2286     def get_layout_engine(self):
2287         return self._parent.get_layout_engine()
2288 
2289     @property
2290     def axes(self):
2291         """
2292         List of Axes in the SubFigure.  You can access and modify the Axes
2293         in the SubFigure through this list.
2294 
2295         Modifying this list has no effect. Instead, use `~.SubFigure.add_axes`,
2296         `~.SubFigure.add_subplot` or `~.SubFigure.delaxes` to add or remove an
2297         Axes.
2298 
2299         Note: The `.SubFigure.axes` property and `~.SubFigure.get_axes` method
2300         are equivalent.
2301         """
2302         return self._localaxes[:]
2303 
2304     get_axes = axes.fget
2305 
2306     def draw(self, renderer):
2307         # docstring inherited
2308 
2309         # draw the figure bounding box, perhaps none for white figure
2310         if not self.get_visible():
2311             return
2312 
2313         artists = self._get_draw_artists(renderer)
2314 
2315         try:
2316             renderer.open_group('subfigure', gid=self.get_gid())
2317             self.patch.draw(renderer)
2318             mimage._draw_list_compositing_images(
2319                 renderer, self, artists, self.figure.suppressComposite)
2320             for sfig in self.subfigs:
2321                 sfig.draw(renderer)
2322             renderer.close_group('subfigure')
2323 
2324         finally:
2325             self.stale = False
2326 
2327 
2328 @_docstring.interpd
2329 class Figure(FigureBase):
2330     """
2331     The top level container for all the plot elements.
2332 
2333     Attributes
2334     ----------
2335     patch
2336         The `.Rectangle` instance representing the figure background patch.
2337 
2338     suppressComposite
2339         For multiple images, the figure will make composite images
2340         depending on the renderer option_image_nocomposite function.  If
2341         *suppressComposite* is a boolean, this will override the renderer.
2342     """
2343     # Remove the self._fig_callbacks properties on figure and subfigure
2344     # after the deprecation expires.
2345     callbacks = _api.deprecated(
2346         "3.6", alternative=("the 'resize_event' signal in "
2347                             "Figure.canvas.callbacks")
2348         )(property(lambda self: self._fig_callbacks))
2349 
2350     def __str__(self):
2351         return "Figure(%gx%g)" % tuple(self.bbox.size)
2352 
2353     def __repr__(self):
2354         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2355             clsname=self.__class__.__name__,
2356             h=self.bbox.size[0], w=self.bbox.size[1],
2357             naxes=len(self.axes),
2358         )
2359 
2360     def __init__(self,
2361                  figsize=None,
2362                  dpi=None,
2363                  *,
2364                  facecolor=None,
2365                  edgecolor=None,
2366                  linewidth=0.0,
2367                  frameon=None,
2368                  subplotpars=None,  # rc figure.subplot.*
2369                  tight_layout=None,  # rc figure.autolayout
2370                  constrained_layout=None,  # rc figure.constrained_layout.use
2371                  layout=None,
2372                  **kwargs
2373                  ):
2374         """
2375         Parameters
2376         ----------
2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2378             Figure dimension ``(width, height)`` in inches.
2379 
2380         dpi : float, default: :rc:`figure.dpi`
2381             Dots per inch.
2382 
2383         facecolor : default: :rc:`figure.facecolor`
2384             The figure patch facecolor.
2385 
2386         edgecolor : default: :rc:`figure.edgecolor`
2387             The figure patch edge color.
2388 
2389         linewidth : float
2390             The linewidth of the frame (i.e. the edge linewidth of the figure
2391             patch).
2392 
2393         frameon : bool, default: :rc:`figure.frameon`
2394             If ``False``, suppress drawing the figure background patch.
2395 
2396         subplotpars : `SubplotParams`
2397             Subplot parameters. If not given, the default subplot
2398             parameters :rc:`figure.subplot.*` are used.
2399 
2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2402 
2403             .. admonition:: Discouraged
2404 
2405                 The use of this parameter is discouraged. Please use
2406                 ``layout='tight'`` instead for the common case of
2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2408 
2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2410             This is equal to ``layout='constrained'``.
2411 
2412             .. admonition:: Discouraged
2413 
2414                 The use of this parameter is discouraged. Please use
2415                 ``layout='constrained'`` instead.
2416 
2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2418 None}, default: None
2419             The layout mechanism for positioning of plot elements to avoid
2420             overlapping Axes decorations (labels, ticks, etc). Note that
2421             layout managers can have significant performance penalties.
2422 
2423             - 'constrained': The constrained layout solver adjusts axes sizes
2424               to avoid overlapping axes decorations.  Can handle complex plot
2425               layouts and colorbars, and is thus recommended.
2426 
2427               See :ref:`constrainedlayout_guide`
2428               for examples.
2429 
2430             - 'compressed': uses the same algorithm as 'constrained', but
2431               removes extra space between fixed-aspect-ratio Axes.  Best for
2432               simple grids of axes.
2433 
2434             - 'tight': Use the tight layout mechanism. This is a relatively
2435               simple algorithm that adjusts the subplot parameters so that
2436               decorations do not overlap. See `.Figure.set_tight_layout` for
2437               further details.
2438 
2439             - 'none': Do not use a layout engine.
2440 
2441             - A `.LayoutEngine` instance. Builtin layout classes are
2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2443               accessible by 'constrained' and 'tight'.  Passing an instance
2444               allows third parties to provide their own layout engine.
2445 
2446             If not given, fall back to using the parameters *tight_layout* and
2447             *constrained_layout*, including their config defaults
2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2449 
2450         Other Parameters
2451         ----------------
2452         **kwargs : `.Figure` properties, optional
2453 
2454             %(Figure:kwdoc)s
2455         """
2456         super().__init__(**kwargs)
2457         self._layout_engine = None
2458 
2459         if layout is not None:
2460             if (tight_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2463                     "be used together. Please use 'layout' only.")
2464             if (constrained_layout is not None):
2465                 _api.warn_external(
2466                     "The Figure parameters 'layout' and 'constrained_layout' "
2467                     "cannot be used together. Please use 'layout' only.")
2468             self.set_layout_engine(layout=layout)
2469         elif tight_layout is not None:
2470             if constrained_layout is not None:
2471                 _api.warn_external(
2472                     "The Figure parameters 'tight_layout' and "
2473                     "'constrained_layout' cannot be used together. Please use "
2474                     "'layout' parameter")
2475             self.set_layout_engine(layout='tight')
2476             if isinstance(tight_layout, dict):
2477                 self.get_layout_engine().set(**tight_layout)
2478         elif constrained_layout is not None:
2479             if isinstance(constrained_layout, dict):
2480                 self.set_layout_engine(layout='constrained')
2481                 self.get_layout_engine().set(**constrained_layout)
2482             elif constrained_layout:
2483                 self.set_layout_engine(layout='constrained')
2484 
2485         else:
2486             # everything is None, so use default:
2487             self.set_layout_engine(layout=layout)
2488 
2489         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2490         # Callbacks traditionally associated with the canvas (and exposed with
2491         # a proxy property), but that actually need to be on the figure for
2492         # pickling.
2493         self._canvas_callbacks = cbook.CallbackRegistry(
2494             signals=FigureCanvasBase.events)
2495         connect = self._canvas_callbacks._connect_picklable
2496         self._mouse_key_ids = [
2497             connect('key_press_event', backend_bases._key_handler),
2498             connect('key_release_event', backend_bases._key_handler),
2499             connect('key_release_event', backend_bases._key_handler),
2500             connect('button_press_event', backend_bases._mouse_handler),
2501             connect('button_release_event', backend_bases._mouse_handler),
2502             connect('scroll_event', backend_bases._mouse_handler),
2503             connect('motion_notify_event', backend_bases._mouse_handler),
2504         ]
2505         self._button_pick_id = connect('button_press_event', self.pick)
2506         self._scroll_pick_id = connect('scroll_event', self.pick)
2507 
2508         if figsize is None:
2509             figsize = mpl.rcParams['figure.figsize']
2510         if dpi is None:
2511             dpi = mpl.rcParams['figure.dpi']
2512         if facecolor is None:
2513             facecolor = mpl.rcParams['figure.facecolor']
2514         if edgecolor is None:
2515             edgecolor = mpl.rcParams['figure.edgecolor']
2516         if frameon is None:
2517             frameon = mpl.rcParams['figure.frameon']
2518 
2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2520             raise ValueError('figure size must be positive finite not '
2521                              f'{figsize}')
2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2523 
2524         self.dpi_scale_trans = Affine2D().scale(dpi)
2525         # do not use property as it will trigger
2526         self._dpi = dpi
2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2528         self.figbbox = self.bbox
2529         self.transFigure = BboxTransformTo(self.bbox)
2530         self.transSubfigure = self.transFigure
2531 
2532         self.patch = Rectangle(
2533             xy=(0, 0), width=1, height=1, visible=frameon,
2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2535             # Don't let the figure patch influence bbox calculation.
2536             in_layout=False)
2537         self._set_artist_props(self.patch)
2538         self.patch.set_antialiased(False)
2539 
2540         FigureCanvasBase(self)  # Set self.canvas.
2541 
2542         if subplotpars is None:
2543             subplotpars = SubplotParams()
2544 
2545         self.subplotpars = subplotpars
2546 
2547         self._axstack = _AxesStack()  # track all figure axes and current axes
2548         self.clear()
2549 
2550     def pick(self, mouseevent):
2551         if not self.canvas.widgetlock.locked():
2552             super().pick(mouseevent)
2553 
2554     def _check_layout_engines_compat(self, old, new):
2555         """
2556         Helper for set_layout engine
2557 
2558         If the figure has used the old engine and added a colorbar then the
2559         value of colorbar_gridspec must be the same on the new engine.
2560         """
2561         if old is None or new is None:
2562             return True
2563         if old.colorbar_gridspec == new.colorbar_gridspec:
2564             return True
2565         # colorbar layout different, so check if any colorbars are on the
2566         # figure...
2567         for ax in self.axes:
2568             if hasattr(ax, '_colorbar'):
2569                 # colorbars list themselves as a colorbar.
2570                 return False
2571         return True
2572 
2573     def set_layout_engine(self, layout=None, **kwargs):
2574         """
2575         Set the layout engine for this figure.
2576 
2577         Parameters
2578         ----------
2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2580 `LayoutEngine` or None
2581 
2582             - 'constrained' will use `~.ConstrainedLayoutEngine`
2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2584               a correction that attempts to make a good layout for fixed-aspect
2585               ratio Axes.
2586             - 'tight' uses `~.TightLayoutEngine`
2587             - 'none' removes layout engine.
2588 
2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2590             (which if `True` behaves as if 'tight' was passed) and
2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2592             'constrained' was passed).  If both are `True`,
2593             :rc:`figure.autolayout` takes priority.
2594 
2595             Users and libraries can define their own layout engines and pass
2596             the instance directly as well.
2597 
2598         kwargs: dict
2599             The keyword arguments are passed to the layout engine to set things
2600             like padding and margin sizes.  Only used if *layout* is a string.
2601 
2602         """
2603         if layout is None:
2604             if mpl.rcParams['figure.autolayout']:
2605                 layout = 'tight'
2606             elif mpl.rcParams['figure.constrained_layout.use']:
2607                 layout = 'constrained'
2608             else:
2609                 self._layout_engine = None
2610                 return
2611         if layout == 'tight':
2612             new_layout_engine = TightLayoutEngine(**kwargs)
2613         elif layout == 'constrained':
2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2615         elif layout == 'compressed':
2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2617                                                         **kwargs)
2618         elif layout == 'none':
2619             if self._layout_engine is not None:
2620                 new_layout_engine = PlaceHolderLayoutEngine(
2621                     self._layout_engine.adjust_compatible,
2622                     self._layout_engine.colorbar_gridspec
2623                 )
2624             else:
2625                 new_layout_engine = None
2626         elif isinstance(layout, LayoutEngine):
2627             new_layout_engine = layout
2628         else:
2629             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2630 
2631         if self._check_layout_engines_compat(self._layout_engine,
2632                                              new_layout_engine):
2633             self._layout_engine = new_layout_engine
2634         else:
2635             raise RuntimeError('Colorbar layout of new layout engine not '
2636                                'compatible with old engine, and a colorbar '
2637                                'has been created.  Engine not changed.')
2638 
2639     def get_layout_engine(self):
2640         return self._layout_engine
2641 
2642     # TODO: I'd like to dynamically add the _repr_html_ method
2643     # to the figure in the right context, but then IPython doesn't
2644     # use it, for some reason.
2645 
2646     def _repr_html_(self):
2647         # We can't use "isinstance" here, because then we'd end up importing
2648         # webagg unconditionally.
2649         if 'WebAgg' in type(self.canvas).__name__:
2650             from matplotlib.backends import backend_webagg
2651             return backend_webagg.ipython_inline_display(self)
2652 
2653     def show(self, warn=True):
2654         """
2655         If using a GUI backend with pyplot, display the figure window.
2656 
2657         If the figure was not created using `~.pyplot.figure`, it will lack
2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2659         AttributeError.
2660 
2661         .. warning::
2662 
2663             This does not manage an GUI event loop. Consequently, the figure
2664             may only be shown briefly or not shown at all if you or your
2665             environment are not managing an event loop.
2666 
2667             Use cases for `.Figure.show` include running this from a GUI
2668             application (where there is persistently an event loop running) or
2669             from a shell, like IPython, that install an input hook to allow the
2670             interactive shell to accept input while the figure is also being
2671             shown and interactive.  Some, but not all, GUI toolkits will
2672             register an input hook on import.  See :ref:`cp_integration` for
2673             more details.
2674 
2675             If you're in a shell without input hook integration or executing a
2676             python script, you should use `matplotlib.pyplot.show` with
2677             ``block=True`` instead, which takes care of starting and running
2678             the event loop for you.
2679 
2680         Parameters
2681         ----------
2682         warn : bool, default: True
2683             If ``True`` and we are not running headless (i.e. on Linux with an
2684             unset DISPLAY), issue warning when called on a non-GUI backend.
2685 
2686         """
2687         if self.canvas.manager is None:
2688             raise AttributeError(
2689                 "Figure.show works only for figures managed by pyplot, "
2690                 "normally created by pyplot.figure()")
2691         try:
2692             self.canvas.manager.show()
2693         except NonGuiException as exc:
2694             if warn:
2695                 _api.warn_external(str(exc))
2696 
2697     @property
2698     def axes(self):
2699         """
2700         List of Axes in the Figure. You can access and modify the Axes in the
2701         Figure through this list.
2702 
2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2705 
2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2707         equivalent.
2708         """
2709         return self._axstack.as_list()
2710 
2711     get_axes = axes.fget
2712 
2713     def _get_renderer(self):
2714         if hasattr(self.canvas, 'get_renderer'):
2715             return self.canvas.get_renderer()
2716         else:
2717             return _get_renderer(self)
2718 
2719     def _get_dpi(self):
2720         return self._dpi
2721 
2722     def _set_dpi(self, dpi, forward=True):
2723         """
2724         Parameters
2725         ----------
2726         dpi : float
2727 
2728         forward : bool
2729             Passed on to `~.Figure.set_size_inches`
2730         """
2731         if dpi == self._dpi:
2732             # We don't want to cause undue events in backends.
2733             return
2734         self._dpi = dpi
2735         self.dpi_scale_trans.clear().scale(dpi)
2736         w, h = self.get_size_inches()
2737         self.set_size_inches(w, h, forward=forward)
2738         self._fig_callbacks.process('dpi_changed', self)
2739 
2740     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2741 
2742     def get_tight_layout(self):
2743         """Return whether `.tight_layout` is called when drawing."""
2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2745 
2746     @_api.deprecated("3.6", alternative="set_layout_engine",
2747                      pending=True)
2748     def set_tight_layout(self, tight):
2749         """
2750         [*Discouraged*] Set whether and how `.tight_layout` is called when
2751         drawing.
2752 
2753         .. admonition:: Discouraged
2754 
2755             This method is discouraged in favor of `~.set_layout_engine`.
2756 
2757         Parameters
2758         ----------
2759         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2760             If a bool, sets whether to call `.tight_layout` upon drawing.
2761             If ``None``, use :rc:`figure.autolayout` instead.
2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2763             default paddings.
2764         """
2765         if tight is None:
2766             tight = mpl.rcParams['figure.autolayout']
2767         _tight = 'tight' if bool(tight) else 'none'
2768         _tight_parameters = tight if isinstance(tight, dict) else {}
2769         self.set_layout_engine(_tight, **_tight_parameters)
2770         self.stale = True
2771 
2772     def get_constrained_layout(self):
2773         """
2774         Return whether constrained layout is being used.
2775 
2776         See :ref:`constrainedlayout_guide`.
2777         """
2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2779 
2780     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2781                      pending=True)
2782     def set_constrained_layout(self, constrained):
2783         """
2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2785         drawing.
2786 
2787         If None, :rc:`figure.constrained_layout.use` value will be used.
2788 
2789         When providing a dict containing the keys ``w_pad``, ``h_pad``
2790         the default ``constrained_layout`` paddings will be
2791         overridden.  These pads are in inches and default to 3.0/72.0.
2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2793 
2794         .. admonition:: Discouraged
2795 
2796             This method is discouraged in favor of `~.set_layout_engine`.
2797 
2798         Parameters
2799         ----------
2800         constrained : bool or dict or None
2801         """
2802         if constrained is None:
2803             constrained = mpl.rcParams['figure.constrained_layout.use']
2804         _constrained = 'constrained' if bool(constrained) else 'none'
2805         _parameters = constrained if isinstance(constrained, dict) else {}
2806         self.set_layout_engine(_constrained, **_parameters)
2807         self.stale = True
2808 
2809     @_api.deprecated(
2810          "3.6", alternative="figure.get_layout_engine().set()",
2811          pending=True)
2812     def set_constrained_layout_pads(self, **kwargs):
2813         """
2814         Set padding for ``constrained_layout``.
2815 
2816         Tip: The parameters can be passed from a dictionary by using
2817         ``fig.set_constrained_layout(**pad_dict)``.
2818 
2819         See :ref:`constrainedlayout_guide`.
2820 
2821         Parameters
2822         ----------
2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2824             Width padding in inches.  This is the pad around Axes
2825             and is meant to make sure there is enough room for fonts to
2826             look good.  Defaults to 3 pts = 0.04167 inches
2827 
2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2829             Height padding in inches. Defaults to 3 pts.
2830 
2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2832             Width padding between subplots, expressed as a fraction of the
2833             subplot width.  The total padding ends up being w_pad + wspace.
2834 
2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2836             Height padding between subplots, expressed as a fraction of the
2837             subplot width. The total padding ends up being h_pad + hspace.
2838 
2839         """
2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2841             self.get_layout_engine().set(**kwargs)
2842 
2843     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2844                      pending=True)
2845     def get_constrained_layout_pads(self, relative=False):
2846         """
2847         Get padding for ``constrained_layout``.
2848 
2849         Returns a list of ``w_pad, h_pad`` in inches and
2850         ``wspace`` and ``hspace`` as fractions of the subplot.
2851         All values are None if ``constrained_layout`` is not used.
2852 
2853         See :ref:`constrainedlayout_guide`.
2854 
2855         Parameters
2856         ----------
2857         relative : bool
2858             If `True`, then convert from inches to figure relative.
2859         """
2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2861             return None, None, None, None
2862         info = self.get_layout_engine().get_info()
2863         w_pad = info['w_pad']
2864         h_pad = info['h_pad']
2865         wspace = info['wspace']
2866         hspace = info['hspace']
2867 
2868         if relative and (w_pad is not None or h_pad is not None):
2869             renderer = self._get_renderer()
2870             dpi = renderer.dpi
2871             w_pad = w_pad * dpi / renderer.width
2872             h_pad = h_pad * dpi / renderer.height
2873 
2874         return w_pad, h_pad, wspace, hspace
2875 
2876     def set_canvas(self, canvas):
2877         """
2878         Set the canvas that contains the figure
2879 
2880         Parameters
2881         ----------
2882         canvas : FigureCanvas
2883         """
2884         self.canvas = canvas
2885 
2886     @_docstring.interpd
2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2889         """
2890         Add a non-resampled image to the figure.
2891 
2892         The image is attached to the lower or upper left corner depending on
2893         *origin*.
2894 
2895         Parameters
2896         ----------
2897         X
2898             The image data. This is an array of one of the following shapes:
2899 
2900             - (M, N): an image with scalar data.  Color-mapping is controlled
2901               by *cmap*, *norm*, *vmin*, and *vmax*.
2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2904               i.e. including transparency.
2905 
2906         xo, yo : int
2907             The *x*/*y* image offset in pixels.
2908 
2909         alpha : None or float
2910             The alpha blending value.
2911 
2912         %(cmap_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(norm_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         %(vmin_vmax_doc)s
2921 
2922             This parameter is ignored if *X* is RGB(A).
2923 
2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2925             Indicates where the [0, 0] index of the array is in the upper left
2926             or lower left corner of the axes.
2927 
2928         resize : bool
2929             If *True*, resize the figure to match the given image size.
2930 
2931         Returns
2932         -------
2933         `matplotlib.image.FigureImage`
2934 
2935         Other Parameters
2936         ----------------
2937         **kwargs
2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2939 
2940         Notes
2941         -----
2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2943         which will be resampled to fit the current Axes.  If you want
2944         a resampled image to fill the entire figure, you can define an
2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2946 
2947         Examples
2948         --------
2949         ::
2950 
2951             f = plt.figure()
2952             nx = int(f.get_figwidth() * f.dpi)
2953             ny = int(f.get_figheight() * f.dpi)
2954             data = np.random.random((ny, nx))
2955             f.figimage(data)
2956             plt.show()
2957         """
2958         if resize:
2959             dpi = self.get_dpi()
2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2961             self.set_size_inches(figsize, forward=True)
2962 
2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2964                                 offsetx=xo, offsety=yo,
2965                                 origin=origin, **kwargs)
2966         im.stale_callback = _stale_figure_callback
2967 
2968         im.set_array(X)
2969         im.set_alpha(alpha)
2970         if norm is None:
2971             im.set_clim(vmin, vmax)
2972         self.images.append(im)
2973         im._remove_method = self.images.remove
2974         self.stale = True
2975         return im
2976 
2977     def set_size_inches(self, w, h=None, forward=True):
2978         """
2979         Set the figure size in inches.
2980 
2981         Call signatures::
2982 
2983              fig.set_size_inches(w, h)  # OR
2984              fig.set_size_inches((w, h))
2985 
2986         Parameters
2987         ----------
2988         w : (float, float) or float
2989             Width and height in inches (if height not specified as a separate
2990             argument) or width.
2991         h : float
2992             Height in inches.
2993         forward : bool, default: True
2994             If ``True``, the canvas size is automatically updated, e.g.,
2995             you can resize the figure window from the shell.
2996 
2997         See Also
2998         --------
2999         matplotlib.figure.Figure.get_size_inches
3000         matplotlib.figure.Figure.set_figwidth
3001         matplotlib.figure.Figure.set_figheight
3002 
3003         Notes
3004         -----
3005         To transform from pixels to inches divide by `Figure.dpi`.
3006         """
3007         if h is None:  # Got called with a single pair as argument.
3008             w, h = w
3009         size = np.array([w, h])
3010         if not np.isfinite(size).all() or (size < 0).any():
3011             raise ValueError(f'figure size must be positive finite not {size}')
3012         self.bbox_inches.p1 = size
3013         if forward:
3014             manager = self.canvas.manager
3015             if manager is not None:
3016                 manager.resize(*(size * self.dpi).astype(int))
3017         self.stale = True
3018 
3019     def get_size_inches(self):
3020         """
3021         Return the current size of the figure in inches.
3022 
3023         Returns
3024         -------
3025         ndarray
3026            The size (width, height) of the figure in inches.
3027 
3028         See Also
3029         --------
3030         matplotlib.figure.Figure.set_size_inches
3031         matplotlib.figure.Figure.get_figwidth
3032         matplotlib.figure.Figure.get_figheight
3033 
3034         Notes
3035         -----
3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3037         """
3038         return np.array(self.bbox_inches.p1)
3039 
3040     def get_figwidth(self):
3041         """Return the figure width in inches."""
3042         return self.bbox_inches.width
3043 
3044     def get_figheight(self):
3045         """Return the figure height in inches."""
3046         return self.bbox_inches.height
3047 
3048     def get_dpi(self):
3049         """Return the resolution in dots per inch as a float."""
3050         return self.dpi
3051 
3052     def set_dpi(self, val):
3053         """
3054         Set the resolution of the figure in dots-per-inch.
3055 
3056         Parameters
3057         ----------
3058         val : float
3059         """
3060         self.dpi = val
3061         self.stale = True
3062 
3063     def set_figwidth(self, val, forward=True):
3064         """
3065         Set the width of the figure in inches.
3066 
3067         Parameters
3068         ----------
3069         val : float
3070         forward : bool
3071             See `set_size_inches`.
3072 
3073         See Also
3074         --------
3075         matplotlib.figure.Figure.set_figheight
3076         matplotlib.figure.Figure.set_size_inches
3077         """
3078         self.set_size_inches(val, self.get_figheight(), forward=forward)
3079 
3080     def set_figheight(self, val, forward=True):
3081         """
3082         Set the height of the figure in inches.
3083 
3084         Parameters
3085         ----------
3086         val : float
3087         forward : bool
3088             See `set_size_inches`.
3089 
3090         See Also
3091         --------
3092         matplotlib.figure.Figure.set_figwidth
3093         matplotlib.figure.Figure.set_size_inches
3094         """
3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3096 
3097     def clear(self, keep_observers=False):
3098         # docstring inherited
3099         super().clear(keep_observers=keep_observers)
3100         # FigureBase.clear does not clear toolbars, as
3101         # only Figure can have toolbars
3102         toolbar = self.canvas.toolbar
3103         if toolbar is not None:
3104             toolbar.update()
3105 
3106     @_finalize_rasterization
3107     @allow_rasterization
3108     def draw(self, renderer):
3109         # docstring inherited
3110 
3111         # draw the figure bounding box, perhaps none for white figure
3112         if not self.get_visible():
3113             return
3114 
3115         artists = self._get_draw_artists(renderer)
3116         try:
3117             renderer.open_group('figure', gid=self.get_gid())
3118             if self.axes and self.get_layout_engine() is not None:
3119                 try:
3120                     self.get_layout_engine().execute(self)
3121                 except ValueError:
3122                     pass
3123                     # ValueError can occur when resizing a window.
3124 
3125             self.patch.draw(renderer)
3126             mimage._draw_list_compositing_images(
3127                 renderer, self, artists, self.suppressComposite)
3128 
3129             for sfig in self.subfigs:
3130                 sfig.draw(renderer)
3131 
3132             renderer.close_group('figure')
3133         finally:
3134             self.stale = False
3135 
3136         DrawEvent("draw_event", self.canvas, renderer)._process()
3137 
3138     def draw_without_rendering(self):
3139         """
3140         Draw the figure with no output.  Useful to get the final size of
3141         artists that require a draw before their size is known (e.g. text).
3142         """
3143         renderer = _get_renderer(self)
3144         with renderer._draw_disabled():
3145             self.draw(renderer)
3146 
3147     def draw_artist(self, a):
3148         """
3149         Draw `.Artist` *a* only.
3150         """
3151         a.draw(self.canvas.get_renderer())
3152 
3153     def __getstate__(self):
3154         state = super().__getstate__()
3155 
3156         # The canvas cannot currently be pickled, but this has the benefit
3157         # of meaning that a figure can be detached from one canvas, and
3158         # re-attached to another.
3159         state.pop("canvas")
3160 
3161         # discard any changes to the dpi due to pixel ratio changes
3162         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3163 
3164         # add version information to the state
3165         state['__mpl_version__'] = mpl.__version__
3166 
3167         # check whether the figure manager (if any) is registered with pyplot
3168         from matplotlib import _pylab_helpers
3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3170             state['_restore_to_pylab'] = True
3171         return state
3172 
3173     def __setstate__(self, state):
3174         version = state.pop('__mpl_version__')
3175         restore_to_pylab = state.pop('_restore_to_pylab', False)
3176 
3177         if version != mpl.__version__:
3178             _api.warn_external(
3179                 f"This figure was saved with matplotlib version {version} and "
3180                 f"is unlikely to function correctly.")
3181 
3182         self.__dict__ = state
3183 
3184         # re-initialise some of the unstored state information
3185         FigureCanvasBase(self)  # Set self.canvas.
3186 
3187         if restore_to_pylab:
3188             # lazy import to avoid circularity
3189             import matplotlib.pyplot as plt
3190             import matplotlib._pylab_helpers as pylab_helpers
3191             allnums = plt.get_fignums()
3192             num = max(allnums) + 1 if allnums else 1
3193             backend = plt._get_backend_mod()
3194             mgr = backend.new_figure_manager_given_figure(num, self)
3195             pylab_helpers.Gcf._set_new_active_manager(mgr)
3196             plt.draw_if_interactive()
3197 
3198         self.stale = True
3199 
3200     def add_axobserver(self, func):
3201         """Whenever the Axes state change, ``func(self)`` will be called."""
3202         # Connect a wrapper lambda and not func itself, to avoid it being
3203         # weakref-collected.
3204         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3205 
3206     def savefig(self, fname, *, transparent=None, **kwargs):
3207         """
3208         Save the current figure.
3209 
3210         Call signature::
3211 
3212           savefig(fname, *, dpi='figure', format=None, metadata=None,
3213                   bbox_inches=None, pad_inches=0.1,
3214                   facecolor='auto', edgecolor='auto',
3215                   backend=None, **kwargs
3216                  )
3217 
3218         The available output formats depend on the backend being used.
3219 
3220         Parameters
3221         ----------
3222         fname : str or path-like or binary file-like
3223             A path, or a Python file-like object, or
3224             possibly some backend-dependent object such as
3225             `matplotlib.backends.backend_pdf.PdfPages`.
3226 
3227             If *format* is set, it determines the output format, and the file
3228             is saved as *fname*.  Note that *fname* is used verbatim, and there
3229             is no attempt to make the extension, if any, of *fname* match
3230             *format*, and no extension is appended.
3231 
3232             If *format* is not set, then the format is inferred from the
3233             extension of *fname*, if there is one.  If *format* is not
3234             set and *fname* has no extension, then the file is saved with
3235             :rc:`savefig.format` and the appropriate extension is appended to
3236             *fname*.
3237 
3238         Other Parameters
3239         ----------------
3240         dpi : float or 'figure', default: :rc:`savefig.dpi`
3241             The resolution in dots per inch.  If 'figure', use the figure's
3242             dpi value.
3243 
3244         format : str
3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3246             this is unset is documented under *fname*.
3247 
3248         metadata : dict, optional
3249             Key/value pairs to store in the image metadata. The supported keys
3250             and defaults depend on the image format and backend:
3251 
3252             - 'png' with Agg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasAgg.print_png`.
3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3255               `~.backend_pdf.PdfPages`.
3256             - 'svg' with svg backend: See the parameter ``metadata`` of
3257               `~.FigureCanvasSVG.print_svg`.
3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3259 
3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
3261             embedding metadata.
3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include
3263             embedding EXIF metadata in the future.
3264 
3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3266             Bounding box in inches: only the given portion of the figure is
3267             saved.  If 'tight', try to figure out the tight bbox of the figure.
3268 
3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3270             Amount of padding in inches around the figure when bbox_inches is
3271             'tight'. If 'layout' use the padding from the constrained or
3272             compressed layout engine; ignored if one of those engines is not in
3273             use.
3274 
3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3276             The facecolor of the figure.  If 'auto', use the current figure
3277             facecolor.
3278 
3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3280             The edgecolor of the figure.  If 'auto', use the current figure
3281             edgecolor.
3282 
3283         backend : str, optional
3284             Use a non-default backend to render the file, e.g. to render a
3285             png file with the "cairo" backend rather than the default "agg",
3286             or a pdf file with the "pgf" backend rather than the default
3287             "pdf".  Note that the default backend is normally sufficient.  See
3288             :ref:`the-builtin-backends` for a list of valid backends for each
3289             file format.  Custom backends can be referenced as "module://...".
3290 
3291         orientation : {'landscape', 'portrait'}
3292             Currently only supported by the postscript backend.
3293 
3294         papertype : str
3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3296             'a10', 'b0' through 'b10'. Only supported for postscript
3297             output.
3298 
3299         transparent : bool
3300             If *True*, the Axes patches will all be transparent; the
3301             Figure patch will also be transparent unless *facecolor*
3302             and/or *edgecolor* are specified via kwargs.
3303 
3304             If *False* has no effect and the color of the Axes and
3305             Figure patches are unchanged (unless the Figure patch
3306             is specified via the *facecolor* and/or *edgecolor* keyword
3307             arguments in which case those colors are used).
3308 
3309             The transparency of these patches will be restored to their
3310             original values upon exit of this function.
3311 
3312             This is useful, for example, for displaying
3313             a plot on top of a colored background on a web page.
3314 
3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3316             A list of extra artists that will be considered when the
3317             tight bbox is calculated.
3318 
3319         pil_kwargs : dict, optional
3320             Additional keyword arguments that are passed to
3321             `PIL.Image.Image.save` when saving the figure.
3322 
3323         """
3324 
3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3326         if transparent is None:
3327             transparent = mpl.rcParams['savefig.transparent']
3328 
3329         with ExitStack() as stack:
3330             if transparent:
3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3332                     exit_stack.enter_context(
3333                         subfig.patch._cm_set(
3334                             facecolor="none", edgecolor="none"))
3335                     for ax in subfig.axes:
3336                         exit_stack.enter_context(
3337                             ax.patch._cm_set(
3338                                 facecolor="none", edgecolor="none"))
3339                     for sub_subfig in subfig.subfigs:
3340                         _recursively_make_subfig_transparent(
3341                             exit_stack, sub_subfig)
3342 
3343                 def _recursively_make_axes_transparent(exit_stack, ax):
3344                     exit_stack.enter_context(
3345                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3346                     for child_ax in ax.child_axes:
3347                         exit_stack.enter_context(
3348                             child_ax.patch._cm_set(
3349                                 facecolor="none", edgecolor="none"))
3350                     for child_childax in ax.child_axes:
3351                         _recursively_make_axes_transparent(
3352                             exit_stack, child_childax)
3353 
3354                 kwargs.setdefault('facecolor', 'none')
3355                 kwargs.setdefault('edgecolor', 'none')
3356                 # set subfigure to appear transparent in printed image
3357                 for subfig in self.subfigs:
3358                     _recursively_make_subfig_transparent(stack, subfig)
3359                 # set axes to be transparent
3360                 for ax in self.axes:
3361                     _recursively_make_axes_transparent(stack, ax)
3362             self.canvas.print_figure(fname, **kwargs)
3363 
3364     def ginput(self, n=1, timeout=30, show_clicks=True,
3365                mouse_add=MouseButton.LEFT,
3366                mouse_pop=MouseButton.RIGHT,
3367                mouse_stop=MouseButton.MIDDLE):
3368         """
3369         Blocking call to interact with a figure.
3370 
3371         Wait until the user clicks *n* times on the figure, and return the
3372         coordinates of each click in a list.
3373 
3374         There are three possible interactions:
3375 
3376         - Add a point.
3377         - Remove the most recently added point.
3378         - Stop the interaction and return the points added so far.
3379 
3380         The actions are assigned to mouse buttons via the arguments
3381         *mouse_add*, *mouse_pop* and *mouse_stop*.
3382 
3383         Parameters
3384         ----------
3385         n : int, default: 1
3386             Number of mouse clicks to accumulate. If negative, accumulate
3387             clicks until the input is terminated manually.
3388         timeout : float, default: 30 seconds
3389             Number of seconds to wait before timing out. If zero or negative
3390             will never time out.
3391         show_clicks : bool, default: True
3392             If True, show a red cross at the location of each click.
3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3394             Mouse button used to add points.
3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3396             Mouse button used to remove the most recently added point.
3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3398             Mouse button used to stop input.
3399 
3400         Returns
3401         -------
3402         list of tuples
3403             A list of the clicked (x, y) coordinates.
3404 
3405         Notes
3406         -----
3407         The keyboard can also be used to select points in case your mouse
3408         does not have one or more of the buttons.  The delete and backspace
3409         keys act like right-clicking (i.e., remove last point), the enter key
3410         terminates input and any other key (not already used by the window
3411         manager) selects a point.
3412         """
3413         clicks = []
3414         marks = []
3415 
3416         def handler(event):
3417             is_button = event.name == "button_press_event"
3418             is_key = event.name == "key_press_event"
3419             # Quit (even if not in infinite mode; this is consistent with
3420             # MATLAB and sometimes quite useful, but will require the user to
3421             # test how many points were actually returned before using data).
3422             if (is_button and event.button == mouse_stop
3423                     or is_key and event.key in ["escape", "enter"]):
3424                 self.canvas.stop_event_loop()
3425             # Pop last click.
3426             elif (is_button and event.button == mouse_pop
3427                   or is_key and event.key in ["backspace", "delete"]):
3428                 if clicks:
3429                     clicks.pop()
3430                     if show_clicks:
3431                         marks.pop().remove()
3432                         self.canvas.draw()
3433             # Add new click.
3434             elif (is_button and event.button == mouse_add
3435                   # On macOS/gtk, some keys return None.
3436                   or is_key and event.key is not None):
3437                 if event.inaxes:
3438                     clicks.append((event.xdata, event.ydata))
3439                     _log.info("input %i: %f, %f",
3440                               len(clicks), event.xdata, event.ydata)
3441                     if show_clicks:
3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3443                                                 marker="+", color="r")
3444                         event.inaxes.add_line(line)
3445                         marks.append(line)
3446                         self.canvas.draw()
3447             if len(clicks) == n and n > 0:
3448                 self.canvas.stop_event_loop()
3449 
3450         _blocking_input.blocking_input_loop(
3451             self, ["button_press_event", "key_press_event"], timeout, handler)
3452 
3453         # Cleanup.
3454         for mark in marks:
3455             mark.remove()
3456         self.canvas.draw()
3457 
3458         return clicks
3459 
3460     def waitforbuttonpress(self, timeout=-1):
3461         """
3462         Blocking call to interact with the figure.
3463 
3464         Wait for user input and return True if a key was pressed, False if a
3465         mouse button was pressed and None if no input was given within
3466         *timeout* seconds.  Negative values deactivate *timeout*.
3467         """
3468         event = None
3469 
3470         def handler(ev):
3471             nonlocal event
3472             event = ev
3473             self.canvas.stop_event_loop()
3474 
3475         _blocking_input.blocking_input_loop(
3476             self, ["button_press_event", "key_press_event"], timeout, handler)
3477 
3478         return None if event is None else event.name == "key_press_event"
3479 
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)
3519 
3520 
3521 def figaspect(arg):
3522     """
3523     Calculate the width and height for a figure with a specified aspect ratio.
3524 
3525     While the height is taken from :rc:`figure.figsize`, the width is
3526     adjusted to match the desired aspect ratio. Additionally, it is ensured
3527     that the width is in the range [4., 16.] and the height is in the range
3528     [2., 16.]. If necessary, the default height is adjusted to ensure this.
3529 
3530     Parameters
3531     ----------
3532     arg : float or 2D array
3533         If a float, this defines the aspect ratio (i.e. the ratio height /
3534         width).
3535         In case of an array the aspect ratio is number of rows / number of
3536         columns, so that the array could be fitted in the figure undistorted.
3537 
3538     Returns
3539     -------
3540     width, height : float
3541         The figure size in inches.
3542 
3543     Notes
3544     -----
3545     If you want to create an Axes within the figure, that still preserves the
3546     aspect ratio, be sure to create it with equal width and height. See
3547     examples below.
3548 
3549     Thanks to Fernando Perez for this function.
3550 
3551     Examples
3552     --------
3553     Make a figure twice as tall as it is wide::
3554 
3555         w, h = figaspect(2.)
3556         fig = Figure(figsize=(w, h))
3557         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
3558         ax.imshow(A, **kwargs)
3559 
3560     Make a figure with the proper aspect for an array::
3561 
3562         A = rand(5, 3)
3563         w, h = figaspect(A)
3564         fig = Figure(figsize=(w, h))
3565         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
3566         ax.imshow(A, **kwargs)
3567     """
3568 
3569     isarray = hasattr(arg, 'shape') and not np.isscalar(arg)
3570 
3571     # min/max sizes to respect when autoscaling.  If John likes the idea, they
3572     # could become rc parameters, for now they're hardwired.
3573     figsize_min = np.array((4.0, 2.0))  # min length for width/height
3574     figsize_max = np.array((16.0, 16.0))  # max length for width/height
3575 
3576     # Extract the aspect ratio of the array
3577     if isarray:
3578         nr, nc = arg.shape[:2]
3579         arr_ratio = nr / nc
3580     else:
3581         arr_ratio = arg
3582 
3583     # Height of user figure defaults
3584     fig_height = mpl.rcParams['figure.figsize'][1]
3585 
3586     # New size for the figure, keeping the aspect ratio of the caller
3587     newsize = np.array((fig_height / arr_ratio, fig_height))
3588 
3589     # Sanity checks, don't drop either dimension below figsize_min
3590     newsize /= min(1.0, *(newsize / figsize_min))
3591 
3592     # Avoid humongous windows as well
3593     newsize /= max(1.0, *(newsize / figsize_max))
3594 
3595     # Finally, if we have a really funky aspect ratio, break it but respect
3596     # the min/max dimensions (we don't want figures 10 feet tall!)
3597     newsize = np.clip(newsize, figsize_min, figsize_max)
3598     return newsize

</code><intended_behavior>Any method or function within this file that reads or modifies the `figure.autolayout` setting needs to be reviewed to ensure it correctly handles situations where both `autolayout` and `tight_layout` are used. If `tight_layout` is called, the code should respect the explicit user request to adjust layout parameters manually, which may involve temporarily disabling `autolayout` or merging the settings with `tight_layout` kwargs. The balance between automatic and manual layout adjustments needs to be clear to users, either through documentation or runtime messages.</intended_behavior>]
2025-10-15 07:40:38.948 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:40:38.948 | INFO     | Search-only: skipping patch selection
2025-10-15 07:40:39.052 | INFO     | Task matplotlib__matplotlib-25624 completed successfully.
2025-10-15 07:40:39.053 | INFO     | No patch generated. You can try running ACR again.
