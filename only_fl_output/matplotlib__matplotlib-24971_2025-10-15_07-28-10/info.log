2025-10-15 07:28:11.056 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:28:15.208 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=598, output_tokens=12, cost=0.006340
2025-10-15 07:28:26.246 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=778, output_tokens=390, cost=0.019480
2025-10-15 07:28:27.532 | INFO     | registered non reproducing test 0
2025-10-15 07:28:44.066 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1553, output_tokens=642, cost=0.034790
2025-10-15 07:28:45.685 | INFO     | registered non reproducing test 1
2025-10-15 07:28:59.827 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1843, output_tokens=599, cost=0.036400
2025-10-15 07:29:01.441 | INFO     | registered non reproducing test 2
2025-10-15 07:29:01.441 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 07:29:01.444 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:29:11.502 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=901, output_tokens=319, cost=0.018580
2025-10-15 07:29:11.509 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:29:13.983 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=673, output_tokens=52, cost=0.008290
2025-10-15 07:29:13.984 | DEBUG    | Extracted a valid json.
2025-10-15 07:29:13.984 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"savefig\")",
        "search_code(\"rcParams['figure.constrained_layout.use'] =\")",
        "search_method(\"subplot_mosaic\")"
    ],
    "bug_locations": []
}
2025-10-15 07:29:14.132 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:29:14.132 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:29:30.067 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10009, output_tokens=601, cost=0.118120
2025-10-15 07:29:30.079 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:29:40.257 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10826, output_tokens=357, cost=0.118970
2025-10-15 07:29:40.265 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:29:50.245 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=289, cost=0.015780
2025-10-15 07:29:50.246 | DEBUG    | Extracted a valid json.
2025-10-15 07:29:50.247 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "savefig",
            "intended_behavior": "The method should ensure that when a figure is saved with 'bbox_inches=\"tight\"' and using a layout set through 'subplot_mosaic' with 'layout='compressed'', the layout settings are preserved accurately across multiple save operations. This entails maintaining the figure's layout and compression settings in the figure's state, such that repeated saves do not alter the layout appearance. This requires potentially caching or reaffirming the layout configuration just before the save operation if 'bbox_inches=\"tight\"' is used, ensuring the layout compression is applied equally across all save operations."
        },
        {
            "file": "lib/matplotlib/figure.py",
            "method": "subplot_mosaic",
            "intended_behavior": "The 'subplot_mosaic' method implementation must ensure that once a compressed layout is set up for a figure, these settings are embedded into the figure's metadata or state in a manner that they are referred to or reapplied in subsequent operations affecting the figure's layout, including saving with 'bbox_inches=\"tight\"'. This means enhancing how layout settings are stored or referenced within a figure's lifecycle, ensuring consistency between the visualization on-screen and the saved files."
        }
    ]
}
2025-10-15 07:29:50.260 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>savefig</method>
<code>
3202     def savefig(self, fname, *, transparent=None, **kwargs):
3203         """
3204         Save the current figure.
3205 
3206         Call signature::
3207 
3208           savefig(fname, *, dpi='figure', format=None, metadata=None,
3209                   bbox_inches=None, pad_inches=0.1,
3210                   facecolor='auto', edgecolor='auto',
3211                   backend=None, **kwargs
3212                  )
3213 
3214         The available output formats depend on the backend being used.
3215 
3216         Parameters
3217         ----------
3218         fname : str or path-like or binary file-like
3219             A path, or a Python file-like object, or
3220             possibly some backend-dependent object such as
3221             `matplotlib.backends.backend_pdf.PdfPages`.
3222 
3223             If *format* is set, it determines the output format, and the file
3224             is saved as *fname*.  Note that *fname* is used verbatim, and there
3225             is no attempt to make the extension, if any, of *fname* match
3226             *format*, and no extension is appended.
3227 
3228             If *format* is not set, then the format is inferred from the
3229             extension of *fname*, if there is one.  If *format* is not
3230             set and *fname* has no extension, then the file is saved with
3231             :rc:`savefig.format` and the appropriate extension is appended to
3232             *fname*.
3233 
3234         Other Parameters
3235         ----------------
3236         dpi : float or 'figure', default: :rc:`savefig.dpi`
3237             The resolution in dots per inch.  If 'figure', use the figure's
3238             dpi value.
3239 
3240         format : str
3241             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3242             this is unset is documented under *fname*.
3243 
3244         metadata : dict, optional
3245             Key/value pairs to store in the image metadata. The supported keys
3246             and defaults depend on the image format and backend:
3247 
3248             - 'png' with Agg backend: See the parameter ``metadata`` of
3249               `~.FigureCanvasAgg.print_png`.
3250             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3251               `~.backend_pdf.PdfPages`.
3252             - 'svg' with svg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasSVG.print_svg`.
3254             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3255 
3256         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3257             Bounding box in inches: only the given portion of the figure is
3258             saved.  If 'tight', try to figure out the tight bbox of the figure.
3259 
3260         pad_inches : float, default: :rc:`savefig.pad_inches`
3261             Amount of padding around the figure when bbox_inches is 'tight'.
3262 
3263         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3264             The facecolor of the figure.  If 'auto', use the current figure
3265             facecolor.
3266 
3267         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3268             The edgecolor of the figure.  If 'auto', use the current figure
3269             edgecolor.
3270 
3271         backend : str, optional
3272             Use a non-default backend to render the file, e.g. to render a
3273             png file with the "cairo" backend rather than the default "agg",
3274             or a pdf file with the "pgf" backend rather than the default
3275             "pdf".  Note that the default backend is normally sufficient.  See
3276             :ref:`the-builtin-backends` for a list of valid backends for each
3277             file format.  Custom backends can be referenced as "module://...".
3278 
3279         orientation : {'landscape', 'portrait'}
3280             Currently only supported by the postscript backend.
3281 
3282         papertype : str
3283             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3284             'a10', 'b0' through 'b10'. Only supported for postscript
3285             output.
3286 
3287         transparent : bool
3288             If *True*, the Axes patches will all be transparent; the
3289             Figure patch will also be transparent unless *facecolor*
3290             and/or *edgecolor* are specified via kwargs.
3291 
3292             If *False* has no effect and the color of the Axes and
3293             Figure patches are unchanged (unless the Figure patch
3294             is specified via the *facecolor* and/or *edgecolor* keyword
3295             arguments in which case those colors are used).
3296 
3297             The transparency of these patches will be restored to their
3298             original values upon exit of this function.
3299 
3300             This is useful, for example, for displaying
3301             a plot on top of a colored background on a web page.
3302 
3303         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3304             A list of extra artists that will be considered when the
3305             tight bbox is calculated.
3306 
3307         pil_kwargs : dict, optional
3308             Additional keyword arguments that are passed to
3309             `PIL.Image.Image.save` when saving the figure.
3310 
3311         """
3312 
3313         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3314         if transparent is None:
3315             transparent = mpl.rcParams['savefig.transparent']
3316 
3317         with ExitStack() as stack:
3318             if transparent:
3319                 kwargs.setdefault('facecolor', 'none')
3320                 kwargs.setdefault('edgecolor', 'none')
3321                 for ax in self.axes:
3322                     stack.enter_context(
3323                         ax.patch._cm_set(facecolor='none', edgecolor='none'))
3324 
3325             self.canvas.print_figure(fname, **kwargs)

</code><intended_behavior>The method should ensure that when a figure is saved with 'bbox_inches="tight"' and using a layout set through 'subplot_mosaic' with 'layout='compressed'', the layout settings are preserved accurately across multiple save operations. This entails maintaining the figure's layout and compression settings in the figure's state, such that repeated saves do not alter the layout appearance. This requires potentially caching or reaffirming the layout configuration just before the save operation if 'bbox_inches="tight"' is used, ensuring the layout compression is applied equally across all save operations.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2326 class Figure(FigureBase):
2327     """
2328     The top level container for all the plot elements.
2329 
2330     Attributes
2331     ----------
2332     patch
2333         The `.Rectangle` instance representing the figure background patch.
2334 
2335     suppressComposite
2336         For multiple images, the figure will make composite images
2337         depending on the renderer option_image_nocomposite function.  If
2338         *suppressComposite* is a boolean, this will override the renderer.
2339     """
2340     # Remove the self._fig_callbacks properties on figure and subfigure
2341     # after the deprecation expires.
2342     callbacks = _api.deprecated(
2343         "3.6", alternative=("the 'resize_event' signal in "
2344                             "Figure.canvas.callbacks")
2345         )(property(lambda self: self._fig_callbacks))
2346 
2347     def __str__(self):
2348         return "Figure(%gx%g)" % tuple(self.bbox.size)
2349 
2350     def __repr__(self):
2351         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2352             clsname=self.__class__.__name__,
2353             h=self.bbox.size[0], w=self.bbox.size[1],
2354             naxes=len(self.axes),
2355         )
2356 
2357     @_api.make_keyword_only("3.6", "facecolor")
2358     def __init__(self,
2359                  figsize=None,
2360                  dpi=None,
2361                  facecolor=None,
2362                  edgecolor=None,
2363                  linewidth=0.0,
2364                  frameon=None,
2365                  subplotpars=None,  # rc figure.subplot.*
2366                  tight_layout=None,  # rc figure.autolayout
2367                  constrained_layout=None,  # rc figure.constrained_layout.use
2368                  *,
2369                  layout=None,
2370                  **kwargs
2371                  ):
2372         """
2373         Parameters
2374         ----------
2375         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2376             Figure dimension ``(width, height)`` in inches.
2377 
2378         dpi : float, default: :rc:`figure.dpi`
2379             Dots per inch.
2380 
2381         facecolor : default: :rc:`figure.facecolor`
2382             The figure patch facecolor.
2383 
2384         edgecolor : default: :rc:`figure.edgecolor`
2385             The figure patch edge color.
2386 
2387         linewidth : float
2388             The linewidth of the frame (i.e. the edge linewidth of the figure
2389             patch).
2390 
2391         frameon : bool, default: :rc:`figure.frameon`
2392             If ``False``, suppress drawing the figure background patch.
2393 
2394         subplotpars : `SubplotParams`
2395             Subplot parameters. If not given, the default subplot
2396             parameters :rc:`figure.subplot.*` are used.
2397 
2398         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2399             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2400 
2401             .. admonition:: Discouraged
2402 
2403                 The use of this parameter is discouraged. Please use
2404                 ``layout='tight'`` instead for the common case of
2405                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2406 
2407         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2408             This is equal to ``layout='constrained'``.
2409 
2410             .. admonition:: Discouraged
2411 
2412                 The use of this parameter is discouraged. Please use
2413                 ``layout='constrained'`` instead.
2414 
2415         layout : {'constrained', 'compressed', 'tight', `.LayoutEngine`, None}
2416             The layout mechanism for positioning of plot elements to avoid
2417             overlapping Axes decorations (labels, ticks, etc). Note that
2418             layout managers can have significant performance penalties.
2419             Defaults to *None*.
2420 
2421             - 'constrained': The constrained layout solver adjusts axes sizes
2422                to avoid overlapping axes decorations.  Can handle complex plot
2423                layouts and colorbars, and is thus recommended.
2424 
2425               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2426               for examples.
2427 
2428             - 'compressed': uses the same algorithm as 'constrained', but
2429               removes extra space between fixed-aspect-ratio Axes.  Best for
2430               simple grids of axes.
2431 
2432             - 'tight': Use the tight layout mechanism. This is a relatively
2433               simple algorithm that adjusts the subplot parameters so that
2434               decorations do not overlap. See `.Figure.set_tight_layout` for
2435               further details.
2436 
2437             - A `.LayoutEngine` instance. Builtin layout classes are
2438               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2439               accessible by 'constrained' and 'tight'.  Passing an instance
2440               allows third parties to provide their own layout engine.
2441 
2442             If not given, fall back to using the parameters *tight_layout* and
2443             *constrained_layout*, including their config defaults
2444             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2445 
2446         Other Parameters
2447         ----------------
2448         **kwargs : `.Figure` properties, optional
2449 
2450             %(Figure:kwdoc)s
2451         """
2452         super().__init__(**kwargs)
2453         self._layout_engine = None
2454 
2455         if layout is not None:
2456             if (tight_layout is not None):
2457                 _api.warn_external(
2458                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2459                     "be used together. Please use 'layout' only.")
2460             if (constrained_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'constrained_layout' "
2463                     "cannot be used together. Please use 'layout' only.")
2464             self.set_layout_engine(layout=layout)
2465         elif tight_layout is not None:
2466             if constrained_layout is not None:
2467                 _api.warn_external(
2468                     "The Figure parameters 'tight_layout' and "
2469                     "'constrained_layout' cannot be used together. Please use "
2470                     "'layout' parameter")
2471             self.set_layout_engine(layout='tight')
2472             if isinstance(tight_layout, dict):
2473                 self.get_layout_engine().set(**tight_layout)
2474         elif constrained_layout is not None:
2475             if isinstance(constrained_layout, dict):
2476                 self.set_layout_engine(layout='constrained')
2477                 self.get_layout_engine().set(**constrained_layout)
2478             elif constrained_layout:
2479                 self.set_layout_engine(layout='constrained')
2480 
2481         else:
2482             # everything is None, so use default:
2483             self.set_layout_engine(layout=layout)
2484 
2485         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2486         # Callbacks traditionally associated with the canvas (and exposed with
2487         # a proxy property), but that actually need to be on the figure for
2488         # pickling.
2489         self._canvas_callbacks = cbook.CallbackRegistry(
2490             signals=FigureCanvasBase.events)
2491         connect = self._canvas_callbacks._connect_picklable
2492         self._mouse_key_ids = [
2493             connect('key_press_event', backend_bases._key_handler),
2494             connect('key_release_event', backend_bases._key_handler),
2495             connect('key_release_event', backend_bases._key_handler),
2496             connect('button_press_event', backend_bases._mouse_handler),
2497             connect('button_release_event', backend_bases._mouse_handler),
2498             connect('scroll_event', backend_bases._mouse_handler),
2499             connect('motion_notify_event', backend_bases._mouse_handler),
2500         ]
2501         self._button_pick_id = connect('button_press_event', self.pick)
2502         self._scroll_pick_id = connect('scroll_event', self.pick)
2503 
2504         if figsize is None:
2505             figsize = mpl.rcParams['figure.figsize']
2506         if dpi is None:
2507             dpi = mpl.rcParams['figure.dpi']
2508         if facecolor is None:
2509             facecolor = mpl.rcParams['figure.facecolor']
2510         if edgecolor is None:
2511             edgecolor = mpl.rcParams['figure.edgecolor']
2512         if frameon is None:
2513             frameon = mpl.rcParams['figure.frameon']
2514 
2515         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2516             raise ValueError('figure size must be positive finite not '
2517                              f'{figsize}')
2518         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2519 
2520         self.dpi_scale_trans = Affine2D().scale(dpi)
2521         # do not use property as it will trigger
2522         self._dpi = dpi
2523         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2524         self.figbbox = self.bbox
2525         self.transFigure = BboxTransformTo(self.bbox)
2526         self.transSubfigure = self.transFigure
2527 
2528         self.patch = Rectangle(
2529             xy=(0, 0), width=1, height=1, visible=frameon,
2530             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2531             # Don't let the figure patch influence bbox calculation.
2532             in_layout=False)
2533         self._set_artist_props(self.patch)
2534         self.patch.set_antialiased(False)
2535 
2536         FigureCanvasBase(self)  # Set self.canvas.
2537 
2538         if subplotpars is None:
2539             subplotpars = SubplotParams()
2540 
2541         self.subplotpars = subplotpars
2542 
2543         self._axstack = _AxesStack()  # track all figure axes and current axes
2544         self.clear()
2545 
2546     def pick(self, mouseevent):
2547         if not self.canvas.widgetlock.locked():
2548             super().pick(mouseevent)
2549 
2550     def _check_layout_engines_compat(self, old, new):
2551         """
2552         Helper for set_layout engine
2553 
2554         If the figure has used the old engine and added a colorbar then the
2555         value of colorbar_gridspec must be the same on the new engine.
2556         """
2557         if old is None or new is None:
2558             return True
2559         if old.colorbar_gridspec == new.colorbar_gridspec:
2560             return True
2561         # colorbar layout different, so check if any colorbars are on the
2562         # figure...
2563         for ax in self.axes:
2564             if hasattr(ax, '_colorbar'):
2565                 # colorbars list themselves as a colorbar.
2566                 return False
2567         return True
2568 
2569     def set_layout_engine(self, layout=None, **kwargs):
2570         """
2571         Set the layout engine for this figure.
2572 
2573         Parameters
2574         ----------
2575         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2576 `LayoutEngine` or None
2577 
2578             - 'constrained' will use `~.ConstrainedLayoutEngine`
2579             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2580               a correction that attempts to make a good layout for fixed-aspect
2581               ratio Axes.
2582             - 'tight' uses `~.TightLayoutEngine`
2583             - 'none' removes layout engine.
2584 
2585             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2586             (which if `True` behaves as if 'tight' was passed) and
2587             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2588             'constrained' was passed).  If both are `True`,
2589             :rc:`figure.autolayout` takes priority.
2590 
2591             Users and libraries can define their own layout engines and pass
2592             the instance directly as well.
2593 
2594         kwargs: dict
2595             The keyword arguments are passed to the layout engine to set things
2596             like padding and margin sizes.  Only used if *layout* is a string.
2597 
2598         """
2599         if layout is None:
2600             if mpl.rcParams['figure.autolayout']:
2601                 layout = 'tight'
2602             elif mpl.rcParams['figure.constrained_layout.use']:
2603                 layout = 'constrained'
2604             else:
2605                 self._layout_engine = None
2606                 return
2607         if layout == 'tight':
2608             new_layout_engine = TightLayoutEngine(**kwargs)
2609         elif layout == 'constrained':
2610             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2611         elif layout == 'compressed':
2612             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2613                                                         **kwargs)
2614         elif layout == 'none':
2615             if self._layout_engine is not None:
2616                 new_layout_engine = PlaceHolderLayoutEngine(
2617                     self._layout_engine.adjust_compatible,
2618                     self._layout_engine.colorbar_gridspec
2619                 )
2620             else:
2621                 new_layout_engine = None
2622         elif isinstance(layout, LayoutEngine):
2623             new_layout_engine = layout
2624         else:
2625             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2626 
2627         if self._check_layout_engines_compat(self._layout_engine,
2628                                              new_layout_engine):
2629             self._layout_engine = new_layout_engine
2630         else:
2631             raise RuntimeError('Colorbar layout of new layout engine not '
2632                                'compatible with old engine, and a colorbar '
2633                                'has been created.  Engine not changed.')
2634 
2635     def get_layout_engine(self):
2636         return self._layout_engine
2637 
2638     # TODO: I'd like to dynamically add the _repr_html_ method
2639     # to the figure in the right context, but then IPython doesn't
2640     # use it, for some reason.
2641 
2642     def _repr_html_(self):
2643         # We can't use "isinstance" here, because then we'd end up importing
2644         # webagg unconditionally.
2645         if 'WebAgg' in type(self.canvas).__name__:
2646             from matplotlib.backends import backend_webagg
2647             return backend_webagg.ipython_inline_display(self)
2648 
2649     def show(self, warn=True):
2650         """
2651         If using a GUI backend with pyplot, display the figure window.
2652 
2653         If the figure was not created using `~.pyplot.figure`, it will lack
2654         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2655         AttributeError.
2656 
2657         .. warning::
2658 
2659             This does not manage an GUI event loop. Consequently, the figure
2660             may only be shown briefly or not shown at all if you or your
2661             environment are not managing an event loop.
2662 
2663             Use cases for `.Figure.show` include running this from a GUI
2664             application (where there is persistently an event loop running) or
2665             from a shell, like IPython, that install an input hook to allow the
2666             interactive shell to accept input while the figure is also being
2667             shown and interactive.  Some, but not all, GUI toolkits will
2668             register an input hook on import.  See :ref:`cp_integration` for
2669             more details.
2670 
2671             If you're in a shell without input hook integration or executing a
2672             python script, you should use `matplotlib.pyplot.show` with
2673             ``block=True`` instead, which takes care of starting and running
2674             the event loop for you.
2675 
2676         Parameters
2677         ----------
2678         warn : bool, default: True
2679             If ``True`` and we are not running headless (i.e. on Linux with an
2680             unset DISPLAY), issue warning when called on a non-GUI backend.
2681 
2682         """
2683         if self.canvas.manager is None:
2684             raise AttributeError(
2685                 "Figure.show works only for figures managed by pyplot, "
2686                 "normally created by pyplot.figure()")
2687         try:
2688             self.canvas.manager.show()
2689         except NonGuiException as exc:
2690             if warn:
2691                 _api.warn_external(str(exc))
2692 
2693     @property
2694     def axes(self):
2695         """
2696         List of Axes in the Figure. You can access and modify the Axes in the
2697         Figure through this list.
2698 
2699         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2700         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2701 
2702         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2703         equivalent.
2704         """
2705         return self._axstack.as_list()
2706 
2707     get_axes = axes.fget
2708 
2709     def _get_renderer(self):
2710         if hasattr(self.canvas, 'get_renderer'):
2711             return self.canvas.get_renderer()
2712         else:
2713             return _get_renderer(self)
2714 
2715     def _get_dpi(self):
2716         return self._dpi
2717 
2718     def _set_dpi(self, dpi, forward=True):
2719         """
2720         Parameters
2721         ----------
2722         dpi : float
2723 
2724         forward : bool
2725             Passed on to `~.Figure.set_size_inches`
2726         """
2727         if dpi == self._dpi:
2728             # We don't want to cause undue events in backends.
2729             return
2730         self._dpi = dpi
2731         self.dpi_scale_trans.clear().scale(dpi)
2732         w, h = self.get_size_inches()
2733         self.set_size_inches(w, h, forward=forward)
2734         self._fig_callbacks.process('dpi_changed', self)
2735 
2736     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2737 
2738     def get_tight_layout(self):
2739         """Return whether `.tight_layout` is called when drawing."""
2740         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2741 
2742     @_api.deprecated("3.6", alternative="set_layout_engine",
2743                      pending=True)
2744     def set_tight_layout(self, tight):
2745         """
2746         [*Discouraged*] Set whether and how `.tight_layout` is called when
2747         drawing.
2748 
2749         .. admonition:: Discouraged
2750 
2751             This method is discouraged in favor of `~.set_layout_engine`.
2752 
2753         Parameters
2754         ----------
2755         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2756             If a bool, sets whether to call `.tight_layout` upon drawing.
2757             If ``None``, use :rc:`figure.autolayout` instead.
2758             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2759             default paddings.
2760         """
2761         if tight is None:
2762             tight = mpl.rcParams['figure.autolayout']
2763         _tight = 'tight' if bool(tight) else 'none'
2764         _tight_parameters = tight if isinstance(tight, dict) else {}
2765         self.set_layout_engine(_tight, **_tight_parameters)
2766         self.stale = True
2767 
2768     def get_constrained_layout(self):
2769         """
2770         Return whether constrained layout is being used.
2771 
2772         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2773         """
2774         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2775 
2776     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2777                      pending=True)
2778     def set_constrained_layout(self, constrained):
2779         """
2780         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2781         drawing.
2782 
2783         If None, :rc:`figure.constrained_layout.use` value will be used.
2784 
2785         When providing a dict containing the keys ``w_pad``, ``h_pad``
2786         the default ``constrained_layout`` paddings will be
2787         overridden.  These pads are in inches and default to 3.0/72.0.
2788         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2789 
2790         .. admonition:: Discouraged
2791 
2792             This method is discouraged in favor of `~.set_layout_engine`.
2793 
2794         Parameters
2795         ----------
2796         constrained : bool or dict or None
2797         """
2798         if constrained is None:
2799             constrained = mpl.rcParams['figure.constrained_layout.use']
2800         _constrained = 'constrained' if bool(constrained) else 'none'
2801         _parameters = constrained if isinstance(constrained, dict) else {}
2802         self.set_layout_engine(_constrained, **_parameters)
2803         self.stale = True
2804 
2805     @_api.deprecated(
2806          "3.6", alternative="figure.get_layout_engine().set()",
2807          pending=True)
2808     def set_constrained_layout_pads(self, **kwargs):
2809         """
2810         Set padding for ``constrained_layout``.
2811 
2812         Tip: The parameters can be passed from a dictionary by using
2813         ``fig.set_constrained_layout(**pad_dict)``.
2814 
2815         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2816 
2817         Parameters
2818         ----------
2819         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2820             Width padding in inches.  This is the pad around Axes
2821             and is meant to make sure there is enough room for fonts to
2822             look good.  Defaults to 3 pts = 0.04167 inches
2823 
2824         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2825             Height padding in inches. Defaults to 3 pts.
2826 
2827         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2828             Width padding between subplots, expressed as a fraction of the
2829             subplot width.  The total padding ends up being w_pad + wspace.
2830 
2831         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2832             Height padding between subplots, expressed as a fraction of the
2833             subplot width. The total padding ends up being h_pad + hspace.
2834 
2835         """
2836         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2837             self.get_layout_engine().set(**kwargs)
2838 
2839     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2840                      pending=True)
2841     def get_constrained_layout_pads(self, relative=False):
2842         """
2843         Get padding for ``constrained_layout``.
2844 
2845         Returns a list of ``w_pad, h_pad`` in inches and
2846         ``wspace`` and ``hspace`` as fractions of the subplot.
2847         All values are None if ``constrained_layout`` is not used.
2848 
2849         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2850 
2851         Parameters
2852         ----------
2853         relative : bool
2854             If `True`, then convert from inches to figure relative.
2855         """
2856         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2857             return None, None, None, None
2858         info = self.get_layout_engine().get_info()
2859         w_pad = info['w_pad']
2860         h_pad = info['h_pad']
2861         wspace = info['wspace']
2862         hspace = info['hspace']
2863 
2864         if relative and (w_pad is not None or h_pad is not None):
2865             renderer = self._get_renderer()
2866             dpi = renderer.dpi
2867             w_pad = w_pad * dpi / renderer.width
2868             h_pad = h_pad * dpi / renderer.height
2869 
2870         return w_pad, h_pad, wspace, hspace
2871 
2872     def set_canvas(self, canvas):
2873         """
2874         Set the canvas that contains the figure
2875 
2876         Parameters
2877         ----------
2878         canvas : FigureCanvas
2879         """
2880         self.canvas = canvas
2881 
2882     @_docstring.interpd
2883     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2884                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2885         """
2886         Add a non-resampled image to the figure.
2887 
2888         The image is attached to the lower or upper left corner depending on
2889         *origin*.
2890 
2891         Parameters
2892         ----------
2893         X
2894             The image data. This is an array of one of the following shapes:
2895 
2896             - (M, N): an image with scalar data.  Color-mapping is controlled
2897               by *cmap*, *norm*, *vmin*, and *vmax*.
2898             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2899             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2900               i.e. including transparency.
2901 
2902         xo, yo : int
2903             The *x*/*y* image offset in pixels.
2904 
2905         alpha : None or float
2906             The alpha blending value.
2907 
2908         %(cmap_doc)s
2909 
2910             This parameter is ignored if *X* is RGB(A).
2911 
2912         %(norm_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(vmin_vmax_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2921             Indicates where the [0, 0] index of the array is in the upper left
2922             or lower left corner of the axes.
2923 
2924         resize : bool
2925             If *True*, resize the figure to match the given image size.
2926 
2927         Returns
2928         -------
2929         `matplotlib.image.FigureImage`
2930 
2931         Other Parameters
2932         ----------------
2933         **kwargs
2934             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2935 
2936         Notes
2937         -----
2938         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2939         which will be resampled to fit the current Axes.  If you want
2940         a resampled image to fill the entire figure, you can define an
2941         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2942 
2943         Examples
2944         --------
2945         ::
2946 
2947             f = plt.figure()
2948             nx = int(f.get_figwidth() * f.dpi)
2949             ny = int(f.get_figheight() * f.dpi)
2950             data = np.random.random((ny, nx))
2951             f.figimage(data)
2952             plt.show()
2953         """
2954         if resize:
2955             dpi = self.get_dpi()
2956             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2957             self.set_size_inches(figsize, forward=True)
2958 
2959         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2960                                 offsetx=xo, offsety=yo,
2961                                 origin=origin, **kwargs)
2962         im.stale_callback = _stale_figure_callback
2963 
2964         im.set_array(X)
2965         im.set_alpha(alpha)
2966         if norm is None:
2967             im.set_clim(vmin, vmax)
2968         self.images.append(im)
2969         im._remove_method = self.images.remove
2970         self.stale = True
2971         return im
2972 
2973     def set_size_inches(self, w, h=None, forward=True):
2974         """
2975         Set the figure size in inches.
2976 
2977         Call signatures::
2978 
2979              fig.set_size_inches(w, h)  # OR
2980              fig.set_size_inches((w, h))
2981 
2982         Parameters
2983         ----------
2984         w : (float, float) or float
2985             Width and height in inches (if height not specified as a separate
2986             argument) or width.
2987         h : float
2988             Height in inches.
2989         forward : bool, default: True
2990             If ``True``, the canvas size is automatically updated, e.g.,
2991             you can resize the figure window from the shell.
2992 
2993         See Also
2994         --------
2995         matplotlib.figure.Figure.get_size_inches
2996         matplotlib.figure.Figure.set_figwidth
2997         matplotlib.figure.Figure.set_figheight
2998 
2999         Notes
3000         -----
3001         To transform from pixels to inches divide by `Figure.dpi`.
3002         """
3003         if h is None:  # Got called with a single pair as argument.
3004             w, h = w
3005         size = np.array([w, h])
3006         if not np.isfinite(size).all() or (size < 0).any():
3007             raise ValueError(f'figure size must be positive finite not {size}')
3008         self.bbox_inches.p1 = size
3009         if forward:
3010             manager = self.canvas.manager
3011             if manager is not None:
3012                 manager.resize(*(size * self.dpi).astype(int))
3013         self.stale = True
3014 
3015     def get_size_inches(self):
3016         """
3017         Return the current size of the figure in inches.
3018 
3019         Returns
3020         -------
3021         ndarray
3022            The size (width, height) of the figure in inches.
3023 
3024         See Also
3025         --------
3026         matplotlib.figure.Figure.set_size_inches
3027         matplotlib.figure.Figure.get_figwidth
3028         matplotlib.figure.Figure.get_figheight
3029 
3030         Notes
3031         -----
3032         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3033         """
3034         return np.array(self.bbox_inches.p1)
3035 
3036     def get_figwidth(self):
3037         """Return the figure width in inches."""
3038         return self.bbox_inches.width
3039 
3040     def get_figheight(self):
3041         """Return the figure height in inches."""
3042         return self.bbox_inches.height
3043 
3044     def get_dpi(self):
3045         """Return the resolution in dots per inch as a float."""
3046         return self.dpi
3047 
3048     def set_dpi(self, val):
3049         """
3050         Set the resolution of the figure in dots-per-inch.
3051 
3052         Parameters
3053         ----------
3054         val : float
3055         """
3056         self.dpi = val
3057         self.stale = True
3058 
3059     def set_figwidth(self, val, forward=True):
3060         """
3061         Set the width of the figure in inches.
3062 
3063         Parameters
3064         ----------
3065         val : float
3066         forward : bool
3067             See `set_size_inches`.
3068 
3069         See Also
3070         --------
3071         matplotlib.figure.Figure.set_figheight
3072         matplotlib.figure.Figure.set_size_inches
3073         """
3074         self.set_size_inches(val, self.get_figheight(), forward=forward)
3075 
3076     def set_figheight(self, val, forward=True):
3077         """
3078         Set the height of the figure in inches.
3079 
3080         Parameters
3081         ----------
3082         val : float
3083         forward : bool
3084             See `set_size_inches`.
3085 
3086         See Also
3087         --------
3088         matplotlib.figure.Figure.set_figwidth
3089         matplotlib.figure.Figure.set_size_inches
3090         """
3091         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3092 
3093     def clear(self, keep_observers=False):
3094         # docstring inherited
3095         super().clear(keep_observers=keep_observers)
3096         # FigureBase.clear does not clear toolbars, as
3097         # only Figure can have toolbars
3098         toolbar = self.canvas.toolbar
3099         if toolbar is not None:
3100             toolbar.update()
3101 
3102     @_finalize_rasterization
3103     @allow_rasterization
3104     def draw(self, renderer):
3105         # docstring inherited
3106 
3107         # draw the figure bounding box, perhaps none for white figure
3108         if not self.get_visible():
3109             return
3110 
3111         artists = self._get_draw_artists(renderer)
3112         try:
3113             renderer.open_group('figure', gid=self.get_gid())
3114             if self.axes and self.get_layout_engine() is not None:
3115                 try:
3116                     self.get_layout_engine().execute(self)
3117                 except ValueError:
3118                     pass
3119                     # ValueError can occur when resizing a window.
3120 
3121             self.patch.draw(renderer)
3122             mimage._draw_list_compositing_images(
3123                 renderer, self, artists, self.suppressComposite)
3124 
3125             for sfig in self.subfigs:
3126                 sfig.draw(renderer)
3127 
3128             renderer.close_group('figure')
3129         finally:
3130             self.stale = False
3131 
3132         DrawEvent("draw_event", self.canvas, renderer)._process()
3133 
3134     def draw_without_rendering(self):
3135         """
3136         Draw the figure with no output.  Useful to get the final size of
3137         artists that require a draw before their size is known (e.g. text).
3138         """
3139         renderer = _get_renderer(self)
3140         with renderer._draw_disabled():
3141             self.draw(renderer)
3142 
3143     def draw_artist(self, a):
3144         """
3145         Draw `.Artist` *a* only.
3146         """
3147         a.draw(self.canvas.get_renderer())
3148 
3149     def __getstate__(self):
3150         state = super().__getstate__()
3151 
3152         # The canvas cannot currently be pickled, but this has the benefit
3153         # of meaning that a figure can be detached from one canvas, and
3154         # re-attached to another.
3155         state.pop("canvas")
3156 
3157         # discard any changes to the dpi due to pixel ratio changes
3158         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3159 
3160         # add version information to the state
3161         state['__mpl_version__'] = mpl.__version__
3162 
3163         # check whether the figure manager (if any) is registered with pyplot
3164         from matplotlib import _pylab_helpers
3165         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3166             state['_restore_to_pylab'] = True
3167         return state
3168 
3169     def __setstate__(self, state):
3170         version = state.pop('__mpl_version__')
3171         restore_to_pylab = state.pop('_restore_to_pylab', False)
3172 
3173         if version != mpl.__version__:
3174             _api.warn_external(
3175                 f"This figure was saved with matplotlib version {version} and "
3176                 f"is unlikely to function correctly.")
3177 
3178         self.__dict__ = state
3179 
3180         # re-initialise some of the unstored state information
3181         FigureCanvasBase(self)  # Set self.canvas.
3182 
3183         if restore_to_pylab:
3184             # lazy import to avoid circularity
3185             import matplotlib.pyplot as plt
3186             import matplotlib._pylab_helpers as pylab_helpers
3187             allnums = plt.get_fignums()
3188             num = max(allnums) + 1 if allnums else 1
3189             backend = plt._get_backend_mod()
3190             mgr = backend.new_figure_manager_given_figure(num, self)
3191             pylab_helpers.Gcf._set_new_active_manager(mgr)
3192             plt.draw_if_interactive()
3193 
3194         self.stale = True
3195 
3196     def add_axobserver(self, func):
3197         """Whenever the Axes state change, ``func(self)`` will be called."""
3198         # Connect a wrapper lambda and not func itself, to avoid it being
3199         # weakref-collected.
3200         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3201 
3202     def savefig(self, fname, *, transparent=None, **kwargs):
3203         """
3204         Save the current figure.
3205 
3206         Call signature::
3207 
3208           savefig(fname, *, dpi='figure', format=None, metadata=None,
3209                   bbox_inches=None, pad_inches=0.1,
3210                   facecolor='auto', edgecolor='auto',
3211                   backend=None, **kwargs
3212                  )
3213 
3214         The available output formats depend on the backend being used.
3215 
3216         Parameters
3217         ----------
3218         fname : str or path-like or binary file-like
3219             A path, or a Python file-like object, or
3220             possibly some backend-dependent object such as
3221             `matplotlib.backends.backend_pdf.PdfPages`.
3222 
3223             If *format* is set, it determines the output format, and the file
3224             is saved as *fname*.  Note that *fname* is used verbatim, and there
3225             is no attempt to make the extension, if any, of *fname* match
3226             *format*, and no extension is appended.
3227 
3228             If *format* is not set, then the format is inferred from the
3229             extension of *fname*, if there is one.  If *format* is not
3230             set and *fname* has no extension, then the file is saved with
3231             :rc:`savefig.format` and the appropriate extension is appended to
3232             *fname*.
3233 
3234         Other Parameters
3235         ----------------
3236         dpi : float or 'figure', default: :rc:`savefig.dpi`
3237             The resolution in dots per inch.  If 'figure', use the figure's
3238             dpi value.
3239 
3240         format : str
3241             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3242             this is unset is documented under *fname*.
3243 
3244         metadata : dict, optional
3245             Key/value pairs to store in the image metadata. The supported keys
3246             and defaults depend on the image format and backend:
3247 
3248             - 'png' with Agg backend: See the parameter ``metadata`` of
3249               `~.FigureCanvasAgg.print_png`.
3250             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3251               `~.backend_pdf.PdfPages`.
3252             - 'svg' with svg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasSVG.print_svg`.
3254             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3255 
3256         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3257             Bounding box in inches: only the given portion of the figure is
3258             saved.  If 'tight', try to figure out the tight bbox of the figure.
3259 
3260         pad_inches : float, default: :rc:`savefig.pad_inches`
3261             Amount of padding around the figure when bbox_inches is 'tight'.
3262 
3263         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3264             The facecolor of the figure.  If 'auto', use the current figure
3265             facecolor.
3266 
3267         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3268             The edgecolor of the figure.  If 'auto', use the current figure
3269             edgecolor.
3270 
3271         backend : str, optional
3272             Use a non-default backend to render the file, e.g. to render a
3273             png file with the "cairo" backend rather than the default "agg",
3274             or a pdf file with the "pgf" backend rather than the default
3275             "pdf".  Note that the default backend is normally sufficient.  See
3276             :ref:`the-builtin-backends` for a list of valid backends for each
3277             file format.  Custom backends can be referenced as "module://...".
3278 
3279         orientation : {'landscape', 'portrait'}
3280             Currently only supported by the postscript backend.
3281 
3282         papertype : str
3283             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3284             'a10', 'b0' through 'b10'. Only supported for postscript
3285             output.
3286 
3287         transparent : bool
3288             If *True*, the Axes patches will all be transparent; the
3289             Figure patch will also be transparent unless *facecolor*
3290             and/or *edgecolor* are specified via kwargs.
3291 
3292             If *False* has no effect and the color of the Axes and
3293             Figure patches are unchanged (unless the Figure patch
3294             is specified via the *facecolor* and/or *edgecolor* keyword
3295             arguments in which case those colors are used).
3296 
3297             The transparency of these patches will be restored to their
3298             original values upon exit of this function.
3299 
3300             This is useful, for example, for displaying
3301             a plot on top of a colored background on a web page.
3302 
3303         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3304             A list of extra artists that will be considered when the
3305             tight bbox is calculated.
3306 
3307         pil_kwargs : dict, optional
3308             Additional keyword arguments that are passed to
3309             `PIL.Image.Image.save` when saving the figure.
3310 
3311         """
3312 
3313         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3314         if transparent is None:
3315             transparent = mpl.rcParams['savefig.transparent']
3316 
3317         with ExitStack() as stack:
3318             if transparent:
3319                 kwargs.setdefault('facecolor', 'none')
3320                 kwargs.setdefault('edgecolor', 'none')
3321                 for ax in self.axes:
3322                     stack.enter_context(
3323                         ax.patch._cm_set(facecolor='none', edgecolor='none'))
3324 
3325             self.canvas.print_figure(fname, **kwargs)
3326 
3327     def ginput(self, n=1, timeout=30, show_clicks=True,
3328                mouse_add=MouseButton.LEFT,
3329                mouse_pop=MouseButton.RIGHT,
3330                mouse_stop=MouseButton.MIDDLE):
3331         """
3332         Blocking call to interact with a figure.
3333 
3334         Wait until the user clicks *n* times on the figure, and return the
3335         coordinates of each click in a list.
3336 
3337         There are three possible interactions:
3338 
3339         - Add a point.
3340         - Remove the most recently added point.
3341         - Stop the interaction and return the points added so far.
3342 
3343         The actions are assigned to mouse buttons via the arguments
3344         *mouse_add*, *mouse_pop* and *mouse_stop*.
3345 
3346         Parameters
3347         ----------
3348         n : int, default: 1
3349             Number of mouse clicks to accumulate. If negative, accumulate
3350             clicks until the input is terminated manually.
3351         timeout : float, default: 30 seconds
3352             Number of seconds to wait before timing out. If zero or negative
3353             will never time out.
3354         show_clicks : bool, default: True
3355             If True, show a red cross at the location of each click.
3356         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3357             Mouse button used to add points.
3358         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3359             Mouse button used to remove the most recently added point.
3360         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3361             Mouse button used to stop input.
3362 
3363         Returns
3364         -------
3365         list of tuples
3366             A list of the clicked (x, y) coordinates.
3367 
3368         Notes
3369         -----
3370         The keyboard can also be used to select points in case your mouse
3371         does not have one or more of the buttons.  The delete and backspace
3372         keys act like right-clicking (i.e., remove last point), the enter key
3373         terminates input and any other key (not already used by the window
3374         manager) selects a point.
3375         """
3376         clicks = []
3377         marks = []
3378 
3379         def handler(event):
3380             is_button = event.name == "button_press_event"
3381             is_key = event.name == "key_press_event"
3382             # Quit (even if not in infinite mode; this is consistent with
3383             # MATLAB and sometimes quite useful, but will require the user to
3384             # test how many points were actually returned before using data).
3385             if (is_button and event.button == mouse_stop
3386                     or is_key and event.key in ["escape", "enter"]):
3387                 self.canvas.stop_event_loop()
3388             # Pop last click.
3389             elif (is_button and event.button == mouse_pop
3390                   or is_key and event.key in ["backspace", "delete"]):
3391                 if clicks:
3392                     clicks.pop()
3393                     if show_clicks:
3394                         marks.pop().remove()
3395                         self.canvas.draw()
3396             # Add new click.
3397             elif (is_button and event.button == mouse_add
3398                   # On macOS/gtk, some keys return None.
3399                   or is_key and event.key is not None):
3400                 if event.inaxes:
3401                     clicks.append((event.xdata, event.ydata))
3402                     _log.info("input %i: %f, %f",
3403                               len(clicks), event.xdata, event.ydata)
3404                     if show_clicks:
3405                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3406                                                 marker="+", color="r")
3407                         event.inaxes.add_line(line)
3408                         marks.append(line)
3409                         self.canvas.draw()
3410             if len(clicks) == n and n > 0:
3411                 self.canvas.stop_event_loop()
3412 
3413         _blocking_input.blocking_input_loop(
3414             self, ["button_press_event", "key_press_event"], timeout, handler)
3415 
3416         # Cleanup.
3417         for mark in marks:
3418             mark.remove()
3419         self.canvas.draw()
3420 
3421         return clicks
3422 
3423     def waitforbuttonpress(self, timeout=-1):
3424         """
3425         Blocking call to interact with the figure.
3426 
3427         Wait for user input and return True if a key was pressed, False if a
3428         mouse button was pressed and None if no input was given within
3429         *timeout* seconds.  Negative values deactivate *timeout*.
3430         """
3431         event = None
3432 
3433         def handler(ev):
3434             nonlocal event
3435             event = ev
3436             self.canvas.stop_event_loop()
3437 
3438         _blocking_input.blocking_input_loop(
3439             self, ["button_press_event", "key_press_event"], timeout, handler)
3440 
3441         return None if event is None else event.name == "key_press_event"
3442 
3443     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3444     def execute_constrained_layout(self, renderer=None):
3445         """
3446         Use ``layoutgrid`` to determine pos positions within Axes.
3447 
3448         See also `.set_constrained_layout_pads`.
3449 
3450         Returns
3451         -------
3452         layoutgrid : private debugging object
3453         """
3454         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3455             return None
3456         return self.get_layout_engine().execute(self)
3457 
3458     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3459         """
3460         Adjust the padding between and around subplots.
3461 
3462         To exclude an artist on the Axes from the bounding box calculation
3463         that determines the subplot parameters (i.e. legend, or annotation),
3464         set ``a.set_in_layout(False)`` for that artist.
3465 
3466         Parameters
3467         ----------
3468         pad : float, default: 1.08
3469             Padding between the figure edge and the edges of subplots,
3470             as a fraction of the font size.
3471         h_pad, w_pad : float, default: *pad*
3472             Padding (height/width) between edges of adjacent subplots,
3473             as a fraction of the font size.
3474         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3475             A rectangle in normalized figure coordinates into which the whole
3476             subplots area (including labels) will fit.
3477 
3478         See Also
3479         --------
3480         .Figure.set_layout_engine
3481         .pyplot.tight_layout
3482         """
3483         # note that here we do not permanently set the figures engine to
3484         # tight_layout but rather just perform the layout in place and remove
3485         # any previous engines.
3486         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3487                                    rect=rect)
3488         try:
3489             previous_engine = self.get_layout_engine()
3490             self.set_layout_engine(engine)
3491             engine.execute(self)
3492             if not isinstance(previous_engine, TightLayoutEngine) \
3493                     and previous_engine is not None:
3494                 _api.warn_external('The figure layout has changed to tight')
3495         finally:
3496             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>subplot_mosaic</method>
<code>
1791     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1792                        width_ratios=None, height_ratios=None,
1793                        empty_sentinel='.',
1794                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1795         """
1796         Build a layout of Axes based on ASCII art or nested lists.
1797 
1798         This is a helper function to build complex GridSpec layouts visually.
1799 
1800         See :doc:`/gallery/subplots_axes_and_figures/mosaic`
1801         for an example and full API documentation
1802 
1803         Parameters
1804         ----------
1805         mosaic : list of list of {hashable or nested} or str
1806 
1807             A visual layout of how you want your Axes to be arranged
1808             labeled as strings.  For example ::
1809 
1810                x = [['A panel', 'A panel', 'edge'],
1811                     ['C panel', '.',       'edge']]
1812 
1813             produces 4 Axes:
1814 
1815             - 'A panel' which is 1 row high and spans the first two columns
1816             - 'edge' which is 2 rows high and is on the right edge
1817             - 'C panel' which in 1 row and 1 column wide in the bottom left
1818             - a blank space 1 row and 1 column wide in the bottom center
1819 
1820             Any of the entries in the layout can be a list of lists
1821             of the same form to create nested layouts.
1822 
1823             If input is a str, then it can either be a multi-line string of
1824             the form ::
1825 
1826               '''
1827               AAE
1828               C.E
1829               '''
1830 
1831             where each character is a column and each line is a row. Or it
1832             can be a single-line string where rows are separated by ``;``::
1833 
1834               'AB;CC'
1835 
1836             The string notation allows only single character Axes labels and
1837             does not support nesting but is very terse.
1838 
1839             The Axes identifiers may be `str` or a non-iterable hashable
1840             object (e.g. `tuple` s may not be used).
1841 
1842         sharex, sharey : bool, default: False
1843             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1844             among all subplots.  In that case, tick label visibility and axis
1845             units behave as for `subplots`.  If False, each subplot's x- or
1846             y-axis will be independent.
1847 
1848         width_ratios : array-like of length *ncols*, optional
1849             Defines the relative widths of the columns. Each column gets a
1850             relative width of ``width_ratios[i] / sum(width_ratios)``.
1851             If not given, all columns will have the same width.  Equivalent
1852             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1853             layouts, this argument applies only to the outer layout.
1854 
1855         height_ratios : array-like of length *nrows*, optional
1856             Defines the relative heights of the rows. Each row gets a
1857             relative height of ``height_ratios[i] / sum(height_ratios)``.
1858             If not given, all rows will have the same height. Equivalent
1859             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1860             layouts, this argument applies only to the outer layout.
1861 
1862         subplot_kw : dict, optional
1863             Dictionary with keywords passed to the `.Figure.add_subplot` call
1864             used to create each subplot.  These values may be overridden by
1865             values in *per_subplot_kw*.
1866 
1867         per_subplot_kw : dict, optional
1868             A dictionary mapping the Axes identifiers or tuples of identifiers
1869             to a dictionary of keyword arguments to be passed to the
1870             `.Figure.add_subplot` call used to create each subplot.  The values
1871             in these dictionaries have precedence over the values in
1872             *subplot_kw*.
1873 
1874             If *mosaic* is a string, and thus all keys are single characters,
1875             it is possible to use a single string instead of a tuple as keys;
1876             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1877 
1878             .. versionadded:: 3.7
1879 
1880         gridspec_kw : dict, optional
1881             Dictionary with keywords passed to the `.GridSpec` constructor used
1882             to create the grid the subplots are placed on. In the case of
1883             nested layouts, this argument applies only to the outer layout.
1884             For more complex layouts, users should use `.Figure.subfigures`
1885             to create the nesting.
1886 
1887         empty_sentinel : object, optional
1888             Entry in the layout to mean "leave this space empty".  Defaults
1889             to ``'.'``. Note, if *layout* is a string, it is processed via
1890             `inspect.cleandoc` to remove leading white space, which may
1891             interfere with using white-space as the empty sentinel.
1892 
1893         Returns
1894         -------
1895         dict[label, Axes]
1896            A dictionary mapping the labels to the Axes objects.  The order of
1897            the axes is left-to-right and top-to-bottom of their position in the
1898            total layout.
1899 
1900         """
1901         subplot_kw = subplot_kw or {}
1902         gridspec_kw = dict(gridspec_kw or {})
1903         per_subplot_kw = per_subplot_kw or {}
1904 
1905         if height_ratios is not None:
1906             if 'height_ratios' in gridspec_kw:
1907                 raise ValueError("'height_ratios' must not be defined both as "
1908                                  "parameter and as key in 'gridspec_kw'")
1909             gridspec_kw['height_ratios'] = height_ratios
1910         if width_ratios is not None:
1911             if 'width_ratios' in gridspec_kw:
1912                 raise ValueError("'width_ratios' must not be defined both as "
1913                                  "parameter and as key in 'gridspec_kw'")
1914             gridspec_kw['width_ratios'] = width_ratios
1915 
1916         # special-case string input
1917         if isinstance(mosaic, str):
1918             mosaic = self._normalize_grid_string(mosaic)
1919             per_subplot_kw = {
1920                 tuple(k): v for k, v in per_subplot_kw.items()
1921             }
1922 
1923         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1924 
1925         # Only accept strict bools to allow a possible future API expansion.
1926         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1927 
1928         def _make_array(inp):
1929             """
1930             Convert input into 2D array
1931 
1932             We need to have this internal function rather than
1933             ``np.asarray(..., dtype=object)`` so that a list of lists
1934             of lists does not get converted to an array of dimension >
1935             2
1936 
1937             Returns
1938             -------
1939             2D object array
1940 
1941             """
1942             r0, *rest = inp
1943             if isinstance(r0, str):
1944                 raise ValueError('List mosaic specification must be 2D')
1945             for j, r in enumerate(rest, start=1):
1946                 if isinstance(r, str):
1947                     raise ValueError('List mosaic specification must be 2D')
1948                 if len(r0) != len(r):
1949                     raise ValueError(
1950                         "All of the rows must be the same length, however "
1951                         f"the first row ({r0!r}) has length {len(r0)} "
1952                         f"and row {j} ({r!r}) has length {len(r)}."
1953                     )
1954             out = np.zeros((len(inp), len(r0)), dtype=object)
1955             for j, r in enumerate(inp):
1956                 for k, v in enumerate(r):
1957                     out[j, k] = v
1958             return out
1959 
1960         def _identify_keys_and_nested(mosaic):
1961             """
1962             Given a 2D object array, identify unique IDs and nested mosaics
1963 
1964             Parameters
1965             ----------
1966             mosaic : 2D numpy object array
1967 
1968             Returns
1969             -------
1970             unique_ids : tuple
1971                 The unique non-sub mosaic entries in this mosaic
1972             nested : dict[tuple[int, int]], 2D object array
1973             """
1974             # make sure we preserve the user supplied order
1975             unique_ids = cbook._OrderedSet()
1976             nested = {}
1977             for j, row in enumerate(mosaic):
1978                 for k, v in enumerate(row):
1979                     if v == empty_sentinel:
1980                         continue
1981                     elif not cbook.is_scalar_or_string(v):
1982                         nested[(j, k)] = _make_array(v)
1983                     else:
1984                         unique_ids.add(v)
1985 
1986             return tuple(unique_ids), nested
1987 
1988         def _do_layout(gs, mosaic, unique_ids, nested):
1989             """
1990             Recursively do the mosaic.
1991 
1992             Parameters
1993             ----------
1994             gs : GridSpec
1995             mosaic : 2D object array
1996                 The input converted to a 2D numpy array for this level.
1997             unique_ids : tuple
1998                 The identified scalar labels at this level of nesting.
1999             nested : dict[tuple[int, int]], 2D object array
2000                 The identified nested mosaics, if any.
2001 
2002             Returns
2003             -------
2004             dict[label, Axes]
2005                 A flat dict of all of the Axes created.
2006             """
2007             output = dict()
2008 
2009             # we need to merge together the Axes at this level and the axes
2010             # in the (recursively) nested sub-mosaics so that we can add
2011             # them to the figure in the "natural" order if you were to
2012             # ravel in c-order all of the Axes that will be created
2013             #
2014             # This will stash the upper left index of each object (axes or
2015             # nested mosaic) at this level
2016             this_level = dict()
2017 
2018             # go through the unique keys,
2019             for name in unique_ids:
2020                 # sort out where each axes starts/ends
2021                 indx = np.argwhere(mosaic == name)
2022                 start_row, start_col = np.min(indx, axis=0)
2023                 end_row, end_col = np.max(indx, axis=0) + 1
2024                 # and construct the slice object
2025                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2026                 # some light error checking
2027                 if (mosaic[slc] != name).any():
2028                     raise ValueError(
2029                         f"While trying to layout\n{mosaic!r}\n"
2030                         f"we found that the label {name!r} specifies a "
2031                         "non-rectangular or non-contiguous area.")
2032                 # and stash this slice for later
2033                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2034 
2035             # do the same thing for the nested mosaics (simpler because these
2036             # can not be spans yet!)
2037             for (j, k), nested_mosaic in nested.items():
2038                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2039 
2040             # now go through the things in this level and add them
2041             # in order left-to-right top-to-bottom
2042             for key in sorted(this_level):
2043                 name, arg, method = this_level[key]
2044                 # we are doing some hokey function dispatch here based
2045                 # on the 'method' string stashed above to sort out if this
2046                 # element is an Axes or a nested mosaic.
2047                 if method == 'axes':
2048                     slc = arg
2049                     # add a single axes
2050                     if name in output:
2051                         raise ValueError(f"There are duplicate keys {name} "
2052                                          f"in the layout\n{mosaic!r}")
2053                     ax = self.add_subplot(
2054                         gs[slc], **{
2055                             'label': str(name),
2056                             **subplot_kw,
2057                             **per_subplot_kw.get(name, {})
2058                         }
2059                     )
2060                     output[name] = ax
2061                 elif method == 'nested':
2062                     nested_mosaic = arg
2063                     j, k = key
2064                     # recursively add the nested mosaic
2065                     rows, cols = nested_mosaic.shape
2066                     nested_output = _do_layout(
2067                         gs[j, k].subgridspec(rows, cols),
2068                         nested_mosaic,
2069                         *_identify_keys_and_nested(nested_mosaic)
2070                     )
2071                     overlap = set(output) & set(nested_output)
2072                     if overlap:
2073                         raise ValueError(
2074                             f"There are duplicate keys {overlap} "
2075                             f"between the outer layout\n{mosaic!r}\n"
2076                             f"and the nested layout\n{nested_mosaic}"
2077                         )
2078                     output.update(nested_output)
2079                 else:
2080                     raise RuntimeError("This should never happen")
2081             return output
2082 
2083         mosaic = _make_array(mosaic)
2084         rows, cols = mosaic.shape
2085         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2086         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2087         ax0 = next(iter(ret.values()))
2088         for ax in ret.values():
2089             if sharex:
2090                 ax.sharex(ax0)
2091                 ax._label_outer_xaxis(check_patch=True)
2092             if sharey:
2093                 ax.sharey(ax0)
2094                 ax._label_outer_yaxis(check_patch=True)
2095         if extra := set(per_subplot_kw) - set(ret):
2096             raise ValueError(
2097                 f"The keys {extra} are in *per_subplot_kw* "
2098                 "but not in the mosaic."
2099             )
2100         return ret

</code><intended_behavior>The 'subplot_mosaic' method implementation must ensure that once a compressed layout is set up for a figure, these settings are embedded into the figure's metadata or state in a manner that they are referred to or reapplied in subsequent operations affecting the figure's layout, including saving with 'bbox_inches="tight"'. This means enhancing how layout settings are stored or referenced within a figure's lifecycle, ensuring consistency between the visualization on-screen and the saved files.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>FigureBase</class>
<method>subplot_mosaic</method>
<code>
1791     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1792                        width_ratios=None, height_ratios=None,
1793                        empty_sentinel='.',
1794                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1795         """
1796         Build a layout of Axes based on ASCII art or nested lists.
1797 
1798         This is a helper function to build complex GridSpec layouts visually.
1799 
1800         See :doc:`/gallery/subplots_axes_and_figures/mosaic`
1801         for an example and full API documentation
1802 
1803         Parameters
1804         ----------
1805         mosaic : list of list of {hashable or nested} or str
1806 
1807             A visual layout of how you want your Axes to be arranged
1808             labeled as strings.  For example ::
1809 
1810                x = [['A panel', 'A panel', 'edge'],
1811                     ['C panel', '.',       'edge']]
1812 
1813             produces 4 Axes:
1814 
1815             - 'A panel' which is 1 row high and spans the first two columns
1816             - 'edge' which is 2 rows high and is on the right edge
1817             - 'C panel' which in 1 row and 1 column wide in the bottom left
1818             - a blank space 1 row and 1 column wide in the bottom center
1819 
1820             Any of the entries in the layout can be a list of lists
1821             of the same form to create nested layouts.
1822 
1823             If input is a str, then it can either be a multi-line string of
1824             the form ::
1825 
1826               '''
1827               AAE
1828               C.E
1829               '''
1830 
1831             where each character is a column and each line is a row. Or it
1832             can be a single-line string where rows are separated by ``;``::
1833 
1834               'AB;CC'
1835 
1836             The string notation allows only single character Axes labels and
1837             does not support nesting but is very terse.
1838 
1839             The Axes identifiers may be `str` or a non-iterable hashable
1840             object (e.g. `tuple` s may not be used).
1841 
1842         sharex, sharey : bool, default: False
1843             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1844             among all subplots.  In that case, tick label visibility and axis
1845             units behave as for `subplots`.  If False, each subplot's x- or
1846             y-axis will be independent.
1847 
1848         width_ratios : array-like of length *ncols*, optional
1849             Defines the relative widths of the columns. Each column gets a
1850             relative width of ``width_ratios[i] / sum(width_ratios)``.
1851             If not given, all columns will have the same width.  Equivalent
1852             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1853             layouts, this argument applies only to the outer layout.
1854 
1855         height_ratios : array-like of length *nrows*, optional
1856             Defines the relative heights of the rows. Each row gets a
1857             relative height of ``height_ratios[i] / sum(height_ratios)``.
1858             If not given, all rows will have the same height. Equivalent
1859             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1860             layouts, this argument applies only to the outer layout.
1861 
1862         subplot_kw : dict, optional
1863             Dictionary with keywords passed to the `.Figure.add_subplot` call
1864             used to create each subplot.  These values may be overridden by
1865             values in *per_subplot_kw*.
1866 
1867         per_subplot_kw : dict, optional
1868             A dictionary mapping the Axes identifiers or tuples of identifiers
1869             to a dictionary of keyword arguments to be passed to the
1870             `.Figure.add_subplot` call used to create each subplot.  The values
1871             in these dictionaries have precedence over the values in
1872             *subplot_kw*.
1873 
1874             If *mosaic* is a string, and thus all keys are single characters,
1875             it is possible to use a single string instead of a tuple as keys;
1876             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1877 
1878             .. versionadded:: 3.7
1879 
1880         gridspec_kw : dict, optional
1881             Dictionary with keywords passed to the `.GridSpec` constructor used
1882             to create the grid the subplots are placed on. In the case of
1883             nested layouts, this argument applies only to the outer layout.
1884             For more complex layouts, users should use `.Figure.subfigures`
1885             to create the nesting.
1886 
1887         empty_sentinel : object, optional
1888             Entry in the layout to mean "leave this space empty".  Defaults
1889             to ``'.'``. Note, if *layout* is a string, it is processed via
1890             `inspect.cleandoc` to remove leading white space, which may
1891             interfere with using white-space as the empty sentinel.
1892 
1893         Returns
1894         -------
1895         dict[label, Axes]
1896            A dictionary mapping the labels to the Axes objects.  The order of
1897            the axes is left-to-right and top-to-bottom of their position in the
1898            total layout.
1899 
1900         """
1901         subplot_kw = subplot_kw or {}
1902         gridspec_kw = dict(gridspec_kw or {})
1903         per_subplot_kw = per_subplot_kw or {}
1904 
1905         if height_ratios is not None:
1906             if 'height_ratios' in gridspec_kw:
1907                 raise ValueError("'height_ratios' must not be defined both as "
1908                                  "parameter and as key in 'gridspec_kw'")
1909             gridspec_kw['height_ratios'] = height_ratios
1910         if width_ratios is not None:
1911             if 'width_ratios' in gridspec_kw:
1912                 raise ValueError("'width_ratios' must not be defined both as "
1913                                  "parameter and as key in 'gridspec_kw'")
1914             gridspec_kw['width_ratios'] = width_ratios
1915 
1916         # special-case string input
1917         if isinstance(mosaic, str):
1918             mosaic = self._normalize_grid_string(mosaic)
1919             per_subplot_kw = {
1920                 tuple(k): v for k, v in per_subplot_kw.items()
1921             }
1922 
1923         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1924 
1925         # Only accept strict bools to allow a possible future API expansion.
1926         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1927 
1928         def _make_array(inp):
1929             """
1930             Convert input into 2D array
1931 
1932             We need to have this internal function rather than
1933             ``np.asarray(..., dtype=object)`` so that a list of lists
1934             of lists does not get converted to an array of dimension >
1935             2
1936 
1937             Returns
1938             -------
1939             2D object array
1940 
1941             """
1942             r0, *rest = inp
1943             if isinstance(r0, str):
1944                 raise ValueError('List mosaic specification must be 2D')
1945             for j, r in enumerate(rest, start=1):
1946                 if isinstance(r, str):
1947                     raise ValueError('List mosaic specification must be 2D')
1948                 if len(r0) != len(r):
1949                     raise ValueError(
1950                         "All of the rows must be the same length, however "
1951                         f"the first row ({r0!r}) has length {len(r0)} "
1952                         f"and row {j} ({r!r}) has length {len(r)}."
1953                     )
1954             out = np.zeros((len(inp), len(r0)), dtype=object)
1955             for j, r in enumerate(inp):
1956                 for k, v in enumerate(r):
1957                     out[j, k] = v
1958             return out
1959 
1960         def _identify_keys_and_nested(mosaic):
1961             """
1962             Given a 2D object array, identify unique IDs and nested mosaics
1963 
1964             Parameters
1965             ----------
1966             mosaic : 2D numpy object array
1967 
1968             Returns
1969             -------
1970             unique_ids : tuple
1971                 The unique non-sub mosaic entries in this mosaic
1972             nested : dict[tuple[int, int]], 2D object array
1973             """
1974             # make sure we preserve the user supplied order
1975             unique_ids = cbook._OrderedSet()
1976             nested = {}
1977             for j, row in enumerate(mosaic):
1978                 for k, v in enumerate(row):
1979                     if v == empty_sentinel:
1980                         continue
1981                     elif not cbook.is_scalar_or_string(v):
1982                         nested[(j, k)] = _make_array(v)
1983                     else:
1984                         unique_ids.add(v)
1985 
1986             return tuple(unique_ids), nested
1987 
1988         def _do_layout(gs, mosaic, unique_ids, nested):
1989             """
1990             Recursively do the mosaic.
1991 
1992             Parameters
1993             ----------
1994             gs : GridSpec
1995             mosaic : 2D object array
1996                 The input converted to a 2D numpy array for this level.
1997             unique_ids : tuple
1998                 The identified scalar labels at this level of nesting.
1999             nested : dict[tuple[int, int]], 2D object array
2000                 The identified nested mosaics, if any.
2001 
2002             Returns
2003             -------
2004             dict[label, Axes]
2005                 A flat dict of all of the Axes created.
2006             """
2007             output = dict()
2008 
2009             # we need to merge together the Axes at this level and the axes
2010             # in the (recursively) nested sub-mosaics so that we can add
2011             # them to the figure in the "natural" order if you were to
2012             # ravel in c-order all of the Axes that will be created
2013             #
2014             # This will stash the upper left index of each object (axes or
2015             # nested mosaic) at this level
2016             this_level = dict()
2017 
2018             # go through the unique keys,
2019             for name in unique_ids:
2020                 # sort out where each axes starts/ends
2021                 indx = np.argwhere(mosaic == name)
2022                 start_row, start_col = np.min(indx, axis=0)
2023                 end_row, end_col = np.max(indx, axis=0) + 1
2024                 # and construct the slice object
2025                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2026                 # some light error checking
2027                 if (mosaic[slc] != name).any():
2028                     raise ValueError(
2029                         f"While trying to layout\n{mosaic!r}\n"
2030                         f"we found that the label {name!r} specifies a "
2031                         "non-rectangular or non-contiguous area.")
2032                 # and stash this slice for later
2033                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2034 
2035             # do the same thing for the nested mosaics (simpler because these
2036             # can not be spans yet!)
2037             for (j, k), nested_mosaic in nested.items():
2038                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2039 
2040             # now go through the things in this level and add them
2041             # in order left-to-right top-to-bottom
2042             for key in sorted(this_level):
2043                 name, arg, method = this_level[key]
2044                 # we are doing some hokey function dispatch here based
2045                 # on the 'method' string stashed above to sort out if this
2046                 # element is an Axes or a nested mosaic.
2047                 if method == 'axes':
2048                     slc = arg
2049                     # add a single axes
2050                     if name in output:
2051                         raise ValueError(f"There are duplicate keys {name} "
2052                                          f"in the layout\n{mosaic!r}")
2053                     ax = self.add_subplot(
2054                         gs[slc], **{
2055                             'label': str(name),
2056                             **subplot_kw,
2057                             **per_subplot_kw.get(name, {})
2058                         }
2059                     )
2060                     output[name] = ax
2061                 elif method == 'nested':
2062                     nested_mosaic = arg
2063                     j, k = key
2064                     # recursively add the nested mosaic
2065                     rows, cols = nested_mosaic.shape
2066                     nested_output = _do_layout(
2067                         gs[j, k].subgridspec(rows, cols),
2068                         nested_mosaic,
2069                         *_identify_keys_and_nested(nested_mosaic)
2070                     )
2071                     overlap = set(output) & set(nested_output)
2072                     if overlap:
2073                         raise ValueError(
2074                             f"There are duplicate keys {overlap} "
2075                             f"between the outer layout\n{mosaic!r}\n"
2076                             f"and the nested layout\n{nested_mosaic}"
2077                         )
2078                     output.update(nested_output)
2079                 else:
2080                     raise RuntimeError("This should never happen")
2081             return output
2082 
2083         mosaic = _make_array(mosaic)
2084         rows, cols = mosaic.shape
2085         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2086         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2087         ax0 = next(iter(ret.values()))
2088         for ax in ret.values():
2089             if sharex:
2090                 ax.sharex(ax0)
2091                 ax._label_outer_xaxis(check_patch=True)
2092             if sharey:
2093                 ax.sharey(ax0)
2094                 ax._label_outer_yaxis(check_patch=True)
2095         if extra := set(per_subplot_kw) - set(ret):
2096             raise ValueError(
2097                 f"The keys {extra} are in *per_subplot_kw* "
2098                 "but not in the mosaic."
2099             )
2100         return ret

</code><intended_behavior>The 'subplot_mosaic' method implementation must ensure that once a compressed layout is set up for a figure, these settings are embedded into the figure's metadata or state in a manner that they are referred to or reapplied in subsequent operations affecting the figure's layout, including saving with 'bbox_inches="tight"'. This means enhancing how layout settings are stored or referenced within a figure's lifecycle, ensuring consistency between the visualization on-screen and the saved files.</intended_behavior>]
2025-10-15 07:29:50.260 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>savefig</method>
<code>
3202     def savefig(self, fname, *, transparent=None, **kwargs):
3203         """
3204         Save the current figure.
3205 
3206         Call signature::
3207 
3208           savefig(fname, *, dpi='figure', format=None, metadata=None,
3209                   bbox_inches=None, pad_inches=0.1,
3210                   facecolor='auto', edgecolor='auto',
3211                   backend=None, **kwargs
3212                  )
3213 
3214         The available output formats depend on the backend being used.
3215 
3216         Parameters
3217         ----------
3218         fname : str or path-like or binary file-like
3219             A path, or a Python file-like object, or
3220             possibly some backend-dependent object such as
3221             `matplotlib.backends.backend_pdf.PdfPages`.
3222 
3223             If *format* is set, it determines the output format, and the file
3224             is saved as *fname*.  Note that *fname* is used verbatim, and there
3225             is no attempt to make the extension, if any, of *fname* match
3226             *format*, and no extension is appended.
3227 
3228             If *format* is not set, then the format is inferred from the
3229             extension of *fname*, if there is one.  If *format* is not
3230             set and *fname* has no extension, then the file is saved with
3231             :rc:`savefig.format` and the appropriate extension is appended to
3232             *fname*.
3233 
3234         Other Parameters
3235         ----------------
3236         dpi : float or 'figure', default: :rc:`savefig.dpi`
3237             The resolution in dots per inch.  If 'figure', use the figure's
3238             dpi value.
3239 
3240         format : str
3241             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3242             this is unset is documented under *fname*.
3243 
3244         metadata : dict, optional
3245             Key/value pairs to store in the image metadata. The supported keys
3246             and defaults depend on the image format and backend:
3247 
3248             - 'png' with Agg backend: See the parameter ``metadata`` of
3249               `~.FigureCanvasAgg.print_png`.
3250             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3251               `~.backend_pdf.PdfPages`.
3252             - 'svg' with svg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasSVG.print_svg`.
3254             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3255 
3256         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3257             Bounding box in inches: only the given portion of the figure is
3258             saved.  If 'tight', try to figure out the tight bbox of the figure.
3259 
3260         pad_inches : float, default: :rc:`savefig.pad_inches`
3261             Amount of padding around the figure when bbox_inches is 'tight'.
3262 
3263         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3264             The facecolor of the figure.  If 'auto', use the current figure
3265             facecolor.
3266 
3267         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3268             The edgecolor of the figure.  If 'auto', use the current figure
3269             edgecolor.
3270 
3271         backend : str, optional
3272             Use a non-default backend to render the file, e.g. to render a
3273             png file with the "cairo" backend rather than the default "agg",
3274             or a pdf file with the "pgf" backend rather than the default
3275             "pdf".  Note that the default backend is normally sufficient.  See
3276             :ref:`the-builtin-backends` for a list of valid backends for each
3277             file format.  Custom backends can be referenced as "module://...".
3278 
3279         orientation : {'landscape', 'portrait'}
3280             Currently only supported by the postscript backend.
3281 
3282         papertype : str
3283             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3284             'a10', 'b0' through 'b10'. Only supported for postscript
3285             output.
3286 
3287         transparent : bool
3288             If *True*, the Axes patches will all be transparent; the
3289             Figure patch will also be transparent unless *facecolor*
3290             and/or *edgecolor* are specified via kwargs.
3291 
3292             If *False* has no effect and the color of the Axes and
3293             Figure patches are unchanged (unless the Figure patch
3294             is specified via the *facecolor* and/or *edgecolor* keyword
3295             arguments in which case those colors are used).
3296 
3297             The transparency of these patches will be restored to their
3298             original values upon exit of this function.
3299 
3300             This is useful, for example, for displaying
3301             a plot on top of a colored background on a web page.
3302 
3303         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3304             A list of extra artists that will be considered when the
3305             tight bbox is calculated.
3306 
3307         pil_kwargs : dict, optional
3308             Additional keyword arguments that are passed to
3309             `PIL.Image.Image.save` when saving the figure.
3310 
3311         """
3312 
3313         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3314         if transparent is None:
3315             transparent = mpl.rcParams['savefig.transparent']
3316 
3317         with ExitStack() as stack:
3318             if transparent:
3319                 kwargs.setdefault('facecolor', 'none')
3320                 kwargs.setdefault('edgecolor', 'none')
3321                 for ax in self.axes:
3322                     stack.enter_context(
3323                         ax.patch._cm_set(facecolor='none', edgecolor='none'))
3324 
3325             self.canvas.print_figure(fname, **kwargs)

</code><intended_behavior>The method should ensure that when a figure is saved with 'bbox_inches="tight"' and using a layout set through 'subplot_mosaic' with 'layout='compressed'', the layout settings are preserved accurately across multiple save operations. This entails maintaining the figure's layout and compression settings in the figure's state, such that repeated saves do not alter the layout appearance. This requires potentially caching or reaffirming the layout configuration just before the save operation if 'bbox_inches="tight"' is used, ensuring the layout compression is applied equally across all save operations.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2326 class Figure(FigureBase):
2327     """
2328     The top level container for all the plot elements.
2329 
2330     Attributes
2331     ----------
2332     patch
2333         The `.Rectangle` instance representing the figure background patch.
2334 
2335     suppressComposite
2336         For multiple images, the figure will make composite images
2337         depending on the renderer option_image_nocomposite function.  If
2338         *suppressComposite* is a boolean, this will override the renderer.
2339     """
2340     # Remove the self._fig_callbacks properties on figure and subfigure
2341     # after the deprecation expires.
2342     callbacks = _api.deprecated(
2343         "3.6", alternative=("the 'resize_event' signal in "
2344                             "Figure.canvas.callbacks")
2345         )(property(lambda self: self._fig_callbacks))
2346 
2347     def __str__(self):
2348         return "Figure(%gx%g)" % tuple(self.bbox.size)
2349 
2350     def __repr__(self):
2351         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2352             clsname=self.__class__.__name__,
2353             h=self.bbox.size[0], w=self.bbox.size[1],
2354             naxes=len(self.axes),
2355         )
2356 
2357     @_api.make_keyword_only("3.6", "facecolor")
2358     def __init__(self,
2359                  figsize=None,
2360                  dpi=None,
2361                  facecolor=None,
2362                  edgecolor=None,
2363                  linewidth=0.0,
2364                  frameon=None,
2365                  subplotpars=None,  # rc figure.subplot.*
2366                  tight_layout=None,  # rc figure.autolayout
2367                  constrained_layout=None,  # rc figure.constrained_layout.use
2368                  *,
2369                  layout=None,
2370                  **kwargs
2371                  ):
2372         """
2373         Parameters
2374         ----------
2375         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2376             Figure dimension ``(width, height)`` in inches.
2377 
2378         dpi : float, default: :rc:`figure.dpi`
2379             Dots per inch.
2380 
2381         facecolor : default: :rc:`figure.facecolor`
2382             The figure patch facecolor.
2383 
2384         edgecolor : default: :rc:`figure.edgecolor`
2385             The figure patch edge color.
2386 
2387         linewidth : float
2388             The linewidth of the frame (i.e. the edge linewidth of the figure
2389             patch).
2390 
2391         frameon : bool, default: :rc:`figure.frameon`
2392             If ``False``, suppress drawing the figure background patch.
2393 
2394         subplotpars : `SubplotParams`
2395             Subplot parameters. If not given, the default subplot
2396             parameters :rc:`figure.subplot.*` are used.
2397 
2398         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2399             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2400 
2401             .. admonition:: Discouraged
2402 
2403                 The use of this parameter is discouraged. Please use
2404                 ``layout='tight'`` instead for the common case of
2405                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2406 
2407         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2408             This is equal to ``layout='constrained'``.
2409 
2410             .. admonition:: Discouraged
2411 
2412                 The use of this parameter is discouraged. Please use
2413                 ``layout='constrained'`` instead.
2414 
2415         layout : {'constrained', 'compressed', 'tight', `.LayoutEngine`, None}
2416             The layout mechanism for positioning of plot elements to avoid
2417             overlapping Axes decorations (labels, ticks, etc). Note that
2418             layout managers can have significant performance penalties.
2419             Defaults to *None*.
2420 
2421             - 'constrained': The constrained layout solver adjusts axes sizes
2422                to avoid overlapping axes decorations.  Can handle complex plot
2423                layouts and colorbars, and is thus recommended.
2424 
2425               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2426               for examples.
2427 
2428             - 'compressed': uses the same algorithm as 'constrained', but
2429               removes extra space between fixed-aspect-ratio Axes.  Best for
2430               simple grids of axes.
2431 
2432             - 'tight': Use the tight layout mechanism. This is a relatively
2433               simple algorithm that adjusts the subplot parameters so that
2434               decorations do not overlap. See `.Figure.set_tight_layout` for
2435               further details.
2436 
2437             - A `.LayoutEngine` instance. Builtin layout classes are
2438               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2439               accessible by 'constrained' and 'tight'.  Passing an instance
2440               allows third parties to provide their own layout engine.
2441 
2442             If not given, fall back to using the parameters *tight_layout* and
2443             *constrained_layout*, including their config defaults
2444             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2445 
2446         Other Parameters
2447         ----------------
2448         **kwargs : `.Figure` properties, optional
2449 
2450             %(Figure:kwdoc)s
2451         """
2452         super().__init__(**kwargs)
2453         self._layout_engine = None
2454 
2455         if layout is not None:
2456             if (tight_layout is not None):
2457                 _api.warn_external(
2458                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2459                     "be used together. Please use 'layout' only.")
2460             if (constrained_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'constrained_layout' "
2463                     "cannot be used together. Please use 'layout' only.")
2464             self.set_layout_engine(layout=layout)
2465         elif tight_layout is not None:
2466             if constrained_layout is not None:
2467                 _api.warn_external(
2468                     "The Figure parameters 'tight_layout' and "
2469                     "'constrained_layout' cannot be used together. Please use "
2470                     "'layout' parameter")
2471             self.set_layout_engine(layout='tight')
2472             if isinstance(tight_layout, dict):
2473                 self.get_layout_engine().set(**tight_layout)
2474         elif constrained_layout is not None:
2475             if isinstance(constrained_layout, dict):
2476                 self.set_layout_engine(layout='constrained')
2477                 self.get_layout_engine().set(**constrained_layout)
2478             elif constrained_layout:
2479                 self.set_layout_engine(layout='constrained')
2480 
2481         else:
2482             # everything is None, so use default:
2483             self.set_layout_engine(layout=layout)
2484 
2485         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2486         # Callbacks traditionally associated with the canvas (and exposed with
2487         # a proxy property), but that actually need to be on the figure for
2488         # pickling.
2489         self._canvas_callbacks = cbook.CallbackRegistry(
2490             signals=FigureCanvasBase.events)
2491         connect = self._canvas_callbacks._connect_picklable
2492         self._mouse_key_ids = [
2493             connect('key_press_event', backend_bases._key_handler),
2494             connect('key_release_event', backend_bases._key_handler),
2495             connect('key_release_event', backend_bases._key_handler),
2496             connect('button_press_event', backend_bases._mouse_handler),
2497             connect('button_release_event', backend_bases._mouse_handler),
2498             connect('scroll_event', backend_bases._mouse_handler),
2499             connect('motion_notify_event', backend_bases._mouse_handler),
2500         ]
2501         self._button_pick_id = connect('button_press_event', self.pick)
2502         self._scroll_pick_id = connect('scroll_event', self.pick)
2503 
2504         if figsize is None:
2505             figsize = mpl.rcParams['figure.figsize']
2506         if dpi is None:
2507             dpi = mpl.rcParams['figure.dpi']
2508         if facecolor is None:
2509             facecolor = mpl.rcParams['figure.facecolor']
2510         if edgecolor is None:
2511             edgecolor = mpl.rcParams['figure.edgecolor']
2512         if frameon is None:
2513             frameon = mpl.rcParams['figure.frameon']
2514 
2515         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2516             raise ValueError('figure size must be positive finite not '
2517                              f'{figsize}')
2518         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2519 
2520         self.dpi_scale_trans = Affine2D().scale(dpi)
2521         # do not use property as it will trigger
2522         self._dpi = dpi
2523         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2524         self.figbbox = self.bbox
2525         self.transFigure = BboxTransformTo(self.bbox)
2526         self.transSubfigure = self.transFigure
2527 
2528         self.patch = Rectangle(
2529             xy=(0, 0), width=1, height=1, visible=frameon,
2530             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2531             # Don't let the figure patch influence bbox calculation.
2532             in_layout=False)
2533         self._set_artist_props(self.patch)
2534         self.patch.set_antialiased(False)
2535 
2536         FigureCanvasBase(self)  # Set self.canvas.
2537 
2538         if subplotpars is None:
2539             subplotpars = SubplotParams()
2540 
2541         self.subplotpars = subplotpars
2542 
2543         self._axstack = _AxesStack()  # track all figure axes and current axes
2544         self.clear()
2545 
2546     def pick(self, mouseevent):
2547         if not self.canvas.widgetlock.locked():
2548             super().pick(mouseevent)
2549 
2550     def _check_layout_engines_compat(self, old, new):
2551         """
2552         Helper for set_layout engine
2553 
2554         If the figure has used the old engine and added a colorbar then the
2555         value of colorbar_gridspec must be the same on the new engine.
2556         """
2557         if old is None or new is None:
2558             return True
2559         if old.colorbar_gridspec == new.colorbar_gridspec:
2560             return True
2561         # colorbar layout different, so check if any colorbars are on the
2562         # figure...
2563         for ax in self.axes:
2564             if hasattr(ax, '_colorbar'):
2565                 # colorbars list themselves as a colorbar.
2566                 return False
2567         return True
2568 
2569     def set_layout_engine(self, layout=None, **kwargs):
2570         """
2571         Set the layout engine for this figure.
2572 
2573         Parameters
2574         ----------
2575         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2576 `LayoutEngine` or None
2577 
2578             - 'constrained' will use `~.ConstrainedLayoutEngine`
2579             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2580               a correction that attempts to make a good layout for fixed-aspect
2581               ratio Axes.
2582             - 'tight' uses `~.TightLayoutEngine`
2583             - 'none' removes layout engine.
2584 
2585             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2586             (which if `True` behaves as if 'tight' was passed) and
2587             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2588             'constrained' was passed).  If both are `True`,
2589             :rc:`figure.autolayout` takes priority.
2590 
2591             Users and libraries can define their own layout engines and pass
2592             the instance directly as well.
2593 
2594         kwargs: dict
2595             The keyword arguments are passed to the layout engine to set things
2596             like padding and margin sizes.  Only used if *layout* is a string.
2597 
2598         """
2599         if layout is None:
2600             if mpl.rcParams['figure.autolayout']:
2601                 layout = 'tight'
2602             elif mpl.rcParams['figure.constrained_layout.use']:
2603                 layout = 'constrained'
2604             else:
2605                 self._layout_engine = None
2606                 return
2607         if layout == 'tight':
2608             new_layout_engine = TightLayoutEngine(**kwargs)
2609         elif layout == 'constrained':
2610             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2611         elif layout == 'compressed':
2612             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2613                                                         **kwargs)
2614         elif layout == 'none':
2615             if self._layout_engine is not None:
2616                 new_layout_engine = PlaceHolderLayoutEngine(
2617                     self._layout_engine.adjust_compatible,
2618                     self._layout_engine.colorbar_gridspec
2619                 )
2620             else:
2621                 new_layout_engine = None
2622         elif isinstance(layout, LayoutEngine):
2623             new_layout_engine = layout
2624         else:
2625             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2626 
2627         if self._check_layout_engines_compat(self._layout_engine,
2628                                              new_layout_engine):
2629             self._layout_engine = new_layout_engine
2630         else:
2631             raise RuntimeError('Colorbar layout of new layout engine not '
2632                                'compatible with old engine, and a colorbar '
2633                                'has been created.  Engine not changed.')
2634 
2635     def get_layout_engine(self):
2636         return self._layout_engine
2637 
2638     # TODO: I'd like to dynamically add the _repr_html_ method
2639     # to the figure in the right context, but then IPython doesn't
2640     # use it, for some reason.
2641 
2642     def _repr_html_(self):
2643         # We can't use "isinstance" here, because then we'd end up importing
2644         # webagg unconditionally.
2645         if 'WebAgg' in type(self.canvas).__name__:
2646             from matplotlib.backends import backend_webagg
2647             return backend_webagg.ipython_inline_display(self)
2648 
2649     def show(self, warn=True):
2650         """
2651         If using a GUI backend with pyplot, display the figure window.
2652 
2653         If the figure was not created using `~.pyplot.figure`, it will lack
2654         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2655         AttributeError.
2656 
2657         .. warning::
2658 
2659             This does not manage an GUI event loop. Consequently, the figure
2660             may only be shown briefly or not shown at all if you or your
2661             environment are not managing an event loop.
2662 
2663             Use cases for `.Figure.show` include running this from a GUI
2664             application (where there is persistently an event loop running) or
2665             from a shell, like IPython, that install an input hook to allow the
2666             interactive shell to accept input while the figure is also being
2667             shown and interactive.  Some, but not all, GUI toolkits will
2668             register an input hook on import.  See :ref:`cp_integration` for
2669             more details.
2670 
2671             If you're in a shell without input hook integration or executing a
2672             python script, you should use `matplotlib.pyplot.show` with
2673             ``block=True`` instead, which takes care of starting and running
2674             the event loop for you.
2675 
2676         Parameters
2677         ----------
2678         warn : bool, default: True
2679             If ``True`` and we are not running headless (i.e. on Linux with an
2680             unset DISPLAY), issue warning when called on a non-GUI backend.
2681 
2682         """
2683         if self.canvas.manager is None:
2684             raise AttributeError(
2685                 "Figure.show works only for figures managed by pyplot, "
2686                 "normally created by pyplot.figure()")
2687         try:
2688             self.canvas.manager.show()
2689         except NonGuiException as exc:
2690             if warn:
2691                 _api.warn_external(str(exc))
2692 
2693     @property
2694     def axes(self):
2695         """
2696         List of Axes in the Figure. You can access and modify the Axes in the
2697         Figure through this list.
2698 
2699         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2700         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2701 
2702         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2703         equivalent.
2704         """
2705         return self._axstack.as_list()
2706 
2707     get_axes = axes.fget
2708 
2709     def _get_renderer(self):
2710         if hasattr(self.canvas, 'get_renderer'):
2711             return self.canvas.get_renderer()
2712         else:
2713             return _get_renderer(self)
2714 
2715     def _get_dpi(self):
2716         return self._dpi
2717 
2718     def _set_dpi(self, dpi, forward=True):
2719         """
2720         Parameters
2721         ----------
2722         dpi : float
2723 
2724         forward : bool
2725             Passed on to `~.Figure.set_size_inches`
2726         """
2727         if dpi == self._dpi:
2728             # We don't want to cause undue events in backends.
2729             return
2730         self._dpi = dpi
2731         self.dpi_scale_trans.clear().scale(dpi)
2732         w, h = self.get_size_inches()
2733         self.set_size_inches(w, h, forward=forward)
2734         self._fig_callbacks.process('dpi_changed', self)
2735 
2736     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2737 
2738     def get_tight_layout(self):
2739         """Return whether `.tight_layout` is called when drawing."""
2740         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2741 
2742     @_api.deprecated("3.6", alternative="set_layout_engine",
2743                      pending=True)
2744     def set_tight_layout(self, tight):
2745         """
2746         [*Discouraged*] Set whether and how `.tight_layout` is called when
2747         drawing.
2748 
2749         .. admonition:: Discouraged
2750 
2751             This method is discouraged in favor of `~.set_layout_engine`.
2752 
2753         Parameters
2754         ----------
2755         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2756             If a bool, sets whether to call `.tight_layout` upon drawing.
2757             If ``None``, use :rc:`figure.autolayout` instead.
2758             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2759             default paddings.
2760         """
2761         if tight is None:
2762             tight = mpl.rcParams['figure.autolayout']
2763         _tight = 'tight' if bool(tight) else 'none'
2764         _tight_parameters = tight if isinstance(tight, dict) else {}
2765         self.set_layout_engine(_tight, **_tight_parameters)
2766         self.stale = True
2767 
2768     def get_constrained_layout(self):
2769         """
2770         Return whether constrained layout is being used.
2771 
2772         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2773         """
2774         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2775 
2776     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2777                      pending=True)
2778     def set_constrained_layout(self, constrained):
2779         """
2780         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2781         drawing.
2782 
2783         If None, :rc:`figure.constrained_layout.use` value will be used.
2784 
2785         When providing a dict containing the keys ``w_pad``, ``h_pad``
2786         the default ``constrained_layout`` paddings will be
2787         overridden.  These pads are in inches and default to 3.0/72.0.
2788         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2789 
2790         .. admonition:: Discouraged
2791 
2792             This method is discouraged in favor of `~.set_layout_engine`.
2793 
2794         Parameters
2795         ----------
2796         constrained : bool or dict or None
2797         """
2798         if constrained is None:
2799             constrained = mpl.rcParams['figure.constrained_layout.use']
2800         _constrained = 'constrained' if bool(constrained) else 'none'
2801         _parameters = constrained if isinstance(constrained, dict) else {}
2802         self.set_layout_engine(_constrained, **_parameters)
2803         self.stale = True
2804 
2805     @_api.deprecated(
2806          "3.6", alternative="figure.get_layout_engine().set()",
2807          pending=True)
2808     def set_constrained_layout_pads(self, **kwargs):
2809         """
2810         Set padding for ``constrained_layout``.
2811 
2812         Tip: The parameters can be passed from a dictionary by using
2813         ``fig.set_constrained_layout(**pad_dict)``.
2814 
2815         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2816 
2817         Parameters
2818         ----------
2819         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2820             Width padding in inches.  This is the pad around Axes
2821             and is meant to make sure there is enough room for fonts to
2822             look good.  Defaults to 3 pts = 0.04167 inches
2823 
2824         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2825             Height padding in inches. Defaults to 3 pts.
2826 
2827         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2828             Width padding between subplots, expressed as a fraction of the
2829             subplot width.  The total padding ends up being w_pad + wspace.
2830 
2831         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2832             Height padding between subplots, expressed as a fraction of the
2833             subplot width. The total padding ends up being h_pad + hspace.
2834 
2835         """
2836         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2837             self.get_layout_engine().set(**kwargs)
2838 
2839     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2840                      pending=True)
2841     def get_constrained_layout_pads(self, relative=False):
2842         """
2843         Get padding for ``constrained_layout``.
2844 
2845         Returns a list of ``w_pad, h_pad`` in inches and
2846         ``wspace`` and ``hspace`` as fractions of the subplot.
2847         All values are None if ``constrained_layout`` is not used.
2848 
2849         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2850 
2851         Parameters
2852         ----------
2853         relative : bool
2854             If `True`, then convert from inches to figure relative.
2855         """
2856         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2857             return None, None, None, None
2858         info = self.get_layout_engine().get_info()
2859         w_pad = info['w_pad']
2860         h_pad = info['h_pad']
2861         wspace = info['wspace']
2862         hspace = info['hspace']
2863 
2864         if relative and (w_pad is not None or h_pad is not None):
2865             renderer = self._get_renderer()
2866             dpi = renderer.dpi
2867             w_pad = w_pad * dpi / renderer.width
2868             h_pad = h_pad * dpi / renderer.height
2869 
2870         return w_pad, h_pad, wspace, hspace
2871 
2872     def set_canvas(self, canvas):
2873         """
2874         Set the canvas that contains the figure
2875 
2876         Parameters
2877         ----------
2878         canvas : FigureCanvas
2879         """
2880         self.canvas = canvas
2881 
2882     @_docstring.interpd
2883     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2884                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2885         """
2886         Add a non-resampled image to the figure.
2887 
2888         The image is attached to the lower or upper left corner depending on
2889         *origin*.
2890 
2891         Parameters
2892         ----------
2893         X
2894             The image data. This is an array of one of the following shapes:
2895 
2896             - (M, N): an image with scalar data.  Color-mapping is controlled
2897               by *cmap*, *norm*, *vmin*, and *vmax*.
2898             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2899             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2900               i.e. including transparency.
2901 
2902         xo, yo : int
2903             The *x*/*y* image offset in pixels.
2904 
2905         alpha : None or float
2906             The alpha blending value.
2907 
2908         %(cmap_doc)s
2909 
2910             This parameter is ignored if *X* is RGB(A).
2911 
2912         %(norm_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(vmin_vmax_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2921             Indicates where the [0, 0] index of the array is in the upper left
2922             or lower left corner of the axes.
2923 
2924         resize : bool
2925             If *True*, resize the figure to match the given image size.
2926 
2927         Returns
2928         -------
2929         `matplotlib.image.FigureImage`
2930 
2931         Other Parameters
2932         ----------------
2933         **kwargs
2934             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2935 
2936         Notes
2937         -----
2938         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2939         which will be resampled to fit the current Axes.  If you want
2940         a resampled image to fill the entire figure, you can define an
2941         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2942 
2943         Examples
2944         --------
2945         ::
2946 
2947             f = plt.figure()
2948             nx = int(f.get_figwidth() * f.dpi)
2949             ny = int(f.get_figheight() * f.dpi)
2950             data = np.random.random((ny, nx))
2951             f.figimage(data)
2952             plt.show()
2953         """
2954         if resize:
2955             dpi = self.get_dpi()
2956             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2957             self.set_size_inches(figsize, forward=True)
2958 
2959         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2960                                 offsetx=xo, offsety=yo,
2961                                 origin=origin, **kwargs)
2962         im.stale_callback = _stale_figure_callback
2963 
2964         im.set_array(X)
2965         im.set_alpha(alpha)
2966         if norm is None:
2967             im.set_clim(vmin, vmax)
2968         self.images.append(im)
2969         im._remove_method = self.images.remove
2970         self.stale = True
2971         return im
2972 
2973     def set_size_inches(self, w, h=None, forward=True):
2974         """
2975         Set the figure size in inches.
2976 
2977         Call signatures::
2978 
2979              fig.set_size_inches(w, h)  # OR
2980              fig.set_size_inches((w, h))
2981 
2982         Parameters
2983         ----------
2984         w : (float, float) or float
2985             Width and height in inches (if height not specified as a separate
2986             argument) or width.
2987         h : float
2988             Height in inches.
2989         forward : bool, default: True
2990             If ``True``, the canvas size is automatically updated, e.g.,
2991             you can resize the figure window from the shell.
2992 
2993         See Also
2994         --------
2995         matplotlib.figure.Figure.get_size_inches
2996         matplotlib.figure.Figure.set_figwidth
2997         matplotlib.figure.Figure.set_figheight
2998 
2999         Notes
3000         -----
3001         To transform from pixels to inches divide by `Figure.dpi`.
3002         """
3003         if h is None:  # Got called with a single pair as argument.
3004             w, h = w
3005         size = np.array([w, h])
3006         if not np.isfinite(size).all() or (size < 0).any():
3007             raise ValueError(f'figure size must be positive finite not {size}')
3008         self.bbox_inches.p1 = size
3009         if forward:
3010             manager = self.canvas.manager
3011             if manager is not None:
3012                 manager.resize(*(size * self.dpi).astype(int))
3013         self.stale = True
3014 
3015     def get_size_inches(self):
3016         """
3017         Return the current size of the figure in inches.
3018 
3019         Returns
3020         -------
3021         ndarray
3022            The size (width, height) of the figure in inches.
3023 
3024         See Also
3025         --------
3026         matplotlib.figure.Figure.set_size_inches
3027         matplotlib.figure.Figure.get_figwidth
3028         matplotlib.figure.Figure.get_figheight
3029 
3030         Notes
3031         -----
3032         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3033         """
3034         return np.array(self.bbox_inches.p1)
3035 
3036     def get_figwidth(self):
3037         """Return the figure width in inches."""
3038         return self.bbox_inches.width
3039 
3040     def get_figheight(self):
3041         """Return the figure height in inches."""
3042         return self.bbox_inches.height
3043 
3044     def get_dpi(self):
3045         """Return the resolution in dots per inch as a float."""
3046         return self.dpi
3047 
3048     def set_dpi(self, val):
3049         """
3050         Set the resolution of the figure in dots-per-inch.
3051 
3052         Parameters
3053         ----------
3054         val : float
3055         """
3056         self.dpi = val
3057         self.stale = True
3058 
3059     def set_figwidth(self, val, forward=True):
3060         """
3061         Set the width of the figure in inches.
3062 
3063         Parameters
3064         ----------
3065         val : float
3066         forward : bool
3067             See `set_size_inches`.
3068 
3069         See Also
3070         --------
3071         matplotlib.figure.Figure.set_figheight
3072         matplotlib.figure.Figure.set_size_inches
3073         """
3074         self.set_size_inches(val, self.get_figheight(), forward=forward)
3075 
3076     def set_figheight(self, val, forward=True):
3077         """
3078         Set the height of the figure in inches.
3079 
3080         Parameters
3081         ----------
3082         val : float
3083         forward : bool
3084             See `set_size_inches`.
3085 
3086         See Also
3087         --------
3088         matplotlib.figure.Figure.set_figwidth
3089         matplotlib.figure.Figure.set_size_inches
3090         """
3091         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3092 
3093     def clear(self, keep_observers=False):
3094         # docstring inherited
3095         super().clear(keep_observers=keep_observers)
3096         # FigureBase.clear does not clear toolbars, as
3097         # only Figure can have toolbars
3098         toolbar = self.canvas.toolbar
3099         if toolbar is not None:
3100             toolbar.update()
3101 
3102     @_finalize_rasterization
3103     @allow_rasterization
3104     def draw(self, renderer):
3105         # docstring inherited
3106 
3107         # draw the figure bounding box, perhaps none for white figure
3108         if not self.get_visible():
3109             return
3110 
3111         artists = self._get_draw_artists(renderer)
3112         try:
3113             renderer.open_group('figure', gid=self.get_gid())
3114             if self.axes and self.get_layout_engine() is not None:
3115                 try:
3116                     self.get_layout_engine().execute(self)
3117                 except ValueError:
3118                     pass
3119                     # ValueError can occur when resizing a window.
3120 
3121             self.patch.draw(renderer)
3122             mimage._draw_list_compositing_images(
3123                 renderer, self, artists, self.suppressComposite)
3124 
3125             for sfig in self.subfigs:
3126                 sfig.draw(renderer)
3127 
3128             renderer.close_group('figure')
3129         finally:
3130             self.stale = False
3131 
3132         DrawEvent("draw_event", self.canvas, renderer)._process()
3133 
3134     def draw_without_rendering(self):
3135         """
3136         Draw the figure with no output.  Useful to get the final size of
3137         artists that require a draw before their size is known (e.g. text).
3138         """
3139         renderer = _get_renderer(self)
3140         with renderer._draw_disabled():
3141             self.draw(renderer)
3142 
3143     def draw_artist(self, a):
3144         """
3145         Draw `.Artist` *a* only.
3146         """
3147         a.draw(self.canvas.get_renderer())
3148 
3149     def __getstate__(self):
3150         state = super().__getstate__()
3151 
3152         # The canvas cannot currently be pickled, but this has the benefit
3153         # of meaning that a figure can be detached from one canvas, and
3154         # re-attached to another.
3155         state.pop("canvas")
3156 
3157         # discard any changes to the dpi due to pixel ratio changes
3158         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3159 
3160         # add version information to the state
3161         state['__mpl_version__'] = mpl.__version__
3162 
3163         # check whether the figure manager (if any) is registered with pyplot
3164         from matplotlib import _pylab_helpers
3165         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3166             state['_restore_to_pylab'] = True
3167         return state
3168 
3169     def __setstate__(self, state):
3170         version = state.pop('__mpl_version__')
3171         restore_to_pylab = state.pop('_restore_to_pylab', False)
3172 
3173         if version != mpl.__version__:
3174             _api.warn_external(
3175                 f"This figure was saved with matplotlib version {version} and "
3176                 f"is unlikely to function correctly.")
3177 
3178         self.__dict__ = state
3179 
3180         # re-initialise some of the unstored state information
3181         FigureCanvasBase(self)  # Set self.canvas.
3182 
3183         if restore_to_pylab:
3184             # lazy import to avoid circularity
3185             import matplotlib.pyplot as plt
3186             import matplotlib._pylab_helpers as pylab_helpers
3187             allnums = plt.get_fignums()
3188             num = max(allnums) + 1 if allnums else 1
3189             backend = plt._get_backend_mod()
3190             mgr = backend.new_figure_manager_given_figure(num, self)
3191             pylab_helpers.Gcf._set_new_active_manager(mgr)
3192             plt.draw_if_interactive()
3193 
3194         self.stale = True
3195 
3196     def add_axobserver(self, func):
3197         """Whenever the Axes state change, ``func(self)`` will be called."""
3198         # Connect a wrapper lambda and not func itself, to avoid it being
3199         # weakref-collected.
3200         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3201 
3202     def savefig(self, fname, *, transparent=None, **kwargs):
3203         """
3204         Save the current figure.
3205 
3206         Call signature::
3207 
3208           savefig(fname, *, dpi='figure', format=None, metadata=None,
3209                   bbox_inches=None, pad_inches=0.1,
3210                   facecolor='auto', edgecolor='auto',
3211                   backend=None, **kwargs
3212                  )
3213 
3214         The available output formats depend on the backend being used.
3215 
3216         Parameters
3217         ----------
3218         fname : str or path-like or binary file-like
3219             A path, or a Python file-like object, or
3220             possibly some backend-dependent object such as
3221             `matplotlib.backends.backend_pdf.PdfPages`.
3222 
3223             If *format* is set, it determines the output format, and the file
3224             is saved as *fname*.  Note that *fname* is used verbatim, and there
3225             is no attempt to make the extension, if any, of *fname* match
3226             *format*, and no extension is appended.
3227 
3228             If *format* is not set, then the format is inferred from the
3229             extension of *fname*, if there is one.  If *format* is not
3230             set and *fname* has no extension, then the file is saved with
3231             :rc:`savefig.format` and the appropriate extension is appended to
3232             *fname*.
3233 
3234         Other Parameters
3235         ----------------
3236         dpi : float or 'figure', default: :rc:`savefig.dpi`
3237             The resolution in dots per inch.  If 'figure', use the figure's
3238             dpi value.
3239 
3240         format : str
3241             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3242             this is unset is documented under *fname*.
3243 
3244         metadata : dict, optional
3245             Key/value pairs to store in the image metadata. The supported keys
3246             and defaults depend on the image format and backend:
3247 
3248             - 'png' with Agg backend: See the parameter ``metadata`` of
3249               `~.FigureCanvasAgg.print_png`.
3250             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3251               `~.backend_pdf.PdfPages`.
3252             - 'svg' with svg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasSVG.print_svg`.
3254             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3255 
3256         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3257             Bounding box in inches: only the given portion of the figure is
3258             saved.  If 'tight', try to figure out the tight bbox of the figure.
3259 
3260         pad_inches : float, default: :rc:`savefig.pad_inches`
3261             Amount of padding around the figure when bbox_inches is 'tight'.
3262 
3263         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3264             The facecolor of the figure.  If 'auto', use the current figure
3265             facecolor.
3266 
3267         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3268             The edgecolor of the figure.  If 'auto', use the current figure
3269             edgecolor.
3270 
3271         backend : str, optional
3272             Use a non-default backend to render the file, e.g. to render a
3273             png file with the "cairo" backend rather than the default "agg",
3274             or a pdf file with the "pgf" backend rather than the default
3275             "pdf".  Note that the default backend is normally sufficient.  See
3276             :ref:`the-builtin-backends` for a list of valid backends for each
3277             file format.  Custom backends can be referenced as "module://...".
3278 
3279         orientation : {'landscape', 'portrait'}
3280             Currently only supported by the postscript backend.
3281 
3282         papertype : str
3283             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3284             'a10', 'b0' through 'b10'. Only supported for postscript
3285             output.
3286 
3287         transparent : bool
3288             If *True*, the Axes patches will all be transparent; the
3289             Figure patch will also be transparent unless *facecolor*
3290             and/or *edgecolor* are specified via kwargs.
3291 
3292             If *False* has no effect and the color of the Axes and
3293             Figure patches are unchanged (unless the Figure patch
3294             is specified via the *facecolor* and/or *edgecolor* keyword
3295             arguments in which case those colors are used).
3296 
3297             The transparency of these patches will be restored to their
3298             original values upon exit of this function.
3299 
3300             This is useful, for example, for displaying
3301             a plot on top of a colored background on a web page.
3302 
3303         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3304             A list of extra artists that will be considered when the
3305             tight bbox is calculated.
3306 
3307         pil_kwargs : dict, optional
3308             Additional keyword arguments that are passed to
3309             `PIL.Image.Image.save` when saving the figure.
3310 
3311         """
3312 
3313         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3314         if transparent is None:
3315             transparent = mpl.rcParams['savefig.transparent']
3316 
3317         with ExitStack() as stack:
3318             if transparent:
3319                 kwargs.setdefault('facecolor', 'none')
3320                 kwargs.setdefault('edgecolor', 'none')
3321                 for ax in self.axes:
3322                     stack.enter_context(
3323                         ax.patch._cm_set(facecolor='none', edgecolor='none'))
3324 
3325             self.canvas.print_figure(fname, **kwargs)
3326 
3327     def ginput(self, n=1, timeout=30, show_clicks=True,
3328                mouse_add=MouseButton.LEFT,
3329                mouse_pop=MouseButton.RIGHT,
3330                mouse_stop=MouseButton.MIDDLE):
3331         """
3332         Blocking call to interact with a figure.
3333 
3334         Wait until the user clicks *n* times on the figure, and return the
3335         coordinates of each click in a list.
3336 
3337         There are three possible interactions:
3338 
3339         - Add a point.
3340         - Remove the most recently added point.
3341         - Stop the interaction and return the points added so far.
3342 
3343         The actions are assigned to mouse buttons via the arguments
3344         *mouse_add*, *mouse_pop* and *mouse_stop*.
3345 
3346         Parameters
3347         ----------
3348         n : int, default: 1
3349             Number of mouse clicks to accumulate. If negative, accumulate
3350             clicks until the input is terminated manually.
3351         timeout : float, default: 30 seconds
3352             Number of seconds to wait before timing out. If zero or negative
3353             will never time out.
3354         show_clicks : bool, default: True
3355             If True, show a red cross at the location of each click.
3356         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3357             Mouse button used to add points.
3358         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3359             Mouse button used to remove the most recently added point.
3360         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3361             Mouse button used to stop input.
3362 
3363         Returns
3364         -------
3365         list of tuples
3366             A list of the clicked (x, y) coordinates.
3367 
3368         Notes
3369         -----
3370         The keyboard can also be used to select points in case your mouse
3371         does not have one or more of the buttons.  The delete and backspace
3372         keys act like right-clicking (i.e., remove last point), the enter key
3373         terminates input and any other key (not already used by the window
3374         manager) selects a point.
3375         """
3376         clicks = []
3377         marks = []
3378 
3379         def handler(event):
3380             is_button = event.name == "button_press_event"
3381             is_key = event.name == "key_press_event"
3382             # Quit (even if not in infinite mode; this is consistent with
3383             # MATLAB and sometimes quite useful, but will require the user to
3384             # test how many points were actually returned before using data).
3385             if (is_button and event.button == mouse_stop
3386                     or is_key and event.key in ["escape", "enter"]):
3387                 self.canvas.stop_event_loop()
3388             # Pop last click.
3389             elif (is_button and event.button == mouse_pop
3390                   or is_key and event.key in ["backspace", "delete"]):
3391                 if clicks:
3392                     clicks.pop()
3393                     if show_clicks:
3394                         marks.pop().remove()
3395                         self.canvas.draw()
3396             # Add new click.
3397             elif (is_button and event.button == mouse_add
3398                   # On macOS/gtk, some keys return None.
3399                   or is_key and event.key is not None):
3400                 if event.inaxes:
3401                     clicks.append((event.xdata, event.ydata))
3402                     _log.info("input %i: %f, %f",
3403                               len(clicks), event.xdata, event.ydata)
3404                     if show_clicks:
3405                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3406                                                 marker="+", color="r")
3407                         event.inaxes.add_line(line)
3408                         marks.append(line)
3409                         self.canvas.draw()
3410             if len(clicks) == n and n > 0:
3411                 self.canvas.stop_event_loop()
3412 
3413         _blocking_input.blocking_input_loop(
3414             self, ["button_press_event", "key_press_event"], timeout, handler)
3415 
3416         # Cleanup.
3417         for mark in marks:
3418             mark.remove()
3419         self.canvas.draw()
3420 
3421         return clicks
3422 
3423     def waitforbuttonpress(self, timeout=-1):
3424         """
3425         Blocking call to interact with the figure.
3426 
3427         Wait for user input and return True if a key was pressed, False if a
3428         mouse button was pressed and None if no input was given within
3429         *timeout* seconds.  Negative values deactivate *timeout*.
3430         """
3431         event = None
3432 
3433         def handler(ev):
3434             nonlocal event
3435             event = ev
3436             self.canvas.stop_event_loop()
3437 
3438         _blocking_input.blocking_input_loop(
3439             self, ["button_press_event", "key_press_event"], timeout, handler)
3440 
3441         return None if event is None else event.name == "key_press_event"
3442 
3443     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3444     def execute_constrained_layout(self, renderer=None):
3445         """
3446         Use ``layoutgrid`` to determine pos positions within Axes.
3447 
3448         See also `.set_constrained_layout_pads`.
3449 
3450         Returns
3451         -------
3452         layoutgrid : private debugging object
3453         """
3454         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3455             return None
3456         return self.get_layout_engine().execute(self)
3457 
3458     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3459         """
3460         Adjust the padding between and around subplots.
3461 
3462         To exclude an artist on the Axes from the bounding box calculation
3463         that determines the subplot parameters (i.e. legend, or annotation),
3464         set ``a.set_in_layout(False)`` for that artist.
3465 
3466         Parameters
3467         ----------
3468         pad : float, default: 1.08
3469             Padding between the figure edge and the edges of subplots,
3470             as a fraction of the font size.
3471         h_pad, w_pad : float, default: *pad*
3472             Padding (height/width) between edges of adjacent subplots,
3473             as a fraction of the font size.
3474         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3475             A rectangle in normalized figure coordinates into which the whole
3476             subplots area (including labels) will fit.
3477 
3478         See Also
3479         --------
3480         .Figure.set_layout_engine
3481         .pyplot.tight_layout
3482         """
3483         # note that here we do not permanently set the figures engine to
3484         # tight_layout but rather just perform the layout in place and remove
3485         # any previous engines.
3486         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3487                                    rect=rect)
3488         try:
3489             previous_engine = self.get_layout_engine()
3490             self.set_layout_engine(engine)
3491             engine.execute(self)
3492             if not isinstance(previous_engine, TightLayoutEngine) \
3493                     and previous_engine is not None:
3494                 _api.warn_external('The figure layout has changed to tight')
3495         finally:
3496             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>subplot_mosaic</method>
<code>
1791     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1792                        width_ratios=None, height_ratios=None,
1793                        empty_sentinel='.',
1794                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1795         """
1796         Build a layout of Axes based on ASCII art or nested lists.
1797 
1798         This is a helper function to build complex GridSpec layouts visually.
1799 
1800         See :doc:`/gallery/subplots_axes_and_figures/mosaic`
1801         for an example and full API documentation
1802 
1803         Parameters
1804         ----------
1805         mosaic : list of list of {hashable or nested} or str
1806 
1807             A visual layout of how you want your Axes to be arranged
1808             labeled as strings.  For example ::
1809 
1810                x = [['A panel', 'A panel', 'edge'],
1811                     ['C panel', '.',       'edge']]
1812 
1813             produces 4 Axes:
1814 
1815             - 'A panel' which is 1 row high and spans the first two columns
1816             - 'edge' which is 2 rows high and is on the right edge
1817             - 'C panel' which in 1 row and 1 column wide in the bottom left
1818             - a blank space 1 row and 1 column wide in the bottom center
1819 
1820             Any of the entries in the layout can be a list of lists
1821             of the same form to create nested layouts.
1822 
1823             If input is a str, then it can either be a multi-line string of
1824             the form ::
1825 
1826               '''
1827               AAE
1828               C.E
1829               '''
1830 
1831             where each character is a column and each line is a row. Or it
1832             can be a single-line string where rows are separated by ``;``::
1833 
1834               'AB;CC'
1835 
1836             The string notation allows only single character Axes labels and
1837             does not support nesting but is very terse.
1838 
1839             The Axes identifiers may be `str` or a non-iterable hashable
1840             object (e.g. `tuple` s may not be used).
1841 
1842         sharex, sharey : bool, default: False
1843             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1844             among all subplots.  In that case, tick label visibility and axis
1845             units behave as for `subplots`.  If False, each subplot's x- or
1846             y-axis will be independent.
1847 
1848         width_ratios : array-like of length *ncols*, optional
1849             Defines the relative widths of the columns. Each column gets a
1850             relative width of ``width_ratios[i] / sum(width_ratios)``.
1851             If not given, all columns will have the same width.  Equivalent
1852             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1853             layouts, this argument applies only to the outer layout.
1854 
1855         height_ratios : array-like of length *nrows*, optional
1856             Defines the relative heights of the rows. Each row gets a
1857             relative height of ``height_ratios[i] / sum(height_ratios)``.
1858             If not given, all rows will have the same height. Equivalent
1859             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1860             layouts, this argument applies only to the outer layout.
1861 
1862         subplot_kw : dict, optional
1863             Dictionary with keywords passed to the `.Figure.add_subplot` call
1864             used to create each subplot.  These values may be overridden by
1865             values in *per_subplot_kw*.
1866 
1867         per_subplot_kw : dict, optional
1868             A dictionary mapping the Axes identifiers or tuples of identifiers
1869             to a dictionary of keyword arguments to be passed to the
1870             `.Figure.add_subplot` call used to create each subplot.  The values
1871             in these dictionaries have precedence over the values in
1872             *subplot_kw*.
1873 
1874             If *mosaic* is a string, and thus all keys are single characters,
1875             it is possible to use a single string instead of a tuple as keys;
1876             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1877 
1878             .. versionadded:: 3.7
1879 
1880         gridspec_kw : dict, optional
1881             Dictionary with keywords passed to the `.GridSpec` constructor used
1882             to create the grid the subplots are placed on. In the case of
1883             nested layouts, this argument applies only to the outer layout.
1884             For more complex layouts, users should use `.Figure.subfigures`
1885             to create the nesting.
1886 
1887         empty_sentinel : object, optional
1888             Entry in the layout to mean "leave this space empty".  Defaults
1889             to ``'.'``. Note, if *layout* is a string, it is processed via
1890             `inspect.cleandoc` to remove leading white space, which may
1891             interfere with using white-space as the empty sentinel.
1892 
1893         Returns
1894         -------
1895         dict[label, Axes]
1896            A dictionary mapping the labels to the Axes objects.  The order of
1897            the axes is left-to-right and top-to-bottom of their position in the
1898            total layout.
1899 
1900         """
1901         subplot_kw = subplot_kw or {}
1902         gridspec_kw = dict(gridspec_kw or {})
1903         per_subplot_kw = per_subplot_kw or {}
1904 
1905         if height_ratios is not None:
1906             if 'height_ratios' in gridspec_kw:
1907                 raise ValueError("'height_ratios' must not be defined both as "
1908                                  "parameter and as key in 'gridspec_kw'")
1909             gridspec_kw['height_ratios'] = height_ratios
1910         if width_ratios is not None:
1911             if 'width_ratios' in gridspec_kw:
1912                 raise ValueError("'width_ratios' must not be defined both as "
1913                                  "parameter and as key in 'gridspec_kw'")
1914             gridspec_kw['width_ratios'] = width_ratios
1915 
1916         # special-case string input
1917         if isinstance(mosaic, str):
1918             mosaic = self._normalize_grid_string(mosaic)
1919             per_subplot_kw = {
1920                 tuple(k): v for k, v in per_subplot_kw.items()
1921             }
1922 
1923         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1924 
1925         # Only accept strict bools to allow a possible future API expansion.
1926         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1927 
1928         def _make_array(inp):
1929             """
1930             Convert input into 2D array
1931 
1932             We need to have this internal function rather than
1933             ``np.asarray(..., dtype=object)`` so that a list of lists
1934             of lists does not get converted to an array of dimension >
1935             2
1936 
1937             Returns
1938             -------
1939             2D object array
1940 
1941             """
1942             r0, *rest = inp
1943             if isinstance(r0, str):
1944                 raise ValueError('List mosaic specification must be 2D')
1945             for j, r in enumerate(rest, start=1):
1946                 if isinstance(r, str):
1947                     raise ValueError('List mosaic specification must be 2D')
1948                 if len(r0) != len(r):
1949                     raise ValueError(
1950                         "All of the rows must be the same length, however "
1951                         f"the first row ({r0!r}) has length {len(r0)} "
1952                         f"and row {j} ({r!r}) has length {len(r)}."
1953                     )
1954             out = np.zeros((len(inp), len(r0)), dtype=object)
1955             for j, r in enumerate(inp):
1956                 for k, v in enumerate(r):
1957                     out[j, k] = v
1958             return out
1959 
1960         def _identify_keys_and_nested(mosaic):
1961             """
1962             Given a 2D object array, identify unique IDs and nested mosaics
1963 
1964             Parameters
1965             ----------
1966             mosaic : 2D numpy object array
1967 
1968             Returns
1969             -------
1970             unique_ids : tuple
1971                 The unique non-sub mosaic entries in this mosaic
1972             nested : dict[tuple[int, int]], 2D object array
1973             """
1974             # make sure we preserve the user supplied order
1975             unique_ids = cbook._OrderedSet()
1976             nested = {}
1977             for j, row in enumerate(mosaic):
1978                 for k, v in enumerate(row):
1979                     if v == empty_sentinel:
1980                         continue
1981                     elif not cbook.is_scalar_or_string(v):
1982                         nested[(j, k)] = _make_array(v)
1983                     else:
1984                         unique_ids.add(v)
1985 
1986             return tuple(unique_ids), nested
1987 
1988         def _do_layout(gs, mosaic, unique_ids, nested):
1989             """
1990             Recursively do the mosaic.
1991 
1992             Parameters
1993             ----------
1994             gs : GridSpec
1995             mosaic : 2D object array
1996                 The input converted to a 2D numpy array for this level.
1997             unique_ids : tuple
1998                 The identified scalar labels at this level of nesting.
1999             nested : dict[tuple[int, int]], 2D object array
2000                 The identified nested mosaics, if any.
2001 
2002             Returns
2003             -------
2004             dict[label, Axes]
2005                 A flat dict of all of the Axes created.
2006             """
2007             output = dict()
2008 
2009             # we need to merge together the Axes at this level and the axes
2010             # in the (recursively) nested sub-mosaics so that we can add
2011             # them to the figure in the "natural" order if you were to
2012             # ravel in c-order all of the Axes that will be created
2013             #
2014             # This will stash the upper left index of each object (axes or
2015             # nested mosaic) at this level
2016             this_level = dict()
2017 
2018             # go through the unique keys,
2019             for name in unique_ids:
2020                 # sort out where each axes starts/ends
2021                 indx = np.argwhere(mosaic == name)
2022                 start_row, start_col = np.min(indx, axis=0)
2023                 end_row, end_col = np.max(indx, axis=0) + 1
2024                 # and construct the slice object
2025                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2026                 # some light error checking
2027                 if (mosaic[slc] != name).any():
2028                     raise ValueError(
2029                         f"While trying to layout\n{mosaic!r}\n"
2030                         f"we found that the label {name!r} specifies a "
2031                         "non-rectangular or non-contiguous area.")
2032                 # and stash this slice for later
2033                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2034 
2035             # do the same thing for the nested mosaics (simpler because these
2036             # can not be spans yet!)
2037             for (j, k), nested_mosaic in nested.items():
2038                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2039 
2040             # now go through the things in this level and add them
2041             # in order left-to-right top-to-bottom
2042             for key in sorted(this_level):
2043                 name, arg, method = this_level[key]
2044                 # we are doing some hokey function dispatch here based
2045                 # on the 'method' string stashed above to sort out if this
2046                 # element is an Axes or a nested mosaic.
2047                 if method == 'axes':
2048                     slc = arg
2049                     # add a single axes
2050                     if name in output:
2051                         raise ValueError(f"There are duplicate keys {name} "
2052                                          f"in the layout\n{mosaic!r}")
2053                     ax = self.add_subplot(
2054                         gs[slc], **{
2055                             'label': str(name),
2056                             **subplot_kw,
2057                             **per_subplot_kw.get(name, {})
2058                         }
2059                     )
2060                     output[name] = ax
2061                 elif method == 'nested':
2062                     nested_mosaic = arg
2063                     j, k = key
2064                     # recursively add the nested mosaic
2065                     rows, cols = nested_mosaic.shape
2066                     nested_output = _do_layout(
2067                         gs[j, k].subgridspec(rows, cols),
2068                         nested_mosaic,
2069                         *_identify_keys_and_nested(nested_mosaic)
2070                     )
2071                     overlap = set(output) & set(nested_output)
2072                     if overlap:
2073                         raise ValueError(
2074                             f"There are duplicate keys {overlap} "
2075                             f"between the outer layout\n{mosaic!r}\n"
2076                             f"and the nested layout\n{nested_mosaic}"
2077                         )
2078                     output.update(nested_output)
2079                 else:
2080                     raise RuntimeError("This should never happen")
2081             return output
2082 
2083         mosaic = _make_array(mosaic)
2084         rows, cols = mosaic.shape
2085         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2086         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2087         ax0 = next(iter(ret.values()))
2088         for ax in ret.values():
2089             if sharex:
2090                 ax.sharex(ax0)
2091                 ax._label_outer_xaxis(check_patch=True)
2092             if sharey:
2093                 ax.sharey(ax0)
2094                 ax._label_outer_yaxis(check_patch=True)
2095         if extra := set(per_subplot_kw) - set(ret):
2096             raise ValueError(
2097                 f"The keys {extra} are in *per_subplot_kw* "
2098                 "but not in the mosaic."
2099             )
2100         return ret

</code><intended_behavior>The 'subplot_mosaic' method implementation must ensure that once a compressed layout is set up for a figure, these settings are embedded into the figure's metadata or state in a manner that they are referred to or reapplied in subsequent operations affecting the figure's layout, including saving with 'bbox_inches="tight"'. This means enhancing how layout settings are stored or referenced within a figure's lifecycle, ensuring consistency between the visualization on-screen and the saved files.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>FigureBase</class>
<method>subplot_mosaic</method>
<code>
1791     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1792                        width_ratios=None, height_ratios=None,
1793                        empty_sentinel='.',
1794                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1795         """
1796         Build a layout of Axes based on ASCII art or nested lists.
1797 
1798         This is a helper function to build complex GridSpec layouts visually.
1799 
1800         See :doc:`/gallery/subplots_axes_and_figures/mosaic`
1801         for an example and full API documentation
1802 
1803         Parameters
1804         ----------
1805         mosaic : list of list of {hashable or nested} or str
1806 
1807             A visual layout of how you want your Axes to be arranged
1808             labeled as strings.  For example ::
1809 
1810                x = [['A panel', 'A panel', 'edge'],
1811                     ['C panel', '.',       'edge']]
1812 
1813             produces 4 Axes:
1814 
1815             - 'A panel' which is 1 row high and spans the first two columns
1816             - 'edge' which is 2 rows high and is on the right edge
1817             - 'C panel' which in 1 row and 1 column wide in the bottom left
1818             - a blank space 1 row and 1 column wide in the bottom center
1819 
1820             Any of the entries in the layout can be a list of lists
1821             of the same form to create nested layouts.
1822 
1823             If input is a str, then it can either be a multi-line string of
1824             the form ::
1825 
1826               '''
1827               AAE
1828               C.E
1829               '''
1830 
1831             where each character is a column and each line is a row. Or it
1832             can be a single-line string where rows are separated by ``;``::
1833 
1834               'AB;CC'
1835 
1836             The string notation allows only single character Axes labels and
1837             does not support nesting but is very terse.
1838 
1839             The Axes identifiers may be `str` or a non-iterable hashable
1840             object (e.g. `tuple` s may not be used).
1841 
1842         sharex, sharey : bool, default: False
1843             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1844             among all subplots.  In that case, tick label visibility and axis
1845             units behave as for `subplots`.  If False, each subplot's x- or
1846             y-axis will be independent.
1847 
1848         width_ratios : array-like of length *ncols*, optional
1849             Defines the relative widths of the columns. Each column gets a
1850             relative width of ``width_ratios[i] / sum(width_ratios)``.
1851             If not given, all columns will have the same width.  Equivalent
1852             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1853             layouts, this argument applies only to the outer layout.
1854 
1855         height_ratios : array-like of length *nrows*, optional
1856             Defines the relative heights of the rows. Each row gets a
1857             relative height of ``height_ratios[i] / sum(height_ratios)``.
1858             If not given, all rows will have the same height. Equivalent
1859             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1860             layouts, this argument applies only to the outer layout.
1861 
1862         subplot_kw : dict, optional
1863             Dictionary with keywords passed to the `.Figure.add_subplot` call
1864             used to create each subplot.  These values may be overridden by
1865             values in *per_subplot_kw*.
1866 
1867         per_subplot_kw : dict, optional
1868             A dictionary mapping the Axes identifiers or tuples of identifiers
1869             to a dictionary of keyword arguments to be passed to the
1870             `.Figure.add_subplot` call used to create each subplot.  The values
1871             in these dictionaries have precedence over the values in
1872             *subplot_kw*.
1873 
1874             If *mosaic* is a string, and thus all keys are single characters,
1875             it is possible to use a single string instead of a tuple as keys;
1876             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1877 
1878             .. versionadded:: 3.7
1879 
1880         gridspec_kw : dict, optional
1881             Dictionary with keywords passed to the `.GridSpec` constructor used
1882             to create the grid the subplots are placed on. In the case of
1883             nested layouts, this argument applies only to the outer layout.
1884             For more complex layouts, users should use `.Figure.subfigures`
1885             to create the nesting.
1886 
1887         empty_sentinel : object, optional
1888             Entry in the layout to mean "leave this space empty".  Defaults
1889             to ``'.'``. Note, if *layout* is a string, it is processed via
1890             `inspect.cleandoc` to remove leading white space, which may
1891             interfere with using white-space as the empty sentinel.
1892 
1893         Returns
1894         -------
1895         dict[label, Axes]
1896            A dictionary mapping the labels to the Axes objects.  The order of
1897            the axes is left-to-right and top-to-bottom of their position in the
1898            total layout.
1899 
1900         """
1901         subplot_kw = subplot_kw or {}
1902         gridspec_kw = dict(gridspec_kw or {})
1903         per_subplot_kw = per_subplot_kw or {}
1904 
1905         if height_ratios is not None:
1906             if 'height_ratios' in gridspec_kw:
1907                 raise ValueError("'height_ratios' must not be defined both as "
1908                                  "parameter and as key in 'gridspec_kw'")
1909             gridspec_kw['height_ratios'] = height_ratios
1910         if width_ratios is not None:
1911             if 'width_ratios' in gridspec_kw:
1912                 raise ValueError("'width_ratios' must not be defined both as "
1913                                  "parameter and as key in 'gridspec_kw'")
1914             gridspec_kw['width_ratios'] = width_ratios
1915 
1916         # special-case string input
1917         if isinstance(mosaic, str):
1918             mosaic = self._normalize_grid_string(mosaic)
1919             per_subplot_kw = {
1920                 tuple(k): v for k, v in per_subplot_kw.items()
1921             }
1922 
1923         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1924 
1925         # Only accept strict bools to allow a possible future API expansion.
1926         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1927 
1928         def _make_array(inp):
1929             """
1930             Convert input into 2D array
1931 
1932             We need to have this internal function rather than
1933             ``np.asarray(..., dtype=object)`` so that a list of lists
1934             of lists does not get converted to an array of dimension >
1935             2
1936 
1937             Returns
1938             -------
1939             2D object array
1940 
1941             """
1942             r0, *rest = inp
1943             if isinstance(r0, str):
1944                 raise ValueError('List mosaic specification must be 2D')
1945             for j, r in enumerate(rest, start=1):
1946                 if isinstance(r, str):
1947                     raise ValueError('List mosaic specification must be 2D')
1948                 if len(r0) != len(r):
1949                     raise ValueError(
1950                         "All of the rows must be the same length, however "
1951                         f"the first row ({r0!r}) has length {len(r0)} "
1952                         f"and row {j} ({r!r}) has length {len(r)}."
1953                     )
1954             out = np.zeros((len(inp), len(r0)), dtype=object)
1955             for j, r in enumerate(inp):
1956                 for k, v in enumerate(r):
1957                     out[j, k] = v
1958             return out
1959 
1960         def _identify_keys_and_nested(mosaic):
1961             """
1962             Given a 2D object array, identify unique IDs and nested mosaics
1963 
1964             Parameters
1965             ----------
1966             mosaic : 2D numpy object array
1967 
1968             Returns
1969             -------
1970             unique_ids : tuple
1971                 The unique non-sub mosaic entries in this mosaic
1972             nested : dict[tuple[int, int]], 2D object array
1973             """
1974             # make sure we preserve the user supplied order
1975             unique_ids = cbook._OrderedSet()
1976             nested = {}
1977             for j, row in enumerate(mosaic):
1978                 for k, v in enumerate(row):
1979                     if v == empty_sentinel:
1980                         continue
1981                     elif not cbook.is_scalar_or_string(v):
1982                         nested[(j, k)] = _make_array(v)
1983                     else:
1984                         unique_ids.add(v)
1985 
1986             return tuple(unique_ids), nested
1987 
1988         def _do_layout(gs, mosaic, unique_ids, nested):
1989             """
1990             Recursively do the mosaic.
1991 
1992             Parameters
1993             ----------
1994             gs : GridSpec
1995             mosaic : 2D object array
1996                 The input converted to a 2D numpy array for this level.
1997             unique_ids : tuple
1998                 The identified scalar labels at this level of nesting.
1999             nested : dict[tuple[int, int]], 2D object array
2000                 The identified nested mosaics, if any.
2001 
2002             Returns
2003             -------
2004             dict[label, Axes]
2005                 A flat dict of all of the Axes created.
2006             """
2007             output = dict()
2008 
2009             # we need to merge together the Axes at this level and the axes
2010             # in the (recursively) nested sub-mosaics so that we can add
2011             # them to the figure in the "natural" order if you were to
2012             # ravel in c-order all of the Axes that will be created
2013             #
2014             # This will stash the upper left index of each object (axes or
2015             # nested mosaic) at this level
2016             this_level = dict()
2017 
2018             # go through the unique keys,
2019             for name in unique_ids:
2020                 # sort out where each axes starts/ends
2021                 indx = np.argwhere(mosaic == name)
2022                 start_row, start_col = np.min(indx, axis=0)
2023                 end_row, end_col = np.max(indx, axis=0) + 1
2024                 # and construct the slice object
2025                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2026                 # some light error checking
2027                 if (mosaic[slc] != name).any():
2028                     raise ValueError(
2029                         f"While trying to layout\n{mosaic!r}\n"
2030                         f"we found that the label {name!r} specifies a "
2031                         "non-rectangular or non-contiguous area.")
2032                 # and stash this slice for later
2033                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2034 
2035             # do the same thing for the nested mosaics (simpler because these
2036             # can not be spans yet!)
2037             for (j, k), nested_mosaic in nested.items():
2038                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2039 
2040             # now go through the things in this level and add them
2041             # in order left-to-right top-to-bottom
2042             for key in sorted(this_level):
2043                 name, arg, method = this_level[key]
2044                 # we are doing some hokey function dispatch here based
2045                 # on the 'method' string stashed above to sort out if this
2046                 # element is an Axes or a nested mosaic.
2047                 if method == 'axes':
2048                     slc = arg
2049                     # add a single axes
2050                     if name in output:
2051                         raise ValueError(f"There are duplicate keys {name} "
2052                                          f"in the layout\n{mosaic!r}")
2053                     ax = self.add_subplot(
2054                         gs[slc], **{
2055                             'label': str(name),
2056                             **subplot_kw,
2057                             **per_subplot_kw.get(name, {})
2058                         }
2059                     )
2060                     output[name] = ax
2061                 elif method == 'nested':
2062                     nested_mosaic = arg
2063                     j, k = key
2064                     # recursively add the nested mosaic
2065                     rows, cols = nested_mosaic.shape
2066                     nested_output = _do_layout(
2067                         gs[j, k].subgridspec(rows, cols),
2068                         nested_mosaic,
2069                         *_identify_keys_and_nested(nested_mosaic)
2070                     )
2071                     overlap = set(output) & set(nested_output)
2072                     if overlap:
2073                         raise ValueError(
2074                             f"There are duplicate keys {overlap} "
2075                             f"between the outer layout\n{mosaic!r}\n"
2076                             f"and the nested layout\n{nested_mosaic}"
2077                         )
2078                     output.update(nested_output)
2079                 else:
2080                     raise RuntimeError("This should never happen")
2081             return output
2082 
2083         mosaic = _make_array(mosaic)
2084         rows, cols = mosaic.shape
2085         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2086         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2087         ax0 = next(iter(ret.values()))
2088         for ax in ret.values():
2089             if sharex:
2090                 ax.sharex(ax0)
2091                 ax._label_outer_xaxis(check_patch=True)
2092             if sharey:
2093                 ax.sharey(ax0)
2094                 ax._label_outer_yaxis(check_patch=True)
2095         if extra := set(per_subplot_kw) - set(ret):
2096             raise ValueError(
2097                 f"The keys {extra} are in *per_subplot_kw* "
2098                 "but not in the mosaic."
2099             )
2100         return ret

</code><intended_behavior>The 'subplot_mosaic' method implementation must ensure that once a compressed layout is set up for a figure, these settings are embedded into the figure's metadata or state in a manner that they are referred to or reapplied in subsequent operations affecting the figure's layout, including saving with 'bbox_inches="tight"'. This means enhancing how layout settings are stored or referenced within a figure's lifecycle, ensuring consistency between the visualization on-screen and the saved files.</intended_behavior>]
2025-10-15 07:29:50.261 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:29:50.261 | INFO     | Search-only: skipping patch selection
2025-10-15 07:29:50.347 | INFO     | Task matplotlib__matplotlib-24971 completed successfully.
2025-10-15 07:29:50.348 | INFO     | No patch generated. You can try running ACR again.
