[
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 274,
        "end": 354,
        "class_name": "PyObject",
        "method_name": "handle_signature",
        "code": "274     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n275         \"\"\"Transform a Python signature into RST nodes.\n276 \n277         Return (fully qualified name of the thing, classname if any).\n278 \n279         If inside a class, the current class name is handled intelligently:\n280         * it is stripped from the displayed name if present\n281         * it is added to the full name (return value) if not present\n282         \"\"\"\n283         m = py_sig_re.match(sig)\n284         if m is None:\n285             raise ValueError\n286         prefix, name, arglist, retann = m.groups()\n287 \n288         # determine module and class name (if applicable), as well as full name\n289         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n290         classname = self.env.ref_context.get('py:class')\n291         if classname:\n292             add_module = False\n293             if prefix and (prefix == classname or\n294                            prefix.startswith(classname + \".\")):\n295                 fullname = prefix + name\n296                 # class name is given again in the signature\n297                 prefix = prefix[len(classname):].lstrip('.')\n298             elif prefix:\n299                 # class name is given in the signature, but different\n300                 # (shouldn't happen)\n301                 fullname = classname + '.' + prefix + name\n302             else:\n303                 # class name is not given in the signature\n304                 fullname = classname + '.' + name\n305         else:\n306             add_module = True\n307             if prefix:\n308                 classname = prefix.rstrip('.')\n309                 fullname = prefix + name\n310             else:\n311                 classname = ''\n312                 fullname = name\n313 \n314         signode['module'] = modname\n315         signode['class'] = classname\n316         signode['fullname'] = fullname\n317 \n318         sig_prefix = self.get_signature_prefix(sig)\n319         if sig_prefix:\n320             signode += addnodes.desc_annotation(sig_prefix, sig_prefix)\n321 \n322         if prefix:\n323             signode += addnodes.desc_addname(prefix, prefix)\n324         elif add_module and self.env.config.add_module_names:\n325             if modname and modname != 'exceptions':\n326                 # exceptions are a special case, since they are documented in the\n327                 # 'exceptions' module.\n328                 nodetext = modname + '.'\n329                 signode += addnodes.desc_addname(nodetext, nodetext)\n330 \n331         signode += addnodes.desc_name(name, name)\n332         if arglist:\n333             try:\n334                 signode += _parse_arglist(arglist)\n335             except SyntaxError:\n336                 # fallback to parse arglist original parser.\n337                 # it supports to represent optional arguments (ex. \"func(foo [, bar])\")\n338                 _pseudo_parse_arglist(signode, arglist)\n339             except NotImplementedError as exc:\n340                 logger.warning(\"could not parse arglist (%r): %s\", arglist, exc)\n341                 _pseudo_parse_arglist(signode, arglist)\n342         else:\n343             if self.needs_arglist():\n344                 # for callables, add an empty parameter list\n345                 signode += addnodes.desc_parameterlist()\n346 \n347         if retann:\n348             signode += addnodes.desc_returns(retann, retann)\n349 \n350         anno = self.options.get('annotation')\n351         if anno:\n352             signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)\n353 \n354         return fullname, prefix\n",
        "intended_behavior": "The `handle_signature` method should be enhanced to parse expressions involving the power operator (`**`) in default values accurately, ensuring Sphinx documentation can handle complex Python expressions in object signatures without errors or warnings."
    },
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 228,
        "end": 437,
        "class_name": "PyObject",
        "method_name": null,
        "code": "228 class PyObject(ObjectDescription):\n229     \"\"\"\n230     Description of a general Python object.\n231 \n232     :cvar allow_nesting: Class is an object that allows for nested namespaces\n233     :vartype allow_nesting: bool\n234     \"\"\"\n235     option_spec = {\n236         'noindex': directives.flag,\n237         'module': directives.unchanged,\n238         'annotation': directives.unchanged,\n239     }\n240 \n241     doc_field_types = [\n242         PyTypedField('parameter', label=_('Parameters'),\n243                      names=('param', 'parameter', 'arg', 'argument',\n244                             'keyword', 'kwarg', 'kwparam'),\n245                      typerolename='class', typenames=('paramtype', 'type'),\n246                      can_collapse=True),\n247         PyTypedField('variable', label=_('Variables'), rolename='obj',\n248                      names=('var', 'ivar', 'cvar'),\n249                      typerolename='class', typenames=('vartype',),\n250                      can_collapse=True),\n251         PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n252                        names=('raises', 'raise', 'exception', 'except'),\n253                        can_collapse=True),\n254         Field('returnvalue', label=_('Returns'), has_arg=False,\n255               names=('returns', 'return')),\n256         PyField('returntype', label=_('Return type'), has_arg=False,\n257                 names=('rtype',), bodyrolename='class'),\n258     ]\n259 \n260     allow_nesting = False\n261 \n262     def get_signature_prefix(self, sig: str) -> str:\n263         \"\"\"May return a prefix to put before the object name in the\n264         signature.\n265         \"\"\"\n266         return ''\n267 \n268     def needs_arglist(self) -> bool:\n269         \"\"\"May return true if an empty argument list is to be generated even if\n270         the document contains none.\n271         \"\"\"\n272         return False\n273 \n274     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n275         \"\"\"Transform a Python signature into RST nodes.\n276 \n277         Return (fully qualified name of the thing, classname if any).\n278 \n279         If inside a class, the current class name is handled intelligently:\n280         * it is stripped from the displayed name if present\n281         * it is added to the full name (return value) if not present\n282         \"\"\"\n283         m = py_sig_re.match(sig)\n284         if m is None:\n285             raise ValueError\n286         prefix, name, arglist, retann = m.groups()\n287 \n288         # determine module and class name (if applicable), as well as full name\n289         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n290         classname = self.env.ref_context.get('py:class')\n291         if classname:\n292             add_module = False\n293             if prefix and (prefix == classname or\n294                            prefix.startswith(classname + \".\")):\n295                 fullname = prefix + name\n296                 # class name is given again in the signature\n297                 prefix = prefix[len(classname):].lstrip('.')\n298             elif prefix:\n299                 # class name is given in the signature, but different\n300                 # (shouldn't happen)\n301                 fullname = classname + '.' + prefix + name\n302             else:\n303                 # class name is not given in the signature\n304                 fullname = classname + '.' + name\n305         else:\n306             add_module = True\n307             if prefix:\n308                 classname = prefix.rstrip('.')\n309                 fullname = prefix + name\n310             else:\n311                 classname = ''\n312                 fullname = name\n313 \n314         signode['module'] = modname\n315         signode['class'] = classname\n316         signode['fullname'] = fullname\n317 \n318         sig_prefix = self.get_signature_prefix(sig)\n319         if sig_prefix:\n320             signode += addnodes.desc_annotation(sig_prefix, sig_prefix)\n321 \n322         if prefix:\n323             signode += addnodes.desc_addname(prefix, prefix)\n324         elif add_module and self.env.config.add_module_names:\n325             if modname and modname != 'exceptions':\n326                 # exceptions are a special case, since they are documented in the\n327                 # 'exceptions' module.\n328                 nodetext = modname + '.'\n329                 signode += addnodes.desc_addname(nodetext, nodetext)\n330 \n331         signode += addnodes.desc_name(name, name)\n332         if arglist:\n333             try:\n334                 signode += _parse_arglist(arglist)\n335             except SyntaxError:\n336                 # fallback to parse arglist original parser.\n337                 # it supports to represent optional arguments (ex. \"func(foo [, bar])\")\n338                 _pseudo_parse_arglist(signode, arglist)\n339             except NotImplementedError as exc:\n340                 logger.warning(\"could not parse arglist (%r): %s\", arglist, exc)\n341                 _pseudo_parse_arglist(signode, arglist)\n342         else:\n343             if self.needs_arglist():\n344                 # for callables, add an empty parameter list\n345                 signode += addnodes.desc_parameterlist()\n346 \n347         if retann:\n348             signode += addnodes.desc_returns(retann, retann)\n349 \n350         anno = self.options.get('annotation')\n351         if anno:\n352             signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)\n353 \n354         return fullname, prefix\n355 \n356     def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:\n357         \"\"\"Return the text for the index entry of the object.\"\"\"\n358         raise NotImplementedError('must be implemented in subclasses')\n359 \n360     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n361                              signode: desc_signature) -> None:\n362         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n363         fullname = (modname + '.' if modname else '') + name_cls[0]\n364         node_id = make_id(self.env, self.state.document, modname or '', name_cls[0])\n365         signode['ids'].append(node_id)\n366 \n367         # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)\n368         # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n369         if node_id != fullname and fullname not in self.state.document.ids:\n370             signode['ids'].append(fullname)\n371 \n372         self.state.document.note_explicit_target(signode)\n373 \n374         domain = cast(PythonDomain, self.env.get_domain('py'))\n375         domain.note_object(fullname, self.objtype, node_id, location=signode)\n376 \n377         indextext = self.get_index_text(modname, name_cls)\n378         if indextext:\n379             self.indexnode['entries'].append(('single', indextext, node_id, '', None))\n380 \n381     def before_content(self) -> None:\n382         \"\"\"Handle object nesting before content\n383 \n384         :py:class:`PyObject` represents Python language constructs. For\n385         constructs that are nestable, such as a Python classes, this method will\n386         build up a stack of the nesting heirarchy so that it can be later\n387         de-nested correctly, in :py:meth:`after_content`.\n388 \n389         For constructs that aren't nestable, the stack is bypassed, and instead\n390         only the most recent object is tracked. This object prefix name will be\n391         removed with :py:meth:`after_content`.\n392         \"\"\"\n393         prefix = None\n394         if self.names:\n395             # fullname and name_prefix come from the `handle_signature` method.\n396             # fullname represents the full object name that is constructed using\n397             # object nesting and explicit prefixes. `name_prefix` is the\n398             # explicit prefix given in a signature\n399             (fullname, name_prefix) = self.names[-1]\n400             if self.allow_nesting:\n401                 prefix = fullname\n402             elif name_prefix:\n403                 prefix = name_prefix.strip('.')\n404         if prefix:\n405             self.env.ref_context['py:class'] = prefix\n406             if self.allow_nesting:\n407                 classes = self.env.ref_context.setdefault('py:classes', [])\n408                 classes.append(prefix)\n409         if 'module' in self.options:\n410             modules = self.env.ref_context.setdefault('py:modules', [])\n411             modules.append(self.env.ref_context.get('py:module'))\n412             self.env.ref_context['py:module'] = self.options['module']\n413 \n414     def after_content(self) -> None:\n415         \"\"\"Handle object de-nesting after content\n416 \n417         If this class is a nestable object, removing the last nested class prefix\n418         ends further nesting in the object.\n419 \n420         If this class is not a nestable object, the list of classes should not\n421         be altered as we didn't affect the nesting levels in\n422         :py:meth:`before_content`.\n423         \"\"\"\n424         classes = self.env.ref_context.setdefault('py:classes', [])\n425         if self.allow_nesting:\n426             try:\n427                 classes.pop()\n428             except IndexError:\n429                 pass\n430         self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0\n431                                             else None)\n432         if 'module' in self.options:\n433             modules = self.env.ref_context.setdefault('py:modules', [])\n434             if modules:\n435                 self.env.ref_context['py:module'] = modules.pop()\n436             else:\n437                 self.env.ref_context.pop('py:module')\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]