2025-10-15 04:08:25.301 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 04:08:29.516 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=652, output_tokens=12, cost=0.006880
2025-10-15 04:08:29.517 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 04:08:29.521 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:08:38.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=952, output_tokens=386, cost=0.021100
2025-10-15 04:08:38.110 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:08:40.430 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=740, output_tokens=66, cost=0.009380
2025-10-15 04:08:40.432 | DEBUG    | Extracted a valid json.
2025-10-15 04:08:40.432 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ShortUUIDField\")",
        "search_class(\"Account\")",
        "search_class(\"Address\")",
        "search_class(\"Profile\")",
        "search_method_in_class(\"makemigrations\", \"MigrationSystem\")"
    ],
    "bug_locations": []
}
2025-10-15 04:08:40.439 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 04:08:40.440 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 04:08:51.582 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1552, output_tokens=517, cost=0.031030
2025-10-15 04:08:51.595 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:09:03.095 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2285, output_tokens=523, cost=0.038540
2025-10-15 04:09:03.104 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:09:05.437 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=877, output_tokens=45, cost=0.010120
2025-10-15 04:09:05.439 | DEBUG    | Extracted a valid json.
2025-10-15 04:09:05.439 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"db_collation\")",
        "search_code(\"models.ForeignKey\")",
        "search_code(\"models.OneToOneField\")"
    ],
    "bug_locations": []
}
2025-10-15 04:09:05.564 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 04:09:05.564 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 04:09:22.301 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3337, output_tokens=722, cost=0.055030
2025-10-15 04:09:22.308 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:09:31.723 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4275, output_tokens=378, cost=0.054090
2025-10-15 04:09:31.731 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:09:41.244 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=301, cost=0.016350
2025-10-15 04:09:41.245 | DEBUG    | Extracted a valid json.
2025-10-15 04:09:41.246 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should include logic that not only allows for 'db_collation' to be defined at the field level but also ensures that when such fields are used as primary keys, any foreign keys referencing them in other models inherit or respect this collation setting during migration generation. The current implementation likely allows 'db_collation' to be specified, but may not ensure it is consistently applied across related foreign key references in migrations. The code fix should address this propagation issue without disrupting the existing functionality for non-related fields."
        },
        {
            "file": "django/db/models/fields/related.py",
            "class": "",
            "method": "",
            "intended_behavior": "Within this file, particularly in the sections that define or manipulate 'ForeignKey' fields, additional logic is required to check the 'db_collation' of the referenced field (if any) and apply it to the 'ForeignKey' field during migrations. The intention is for foreign keys to maintain database consistency by automatically adopting the 'db_collation' of their referenced primary key fields when migrations are generated, thus preventing collation mismatch errors. This adjustment should ensure that fields referencing custom or altered collation settings adhere to those settings across all related tables, respecting database constraints."
        }
    ]
}
2025-10-15 04:09:41.266 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections.abc
2 import copy
3 import datetime
4 import decimal
5 import math
6 import operator
7 import uuid
8 import warnings
9 from base64 import b64decode, b64encode
10 from functools import partialmethod, total_ordering
11 
12 from django import forms
13 from django.apps import apps
14 from django.conf import settings
15 from django.core import checks, exceptions, validators
16 from django.db import connection, connections, router
17 from django.db.models.constants import LOOKUP_SEP
18 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin
19 from django.utils import timezone
20 from django.utils.datastructures import DictWrapper
21 from django.utils.dateparse import (
22     parse_date,
23     parse_datetime,
24     parse_duration,
25     parse_time,
26 )
27 from django.utils.duration import duration_microseconds, duration_string
28 from django.utils.functional import Promise, cached_property
29 from django.utils.ipv6 import clean_ipv6_address
30 from django.utils.itercompat import is_iterable
31 from django.utils.text import capfirst
32 from django.utils.translation import gettext_lazy as _
33 
34 __all__ = [
35     "AutoField",
36     "BLANK_CHOICE_DASH",
37     "BigAutoField",
38     "BigIntegerField",
39     "BinaryField",
40     "BooleanField",
41     "CharField",
42     "CommaSeparatedIntegerField",
43     "DateField",
44     "DateTimeField",
45     "DecimalField",
46     "DurationField",
47     "EmailField",
48     "Empty",
49     "Field",
50     "FilePathField",
51     "FloatField",
52     "GenericIPAddressField",
53     "IPAddressField",
54     "IntegerField",
55     "NOT_PROVIDED",
56     "NullBooleanField",
57     "PositiveBigIntegerField",
58     "PositiveIntegerField",
59     "PositiveSmallIntegerField",
60     "SlugField",
61     "SmallAutoField",
62     "SmallIntegerField",
63     "TextField",
64     "TimeField",
65     "URLField",
66     "UUIDField",
67 ]
68 
69 
70 class Empty:
71     pass
72 
73 
74 class NOT_PROVIDED:
75     pass
76 
77 
78 # The values to use for "blank" in SelectFields. Will be appended to the start
79 # of most "choices" lists.
80 BLANK_CHOICE_DASH = [("", "---------")]
81 
82 
83 def _load_field(app_label, model_name, field_name):
84     return apps.get_model(app_label, model_name)._meta.get_field(field_name)
85 
86 
87 # A guide to Field parameters:
88 #
89 #   * name:      The name of the field specified in the model.
90 #   * attname:   The attribute to use on the model object. This is the same as
91 #                "name", except in the case of ForeignKeys, where "_id" is
92 #                appended.
93 #   * db_column: The db_column specified in the model (or None).
94 #   * column:    The database column for this field. This is the same as
95 #                "attname", except if db_column is specified.
96 #
97 # Code that introspects values, or does other dynamic things, should use
98 # attname. For example, this gets the primary key value of object "obj":
99 #
100 #     getattr(obj, opts.pk.attname)
101 
102 
103 def _empty(of_cls):
104     new = Empty()
105     new.__class__ = of_cls
106     return new
107 
108 
109 def return_None():
110     return None
111 
112 
113 @total_ordering
114 class Field(RegisterLookupMixin):
115     """Base class for all field types"""
116 
117     # Designates whether empty strings fundamentally are allowed at the
118     # database level.
119     empty_strings_allowed = True
120     empty_values = list(validators.EMPTY_VALUES)
121 
122     # These track each time a Field instance is created. Used to retain order.
123     # The auto_creation_counter is used for fields that Django implicitly
124     # creates, creation_counter is used for all user-specified fields.
125     creation_counter = 0
126     auto_creation_counter = -1
127     default_validators = []  # Default set of validators
128     default_error_messages = {
129         "invalid_choice": _("Value %(value)r is not a valid choice."),
130         "null": _("This field cannot be null."),
131         "blank": _("This field cannot be blank."),
132         "unique": _("%(model_name)s with this %(field_label)s already exists."),
133         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.
134         # Eg: "Title must be unique for pub_date year"
135         "unique_for_date": _(
136             "%(field_label)s must be unique for "
137             "%(date_field_label)s %(lookup_type)s."
138         ),
139     }
140     system_check_deprecated_details = None
141     system_check_removed_details = None
142 
143     # Attributes that don't affect a column definition.
144     # These attributes are ignored when altering the field.
145     non_db_attrs = (
146         "blank",
147         "choices",
148         "db_column",
149         "editable",
150         "error_messages",
151         "help_text",
152         "limit_choices_to",
153         # Database-level options are not supported, see #21961.
154         "on_delete",
155         "related_name",
156         "related_query_name",
157         "validators",
158         "verbose_name",
159     )
160 
161     # Field flags
162     hidden = False
163 
164     many_to_many = None
165     many_to_one = None
166     one_to_many = None
167     one_to_one = None
168     related_model = None
169 
170     descriptor_class = DeferredAttribute
171 
172     # Generic field type description, usually overridden by subclasses
173     def _description(self):
174         return _("Field of type: %(field_type)s") % {
175             "field_type": self.__class__.__name__
176         }
177 
178     description = property(_description)
179 
180     def __init__(
181         self,
182         verbose_name=None,
183         name=None,
184         primary_key=False,
185         max_length=None,
186         unique=False,
187         blank=False,
188         null=False,
189         db_index=False,
190         rel=None,
191         default=NOT_PROVIDED,
192         editable=True,
193         serialize=True,
194         unique_for_date=None,
195         unique_for_month=None,
196         unique_for_year=None,
197         choices=None,
198         help_text="",
199         db_column=None,
200         db_tablespace=None,
201         auto_created=False,
202         validators=(),
203         error_messages=None,
204     ):
205         self.name = name
206         self.verbose_name = verbose_name  # May be set by set_attributes_from_name
207         self._verbose_name = verbose_name  # Store original for deconstruction
208         self.primary_key = primary_key
209         self.max_length, self._unique = max_length, unique
210         self.blank, self.null = blank, null
211         self.remote_field = rel
212         self.is_relation = self.remote_field is not None
213         self.default = default
214         self.editable = editable
215         self.serialize = serialize
216         self.unique_for_date = unique_for_date
217         self.unique_for_month = unique_for_month
218         self.unique_for_year = unique_for_year
219         if isinstance(choices, collections.abc.Iterator):
220             choices = list(choices)
221         self.choices = choices
222         self.help_text = help_text
223         self.db_index = db_index
224         self.db_column = db_column
225         self._db_tablespace = db_tablespace
226         self.auto_created = auto_created
227 
228         # Adjust the appropriate creation counter, and save our local copy.
229         if auto_created:
230             self.creation_counter = Field.auto_creation_counter
231             Field.auto_creation_counter -= 1
232         else:
233             self.creation_counter = Field.creation_counter
234             Field.creation_counter += 1
235 
236         self._validators = list(validators)  # Store for deconstruction later
237 
238         self._error_messages = error_messages  # Store for deconstruction later
239 
240     def __str__(self):
241         """
242         Return "app_label.model_label.field_name" for fields attached to
243         models.
244         """
245         if not hasattr(self, "model"):
246             return super().__str__()
247         model = self.model
248         return "%s.%s" % (model._meta.label, self.name)
249 
250     def __repr__(self):
251         """Display the module, class, and name of the field."""
252         path = "%s.%s" % (self.__class__.__module__, self.__class__.__qualname__)
253         name = getattr(self, "name", None)
254         if name is not None:
255             return "<%s: %s>" % (path, name)
256         return "<%s>" % path
257 
258     def check(self, **kwargs):
259         return [
260             *self._check_field_name(),
261             *self._check_choices(),
262             *self._check_db_index(),
263             *self._check_null_allowed_for_primary_keys(),
264             *self._check_backend_specific_checks(**kwargs),
265             *self._check_validators(),
266             *self._check_deprecation_details(),
267         ]
268 
269     def _check_field_name(self):
270         """
271         Check if field name is valid, i.e. 1) does not end with an
272         underscore, 2) does not contain "__" and 3) is not "pk".
273         """
274         if self.name.endswith("_"):
275             return [
276                 checks.Error(
277                     "Field names must not end with an underscore.",
278                     obj=self,
279                     id="fields.E001",
280                 )
281             ]
282         elif LOOKUP_SEP in self.name:
283             return [
284                 checks.Error(
285                     'Field names must not contain "%s".' % LOOKUP_SEP,
286                     obj=self,
287                     id="fields.E002",
288                 )
289             ]
290         elif self.name == "pk":
291             return [
292                 checks.Error(
293                     "'pk' is a reserved word that cannot be used as a field name.",
294                     obj=self,
295                     id="fields.E003",
296                 )
297             ]
298         else:
299             return []
300 
301     @classmethod
302     def _choices_is_value(cls, value):
303         return isinstance(value, (str, Promise)) or not is_iterable(value)
304 
305     def _check_choices(self):
306         if not self.choices:
307             return []
308 
309         if not is_iterable(self.choices) or isinstance(self.choices, str):
310             return [
311                 checks.Error(
312                     "'choices' must be an iterable (e.g., a list or tuple).",
313                     obj=self,
314                     id="fields.E004",
315                 )
316             ]
317 
318         choice_max_length = 0
319         # Expect [group_name, [value, display]]
320         for choices_group in self.choices:
321             try:
322                 group_name, group_choices = choices_group
323             except (TypeError, ValueError):
324                 # Containing non-pairs
325                 break
326             try:
327                 if not all(
328                     self._choices_is_value(value) and self._choices_is_value(human_name)
329                     for value, human_name in group_choices
330                 ):
331                     break
332                 if self.max_length is not None and group_choices:
333                     choice_max_length = max(
334                         [
335                             choice_max_length,
336                             *(
337                                 len(value)
338                                 for value, _ in group_choices
339                                 if isinstance(value, str)
340                             ),
341                         ]
342                     )
343             except (TypeError, ValueError):
344                 # No groups, choices in the form [value, display]
345                 value, human_name = group_name, group_choices
346                 if not self._choices_is_value(value) or not self._choices_is_value(
347                     human_name
348                 ):
349                     break
350                 if self.max_length is not None and isinstance(value, str):
351                     choice_max_length = max(choice_max_length, len(value))
352 
353             # Special case: choices=['ab']
354             if isinstance(choices_group, str):
355                 break
356         else:
357             if self.max_length is not None and choice_max_length > self.max_length:
358                 return [
359                     checks.Error(
360                         "'max_length' is too small to fit the longest value "
361                         "in 'choices' (%d characters)." % choice_max_length,
362                         obj=self,
363                         id="fields.E009",
364                     ),
365                 ]
366             return []
367 
368         return [
369             checks.Error(
370                 "'choices' must be an iterable containing "
371                 "(actual value, human readable name) tuples.",
372                 obj=self,
373                 id="fields.E005",
374             )
375         ]
376 
377     def _check_db_index(self):
378         if self.db_index not in (None, True, False):
379             return [
380                 checks.Error(
381                     "'db_index' must be None, True or False.",
382                     obj=self,
383                     id="fields.E006",
384                 )
385             ]
386         else:
387             return []
388 
389     def _check_null_allowed_for_primary_keys(self):
390         if (
391             self.primary_key
392             and self.null
393             and not connection.features.interprets_empty_strings_as_nulls
394         ):
395             # We cannot reliably check this for backends like Oracle which
396             # consider NULL and '' to be equal (and thus set up
397             # character-based fields a little differently).
398             return [
399                 checks.Error(
400                     "Primary keys must not have null=True.",
401                     hint=(
402                         "Set null=False on the field, or "
403                         "remove primary_key=True argument."
404                     ),
405                     obj=self,
406                     id="fields.E007",
407                 )
408             ]
409         else:
410             return []
411 
412     def _check_backend_specific_checks(self, databases=None, **kwargs):
413         if databases is None:
414             return []
415         app_label = self.model._meta.app_label
416         errors = []
417         for alias in databases:
418             if router.allow_migrate(
419                 alias, app_label, model_name=self.model._meta.model_name
420             ):
421                 errors.extend(connections[alias].validation.check_field(self, **kwargs))
422         return errors
423 
424     def _check_validators(self):
425         errors = []
426         for i, validator in enumerate(self.validators):
427             if not callable(validator):
428                 errors.append(
429                     checks.Error(
430                         "All 'validators' must be callable.",
431                         hint=(
432                             "validators[{i}] ({repr}) isn't a function or "
433                             "instance of a validator class.".format(
434                                 i=i,
435                                 repr=repr(validator),
436                             )
437                         ),
438                         obj=self,
439                         id="fields.E008",
440                     )
441                 )
442         return errors
443 
444     def _check_deprecation_details(self):
445         if self.system_check_removed_details is not None:
446             return [
447                 checks.Error(
448                     self.system_check_removed_details.get(
449                         "msg",
450                         "%s has been removed except for support in historical "
451                         "migrations." % self.__class__.__name__,
452                     ),
453                     hint=self.system_check_removed_details.get("hint"),
454                     obj=self,
455                     id=self.system_check_removed_details.get("id", "fields.EXXX"),
456                 )
457             ]
458         elif self.system_check_deprecated_details is not None:
459             return [
460                 checks.Warning(
461                     self.system_check_deprecated_details.get(
462                         "msg", "%s has been deprecated." % self.__class__.__name__
463                     ),
464                     hint=self.system_check_deprecated_details.get("hint"),
465                     obj=self,
466                     id=self.system_check_deprecated_details.get("id", "fields.WXXX"),
467                 )
468             ]
469         return []
470 
471     def get_col(self, alias, output_field=None):
472         if alias == self.model._meta.db_table and (
473             output_field is None or output_field == self
474         ):
475             return self.cached_col
476         from django.db.models.expressions import Col
477 
478         return Col(alias, self, output_field)
479 
480     @cached_property
481     def cached_col(self):
482         from django.db.models.expressions import Col
483 
484         return Col(self.model._meta.db_table, self)
485 
486     def select_format(self, compiler, sql, params):
487         """
488         Custom format for select clauses. For example, GIS columns need to be
489         selected as AsText(table.col) on MySQL as the table.col data can't be
490         used by Django.
491         """
492         return sql, params
493 
494     def deconstruct(self):
495         """
496         Return enough information to recreate the field as a 4-tuple:
497 
498          * The name of the field on the model, if contribute_to_class() has
499            been run.
500          * The import path of the field, including the class, e.g.
501            django.db.models.IntegerField. This should be the most portable
502            version, so less specific may be better.
503          * A list of positional arguments.
504          * A dict of keyword arguments.
505 
506         Note that the positional or keyword arguments must contain values of
507         the following types (including inner values of collection types):
508 
509          * None, bool, str, int, float, complex, set, frozenset, list, tuple,
510            dict
511          * UUID
512          * datetime.datetime (naive), datetime.date
513          * top-level classes, top-level functions - will be referenced by their
514            full import path
515          * Storage instances - these have their own deconstruct() method
516 
517         This is because the values here must be serialized into a text format
518         (possibly new Python code, possibly JSON) and these are the only types
519         with encoding handlers defined.
520 
521         There's no need to return the exact way the field was instantiated this
522         time, just ensure that the resulting field is the same - prefer keyword
523         arguments over positional ones, and omit parameters with their default
524         values.
525         """
526         # Short-form way of fetching all the default parameters
527         keywords = {}
528         possibles = {
529             "verbose_name": None,
530             "primary_key": False,
531             "max_length": None,
532             "unique": False,
533             "blank": False,
534             "null": False,
535             "db_index": False,
536             "default": NOT_PROVIDED,
537             "editable": True,
538             "serialize": True,
539             "unique_for_date": None,
540             "unique_for_month": None,
541             "unique_for_year": None,
542             "choices": None,
543             "help_text": "",
544             "db_column": None,
545             "db_tablespace": None,
546             "auto_created": False,
547             "validators": [],
548             "error_messages": None,
549         }
550         attr_overrides = {
551             "unique": "_unique",
552             "error_messages": "_error_messages",
553             "validators": "_validators",
554             "verbose_name": "_verbose_name",
555             "db_tablespace": "_db_tablespace",
556         }
557         equals_comparison = {"choices", "validators"}
558         for name, default in possibles.items():
559             value = getattr(self, attr_overrides.get(name, name))
560             # Unroll anything iterable for choices into a concrete list
561             if name == "choices" and isinstance(value, collections.abc.Iterable):
562                 value = list(value)
563             # Do correct kind of comparison
564             if name in equals_comparison:
565                 if value != default:
566                     keywords[name] = value
567             else:
568                 if value is not default:
569                     keywords[name] = value
570         # Work out path - we shorten it for known Django core fields
571         path = "%s.%s" % (self.__class__.__module__, self.__class__.__qualname__)
572         if path.startswith("django.db.models.fields.related"):
573             path = path.replace("django.db.models.fields.related", "django.db.models")
574         elif path.startswith("django.db.models.fields.files"):
575             path = path.replace("django.db.models.fields.files", "django.db.models")
576         elif path.startswith("django.db.models.fields.json"):
577             path = path.replace("django.db.models.fields.json", "django.db.models")
578         elif path.startswith("django.db.models.fields.proxy"):
579             path = path.replace("django.db.models.fields.proxy", "django.db.models")
580         elif path.startswith("django.db.models.fields"):
581             path = path.replace("django.db.models.fields", "django.db.models")
582         # Return basic info - other fields should override this.
583         return (self.name, path, [], keywords)
584 
585     def clone(self):
586         """
587         Uses deconstruct() to clone a new copy of this Field.
588         Will not preserve any class attachments/attribute names.
589         """
590         name, path, args, kwargs = self.deconstruct()
591         return self.__class__(*args, **kwargs)
592 
593     def __eq__(self, other):
594         # Needed for @total_ordering
595         if isinstance(other, Field):
596             return self.creation_counter == other.creation_counter and getattr(
597                 self, "model", None
598             ) == getattr(other, "model", None)
599         return NotImplemented
600 
601     def __lt__(self, other):
602         # This is needed because bisect does not take a comparison function.
603         # Order by creation_counter first for backward compatibility.
604         if isinstance(other, Field):
605             if (
606                 self.creation_counter != other.creation_counter
607                 or not hasattr(self, "model")
608                 and not hasattr(other, "model")
609             ):
610                 return self.creation_counter < other.creation_counter
611             elif hasattr(self, "model") != hasattr(other, "model"):
612                 return not hasattr(self, "model")  # Order no-model fields first
613             else:
614                 # creation_counter's are equal, compare only models.
615                 return (self.model._meta.app_label, self.model._meta.model_name) < (
616                     other.model._meta.app_label,
617                     other.model._meta.model_name,
618                 )
619         return NotImplemented
620 
621     def __hash__(self):
622         return hash(self.creation_counter)
623 
624     def __deepcopy__(self, memodict):
625         # We don't have to deepcopy very much here, since most things are not
626         # intended to be altered after initial creation.
627         obj = copy.copy(self)
628         if self.remote_field:
629             obj.remote_field = copy.copy(self.remote_field)
630             if hasattr(self.remote_field, "field") and self.remote_field.field is self:
631                 obj.remote_field.field = obj
632         memodict[id(self)] = obj
633         return obj
634 
635     def __copy__(self):
636         # We need to avoid hitting __reduce__, so define this
637         # slightly weird copy construct.
638         obj = Empty()
639         obj.__class__ = self.__class__
640         obj.__dict__ = self.__dict__.copy()
641         return obj
642 
643     def __reduce__(self):
644         """
645         Pickling should return the model._meta.fields instance of the field,
646         not a new copy of that field. So, use the app registry to load the
647         model and then the field back.
648         """
649         if not hasattr(self, "model"):
650             # Fields are sometimes used without attaching them to models (for
651             # example in aggregation). In this case give back a plain field
652             # instance. The code below will create a new empty instance of
653             # class self.__class__, then update its dict with self.__dict__
654             # values - so, this is very close to normal pickle.
655             state = self.__dict__.copy()
656             # The _get_default cached_property can't be pickled due to lambda
657             # usage.
658             state.pop("_get_default", None)
659             return _empty, (self.__class__,), state
660         return _load_field, (
661             self.model._meta.app_label,
662             self.model._meta.object_name,
663             self.name,
664         )
665 
666     def get_pk_value_on_save(self, instance):
667         """
668         Hook to generate new PK values on save. This method is called when
669         saving instances with no primary key value set. If this method returns
670         something else than None, then the returned value is used when saving
671         the new instance.
672         """
673         if self.default:
674             return self.get_default()
675         return None
676 
677     def to_python(self, value):
678         """
679         Convert the input value into the expected Python data type, raising
680         django.core.exceptions.ValidationError if the data can't be converted.
681         Return the converted value. Subclasses should override this.
682         """
683         return value
684 
685     @cached_property
686     def error_messages(self):
687         messages = {}
688         for c in reversed(self.__class__.__mro__):
689             messages.update(getattr(c, "default_error_messages", {}))
690         messages.update(self._error_messages or {})
691         return messages
692 
693     @cached_property
694     def validators(self):
695         """
696         Some validators can't be created at field initialization time.
697         This method provides a way to delay their creation until required.
698         """
699         return [*self.default_validators, *self._validators]
700 
701     def run_validators(self, value):
702         if value in self.empty_values:
703             return
704 
705         errors = []
706         for v in self.validators:
707             try:
708                 v(value)
709             except exceptions.ValidationError as e:
710                 if hasattr(e, "code") and e.code in self.error_messages:
711                     e.message = self.error_messages[e.code]
712                 errors.extend(e.error_list)
713 
714         if errors:
715             raise exceptions.ValidationError(errors)
716 
717     def validate(self, value, model_instance):
718         """
719         Validate value and raise ValidationError if necessary. Subclasses
720         should override this to provide validation logic.
721         """
722         if not self.editable:
723             # Skip validation for non-editable fields.
724             return
725 
726         if self.choices is not None and value not in self.empty_values:
727             for option_key, option_value in self.choices:
728                 if isinstance(option_value, (list, tuple)):
729                     # This is an optgroup, so look inside the group for
730                     # options.
731                     for optgroup_key, optgroup_value in option_value:
732                         if value == optgroup_key:
733                             return
734                 elif value == option_key:
735                     return
736             raise exceptions.ValidationError(
737                 self.error_messages["invalid_choice"],
738                 code="invalid_choice",
739                 params={"value": value},
740             )
741 
742         if value is None and not self.null:
743             raise exceptions.ValidationError(self.error_messages["null"], code="null")
744 
745         if not self.blank and value in self.empty_values:
746             raise exceptions.ValidationError(self.error_messages["blank"], code="blank")
747 
748     def clean(self, value, model_instance):
749         """
750         Convert the value's type and run validation. Validation errors
751         from to_python() and validate() are propagated. Return the correct
752         value if no error is raised.
753         """
754         value = self.to_python(value)
755         self.validate(value, model_instance)
756         self.run_validators(value)
757         return value
758 
759     def db_type_parameters(self, connection):
760         return DictWrapper(self.__dict__, connection.ops.quote_name, "qn_")
761 
762     def db_check(self, connection):
763         """
764         Return the database column check constraint for this field, for the
765         provided connection. Works the same way as db_type() for the case that
766         get_internal_type() does not map to a preexisting model field.
767         """
768         data = self.db_type_parameters(connection)
769         try:
770             return (
771                 connection.data_type_check_constraints[self.get_internal_type()] % data
772             )
773         except KeyError:
774             return None
775 
776     def db_type(self, connection):
777         """
778         Return the database column data type for this field, for the provided
779         connection.
780         """
781         # The default implementation of this method looks at the
782         # backend-specific data_types dictionary, looking up the field by its
783         # "internal type".
784         #
785         # A Field class can implement the get_internal_type() method to specify
786         # which *preexisting* Django Field class it's most similar to -- i.e.,
787         # a custom field might be represented by a TEXT column type, which is
788         # the same as the TextField Django field type, which means the custom
789         # field's get_internal_type() returns 'TextField'.
790         #
791         # But the limitation of the get_internal_type() / data_types approach
792         # is that it cannot handle database column types that aren't already
793         # mapped to one of the built-in Django field types. In this case, you
794         # can implement db_type() instead of get_internal_type() to specify
795         # exactly which wacky database column type you want to use.
796         data = self.db_type_parameters(connection)
797         try:
798             return connection.data_types[self.get_internal_type()] % data
799         except KeyError:
800             return None
801 
802     def rel_db_type(self, connection):
803         """
804         Return the data type that a related field pointing to this field should
805         use. For example, this method is called by ForeignKey and OneToOneField
806         to determine its data type.
807         """
808         return self.db_type(connection)
809 
810     def cast_db_type(self, connection):
811         """Return the data type to use in the Cast() function."""
812         db_type = connection.ops.cast_data_types.get(self.get_internal_type())
813         if db_type:
814             return db_type % self.db_type_parameters(connection)
815         return self.db_type(connection)
816 
817     def db_parameters(self, connection):
818         """
819         Extension of db_type(), providing a range of different return values
820         (type, checks). This will look at db_type(), allowing custom model
821         fields to override it.
822         """
823         type_string = self.db_type(connection)
824         check_string = self.db_check(connection)
825         return {
826             "type": type_string,
827             "check": check_string,
828         }
829 
830     def db_type_suffix(self, connection):
831         return connection.data_types_suffix.get(self.get_internal_type())
832 
833     def get_db_converters(self, connection):
834         if hasattr(self, "from_db_value"):
835             return [self.from_db_value]
836         return []
837 
838     @property
839     def unique(self):
840         return self._unique or self.primary_key
841 
842     @property
843     def db_tablespace(self):
844         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE
845 
846     @property
847     def db_returning(self):
848         """
849         Private API intended only to be used by Django itself. Currently only
850         the PostgreSQL backend supports returning multiple fields on a model.
851         """
852         return False
853 
854     def set_attributes_from_name(self, name):
855         self.name = self.name or name
856         self.attname, self.column = self.get_attname_column()
857         self.concrete = self.column is not None
858         if self.verbose_name is None and self.name:
859             self.verbose_name = self.name.replace("_", " ")
860 
861     def contribute_to_class(self, cls, name, private_only=False):
862         """
863         Register the field with the model class it belongs to.
864 
865         If private_only is True, create a separate instance of this field
866         for every subclass of cls, even if cls is not an abstract model.
867         """
868         self.set_attributes_from_name(name)
869         self.model = cls
870         cls._meta.add_field(self, private=private_only)
871         if self.column:
872             setattr(cls, self.attname, self.descriptor_class(self))
873         if self.choices is not None:
874             # Don't override a get_FOO_display() method defined explicitly on
875             # this class, but don't check methods derived from inheritance, to
876             # allow overriding inherited choices. For more complex inheritance
877             # structures users should override contribute_to_class().
878             if "get_%s_display" % self.name not in cls.__dict__:
879                 setattr(
880                     cls,
881                     "get_%s_display" % self.name,
882                     partialmethod(cls._get_FIELD_display, field=self),
883                 )
884 
885     def get_filter_kwargs_for_object(self, obj):
886         """
887         Return a dict that when passed as kwargs to self.model.filter(), would
888         yield all instances having the same value for this field as obj has.
889         """
890         return {self.name: getattr(obj, self.attname)}
891 
892     def get_attname(self):
893         return self.name
894 
895     def get_attname_column(self):
896         attname = self.get_attname()
897         column = self.db_column or attname
898         return attname, column
899 
900     def get_internal_type(self):
901         return self.__class__.__name__
902 
903     def pre_save(self, model_instance, add):
904         """Return field's value just before saving."""
905         return getattr(model_instance, self.attname)
906 
907     def get_prep_value(self, value):
908         """Perform preliminary non-db specific value checks and conversions."""
909         if isinstance(value, Promise):
910             value = value._proxy____cast()
911         return value
912 
913     def get_db_prep_value(self, value, connection, prepared=False):
914         """
915         Return field's value prepared for interacting with the database backend.
916 
917         Used by the default implementations of get_db_prep_save().
918         """
919         if not prepared:
920             value = self.get_prep_value(value)
921         return value
922 
923     def get_db_prep_save(self, value, connection):
924         """Return field's value prepared for saving into a database."""
925         return self.get_db_prep_value(value, connection=connection, prepared=False)
926 
927     def has_default(self):
928         """Return a boolean of whether this field has a default value."""
929         return self.default is not NOT_PROVIDED
930 
931     def get_default(self):
932         """Return the default value for this field."""
933         return self._get_default()
934 
935     @cached_property
936     def _get_default(self):
937         if self.has_default():
938             if callable(self.default):
939                 return self.default
940             return lambda: self.default
941 
942         if (
943             not self.empty_strings_allowed
944             or self.null
945             and not connection.features.interprets_empty_strings_as_nulls
946         ):
947             return return_None
948         return str  # return empty string
949 
950     def get_choices(
951         self,
952         include_blank=True,
953         blank_choice=BLANK_CHOICE_DASH,
954         limit_choices_to=None,
955         ordering=(),
956     ):
957         """
958         Return choices with a default blank choices included, for use
959         as <select> choices for this field.
960         """
961         if self.choices is not None:
962             choices = list(self.choices)
963             if include_blank:
964                 blank_defined = any(
965                     choice in ("", None) for choice, _ in self.flatchoices
966                 )
967                 if not blank_defined:
968                     choices = blank_choice + choices
969             return choices
970         rel_model = self.remote_field.model
971         limit_choices_to = limit_choices_to or self.get_limit_choices_to()
972         choice_func = operator.attrgetter(
973             self.remote_field.get_related_field().attname
974             if hasattr(self.remote_field, "get_related_field")
975             else "pk"
976         )
977         qs = rel_model._default_manager.complex_filter(limit_choices_to)
978         if ordering:
979             qs = qs.order_by(*ordering)
980         return (blank_choice if include_blank else []) + [
981             (choice_func(x), str(x)) for x in qs
982         ]
983 
984     def value_to_string(self, obj):
985         """
986         Return a string value of this field from the passed obj.
987         This is used by the serialization framework.
988         """
989         return str(self.value_from_object(obj))
990 
991     def _get_flatchoices(self):
992         """Flattened version of choices tuple."""
993         if self.choices is None:
994             return []
995         flat = []
996         for choice, value in self.choices:
997             if isinstance(value, (list, tuple)):
998                 flat.extend(value)
999             else:
1000                 flat.append((choice, value))
1001         return flat
1002 
1003     flatchoices = property(_get_flatchoices)
1004 
1005     def save_form_data(self, instance, data):
1006         setattr(instance, self.name, data)
1007 
1008     def formfield(self, form_class=None, choices_form_class=None, **kwargs):
1009         """Return a django.forms.Field instance for this field."""
1010         defaults = {
1011             "required": not self.blank,
1012             "label": capfirst(self.verbose_name),
1013             "help_text": self.help_text,
1014         }
1015         if self.has_default():
1016             if callable(self.default):
1017                 defaults["initial"] = self.default
1018                 defaults["show_hidden_initial"] = True
1019             else:
1020                 defaults["initial"] = self.get_default()
1021         if self.choices is not None:
1022             # Fields with choices get special treatment.
1023             include_blank = self.blank or not (
1024                 self.has_default() or "initial" in kwargs
1025             )
1026             defaults["choices"] = self.get_choices(include_blank=include_blank)
1027             defaults["coerce"] = self.to_python
1028             if self.null:
1029                 defaults["empty_value"] = None
1030             if choices_form_class is not None:
1031                 form_class = choices_form_class
1032             else:
1033                 form_class = forms.TypedChoiceField
1034             # Many of the subclass-specific formfield arguments (min_value,
1035             # max_value) don't apply for choice fields, so be sure to only pass
1036             # the values that TypedChoiceField will understand.
1037             for k in list(kwargs):
1038                 if k not in (
1039                     "coerce",
1040                     "empty_value",
1041                     "choices",
1042                     "required",
1043                     "widget",
1044                     "label",
1045                     "initial",
1046                     "help_text",
1047                     "error_messages",
1048                     "show_hidden_initial",
1049                     "disabled",
1050                 ):
1051                     del kwargs[k]
1052         defaults.update(kwargs)
1053         if form_class is None:
1054             form_class = forms.CharField
1055         return form_class(**defaults)
1056 
1057     def value_from_object(self, obj):
1058         """Return the value of this field in the given model instance."""
1059         return getattr(obj, self.attname)
1060 
1061 
1062 class BooleanField(Field):
1063     empty_strings_allowed = False
1064     default_error_messages = {
1065         "invalid": _("“%(value)s” value must be either True or False."),
1066         "invalid_nullable": _("“%(value)s” value must be either True, False, or None."),
1067     }
1068     description = _("Boolean (Either True or False)")
1069 
1070     def get_internal_type(self):
1071         return "BooleanField"
1072 
1073     def to_python(self, value):
1074         if self.null and value in self.empty_values:
1075             return None
1076         if value in (True, False):
1077             # 1/0 are equal to True/False. bool() converts former to latter.
1078             return bool(value)
1079         if value in ("t", "True", "1"):
1080             return True
1081         if value in ("f", "False", "0"):
1082             return False
1083         raise exceptions.ValidationError(
1084             self.error_messages["invalid_nullable" if self.null else "invalid"],
1085             code="invalid",
1086             params={"value": value},
1087         )
1088 
1089     def get_prep_value(self, value):
1090         value = super().get_prep_value(value)
1091         if value is None:
1092             return None
1093         return self.to_python(value)
1094 
1095     def formfield(self, **kwargs):
1096         if self.choices is not None:
1097             include_blank = not (self.has_default() or "initial" in kwargs)
1098             defaults = {"choices": self.get_choices(include_blank=include_blank)}
1099         else:
1100             form_class = forms.NullBooleanField if self.null else forms.BooleanField
1101             # In HTML checkboxes, 'required' means "must be checked" which is
1102             # different from the choices case ("must select some value").
1103             # required=False allows unchecked checkboxes.
1104             defaults = {"form_class": form_class, "required": False}
1105         return super().formfield(**{**defaults, **kwargs})
1106 
1107     def select_format(self, compiler, sql, params):
1108         sql, params = super().select_format(compiler, sql, params)
1109         # Filters that match everything are handled as empty strings in the
1110         # WHERE clause, but in SELECT or GROUP BY list they must use a
1111         # predicate that's always True.
1112         if sql == "":
1113             sql = "1"
1114         return sql, params
1115 
1116 
1117 class CharField(Field):
1118     description = _("String (up to %(max_length)s)")
1119 
1120     def __init__(self, *args, db_collation=None, **kwargs):
1121         super().__init__(*args, **kwargs)
1122         self.db_collation = db_collation
1123         if self.max_length is not None:
1124             self.validators.append(validators.MaxLengthValidator(self.max_length))
1125 
1126     def check(self, **kwargs):
1127         databases = kwargs.get("databases") or []
1128         return [
1129             *super().check(**kwargs),
1130             *self._check_db_collation(databases),
1131             *self._check_max_length_attribute(**kwargs),
1132         ]
1133 
1134     def _check_max_length_attribute(self, **kwargs):
1135         if self.max_length is None:
1136             return [
1137                 checks.Error(
1138                     "CharFields must define a 'max_length' attribute.",
1139                     obj=self,
1140                     id="fields.E120",
1141                 )
1142             ]
1143         elif (
1144             not isinstance(self.max_length, int)
1145             or isinstance(self.max_length, bool)
1146             or self.max_length <= 0
1147         ):
1148             return [
1149                 checks.Error(
1150                     "'max_length' must be a positive integer.",
1151                     obj=self,
1152                     id="fields.E121",
1153                 )
1154             ]
1155         else:
1156             return []
1157 
1158     def _check_db_collation(self, databases):
1159         errors = []
1160         for db in databases:
1161             if not router.allow_migrate_model(db, self.model):
1162                 continue
1163             connection = connections[db]
1164             if not (
1165                 self.db_collation is None
1166                 or "supports_collation_on_charfield"
1167                 in self.model._meta.required_db_features
1168                 or connection.features.supports_collation_on_charfield
1169             ):
1170                 errors.append(
1171                     checks.Error(
1172                         "%s does not support a database collation on "
1173                         "CharFields." % connection.display_name,
1174                         obj=self,
1175                         id="fields.E190",
1176                     ),
1177                 )
1178         return errors
1179 
1180     def cast_db_type(self, connection):
1181         if self.max_length is None:
1182             return connection.ops.cast_char_field_without_max_length
1183         return super().cast_db_type(connection)
1184 
1185     def db_parameters(self, connection):
1186         db_params = super().db_parameters(connection)
1187         db_params["collation"] = self.db_collation
1188         return db_params
1189 
1190     def get_internal_type(self):
1191         return "CharField"
1192 
1193     def to_python(self, value):
1194         if isinstance(value, str) or value is None:
1195             return value
1196         return str(value)
1197 
1198     def get_prep_value(self, value):
1199         value = super().get_prep_value(value)
1200         return self.to_python(value)
1201 
1202     def formfield(self, **kwargs):
1203         # Passing max_length to forms.CharField means that the value's length
1204         # will be validated twice. This is considered acceptable since we want
1205         # the value in the form field (to pass into widget for example).
1206         defaults = {"max_length": self.max_length}
1207         # TODO: Handle multiple backends with different feature flags.
1208         if self.null and not connection.features.interprets_empty_strings_as_nulls:
1209             defaults["empty_value"] = None
1210         defaults.update(kwargs)
1211         return super().formfield(**defaults)
1212 
1213     def deconstruct(self):
1214         name, path, args, kwargs = super().deconstruct()
1215         if self.db_collation:
1216             kwargs["db_collation"] = self.db_collation
1217         return name, path, args, kwargs
1218 
1219 
1220 class CommaSeparatedIntegerField(CharField):
1221     default_validators = [validators.validate_comma_separated_integer_list]
1222     description = _("Comma-separated integers")
1223     system_check_removed_details = {
1224         "msg": (
1225             "CommaSeparatedIntegerField is removed except for support in "
1226             "historical migrations."
1227         ),
1228         "hint": (
1229             "Use CharField(validators=[validate_comma_separated_integer_list]) "
1230             "instead."
1231         ),
1232         "id": "fields.E901",
1233     }
1234 
1235 
1236 def _to_naive(value):
1237     if timezone.is_aware(value):
1238         value = timezone.make_naive(value, datetime.timezone.utc)
1239     return value
1240 
1241 
1242 def _get_naive_now():
1243     return _to_naive(timezone.now())
1244 
1245 
1246 class DateTimeCheckMixin:
1247     def check(self, **kwargs):
1248         return [
1249             *super().check(**kwargs),
1250             *self._check_mutually_exclusive_options(),
1251             *self._check_fix_default_value(),
1252         ]
1253 
1254     def _check_mutually_exclusive_options(self):
1255         # auto_now, auto_now_add, and default are mutually exclusive
1256         # options. The use of more than one of these options together
1257         # will trigger an Error
1258         mutually_exclusive_options = [
1259             self.auto_now_add,
1260             self.auto_now,
1261             self.has_default(),
1262         ]
1263         enabled_options = [
1264             option not in (None, False) for option in mutually_exclusive_options
1265         ].count(True)
1266         if enabled_options > 1:
1267             return [
1268                 checks.Error(
1269                     "The options auto_now, auto_now_add, and default "
1270                     "are mutually exclusive. Only one of these options "
1271                     "may be present.",
1272                     obj=self,
1273                     id="fields.E160",
1274                 )
1275             ]
1276         else:
1277             return []
1278 
1279     def _check_fix_default_value(self):
1280         return []
1281 
1282     # Concrete subclasses use this in their implementations of
1283     # _check_fix_default_value().
1284     def _check_if_value_fixed(self, value, now=None):
1285         """
1286         Check if the given value appears to have been provided as a "fixed"
1287         time value, and include a warning in the returned list if it does. The
1288         value argument must be a date object or aware/naive datetime object. If
1289         now is provided, it must be a naive datetime object.
1290         """
1291         if now is None:
1292             now = _get_naive_now()
1293         offset = datetime.timedelta(seconds=10)
1294         lower = now - offset
1295         upper = now + offset
1296         if isinstance(value, datetime.datetime):
1297             value = _to_naive(value)
1298         else:
1299             assert isinstance(value, datetime.date)
1300             lower = lower.date()
1301             upper = upper.date()
1302         if lower <= value <= upper:
1303             return [
1304                 checks.Warning(
1305                     "Fixed default value provided.",
1306                     hint=(
1307                         "It seems you set a fixed date / time / datetime "
1308                         "value as default for this field. This may not be "
1309                         "what you want. If you want to have the current date "
1310                         "as default, use `django.utils.timezone.now`"
1311                     ),
1312                     obj=self,
1313                     id="fields.W161",
1314                 )
1315             ]
1316         return []
1317 
1318 
1319 class DateField(DateTimeCheckMixin, Field):
1320     empty_strings_allowed = False
1321     default_error_messages = {
1322         "invalid": _(
1323             "“%(value)s” value has an invalid date format. It must be "
1324             "in YYYY-MM-DD format."
1325         ),
1326         "invalid_date": _(
1327             "“%(value)s” value has the correct format (YYYY-MM-DD) "
1328             "but it is an invalid date."
1329         ),
1330     }
1331     description = _("Date (without time)")
1332 
1333     def __init__(
1334         self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs
1335     ):
1336         self.auto_now, self.auto_now_add = auto_now, auto_now_add
1337         if auto_now or auto_now_add:
1338             kwargs["editable"] = False
1339             kwargs["blank"] = True
1340         super().__init__(verbose_name, name, **kwargs)
1341 
1342     def _check_fix_default_value(self):
1343         """
1344         Warn that using an actual date or datetime value is probably wrong;
1345         it's only evaluated on server startup.
1346         """
1347         if not self.has_default():
1348             return []
1349 
1350         value = self.default
1351         if isinstance(value, datetime.datetime):
1352             value = _to_naive(value).date()
1353         elif isinstance(value, datetime.date):
1354             pass
1355         else:
1356             # No explicit date / datetime value -- no checks necessary
1357             return []
1358         # At this point, value is a date object.
1359         return self._check_if_value_fixed(value)
1360 
1361     def deconstruct(self):
1362         name, path, args, kwargs = super().deconstruct()
1363         if self.auto_now:
1364             kwargs["auto_now"] = True
1365         if self.auto_now_add:
1366             kwargs["auto_now_add"] = True
1367         if self.auto_now or self.auto_now_add:
1368             del kwargs["editable"]
1369             del kwargs["blank"]
1370         return name, path, args, kwargs
1371 
1372     def get_internal_type(self):
1373         return "DateField"
1374 
1375     def to_python(self, value):
1376         if value is None:
1377             return value
1378         if isinstance(value, datetime.datetime):
1379             if settings.USE_TZ and timezone.is_aware(value):
1380                 # Convert aware datetimes to the default time zone
1381                 # before casting them to dates (#17742).
1382                 default_timezone = timezone.get_default_timezone()
1383                 value = timezone.make_naive(value, default_timezone)
1384             return value.date()
1385         if isinstance(value, datetime.date):
1386             return value
1387 
1388         try:
1389             parsed = parse_date(value)
1390             if parsed is not None:
1391                 return parsed
1392         except ValueError:
1393             raise exceptions.ValidationError(
1394                 self.error_messages["invalid_date"],
1395                 code="invalid_date",
1396                 params={"value": value},
1397             )
1398 
1399         raise exceptions.ValidationError(
1400             self.error_messages["invalid"],
1401             code="invalid",
1402             params={"value": value},
1403         )
1404 
1405     def pre_save(self, model_instance, add):
1406         if self.auto_now or (self.auto_now_add and add):
1407             value = datetime.date.today()
1408             setattr(model_instance, self.attname, value)
1409             return value
1410         else:
1411             return super().pre_save(model_instance, add)
1412 
1413     def contribute_to_class(self, cls, name, **kwargs):
1414         super().contribute_to_class(cls, name, **kwargs)
1415         if not self.null:
1416             setattr(
1417                 cls,
1418                 "get_next_by_%s" % self.name,
1419                 partialmethod(
1420                     cls._get_next_or_previous_by_FIELD, field=self, is_next=True
1421                 ),
1422             )
1423             setattr(
1424                 cls,
1425                 "get_previous_by_%s" % self.name,
1426                 partialmethod(
1427                     cls._get_next_or_previous_by_FIELD, field=self, is_next=False
1428                 ),
1429             )
1430 
1431     def get_prep_value(self, value):
1432         value = super().get_prep_value(value)
1433         return self.to_python(value)
1434 
1435     def get_db_prep_value(self, value, connection, prepared=False):
1436         # Casts dates into the format expected by the backend
1437         if not prepared:
1438             value = self.get_prep_value(value)
1439         return connection.ops.adapt_datefield_value(value)
1440 
1441     def value_to_string(self, obj):
1442         val = self.value_from_object(obj)
1443         return "" if val is None else val.isoformat()
1444 
1445     def formfield(self, **kwargs):
1446         return super().formfield(
1447             **{
1448                 "form_class": forms.DateField,
1449                 **kwargs,
1450             }
1451         )
1452 
1453 
1454 class DateTimeField(DateField):
1455     empty_strings_allowed = False
1456     default_error_messages = {
1457         "invalid": _(
1458             "“%(value)s” value has an invalid format. It must be in "
1459             "YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format."
1460         ),
1461         "invalid_date": _(
1462             "“%(value)s” value has the correct format "
1463             "(YYYY-MM-DD) but it is an invalid date."
1464         ),
1465         "invalid_datetime": _(
1466             "“%(value)s” value has the correct format "
1467             "(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) "
1468             "but it is an invalid date/time."
1469         ),
1470     }
1471     description = _("Date (with time)")
1472 
1473     # __init__ is inherited from DateField
1474 
1475     def _check_fix_default_value(self):
1476         """
1477         Warn that using an actual date or datetime value is probably wrong;
1478         it's only evaluated on server startup.
1479         """
1480         if not self.has_default():
1481             return []
1482 
1483         value = self.default
1484         if isinstance(value, (datetime.datetime, datetime.date)):
1485             return self._check_if_value_fixed(value)
1486         # No explicit date / datetime value -- no checks necessary.
1487         return []
1488 
1489     def get_internal_type(self):
1490         return "DateTimeField"
1491 
1492     def to_python(self, value):
1493         if value is None:
1494             return value
1495         if isinstance(value, datetime.datetime):
1496             return value
1497         if isinstance(value, datetime.date):
1498             value = datetime.datetime(value.year, value.month, value.day)
1499             if settings.USE_TZ:
1500                 # For backwards compatibility, interpret naive datetimes in
1501                 # local time. This won't work during DST change, but we can't
1502                 # do much about it, so we let the exceptions percolate up the
1503                 # call stack.
1504                 warnings.warn(
1505                     "DateTimeField %s.%s received a naive datetime "
1506                     "(%s) while time zone support is active."
1507                     % (self.model.__name__, self.name, value),
1508                     RuntimeWarning,
1509                 )
1510                 default_timezone = timezone.get_default_timezone()
1511                 value = timezone.make_aware(value, default_timezone)
1512             return value
1513 
1514         try:
1515             parsed = parse_datetime(value)
1516             if parsed is not None:
1517                 return parsed
1518         except ValueError:
1519             raise exceptions.ValidationError(
1520                 self.error_messages["invalid_datetime"],
1521                 code="invalid_datetime",
1522                 params={"value": value},
1523             )
1524 
1525         try:
1526             parsed = parse_date(value)
1527             if parsed is not None:
1528                 return datetime.datetime(parsed.year, parsed.month, parsed.day)
1529         except ValueError:
1530             raise exceptions.ValidationError(
1531                 self.error_messages["invalid_date"],
1532                 code="invalid_date",
1533                 params={"value": value},
1534             )
1535 
1536         raise exceptions.ValidationError(
1537             self.error_messages["invalid"],
1538             code="invalid",
1539             params={"value": value},
1540         )
1541 
1542     def pre_save(self, model_instance, add):
1543         if self.auto_now or (self.auto_now_add and add):
1544             value = timezone.now()
1545             setattr(model_instance, self.attname, value)
1546             return value
1547         else:
1548             return super().pre_save(model_instance, add)
1549 
1550     # contribute_to_class is inherited from DateField, it registers
1551     # get_next_by_FOO and get_prev_by_FOO
1552 
1553     def get_prep_value(self, value):
1554         value = super().get_prep_value(value)
1555         value = self.to_python(value)
1556         if value is not None and settings.USE_TZ and timezone.is_naive(value):
1557             # For backwards compatibility, interpret naive datetimes in local
1558             # time. This won't work during DST change, but we can't do much
1559             # about it, so we let the exceptions percolate up the call stack.
1560             try:
1561                 name = "%s.%s" % (self.model.__name__, self.name)
1562             except AttributeError:
1563                 name = "(unbound)"
1564             warnings.warn(
1565                 "DateTimeField %s received a naive datetime (%s)"
1566                 " while time zone support is active." % (name, value),
1567                 RuntimeWarning,
1568             )
1569             default_timezone = timezone.get_default_timezone()
1570             value = timezone.make_aware(value, default_timezone)
1571         return value
1572 
1573     def get_db_prep_value(self, value, connection, prepared=False):
1574         # Casts datetimes into the format expected by the backend
1575         if not prepared:
1576             value = self.get_prep_value(value)
1577         return connection.ops.adapt_datetimefield_value(value)
1578 
1579     def value_to_string(self, obj):
1580         val = self.value_from_object(obj)
1581         return "" if val is None else val.isoformat()
1582 
1583     def formfield(self, **kwargs):
1584         return super().formfield(
1585             **{
1586                 "form_class": forms.DateTimeField,
1587                 **kwargs,
1588             }
1589         )
1590 
1591 
1592 class DecimalField(Field):
1593     empty_strings_allowed = False
1594     default_error_messages = {
1595         "invalid": _("“%(value)s” value must be a decimal number."),
1596     }
1597     description = _("Decimal number")
1598 
1599     def __init__(
1600         self,
1601         verbose_name=None,
1602         name=None,
1603         max_digits=None,
1604         decimal_places=None,
1605         **kwargs,
1606     ):
1607         self.max_digits, self.decimal_places = max_digits, decimal_places
1608         super().__init__(verbose_name, name, **kwargs)
1609 
1610     def check(self, **kwargs):
1611         errors = super().check(**kwargs)
1612 
1613         digits_errors = [
1614             *self._check_decimal_places(),
1615             *self._check_max_digits(),
1616         ]
1617         if not digits_errors:
1618             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))
1619         else:
1620             errors.extend(digits_errors)
1621         return errors
1622 
1623     def _check_decimal_places(self):
1624         try:
1625             decimal_places = int(self.decimal_places)
1626             if decimal_places < 0:
1627                 raise ValueError()
1628         except TypeError:
1629             return [
1630                 checks.Error(
1631                     "DecimalFields must define a 'decimal_places' attribute.",
1632                     obj=self,
1633                     id="fields.E130",
1634                 )
1635             ]
1636         except ValueError:
1637             return [
1638                 checks.Error(
1639                     "'decimal_places' must be a non-negative integer.",
1640                     obj=self,
1641                     id="fields.E131",
1642                 )
1643             ]
1644         else:
1645             return []
1646 
1647     def _check_max_digits(self):
1648         try:
1649             max_digits = int(self.max_digits)
1650             if max_digits <= 0:
1651                 raise ValueError()
1652         except TypeError:
1653             return [
1654                 checks.Error(
1655                     "DecimalFields must define a 'max_digits' attribute.",
1656                     obj=self,
1657                     id="fields.E132",
1658                 )
1659             ]
1660         except ValueError:
1661             return [
1662                 checks.Error(
1663                     "'max_digits' must be a positive integer.",
1664                     obj=self,
1665                     id="fields.E133",
1666                 )
1667             ]
1668         else:
1669             return []
1670 
1671     def _check_decimal_places_and_max_digits(self, **kwargs):
1672         if int(self.decimal_places) > int(self.max_digits):
1673             return [
1674                 checks.Error(
1675                     "'max_digits' must be greater or equal to 'decimal_places'.",
1676                     obj=self,
1677                     id="fields.E134",
1678                 )
1679             ]
1680         return []
1681 
1682     @cached_property
1683     def validators(self):
1684         return super().validators + [
1685             validators.DecimalValidator(self.max_digits, self.decimal_places)
1686         ]
1687 
1688     @cached_property
1689     def context(self):
1690         return decimal.Context(prec=self.max_digits)
1691 
1692     def deconstruct(self):
1693         name, path, args, kwargs = super().deconstruct()
1694         if self.max_digits is not None:
1695             kwargs["max_digits"] = self.max_digits
1696         if self.decimal_places is not None:
1697             kwargs["decimal_places"] = self.decimal_places
1698         return name, path, args, kwargs
1699 
1700     def get_internal_type(self):
1701         return "DecimalField"
1702 
1703     def to_python(self, value):
1704         if value is None:
1705             return value
1706         if isinstance(value, float):
1707             if math.isnan(value):
1708                 raise exceptions.ValidationError(
1709                     self.error_messages["invalid"],
1710                     code="invalid",
1711                     params={"value": value},
1712                 )
1713             return self.context.create_decimal_from_float(value)
1714         try:
1715             return decimal.Decimal(value)
1716         except (decimal.InvalidOperation, TypeError, ValueError):
1717             raise exceptions.ValidationError(
1718                 self.error_messages["invalid"],
1719                 code="invalid",
1720                 params={"value": value},
1721             )
1722 
1723     def get_db_prep_save(self, value, connection):
1724         return connection.ops.adapt_decimalfield_value(
1725             self.to_python(value), self.max_digits, self.decimal_places
1726         )
1727 
1728     def get_prep_value(self, value):
1729         value = super().get_prep_value(value)
1730         return self.to_python(value)
1731 
1732     def formfield(self, **kwargs):
1733         return super().formfield(
1734             **{
1735                 "max_digits": self.max_digits,
1736                 "decimal_places": self.decimal_places,
1737                 "form_class": forms.DecimalField,
1738                 **kwargs,
1739             }
1740         )
1741 
1742 
1743 class DurationField(Field):
1744     """
1745     Store timedelta objects.
1746 
1747     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint
1748     of microseconds on other databases.
1749     """
1750 
1751     empty_strings_allowed = False
1752     default_error_messages = {
1753         "invalid": _(
1754             "“%(value)s” value has an invalid format. It must be in "
1755             "[DD] [[HH:]MM:]ss[.uuuuuu] format."
1756         )
1757     }
1758     description = _("Duration")
1759 
1760     def get_internal_type(self):
1761         return "DurationField"
1762 
1763     def to_python(self, value):
1764         if value is None:
1765             return value
1766         if isinstance(value, datetime.timedelta):
1767             return value
1768         try:
1769             parsed = parse_duration(value)
1770         except ValueError:
1771             pass
1772         else:
1773             if parsed is not None:
1774                 return parsed
1775 
1776         raise exceptions.ValidationError(
1777             self.error_messages["invalid"],
1778             code="invalid",
1779             params={"value": value},
1780         )
1781 
1782     def get_db_prep_value(self, value, connection, prepared=False):
1783         if connection.features.has_native_duration_field:
1784             return value
1785         if value is None:
1786             return None
1787         return duration_microseconds(value)
1788 
1789     def get_db_converters(self, connection):
1790         converters = []
1791         if not connection.features.has_native_duration_field:
1792             converters.append(connection.ops.convert_durationfield_value)
1793         return converters + super().get_db_converters(connection)
1794 
1795     def value_to_string(self, obj):
1796         val = self.value_from_object(obj)
1797         return "" if val is None else duration_string(val)
1798 
1799     def formfield(self, **kwargs):
1800         return super().formfield(
1801             **{
1802                 "form_class": forms.DurationField,
1803                 **kwargs,
1804             }
1805         )
1806 
1807 
1808 class EmailField(CharField):
1809     default_validators = [validators.validate_email]
1810     description = _("Email address")
1811 
1812     def __init__(self, *args, **kwargs):
1813         # max_length=254 to be compliant with RFCs 3696 and 5321
1814         kwargs.setdefault("max_length", 254)
1815         super().__init__(*args, **kwargs)
1816 
1817     def deconstruct(self):
1818         name, path, args, kwargs = super().deconstruct()
1819         # We do not exclude max_length if it matches default as we want to change
1820         # the default in future.
1821         return name, path, args, kwargs
1822 
1823     def formfield(self, **kwargs):
1824         # As with CharField, this will cause email validation to be performed
1825         # twice.
1826         return super().formfield(
1827             **{
1828                 "form_class": forms.EmailField,
1829                 **kwargs,
1830             }
1831         )
1832 
1833 
1834 class FilePathField(Field):
1835     description = _("File path")
1836 
1837     def __init__(
1838         self,
1839         verbose_name=None,
1840         name=None,
1841         path="",
1842         match=None,
1843         recursive=False,
1844         allow_files=True,
1845         allow_folders=False,
1846         **kwargs,
1847     ):
1848         self.path, self.match, self.recursive = path, match, recursive
1849         self.allow_files, self.allow_folders = allow_files, allow_folders
1850         kwargs.setdefault("max_length", 100)
1851         super().__init__(verbose_name, name, **kwargs)
1852 
1853     def check(self, **kwargs):
1854         return [
1855             *super().check(**kwargs),
1856             *self._check_allowing_files_or_folders(**kwargs),
1857         ]
1858 
1859     def _check_allowing_files_or_folders(self, **kwargs):
1860         if not self.allow_files and not self.allow_folders:
1861             return [
1862                 checks.Error(
1863                     "FilePathFields must have either 'allow_files' or 'allow_folders' "
1864                     "set to True.",
1865                     obj=self,
1866                     id="fields.E140",
1867                 )
1868             ]
1869         return []
1870 
1871     def deconstruct(self):
1872         name, path, args, kwargs = super().deconstruct()
1873         if self.path != "":
1874             kwargs["path"] = self.path
1875         if self.match is not None:
1876             kwargs["match"] = self.match
1877         if self.recursive is not False:
1878             kwargs["recursive"] = self.recursive
1879         if self.allow_files is not True:
1880             kwargs["allow_files"] = self.allow_files
1881         if self.allow_folders is not False:
1882             kwargs["allow_folders"] = self.allow_folders
1883         if kwargs.get("max_length") == 100:
1884             del kwargs["max_length"]
1885         return name, path, args, kwargs
1886 
1887     def get_prep_value(self, value):
1888         value = super().get_prep_value(value)
1889         if value is None:
1890             return None
1891         return str(value)
1892 
1893     def formfield(self, **kwargs):
1894         return super().formfield(
1895             **{
1896                 "path": self.path() if callable(self.path) else self.path,
1897                 "match": self.match,
1898                 "recursive": self.recursive,
1899                 "form_class": forms.FilePathField,
1900                 "allow_files": self.allow_files,
1901                 "allow_folders": self.allow_folders,
1902                 **kwargs,
1903             }
1904         )
1905 
1906     def get_internal_type(self):
1907         return "FilePathField"
1908 
1909 
1910 class FloatField(Field):
1911     empty_strings_allowed = False
1912     default_error_messages = {
1913         "invalid": _("“%(value)s” value must be a float."),
1914     }
1915     description = _("Floating point number")
1916 
1917     def get_prep_value(self, value):
1918         value = super().get_prep_value(value)
1919         if value is None:
1920             return None
1921         try:
1922             return float(value)
1923         except (TypeError, ValueError) as e:
1924             raise e.__class__(
1925                 "Field '%s' expected a number but got %r." % (self.name, value),
1926             ) from e
1927 
1928     def get_internal_type(self):
1929         return "FloatField"
1930 
1931     def to_python(self, value):
1932         if value is None:
1933             return value
1934         try:
1935             return float(value)
1936         except (TypeError, ValueError):
1937             raise exceptions.ValidationError(
1938                 self.error_messages["invalid"],
1939                 code="invalid",
1940                 params={"value": value},
1941             )
1942 
1943     def formfield(self, **kwargs):
1944         return super().formfield(
1945             **{
1946                 "form_class": forms.FloatField,
1947                 **kwargs,
1948             }
1949         )
1950 
1951 
1952 class IntegerField(Field):
1953     empty_strings_allowed = False
1954     default_error_messages = {
1955         "invalid": _("“%(value)s” value must be an integer."),
1956     }
1957     description = _("Integer")
1958 
1959     def check(self, **kwargs):
1960         return [
1961             *super().check(**kwargs),
1962             *self._check_max_length_warning(),
1963         ]
1964 
1965     def _check_max_length_warning(self):
1966         if self.max_length is not None:
1967             return [
1968                 checks.Warning(
1969                     "'max_length' is ignored when used with %s."
1970                     % self.__class__.__name__,
1971                     hint="Remove 'max_length' from field",
1972                     obj=self,
1973                     id="fields.W122",
1974                 )
1975             ]
1976         return []
1977 
1978     @cached_property
1979     def validators(self):
1980         # These validators can't be added at field initialization time since
1981         # they're based on values retrieved from `connection`.
1982         validators_ = super().validators
1983         internal_type = self.get_internal_type()
1984         min_value, max_value = connection.ops.integer_field_range(internal_type)
1985         if min_value is not None and not any(
1986             (
1987                 isinstance(validator, validators.MinValueValidator)
1988                 and (
1989                     validator.limit_value()
1990                     if callable(validator.limit_value)
1991                     else validator.limit_value
1992                 )
1993                 >= min_value
1994             )
1995             for validator in validators_
1996         ):
1997             validators_.append(validators.MinValueValidator(min_value))
1998         if max_value is not None and not any(
1999             (
2000                 isinstance(validator, validators.MaxValueValidator)
2001                 and (
2002                     validator.limit_value()
2003                     if callable(validator.limit_value)
2004                     else validator.limit_value
2005                 )
2006                 <= max_value
2007             )
2008             for validator in validators_
2009         ):
2010             validators_.append(validators.MaxValueValidator(max_value))
2011         return validators_
2012 
2013     def get_prep_value(self, value):
2014         value = super().get_prep_value(value)
2015         if value is None:
2016             return None
2017         try:
2018             return int(value)
2019         except (TypeError, ValueError) as e:
2020             raise e.__class__(
2021                 "Field '%s' expected a number but got %r." % (self.name, value),
2022             ) from e
2023 
2024     def get_internal_type(self):
2025         return "IntegerField"
2026 
2027     def to_python(self, value):
2028         if value is None:
2029             return value
2030         try:
2031             return int(value)
2032         except (TypeError, ValueError):
2033             raise exceptions.ValidationError(
2034                 self.error_messages["invalid"],
2035                 code="invalid",
2036                 params={"value": value},
2037             )
2038 
2039     def formfield(self, **kwargs):
2040         return super().formfield(
2041             **{
2042                 "form_class": forms.IntegerField,
2043                 **kwargs,
2044             }
2045         )
2046 
2047 
2048 class BigIntegerField(IntegerField):
2049     description = _("Big (8 byte) integer")
2050     MAX_BIGINT = 9223372036854775807
2051 
2052     def get_internal_type(self):
2053         return "BigIntegerField"
2054 
2055     def formfield(self, **kwargs):
2056         return super().formfield(
2057             **{
2058                 "min_value": -BigIntegerField.MAX_BIGINT - 1,
2059                 "max_value": BigIntegerField.MAX_BIGINT,
2060                 **kwargs,
2061             }
2062         )
2063 
2064 
2065 class SmallIntegerField(IntegerField):
2066     description = _("Small integer")
2067 
2068     def get_internal_type(self):
2069         return "SmallIntegerField"
2070 
2071 
2072 class IPAddressField(Field):
2073     empty_strings_allowed = False
2074     description = _("IPv4 address")
2075     system_check_removed_details = {
2076         "msg": (
2077             "IPAddressField has been removed except for support in "
2078             "historical migrations."
2079         ),
2080         "hint": "Use GenericIPAddressField instead.",
2081         "id": "fields.E900",
2082     }
2083 
2084     def __init__(self, *args, **kwargs):
2085         kwargs["max_length"] = 15
2086         super().__init__(*args, **kwargs)
2087 
2088     def deconstruct(self):
2089         name, path, args, kwargs = super().deconstruct()
2090         del kwargs["max_length"]
2091         return name, path, args, kwargs
2092 
2093     def get_prep_value(self, value):
2094         value = super().get_prep_value(value)
2095         if value is None:
2096             return None
2097         return str(value)
2098 
2099     def get_internal_type(self):
2100         return "IPAddressField"
2101 
2102 
2103 class GenericIPAddressField(Field):
2104     empty_strings_allowed = False
2105     description = _("IP address")
2106     default_error_messages = {}
2107 
2108     def __init__(
2109         self,
2110         verbose_name=None,
2111         name=None,
2112         protocol="both",
2113         unpack_ipv4=False,
2114         *args,
2115         **kwargs,
2116     ):
2117         self.unpack_ipv4 = unpack_ipv4
2118         self.protocol = protocol
2119         (
2120             self.default_validators,
2121             invalid_error_message,
2122         ) = validators.ip_address_validators(protocol, unpack_ipv4)
2123         self.default_error_messages["invalid"] = invalid_error_message
2124         kwargs["max_length"] = 39
2125         super().__init__(verbose_name, name, *args, **kwargs)
2126 
2127     def check(self, **kwargs):
2128         return [
2129             *super().check(**kwargs),
2130             *self._check_blank_and_null_values(**kwargs),
2131         ]
2132 
2133     def _check_blank_and_null_values(self, **kwargs):
2134         if not getattr(self, "null", False) and getattr(self, "blank", False):
2135             return [
2136                 checks.Error(
2137                     "GenericIPAddressFields cannot have blank=True if null=False, "
2138                     "as blank values are stored as nulls.",
2139                     obj=self,
2140                     id="fields.E150",
2141                 )
2142             ]
2143         return []
2144 
2145     def deconstruct(self):
2146         name, path, args, kwargs = super().deconstruct()
2147         if self.unpack_ipv4 is not False:
2148             kwargs["unpack_ipv4"] = self.unpack_ipv4
2149         if self.protocol != "both":
2150             kwargs["protocol"] = self.protocol
2151         if kwargs.get("max_length") == 39:
2152             del kwargs["max_length"]
2153         return name, path, args, kwargs
2154 
2155     def get_internal_type(self):
2156         return "GenericIPAddressField"
2157 
2158     def to_python(self, value):
2159         if value is None:
2160             return None
2161         if not isinstance(value, str):
2162             value = str(value)
2163         value = value.strip()
2164         if ":" in value:
2165             return clean_ipv6_address(
2166                 value, self.unpack_ipv4, self.error_messages["invalid"]
2167             )
2168         return value
2169 
2170     def get_db_prep_value(self, value, connection, prepared=False):
2171         if not prepared:
2172             value = self.get_prep_value(value)
2173         return connection.ops.adapt_ipaddressfield_value(value)
2174 
2175     def get_prep_value(self, value):
2176         value = super().get_prep_value(value)
2177         if value is None:
2178             return None
2179         if value and ":" in value:
2180             try:
2181                 return clean_ipv6_address(value, self.unpack_ipv4)
2182             except exceptions.ValidationError:
2183                 pass
2184         return str(value)
2185 
2186     def formfield(self, **kwargs):
2187         return super().formfield(
2188             **{
2189                 "protocol": self.protocol,
2190                 "form_class": forms.GenericIPAddressField,
2191                 **kwargs,
2192             }
2193         )
2194 
2195 
2196 class NullBooleanField(BooleanField):
2197     default_error_messages = {
2198         "invalid": _("“%(value)s” value must be either None, True or False."),
2199         "invalid_nullable": _("“%(value)s” value must be either None, True or False."),
2200     }
2201     description = _("Boolean (Either True, False or None)")
2202     system_check_removed_details = {
2203         "msg": (
2204             "NullBooleanField is removed except for support in historical "
2205             "migrations."
2206         ),
2207         "hint": "Use BooleanField(null=True) instead.",
2208         "id": "fields.E903",
2209     }
2210 
2211     def __init__(self, *args, **kwargs):
2212         kwargs["null"] = True
2213         kwargs["blank"] = True
2214         super().__init__(*args, **kwargs)
2215 
2216     def deconstruct(self):
2217         name, path, args, kwargs = super().deconstruct()
2218         del kwargs["null"]
2219         del kwargs["blank"]
2220         return name, path, args, kwargs
2221 
2222 
2223 class PositiveIntegerRelDbTypeMixin:
2224     def __init_subclass__(cls, **kwargs):
2225         super().__init_subclass__(**kwargs)
2226         if not hasattr(cls, "integer_field_class"):
2227             cls.integer_field_class = next(
2228                 (
2229                     parent
2230                     for parent in cls.__mro__[1:]
2231                     if issubclass(parent, IntegerField)
2232                 ),
2233                 None,
2234             )
2235 
2236     def rel_db_type(self, connection):
2237         """
2238         Return the data type that a related field pointing to this field should
2239         use. In most cases, a foreign key pointing to a positive integer
2240         primary key will have an integer column data type but some databases
2241         (e.g. MySQL) have an unsigned integer type. In that case
2242         (related_fields_match_type=True), the primary key should return its
2243         db_type.
2244         """
2245         if connection.features.related_fields_match_type:
2246             return self.db_type(connection)
2247         else:
2248             return self.integer_field_class().db_type(connection=connection)
2249 
2250 
2251 class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, BigIntegerField):
2252     description = _("Positive big integer")
2253 
2254     def get_internal_type(self):
2255         return "PositiveBigIntegerField"
2256 
2257     def formfield(self, **kwargs):
2258         return super().formfield(
2259             **{
2260                 "min_value": 0,
2261                 **kwargs,
2262             }
2263         )
2264 
2265 
2266 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
2267     description = _("Positive integer")
2268 
2269     def get_internal_type(self):
2270         return "PositiveIntegerField"
2271 
2272     def formfield(self, **kwargs):
2273         return super().formfield(
2274             **{
2275                 "min_value": 0,
2276                 **kwargs,
2277             }
2278         )
2279 
2280 
2281 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, SmallIntegerField):
2282     description = _("Positive small integer")
2283 
2284     def get_internal_type(self):
2285         return "PositiveSmallIntegerField"
2286 
2287     def formfield(self, **kwargs):
2288         return super().formfield(
2289             **{
2290                 "min_value": 0,
2291                 **kwargs,
2292             }
2293         )
2294 
2295 
2296 class SlugField(CharField):
2297     default_validators = [validators.validate_slug]
2298     description = _("Slug (up to %(max_length)s)")
2299 
2300     def __init__(
2301         self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs
2302     ):
2303         self.allow_unicode = allow_unicode
2304         if self.allow_unicode:
2305             self.default_validators = [validators.validate_unicode_slug]
2306         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)
2307 
2308     def deconstruct(self):
2309         name, path, args, kwargs = super().deconstruct()
2310         if kwargs.get("max_length") == 50:
2311             del kwargs["max_length"]
2312         if self.db_index is False:
2313             kwargs["db_index"] = False
2314         else:
2315             del kwargs["db_index"]
2316         if self.allow_unicode is not False:
2317             kwargs["allow_unicode"] = self.allow_unicode
2318         return name, path, args, kwargs
2319 
2320     def get_internal_type(self):
2321         return "SlugField"
2322 
2323     def formfield(self, **kwargs):
2324         return super().formfield(
2325             **{
2326                 "form_class": forms.SlugField,
2327                 "allow_unicode": self.allow_unicode,
2328                 **kwargs,
2329             }
2330         )
2331 
2332 
2333 class TextField(Field):
2334     description = _("Text")
2335 
2336     def __init__(self, *args, db_collation=None, **kwargs):
2337         super().__init__(*args, **kwargs)
2338         self.db_collation = db_collation
2339 
2340     def check(self, **kwargs):
2341         databases = kwargs.get("databases") or []
2342         return [
2343             *super().check(**kwargs),
2344             *self._check_db_collation(databases),
2345         ]
2346 
2347     def _check_db_collation(self, databases):
2348         errors = []
2349         for db in databases:
2350             if not router.allow_migrate_model(db, self.model):
2351                 continue
2352             connection = connections[db]
2353             if not (
2354                 self.db_collation is None
2355                 or "supports_collation_on_textfield"
2356                 in self.model._meta.required_db_features
2357                 or connection.features.supports_collation_on_textfield
2358             ):
2359                 errors.append(
2360                     checks.Error(
2361                         "%s does not support a database collation on "
2362                         "TextFields." % connection.display_name,
2363                         obj=self,
2364                         id="fields.E190",
2365                     ),
2366                 )
2367         return errors
2368 
2369     def db_parameters(self, connection):
2370         db_params = super().db_parameters(connection)
2371         db_params["collation"] = self.db_collation
2372         return db_params
2373 
2374     def get_internal_type(self):
2375         return "TextField"
2376 
2377     def to_python(self, value):
2378         if isinstance(value, str) or value is None:
2379             return value
2380         return str(value)
2381 
2382     def get_prep_value(self, value):
2383         value = super().get_prep_value(value)
2384         return self.to_python(value)
2385 
2386     def formfield(self, **kwargs):
2387         # Passing max_length to forms.CharField means that the value's length
2388         # will be validated twice. This is considered acceptable since we want
2389         # the value in the form field (to pass into widget for example).
2390         return super().formfield(
2391             **{
2392                 "max_length": self.max_length,
2393                 **({} if self.choices is not None else {"widget": forms.Textarea}),
2394                 **kwargs,
2395             }
2396         )
2397 
2398     def deconstruct(self):
2399         name, path, args, kwargs = super().deconstruct()
2400         if self.db_collation:
2401             kwargs["db_collation"] = self.db_collation
2402         return name, path, args, kwargs
2403 
2404 
2405 class TimeField(DateTimeCheckMixin, Field):
2406     empty_strings_allowed = False
2407     default_error_messages = {
2408         "invalid": _(
2409             "“%(value)s” value has an invalid format. It must be in "
2410             "HH:MM[:ss[.uuuuuu]] format."
2411         ),
2412         "invalid_time": _(
2413             "“%(value)s” value has the correct format "
2414             "(HH:MM[:ss[.uuuuuu]]) but it is an invalid time."
2415         ),
2416     }
2417     description = _("Time")
2418 
2419     def __init__(
2420         self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs
2421     ):
2422         self.auto_now, self.auto_now_add = auto_now, auto_now_add
2423         if auto_now or auto_now_add:
2424             kwargs["editable"] = False
2425             kwargs["blank"] = True
2426         super().__init__(verbose_name, name, **kwargs)
2427 
2428     def _check_fix_default_value(self):
2429         """
2430         Warn that using an actual date or datetime value is probably wrong;
2431         it's only evaluated on server startup.
2432         """
2433         if not self.has_default():
2434             return []
2435 
2436         value = self.default
2437         if isinstance(value, datetime.datetime):
2438             now = None
2439         elif isinstance(value, datetime.time):
2440             now = _get_naive_now()
2441             # This will not use the right date in the race condition where now
2442             # is just before the date change and value is just past 0:00.
2443             value = datetime.datetime.combine(now.date(), value)
2444         else:
2445             # No explicit time / datetime value -- no checks necessary
2446             return []
2447         # At this point, value is a datetime object.
2448         return self._check_if_value_fixed(value, now=now)
2449 
2450     def deconstruct(self):
2451         name, path, args, kwargs = super().deconstruct()
2452         if self.auto_now is not False:
2453             kwargs["auto_now"] = self.auto_now
2454         if self.auto_now_add is not False:
2455             kwargs["auto_now_add"] = self.auto_now_add
2456         if self.auto_now or self.auto_now_add:
2457             del kwargs["blank"]
2458             del kwargs["editable"]
2459         return name, path, args, kwargs
2460 
2461     def get_internal_type(self):
2462         return "TimeField"
2463 
2464     def to_python(self, value):
2465         if value is None:
2466             return None
2467         if isinstance(value, datetime.time):
2468             return value
2469         if isinstance(value, datetime.datetime):
2470             # Not usually a good idea to pass in a datetime here (it loses
2471             # information), but this can be a side-effect of interacting with a
2472             # database backend (e.g. Oracle), so we'll be accommodating.
2473             return value.time()
2474 
2475         try:
2476             parsed = parse_time(value)
2477             if parsed is not None:
2478                 return parsed
2479         except ValueError:
2480             raise exceptions.ValidationError(
2481                 self.error_messages["invalid_time"],
2482                 code="invalid_time",
2483                 params={"value": value},
2484             )
2485 
2486         raise exceptions.ValidationError(
2487             self.error_messages["invalid"],
2488             code="invalid",
2489             params={"value": value},
2490         )
2491 
2492     def pre_save(self, model_instance, add):
2493         if self.auto_now or (self.auto_now_add and add):
2494             value = datetime.datetime.now().time()
2495             setattr(model_instance, self.attname, value)
2496             return value
2497         else:
2498             return super().pre_save(model_instance, add)
2499 
2500     def get_prep_value(self, value):
2501         value = super().get_prep_value(value)
2502         return self.to_python(value)
2503 
2504     def get_db_prep_value(self, value, connection, prepared=False):
2505         # Casts times into the format expected by the backend
2506         if not prepared:
2507             value = self.get_prep_value(value)
2508         return connection.ops.adapt_timefield_value(value)
2509 
2510     def value_to_string(self, obj):
2511         val = self.value_from_object(obj)
2512         return "" if val is None else val.isoformat()
2513 
2514     def formfield(self, **kwargs):
2515         return super().formfield(
2516             **{
2517                 "form_class": forms.TimeField,
2518                 **kwargs,
2519             }
2520         )
2521 
2522 
2523 class URLField(CharField):
2524     default_validators = [validators.URLValidator()]
2525     description = _("URL")
2526 
2527     def __init__(self, verbose_name=None, name=None, **kwargs):
2528         kwargs.setdefault("max_length", 200)
2529         super().__init__(verbose_name, name, **kwargs)
2530 
2531     def deconstruct(self):
2532         name, path, args, kwargs = super().deconstruct()
2533         if kwargs.get("max_length") == 200:
2534             del kwargs["max_length"]
2535         return name, path, args, kwargs
2536 
2537     def formfield(self, **kwargs):
2538         # As with CharField, this will cause URL validation to be performed
2539         # twice.
2540         return super().formfield(
2541             **{
2542                 "form_class": forms.URLField,
2543                 **kwargs,
2544             }
2545         )
2546 
2547 
2548 class BinaryField(Field):
2549     description = _("Raw binary data")
2550     empty_values = [None, b""]
2551 
2552     def __init__(self, *args, **kwargs):
2553         kwargs.setdefault("editable", False)
2554         super().__init__(*args, **kwargs)
2555         if self.max_length is not None:
2556             self.validators.append(validators.MaxLengthValidator(self.max_length))
2557 
2558     def check(self, **kwargs):
2559         return [*super().check(**kwargs), *self._check_str_default_value()]
2560 
2561     def _check_str_default_value(self):
2562         if self.has_default() and isinstance(self.default, str):
2563             return [
2564                 checks.Error(
2565                     "BinaryField's default cannot be a string. Use bytes "
2566                     "content instead.",
2567                     obj=self,
2568                     id="fields.E170",
2569                 )
2570             ]
2571         return []
2572 
2573     def deconstruct(self):
2574         name, path, args, kwargs = super().deconstruct()
2575         if self.editable:
2576             kwargs["editable"] = True
2577         else:
2578             del kwargs["editable"]
2579         return name, path, args, kwargs
2580 
2581     def get_internal_type(self):
2582         return "BinaryField"
2583 
2584     def get_placeholder(self, value, compiler, connection):
2585         return connection.ops.binary_placeholder_sql(value)
2586 
2587     def get_default(self):
2588         if self.has_default() and not callable(self.default):
2589             return self.default
2590         default = super().get_default()
2591         if default == "":
2592             return b""
2593         return default
2594 
2595     def get_db_prep_value(self, value, connection, prepared=False):
2596         value = super().get_db_prep_value(value, connection, prepared)
2597         if value is not None:
2598             return connection.Database.Binary(value)
2599         return value
2600 
2601     def value_to_string(self, obj):
2602         """Binary data is serialized as base64"""
2603         return b64encode(self.value_from_object(obj)).decode("ascii")
2604 
2605     def to_python(self, value):
2606         # If it's a string, it should be base64-encoded data
2607         if isinstance(value, str):
2608             return memoryview(b64decode(value.encode("ascii")))
2609         return value
2610 
2611 
2612 class UUIDField(Field):
2613     default_error_messages = {
2614         "invalid": _("“%(value)s” is not a valid UUID."),
2615     }
2616     description = _("Universally unique identifier")
2617     empty_strings_allowed = False
2618 
2619     def __init__(self, verbose_name=None, **kwargs):
2620         kwargs["max_length"] = 32
2621         super().__init__(verbose_name, **kwargs)
2622 
2623     def deconstruct(self):
2624         name, path, args, kwargs = super().deconstruct()
2625         del kwargs["max_length"]
2626         return name, path, args, kwargs
2627 
2628     def get_internal_type(self):
2629         return "UUIDField"
2630 
2631     def get_prep_value(self, value):
2632         value = super().get_prep_value(value)
2633         return self.to_python(value)
2634 
2635     def get_db_prep_value(self, value, connection, prepared=False):
2636         if value is None:
2637             return None
2638         if not isinstance(value, uuid.UUID):
2639             value = self.to_python(value)
2640 
2641         if connection.features.has_native_uuid_field:
2642             return value
2643         return value.hex
2644 
2645     def to_python(self, value):
2646         if value is not None and not isinstance(value, uuid.UUID):
2647             input_form = "int" if isinstance(value, int) else "hex"
2648             try:
2649                 return uuid.UUID(**{input_form: value})
2650             except (AttributeError, ValueError):
2651                 raise exceptions.ValidationError(
2652                     self.error_messages["invalid"],
2653                     code="invalid",
2654                     params={"value": value},
2655                 )
2656         return value
2657 
2658     def formfield(self, **kwargs):
2659         return super().formfield(
2660             **{
2661                 "form_class": forms.UUIDField,
2662                 **kwargs,
2663             }
2664         )
2665 
2666 
2667 class AutoFieldMixin:
2668     db_returning = True
2669 
2670     def __init__(self, *args, **kwargs):
2671         kwargs["blank"] = True
2672         super().__init__(*args, **kwargs)
2673 
2674     def check(self, **kwargs):
2675         return [
2676             *super().check(**kwargs),
2677             *self._check_primary_key(),
2678         ]
2679 
2680     def _check_primary_key(self):
2681         if not self.primary_key:
2682             return [
2683                 checks.Error(
2684                     "AutoFields must set primary_key=True.",
2685                     obj=self,
2686                     id="fields.E100",
2687                 ),
2688             ]
2689         else:
2690             return []
2691 
2692     def deconstruct(self):
2693         name, path, args, kwargs = super().deconstruct()
2694         del kwargs["blank"]
2695         kwargs["primary_key"] = True
2696         return name, path, args, kwargs
2697 
2698     def validate(self, value, model_instance):
2699         pass
2700 
2701     def get_db_prep_value(self, value, connection, prepared=False):
2702         if not prepared:
2703             value = self.get_prep_value(value)
2704             value = connection.ops.validate_autopk_value(value)
2705         return value
2706 
2707     def contribute_to_class(self, cls, name, **kwargs):
2708         if cls._meta.auto_field:
2709             raise ValueError(
2710                 "Model %s can't have more than one auto-generated field."
2711                 % cls._meta.label
2712             )
2713         super().contribute_to_class(cls, name, **kwargs)
2714         cls._meta.auto_field = self
2715 
2716     def formfield(self, **kwargs):
2717         return None
2718 
2719 
2720 class AutoFieldMeta(type):
2721     """
2722     Metaclass to maintain backward inheritance compatibility for AutoField.
2723 
2724     It is intended that AutoFieldMixin become public API when it is possible to
2725     create a non-integer automatically-generated field using column defaults
2726     stored in the database.
2727 
2728     In many areas Django also relies on using isinstance() to check for an
2729     automatically-generated field as a subclass of AutoField. A new flag needs
2730     to be implemented on Field to be used instead.
2731 
2732     When these issues have been addressed, this metaclass could be used to
2733     deprecate inheritance from AutoField and use of isinstance() with AutoField
2734     for detecting automatically-generated fields.
2735     """
2736 
2737     @property
2738     def _subclasses(self):
2739         return (BigAutoField, SmallAutoField)
2740 
2741     def __instancecheck__(self, instance):
2742         return isinstance(instance, self._subclasses) or super().__instancecheck__(
2743             instance
2744         )
2745 
2746     def __subclasscheck__(self, subclass):
2747         return issubclass(subclass, self._subclasses) or super().__subclasscheck__(
2748             subclass
2749         )
2750 
2751 
2752 class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):
2753     def get_internal_type(self):
2754         return "AutoField"
2755 
2756     def rel_db_type(self, connection):
2757         return IntegerField().db_type(connection=connection)
2758 
2759 
2760 class BigAutoField(AutoFieldMixin, BigIntegerField):
2761     def get_internal_type(self):
2762         return "BigAutoField"
2763 
2764     def rel_db_type(self, connection):
2765         return BigIntegerField().db_type(connection=connection)
2766 
2767 
2768 class SmallAutoField(AutoFieldMixin, SmallIntegerField):
2769     def get_internal_type(self):
2770         return "SmallAutoField"
2771 
2772     def rel_db_type(self, connection):
2773         return SmallIntegerField().db_type(connection=connection)

</code><intended_behavior>This file should include logic that not only allows for 'db_collation' to be defined at the field level but also ensures that when such fields are used as primary keys, any foreign keys referencing them in other models inherit or respect this collation setting during migration generation. The current implementation likely allows 'db_collation' to be specified, but may not ensure it is consistently applied across related foreign key references in migrations. The code fix should address this propagation issue without disrupting the existing functionality for non-related fields.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name = related_name % {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_filter = (
411             (rh_field.attname, getattr(obj, lh_field.attname))
412             for lh_field, rh_field in self.related_fields
413         )
414         descriptor_filter = self.get_extra_descriptor_filter(obj)
415         base_q = Q(*base_filter)
416         if isinstance(descriptor_filter, dict):
417             return base_q & Q(**descriptor_filter)
418         elif descriptor_filter:
419             return base_q & descriptor_filter
420         return base_q
421 
422     @property
423     def swappable_setting(self):
424         """
425         Get the setting that this is powered from for swapping, or None
426         if it's not swapped in / marked with swappable=False.
427         """
428         if self.swappable:
429             # Work out string form of "to"
430             if isinstance(self.remote_field.model, str):
431                 to_string = self.remote_field.model
432             else:
433                 to_string = self.remote_field.model._meta.label
434             return apps.get_swappable_settings_name(to_string)
435         return None
436 
437     def set_attributes_from_rel(self):
438         self.name = self.name or (
439             self.remote_field.model._meta.model_name
440             + "_"
441             + self.remote_field.model._meta.pk.name
442         )
443         if self.verbose_name is None:
444             self.verbose_name = self.remote_field.model._meta.verbose_name
445         self.remote_field.set_field_name()
446 
447     def do_related_class(self, other, cls):
448         self.set_attributes_from_rel()
449         self.contribute_to_related_class(other, self.remote_field)
450 
451     def get_limit_choices_to(self):
452         """
453         Return ``limit_choices_to`` for this model field.
454 
455         If it is a callable, it will be invoked and the result will be
456         returned.
457         """
458         if callable(self.remote_field.limit_choices_to):
459             return self.remote_field.limit_choices_to()
460         return self.remote_field.limit_choices_to
461 
462     def formfield(self, **kwargs):
463         """
464         Pass ``limit_choices_to`` to the field being constructed.
465 
466         Only passes it if there is a type that supports related fields.
467         This is a similar strategy used to pass the ``queryset`` to the field
468         being constructed.
469         """
470         defaults = {}
471         if hasattr(self.remote_field, "get_related_field"):
472             # If this is a callable, do not invoke it here. Just pass
473             # it in the defaults for when the form class will later be
474             # instantiated.
475             limit_choices_to = self.remote_field.limit_choices_to
476             defaults.update(
477                 {
478                     "limit_choices_to": limit_choices_to,
479                 }
480             )
481         defaults.update(kwargs)
482         return super().formfield(**defaults)
483 
484     def related_query_name(self):
485         """
486         Define the name that can be used to identify this related object in a
487         table-spanning query.
488         """
489         return (
490             self.remote_field.related_query_name
491             or self.remote_field.related_name
492             or self.opts.model_name
493         )
494 
495     @property
496     def target_field(self):
497         """
498         When filtering against this relation, return the field on the remote
499         model against which the filtering should happen.
500         """
501         target_fields = self.path_infos[-1].target_fields
502         if len(target_fields) > 1:
503             raise exceptions.FieldError(
504                 "The relation has multiple target fields, but only single target field "
505                 "was asked for"
506             )
507         return target_fields[0]
508 
509     def get_cache_name(self):
510         return self.name
511 
512 
513 class ForeignObject(RelatedField):
514     """
515     Abstraction of the ForeignKey relation to support multi-column relations.
516     """
517 
518     # Field flags
519     many_to_many = False
520     many_to_one = True
521     one_to_many = False
522     one_to_one = False
523 
524     requires_unique_target = True
525     related_accessor_class = ReverseManyToOneDescriptor
526     forward_related_accessor_class = ForwardManyToOneDescriptor
527     rel_class = ForeignObjectRel
528 
529     def __init__(
530         self,
531         to,
532         on_delete,
533         from_fields,
534         to_fields,
535         rel=None,
536         related_name=None,
537         related_query_name=None,
538         limit_choices_to=None,
539         parent_link=False,
540         swappable=True,
541         **kwargs,
542     ):
543 
544         if rel is None:
545             rel = self.rel_class(
546                 self,
547                 to,
548                 related_name=related_name,
549                 related_query_name=related_query_name,
550                 limit_choices_to=limit_choices_to,
551                 parent_link=parent_link,
552                 on_delete=on_delete,
553             )
554 
555         super().__init__(
556             rel=rel,
557             related_name=related_name,
558             related_query_name=related_query_name,
559             limit_choices_to=limit_choices_to,
560             **kwargs,
561         )
562 
563         self.from_fields = from_fields
564         self.to_fields = to_fields
565         self.swappable = swappable
566 
567     def __copy__(self):
568         obj = super().__copy__()
569         # Remove any cached PathInfo values.
570         obj.__dict__.pop("path_infos", None)
571         obj.__dict__.pop("reverse_path_infos", None)
572         return obj
573 
574     def check(self, **kwargs):
575         return [
576             *super().check(**kwargs),
577             *self._check_to_fields_exist(),
578             *self._check_unique_target(),
579         ]
580 
581     def _check_to_fields_exist(self):
582         # Skip nonexistent models.
583         if isinstance(self.remote_field.model, str):
584             return []
585 
586         errors = []
587         for to_field in self.to_fields:
588             if to_field:
589                 try:
590                     self.remote_field.model._meta.get_field(to_field)
591                 except exceptions.FieldDoesNotExist:
592                     errors.append(
593                         checks.Error(
594                             "The to_field '%s' doesn't exist on the related "
595                             "model '%s'."
596                             % (to_field, self.remote_field.model._meta.label),
597                             obj=self,
598                             id="fields.E312",
599                         )
600                     )
601         return errors
602 
603     def _check_unique_target(self):
604         rel_is_string = isinstance(self.remote_field.model, str)
605         if rel_is_string or not self.requires_unique_target:
606             return []
607 
608         try:
609             self.foreign_related_fields
610         except exceptions.FieldDoesNotExist:
611             return []
612 
613         if not self.foreign_related_fields:
614             return []
615 
616         unique_foreign_fields = {
617             frozenset([f.name])
618             for f in self.remote_field.model._meta.get_fields()
619             if getattr(f, "unique", False)
620         }
621         unique_foreign_fields.update(
622             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
623         )
624         unique_foreign_fields.update(
625             {
626                 frozenset(uc.fields)
627                 for uc in self.remote_field.model._meta.total_unique_constraints
628             }
629         )
630         foreign_fields = {f.name for f in self.foreign_related_fields}
631         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
632 
633         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
634             field_combination = ", ".join(
635                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
636             )
637             model_name = self.remote_field.model.__name__
638             return [
639                 checks.Error(
640                     "No subset of the fields %s on model '%s' is unique."
641                     % (field_combination, model_name),
642                     hint=(
643                         "Mark a single field as unique=True or add a set of "
644                         "fields to a unique constraint (via unique_together "
645                         "or a UniqueConstraint (without condition) in the "
646                         "model Meta.constraints)."
647                     ),
648                     obj=self,
649                     id="fields.E310",
650                 )
651             ]
652         elif not has_unique_constraint:
653             field_name = self.foreign_related_fields[0].name
654             model_name = self.remote_field.model.__name__
655             return [
656                 checks.Error(
657                     "'%s.%s' must be unique because it is referenced by "
658                     "a foreign key." % (model_name, field_name),
659                     hint=(
660                         "Add unique=True to this field or add a "
661                         "UniqueConstraint (without condition) in the model "
662                         "Meta.constraints."
663                     ),
664                     obj=self,
665                     id="fields.E311",
666                 )
667             ]
668         else:
669             return []
670 
671     def deconstruct(self):
672         name, path, args, kwargs = super().deconstruct()
673         kwargs["on_delete"] = self.remote_field.on_delete
674         kwargs["from_fields"] = self.from_fields
675         kwargs["to_fields"] = self.to_fields
676 
677         if self.remote_field.parent_link:
678             kwargs["parent_link"] = self.remote_field.parent_link
679         if isinstance(self.remote_field.model, str):
680             if "." in self.remote_field.model:
681                 app_label, model_name = self.remote_field.model.split(".")
682                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
683             else:
684                 kwargs["to"] = self.remote_field.model.lower()
685         else:
686             kwargs["to"] = self.remote_field.model._meta.label_lower
687         # If swappable is True, then see if we're actually pointing to the target
688         # of a swap.
689         swappable_setting = self.swappable_setting
690         if swappable_setting is not None:
691             # If it's already a settings reference, error
692             if hasattr(kwargs["to"], "setting_name"):
693                 if kwargs["to"].setting_name != swappable_setting:
694                     raise ValueError(
695                         "Cannot deconstruct a ForeignKey pointing to a model "
696                         "that is swapped in place of more than one model (%s and %s)"
697                         % (kwargs["to"].setting_name, swappable_setting)
698                     )
699             # Set it
700             kwargs["to"] = SettingsReference(
701                 kwargs["to"],
702                 swappable_setting,
703             )
704         return name, path, args, kwargs
705 
706     def resolve_related_fields(self):
707         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
708             raise ValueError(
709                 "Foreign Object from and to fields must be the same non-zero length"
710             )
711         if isinstance(self.remote_field.model, str):
712             raise ValueError(
713                 "Related model %r cannot be resolved" % self.remote_field.model
714             )
715         related_fields = []
716         for index in range(len(self.from_fields)):
717             from_field_name = self.from_fields[index]
718             to_field_name = self.to_fields[index]
719             from_field = (
720                 self
721                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
722                 else self.opts.get_field(from_field_name)
723             )
724             to_field = (
725                 self.remote_field.model._meta.pk
726                 if to_field_name is None
727                 else self.remote_field.model._meta.get_field(to_field_name)
728             )
729             related_fields.append((from_field, to_field))
730         return related_fields
731 
732     @cached_property
733     def related_fields(self):
734         return self.resolve_related_fields()
735 
736     @cached_property
737     def reverse_related_fields(self):
738         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
739 
740     @cached_property
741     def local_related_fields(self):
742         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
743 
744     @cached_property
745     def foreign_related_fields(self):
746         return tuple(
747             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
748         )
749 
750     def get_local_related_value(self, instance):
751         return self.get_instance_value_for_fields(instance, self.local_related_fields)
752 
753     def get_foreign_related_value(self, instance):
754         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
755 
756     @staticmethod
757     def get_instance_value_for_fields(instance, fields):
758         ret = []
759         opts = instance._meta
760         for field in fields:
761             # Gotcha: in some cases (like fixture loading) a model can have
762             # different values in parent_ptr_id and parent's id. So, use
763             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
764             if field.primary_key:
765                 possible_parent_link = opts.get_ancestor_link(field.model)
766                 if (
767                     not possible_parent_link
768                     or possible_parent_link.primary_key
769                     or possible_parent_link.model._meta.abstract
770                 ):
771                     ret.append(instance.pk)
772                     continue
773             ret.append(getattr(instance, field.attname))
774         return tuple(ret)
775 
776     def get_attname_column(self):
777         attname, column = super().get_attname_column()
778         return attname, None
779 
780     def get_joining_columns(self, reverse_join=False):
781         source = self.reverse_related_fields if reverse_join else self.related_fields
782         return tuple(
783             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
784         )
785 
786     def get_reverse_joining_columns(self):
787         return self.get_joining_columns(reverse_join=True)
788 
789     def get_extra_descriptor_filter(self, instance):
790         """
791         Return an extra filter condition for related object fetching when
792         user does 'instance.fieldname', that is the extra filter is used in
793         the descriptor of the field.
794 
795         The filter should be either a dict usable in .filter(**kwargs) call or
796         a Q-object. The condition will be ANDed together with the relation's
797         joining columns.
798 
799         A parallel method is get_extra_restriction() which is used in
800         JOIN and subquery conditions.
801         """
802         return {}
803 
804     def get_extra_restriction(self, alias, related_alias):
805         """
806         Return a pair condition used for joining and subquery pushdown. The
807         condition is something that responds to as_sql(compiler, connection)
808         method.
809 
810         Note that currently referring both the 'alias' and 'related_alias'
811         will not work in some conditions, like subquery pushdown.
812 
813         A parallel method is get_extra_descriptor_filter() which is used in
814         instance.fieldname related object fetching.
815         """
816         return None
817 
818     def get_path_info(self, filtered_relation=None):
819         """Get path from this field to the related model."""
820         opts = self.remote_field.model._meta
821         from_opts = self.model._meta
822         return [
823             PathInfo(
824                 from_opts=from_opts,
825                 to_opts=opts,
826                 target_fields=self.foreign_related_fields,
827                 join_field=self,
828                 m2m=False,
829                 direct=True,
830                 filtered_relation=filtered_relation,
831             )
832         ]
833 
834     @cached_property
835     def path_infos(self):
836         return self.get_path_info()
837 
838     def get_reverse_path_info(self, filtered_relation=None):
839         """Get path from the related model to this field's model."""
840         opts = self.model._meta
841         from_opts = self.remote_field.model._meta
842         return [
843             PathInfo(
844                 from_opts=from_opts,
845                 to_opts=opts,
846                 target_fields=(opts.pk,),
847                 join_field=self.remote_field,
848                 m2m=not self.unique,
849                 direct=False,
850                 filtered_relation=filtered_relation,
851             )
852         ]
853 
854     @cached_property
855     def reverse_path_infos(self):
856         return self.get_reverse_path_info()
857 
858     @classmethod
859     @functools.lru_cache(maxsize=None)
860     def get_lookups(cls):
861         bases = inspect.getmro(cls)
862         bases = bases[: bases.index(ForeignObject) + 1]
863         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
864         return cls.merge_dicts(class_lookups)
865 
866     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
867         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
868         setattr(cls, self.name, self.forward_related_accessor_class(self))
869 
870     def contribute_to_related_class(self, cls, related):
871         # Internal FK's - i.e., those with a related name ending with '+' -
872         # and swapped models don't get a related descriptor.
873         if (
874             not self.remote_field.is_hidden()
875             and not related.related_model._meta.swapped
876         ):
877             setattr(
878                 cls._meta.concrete_model,
879                 related.get_accessor_name(),
880                 self.related_accessor_class(related),
881             )
882             # While 'limit_choices_to' might be a callable, simply pass
883             # it along for later - this is too early because it's still
884             # model load time.
885             if self.remote_field.limit_choices_to:
886                 cls._meta.related_fkey_lookups.append(
887                     self.remote_field.limit_choices_to
888                 )
889 
890 
891 ForeignObject.register_lookup(RelatedIn)
892 ForeignObject.register_lookup(RelatedExact)
893 ForeignObject.register_lookup(RelatedLessThan)
894 ForeignObject.register_lookup(RelatedGreaterThan)
895 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
896 ForeignObject.register_lookup(RelatedLessThanOrEqual)
897 ForeignObject.register_lookup(RelatedIsNull)
898 
899 
900 class ForeignKey(ForeignObject):
901     """
902     Provide a many-to-one relation by adding a column to the local model
903     to hold the remote value.
904 
905     By default ForeignKey will target the pk of the remote model but this
906     behavior can be changed by using the ``to_field`` argument.
907     """
908 
909     descriptor_class = ForeignKeyDeferredAttribute
910     # Field flags
911     many_to_many = False
912     many_to_one = True
913     one_to_many = False
914     one_to_one = False
915 
916     rel_class = ManyToOneRel
917 
918     empty_strings_allowed = False
919     default_error_messages = {
920         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
921     }
922     description = _("Foreign Key (type determined by related field)")
923 
924     def __init__(
925         self,
926         to,
927         on_delete,
928         related_name=None,
929         related_query_name=None,
930         limit_choices_to=None,
931         parent_link=False,
932         to_field=None,
933         db_constraint=True,
934         **kwargs,
935     ):
936         try:
937             to._meta.model_name
938         except AttributeError:
939             if not isinstance(to, str):
940                 raise TypeError(
941                     "%s(%r) is invalid. First parameter to ForeignKey must be "
942                     "either a model, a model name, or the string %r"
943                     % (
944                         self.__class__.__name__,
945                         to,
946                         RECURSIVE_RELATIONSHIP_CONSTANT,
947                     )
948                 )
949         else:
950             # For backwards compatibility purposes, we need to *try* and set
951             # the to_field during FK construction. It won't be guaranteed to
952             # be correct until contribute_to_class is called. Refs #12190.
953             to_field = to_field or (to._meta.pk and to._meta.pk.name)
954         if not callable(on_delete):
955             raise TypeError("on_delete must be callable.")
956 
957         kwargs["rel"] = self.rel_class(
958             self,
959             to,
960             to_field,
961             related_name=related_name,
962             related_query_name=related_query_name,
963             limit_choices_to=limit_choices_to,
964             parent_link=parent_link,
965             on_delete=on_delete,
966         )
967         kwargs.setdefault("db_index", True)
968 
969         super().__init__(
970             to,
971             on_delete,
972             related_name=related_name,
973             related_query_name=related_query_name,
974             limit_choices_to=limit_choices_to,
975             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
976             to_fields=[to_field],
977             **kwargs,
978         )
979         self.db_constraint = db_constraint
980 
981     def __class_getitem__(cls, *args, **kwargs):
982         return cls
983 
984     def check(self, **kwargs):
985         return [
986             *super().check(**kwargs),
987             *self._check_on_delete(),
988             *self._check_unique(),
989         ]
990 
991     def _check_on_delete(self):
992         on_delete = getattr(self.remote_field, "on_delete", None)
993         if on_delete == SET_NULL and not self.null:
994             return [
995                 checks.Error(
996                     "Field specifies on_delete=SET_NULL, but cannot be null.",
997                     hint=(
998                         "Set null=True argument on the field, or change the on_delete "
999                         "rule."
1000                     ),
1001                     obj=self,
1002                     id="fields.E320",
1003                 )
1004             ]
1005         elif on_delete == SET_DEFAULT and not self.has_default():
1006             return [
1007                 checks.Error(
1008                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1009                     hint="Set a default value, or change the on_delete rule.",
1010                     obj=self,
1011                     id="fields.E321",
1012                 )
1013             ]
1014         else:
1015             return []
1016 
1017     def _check_unique(self, **kwargs):
1018         return (
1019             [
1020                 checks.Warning(
1021                     "Setting unique=True on a ForeignKey has the same effect as using "
1022                     "a OneToOneField.",
1023                     hint=(
1024                         "ForeignKey(unique=True) is usually better served by a "
1025                         "OneToOneField."
1026                     ),
1027                     obj=self,
1028                     id="fields.W342",
1029                 )
1030             ]
1031             if self.unique
1032             else []
1033         )
1034 
1035     def deconstruct(self):
1036         name, path, args, kwargs = super().deconstruct()
1037         del kwargs["to_fields"]
1038         del kwargs["from_fields"]
1039         # Handle the simpler arguments
1040         if self.db_index:
1041             del kwargs["db_index"]
1042         else:
1043             kwargs["db_index"] = False
1044         if self.db_constraint is not True:
1045             kwargs["db_constraint"] = self.db_constraint
1046         # Rel needs more work.
1047         to_meta = getattr(self.remote_field.model, "_meta", None)
1048         if self.remote_field.field_name and (
1049             not to_meta
1050             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1051         ):
1052             kwargs["to_field"] = self.remote_field.field_name
1053         return name, path, args, kwargs
1054 
1055     def to_python(self, value):
1056         return self.target_field.to_python(value)
1057 
1058     @property
1059     def target_field(self):
1060         return self.foreign_related_fields[0]
1061 
1062     def get_reverse_path_info(self, filtered_relation=None):
1063         """Get path from the related model to this field's model."""
1064         opts = self.model._meta
1065         from_opts = self.remote_field.model._meta
1066         return [
1067             PathInfo(
1068                 from_opts=from_opts,
1069                 to_opts=opts,
1070                 target_fields=(opts.pk,),
1071                 join_field=self.remote_field,
1072                 m2m=not self.unique,
1073                 direct=False,
1074                 filtered_relation=filtered_relation,
1075             )
1076         ]
1077 
1078     def validate(self, value, model_instance):
1079         if self.remote_field.parent_link:
1080             return
1081         super().validate(value, model_instance)
1082         if value is None:
1083             return
1084 
1085         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1086         qs = self.remote_field.model._base_manager.using(using).filter(
1087             **{self.remote_field.field_name: value}
1088         )
1089         qs = qs.complex_filter(self.get_limit_choices_to())
1090         if not qs.exists():
1091             raise exceptions.ValidationError(
1092                 self.error_messages["invalid"],
1093                 code="invalid",
1094                 params={
1095                     "model": self.remote_field.model._meta.verbose_name,
1096                     "pk": value,
1097                     "field": self.remote_field.field_name,
1098                     "value": value,
1099                 },  # 'pk' is included for backwards compatibility
1100             )
1101 
1102     def resolve_related_fields(self):
1103         related_fields = super().resolve_related_fields()
1104         for from_field, to_field in related_fields:
1105             if (
1106                 to_field
1107                 and to_field.model != self.remote_field.model._meta.concrete_model
1108             ):
1109                 raise exceptions.FieldError(
1110                     "'%s.%s' refers to field '%s' which is not local to model "
1111                     "'%s'."
1112                     % (
1113                         self.model._meta.label,
1114                         self.name,
1115                         to_field.name,
1116                         self.remote_field.model._meta.concrete_model._meta.label,
1117                     )
1118                 )
1119         return related_fields
1120 
1121     def get_attname(self):
1122         return "%s_id" % self.name
1123 
1124     def get_attname_column(self):
1125         attname = self.get_attname()
1126         column = self.db_column or attname
1127         return attname, column
1128 
1129     def get_default(self):
1130         """Return the to_field if the default value is an object."""
1131         field_default = super().get_default()
1132         if isinstance(field_default, self.remote_field.model):
1133             return getattr(field_default, self.target_field.attname)
1134         return field_default
1135 
1136     def get_db_prep_save(self, value, connection):
1137         if value is None or (
1138             value == ""
1139             and (
1140                 not self.target_field.empty_strings_allowed
1141                 or connection.features.interprets_empty_strings_as_nulls
1142             )
1143         ):
1144             return None
1145         else:
1146             return self.target_field.get_db_prep_save(value, connection=connection)
1147 
1148     def get_db_prep_value(self, value, connection, prepared=False):
1149         return self.target_field.get_db_prep_value(value, connection, prepared)
1150 
1151     def get_prep_value(self, value):
1152         return self.target_field.get_prep_value(value)
1153 
1154     def contribute_to_related_class(self, cls, related):
1155         super().contribute_to_related_class(cls, related)
1156         if self.remote_field.field_name is None:
1157             self.remote_field.field_name = cls._meta.pk.name
1158 
1159     def formfield(self, *, using=None, **kwargs):
1160         if isinstance(self.remote_field.model, str):
1161             raise ValueError(
1162                 "Cannot create form field for %r yet, because "
1163                 "its related model %r has not been loaded yet"
1164                 % (self.name, self.remote_field.model)
1165             )
1166         return super().formfield(
1167             **{
1168                 "form_class": forms.ModelChoiceField,
1169                 "queryset": self.remote_field.model._default_manager.using(using),
1170                 "to_field_name": self.remote_field.field_name,
1171                 **kwargs,
1172                 "blank": self.blank,
1173             }
1174         )
1175 
1176     def db_check(self, connection):
1177         return None
1178 
1179     def db_type(self, connection):
1180         return self.target_field.rel_db_type(connection=connection)
1181 
1182     def db_parameters(self, connection):
1183         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1184 
1185     def convert_empty_strings(self, value, expression, connection):
1186         if (not value) and isinstance(value, str):
1187             return None
1188         return value
1189 
1190     def get_db_converters(self, connection):
1191         converters = super().get_db_converters(connection)
1192         if connection.features.interprets_empty_strings_as_nulls:
1193             converters += [self.convert_empty_strings]
1194         return converters
1195 
1196     def get_col(self, alias, output_field=None):
1197         if output_field is None:
1198             output_field = self.target_field
1199             while isinstance(output_field, ForeignKey):
1200                 output_field = output_field.target_field
1201                 if output_field is self:
1202                     raise ValueError("Cannot resolve output_field.")
1203         return super().get_col(alias, output_field)
1204 
1205 
1206 class OneToOneField(ForeignKey):
1207     """
1208     A OneToOneField is essentially the same as a ForeignKey, with the exception
1209     that it always carries a "unique" constraint with it and the reverse
1210     relation always returns the object pointed to (since there will only ever
1211     be one), rather than returning a list.
1212     """
1213 
1214     # Field flags
1215     many_to_many = False
1216     many_to_one = False
1217     one_to_many = False
1218     one_to_one = True
1219 
1220     related_accessor_class = ReverseOneToOneDescriptor
1221     forward_related_accessor_class = ForwardOneToOneDescriptor
1222     rel_class = OneToOneRel
1223 
1224     description = _("One-to-one relationship")
1225 
1226     def __init__(self, to, on_delete, to_field=None, **kwargs):
1227         kwargs["unique"] = True
1228         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1229 
1230     def deconstruct(self):
1231         name, path, args, kwargs = super().deconstruct()
1232         if "unique" in kwargs:
1233             del kwargs["unique"]
1234         return name, path, args, kwargs
1235 
1236     def formfield(self, **kwargs):
1237         if self.remote_field.parent_link:
1238             return None
1239         return super().formfield(**kwargs)
1240 
1241     def save_form_data(self, instance, data):
1242         if isinstance(data, self.remote_field.model):
1243             setattr(instance, self.name, data)
1244         else:
1245             setattr(instance, self.attname, data)
1246             # Remote field object must be cleared otherwise Model.save()
1247             # will reassign attname using the related object pk.
1248             if data is None:
1249                 setattr(instance, self.name, data)
1250 
1251     def _check_unique(self, **kwargs):
1252         # Override ForeignKey since check isn't applicable here.
1253         return []
1254 
1255 
1256 def create_many_to_many_intermediary_model(field, klass):
1257     from django.db import models
1258 
1259     def set_managed(model, related, through):
1260         through._meta.managed = model._meta.managed or related._meta.managed
1261 
1262     to_model = resolve_relation(klass, field.remote_field.model)
1263     name = "%s_%s" % (klass._meta.object_name, field.name)
1264     lazy_related_operation(set_managed, klass, to_model, name)
1265 
1266     to = make_model_tuple(to_model)[1]
1267     from_ = klass._meta.model_name
1268     if to == from_:
1269         to = "to_%s" % to
1270         from_ = "from_%s" % from_
1271 
1272     meta = type(
1273         "Meta",
1274         (),
1275         {
1276             "db_table": field._get_m2m_db_table(klass._meta),
1277             "auto_created": klass,
1278             "app_label": klass._meta.app_label,
1279             "db_tablespace": klass._meta.db_tablespace,
1280             "unique_together": (from_, to),
1281             "verbose_name": _("%(from)s-%(to)s relationship")
1282             % {"from": from_, "to": to},
1283             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1284             % {"from": from_, "to": to},
1285             "apps": field.model._meta.apps,
1286         },
1287     )
1288     # Construct and return the new class.
1289     return type(
1290         name,
1291         (models.Model,),
1292         {
1293             "Meta": meta,
1294             "__module__": klass.__module__,
1295             from_: models.ForeignKey(
1296                 klass,
1297                 related_name="%s+" % name,
1298                 db_tablespace=field.db_tablespace,
1299                 db_constraint=field.remote_field.db_constraint,
1300                 on_delete=CASCADE,
1301             ),
1302             to: models.ForeignKey(
1303                 to_model,
1304                 related_name="%s+" % name,
1305                 db_tablespace=field.db_tablespace,
1306                 db_constraint=field.remote_field.db_constraint,
1307                 on_delete=CASCADE,
1308             ),
1309         },
1310     )
1311 
1312 
1313 class ManyToManyField(RelatedField):
1314     """
1315     Provide a many-to-many relation by using an intermediary model that
1316     holds two ForeignKey fields pointed at the two sides of the relation.
1317 
1318     Unless a ``through`` model was provided, ManyToManyField will use the
1319     create_many_to_many_intermediary_model factory to automatically generate
1320     the intermediary model.
1321     """
1322 
1323     # Field flags
1324     many_to_many = True
1325     many_to_one = False
1326     one_to_many = False
1327     one_to_one = False
1328 
1329     rel_class = ManyToManyRel
1330 
1331     description = _("Many-to-many relationship")
1332 
1333     def __init__(
1334         self,
1335         to,
1336         related_name=None,
1337         related_query_name=None,
1338         limit_choices_to=None,
1339         symmetrical=None,
1340         through=None,
1341         through_fields=None,
1342         db_constraint=True,
1343         db_table=None,
1344         swappable=True,
1345         **kwargs,
1346     ):
1347         try:
1348             to._meta
1349         except AttributeError:
1350             if not isinstance(to, str):
1351                 raise TypeError(
1352                     "%s(%r) is invalid. First parameter to ManyToManyField "
1353                     "must be either a model, a model name, or the string %r"
1354                     % (
1355                         self.__class__.__name__,
1356                         to,
1357                         RECURSIVE_RELATIONSHIP_CONSTANT,
1358                     )
1359                 )
1360 
1361         if symmetrical is None:
1362             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1363 
1364         if through is not None and db_table is not None:
1365             raise ValueError(
1366                 "Cannot specify a db_table if an intermediary model is used."
1367             )
1368 
1369         kwargs["rel"] = self.rel_class(
1370             self,
1371             to,
1372             related_name=related_name,
1373             related_query_name=related_query_name,
1374             limit_choices_to=limit_choices_to,
1375             symmetrical=symmetrical,
1376             through=through,
1377             through_fields=through_fields,
1378             db_constraint=db_constraint,
1379         )
1380         self.has_null_arg = "null" in kwargs
1381 
1382         super().__init__(
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             **kwargs,
1387         )
1388 
1389         self.db_table = db_table
1390         self.swappable = swappable
1391 
1392     def check(self, **kwargs):
1393         return [
1394             *super().check(**kwargs),
1395             *self._check_unique(**kwargs),
1396             *self._check_relationship_model(**kwargs),
1397             *self._check_ignored_options(**kwargs),
1398             *self._check_table_uniqueness(**kwargs),
1399         ]
1400 
1401     def _check_unique(self, **kwargs):
1402         if self.unique:
1403             return [
1404                 checks.Error(
1405                     "ManyToManyFields cannot be unique.",
1406                     obj=self,
1407                     id="fields.E330",
1408                 )
1409             ]
1410         return []
1411 
1412     def _check_ignored_options(self, **kwargs):
1413         warnings = []
1414 
1415         if self.has_null_arg:
1416             warnings.append(
1417                 checks.Warning(
1418                     "null has no effect on ManyToManyField.",
1419                     obj=self,
1420                     id="fields.W340",
1421                 )
1422             )
1423 
1424         if self._validators:
1425             warnings.append(
1426                 checks.Warning(
1427                     "ManyToManyField does not support validators.",
1428                     obj=self,
1429                     id="fields.W341",
1430                 )
1431             )
1432         if self.remote_field.symmetrical and self._related_name:
1433             warnings.append(
1434                 checks.Warning(
1435                     "related_name has no effect on ManyToManyField "
1436                     'with a symmetrical relationship, e.g. to "self".',
1437                     obj=self,
1438                     id="fields.W345",
1439                 )
1440             )
1441 
1442         return warnings
1443 
1444     def _check_relationship_model(self, from_model=None, **kwargs):
1445         if hasattr(self.remote_field.through, "_meta"):
1446             qualified_model_name = "%s.%s" % (
1447                 self.remote_field.through._meta.app_label,
1448                 self.remote_field.through.__name__,
1449             )
1450         else:
1451             qualified_model_name = self.remote_field.through
1452 
1453         errors = []
1454 
1455         if self.remote_field.through not in self.opts.apps.get_models(
1456             include_auto_created=True
1457         ):
1458             # The relationship model is not installed.
1459             errors.append(
1460                 checks.Error(
1461                     "Field specifies a many-to-many relation through model "
1462                     "'%s', which has not been installed." % qualified_model_name,
1463                     obj=self,
1464                     id="fields.E331",
1465                 )
1466             )
1467 
1468         else:
1469             assert from_model is not None, (
1470                 "ManyToManyField with intermediate "
1471                 "tables cannot be checked if you don't pass the model "
1472                 "where the field is attached to."
1473             )
1474             # Set some useful local variables
1475             to_model = resolve_relation(from_model, self.remote_field.model)
1476             from_model_name = from_model._meta.object_name
1477             if isinstance(to_model, str):
1478                 to_model_name = to_model
1479             else:
1480                 to_model_name = to_model._meta.object_name
1481             relationship_model_name = self.remote_field.through._meta.object_name
1482             self_referential = from_model == to_model
1483             # Count foreign keys in intermediate model
1484             if self_referential:
1485                 seen_self = sum(
1486                     from_model == getattr(field.remote_field, "model", None)
1487                     for field in self.remote_field.through._meta.fields
1488                 )
1489 
1490                 if seen_self > 2 and not self.remote_field.through_fields:
1491                     errors.append(
1492                         checks.Error(
1493                             "The model is used as an intermediate model by "
1494                             "'%s', but it has more than two foreign keys "
1495                             "to '%s', which is ambiguous. You must specify "
1496                             "which two foreign keys Django should use via the "
1497                             "through_fields keyword argument."
1498                             % (self, from_model_name),
1499                             hint=(
1500                                 "Use through_fields to specify which two foreign keys "
1501                                 "Django should use."
1502                             ),
1503                             obj=self.remote_field.through,
1504                             id="fields.E333",
1505                         )
1506                     )
1507 
1508             else:
1509                 # Count foreign keys in relationship model
1510                 seen_from = sum(
1511                     from_model == getattr(field.remote_field, "model", None)
1512                     for field in self.remote_field.through._meta.fields
1513                 )
1514                 seen_to = sum(
1515                     to_model == getattr(field.remote_field, "model", None)
1516                     for field in self.remote_field.through._meta.fields
1517                 )
1518 
1519                 if seen_from > 1 and not self.remote_field.through_fields:
1520                     errors.append(
1521                         checks.Error(
1522                             (
1523                                 "The model is used as an intermediate model by "
1524                                 "'%s', but it has more than one foreign key "
1525                                 "from '%s', which is ambiguous. You must specify "
1526                                 "which foreign key Django should use via the "
1527                                 "through_fields keyword argument."
1528                             )
1529                             % (self, from_model_name),
1530                             hint=(
1531                                 "If you want to create a recursive relationship, "
1532                                 'use ManyToManyField("%s", through="%s").'
1533                             )
1534                             % (
1535                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1536                                 relationship_model_name,
1537                             ),
1538                             obj=self,
1539                             id="fields.E334",
1540                         )
1541                     )
1542 
1543                 if seen_to > 1 and not self.remote_field.through_fields:
1544                     errors.append(
1545                         checks.Error(
1546                             "The model is used as an intermediate model by "
1547                             "'%s', but it has more than one foreign key "
1548                             "to '%s', which is ambiguous. You must specify "
1549                             "which foreign key Django should use via the "
1550                             "through_fields keyword argument." % (self, to_model_name),
1551                             hint=(
1552                                 "If you want to create a recursive relationship, "
1553                                 'use ManyToManyField("%s", through="%s").'
1554                             )
1555                             % (
1556                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1557                                 relationship_model_name,
1558                             ),
1559                             obj=self,
1560                             id="fields.E335",
1561                         )
1562                     )
1563 
1564                 if seen_from == 0 or seen_to == 0:
1565                     errors.append(
1566                         checks.Error(
1567                             "The model is used as an intermediate model by "
1568                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1569                             % (self, from_model_name, to_model_name),
1570                             obj=self.remote_field.through,
1571                             id="fields.E336",
1572                         )
1573                     )
1574 
1575         # Validate `through_fields`.
1576         if self.remote_field.through_fields is not None:
1577             # Validate that we're given an iterable of at least two items
1578             # and that none of them is "falsy".
1579             if not (
1580                 len(self.remote_field.through_fields) >= 2
1581                 and self.remote_field.through_fields[0]
1582                 and self.remote_field.through_fields[1]
1583             ):
1584                 errors.append(
1585                     checks.Error(
1586                         "Field specifies 'through_fields' but does not provide "
1587                         "the names of the two link fields that should be used "
1588                         "for the relation through model '%s'." % qualified_model_name,
1589                         hint=(
1590                             "Make sure you specify 'through_fields' as "
1591                             "through_fields=('field1', 'field2')"
1592                         ),
1593                         obj=self,
1594                         id="fields.E337",
1595                     )
1596                 )
1597 
1598             # Validate the given through fields -- they should be actual
1599             # fields on the through model, and also be foreign keys to the
1600             # expected models.
1601             else:
1602                 assert from_model is not None, (
1603                     "ManyToManyField with intermediate "
1604                     "tables cannot be checked if you don't pass the model "
1605                     "where the field is attached to."
1606                 )
1607 
1608                 source, through, target = (
1609                     from_model,
1610                     self.remote_field.through,
1611                     self.remote_field.model,
1612                 )
1613                 source_field_name, target_field_name = self.remote_field.through_fields[
1614                     :2
1615                 ]
1616 
1617                 for field_name, related_model in (
1618                     (source_field_name, source),
1619                     (target_field_name, target),
1620                 ):
1621 
1622                     possible_field_names = []
1623                     for f in through._meta.fields:
1624                         if (
1625                             hasattr(f, "remote_field")
1626                             and getattr(f.remote_field, "model", None) == related_model
1627                         ):
1628                             possible_field_names.append(f.name)
1629                     if possible_field_names:
1630                         hint = (
1631                             "Did you mean one of the following foreign keys to '%s': "
1632                             "%s?"
1633                             % (
1634                                 related_model._meta.object_name,
1635                                 ", ".join(possible_field_names),
1636                             )
1637                         )
1638                     else:
1639                         hint = None
1640 
1641                     try:
1642                         field = through._meta.get_field(field_name)
1643                     except exceptions.FieldDoesNotExist:
1644                         errors.append(
1645                             checks.Error(
1646                                 "The intermediary model '%s' has no field '%s'."
1647                                 % (qualified_model_name, field_name),
1648                                 hint=hint,
1649                                 obj=self,
1650                                 id="fields.E338",
1651                             )
1652                         )
1653                     else:
1654                         if not (
1655                             hasattr(field, "remote_field")
1656                             and getattr(field.remote_field, "model", None)
1657                             == related_model
1658                         ):
1659                             errors.append(
1660                                 checks.Error(
1661                                     "'%s.%s' is not a foreign key to '%s'."
1662                                     % (
1663                                         through._meta.object_name,
1664                                         field_name,
1665                                         related_model._meta.object_name,
1666                                     ),
1667                                     hint=hint,
1668                                     obj=self,
1669                                     id="fields.E339",
1670                                 )
1671                             )
1672 
1673         return errors
1674 
1675     def _check_table_uniqueness(self, **kwargs):
1676         if (
1677             isinstance(self.remote_field.through, str)
1678             or not self.remote_field.through._meta.managed
1679         ):
1680             return []
1681         registered_tables = {
1682             model._meta.db_table: model
1683             for model in self.opts.apps.get_models(include_auto_created=True)
1684             if model != self.remote_field.through and model._meta.managed
1685         }
1686         m2m_db_table = self.m2m_db_table()
1687         model = registered_tables.get(m2m_db_table)
1688         # The second condition allows multiple m2m relations on a model if
1689         # some point to a through model that proxies another through model.
1690         if (
1691             model
1692             and model._meta.concrete_model
1693             != self.remote_field.through._meta.concrete_model
1694         ):
1695             if model._meta.auto_created:
1696 
1697                 def _get_field_name(model):
1698                     for field in model._meta.auto_created._meta.many_to_many:
1699                         if field.remote_field.through is model:
1700                             return field.name
1701 
1702                 opts = model._meta.auto_created._meta
1703                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1704             else:
1705                 clashing_obj = model._meta.label
1706             if settings.DATABASE_ROUTERS:
1707                 error_class, error_id = checks.Warning, "fields.W344"
1708                 error_hint = (
1709                     "You have configured settings.DATABASE_ROUTERS. Verify "
1710                     "that the table of %r is correctly routed to a separate "
1711                     "database." % clashing_obj
1712                 )
1713             else:
1714                 error_class, error_id = checks.Error, "fields.E340"
1715                 error_hint = None
1716             return [
1717                 error_class(
1718                     "The field's intermediary table '%s' clashes with the "
1719                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1720                     obj=self,
1721                     hint=error_hint,
1722                     id=error_id,
1723                 )
1724             ]
1725         return []
1726 
1727     def deconstruct(self):
1728         name, path, args, kwargs = super().deconstruct()
1729         # Handle the simpler arguments.
1730         if self.db_table is not None:
1731             kwargs["db_table"] = self.db_table
1732         if self.remote_field.db_constraint is not True:
1733             kwargs["db_constraint"] = self.remote_field.db_constraint
1734         # Lowercase model names as they should be treated as case-insensitive.
1735         if isinstance(self.remote_field.model, str):
1736             if "." in self.remote_field.model:
1737                 app_label, model_name = self.remote_field.model.split(".")
1738                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1739             else:
1740                 kwargs["to"] = self.remote_field.model.lower()
1741         else:
1742             kwargs["to"] = self.remote_field.model._meta.label_lower
1743         if getattr(self.remote_field, "through", None) is not None:
1744             if isinstance(self.remote_field.through, str):
1745                 kwargs["through"] = self.remote_field.through
1746             elif not self.remote_field.through._meta.auto_created:
1747                 kwargs["through"] = self.remote_field.through._meta.label
1748         # If swappable is True, then see if we're actually pointing to the target
1749         # of a swap.
1750         swappable_setting = self.swappable_setting
1751         if swappable_setting is not None:
1752             # If it's already a settings reference, error.
1753             if hasattr(kwargs["to"], "setting_name"):
1754                 if kwargs["to"].setting_name != swappable_setting:
1755                     raise ValueError(
1756                         "Cannot deconstruct a ManyToManyField pointing to a "
1757                         "model that is swapped in place of more than one model "
1758                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1759                     )
1760 
1761             kwargs["to"] = SettingsReference(
1762                 kwargs["to"],
1763                 swappable_setting,
1764             )
1765         return name, path, args, kwargs
1766 
1767     def _get_path_info(self, direct=False, filtered_relation=None):
1768         """Called by both direct and indirect m2m traversal."""
1769         int_model = self.remote_field.through
1770         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1771         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1772         if direct:
1773             join1infos = linkfield1.reverse_path_infos
1774             if filtered_relation:
1775                 join2infos = linkfield2.get_path_info(filtered_relation)
1776             else:
1777                 join2infos = linkfield2.path_infos
1778         else:
1779             join1infos = linkfield2.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield1.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield1.path_infos
1784         # Get join infos between the last model of join 1 and the first model
1785         # of join 2. Assume the only reason these may differ is due to model
1786         # inheritance.
1787         join1_final = join1infos[-1].to_opts
1788         join2_initial = join2infos[0].from_opts
1789         if join1_final is join2_initial:
1790             intermediate_infos = []
1791         elif issubclass(join1_final.model, join2_initial.model):
1792             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1793         else:
1794             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1795 
1796         return [*join1infos, *intermediate_infos, *join2infos]
1797 
1798     def get_path_info(self, filtered_relation=None):
1799         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1800 
1801     @cached_property
1802     def path_infos(self):
1803         return self.get_path_info()
1804 
1805     def get_reverse_path_info(self, filtered_relation=None):
1806         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1807 
1808     @cached_property
1809     def reverse_path_infos(self):
1810         return self.get_reverse_path_info()
1811 
1812     def _get_m2m_db_table(self, opts):
1813         """
1814         Function that can be curried to provide the m2m table name for this
1815         relation.
1816         """
1817         if self.remote_field.through is not None:
1818             return self.remote_field.through._meta.db_table
1819         elif self.db_table:
1820             return self.db_table
1821         else:
1822             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1823             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1824 
1825     def _get_m2m_attr(self, related, attr):
1826         """
1827         Function that can be curried to provide the source accessor or DB
1828         column name for the m2m table.
1829         """
1830         cache_attr = "_m2m_%s_cache" % attr
1831         if hasattr(self, cache_attr):
1832             return getattr(self, cache_attr)
1833         if self.remote_field.through_fields is not None:
1834             link_field_name = self.remote_field.through_fields[0]
1835         else:
1836             link_field_name = None
1837         for f in self.remote_field.through._meta.fields:
1838             if (
1839                 f.is_relation
1840                 and f.remote_field.model == related.related_model
1841                 and (link_field_name is None or link_field_name == f.name)
1842             ):
1843                 setattr(self, cache_attr, getattr(f, attr))
1844                 return getattr(self, cache_attr)
1845 
1846     def _get_m2m_reverse_attr(self, related, attr):
1847         """
1848         Function that can be curried to provide the related accessor or DB
1849         column name for the m2m table.
1850         """
1851         cache_attr = "_m2m_reverse_%s_cache" % attr
1852         if hasattr(self, cache_attr):
1853             return getattr(self, cache_attr)
1854         found = False
1855         if self.remote_field.through_fields is not None:
1856             link_field_name = self.remote_field.through_fields[1]
1857         else:
1858             link_field_name = None
1859         for f in self.remote_field.through._meta.fields:
1860             if f.is_relation and f.remote_field.model == related.model:
1861                 if link_field_name is None and related.related_model == related.model:
1862                     # If this is an m2m-intermediate to self,
1863                     # the first foreign key you find will be
1864                     # the source column. Keep searching for
1865                     # the second foreign key.
1866                     if found:
1867                         setattr(self, cache_attr, getattr(f, attr))
1868                         break
1869                     else:
1870                         found = True
1871                 elif link_field_name is None or link_field_name == f.name:
1872                     setattr(self, cache_attr, getattr(f, attr))
1873                     break
1874         return getattr(self, cache_attr)
1875 
1876     def contribute_to_class(self, cls, name, **kwargs):
1877         # To support multiple relations to self, it's useful to have a non-None
1878         # related name on symmetrical relations for internal reasons. The
1879         # concept doesn't make a lot of sense externally ("you want me to
1880         # specify *what* on my non-reversible relation?!"), so we set it up
1881         # automatically. The funky name reduces the chance of an accidental
1882         # clash.
1883         if self.remote_field.symmetrical and (
1884             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1885             or self.remote_field.model == cls._meta.object_name
1886         ):
1887             self.remote_field.related_name = "%s_rel_+" % name
1888         elif self.remote_field.is_hidden():
1889             # If the backwards relation is disabled, replace the original
1890             # related_name with one generated from the m2m field name. Django
1891             # still uses backwards relations internally and we need to avoid
1892             # clashes between multiple m2m fields with related_name == '+'.
1893             self.remote_field.related_name = "_%s_%s_%s_+" % (
1894                 cls._meta.app_label,
1895                 cls.__name__.lower(),
1896                 name,
1897             )
1898 
1899         super().contribute_to_class(cls, name, **kwargs)
1900 
1901         # The intermediate m2m model is not auto created if:
1902         #  1) There is a manually specified intermediate, or
1903         #  2) The class owning the m2m field is abstract.
1904         #  3) The class owning the m2m field has been swapped out.
1905         if not cls._meta.abstract:
1906             if self.remote_field.through:
1907 
1908                 def resolve_through_model(_, model, field):
1909                     field.remote_field.through = model
1910 
1911                 lazy_related_operation(
1912                     resolve_through_model, cls, self.remote_field.through, field=self
1913                 )
1914             elif not cls._meta.swapped:
1915                 self.remote_field.through = create_many_to_many_intermediary_model(
1916                     self, cls
1917                 )
1918 
1919         # Add the descriptor for the m2m relation.
1920         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1921 
1922         # Set up the accessor for the m2m table name for the relation.
1923         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1924 
1925     def contribute_to_related_class(self, cls, related):
1926         # Internal M2Ms (i.e., those with a related name ending with '+')
1927         # and swapped models don't get a related descriptor.
1928         if (
1929             not self.remote_field.is_hidden()
1930             and not related.related_model._meta.swapped
1931         ):
1932             setattr(
1933                 cls,
1934                 related.get_accessor_name(),
1935                 ManyToManyDescriptor(self.remote_field, reverse=True),
1936             )
1937 
1938         # Set up the accessors for the column names on the m2m table.
1939         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1940         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1941 
1942         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1943         self.m2m_reverse_field_name = partial(
1944             self._get_m2m_reverse_attr, related, "name"
1945         )
1946 
1947         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1948         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1949         get_m2m_reverse_rel = partial(
1950             self._get_m2m_reverse_attr, related, "remote_field"
1951         )
1952         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1953 
1954     def set_attributes_from_rel(self):
1955         pass
1956 
1957     def value_from_object(self, obj):
1958         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1959 
1960     def save_form_data(self, instance, data):
1961         getattr(instance, self.attname).set(data)
1962 
1963     def formfield(self, *, using=None, **kwargs):
1964         defaults = {
1965             "form_class": forms.ModelMultipleChoiceField,
1966             "queryset": self.remote_field.model._default_manager.using(using),
1967             **kwargs,
1968         }
1969         # If initial is passed in, it's a list of related objects, but the
1970         # MultipleChoiceField takes a list of IDs.
1971         if defaults.get("initial") is not None:
1972             initial = defaults["initial"]
1973             if callable(initial):
1974                 initial = initial()
1975             defaults["initial"] = [i.pk for i in initial]
1976         return super().formfield(**defaults)
1977 
1978     def db_check(self, connection):
1979         return None
1980 
1981     def db_type(self, connection):
1982         # A ManyToManyField is not represented by a single column,
1983         # so return None.
1984         return None
1985 
1986     def db_parameters(self, connection):
1987         return {"type": None, "check": None}

</code><intended_behavior>Within this file, particularly in the sections that define or manipulate 'ForeignKey' fields, additional logic is required to check the 'db_collation' of the referenced field (if any) and apply it to the 'ForeignKey' field during migrations. The intention is for foreign keys to maintain database consistency by automatically adopting the 'db_collation' of their referenced primary key fields when migrations are generated, thus preventing collation mismatch errors. This adjustment should ensure that fields referencing custom or altered collation settings adhere to those settings across all related tables, respecting database constraints.</intended_behavior>]
2025-10-15 04:09:41.267 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections.abc
2 import copy
3 import datetime
4 import decimal
5 import math
6 import operator
7 import uuid
8 import warnings
9 from base64 import b64decode, b64encode
10 from functools import partialmethod, total_ordering
11 
12 from django import forms
13 from django.apps import apps
14 from django.conf import settings
15 from django.core import checks, exceptions, validators
16 from django.db import connection, connections, router
17 from django.db.models.constants import LOOKUP_SEP
18 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin
19 from django.utils import timezone
20 from django.utils.datastructures import DictWrapper
21 from django.utils.dateparse import (
22     parse_date,
23     parse_datetime,
24     parse_duration,
25     parse_time,
26 )
27 from django.utils.duration import duration_microseconds, duration_string
28 from django.utils.functional import Promise, cached_property
29 from django.utils.ipv6 import clean_ipv6_address
30 from django.utils.itercompat import is_iterable
31 from django.utils.text import capfirst
32 from django.utils.translation import gettext_lazy as _
33 
34 __all__ = [
35     "AutoField",
36     "BLANK_CHOICE_DASH",
37     "BigAutoField",
38     "BigIntegerField",
39     "BinaryField",
40     "BooleanField",
41     "CharField",
42     "CommaSeparatedIntegerField",
43     "DateField",
44     "DateTimeField",
45     "DecimalField",
46     "DurationField",
47     "EmailField",
48     "Empty",
49     "Field",
50     "FilePathField",
51     "FloatField",
52     "GenericIPAddressField",
53     "IPAddressField",
54     "IntegerField",
55     "NOT_PROVIDED",
56     "NullBooleanField",
57     "PositiveBigIntegerField",
58     "PositiveIntegerField",
59     "PositiveSmallIntegerField",
60     "SlugField",
61     "SmallAutoField",
62     "SmallIntegerField",
63     "TextField",
64     "TimeField",
65     "URLField",
66     "UUIDField",
67 ]
68 
69 
70 class Empty:
71     pass
72 
73 
74 class NOT_PROVIDED:
75     pass
76 
77 
78 # The values to use for "blank" in SelectFields. Will be appended to the start
79 # of most "choices" lists.
80 BLANK_CHOICE_DASH = [("", "---------")]
81 
82 
83 def _load_field(app_label, model_name, field_name):
84     return apps.get_model(app_label, model_name)._meta.get_field(field_name)
85 
86 
87 # A guide to Field parameters:
88 #
89 #   * name:      The name of the field specified in the model.
90 #   * attname:   The attribute to use on the model object. This is the same as
91 #                "name", except in the case of ForeignKeys, where "_id" is
92 #                appended.
93 #   * db_column: The db_column specified in the model (or None).
94 #   * column:    The database column for this field. This is the same as
95 #                "attname", except if db_column is specified.
96 #
97 # Code that introspects values, or does other dynamic things, should use
98 # attname. For example, this gets the primary key value of object "obj":
99 #
100 #     getattr(obj, opts.pk.attname)
101 
102 
103 def _empty(of_cls):
104     new = Empty()
105     new.__class__ = of_cls
106     return new
107 
108 
109 def return_None():
110     return None
111 
112 
113 @total_ordering
114 class Field(RegisterLookupMixin):
115     """Base class for all field types"""
116 
117     # Designates whether empty strings fundamentally are allowed at the
118     # database level.
119     empty_strings_allowed = True
120     empty_values = list(validators.EMPTY_VALUES)
121 
122     # These track each time a Field instance is created. Used to retain order.
123     # The auto_creation_counter is used for fields that Django implicitly
124     # creates, creation_counter is used for all user-specified fields.
125     creation_counter = 0
126     auto_creation_counter = -1
127     default_validators = []  # Default set of validators
128     default_error_messages = {
129         "invalid_choice": _("Value %(value)r is not a valid choice."),
130         "null": _("This field cannot be null."),
131         "blank": _("This field cannot be blank."),
132         "unique": _("%(model_name)s with this %(field_label)s already exists."),
133         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.
134         # Eg: "Title must be unique for pub_date year"
135         "unique_for_date": _(
136             "%(field_label)s must be unique for "
137             "%(date_field_label)s %(lookup_type)s."
138         ),
139     }
140     system_check_deprecated_details = None
141     system_check_removed_details = None
142 
143     # Attributes that don't affect a column definition.
144     # These attributes are ignored when altering the field.
145     non_db_attrs = (
146         "blank",
147         "choices",
148         "db_column",
149         "editable",
150         "error_messages",
151         "help_text",
152         "limit_choices_to",
153         # Database-level options are not supported, see #21961.
154         "on_delete",
155         "related_name",
156         "related_query_name",
157         "validators",
158         "verbose_name",
159     )
160 
161     # Field flags
162     hidden = False
163 
164     many_to_many = None
165     many_to_one = None
166     one_to_many = None
167     one_to_one = None
168     related_model = None
169 
170     descriptor_class = DeferredAttribute
171 
172     # Generic field type description, usually overridden by subclasses
173     def _description(self):
174         return _("Field of type: %(field_type)s") % {
175             "field_type": self.__class__.__name__
176         }
177 
178     description = property(_description)
179 
180     def __init__(
181         self,
182         verbose_name=None,
183         name=None,
184         primary_key=False,
185         max_length=None,
186         unique=False,
187         blank=False,
188         null=False,
189         db_index=False,
190         rel=None,
191         default=NOT_PROVIDED,
192         editable=True,
193         serialize=True,
194         unique_for_date=None,
195         unique_for_month=None,
196         unique_for_year=None,
197         choices=None,
198         help_text="",
199         db_column=None,
200         db_tablespace=None,
201         auto_created=False,
202         validators=(),
203         error_messages=None,
204     ):
205         self.name = name
206         self.verbose_name = verbose_name  # May be set by set_attributes_from_name
207         self._verbose_name = verbose_name  # Store original for deconstruction
208         self.primary_key = primary_key
209         self.max_length, self._unique = max_length, unique
210         self.blank, self.null = blank, null
211         self.remote_field = rel
212         self.is_relation = self.remote_field is not None
213         self.default = default
214         self.editable = editable
215         self.serialize = serialize
216         self.unique_for_date = unique_for_date
217         self.unique_for_month = unique_for_month
218         self.unique_for_year = unique_for_year
219         if isinstance(choices, collections.abc.Iterator):
220             choices = list(choices)
221         self.choices = choices
222         self.help_text = help_text
223         self.db_index = db_index
224         self.db_column = db_column
225         self._db_tablespace = db_tablespace
226         self.auto_created = auto_created
227 
228         # Adjust the appropriate creation counter, and save our local copy.
229         if auto_created:
230             self.creation_counter = Field.auto_creation_counter
231             Field.auto_creation_counter -= 1
232         else:
233             self.creation_counter = Field.creation_counter
234             Field.creation_counter += 1
235 
236         self._validators = list(validators)  # Store for deconstruction later
237 
238         self._error_messages = error_messages  # Store for deconstruction later
239 
240     def __str__(self):
241         """
242         Return "app_label.model_label.field_name" for fields attached to
243         models.
244         """
245         if not hasattr(self, "model"):
246             return super().__str__()
247         model = self.model
248         return "%s.%s" % (model._meta.label, self.name)
249 
250     def __repr__(self):
251         """Display the module, class, and name of the field."""
252         path = "%s.%s" % (self.__class__.__module__, self.__class__.__qualname__)
253         name = getattr(self, "name", None)
254         if name is not None:
255             return "<%s: %s>" % (path, name)
256         return "<%s>" % path
257 
258     def check(self, **kwargs):
259         return [
260             *self._check_field_name(),
261             *self._check_choices(),
262             *self._check_db_index(),
263             *self._check_null_allowed_for_primary_keys(),
264             *self._check_backend_specific_checks(**kwargs),
265             *self._check_validators(),
266             *self._check_deprecation_details(),
267         ]
268 
269     def _check_field_name(self):
270         """
271         Check if field name is valid, i.e. 1) does not end with an
272         underscore, 2) does not contain "__" and 3) is not "pk".
273         """
274         if self.name.endswith("_"):
275             return [
276                 checks.Error(
277                     "Field names must not end with an underscore.",
278                     obj=self,
279                     id="fields.E001",
280                 )
281             ]
282         elif LOOKUP_SEP in self.name:
283             return [
284                 checks.Error(
285                     'Field names must not contain "%s".' % LOOKUP_SEP,
286                     obj=self,
287                     id="fields.E002",
288                 )
289             ]
290         elif self.name == "pk":
291             return [
292                 checks.Error(
293                     "'pk' is a reserved word that cannot be used as a field name.",
294                     obj=self,
295                     id="fields.E003",
296                 )
297             ]
298         else:
299             return []
300 
301     @classmethod
302     def _choices_is_value(cls, value):
303         return isinstance(value, (str, Promise)) or not is_iterable(value)
304 
305     def _check_choices(self):
306         if not self.choices:
307             return []
308 
309         if not is_iterable(self.choices) or isinstance(self.choices, str):
310             return [
311                 checks.Error(
312                     "'choices' must be an iterable (e.g., a list or tuple).",
313                     obj=self,
314                     id="fields.E004",
315                 )
316             ]
317 
318         choice_max_length = 0
319         # Expect [group_name, [value, display]]
320         for choices_group in self.choices:
321             try:
322                 group_name, group_choices = choices_group
323             except (TypeError, ValueError):
324                 # Containing non-pairs
325                 break
326             try:
327                 if not all(
328                     self._choices_is_value(value) and self._choices_is_value(human_name)
329                     for value, human_name in group_choices
330                 ):
331                     break
332                 if self.max_length is not None and group_choices:
333                     choice_max_length = max(
334                         [
335                             choice_max_length,
336                             *(
337                                 len(value)
338                                 for value, _ in group_choices
339                                 if isinstance(value, str)
340                             ),
341                         ]
342                     )
343             except (TypeError, ValueError):
344                 # No groups, choices in the form [value, display]
345                 value, human_name = group_name, group_choices
346                 if not self._choices_is_value(value) or not self._choices_is_value(
347                     human_name
348                 ):
349                     break
350                 if self.max_length is not None and isinstance(value, str):
351                     choice_max_length = max(choice_max_length, len(value))
352 
353             # Special case: choices=['ab']
354             if isinstance(choices_group, str):
355                 break
356         else:
357             if self.max_length is not None and choice_max_length > self.max_length:
358                 return [
359                     checks.Error(
360                         "'max_length' is too small to fit the longest value "
361                         "in 'choices' (%d characters)." % choice_max_length,
362                         obj=self,
363                         id="fields.E009",
364                     ),
365                 ]
366             return []
367 
368         return [
369             checks.Error(
370                 "'choices' must be an iterable containing "
371                 "(actual value, human readable name) tuples.",
372                 obj=self,
373                 id="fields.E005",
374             )
375         ]
376 
377     def _check_db_index(self):
378         if self.db_index not in (None, True, False):
379             return [
380                 checks.Error(
381                     "'db_index' must be None, True or False.",
382                     obj=self,
383                     id="fields.E006",
384                 )
385             ]
386         else:
387             return []
388 
389     def _check_null_allowed_for_primary_keys(self):
390         if (
391             self.primary_key
392             and self.null
393             and not connection.features.interprets_empty_strings_as_nulls
394         ):
395             # We cannot reliably check this for backends like Oracle which
396             # consider NULL and '' to be equal (and thus set up
397             # character-based fields a little differently).
398             return [
399                 checks.Error(
400                     "Primary keys must not have null=True.",
401                     hint=(
402                         "Set null=False on the field, or "
403                         "remove primary_key=True argument."
404                     ),
405                     obj=self,
406                     id="fields.E007",
407                 )
408             ]
409         else:
410             return []
411 
412     def _check_backend_specific_checks(self, databases=None, **kwargs):
413         if databases is None:
414             return []
415         app_label = self.model._meta.app_label
416         errors = []
417         for alias in databases:
418             if router.allow_migrate(
419                 alias, app_label, model_name=self.model._meta.model_name
420             ):
421                 errors.extend(connections[alias].validation.check_field(self, **kwargs))
422         return errors
423 
424     def _check_validators(self):
425         errors = []
426         for i, validator in enumerate(self.validators):
427             if not callable(validator):
428                 errors.append(
429                     checks.Error(
430                         "All 'validators' must be callable.",
431                         hint=(
432                             "validators[{i}] ({repr}) isn't a function or "
433                             "instance of a validator class.".format(
434                                 i=i,
435                                 repr=repr(validator),
436                             )
437                         ),
438                         obj=self,
439                         id="fields.E008",
440                     )
441                 )
442         return errors
443 
444     def _check_deprecation_details(self):
445         if self.system_check_removed_details is not None:
446             return [
447                 checks.Error(
448                     self.system_check_removed_details.get(
449                         "msg",
450                         "%s has been removed except for support in historical "
451                         "migrations." % self.__class__.__name__,
452                     ),
453                     hint=self.system_check_removed_details.get("hint"),
454                     obj=self,
455                     id=self.system_check_removed_details.get("id", "fields.EXXX"),
456                 )
457             ]
458         elif self.system_check_deprecated_details is not None:
459             return [
460                 checks.Warning(
461                     self.system_check_deprecated_details.get(
462                         "msg", "%s has been deprecated." % self.__class__.__name__
463                     ),
464                     hint=self.system_check_deprecated_details.get("hint"),
465                     obj=self,
466                     id=self.system_check_deprecated_details.get("id", "fields.WXXX"),
467                 )
468             ]
469         return []
470 
471     def get_col(self, alias, output_field=None):
472         if alias == self.model._meta.db_table and (
473             output_field is None or output_field == self
474         ):
475             return self.cached_col
476         from django.db.models.expressions import Col
477 
478         return Col(alias, self, output_field)
479 
480     @cached_property
481     def cached_col(self):
482         from django.db.models.expressions import Col
483 
484         return Col(self.model._meta.db_table, self)
485 
486     def select_format(self, compiler, sql, params):
487         """
488         Custom format for select clauses. For example, GIS columns need to be
489         selected as AsText(table.col) on MySQL as the table.col data can't be
490         used by Django.
491         """
492         return sql, params
493 
494     def deconstruct(self):
495         """
496         Return enough information to recreate the field as a 4-tuple:
497 
498          * The name of the field on the model, if contribute_to_class() has
499            been run.
500          * The import path of the field, including the class, e.g.
501            django.db.models.IntegerField. This should be the most portable
502            version, so less specific may be better.
503          * A list of positional arguments.
504          * A dict of keyword arguments.
505 
506         Note that the positional or keyword arguments must contain values of
507         the following types (including inner values of collection types):
508 
509          * None, bool, str, int, float, complex, set, frozenset, list, tuple,
510            dict
511          * UUID
512          * datetime.datetime (naive), datetime.date
513          * top-level classes, top-level functions - will be referenced by their
514            full import path
515          * Storage instances - these have their own deconstruct() method
516 
517         This is because the values here must be serialized into a text format
518         (possibly new Python code, possibly JSON) and these are the only types
519         with encoding handlers defined.
520 
521         There's no need to return the exact way the field was instantiated this
522         time, just ensure that the resulting field is the same - prefer keyword
523         arguments over positional ones, and omit parameters with their default
524         values.
525         """
526         # Short-form way of fetching all the default parameters
527         keywords = {}
528         possibles = {
529             "verbose_name": None,
530             "primary_key": False,
531             "max_length": None,
532             "unique": False,
533             "blank": False,
534             "null": False,
535             "db_index": False,
536             "default": NOT_PROVIDED,
537             "editable": True,
538             "serialize": True,
539             "unique_for_date": None,
540             "unique_for_month": None,
541             "unique_for_year": None,
542             "choices": None,
543             "help_text": "",
544             "db_column": None,
545             "db_tablespace": None,
546             "auto_created": False,
547             "validators": [],
548             "error_messages": None,
549         }
550         attr_overrides = {
551             "unique": "_unique",
552             "error_messages": "_error_messages",
553             "validators": "_validators",
554             "verbose_name": "_verbose_name",
555             "db_tablespace": "_db_tablespace",
556         }
557         equals_comparison = {"choices", "validators"}
558         for name, default in possibles.items():
559             value = getattr(self, attr_overrides.get(name, name))
560             # Unroll anything iterable for choices into a concrete list
561             if name == "choices" and isinstance(value, collections.abc.Iterable):
562                 value = list(value)
563             # Do correct kind of comparison
564             if name in equals_comparison:
565                 if value != default:
566                     keywords[name] = value
567             else:
568                 if value is not default:
569                     keywords[name] = value
570         # Work out path - we shorten it for known Django core fields
571         path = "%s.%s" % (self.__class__.__module__, self.__class__.__qualname__)
572         if path.startswith("django.db.models.fields.related"):
573             path = path.replace("django.db.models.fields.related", "django.db.models")
574         elif path.startswith("django.db.models.fields.files"):
575             path = path.replace("django.db.models.fields.files", "django.db.models")
576         elif path.startswith("django.db.models.fields.json"):
577             path = path.replace("django.db.models.fields.json", "django.db.models")
578         elif path.startswith("django.db.models.fields.proxy"):
579             path = path.replace("django.db.models.fields.proxy", "django.db.models")
580         elif path.startswith("django.db.models.fields"):
581             path = path.replace("django.db.models.fields", "django.db.models")
582         # Return basic info - other fields should override this.
583         return (self.name, path, [], keywords)
584 
585     def clone(self):
586         """
587         Uses deconstruct() to clone a new copy of this Field.
588         Will not preserve any class attachments/attribute names.
589         """
590         name, path, args, kwargs = self.deconstruct()
591         return self.__class__(*args, **kwargs)
592 
593     def __eq__(self, other):
594         # Needed for @total_ordering
595         if isinstance(other, Field):
596             return self.creation_counter == other.creation_counter and getattr(
597                 self, "model", None
598             ) == getattr(other, "model", None)
599         return NotImplemented
600 
601     def __lt__(self, other):
602         # This is needed because bisect does not take a comparison function.
603         # Order by creation_counter first for backward compatibility.
604         if isinstance(other, Field):
605             if (
606                 self.creation_counter != other.creation_counter
607                 or not hasattr(self, "model")
608                 and not hasattr(other, "model")
609             ):
610                 return self.creation_counter < other.creation_counter
611             elif hasattr(self, "model") != hasattr(other, "model"):
612                 return not hasattr(self, "model")  # Order no-model fields first
613             else:
614                 # creation_counter's are equal, compare only models.
615                 return (self.model._meta.app_label, self.model._meta.model_name) < (
616                     other.model._meta.app_label,
617                     other.model._meta.model_name,
618                 )
619         return NotImplemented
620 
621     def __hash__(self):
622         return hash(self.creation_counter)
623 
624     def __deepcopy__(self, memodict):
625         # We don't have to deepcopy very much here, since most things are not
626         # intended to be altered after initial creation.
627         obj = copy.copy(self)
628         if self.remote_field:
629             obj.remote_field = copy.copy(self.remote_field)
630             if hasattr(self.remote_field, "field") and self.remote_field.field is self:
631                 obj.remote_field.field = obj
632         memodict[id(self)] = obj
633         return obj
634 
635     def __copy__(self):
636         # We need to avoid hitting __reduce__, so define this
637         # slightly weird copy construct.
638         obj = Empty()
639         obj.__class__ = self.__class__
640         obj.__dict__ = self.__dict__.copy()
641         return obj
642 
643     def __reduce__(self):
644         """
645         Pickling should return the model._meta.fields instance of the field,
646         not a new copy of that field. So, use the app registry to load the
647         model and then the field back.
648         """
649         if not hasattr(self, "model"):
650             # Fields are sometimes used without attaching them to models (for
651             # example in aggregation). In this case give back a plain field
652             # instance. The code below will create a new empty instance of
653             # class self.__class__, then update its dict with self.__dict__
654             # values - so, this is very close to normal pickle.
655             state = self.__dict__.copy()
656             # The _get_default cached_property can't be pickled due to lambda
657             # usage.
658             state.pop("_get_default", None)
659             return _empty, (self.__class__,), state
660         return _load_field, (
661             self.model._meta.app_label,
662             self.model._meta.object_name,
663             self.name,
664         )
665 
666     def get_pk_value_on_save(self, instance):
667         """
668         Hook to generate new PK values on save. This method is called when
669         saving instances with no primary key value set. If this method returns
670         something else than None, then the returned value is used when saving
671         the new instance.
672         """
673         if self.default:
674             return self.get_default()
675         return None
676 
677     def to_python(self, value):
678         """
679         Convert the input value into the expected Python data type, raising
680         django.core.exceptions.ValidationError if the data can't be converted.
681         Return the converted value. Subclasses should override this.
682         """
683         return value
684 
685     @cached_property
686     def error_messages(self):
687         messages = {}
688         for c in reversed(self.__class__.__mro__):
689             messages.update(getattr(c, "default_error_messages", {}))
690         messages.update(self._error_messages or {})
691         return messages
692 
693     @cached_property
694     def validators(self):
695         """
696         Some validators can't be created at field initialization time.
697         This method provides a way to delay their creation until required.
698         """
699         return [*self.default_validators, *self._validators]
700 
701     def run_validators(self, value):
702         if value in self.empty_values:
703             return
704 
705         errors = []
706         for v in self.validators:
707             try:
708                 v(value)
709             except exceptions.ValidationError as e:
710                 if hasattr(e, "code") and e.code in self.error_messages:
711                     e.message = self.error_messages[e.code]
712                 errors.extend(e.error_list)
713 
714         if errors:
715             raise exceptions.ValidationError(errors)
716 
717     def validate(self, value, model_instance):
718         """
719         Validate value and raise ValidationError if necessary. Subclasses
720         should override this to provide validation logic.
721         """
722         if not self.editable:
723             # Skip validation for non-editable fields.
724             return
725 
726         if self.choices is not None and value not in self.empty_values:
727             for option_key, option_value in self.choices:
728                 if isinstance(option_value, (list, tuple)):
729                     # This is an optgroup, so look inside the group for
730                     # options.
731                     for optgroup_key, optgroup_value in option_value:
732                         if value == optgroup_key:
733                             return
734                 elif value == option_key:
735                     return
736             raise exceptions.ValidationError(
737                 self.error_messages["invalid_choice"],
738                 code="invalid_choice",
739                 params={"value": value},
740             )
741 
742         if value is None and not self.null:
743             raise exceptions.ValidationError(self.error_messages["null"], code="null")
744 
745         if not self.blank and value in self.empty_values:
746             raise exceptions.ValidationError(self.error_messages["blank"], code="blank")
747 
748     def clean(self, value, model_instance):
749         """
750         Convert the value's type and run validation. Validation errors
751         from to_python() and validate() are propagated. Return the correct
752         value if no error is raised.
753         """
754         value = self.to_python(value)
755         self.validate(value, model_instance)
756         self.run_validators(value)
757         return value
758 
759     def db_type_parameters(self, connection):
760         return DictWrapper(self.__dict__, connection.ops.quote_name, "qn_")
761 
762     def db_check(self, connection):
763         """
764         Return the database column check constraint for this field, for the
765         provided connection. Works the same way as db_type() for the case that
766         get_internal_type() does not map to a preexisting model field.
767         """
768         data = self.db_type_parameters(connection)
769         try:
770             return (
771                 connection.data_type_check_constraints[self.get_internal_type()] % data
772             )
773         except KeyError:
774             return None
775 
776     def db_type(self, connection):
777         """
778         Return the database column data type for this field, for the provided
779         connection.
780         """
781         # The default implementation of this method looks at the
782         # backend-specific data_types dictionary, looking up the field by its
783         # "internal type".
784         #
785         # A Field class can implement the get_internal_type() method to specify
786         # which *preexisting* Django Field class it's most similar to -- i.e.,
787         # a custom field might be represented by a TEXT column type, which is
788         # the same as the TextField Django field type, which means the custom
789         # field's get_internal_type() returns 'TextField'.
790         #
791         # But the limitation of the get_internal_type() / data_types approach
792         # is that it cannot handle database column types that aren't already
793         # mapped to one of the built-in Django field types. In this case, you
794         # can implement db_type() instead of get_internal_type() to specify
795         # exactly which wacky database column type you want to use.
796         data = self.db_type_parameters(connection)
797         try:
798             return connection.data_types[self.get_internal_type()] % data
799         except KeyError:
800             return None
801 
802     def rel_db_type(self, connection):
803         """
804         Return the data type that a related field pointing to this field should
805         use. For example, this method is called by ForeignKey and OneToOneField
806         to determine its data type.
807         """
808         return self.db_type(connection)
809 
810     def cast_db_type(self, connection):
811         """Return the data type to use in the Cast() function."""
812         db_type = connection.ops.cast_data_types.get(self.get_internal_type())
813         if db_type:
814             return db_type % self.db_type_parameters(connection)
815         return self.db_type(connection)
816 
817     def db_parameters(self, connection):
818         """
819         Extension of db_type(), providing a range of different return values
820         (type, checks). This will look at db_type(), allowing custom model
821         fields to override it.
822         """
823         type_string = self.db_type(connection)
824         check_string = self.db_check(connection)
825         return {
826             "type": type_string,
827             "check": check_string,
828         }
829 
830     def db_type_suffix(self, connection):
831         return connection.data_types_suffix.get(self.get_internal_type())
832 
833     def get_db_converters(self, connection):
834         if hasattr(self, "from_db_value"):
835             return [self.from_db_value]
836         return []
837 
838     @property
839     def unique(self):
840         return self._unique or self.primary_key
841 
842     @property
843     def db_tablespace(self):
844         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE
845 
846     @property
847     def db_returning(self):
848         """
849         Private API intended only to be used by Django itself. Currently only
850         the PostgreSQL backend supports returning multiple fields on a model.
851         """
852         return False
853 
854     def set_attributes_from_name(self, name):
855         self.name = self.name or name
856         self.attname, self.column = self.get_attname_column()
857         self.concrete = self.column is not None
858         if self.verbose_name is None and self.name:
859             self.verbose_name = self.name.replace("_", " ")
860 
861     def contribute_to_class(self, cls, name, private_only=False):
862         """
863         Register the field with the model class it belongs to.
864 
865         If private_only is True, create a separate instance of this field
866         for every subclass of cls, even if cls is not an abstract model.
867         """
868         self.set_attributes_from_name(name)
869         self.model = cls
870         cls._meta.add_field(self, private=private_only)
871         if self.column:
872             setattr(cls, self.attname, self.descriptor_class(self))
873         if self.choices is not None:
874             # Don't override a get_FOO_display() method defined explicitly on
875             # this class, but don't check methods derived from inheritance, to
876             # allow overriding inherited choices. For more complex inheritance
877             # structures users should override contribute_to_class().
878             if "get_%s_display" % self.name not in cls.__dict__:
879                 setattr(
880                     cls,
881                     "get_%s_display" % self.name,
882                     partialmethod(cls._get_FIELD_display, field=self),
883                 )
884 
885     def get_filter_kwargs_for_object(self, obj):
886         """
887         Return a dict that when passed as kwargs to self.model.filter(), would
888         yield all instances having the same value for this field as obj has.
889         """
890         return {self.name: getattr(obj, self.attname)}
891 
892     def get_attname(self):
893         return self.name
894 
895     def get_attname_column(self):
896         attname = self.get_attname()
897         column = self.db_column or attname
898         return attname, column
899 
900     def get_internal_type(self):
901         return self.__class__.__name__
902 
903     def pre_save(self, model_instance, add):
904         """Return field's value just before saving."""
905         return getattr(model_instance, self.attname)
906 
907     def get_prep_value(self, value):
908         """Perform preliminary non-db specific value checks and conversions."""
909         if isinstance(value, Promise):
910             value = value._proxy____cast()
911         return value
912 
913     def get_db_prep_value(self, value, connection, prepared=False):
914         """
915         Return field's value prepared for interacting with the database backend.
916 
917         Used by the default implementations of get_db_prep_save().
918         """
919         if not prepared:
920             value = self.get_prep_value(value)
921         return value
922 
923     def get_db_prep_save(self, value, connection):
924         """Return field's value prepared for saving into a database."""
925         return self.get_db_prep_value(value, connection=connection, prepared=False)
926 
927     def has_default(self):
928         """Return a boolean of whether this field has a default value."""
929         return self.default is not NOT_PROVIDED
930 
931     def get_default(self):
932         """Return the default value for this field."""
933         return self._get_default()
934 
935     @cached_property
936     def _get_default(self):
937         if self.has_default():
938             if callable(self.default):
939                 return self.default
940             return lambda: self.default
941 
942         if (
943             not self.empty_strings_allowed
944             or self.null
945             and not connection.features.interprets_empty_strings_as_nulls
946         ):
947             return return_None
948         return str  # return empty string
949 
950     def get_choices(
951         self,
952         include_blank=True,
953         blank_choice=BLANK_CHOICE_DASH,
954         limit_choices_to=None,
955         ordering=(),
956     ):
957         """
958         Return choices with a default blank choices included, for use
959         as <select> choices for this field.
960         """
961         if self.choices is not None:
962             choices = list(self.choices)
963             if include_blank:
964                 blank_defined = any(
965                     choice in ("", None) for choice, _ in self.flatchoices
966                 )
967                 if not blank_defined:
968                     choices = blank_choice + choices
969             return choices
970         rel_model = self.remote_field.model
971         limit_choices_to = limit_choices_to or self.get_limit_choices_to()
972         choice_func = operator.attrgetter(
973             self.remote_field.get_related_field().attname
974             if hasattr(self.remote_field, "get_related_field")
975             else "pk"
976         )
977         qs = rel_model._default_manager.complex_filter(limit_choices_to)
978         if ordering:
979             qs = qs.order_by(*ordering)
980         return (blank_choice if include_blank else []) + [
981             (choice_func(x), str(x)) for x in qs
982         ]
983 
984     def value_to_string(self, obj):
985         """
986         Return a string value of this field from the passed obj.
987         This is used by the serialization framework.
988         """
989         return str(self.value_from_object(obj))
990 
991     def _get_flatchoices(self):
992         """Flattened version of choices tuple."""
993         if self.choices is None:
994             return []
995         flat = []
996         for choice, value in self.choices:
997             if isinstance(value, (list, tuple)):
998                 flat.extend(value)
999             else:
1000                 flat.append((choice, value))
1001         return flat
1002 
1003     flatchoices = property(_get_flatchoices)
1004 
1005     def save_form_data(self, instance, data):
1006         setattr(instance, self.name, data)
1007 
1008     def formfield(self, form_class=None, choices_form_class=None, **kwargs):
1009         """Return a django.forms.Field instance for this field."""
1010         defaults = {
1011             "required": not self.blank,
1012             "label": capfirst(self.verbose_name),
1013             "help_text": self.help_text,
1014         }
1015         if self.has_default():
1016             if callable(self.default):
1017                 defaults["initial"] = self.default
1018                 defaults["show_hidden_initial"] = True
1019             else:
1020                 defaults["initial"] = self.get_default()
1021         if self.choices is not None:
1022             # Fields with choices get special treatment.
1023             include_blank = self.blank or not (
1024                 self.has_default() or "initial" in kwargs
1025             )
1026             defaults["choices"] = self.get_choices(include_blank=include_blank)
1027             defaults["coerce"] = self.to_python
1028             if self.null:
1029                 defaults["empty_value"] = None
1030             if choices_form_class is not None:
1031                 form_class = choices_form_class
1032             else:
1033                 form_class = forms.TypedChoiceField
1034             # Many of the subclass-specific formfield arguments (min_value,
1035             # max_value) don't apply for choice fields, so be sure to only pass
1036             # the values that TypedChoiceField will understand.
1037             for k in list(kwargs):
1038                 if k not in (
1039                     "coerce",
1040                     "empty_value",
1041                     "choices",
1042                     "required",
1043                     "widget",
1044                     "label",
1045                     "initial",
1046                     "help_text",
1047                     "error_messages",
1048                     "show_hidden_initial",
1049                     "disabled",
1050                 ):
1051                     del kwargs[k]
1052         defaults.update(kwargs)
1053         if form_class is None:
1054             form_class = forms.CharField
1055         return form_class(**defaults)
1056 
1057     def value_from_object(self, obj):
1058         """Return the value of this field in the given model instance."""
1059         return getattr(obj, self.attname)
1060 
1061 
1062 class BooleanField(Field):
1063     empty_strings_allowed = False
1064     default_error_messages = {
1065         "invalid": _("“%(value)s” value must be either True or False."),
1066         "invalid_nullable": _("“%(value)s” value must be either True, False, or None."),
1067     }
1068     description = _("Boolean (Either True or False)")
1069 
1070     def get_internal_type(self):
1071         return "BooleanField"
1072 
1073     def to_python(self, value):
1074         if self.null and value in self.empty_values:
1075             return None
1076         if value in (True, False):
1077             # 1/0 are equal to True/False. bool() converts former to latter.
1078             return bool(value)
1079         if value in ("t", "True", "1"):
1080             return True
1081         if value in ("f", "False", "0"):
1082             return False
1083         raise exceptions.ValidationError(
1084             self.error_messages["invalid_nullable" if self.null else "invalid"],
1085             code="invalid",
1086             params={"value": value},
1087         )
1088 
1089     def get_prep_value(self, value):
1090         value = super().get_prep_value(value)
1091         if value is None:
1092             return None
1093         return self.to_python(value)
1094 
1095     def formfield(self, **kwargs):
1096         if self.choices is not None:
1097             include_blank = not (self.has_default() or "initial" in kwargs)
1098             defaults = {"choices": self.get_choices(include_blank=include_blank)}
1099         else:
1100             form_class = forms.NullBooleanField if self.null else forms.BooleanField
1101             # In HTML checkboxes, 'required' means "must be checked" which is
1102             # different from the choices case ("must select some value").
1103             # required=False allows unchecked checkboxes.
1104             defaults = {"form_class": form_class, "required": False}
1105         return super().formfield(**{**defaults, **kwargs})
1106 
1107     def select_format(self, compiler, sql, params):
1108         sql, params = super().select_format(compiler, sql, params)
1109         # Filters that match everything are handled as empty strings in the
1110         # WHERE clause, but in SELECT or GROUP BY list they must use a
1111         # predicate that's always True.
1112         if sql == "":
1113             sql = "1"
1114         return sql, params
1115 
1116 
1117 class CharField(Field):
1118     description = _("String (up to %(max_length)s)")
1119 
1120     def __init__(self, *args, db_collation=None, **kwargs):
1121         super().__init__(*args, **kwargs)
1122         self.db_collation = db_collation
1123         if self.max_length is not None:
1124             self.validators.append(validators.MaxLengthValidator(self.max_length))
1125 
1126     def check(self, **kwargs):
1127         databases = kwargs.get("databases") or []
1128         return [
1129             *super().check(**kwargs),
1130             *self._check_db_collation(databases),
1131             *self._check_max_length_attribute(**kwargs),
1132         ]
1133 
1134     def _check_max_length_attribute(self, **kwargs):
1135         if self.max_length is None:
1136             return [
1137                 checks.Error(
1138                     "CharFields must define a 'max_length' attribute.",
1139                     obj=self,
1140                     id="fields.E120",
1141                 )
1142             ]
1143         elif (
1144             not isinstance(self.max_length, int)
1145             or isinstance(self.max_length, bool)
1146             or self.max_length <= 0
1147         ):
1148             return [
1149                 checks.Error(
1150                     "'max_length' must be a positive integer.",
1151                     obj=self,
1152                     id="fields.E121",
1153                 )
1154             ]
1155         else:
1156             return []
1157 
1158     def _check_db_collation(self, databases):
1159         errors = []
1160         for db in databases:
1161             if not router.allow_migrate_model(db, self.model):
1162                 continue
1163             connection = connections[db]
1164             if not (
1165                 self.db_collation is None
1166                 or "supports_collation_on_charfield"
1167                 in self.model._meta.required_db_features
1168                 or connection.features.supports_collation_on_charfield
1169             ):
1170                 errors.append(
1171                     checks.Error(
1172                         "%s does not support a database collation on "
1173                         "CharFields." % connection.display_name,
1174                         obj=self,
1175                         id="fields.E190",
1176                     ),
1177                 )
1178         return errors
1179 
1180     def cast_db_type(self, connection):
1181         if self.max_length is None:
1182             return connection.ops.cast_char_field_without_max_length
1183         return super().cast_db_type(connection)
1184 
1185     def db_parameters(self, connection):
1186         db_params = super().db_parameters(connection)
1187         db_params["collation"] = self.db_collation
1188         return db_params
1189 
1190     def get_internal_type(self):
1191         return "CharField"
1192 
1193     def to_python(self, value):
1194         if isinstance(value, str) or value is None:
1195             return value
1196         return str(value)
1197 
1198     def get_prep_value(self, value):
1199         value = super().get_prep_value(value)
1200         return self.to_python(value)
1201 
1202     def formfield(self, **kwargs):
1203         # Passing max_length to forms.CharField means that the value's length
1204         # will be validated twice. This is considered acceptable since we want
1205         # the value in the form field (to pass into widget for example).
1206         defaults = {"max_length": self.max_length}
1207         # TODO: Handle multiple backends with different feature flags.
1208         if self.null and not connection.features.interprets_empty_strings_as_nulls:
1209             defaults["empty_value"] = None
1210         defaults.update(kwargs)
1211         return super().formfield(**defaults)
1212 
1213     def deconstruct(self):
1214         name, path, args, kwargs = super().deconstruct()
1215         if self.db_collation:
1216             kwargs["db_collation"] = self.db_collation
1217         return name, path, args, kwargs
1218 
1219 
1220 class CommaSeparatedIntegerField(CharField):
1221     default_validators = [validators.validate_comma_separated_integer_list]
1222     description = _("Comma-separated integers")
1223     system_check_removed_details = {
1224         "msg": (
1225             "CommaSeparatedIntegerField is removed except for support in "
1226             "historical migrations."
1227         ),
1228         "hint": (
1229             "Use CharField(validators=[validate_comma_separated_integer_list]) "
1230             "instead."
1231         ),
1232         "id": "fields.E901",
1233     }
1234 
1235 
1236 def _to_naive(value):
1237     if timezone.is_aware(value):
1238         value = timezone.make_naive(value, datetime.timezone.utc)
1239     return value
1240 
1241 
1242 def _get_naive_now():
1243     return _to_naive(timezone.now())
1244 
1245 
1246 class DateTimeCheckMixin:
1247     def check(self, **kwargs):
1248         return [
1249             *super().check(**kwargs),
1250             *self._check_mutually_exclusive_options(),
1251             *self._check_fix_default_value(),
1252         ]
1253 
1254     def _check_mutually_exclusive_options(self):
1255         # auto_now, auto_now_add, and default are mutually exclusive
1256         # options. The use of more than one of these options together
1257         # will trigger an Error
1258         mutually_exclusive_options = [
1259             self.auto_now_add,
1260             self.auto_now,
1261             self.has_default(),
1262         ]
1263         enabled_options = [
1264             option not in (None, False) for option in mutually_exclusive_options
1265         ].count(True)
1266         if enabled_options > 1:
1267             return [
1268                 checks.Error(
1269                     "The options auto_now, auto_now_add, and default "
1270                     "are mutually exclusive. Only one of these options "
1271                     "may be present.",
1272                     obj=self,
1273                     id="fields.E160",
1274                 )
1275             ]
1276         else:
1277             return []
1278 
1279     def _check_fix_default_value(self):
1280         return []
1281 
1282     # Concrete subclasses use this in their implementations of
1283     # _check_fix_default_value().
1284     def _check_if_value_fixed(self, value, now=None):
1285         """
1286         Check if the given value appears to have been provided as a "fixed"
1287         time value, and include a warning in the returned list if it does. The
1288         value argument must be a date object or aware/naive datetime object. If
1289         now is provided, it must be a naive datetime object.
1290         """
1291         if now is None:
1292             now = _get_naive_now()
1293         offset = datetime.timedelta(seconds=10)
1294         lower = now - offset
1295         upper = now + offset
1296         if isinstance(value, datetime.datetime):
1297             value = _to_naive(value)
1298         else:
1299             assert isinstance(value, datetime.date)
1300             lower = lower.date()
1301             upper = upper.date()
1302         if lower <= value <= upper:
1303             return [
1304                 checks.Warning(
1305                     "Fixed default value provided.",
1306                     hint=(
1307                         "It seems you set a fixed date / time / datetime "
1308                         "value as default for this field. This may not be "
1309                         "what you want. If you want to have the current date "
1310                         "as default, use `django.utils.timezone.now`"
1311                     ),
1312                     obj=self,
1313                     id="fields.W161",
1314                 )
1315             ]
1316         return []
1317 
1318 
1319 class DateField(DateTimeCheckMixin, Field):
1320     empty_strings_allowed = False
1321     default_error_messages = {
1322         "invalid": _(
1323             "“%(value)s” value has an invalid date format. It must be "
1324             "in YYYY-MM-DD format."
1325         ),
1326         "invalid_date": _(
1327             "“%(value)s” value has the correct format (YYYY-MM-DD) "
1328             "but it is an invalid date."
1329         ),
1330     }
1331     description = _("Date (without time)")
1332 
1333     def __init__(
1334         self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs
1335     ):
1336         self.auto_now, self.auto_now_add = auto_now, auto_now_add
1337         if auto_now or auto_now_add:
1338             kwargs["editable"] = False
1339             kwargs["blank"] = True
1340         super().__init__(verbose_name, name, **kwargs)
1341 
1342     def _check_fix_default_value(self):
1343         """
1344         Warn that using an actual date or datetime value is probably wrong;
1345         it's only evaluated on server startup.
1346         """
1347         if not self.has_default():
1348             return []
1349 
1350         value = self.default
1351         if isinstance(value, datetime.datetime):
1352             value = _to_naive(value).date()
1353         elif isinstance(value, datetime.date):
1354             pass
1355         else:
1356             # No explicit date / datetime value -- no checks necessary
1357             return []
1358         # At this point, value is a date object.
1359         return self._check_if_value_fixed(value)
1360 
1361     def deconstruct(self):
1362         name, path, args, kwargs = super().deconstruct()
1363         if self.auto_now:
1364             kwargs["auto_now"] = True
1365         if self.auto_now_add:
1366             kwargs["auto_now_add"] = True
1367         if self.auto_now or self.auto_now_add:
1368             del kwargs["editable"]
1369             del kwargs["blank"]
1370         return name, path, args, kwargs
1371 
1372     def get_internal_type(self):
1373         return "DateField"
1374 
1375     def to_python(self, value):
1376         if value is None:
1377             return value
1378         if isinstance(value, datetime.datetime):
1379             if settings.USE_TZ and timezone.is_aware(value):
1380                 # Convert aware datetimes to the default time zone
1381                 # before casting them to dates (#17742).
1382                 default_timezone = timezone.get_default_timezone()
1383                 value = timezone.make_naive(value, default_timezone)
1384             return value.date()
1385         if isinstance(value, datetime.date):
1386             return value
1387 
1388         try:
1389             parsed = parse_date(value)
1390             if parsed is not None:
1391                 return parsed
1392         except ValueError:
1393             raise exceptions.ValidationError(
1394                 self.error_messages["invalid_date"],
1395                 code="invalid_date",
1396                 params={"value": value},
1397             )
1398 
1399         raise exceptions.ValidationError(
1400             self.error_messages["invalid"],
1401             code="invalid",
1402             params={"value": value},
1403         )
1404 
1405     def pre_save(self, model_instance, add):
1406         if self.auto_now or (self.auto_now_add and add):
1407             value = datetime.date.today()
1408             setattr(model_instance, self.attname, value)
1409             return value
1410         else:
1411             return super().pre_save(model_instance, add)
1412 
1413     def contribute_to_class(self, cls, name, **kwargs):
1414         super().contribute_to_class(cls, name, **kwargs)
1415         if not self.null:
1416             setattr(
1417                 cls,
1418                 "get_next_by_%s" % self.name,
1419                 partialmethod(
1420                     cls._get_next_or_previous_by_FIELD, field=self, is_next=True
1421                 ),
1422             )
1423             setattr(
1424                 cls,
1425                 "get_previous_by_%s" % self.name,
1426                 partialmethod(
1427                     cls._get_next_or_previous_by_FIELD, field=self, is_next=False
1428                 ),
1429             )
1430 
1431     def get_prep_value(self, value):
1432         value = super().get_prep_value(value)
1433         return self.to_python(value)
1434 
1435     def get_db_prep_value(self, value, connection, prepared=False):
1436         # Casts dates into the format expected by the backend
1437         if not prepared:
1438             value = self.get_prep_value(value)
1439         return connection.ops.adapt_datefield_value(value)
1440 
1441     def value_to_string(self, obj):
1442         val = self.value_from_object(obj)
1443         return "" if val is None else val.isoformat()
1444 
1445     def formfield(self, **kwargs):
1446         return super().formfield(
1447             **{
1448                 "form_class": forms.DateField,
1449                 **kwargs,
1450             }
1451         )
1452 
1453 
1454 class DateTimeField(DateField):
1455     empty_strings_allowed = False
1456     default_error_messages = {
1457         "invalid": _(
1458             "“%(value)s” value has an invalid format. It must be in "
1459             "YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format."
1460         ),
1461         "invalid_date": _(
1462             "“%(value)s” value has the correct format "
1463             "(YYYY-MM-DD) but it is an invalid date."
1464         ),
1465         "invalid_datetime": _(
1466             "“%(value)s” value has the correct format "
1467             "(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) "
1468             "but it is an invalid date/time."
1469         ),
1470     }
1471     description = _("Date (with time)")
1472 
1473     # __init__ is inherited from DateField
1474 
1475     def _check_fix_default_value(self):
1476         """
1477         Warn that using an actual date or datetime value is probably wrong;
1478         it's only evaluated on server startup.
1479         """
1480         if not self.has_default():
1481             return []
1482 
1483         value = self.default
1484         if isinstance(value, (datetime.datetime, datetime.date)):
1485             return self._check_if_value_fixed(value)
1486         # No explicit date / datetime value -- no checks necessary.
1487         return []
1488 
1489     def get_internal_type(self):
1490         return "DateTimeField"
1491 
1492     def to_python(self, value):
1493         if value is None:
1494             return value
1495         if isinstance(value, datetime.datetime):
1496             return value
1497         if isinstance(value, datetime.date):
1498             value = datetime.datetime(value.year, value.month, value.day)
1499             if settings.USE_TZ:
1500                 # For backwards compatibility, interpret naive datetimes in
1501                 # local time. This won't work during DST change, but we can't
1502                 # do much about it, so we let the exceptions percolate up the
1503                 # call stack.
1504                 warnings.warn(
1505                     "DateTimeField %s.%s received a naive datetime "
1506                     "(%s) while time zone support is active."
1507                     % (self.model.__name__, self.name, value),
1508                     RuntimeWarning,
1509                 )
1510                 default_timezone = timezone.get_default_timezone()
1511                 value = timezone.make_aware(value, default_timezone)
1512             return value
1513 
1514         try:
1515             parsed = parse_datetime(value)
1516             if parsed is not None:
1517                 return parsed
1518         except ValueError:
1519             raise exceptions.ValidationError(
1520                 self.error_messages["invalid_datetime"],
1521                 code="invalid_datetime",
1522                 params={"value": value},
1523             )
1524 
1525         try:
1526             parsed = parse_date(value)
1527             if parsed is not None:
1528                 return datetime.datetime(parsed.year, parsed.month, parsed.day)
1529         except ValueError:
1530             raise exceptions.ValidationError(
1531                 self.error_messages["invalid_date"],
1532                 code="invalid_date",
1533                 params={"value": value},
1534             )
1535 
1536         raise exceptions.ValidationError(
1537             self.error_messages["invalid"],
1538             code="invalid",
1539             params={"value": value},
1540         )
1541 
1542     def pre_save(self, model_instance, add):
1543         if self.auto_now or (self.auto_now_add and add):
1544             value = timezone.now()
1545             setattr(model_instance, self.attname, value)
1546             return value
1547         else:
1548             return super().pre_save(model_instance, add)
1549 
1550     # contribute_to_class is inherited from DateField, it registers
1551     # get_next_by_FOO and get_prev_by_FOO
1552 
1553     def get_prep_value(self, value):
1554         value = super().get_prep_value(value)
1555         value = self.to_python(value)
1556         if value is not None and settings.USE_TZ and timezone.is_naive(value):
1557             # For backwards compatibility, interpret naive datetimes in local
1558             # time. This won't work during DST change, but we can't do much
1559             # about it, so we let the exceptions percolate up the call stack.
1560             try:
1561                 name = "%s.%s" % (self.model.__name__, self.name)
1562             except AttributeError:
1563                 name = "(unbound)"
1564             warnings.warn(
1565                 "DateTimeField %s received a naive datetime (%s)"
1566                 " while time zone support is active." % (name, value),
1567                 RuntimeWarning,
1568             )
1569             default_timezone = timezone.get_default_timezone()
1570             value = timezone.make_aware(value, default_timezone)
1571         return value
1572 
1573     def get_db_prep_value(self, value, connection, prepared=False):
1574         # Casts datetimes into the format expected by the backend
1575         if not prepared:
1576             value = self.get_prep_value(value)
1577         return connection.ops.adapt_datetimefield_value(value)
1578 
1579     def value_to_string(self, obj):
1580         val = self.value_from_object(obj)
1581         return "" if val is None else val.isoformat()
1582 
1583     def formfield(self, **kwargs):
1584         return super().formfield(
1585             **{
1586                 "form_class": forms.DateTimeField,
1587                 **kwargs,
1588             }
1589         )
1590 
1591 
1592 class DecimalField(Field):
1593     empty_strings_allowed = False
1594     default_error_messages = {
1595         "invalid": _("“%(value)s” value must be a decimal number."),
1596     }
1597     description = _("Decimal number")
1598 
1599     def __init__(
1600         self,
1601         verbose_name=None,
1602         name=None,
1603         max_digits=None,
1604         decimal_places=None,
1605         **kwargs,
1606     ):
1607         self.max_digits, self.decimal_places = max_digits, decimal_places
1608         super().__init__(verbose_name, name, **kwargs)
1609 
1610     def check(self, **kwargs):
1611         errors = super().check(**kwargs)
1612 
1613         digits_errors = [
1614             *self._check_decimal_places(),
1615             *self._check_max_digits(),
1616         ]
1617         if not digits_errors:
1618             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))
1619         else:
1620             errors.extend(digits_errors)
1621         return errors
1622 
1623     def _check_decimal_places(self):
1624         try:
1625             decimal_places = int(self.decimal_places)
1626             if decimal_places < 0:
1627                 raise ValueError()
1628         except TypeError:
1629             return [
1630                 checks.Error(
1631                     "DecimalFields must define a 'decimal_places' attribute.",
1632                     obj=self,
1633                     id="fields.E130",
1634                 )
1635             ]
1636         except ValueError:
1637             return [
1638                 checks.Error(
1639                     "'decimal_places' must be a non-negative integer.",
1640                     obj=self,
1641                     id="fields.E131",
1642                 )
1643             ]
1644         else:
1645             return []
1646 
1647     def _check_max_digits(self):
1648         try:
1649             max_digits = int(self.max_digits)
1650             if max_digits <= 0:
1651                 raise ValueError()
1652         except TypeError:
1653             return [
1654                 checks.Error(
1655                     "DecimalFields must define a 'max_digits' attribute.",
1656                     obj=self,
1657                     id="fields.E132",
1658                 )
1659             ]
1660         except ValueError:
1661             return [
1662                 checks.Error(
1663                     "'max_digits' must be a positive integer.",
1664                     obj=self,
1665                     id="fields.E133",
1666                 )
1667             ]
1668         else:
1669             return []
1670 
1671     def _check_decimal_places_and_max_digits(self, **kwargs):
1672         if int(self.decimal_places) > int(self.max_digits):
1673             return [
1674                 checks.Error(
1675                     "'max_digits' must be greater or equal to 'decimal_places'.",
1676                     obj=self,
1677                     id="fields.E134",
1678                 )
1679             ]
1680         return []
1681 
1682     @cached_property
1683     def validators(self):
1684         return super().validators + [
1685             validators.DecimalValidator(self.max_digits, self.decimal_places)
1686         ]
1687 
1688     @cached_property
1689     def context(self):
1690         return decimal.Context(prec=self.max_digits)
1691 
1692     def deconstruct(self):
1693         name, path, args, kwargs = super().deconstruct()
1694         if self.max_digits is not None:
1695             kwargs["max_digits"] = self.max_digits
1696         if self.decimal_places is not None:
1697             kwargs["decimal_places"] = self.decimal_places
1698         return name, path, args, kwargs
1699 
1700     def get_internal_type(self):
1701         return "DecimalField"
1702 
1703     def to_python(self, value):
1704         if value is None:
1705             return value
1706         if isinstance(value, float):
1707             if math.isnan(value):
1708                 raise exceptions.ValidationError(
1709                     self.error_messages["invalid"],
1710                     code="invalid",
1711                     params={"value": value},
1712                 )
1713             return self.context.create_decimal_from_float(value)
1714         try:
1715             return decimal.Decimal(value)
1716         except (decimal.InvalidOperation, TypeError, ValueError):
1717             raise exceptions.ValidationError(
1718                 self.error_messages["invalid"],
1719                 code="invalid",
1720                 params={"value": value},
1721             )
1722 
1723     def get_db_prep_save(self, value, connection):
1724         return connection.ops.adapt_decimalfield_value(
1725             self.to_python(value), self.max_digits, self.decimal_places
1726         )
1727 
1728     def get_prep_value(self, value):
1729         value = super().get_prep_value(value)
1730         return self.to_python(value)
1731 
1732     def formfield(self, **kwargs):
1733         return super().formfield(
1734             **{
1735                 "max_digits": self.max_digits,
1736                 "decimal_places": self.decimal_places,
1737                 "form_class": forms.DecimalField,
1738                 **kwargs,
1739             }
1740         )
1741 
1742 
1743 class DurationField(Field):
1744     """
1745     Store timedelta objects.
1746 
1747     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint
1748     of microseconds on other databases.
1749     """
1750 
1751     empty_strings_allowed = False
1752     default_error_messages = {
1753         "invalid": _(
1754             "“%(value)s” value has an invalid format. It must be in "
1755             "[DD] [[HH:]MM:]ss[.uuuuuu] format."
1756         )
1757     }
1758     description = _("Duration")
1759 
1760     def get_internal_type(self):
1761         return "DurationField"
1762 
1763     def to_python(self, value):
1764         if value is None:
1765             return value
1766         if isinstance(value, datetime.timedelta):
1767             return value
1768         try:
1769             parsed = parse_duration(value)
1770         except ValueError:
1771             pass
1772         else:
1773             if parsed is not None:
1774                 return parsed
1775 
1776         raise exceptions.ValidationError(
1777             self.error_messages["invalid"],
1778             code="invalid",
1779             params={"value": value},
1780         )
1781 
1782     def get_db_prep_value(self, value, connection, prepared=False):
1783         if connection.features.has_native_duration_field:
1784             return value
1785         if value is None:
1786             return None
1787         return duration_microseconds(value)
1788 
1789     def get_db_converters(self, connection):
1790         converters = []
1791         if not connection.features.has_native_duration_field:
1792             converters.append(connection.ops.convert_durationfield_value)
1793         return converters + super().get_db_converters(connection)
1794 
1795     def value_to_string(self, obj):
1796         val = self.value_from_object(obj)
1797         return "" if val is None else duration_string(val)
1798 
1799     def formfield(self, **kwargs):
1800         return super().formfield(
1801             **{
1802                 "form_class": forms.DurationField,
1803                 **kwargs,
1804             }
1805         )
1806 
1807 
1808 class EmailField(CharField):
1809     default_validators = [validators.validate_email]
1810     description = _("Email address")
1811 
1812     def __init__(self, *args, **kwargs):
1813         # max_length=254 to be compliant with RFCs 3696 and 5321
1814         kwargs.setdefault("max_length", 254)
1815         super().__init__(*args, **kwargs)
1816 
1817     def deconstruct(self):
1818         name, path, args, kwargs = super().deconstruct()
1819         # We do not exclude max_length if it matches default as we want to change
1820         # the default in future.
1821         return name, path, args, kwargs
1822 
1823     def formfield(self, **kwargs):
1824         # As with CharField, this will cause email validation to be performed
1825         # twice.
1826         return super().formfield(
1827             **{
1828                 "form_class": forms.EmailField,
1829                 **kwargs,
1830             }
1831         )
1832 
1833 
1834 class FilePathField(Field):
1835     description = _("File path")
1836 
1837     def __init__(
1838         self,
1839         verbose_name=None,
1840         name=None,
1841         path="",
1842         match=None,
1843         recursive=False,
1844         allow_files=True,
1845         allow_folders=False,
1846         **kwargs,
1847     ):
1848         self.path, self.match, self.recursive = path, match, recursive
1849         self.allow_files, self.allow_folders = allow_files, allow_folders
1850         kwargs.setdefault("max_length", 100)
1851         super().__init__(verbose_name, name, **kwargs)
1852 
1853     def check(self, **kwargs):
1854         return [
1855             *super().check(**kwargs),
1856             *self._check_allowing_files_or_folders(**kwargs),
1857         ]
1858 
1859     def _check_allowing_files_or_folders(self, **kwargs):
1860         if not self.allow_files and not self.allow_folders:
1861             return [
1862                 checks.Error(
1863                     "FilePathFields must have either 'allow_files' or 'allow_folders' "
1864                     "set to True.",
1865                     obj=self,
1866                     id="fields.E140",
1867                 )
1868             ]
1869         return []
1870 
1871     def deconstruct(self):
1872         name, path, args, kwargs = super().deconstruct()
1873         if self.path != "":
1874             kwargs["path"] = self.path
1875         if self.match is not None:
1876             kwargs["match"] = self.match
1877         if self.recursive is not False:
1878             kwargs["recursive"] = self.recursive
1879         if self.allow_files is not True:
1880             kwargs["allow_files"] = self.allow_files
1881         if self.allow_folders is not False:
1882             kwargs["allow_folders"] = self.allow_folders
1883         if kwargs.get("max_length") == 100:
1884             del kwargs["max_length"]
1885         return name, path, args, kwargs
1886 
1887     def get_prep_value(self, value):
1888         value = super().get_prep_value(value)
1889         if value is None:
1890             return None
1891         return str(value)
1892 
1893     def formfield(self, **kwargs):
1894         return super().formfield(
1895             **{
1896                 "path": self.path() if callable(self.path) else self.path,
1897                 "match": self.match,
1898                 "recursive": self.recursive,
1899                 "form_class": forms.FilePathField,
1900                 "allow_files": self.allow_files,
1901                 "allow_folders": self.allow_folders,
1902                 **kwargs,
1903             }
1904         )
1905 
1906     def get_internal_type(self):
1907         return "FilePathField"
1908 
1909 
1910 class FloatField(Field):
1911     empty_strings_allowed = False
1912     default_error_messages = {
1913         "invalid": _("“%(value)s” value must be a float."),
1914     }
1915     description = _("Floating point number")
1916 
1917     def get_prep_value(self, value):
1918         value = super().get_prep_value(value)
1919         if value is None:
1920             return None
1921         try:
1922             return float(value)
1923         except (TypeError, ValueError) as e:
1924             raise e.__class__(
1925                 "Field '%s' expected a number but got %r." % (self.name, value),
1926             ) from e
1927 
1928     def get_internal_type(self):
1929         return "FloatField"
1930 
1931     def to_python(self, value):
1932         if value is None:
1933             return value
1934         try:
1935             return float(value)
1936         except (TypeError, ValueError):
1937             raise exceptions.ValidationError(
1938                 self.error_messages["invalid"],
1939                 code="invalid",
1940                 params={"value": value},
1941             )
1942 
1943     def formfield(self, **kwargs):
1944         return super().formfield(
1945             **{
1946                 "form_class": forms.FloatField,
1947                 **kwargs,
1948             }
1949         )
1950 
1951 
1952 class IntegerField(Field):
1953     empty_strings_allowed = False
1954     default_error_messages = {
1955         "invalid": _("“%(value)s” value must be an integer."),
1956     }
1957     description = _("Integer")
1958 
1959     def check(self, **kwargs):
1960         return [
1961             *super().check(**kwargs),
1962             *self._check_max_length_warning(),
1963         ]
1964 
1965     def _check_max_length_warning(self):
1966         if self.max_length is not None:
1967             return [
1968                 checks.Warning(
1969                     "'max_length' is ignored when used with %s."
1970                     % self.__class__.__name__,
1971                     hint="Remove 'max_length' from field",
1972                     obj=self,
1973                     id="fields.W122",
1974                 )
1975             ]
1976         return []
1977 
1978     @cached_property
1979     def validators(self):
1980         # These validators can't be added at field initialization time since
1981         # they're based on values retrieved from `connection`.
1982         validators_ = super().validators
1983         internal_type = self.get_internal_type()
1984         min_value, max_value = connection.ops.integer_field_range(internal_type)
1985         if min_value is not None and not any(
1986             (
1987                 isinstance(validator, validators.MinValueValidator)
1988                 and (
1989                     validator.limit_value()
1990                     if callable(validator.limit_value)
1991                     else validator.limit_value
1992                 )
1993                 >= min_value
1994             )
1995             for validator in validators_
1996         ):
1997             validators_.append(validators.MinValueValidator(min_value))
1998         if max_value is not None and not any(
1999             (
2000                 isinstance(validator, validators.MaxValueValidator)
2001                 and (
2002                     validator.limit_value()
2003                     if callable(validator.limit_value)
2004                     else validator.limit_value
2005                 )
2006                 <= max_value
2007             )
2008             for validator in validators_
2009         ):
2010             validators_.append(validators.MaxValueValidator(max_value))
2011         return validators_
2012 
2013     def get_prep_value(self, value):
2014         value = super().get_prep_value(value)
2015         if value is None:
2016             return None
2017         try:
2018             return int(value)
2019         except (TypeError, ValueError) as e:
2020             raise e.__class__(
2021                 "Field '%s' expected a number but got %r." % (self.name, value),
2022             ) from e
2023 
2024     def get_internal_type(self):
2025         return "IntegerField"
2026 
2027     def to_python(self, value):
2028         if value is None:
2029             return value
2030         try:
2031             return int(value)
2032         except (TypeError, ValueError):
2033             raise exceptions.ValidationError(
2034                 self.error_messages["invalid"],
2035                 code="invalid",
2036                 params={"value": value},
2037             )
2038 
2039     def formfield(self, **kwargs):
2040         return super().formfield(
2041             **{
2042                 "form_class": forms.IntegerField,
2043                 **kwargs,
2044             }
2045         )
2046 
2047 
2048 class BigIntegerField(IntegerField):
2049     description = _("Big (8 byte) integer")
2050     MAX_BIGINT = 9223372036854775807
2051 
2052     def get_internal_type(self):
2053         return "BigIntegerField"
2054 
2055     def formfield(self, **kwargs):
2056         return super().formfield(
2057             **{
2058                 "min_value": -BigIntegerField.MAX_BIGINT - 1,
2059                 "max_value": BigIntegerField.MAX_BIGINT,
2060                 **kwargs,
2061             }
2062         )
2063 
2064 
2065 class SmallIntegerField(IntegerField):
2066     description = _("Small integer")
2067 
2068     def get_internal_type(self):
2069         return "SmallIntegerField"
2070 
2071 
2072 class IPAddressField(Field):
2073     empty_strings_allowed = False
2074     description = _("IPv4 address")
2075     system_check_removed_details = {
2076         "msg": (
2077             "IPAddressField has been removed except for support in "
2078             "historical migrations."
2079         ),
2080         "hint": "Use GenericIPAddressField instead.",
2081         "id": "fields.E900",
2082     }
2083 
2084     def __init__(self, *args, **kwargs):
2085         kwargs["max_length"] = 15
2086         super().__init__(*args, **kwargs)
2087 
2088     def deconstruct(self):
2089         name, path, args, kwargs = super().deconstruct()
2090         del kwargs["max_length"]
2091         return name, path, args, kwargs
2092 
2093     def get_prep_value(self, value):
2094         value = super().get_prep_value(value)
2095         if value is None:
2096             return None
2097         return str(value)
2098 
2099     def get_internal_type(self):
2100         return "IPAddressField"
2101 
2102 
2103 class GenericIPAddressField(Field):
2104     empty_strings_allowed = False
2105     description = _("IP address")
2106     default_error_messages = {}
2107 
2108     def __init__(
2109         self,
2110         verbose_name=None,
2111         name=None,
2112         protocol="both",
2113         unpack_ipv4=False,
2114         *args,
2115         **kwargs,
2116     ):
2117         self.unpack_ipv4 = unpack_ipv4
2118         self.protocol = protocol
2119         (
2120             self.default_validators,
2121             invalid_error_message,
2122         ) = validators.ip_address_validators(protocol, unpack_ipv4)
2123         self.default_error_messages["invalid"] = invalid_error_message
2124         kwargs["max_length"] = 39
2125         super().__init__(verbose_name, name, *args, **kwargs)
2126 
2127     def check(self, **kwargs):
2128         return [
2129             *super().check(**kwargs),
2130             *self._check_blank_and_null_values(**kwargs),
2131         ]
2132 
2133     def _check_blank_and_null_values(self, **kwargs):
2134         if not getattr(self, "null", False) and getattr(self, "blank", False):
2135             return [
2136                 checks.Error(
2137                     "GenericIPAddressFields cannot have blank=True if null=False, "
2138                     "as blank values are stored as nulls.",
2139                     obj=self,
2140                     id="fields.E150",
2141                 )
2142             ]
2143         return []
2144 
2145     def deconstruct(self):
2146         name, path, args, kwargs = super().deconstruct()
2147         if self.unpack_ipv4 is not False:
2148             kwargs["unpack_ipv4"] = self.unpack_ipv4
2149         if self.protocol != "both":
2150             kwargs["protocol"] = self.protocol
2151         if kwargs.get("max_length") == 39:
2152             del kwargs["max_length"]
2153         return name, path, args, kwargs
2154 
2155     def get_internal_type(self):
2156         return "GenericIPAddressField"
2157 
2158     def to_python(self, value):
2159         if value is None:
2160             return None
2161         if not isinstance(value, str):
2162             value = str(value)
2163         value = value.strip()
2164         if ":" in value:
2165             return clean_ipv6_address(
2166                 value, self.unpack_ipv4, self.error_messages["invalid"]
2167             )
2168         return value
2169 
2170     def get_db_prep_value(self, value, connection, prepared=False):
2171         if not prepared:
2172             value = self.get_prep_value(value)
2173         return connection.ops.adapt_ipaddressfield_value(value)
2174 
2175     def get_prep_value(self, value):
2176         value = super().get_prep_value(value)
2177         if value is None:
2178             return None
2179         if value and ":" in value:
2180             try:
2181                 return clean_ipv6_address(value, self.unpack_ipv4)
2182             except exceptions.ValidationError:
2183                 pass
2184         return str(value)
2185 
2186     def formfield(self, **kwargs):
2187         return super().formfield(
2188             **{
2189                 "protocol": self.protocol,
2190                 "form_class": forms.GenericIPAddressField,
2191                 **kwargs,
2192             }
2193         )
2194 
2195 
2196 class NullBooleanField(BooleanField):
2197     default_error_messages = {
2198         "invalid": _("“%(value)s” value must be either None, True or False."),
2199         "invalid_nullable": _("“%(value)s” value must be either None, True or False."),
2200     }
2201     description = _("Boolean (Either True, False or None)")
2202     system_check_removed_details = {
2203         "msg": (
2204             "NullBooleanField is removed except for support in historical "
2205             "migrations."
2206         ),
2207         "hint": "Use BooleanField(null=True) instead.",
2208         "id": "fields.E903",
2209     }
2210 
2211     def __init__(self, *args, **kwargs):
2212         kwargs["null"] = True
2213         kwargs["blank"] = True
2214         super().__init__(*args, **kwargs)
2215 
2216     def deconstruct(self):
2217         name, path, args, kwargs = super().deconstruct()
2218         del kwargs["null"]
2219         del kwargs["blank"]
2220         return name, path, args, kwargs
2221 
2222 
2223 class PositiveIntegerRelDbTypeMixin:
2224     def __init_subclass__(cls, **kwargs):
2225         super().__init_subclass__(**kwargs)
2226         if not hasattr(cls, "integer_field_class"):
2227             cls.integer_field_class = next(
2228                 (
2229                     parent
2230                     for parent in cls.__mro__[1:]
2231                     if issubclass(parent, IntegerField)
2232                 ),
2233                 None,
2234             )
2235 
2236     def rel_db_type(self, connection):
2237         """
2238         Return the data type that a related field pointing to this field should
2239         use. In most cases, a foreign key pointing to a positive integer
2240         primary key will have an integer column data type but some databases
2241         (e.g. MySQL) have an unsigned integer type. In that case
2242         (related_fields_match_type=True), the primary key should return its
2243         db_type.
2244         """
2245         if connection.features.related_fields_match_type:
2246             return self.db_type(connection)
2247         else:
2248             return self.integer_field_class().db_type(connection=connection)
2249 
2250 
2251 class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, BigIntegerField):
2252     description = _("Positive big integer")
2253 
2254     def get_internal_type(self):
2255         return "PositiveBigIntegerField"
2256 
2257     def formfield(self, **kwargs):
2258         return super().formfield(
2259             **{
2260                 "min_value": 0,
2261                 **kwargs,
2262             }
2263         )
2264 
2265 
2266 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
2267     description = _("Positive integer")
2268 
2269     def get_internal_type(self):
2270         return "PositiveIntegerField"
2271 
2272     def formfield(self, **kwargs):
2273         return super().formfield(
2274             **{
2275                 "min_value": 0,
2276                 **kwargs,
2277             }
2278         )
2279 
2280 
2281 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, SmallIntegerField):
2282     description = _("Positive small integer")
2283 
2284     def get_internal_type(self):
2285         return "PositiveSmallIntegerField"
2286 
2287     def formfield(self, **kwargs):
2288         return super().formfield(
2289             **{
2290                 "min_value": 0,
2291                 **kwargs,
2292             }
2293         )
2294 
2295 
2296 class SlugField(CharField):
2297     default_validators = [validators.validate_slug]
2298     description = _("Slug (up to %(max_length)s)")
2299 
2300     def __init__(
2301         self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs
2302     ):
2303         self.allow_unicode = allow_unicode
2304         if self.allow_unicode:
2305             self.default_validators = [validators.validate_unicode_slug]
2306         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)
2307 
2308     def deconstruct(self):
2309         name, path, args, kwargs = super().deconstruct()
2310         if kwargs.get("max_length") == 50:
2311             del kwargs["max_length"]
2312         if self.db_index is False:
2313             kwargs["db_index"] = False
2314         else:
2315             del kwargs["db_index"]
2316         if self.allow_unicode is not False:
2317             kwargs["allow_unicode"] = self.allow_unicode
2318         return name, path, args, kwargs
2319 
2320     def get_internal_type(self):
2321         return "SlugField"
2322 
2323     def formfield(self, **kwargs):
2324         return super().formfield(
2325             **{
2326                 "form_class": forms.SlugField,
2327                 "allow_unicode": self.allow_unicode,
2328                 **kwargs,
2329             }
2330         )
2331 
2332 
2333 class TextField(Field):
2334     description = _("Text")
2335 
2336     def __init__(self, *args, db_collation=None, **kwargs):
2337         super().__init__(*args, **kwargs)
2338         self.db_collation = db_collation
2339 
2340     def check(self, **kwargs):
2341         databases = kwargs.get("databases") or []
2342         return [
2343             *super().check(**kwargs),
2344             *self._check_db_collation(databases),
2345         ]
2346 
2347     def _check_db_collation(self, databases):
2348         errors = []
2349         for db in databases:
2350             if not router.allow_migrate_model(db, self.model):
2351                 continue
2352             connection = connections[db]
2353             if not (
2354                 self.db_collation is None
2355                 or "supports_collation_on_textfield"
2356                 in self.model._meta.required_db_features
2357                 or connection.features.supports_collation_on_textfield
2358             ):
2359                 errors.append(
2360                     checks.Error(
2361                         "%s does not support a database collation on "
2362                         "TextFields." % connection.display_name,
2363                         obj=self,
2364                         id="fields.E190",
2365                     ),
2366                 )
2367         return errors
2368 
2369     def db_parameters(self, connection):
2370         db_params = super().db_parameters(connection)
2371         db_params["collation"] = self.db_collation
2372         return db_params
2373 
2374     def get_internal_type(self):
2375         return "TextField"
2376 
2377     def to_python(self, value):
2378         if isinstance(value, str) or value is None:
2379             return value
2380         return str(value)
2381 
2382     def get_prep_value(self, value):
2383         value = super().get_prep_value(value)
2384         return self.to_python(value)
2385 
2386     def formfield(self, **kwargs):
2387         # Passing max_length to forms.CharField means that the value's length
2388         # will be validated twice. This is considered acceptable since we want
2389         # the value in the form field (to pass into widget for example).
2390         return super().formfield(
2391             **{
2392                 "max_length": self.max_length,
2393                 **({} if self.choices is not None else {"widget": forms.Textarea}),
2394                 **kwargs,
2395             }
2396         )
2397 
2398     def deconstruct(self):
2399         name, path, args, kwargs = super().deconstruct()
2400         if self.db_collation:
2401             kwargs["db_collation"] = self.db_collation
2402         return name, path, args, kwargs
2403 
2404 
2405 class TimeField(DateTimeCheckMixin, Field):
2406     empty_strings_allowed = False
2407     default_error_messages = {
2408         "invalid": _(
2409             "“%(value)s” value has an invalid format. It must be in "
2410             "HH:MM[:ss[.uuuuuu]] format."
2411         ),
2412         "invalid_time": _(
2413             "“%(value)s” value has the correct format "
2414             "(HH:MM[:ss[.uuuuuu]]) but it is an invalid time."
2415         ),
2416     }
2417     description = _("Time")
2418 
2419     def __init__(
2420         self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs
2421     ):
2422         self.auto_now, self.auto_now_add = auto_now, auto_now_add
2423         if auto_now or auto_now_add:
2424             kwargs["editable"] = False
2425             kwargs["blank"] = True
2426         super().__init__(verbose_name, name, **kwargs)
2427 
2428     def _check_fix_default_value(self):
2429         """
2430         Warn that using an actual date or datetime value is probably wrong;
2431         it's only evaluated on server startup.
2432         """
2433         if not self.has_default():
2434             return []
2435 
2436         value = self.default
2437         if isinstance(value, datetime.datetime):
2438             now = None
2439         elif isinstance(value, datetime.time):
2440             now = _get_naive_now()
2441             # This will not use the right date in the race condition where now
2442             # is just before the date change and value is just past 0:00.
2443             value = datetime.datetime.combine(now.date(), value)
2444         else:
2445             # No explicit time / datetime value -- no checks necessary
2446             return []
2447         # At this point, value is a datetime object.
2448         return self._check_if_value_fixed(value, now=now)
2449 
2450     def deconstruct(self):
2451         name, path, args, kwargs = super().deconstruct()
2452         if self.auto_now is not False:
2453             kwargs["auto_now"] = self.auto_now
2454         if self.auto_now_add is not False:
2455             kwargs["auto_now_add"] = self.auto_now_add
2456         if self.auto_now or self.auto_now_add:
2457             del kwargs["blank"]
2458             del kwargs["editable"]
2459         return name, path, args, kwargs
2460 
2461     def get_internal_type(self):
2462         return "TimeField"
2463 
2464     def to_python(self, value):
2465         if value is None:
2466             return None
2467         if isinstance(value, datetime.time):
2468             return value
2469         if isinstance(value, datetime.datetime):
2470             # Not usually a good idea to pass in a datetime here (it loses
2471             # information), but this can be a side-effect of interacting with a
2472             # database backend (e.g. Oracle), so we'll be accommodating.
2473             return value.time()
2474 
2475         try:
2476             parsed = parse_time(value)
2477             if parsed is not None:
2478                 return parsed
2479         except ValueError:
2480             raise exceptions.ValidationError(
2481                 self.error_messages["invalid_time"],
2482                 code="invalid_time",
2483                 params={"value": value},
2484             )
2485 
2486         raise exceptions.ValidationError(
2487             self.error_messages["invalid"],
2488             code="invalid",
2489             params={"value": value},
2490         )
2491 
2492     def pre_save(self, model_instance, add):
2493         if self.auto_now or (self.auto_now_add and add):
2494             value = datetime.datetime.now().time()
2495             setattr(model_instance, self.attname, value)
2496             return value
2497         else:
2498             return super().pre_save(model_instance, add)
2499 
2500     def get_prep_value(self, value):
2501         value = super().get_prep_value(value)
2502         return self.to_python(value)
2503 
2504     def get_db_prep_value(self, value, connection, prepared=False):
2505         # Casts times into the format expected by the backend
2506         if not prepared:
2507             value = self.get_prep_value(value)
2508         return connection.ops.adapt_timefield_value(value)
2509 
2510     def value_to_string(self, obj):
2511         val = self.value_from_object(obj)
2512         return "" if val is None else val.isoformat()
2513 
2514     def formfield(self, **kwargs):
2515         return super().formfield(
2516             **{
2517                 "form_class": forms.TimeField,
2518                 **kwargs,
2519             }
2520         )
2521 
2522 
2523 class URLField(CharField):
2524     default_validators = [validators.URLValidator()]
2525     description = _("URL")
2526 
2527     def __init__(self, verbose_name=None, name=None, **kwargs):
2528         kwargs.setdefault("max_length", 200)
2529         super().__init__(verbose_name, name, **kwargs)
2530 
2531     def deconstruct(self):
2532         name, path, args, kwargs = super().deconstruct()
2533         if kwargs.get("max_length") == 200:
2534             del kwargs["max_length"]
2535         return name, path, args, kwargs
2536 
2537     def formfield(self, **kwargs):
2538         # As with CharField, this will cause URL validation to be performed
2539         # twice.
2540         return super().formfield(
2541             **{
2542                 "form_class": forms.URLField,
2543                 **kwargs,
2544             }
2545         )
2546 
2547 
2548 class BinaryField(Field):
2549     description = _("Raw binary data")
2550     empty_values = [None, b""]
2551 
2552     def __init__(self, *args, **kwargs):
2553         kwargs.setdefault("editable", False)
2554         super().__init__(*args, **kwargs)
2555         if self.max_length is not None:
2556             self.validators.append(validators.MaxLengthValidator(self.max_length))
2557 
2558     def check(self, **kwargs):
2559         return [*super().check(**kwargs), *self._check_str_default_value()]
2560 
2561     def _check_str_default_value(self):
2562         if self.has_default() and isinstance(self.default, str):
2563             return [
2564                 checks.Error(
2565                     "BinaryField's default cannot be a string. Use bytes "
2566                     "content instead.",
2567                     obj=self,
2568                     id="fields.E170",
2569                 )
2570             ]
2571         return []
2572 
2573     def deconstruct(self):
2574         name, path, args, kwargs = super().deconstruct()
2575         if self.editable:
2576             kwargs["editable"] = True
2577         else:
2578             del kwargs["editable"]
2579         return name, path, args, kwargs
2580 
2581     def get_internal_type(self):
2582         return "BinaryField"
2583 
2584     def get_placeholder(self, value, compiler, connection):
2585         return connection.ops.binary_placeholder_sql(value)
2586 
2587     def get_default(self):
2588         if self.has_default() and not callable(self.default):
2589             return self.default
2590         default = super().get_default()
2591         if default == "":
2592             return b""
2593         return default
2594 
2595     def get_db_prep_value(self, value, connection, prepared=False):
2596         value = super().get_db_prep_value(value, connection, prepared)
2597         if value is not None:
2598             return connection.Database.Binary(value)
2599         return value
2600 
2601     def value_to_string(self, obj):
2602         """Binary data is serialized as base64"""
2603         return b64encode(self.value_from_object(obj)).decode("ascii")
2604 
2605     def to_python(self, value):
2606         # If it's a string, it should be base64-encoded data
2607         if isinstance(value, str):
2608             return memoryview(b64decode(value.encode("ascii")))
2609         return value
2610 
2611 
2612 class UUIDField(Field):
2613     default_error_messages = {
2614         "invalid": _("“%(value)s” is not a valid UUID."),
2615     }
2616     description = _("Universally unique identifier")
2617     empty_strings_allowed = False
2618 
2619     def __init__(self, verbose_name=None, **kwargs):
2620         kwargs["max_length"] = 32
2621         super().__init__(verbose_name, **kwargs)
2622 
2623     def deconstruct(self):
2624         name, path, args, kwargs = super().deconstruct()
2625         del kwargs["max_length"]
2626         return name, path, args, kwargs
2627 
2628     def get_internal_type(self):
2629         return "UUIDField"
2630 
2631     def get_prep_value(self, value):
2632         value = super().get_prep_value(value)
2633         return self.to_python(value)
2634 
2635     def get_db_prep_value(self, value, connection, prepared=False):
2636         if value is None:
2637             return None
2638         if not isinstance(value, uuid.UUID):
2639             value = self.to_python(value)
2640 
2641         if connection.features.has_native_uuid_field:
2642             return value
2643         return value.hex
2644 
2645     def to_python(self, value):
2646         if value is not None and not isinstance(value, uuid.UUID):
2647             input_form = "int" if isinstance(value, int) else "hex"
2648             try:
2649                 return uuid.UUID(**{input_form: value})
2650             except (AttributeError, ValueError):
2651                 raise exceptions.ValidationError(
2652                     self.error_messages["invalid"],
2653                     code="invalid",
2654                     params={"value": value},
2655                 )
2656         return value
2657 
2658     def formfield(self, **kwargs):
2659         return super().formfield(
2660             **{
2661                 "form_class": forms.UUIDField,
2662                 **kwargs,
2663             }
2664         )
2665 
2666 
2667 class AutoFieldMixin:
2668     db_returning = True
2669 
2670     def __init__(self, *args, **kwargs):
2671         kwargs["blank"] = True
2672         super().__init__(*args, **kwargs)
2673 
2674     def check(self, **kwargs):
2675         return [
2676             *super().check(**kwargs),
2677             *self._check_primary_key(),
2678         ]
2679 
2680     def _check_primary_key(self):
2681         if not self.primary_key:
2682             return [
2683                 checks.Error(
2684                     "AutoFields must set primary_key=True.",
2685                     obj=self,
2686                     id="fields.E100",
2687                 ),
2688             ]
2689         else:
2690             return []
2691 
2692     def deconstruct(self):
2693         name, path, args, kwargs = super().deconstruct()
2694         del kwargs["blank"]
2695         kwargs["primary_key"] = True
2696         return name, path, args, kwargs
2697 
2698     def validate(self, value, model_instance):
2699         pass
2700 
2701     def get_db_prep_value(self, value, connection, prepared=False):
2702         if not prepared:
2703             value = self.get_prep_value(value)
2704             value = connection.ops.validate_autopk_value(value)
2705         return value
2706 
2707     def contribute_to_class(self, cls, name, **kwargs):
2708         if cls._meta.auto_field:
2709             raise ValueError(
2710                 "Model %s can't have more than one auto-generated field."
2711                 % cls._meta.label
2712             )
2713         super().contribute_to_class(cls, name, **kwargs)
2714         cls._meta.auto_field = self
2715 
2716     def formfield(self, **kwargs):
2717         return None
2718 
2719 
2720 class AutoFieldMeta(type):
2721     """
2722     Metaclass to maintain backward inheritance compatibility for AutoField.
2723 
2724     It is intended that AutoFieldMixin become public API when it is possible to
2725     create a non-integer automatically-generated field using column defaults
2726     stored in the database.
2727 
2728     In many areas Django also relies on using isinstance() to check for an
2729     automatically-generated field as a subclass of AutoField. A new flag needs
2730     to be implemented on Field to be used instead.
2731 
2732     When these issues have been addressed, this metaclass could be used to
2733     deprecate inheritance from AutoField and use of isinstance() with AutoField
2734     for detecting automatically-generated fields.
2735     """
2736 
2737     @property
2738     def _subclasses(self):
2739         return (BigAutoField, SmallAutoField)
2740 
2741     def __instancecheck__(self, instance):
2742         return isinstance(instance, self._subclasses) or super().__instancecheck__(
2743             instance
2744         )
2745 
2746     def __subclasscheck__(self, subclass):
2747         return issubclass(subclass, self._subclasses) or super().__subclasscheck__(
2748             subclass
2749         )
2750 
2751 
2752 class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):
2753     def get_internal_type(self):
2754         return "AutoField"
2755 
2756     def rel_db_type(self, connection):
2757         return IntegerField().db_type(connection=connection)
2758 
2759 
2760 class BigAutoField(AutoFieldMixin, BigIntegerField):
2761     def get_internal_type(self):
2762         return "BigAutoField"
2763 
2764     def rel_db_type(self, connection):
2765         return BigIntegerField().db_type(connection=connection)
2766 
2767 
2768 class SmallAutoField(AutoFieldMixin, SmallIntegerField):
2769     def get_internal_type(self):
2770         return "SmallAutoField"
2771 
2772     def rel_db_type(self, connection):
2773         return SmallIntegerField().db_type(connection=connection)

</code><intended_behavior>This file should include logic that not only allows for 'db_collation' to be defined at the field level but also ensures that when such fields are used as primary keys, any foreign keys referencing them in other models inherit or respect this collation setting during migration generation. The current implementation likely allows 'db_collation' to be specified, but may not ensure it is consistently applied across related foreign key references in migrations. The code fix should address this propagation issue without disrupting the existing functionality for non-related fields.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name = related_name % {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_filter = (
411             (rh_field.attname, getattr(obj, lh_field.attname))
412             for lh_field, rh_field in self.related_fields
413         )
414         descriptor_filter = self.get_extra_descriptor_filter(obj)
415         base_q = Q(*base_filter)
416         if isinstance(descriptor_filter, dict):
417             return base_q & Q(**descriptor_filter)
418         elif descriptor_filter:
419             return base_q & descriptor_filter
420         return base_q
421 
422     @property
423     def swappable_setting(self):
424         """
425         Get the setting that this is powered from for swapping, or None
426         if it's not swapped in / marked with swappable=False.
427         """
428         if self.swappable:
429             # Work out string form of "to"
430             if isinstance(self.remote_field.model, str):
431                 to_string = self.remote_field.model
432             else:
433                 to_string = self.remote_field.model._meta.label
434             return apps.get_swappable_settings_name(to_string)
435         return None
436 
437     def set_attributes_from_rel(self):
438         self.name = self.name or (
439             self.remote_field.model._meta.model_name
440             + "_"
441             + self.remote_field.model._meta.pk.name
442         )
443         if self.verbose_name is None:
444             self.verbose_name = self.remote_field.model._meta.verbose_name
445         self.remote_field.set_field_name()
446 
447     def do_related_class(self, other, cls):
448         self.set_attributes_from_rel()
449         self.contribute_to_related_class(other, self.remote_field)
450 
451     def get_limit_choices_to(self):
452         """
453         Return ``limit_choices_to`` for this model field.
454 
455         If it is a callable, it will be invoked and the result will be
456         returned.
457         """
458         if callable(self.remote_field.limit_choices_to):
459             return self.remote_field.limit_choices_to()
460         return self.remote_field.limit_choices_to
461 
462     def formfield(self, **kwargs):
463         """
464         Pass ``limit_choices_to`` to the field being constructed.
465 
466         Only passes it if there is a type that supports related fields.
467         This is a similar strategy used to pass the ``queryset`` to the field
468         being constructed.
469         """
470         defaults = {}
471         if hasattr(self.remote_field, "get_related_field"):
472             # If this is a callable, do not invoke it here. Just pass
473             # it in the defaults for when the form class will later be
474             # instantiated.
475             limit_choices_to = self.remote_field.limit_choices_to
476             defaults.update(
477                 {
478                     "limit_choices_to": limit_choices_to,
479                 }
480             )
481         defaults.update(kwargs)
482         return super().formfield(**defaults)
483 
484     def related_query_name(self):
485         """
486         Define the name that can be used to identify this related object in a
487         table-spanning query.
488         """
489         return (
490             self.remote_field.related_query_name
491             or self.remote_field.related_name
492             or self.opts.model_name
493         )
494 
495     @property
496     def target_field(self):
497         """
498         When filtering against this relation, return the field on the remote
499         model against which the filtering should happen.
500         """
501         target_fields = self.path_infos[-1].target_fields
502         if len(target_fields) > 1:
503             raise exceptions.FieldError(
504                 "The relation has multiple target fields, but only single target field "
505                 "was asked for"
506             )
507         return target_fields[0]
508 
509     def get_cache_name(self):
510         return self.name
511 
512 
513 class ForeignObject(RelatedField):
514     """
515     Abstraction of the ForeignKey relation to support multi-column relations.
516     """
517 
518     # Field flags
519     many_to_many = False
520     many_to_one = True
521     one_to_many = False
522     one_to_one = False
523 
524     requires_unique_target = True
525     related_accessor_class = ReverseManyToOneDescriptor
526     forward_related_accessor_class = ForwardManyToOneDescriptor
527     rel_class = ForeignObjectRel
528 
529     def __init__(
530         self,
531         to,
532         on_delete,
533         from_fields,
534         to_fields,
535         rel=None,
536         related_name=None,
537         related_query_name=None,
538         limit_choices_to=None,
539         parent_link=False,
540         swappable=True,
541         **kwargs,
542     ):
543 
544         if rel is None:
545             rel = self.rel_class(
546                 self,
547                 to,
548                 related_name=related_name,
549                 related_query_name=related_query_name,
550                 limit_choices_to=limit_choices_to,
551                 parent_link=parent_link,
552                 on_delete=on_delete,
553             )
554 
555         super().__init__(
556             rel=rel,
557             related_name=related_name,
558             related_query_name=related_query_name,
559             limit_choices_to=limit_choices_to,
560             **kwargs,
561         )
562 
563         self.from_fields = from_fields
564         self.to_fields = to_fields
565         self.swappable = swappable
566 
567     def __copy__(self):
568         obj = super().__copy__()
569         # Remove any cached PathInfo values.
570         obj.__dict__.pop("path_infos", None)
571         obj.__dict__.pop("reverse_path_infos", None)
572         return obj
573 
574     def check(self, **kwargs):
575         return [
576             *super().check(**kwargs),
577             *self._check_to_fields_exist(),
578             *self._check_unique_target(),
579         ]
580 
581     def _check_to_fields_exist(self):
582         # Skip nonexistent models.
583         if isinstance(self.remote_field.model, str):
584             return []
585 
586         errors = []
587         for to_field in self.to_fields:
588             if to_field:
589                 try:
590                     self.remote_field.model._meta.get_field(to_field)
591                 except exceptions.FieldDoesNotExist:
592                     errors.append(
593                         checks.Error(
594                             "The to_field '%s' doesn't exist on the related "
595                             "model '%s'."
596                             % (to_field, self.remote_field.model._meta.label),
597                             obj=self,
598                             id="fields.E312",
599                         )
600                     )
601         return errors
602 
603     def _check_unique_target(self):
604         rel_is_string = isinstance(self.remote_field.model, str)
605         if rel_is_string or not self.requires_unique_target:
606             return []
607 
608         try:
609             self.foreign_related_fields
610         except exceptions.FieldDoesNotExist:
611             return []
612 
613         if not self.foreign_related_fields:
614             return []
615 
616         unique_foreign_fields = {
617             frozenset([f.name])
618             for f in self.remote_field.model._meta.get_fields()
619             if getattr(f, "unique", False)
620         }
621         unique_foreign_fields.update(
622             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
623         )
624         unique_foreign_fields.update(
625             {
626                 frozenset(uc.fields)
627                 for uc in self.remote_field.model._meta.total_unique_constraints
628             }
629         )
630         foreign_fields = {f.name for f in self.foreign_related_fields}
631         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
632 
633         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
634             field_combination = ", ".join(
635                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
636             )
637             model_name = self.remote_field.model.__name__
638             return [
639                 checks.Error(
640                     "No subset of the fields %s on model '%s' is unique."
641                     % (field_combination, model_name),
642                     hint=(
643                         "Mark a single field as unique=True or add a set of "
644                         "fields to a unique constraint (via unique_together "
645                         "or a UniqueConstraint (without condition) in the "
646                         "model Meta.constraints)."
647                     ),
648                     obj=self,
649                     id="fields.E310",
650                 )
651             ]
652         elif not has_unique_constraint:
653             field_name = self.foreign_related_fields[0].name
654             model_name = self.remote_field.model.__name__
655             return [
656                 checks.Error(
657                     "'%s.%s' must be unique because it is referenced by "
658                     "a foreign key." % (model_name, field_name),
659                     hint=(
660                         "Add unique=True to this field or add a "
661                         "UniqueConstraint (without condition) in the model "
662                         "Meta.constraints."
663                     ),
664                     obj=self,
665                     id="fields.E311",
666                 )
667             ]
668         else:
669             return []
670 
671     def deconstruct(self):
672         name, path, args, kwargs = super().deconstruct()
673         kwargs["on_delete"] = self.remote_field.on_delete
674         kwargs["from_fields"] = self.from_fields
675         kwargs["to_fields"] = self.to_fields
676 
677         if self.remote_field.parent_link:
678             kwargs["parent_link"] = self.remote_field.parent_link
679         if isinstance(self.remote_field.model, str):
680             if "." in self.remote_field.model:
681                 app_label, model_name = self.remote_field.model.split(".")
682                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
683             else:
684                 kwargs["to"] = self.remote_field.model.lower()
685         else:
686             kwargs["to"] = self.remote_field.model._meta.label_lower
687         # If swappable is True, then see if we're actually pointing to the target
688         # of a swap.
689         swappable_setting = self.swappable_setting
690         if swappable_setting is not None:
691             # If it's already a settings reference, error
692             if hasattr(kwargs["to"], "setting_name"):
693                 if kwargs["to"].setting_name != swappable_setting:
694                     raise ValueError(
695                         "Cannot deconstruct a ForeignKey pointing to a model "
696                         "that is swapped in place of more than one model (%s and %s)"
697                         % (kwargs["to"].setting_name, swappable_setting)
698                     )
699             # Set it
700             kwargs["to"] = SettingsReference(
701                 kwargs["to"],
702                 swappable_setting,
703             )
704         return name, path, args, kwargs
705 
706     def resolve_related_fields(self):
707         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
708             raise ValueError(
709                 "Foreign Object from and to fields must be the same non-zero length"
710             )
711         if isinstance(self.remote_field.model, str):
712             raise ValueError(
713                 "Related model %r cannot be resolved" % self.remote_field.model
714             )
715         related_fields = []
716         for index in range(len(self.from_fields)):
717             from_field_name = self.from_fields[index]
718             to_field_name = self.to_fields[index]
719             from_field = (
720                 self
721                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
722                 else self.opts.get_field(from_field_name)
723             )
724             to_field = (
725                 self.remote_field.model._meta.pk
726                 if to_field_name is None
727                 else self.remote_field.model._meta.get_field(to_field_name)
728             )
729             related_fields.append((from_field, to_field))
730         return related_fields
731 
732     @cached_property
733     def related_fields(self):
734         return self.resolve_related_fields()
735 
736     @cached_property
737     def reverse_related_fields(self):
738         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
739 
740     @cached_property
741     def local_related_fields(self):
742         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
743 
744     @cached_property
745     def foreign_related_fields(self):
746         return tuple(
747             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
748         )
749 
750     def get_local_related_value(self, instance):
751         return self.get_instance_value_for_fields(instance, self.local_related_fields)
752 
753     def get_foreign_related_value(self, instance):
754         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
755 
756     @staticmethod
757     def get_instance_value_for_fields(instance, fields):
758         ret = []
759         opts = instance._meta
760         for field in fields:
761             # Gotcha: in some cases (like fixture loading) a model can have
762             # different values in parent_ptr_id and parent's id. So, use
763             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
764             if field.primary_key:
765                 possible_parent_link = opts.get_ancestor_link(field.model)
766                 if (
767                     not possible_parent_link
768                     or possible_parent_link.primary_key
769                     or possible_parent_link.model._meta.abstract
770                 ):
771                     ret.append(instance.pk)
772                     continue
773             ret.append(getattr(instance, field.attname))
774         return tuple(ret)
775 
776     def get_attname_column(self):
777         attname, column = super().get_attname_column()
778         return attname, None
779 
780     def get_joining_columns(self, reverse_join=False):
781         source = self.reverse_related_fields if reverse_join else self.related_fields
782         return tuple(
783             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
784         )
785 
786     def get_reverse_joining_columns(self):
787         return self.get_joining_columns(reverse_join=True)
788 
789     def get_extra_descriptor_filter(self, instance):
790         """
791         Return an extra filter condition for related object fetching when
792         user does 'instance.fieldname', that is the extra filter is used in
793         the descriptor of the field.
794 
795         The filter should be either a dict usable in .filter(**kwargs) call or
796         a Q-object. The condition will be ANDed together with the relation's
797         joining columns.
798 
799         A parallel method is get_extra_restriction() which is used in
800         JOIN and subquery conditions.
801         """
802         return {}
803 
804     def get_extra_restriction(self, alias, related_alias):
805         """
806         Return a pair condition used for joining and subquery pushdown. The
807         condition is something that responds to as_sql(compiler, connection)
808         method.
809 
810         Note that currently referring both the 'alias' and 'related_alias'
811         will not work in some conditions, like subquery pushdown.
812 
813         A parallel method is get_extra_descriptor_filter() which is used in
814         instance.fieldname related object fetching.
815         """
816         return None
817 
818     def get_path_info(self, filtered_relation=None):
819         """Get path from this field to the related model."""
820         opts = self.remote_field.model._meta
821         from_opts = self.model._meta
822         return [
823             PathInfo(
824                 from_opts=from_opts,
825                 to_opts=opts,
826                 target_fields=self.foreign_related_fields,
827                 join_field=self,
828                 m2m=False,
829                 direct=True,
830                 filtered_relation=filtered_relation,
831             )
832         ]
833 
834     @cached_property
835     def path_infos(self):
836         return self.get_path_info()
837 
838     def get_reverse_path_info(self, filtered_relation=None):
839         """Get path from the related model to this field's model."""
840         opts = self.model._meta
841         from_opts = self.remote_field.model._meta
842         return [
843             PathInfo(
844                 from_opts=from_opts,
845                 to_opts=opts,
846                 target_fields=(opts.pk,),
847                 join_field=self.remote_field,
848                 m2m=not self.unique,
849                 direct=False,
850                 filtered_relation=filtered_relation,
851             )
852         ]
853 
854     @cached_property
855     def reverse_path_infos(self):
856         return self.get_reverse_path_info()
857 
858     @classmethod
859     @functools.lru_cache(maxsize=None)
860     def get_lookups(cls):
861         bases = inspect.getmro(cls)
862         bases = bases[: bases.index(ForeignObject) + 1]
863         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
864         return cls.merge_dicts(class_lookups)
865 
866     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
867         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
868         setattr(cls, self.name, self.forward_related_accessor_class(self))
869 
870     def contribute_to_related_class(self, cls, related):
871         # Internal FK's - i.e., those with a related name ending with '+' -
872         # and swapped models don't get a related descriptor.
873         if (
874             not self.remote_field.is_hidden()
875             and not related.related_model._meta.swapped
876         ):
877             setattr(
878                 cls._meta.concrete_model,
879                 related.get_accessor_name(),
880                 self.related_accessor_class(related),
881             )
882             # While 'limit_choices_to' might be a callable, simply pass
883             # it along for later - this is too early because it's still
884             # model load time.
885             if self.remote_field.limit_choices_to:
886                 cls._meta.related_fkey_lookups.append(
887                     self.remote_field.limit_choices_to
888                 )
889 
890 
891 ForeignObject.register_lookup(RelatedIn)
892 ForeignObject.register_lookup(RelatedExact)
893 ForeignObject.register_lookup(RelatedLessThan)
894 ForeignObject.register_lookup(RelatedGreaterThan)
895 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
896 ForeignObject.register_lookup(RelatedLessThanOrEqual)
897 ForeignObject.register_lookup(RelatedIsNull)
898 
899 
900 class ForeignKey(ForeignObject):
901     """
902     Provide a many-to-one relation by adding a column to the local model
903     to hold the remote value.
904 
905     By default ForeignKey will target the pk of the remote model but this
906     behavior can be changed by using the ``to_field`` argument.
907     """
908 
909     descriptor_class = ForeignKeyDeferredAttribute
910     # Field flags
911     many_to_many = False
912     many_to_one = True
913     one_to_many = False
914     one_to_one = False
915 
916     rel_class = ManyToOneRel
917 
918     empty_strings_allowed = False
919     default_error_messages = {
920         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
921     }
922     description = _("Foreign Key (type determined by related field)")
923 
924     def __init__(
925         self,
926         to,
927         on_delete,
928         related_name=None,
929         related_query_name=None,
930         limit_choices_to=None,
931         parent_link=False,
932         to_field=None,
933         db_constraint=True,
934         **kwargs,
935     ):
936         try:
937             to._meta.model_name
938         except AttributeError:
939             if not isinstance(to, str):
940                 raise TypeError(
941                     "%s(%r) is invalid. First parameter to ForeignKey must be "
942                     "either a model, a model name, or the string %r"
943                     % (
944                         self.__class__.__name__,
945                         to,
946                         RECURSIVE_RELATIONSHIP_CONSTANT,
947                     )
948                 )
949         else:
950             # For backwards compatibility purposes, we need to *try* and set
951             # the to_field during FK construction. It won't be guaranteed to
952             # be correct until contribute_to_class is called. Refs #12190.
953             to_field = to_field or (to._meta.pk and to._meta.pk.name)
954         if not callable(on_delete):
955             raise TypeError("on_delete must be callable.")
956 
957         kwargs["rel"] = self.rel_class(
958             self,
959             to,
960             to_field,
961             related_name=related_name,
962             related_query_name=related_query_name,
963             limit_choices_to=limit_choices_to,
964             parent_link=parent_link,
965             on_delete=on_delete,
966         )
967         kwargs.setdefault("db_index", True)
968 
969         super().__init__(
970             to,
971             on_delete,
972             related_name=related_name,
973             related_query_name=related_query_name,
974             limit_choices_to=limit_choices_to,
975             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
976             to_fields=[to_field],
977             **kwargs,
978         )
979         self.db_constraint = db_constraint
980 
981     def __class_getitem__(cls, *args, **kwargs):
982         return cls
983 
984     def check(self, **kwargs):
985         return [
986             *super().check(**kwargs),
987             *self._check_on_delete(),
988             *self._check_unique(),
989         ]
990 
991     def _check_on_delete(self):
992         on_delete = getattr(self.remote_field, "on_delete", None)
993         if on_delete == SET_NULL and not self.null:
994             return [
995                 checks.Error(
996                     "Field specifies on_delete=SET_NULL, but cannot be null.",
997                     hint=(
998                         "Set null=True argument on the field, or change the on_delete "
999                         "rule."
1000                     ),
1001                     obj=self,
1002                     id="fields.E320",
1003                 )
1004             ]
1005         elif on_delete == SET_DEFAULT and not self.has_default():
1006             return [
1007                 checks.Error(
1008                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1009                     hint="Set a default value, or change the on_delete rule.",
1010                     obj=self,
1011                     id="fields.E321",
1012                 )
1013             ]
1014         else:
1015             return []
1016 
1017     def _check_unique(self, **kwargs):
1018         return (
1019             [
1020                 checks.Warning(
1021                     "Setting unique=True on a ForeignKey has the same effect as using "
1022                     "a OneToOneField.",
1023                     hint=(
1024                         "ForeignKey(unique=True) is usually better served by a "
1025                         "OneToOneField."
1026                     ),
1027                     obj=self,
1028                     id="fields.W342",
1029                 )
1030             ]
1031             if self.unique
1032             else []
1033         )
1034 
1035     def deconstruct(self):
1036         name, path, args, kwargs = super().deconstruct()
1037         del kwargs["to_fields"]
1038         del kwargs["from_fields"]
1039         # Handle the simpler arguments
1040         if self.db_index:
1041             del kwargs["db_index"]
1042         else:
1043             kwargs["db_index"] = False
1044         if self.db_constraint is not True:
1045             kwargs["db_constraint"] = self.db_constraint
1046         # Rel needs more work.
1047         to_meta = getattr(self.remote_field.model, "_meta", None)
1048         if self.remote_field.field_name and (
1049             not to_meta
1050             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1051         ):
1052             kwargs["to_field"] = self.remote_field.field_name
1053         return name, path, args, kwargs
1054 
1055     def to_python(self, value):
1056         return self.target_field.to_python(value)
1057 
1058     @property
1059     def target_field(self):
1060         return self.foreign_related_fields[0]
1061 
1062     def get_reverse_path_info(self, filtered_relation=None):
1063         """Get path from the related model to this field's model."""
1064         opts = self.model._meta
1065         from_opts = self.remote_field.model._meta
1066         return [
1067             PathInfo(
1068                 from_opts=from_opts,
1069                 to_opts=opts,
1070                 target_fields=(opts.pk,),
1071                 join_field=self.remote_field,
1072                 m2m=not self.unique,
1073                 direct=False,
1074                 filtered_relation=filtered_relation,
1075             )
1076         ]
1077 
1078     def validate(self, value, model_instance):
1079         if self.remote_field.parent_link:
1080             return
1081         super().validate(value, model_instance)
1082         if value is None:
1083             return
1084 
1085         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1086         qs = self.remote_field.model._base_manager.using(using).filter(
1087             **{self.remote_field.field_name: value}
1088         )
1089         qs = qs.complex_filter(self.get_limit_choices_to())
1090         if not qs.exists():
1091             raise exceptions.ValidationError(
1092                 self.error_messages["invalid"],
1093                 code="invalid",
1094                 params={
1095                     "model": self.remote_field.model._meta.verbose_name,
1096                     "pk": value,
1097                     "field": self.remote_field.field_name,
1098                     "value": value,
1099                 },  # 'pk' is included for backwards compatibility
1100             )
1101 
1102     def resolve_related_fields(self):
1103         related_fields = super().resolve_related_fields()
1104         for from_field, to_field in related_fields:
1105             if (
1106                 to_field
1107                 and to_field.model != self.remote_field.model._meta.concrete_model
1108             ):
1109                 raise exceptions.FieldError(
1110                     "'%s.%s' refers to field '%s' which is not local to model "
1111                     "'%s'."
1112                     % (
1113                         self.model._meta.label,
1114                         self.name,
1115                         to_field.name,
1116                         self.remote_field.model._meta.concrete_model._meta.label,
1117                     )
1118                 )
1119         return related_fields
1120 
1121     def get_attname(self):
1122         return "%s_id" % self.name
1123 
1124     def get_attname_column(self):
1125         attname = self.get_attname()
1126         column = self.db_column or attname
1127         return attname, column
1128 
1129     def get_default(self):
1130         """Return the to_field if the default value is an object."""
1131         field_default = super().get_default()
1132         if isinstance(field_default, self.remote_field.model):
1133             return getattr(field_default, self.target_field.attname)
1134         return field_default
1135 
1136     def get_db_prep_save(self, value, connection):
1137         if value is None or (
1138             value == ""
1139             and (
1140                 not self.target_field.empty_strings_allowed
1141                 or connection.features.interprets_empty_strings_as_nulls
1142             )
1143         ):
1144             return None
1145         else:
1146             return self.target_field.get_db_prep_save(value, connection=connection)
1147 
1148     def get_db_prep_value(self, value, connection, prepared=False):
1149         return self.target_field.get_db_prep_value(value, connection, prepared)
1150 
1151     def get_prep_value(self, value):
1152         return self.target_field.get_prep_value(value)
1153 
1154     def contribute_to_related_class(self, cls, related):
1155         super().contribute_to_related_class(cls, related)
1156         if self.remote_field.field_name is None:
1157             self.remote_field.field_name = cls._meta.pk.name
1158 
1159     def formfield(self, *, using=None, **kwargs):
1160         if isinstance(self.remote_field.model, str):
1161             raise ValueError(
1162                 "Cannot create form field for %r yet, because "
1163                 "its related model %r has not been loaded yet"
1164                 % (self.name, self.remote_field.model)
1165             )
1166         return super().formfield(
1167             **{
1168                 "form_class": forms.ModelChoiceField,
1169                 "queryset": self.remote_field.model._default_manager.using(using),
1170                 "to_field_name": self.remote_field.field_name,
1171                 **kwargs,
1172                 "blank": self.blank,
1173             }
1174         )
1175 
1176     def db_check(self, connection):
1177         return None
1178 
1179     def db_type(self, connection):
1180         return self.target_field.rel_db_type(connection=connection)
1181 
1182     def db_parameters(self, connection):
1183         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1184 
1185     def convert_empty_strings(self, value, expression, connection):
1186         if (not value) and isinstance(value, str):
1187             return None
1188         return value
1189 
1190     def get_db_converters(self, connection):
1191         converters = super().get_db_converters(connection)
1192         if connection.features.interprets_empty_strings_as_nulls:
1193             converters += [self.convert_empty_strings]
1194         return converters
1195 
1196     def get_col(self, alias, output_field=None):
1197         if output_field is None:
1198             output_field = self.target_field
1199             while isinstance(output_field, ForeignKey):
1200                 output_field = output_field.target_field
1201                 if output_field is self:
1202                     raise ValueError("Cannot resolve output_field.")
1203         return super().get_col(alias, output_field)
1204 
1205 
1206 class OneToOneField(ForeignKey):
1207     """
1208     A OneToOneField is essentially the same as a ForeignKey, with the exception
1209     that it always carries a "unique" constraint with it and the reverse
1210     relation always returns the object pointed to (since there will only ever
1211     be one), rather than returning a list.
1212     """
1213 
1214     # Field flags
1215     many_to_many = False
1216     many_to_one = False
1217     one_to_many = False
1218     one_to_one = True
1219 
1220     related_accessor_class = ReverseOneToOneDescriptor
1221     forward_related_accessor_class = ForwardOneToOneDescriptor
1222     rel_class = OneToOneRel
1223 
1224     description = _("One-to-one relationship")
1225 
1226     def __init__(self, to, on_delete, to_field=None, **kwargs):
1227         kwargs["unique"] = True
1228         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1229 
1230     def deconstruct(self):
1231         name, path, args, kwargs = super().deconstruct()
1232         if "unique" in kwargs:
1233             del kwargs["unique"]
1234         return name, path, args, kwargs
1235 
1236     def formfield(self, **kwargs):
1237         if self.remote_field.parent_link:
1238             return None
1239         return super().formfield(**kwargs)
1240 
1241     def save_form_data(self, instance, data):
1242         if isinstance(data, self.remote_field.model):
1243             setattr(instance, self.name, data)
1244         else:
1245             setattr(instance, self.attname, data)
1246             # Remote field object must be cleared otherwise Model.save()
1247             # will reassign attname using the related object pk.
1248             if data is None:
1249                 setattr(instance, self.name, data)
1250 
1251     def _check_unique(self, **kwargs):
1252         # Override ForeignKey since check isn't applicable here.
1253         return []
1254 
1255 
1256 def create_many_to_many_intermediary_model(field, klass):
1257     from django.db import models
1258 
1259     def set_managed(model, related, through):
1260         through._meta.managed = model._meta.managed or related._meta.managed
1261 
1262     to_model = resolve_relation(klass, field.remote_field.model)
1263     name = "%s_%s" % (klass._meta.object_name, field.name)
1264     lazy_related_operation(set_managed, klass, to_model, name)
1265 
1266     to = make_model_tuple(to_model)[1]
1267     from_ = klass._meta.model_name
1268     if to == from_:
1269         to = "to_%s" % to
1270         from_ = "from_%s" % from_
1271 
1272     meta = type(
1273         "Meta",
1274         (),
1275         {
1276             "db_table": field._get_m2m_db_table(klass._meta),
1277             "auto_created": klass,
1278             "app_label": klass._meta.app_label,
1279             "db_tablespace": klass._meta.db_tablespace,
1280             "unique_together": (from_, to),
1281             "verbose_name": _("%(from)s-%(to)s relationship")
1282             % {"from": from_, "to": to},
1283             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1284             % {"from": from_, "to": to},
1285             "apps": field.model._meta.apps,
1286         },
1287     )
1288     # Construct and return the new class.
1289     return type(
1290         name,
1291         (models.Model,),
1292         {
1293             "Meta": meta,
1294             "__module__": klass.__module__,
1295             from_: models.ForeignKey(
1296                 klass,
1297                 related_name="%s+" % name,
1298                 db_tablespace=field.db_tablespace,
1299                 db_constraint=field.remote_field.db_constraint,
1300                 on_delete=CASCADE,
1301             ),
1302             to: models.ForeignKey(
1303                 to_model,
1304                 related_name="%s+" % name,
1305                 db_tablespace=field.db_tablespace,
1306                 db_constraint=field.remote_field.db_constraint,
1307                 on_delete=CASCADE,
1308             ),
1309         },
1310     )
1311 
1312 
1313 class ManyToManyField(RelatedField):
1314     """
1315     Provide a many-to-many relation by using an intermediary model that
1316     holds two ForeignKey fields pointed at the two sides of the relation.
1317 
1318     Unless a ``through`` model was provided, ManyToManyField will use the
1319     create_many_to_many_intermediary_model factory to automatically generate
1320     the intermediary model.
1321     """
1322 
1323     # Field flags
1324     many_to_many = True
1325     many_to_one = False
1326     one_to_many = False
1327     one_to_one = False
1328 
1329     rel_class = ManyToManyRel
1330 
1331     description = _("Many-to-many relationship")
1332 
1333     def __init__(
1334         self,
1335         to,
1336         related_name=None,
1337         related_query_name=None,
1338         limit_choices_to=None,
1339         symmetrical=None,
1340         through=None,
1341         through_fields=None,
1342         db_constraint=True,
1343         db_table=None,
1344         swappable=True,
1345         **kwargs,
1346     ):
1347         try:
1348             to._meta
1349         except AttributeError:
1350             if not isinstance(to, str):
1351                 raise TypeError(
1352                     "%s(%r) is invalid. First parameter to ManyToManyField "
1353                     "must be either a model, a model name, or the string %r"
1354                     % (
1355                         self.__class__.__name__,
1356                         to,
1357                         RECURSIVE_RELATIONSHIP_CONSTANT,
1358                     )
1359                 )
1360 
1361         if symmetrical is None:
1362             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1363 
1364         if through is not None and db_table is not None:
1365             raise ValueError(
1366                 "Cannot specify a db_table if an intermediary model is used."
1367             )
1368 
1369         kwargs["rel"] = self.rel_class(
1370             self,
1371             to,
1372             related_name=related_name,
1373             related_query_name=related_query_name,
1374             limit_choices_to=limit_choices_to,
1375             symmetrical=symmetrical,
1376             through=through,
1377             through_fields=through_fields,
1378             db_constraint=db_constraint,
1379         )
1380         self.has_null_arg = "null" in kwargs
1381 
1382         super().__init__(
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             **kwargs,
1387         )
1388 
1389         self.db_table = db_table
1390         self.swappable = swappable
1391 
1392     def check(self, **kwargs):
1393         return [
1394             *super().check(**kwargs),
1395             *self._check_unique(**kwargs),
1396             *self._check_relationship_model(**kwargs),
1397             *self._check_ignored_options(**kwargs),
1398             *self._check_table_uniqueness(**kwargs),
1399         ]
1400 
1401     def _check_unique(self, **kwargs):
1402         if self.unique:
1403             return [
1404                 checks.Error(
1405                     "ManyToManyFields cannot be unique.",
1406                     obj=self,
1407                     id="fields.E330",
1408                 )
1409             ]
1410         return []
1411 
1412     def _check_ignored_options(self, **kwargs):
1413         warnings = []
1414 
1415         if self.has_null_arg:
1416             warnings.append(
1417                 checks.Warning(
1418                     "null has no effect on ManyToManyField.",
1419                     obj=self,
1420                     id="fields.W340",
1421                 )
1422             )
1423 
1424         if self._validators:
1425             warnings.append(
1426                 checks.Warning(
1427                     "ManyToManyField does not support validators.",
1428                     obj=self,
1429                     id="fields.W341",
1430                 )
1431             )
1432         if self.remote_field.symmetrical and self._related_name:
1433             warnings.append(
1434                 checks.Warning(
1435                     "related_name has no effect on ManyToManyField "
1436                     'with a symmetrical relationship, e.g. to "self".',
1437                     obj=self,
1438                     id="fields.W345",
1439                 )
1440             )
1441 
1442         return warnings
1443 
1444     def _check_relationship_model(self, from_model=None, **kwargs):
1445         if hasattr(self.remote_field.through, "_meta"):
1446             qualified_model_name = "%s.%s" % (
1447                 self.remote_field.through._meta.app_label,
1448                 self.remote_field.through.__name__,
1449             )
1450         else:
1451             qualified_model_name = self.remote_field.through
1452 
1453         errors = []
1454 
1455         if self.remote_field.through not in self.opts.apps.get_models(
1456             include_auto_created=True
1457         ):
1458             # The relationship model is not installed.
1459             errors.append(
1460                 checks.Error(
1461                     "Field specifies a many-to-many relation through model "
1462                     "'%s', which has not been installed." % qualified_model_name,
1463                     obj=self,
1464                     id="fields.E331",
1465                 )
1466             )
1467 
1468         else:
1469             assert from_model is not None, (
1470                 "ManyToManyField with intermediate "
1471                 "tables cannot be checked if you don't pass the model "
1472                 "where the field is attached to."
1473             )
1474             # Set some useful local variables
1475             to_model = resolve_relation(from_model, self.remote_field.model)
1476             from_model_name = from_model._meta.object_name
1477             if isinstance(to_model, str):
1478                 to_model_name = to_model
1479             else:
1480                 to_model_name = to_model._meta.object_name
1481             relationship_model_name = self.remote_field.through._meta.object_name
1482             self_referential = from_model == to_model
1483             # Count foreign keys in intermediate model
1484             if self_referential:
1485                 seen_self = sum(
1486                     from_model == getattr(field.remote_field, "model", None)
1487                     for field in self.remote_field.through._meta.fields
1488                 )
1489 
1490                 if seen_self > 2 and not self.remote_field.through_fields:
1491                     errors.append(
1492                         checks.Error(
1493                             "The model is used as an intermediate model by "
1494                             "'%s', but it has more than two foreign keys "
1495                             "to '%s', which is ambiguous. You must specify "
1496                             "which two foreign keys Django should use via the "
1497                             "through_fields keyword argument."
1498                             % (self, from_model_name),
1499                             hint=(
1500                                 "Use through_fields to specify which two foreign keys "
1501                                 "Django should use."
1502                             ),
1503                             obj=self.remote_field.through,
1504                             id="fields.E333",
1505                         )
1506                     )
1507 
1508             else:
1509                 # Count foreign keys in relationship model
1510                 seen_from = sum(
1511                     from_model == getattr(field.remote_field, "model", None)
1512                     for field in self.remote_field.through._meta.fields
1513                 )
1514                 seen_to = sum(
1515                     to_model == getattr(field.remote_field, "model", None)
1516                     for field in self.remote_field.through._meta.fields
1517                 )
1518 
1519                 if seen_from > 1 and not self.remote_field.through_fields:
1520                     errors.append(
1521                         checks.Error(
1522                             (
1523                                 "The model is used as an intermediate model by "
1524                                 "'%s', but it has more than one foreign key "
1525                                 "from '%s', which is ambiguous. You must specify "
1526                                 "which foreign key Django should use via the "
1527                                 "through_fields keyword argument."
1528                             )
1529                             % (self, from_model_name),
1530                             hint=(
1531                                 "If you want to create a recursive relationship, "
1532                                 'use ManyToManyField("%s", through="%s").'
1533                             )
1534                             % (
1535                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1536                                 relationship_model_name,
1537                             ),
1538                             obj=self,
1539                             id="fields.E334",
1540                         )
1541                     )
1542 
1543                 if seen_to > 1 and not self.remote_field.through_fields:
1544                     errors.append(
1545                         checks.Error(
1546                             "The model is used as an intermediate model by "
1547                             "'%s', but it has more than one foreign key "
1548                             "to '%s', which is ambiguous. You must specify "
1549                             "which foreign key Django should use via the "
1550                             "through_fields keyword argument." % (self, to_model_name),
1551                             hint=(
1552                                 "If you want to create a recursive relationship, "
1553                                 'use ManyToManyField("%s", through="%s").'
1554                             )
1555                             % (
1556                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1557                                 relationship_model_name,
1558                             ),
1559                             obj=self,
1560                             id="fields.E335",
1561                         )
1562                     )
1563 
1564                 if seen_from == 0 or seen_to == 0:
1565                     errors.append(
1566                         checks.Error(
1567                             "The model is used as an intermediate model by "
1568                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1569                             % (self, from_model_name, to_model_name),
1570                             obj=self.remote_field.through,
1571                             id="fields.E336",
1572                         )
1573                     )
1574 
1575         # Validate `through_fields`.
1576         if self.remote_field.through_fields is not None:
1577             # Validate that we're given an iterable of at least two items
1578             # and that none of them is "falsy".
1579             if not (
1580                 len(self.remote_field.through_fields) >= 2
1581                 and self.remote_field.through_fields[0]
1582                 and self.remote_field.through_fields[1]
1583             ):
1584                 errors.append(
1585                     checks.Error(
1586                         "Field specifies 'through_fields' but does not provide "
1587                         "the names of the two link fields that should be used "
1588                         "for the relation through model '%s'." % qualified_model_name,
1589                         hint=(
1590                             "Make sure you specify 'through_fields' as "
1591                             "through_fields=('field1', 'field2')"
1592                         ),
1593                         obj=self,
1594                         id="fields.E337",
1595                     )
1596                 )
1597 
1598             # Validate the given through fields -- they should be actual
1599             # fields on the through model, and also be foreign keys to the
1600             # expected models.
1601             else:
1602                 assert from_model is not None, (
1603                     "ManyToManyField with intermediate "
1604                     "tables cannot be checked if you don't pass the model "
1605                     "where the field is attached to."
1606                 )
1607 
1608                 source, through, target = (
1609                     from_model,
1610                     self.remote_field.through,
1611                     self.remote_field.model,
1612                 )
1613                 source_field_name, target_field_name = self.remote_field.through_fields[
1614                     :2
1615                 ]
1616 
1617                 for field_name, related_model in (
1618                     (source_field_name, source),
1619                     (target_field_name, target),
1620                 ):
1621 
1622                     possible_field_names = []
1623                     for f in through._meta.fields:
1624                         if (
1625                             hasattr(f, "remote_field")
1626                             and getattr(f.remote_field, "model", None) == related_model
1627                         ):
1628                             possible_field_names.append(f.name)
1629                     if possible_field_names:
1630                         hint = (
1631                             "Did you mean one of the following foreign keys to '%s': "
1632                             "%s?"
1633                             % (
1634                                 related_model._meta.object_name,
1635                                 ", ".join(possible_field_names),
1636                             )
1637                         )
1638                     else:
1639                         hint = None
1640 
1641                     try:
1642                         field = through._meta.get_field(field_name)
1643                     except exceptions.FieldDoesNotExist:
1644                         errors.append(
1645                             checks.Error(
1646                                 "The intermediary model '%s' has no field '%s'."
1647                                 % (qualified_model_name, field_name),
1648                                 hint=hint,
1649                                 obj=self,
1650                                 id="fields.E338",
1651                             )
1652                         )
1653                     else:
1654                         if not (
1655                             hasattr(field, "remote_field")
1656                             and getattr(field.remote_field, "model", None)
1657                             == related_model
1658                         ):
1659                             errors.append(
1660                                 checks.Error(
1661                                     "'%s.%s' is not a foreign key to '%s'."
1662                                     % (
1663                                         through._meta.object_name,
1664                                         field_name,
1665                                         related_model._meta.object_name,
1666                                     ),
1667                                     hint=hint,
1668                                     obj=self,
1669                                     id="fields.E339",
1670                                 )
1671                             )
1672 
1673         return errors
1674 
1675     def _check_table_uniqueness(self, **kwargs):
1676         if (
1677             isinstance(self.remote_field.through, str)
1678             or not self.remote_field.through._meta.managed
1679         ):
1680             return []
1681         registered_tables = {
1682             model._meta.db_table: model
1683             for model in self.opts.apps.get_models(include_auto_created=True)
1684             if model != self.remote_field.through and model._meta.managed
1685         }
1686         m2m_db_table = self.m2m_db_table()
1687         model = registered_tables.get(m2m_db_table)
1688         # The second condition allows multiple m2m relations on a model if
1689         # some point to a through model that proxies another through model.
1690         if (
1691             model
1692             and model._meta.concrete_model
1693             != self.remote_field.through._meta.concrete_model
1694         ):
1695             if model._meta.auto_created:
1696 
1697                 def _get_field_name(model):
1698                     for field in model._meta.auto_created._meta.many_to_many:
1699                         if field.remote_field.through is model:
1700                             return field.name
1701 
1702                 opts = model._meta.auto_created._meta
1703                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1704             else:
1705                 clashing_obj = model._meta.label
1706             if settings.DATABASE_ROUTERS:
1707                 error_class, error_id = checks.Warning, "fields.W344"
1708                 error_hint = (
1709                     "You have configured settings.DATABASE_ROUTERS. Verify "
1710                     "that the table of %r is correctly routed to a separate "
1711                     "database." % clashing_obj
1712                 )
1713             else:
1714                 error_class, error_id = checks.Error, "fields.E340"
1715                 error_hint = None
1716             return [
1717                 error_class(
1718                     "The field's intermediary table '%s' clashes with the "
1719                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1720                     obj=self,
1721                     hint=error_hint,
1722                     id=error_id,
1723                 )
1724             ]
1725         return []
1726 
1727     def deconstruct(self):
1728         name, path, args, kwargs = super().deconstruct()
1729         # Handle the simpler arguments.
1730         if self.db_table is not None:
1731             kwargs["db_table"] = self.db_table
1732         if self.remote_field.db_constraint is not True:
1733             kwargs["db_constraint"] = self.remote_field.db_constraint
1734         # Lowercase model names as they should be treated as case-insensitive.
1735         if isinstance(self.remote_field.model, str):
1736             if "." in self.remote_field.model:
1737                 app_label, model_name = self.remote_field.model.split(".")
1738                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1739             else:
1740                 kwargs["to"] = self.remote_field.model.lower()
1741         else:
1742             kwargs["to"] = self.remote_field.model._meta.label_lower
1743         if getattr(self.remote_field, "through", None) is not None:
1744             if isinstance(self.remote_field.through, str):
1745                 kwargs["through"] = self.remote_field.through
1746             elif not self.remote_field.through._meta.auto_created:
1747                 kwargs["through"] = self.remote_field.through._meta.label
1748         # If swappable is True, then see if we're actually pointing to the target
1749         # of a swap.
1750         swappable_setting = self.swappable_setting
1751         if swappable_setting is not None:
1752             # If it's already a settings reference, error.
1753             if hasattr(kwargs["to"], "setting_name"):
1754                 if kwargs["to"].setting_name != swappable_setting:
1755                     raise ValueError(
1756                         "Cannot deconstruct a ManyToManyField pointing to a "
1757                         "model that is swapped in place of more than one model "
1758                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1759                     )
1760 
1761             kwargs["to"] = SettingsReference(
1762                 kwargs["to"],
1763                 swappable_setting,
1764             )
1765         return name, path, args, kwargs
1766 
1767     def _get_path_info(self, direct=False, filtered_relation=None):
1768         """Called by both direct and indirect m2m traversal."""
1769         int_model = self.remote_field.through
1770         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1771         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1772         if direct:
1773             join1infos = linkfield1.reverse_path_infos
1774             if filtered_relation:
1775                 join2infos = linkfield2.get_path_info(filtered_relation)
1776             else:
1777                 join2infos = linkfield2.path_infos
1778         else:
1779             join1infos = linkfield2.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield1.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield1.path_infos
1784         # Get join infos between the last model of join 1 and the first model
1785         # of join 2. Assume the only reason these may differ is due to model
1786         # inheritance.
1787         join1_final = join1infos[-1].to_opts
1788         join2_initial = join2infos[0].from_opts
1789         if join1_final is join2_initial:
1790             intermediate_infos = []
1791         elif issubclass(join1_final.model, join2_initial.model):
1792             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1793         else:
1794             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1795 
1796         return [*join1infos, *intermediate_infos, *join2infos]
1797 
1798     def get_path_info(self, filtered_relation=None):
1799         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1800 
1801     @cached_property
1802     def path_infos(self):
1803         return self.get_path_info()
1804 
1805     def get_reverse_path_info(self, filtered_relation=None):
1806         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1807 
1808     @cached_property
1809     def reverse_path_infos(self):
1810         return self.get_reverse_path_info()
1811 
1812     def _get_m2m_db_table(self, opts):
1813         """
1814         Function that can be curried to provide the m2m table name for this
1815         relation.
1816         """
1817         if self.remote_field.through is not None:
1818             return self.remote_field.through._meta.db_table
1819         elif self.db_table:
1820             return self.db_table
1821         else:
1822             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1823             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1824 
1825     def _get_m2m_attr(self, related, attr):
1826         """
1827         Function that can be curried to provide the source accessor or DB
1828         column name for the m2m table.
1829         """
1830         cache_attr = "_m2m_%s_cache" % attr
1831         if hasattr(self, cache_attr):
1832             return getattr(self, cache_attr)
1833         if self.remote_field.through_fields is not None:
1834             link_field_name = self.remote_field.through_fields[0]
1835         else:
1836             link_field_name = None
1837         for f in self.remote_field.through._meta.fields:
1838             if (
1839                 f.is_relation
1840                 and f.remote_field.model == related.related_model
1841                 and (link_field_name is None or link_field_name == f.name)
1842             ):
1843                 setattr(self, cache_attr, getattr(f, attr))
1844                 return getattr(self, cache_attr)
1845 
1846     def _get_m2m_reverse_attr(self, related, attr):
1847         """
1848         Function that can be curried to provide the related accessor or DB
1849         column name for the m2m table.
1850         """
1851         cache_attr = "_m2m_reverse_%s_cache" % attr
1852         if hasattr(self, cache_attr):
1853             return getattr(self, cache_attr)
1854         found = False
1855         if self.remote_field.through_fields is not None:
1856             link_field_name = self.remote_field.through_fields[1]
1857         else:
1858             link_field_name = None
1859         for f in self.remote_field.through._meta.fields:
1860             if f.is_relation and f.remote_field.model == related.model:
1861                 if link_field_name is None and related.related_model == related.model:
1862                     # If this is an m2m-intermediate to self,
1863                     # the first foreign key you find will be
1864                     # the source column. Keep searching for
1865                     # the second foreign key.
1866                     if found:
1867                         setattr(self, cache_attr, getattr(f, attr))
1868                         break
1869                     else:
1870                         found = True
1871                 elif link_field_name is None or link_field_name == f.name:
1872                     setattr(self, cache_attr, getattr(f, attr))
1873                     break
1874         return getattr(self, cache_attr)
1875 
1876     def contribute_to_class(self, cls, name, **kwargs):
1877         # To support multiple relations to self, it's useful to have a non-None
1878         # related name on symmetrical relations for internal reasons. The
1879         # concept doesn't make a lot of sense externally ("you want me to
1880         # specify *what* on my non-reversible relation?!"), so we set it up
1881         # automatically. The funky name reduces the chance of an accidental
1882         # clash.
1883         if self.remote_field.symmetrical and (
1884             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1885             or self.remote_field.model == cls._meta.object_name
1886         ):
1887             self.remote_field.related_name = "%s_rel_+" % name
1888         elif self.remote_field.is_hidden():
1889             # If the backwards relation is disabled, replace the original
1890             # related_name with one generated from the m2m field name. Django
1891             # still uses backwards relations internally and we need to avoid
1892             # clashes between multiple m2m fields with related_name == '+'.
1893             self.remote_field.related_name = "_%s_%s_%s_+" % (
1894                 cls._meta.app_label,
1895                 cls.__name__.lower(),
1896                 name,
1897             )
1898 
1899         super().contribute_to_class(cls, name, **kwargs)
1900 
1901         # The intermediate m2m model is not auto created if:
1902         #  1) There is a manually specified intermediate, or
1903         #  2) The class owning the m2m field is abstract.
1904         #  3) The class owning the m2m field has been swapped out.
1905         if not cls._meta.abstract:
1906             if self.remote_field.through:
1907 
1908                 def resolve_through_model(_, model, field):
1909                     field.remote_field.through = model
1910 
1911                 lazy_related_operation(
1912                     resolve_through_model, cls, self.remote_field.through, field=self
1913                 )
1914             elif not cls._meta.swapped:
1915                 self.remote_field.through = create_many_to_many_intermediary_model(
1916                     self, cls
1917                 )
1918 
1919         # Add the descriptor for the m2m relation.
1920         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1921 
1922         # Set up the accessor for the m2m table name for the relation.
1923         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1924 
1925     def contribute_to_related_class(self, cls, related):
1926         # Internal M2Ms (i.e., those with a related name ending with '+')
1927         # and swapped models don't get a related descriptor.
1928         if (
1929             not self.remote_field.is_hidden()
1930             and not related.related_model._meta.swapped
1931         ):
1932             setattr(
1933                 cls,
1934                 related.get_accessor_name(),
1935                 ManyToManyDescriptor(self.remote_field, reverse=True),
1936             )
1937 
1938         # Set up the accessors for the column names on the m2m table.
1939         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1940         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1941 
1942         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1943         self.m2m_reverse_field_name = partial(
1944             self._get_m2m_reverse_attr, related, "name"
1945         )
1946 
1947         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1948         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1949         get_m2m_reverse_rel = partial(
1950             self._get_m2m_reverse_attr, related, "remote_field"
1951         )
1952         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1953 
1954     def set_attributes_from_rel(self):
1955         pass
1956 
1957     def value_from_object(self, obj):
1958         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1959 
1960     def save_form_data(self, instance, data):
1961         getattr(instance, self.attname).set(data)
1962 
1963     def formfield(self, *, using=None, **kwargs):
1964         defaults = {
1965             "form_class": forms.ModelMultipleChoiceField,
1966             "queryset": self.remote_field.model._default_manager.using(using),
1967             **kwargs,
1968         }
1969         # If initial is passed in, it's a list of related objects, but the
1970         # MultipleChoiceField takes a list of IDs.
1971         if defaults.get("initial") is not None:
1972             initial = defaults["initial"]
1973             if callable(initial):
1974                 initial = initial()
1975             defaults["initial"] = [i.pk for i in initial]
1976         return super().formfield(**defaults)
1977 
1978     def db_check(self, connection):
1979         return None
1980 
1981     def db_type(self, connection):
1982         # A ManyToManyField is not represented by a single column,
1983         # so return None.
1984         return None
1985 
1986     def db_parameters(self, connection):
1987         return {"type": None, "check": None}

</code><intended_behavior>Within this file, particularly in the sections that define or manipulate 'ForeignKey' fields, additional logic is required to check the 'db_collation' of the referenced field (if any) and apply it to the 'ForeignKey' field during migrations. The intention is for foreign keys to maintain database consistency by automatically adopting the 'db_collation' of their referenced primary key fields when migrations are generated, thus preventing collation mismatch errors. This adjustment should ensure that fields referencing custom or altered collation settings adhere to those settings across all related tables, respecting database constraints.</intended_behavior>]
2025-10-15 04:09:41.268 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 04:09:41.268 | INFO     | Search-only: skipping patch selection
2025-10-15 04:09:41.439 | INFO     | Task django__django-15629 completed successfully.
2025-10-15 04:09:41.440 | INFO     | No patch generated. You can try running ACR again.
