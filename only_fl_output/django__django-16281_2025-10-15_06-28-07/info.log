2025-10-15 06:28:07.604 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 06:28:12.561 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=221, output_tokens=12, cost=0.002570
2025-10-15 06:28:30.020 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=401, output_tokens=615, cost=0.022460
2025-10-15 06:28:31.344 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 06:28:41.901 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=530, output_tokens=382, cost=0.016760
2025-10-15 06:28:41.908 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 06:28:45.014 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=736, output_tokens=71, cost=0.009490
2025-10-15 06:28:45.016 | DEBUG    | Extracted a valid json.
2025-10-15 06:28:45.016 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Bar\")",
        "search_class(\"Foo\")",
        "search_code(\"ManyToManyField\")",
        "search_code(\"OperationalError\")",
        "search_method(\"makemigrations\")",
        "search_method(\"migrate\")"
    ],
    "bug_locations": []
}
2025-10-15 06:28:45.158 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 06:28:45.158 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 06:29:03.984 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2709, output_tokens=743, cost=0.049380
2025-10-15 06:29:03.996 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 06:29:15.838 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3668, output_tokens=493, cost=0.051470
2025-10-15 06:29:15.849 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 06:29:21.067 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=847, output_tokens=198, cost=0.014410
2025-10-15 06:29:21.069 | DEBUG    | Extracted a valid json.
2025-10-15 06:29:21.069 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that when a ManyToManyField targets 'self', Django's migration framework correctly adjusts the underlying database schema, specifically creating or modifying the necessary intermediary table columns to reflect the self-referencing nature of the field."
        },
        {
            "file": "django/db/migrations/executor.py",
            "class": "MigrationExecutor",
            "method": "migrate",
            "intended_behavior": "The migrate method must ensure that migrations involving changes to a ManyToManyField's target include the correct operations for adjusting the schema, especially when changing from a reference to another model to 'self'. This could involve creating specific checks or operations within the migration planning or execution phases that deal with self-referencing ManyToMany fields."
        }
    ]
}
2025-10-15 06:29:21.082 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name %= {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_q = Q.create(
411             [
412                 (rh_field.attname, getattr(obj, lh_field.attname))
413                 for lh_field, rh_field in self.related_fields
414             ]
415         )
416         descriptor_filter = self.get_extra_descriptor_filter(obj)
417         if isinstance(descriptor_filter, dict):
418             return base_q & Q(**descriptor_filter)
419         elif descriptor_filter:
420             return base_q & descriptor_filter
421         return base_q
422 
423     @property
424     def swappable_setting(self):
425         """
426         Get the setting that this is powered from for swapping, or None
427         if it's not swapped in / marked with swappable=False.
428         """
429         if self.swappable:
430             # Work out string form of "to"
431             if isinstance(self.remote_field.model, str):
432                 to_string = self.remote_field.model
433             else:
434                 to_string = self.remote_field.model._meta.label
435             return apps.get_swappable_settings_name(to_string)
436         return None
437 
438     def set_attributes_from_rel(self):
439         self.name = self.name or (
440             self.remote_field.model._meta.model_name
441             + "_"
442             + self.remote_field.model._meta.pk.name
443         )
444         if self.verbose_name is None:
445             self.verbose_name = self.remote_field.model._meta.verbose_name
446         self.remote_field.set_field_name()
447 
448     def do_related_class(self, other, cls):
449         self.set_attributes_from_rel()
450         self.contribute_to_related_class(other, self.remote_field)
451 
452     def get_limit_choices_to(self):
453         """
454         Return ``limit_choices_to`` for this model field.
455 
456         If it is a callable, it will be invoked and the result will be
457         returned.
458         """
459         if callable(self.remote_field.limit_choices_to):
460             return self.remote_field.limit_choices_to()
461         return self.remote_field.limit_choices_to
462 
463     def formfield(self, **kwargs):
464         """
465         Pass ``limit_choices_to`` to the field being constructed.
466 
467         Only passes it if there is a type that supports related fields.
468         This is a similar strategy used to pass the ``queryset`` to the field
469         being constructed.
470         """
471         defaults = {}
472         if hasattr(self.remote_field, "get_related_field"):
473             # If this is a callable, do not invoke it here. Just pass
474             # it in the defaults for when the form class will later be
475             # instantiated.
476             limit_choices_to = self.remote_field.limit_choices_to
477             defaults.update(
478                 {
479                     "limit_choices_to": limit_choices_to,
480                 }
481             )
482         defaults.update(kwargs)
483         return super().formfield(**defaults)
484 
485     def related_query_name(self):
486         """
487         Define the name that can be used to identify this related object in a
488         table-spanning query.
489         """
490         return (
491             self.remote_field.related_query_name
492             or self.remote_field.related_name
493             or self.opts.model_name
494         )
495 
496     @property
497     def target_field(self):
498         """
499         When filtering against this relation, return the field on the remote
500         model against which the filtering should happen.
501         """
502         target_fields = self.path_infos[-1].target_fields
503         if len(target_fields) > 1:
504             raise exceptions.FieldError(
505                 "The relation has multiple target fields, but only single target field "
506                 "was asked for"
507             )
508         return target_fields[0]
509 
510     def get_cache_name(self):
511         return self.name
512 
513 
514 class ForeignObject(RelatedField):
515     """
516     Abstraction of the ForeignKey relation to support multi-column relations.
517     """
518 
519     # Field flags
520     many_to_many = False
521     many_to_one = True
522     one_to_many = False
523     one_to_one = False
524 
525     requires_unique_target = True
526     related_accessor_class = ReverseManyToOneDescriptor
527     forward_related_accessor_class = ForwardManyToOneDescriptor
528     rel_class = ForeignObjectRel
529 
530     def __init__(
531         self,
532         to,
533         on_delete,
534         from_fields,
535         to_fields,
536         rel=None,
537         related_name=None,
538         related_query_name=None,
539         limit_choices_to=None,
540         parent_link=False,
541         swappable=True,
542         **kwargs,
543     ):
544 
545         if rel is None:
546             rel = self.rel_class(
547                 self,
548                 to,
549                 related_name=related_name,
550                 related_query_name=related_query_name,
551                 limit_choices_to=limit_choices_to,
552                 parent_link=parent_link,
553                 on_delete=on_delete,
554             )
555 
556         super().__init__(
557             rel=rel,
558             related_name=related_name,
559             related_query_name=related_query_name,
560             limit_choices_to=limit_choices_to,
561             **kwargs,
562         )
563 
564         self.from_fields = from_fields
565         self.to_fields = to_fields
566         self.swappable = swappable
567 
568     def __copy__(self):
569         obj = super().__copy__()
570         # Remove any cached PathInfo values.
571         obj.__dict__.pop("path_infos", None)
572         obj.__dict__.pop("reverse_path_infos", None)
573         return obj
574 
575     def check(self, **kwargs):
576         return [
577             *super().check(**kwargs),
578             *self._check_to_fields_exist(),
579             *self._check_unique_target(),
580         ]
581 
582     def _check_to_fields_exist(self):
583         # Skip nonexistent models.
584         if isinstance(self.remote_field.model, str):
585             return []
586 
587         errors = []
588         for to_field in self.to_fields:
589             if to_field:
590                 try:
591                     self.remote_field.model._meta.get_field(to_field)
592                 except exceptions.FieldDoesNotExist:
593                     errors.append(
594                         checks.Error(
595                             "The to_field '%s' doesn't exist on the related "
596                             "model '%s'."
597                             % (to_field, self.remote_field.model._meta.label),
598                             obj=self,
599                             id="fields.E312",
600                         )
601                     )
602         return errors
603 
604     def _check_unique_target(self):
605         rel_is_string = isinstance(self.remote_field.model, str)
606         if rel_is_string or not self.requires_unique_target:
607             return []
608 
609         try:
610             self.foreign_related_fields
611         except exceptions.FieldDoesNotExist:
612             return []
613 
614         if not self.foreign_related_fields:
615             return []
616 
617         unique_foreign_fields = {
618             frozenset([f.name])
619             for f in self.remote_field.model._meta.get_fields()
620             if getattr(f, "unique", False)
621         }
622         unique_foreign_fields.update(
623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
624         )
625         unique_foreign_fields.update(
626             {
627                 frozenset(uc.fields)
628                 for uc in self.remote_field.model._meta.total_unique_constraints
629             }
630         )
631         foreign_fields = {f.name for f in self.foreign_related_fields}
632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
633 
634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
635             field_combination = ", ".join(
636                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
637             )
638             model_name = self.remote_field.model.__name__
639             return [
640                 checks.Error(
641                     "No subset of the fields %s on model '%s' is unique."
642                     % (field_combination, model_name),
643                     hint=(
644                         "Mark a single field as unique=True or add a set of "
645                         "fields to a unique constraint (via unique_together "
646                         "or a UniqueConstraint (without condition) in the "
647                         "model Meta.constraints)."
648                     ),
649                     obj=self,
650                     id="fields.E310",
651                 )
652             ]
653         elif not has_unique_constraint:
654             field_name = self.foreign_related_fields[0].name
655             model_name = self.remote_field.model.__name__
656             return [
657                 checks.Error(
658                     "'%s.%s' must be unique because it is referenced by "
659                     "a foreign key." % (model_name, field_name),
660                     hint=(
661                         "Add unique=True to this field or add a "
662                         "UniqueConstraint (without condition) in the model "
663                         "Meta.constraints."
664                     ),
665                     obj=self,
666                     id="fields.E311",
667                 )
668             ]
669         else:
670             return []
671 
672     def deconstruct(self):
673         name, path, args, kwargs = super().deconstruct()
674         kwargs["on_delete"] = self.remote_field.on_delete
675         kwargs["from_fields"] = self.from_fields
676         kwargs["to_fields"] = self.to_fields
677 
678         if self.remote_field.parent_link:
679             kwargs["parent_link"] = self.remote_field.parent_link
680         if isinstance(self.remote_field.model, str):
681             if "." in self.remote_field.model:
682                 app_label, model_name = self.remote_field.model.split(".")
683                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
684             else:
685                 kwargs["to"] = self.remote_field.model.lower()
686         else:
687             kwargs["to"] = self.remote_field.model._meta.label_lower
688         # If swappable is True, then see if we're actually pointing to the target
689         # of a swap.
690         swappable_setting = self.swappable_setting
691         if swappable_setting is not None:
692             # If it's already a settings reference, error
693             if hasattr(kwargs["to"], "setting_name"):
694                 if kwargs["to"].setting_name != swappable_setting:
695                     raise ValueError(
696                         "Cannot deconstruct a ForeignKey pointing to a model "
697                         "that is swapped in place of more than one model (%s and %s)"
698                         % (kwargs["to"].setting_name, swappable_setting)
699                     )
700             # Set it
701             kwargs["to"] = SettingsReference(
702                 kwargs["to"],
703                 swappable_setting,
704             )
705         return name, path, args, kwargs
706 
707     def resolve_related_fields(self):
708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
709             raise ValueError(
710                 "Foreign Object from and to fields must be the same non-zero length"
711             )
712         if isinstance(self.remote_field.model, str):
713             raise ValueError(
714                 "Related model %r cannot be resolved" % self.remote_field.model
715             )
716         related_fields = []
717         for index in range(len(self.from_fields)):
718             from_field_name = self.from_fields[index]
719             to_field_name = self.to_fields[index]
720             from_field = (
721                 self
722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
723                 else self.opts.get_field(from_field_name)
724             )
725             to_field = (
726                 self.remote_field.model._meta.pk
727                 if to_field_name is None
728                 else self.remote_field.model._meta.get_field(to_field_name)
729             )
730             related_fields.append((from_field, to_field))
731         return related_fields
732 
733     @cached_property
734     def related_fields(self):
735         return self.resolve_related_fields()
736 
737     @cached_property
738     def reverse_related_fields(self):
739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
740 
741     @cached_property
742     def local_related_fields(self):
743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
744 
745     @cached_property
746     def foreign_related_fields(self):
747         return tuple(
748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
749         )
750 
751     def get_local_related_value(self, instance):
752         return self.get_instance_value_for_fields(instance, self.local_related_fields)
753 
754     def get_foreign_related_value(self, instance):
755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
756 
757     @staticmethod
758     def get_instance_value_for_fields(instance, fields):
759         ret = []
760         opts = instance._meta
761         for field in fields:
762             # Gotcha: in some cases (like fixture loading) a model can have
763             # different values in parent_ptr_id and parent's id. So, use
764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
765             if field.primary_key:
766                 possible_parent_link = opts.get_ancestor_link(field.model)
767                 if (
768                     not possible_parent_link
769                     or possible_parent_link.primary_key
770                     or possible_parent_link.model._meta.abstract
771                 ):
772                     ret.append(instance.pk)
773                     continue
774             ret.append(getattr(instance, field.attname))
775         return tuple(ret)
776 
777     def get_attname_column(self):
778         attname, column = super().get_attname_column()
779         return attname, None
780 
781     def get_joining_columns(self, reverse_join=False):
782         source = self.reverse_related_fields if reverse_join else self.related_fields
783         return tuple(
784             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
785         )
786 
787     def get_reverse_joining_columns(self):
788         return self.get_joining_columns(reverse_join=True)
789 
790     def get_extra_descriptor_filter(self, instance):
791         """
792         Return an extra filter condition for related object fetching when
793         user does 'instance.fieldname', that is the extra filter is used in
794         the descriptor of the field.
795 
796         The filter should be either a dict usable in .filter(**kwargs) call or
797         a Q-object. The condition will be ANDed together with the relation's
798         joining columns.
799 
800         A parallel method is get_extra_restriction() which is used in
801         JOIN and subquery conditions.
802         """
803         return {}
804 
805     def get_extra_restriction(self, alias, related_alias):
806         """
807         Return a pair condition used for joining and subquery pushdown. The
808         condition is something that responds to as_sql(compiler, connection)
809         method.
810 
811         Note that currently referring both the 'alias' and 'related_alias'
812         will not work in some conditions, like subquery pushdown.
813 
814         A parallel method is get_extra_descriptor_filter() which is used in
815         instance.fieldname related object fetching.
816         """
817         return None
818 
819     def get_path_info(self, filtered_relation=None):
820         """Get path from this field to the related model."""
821         opts = self.remote_field.model._meta
822         from_opts = self.model._meta
823         return [
824             PathInfo(
825                 from_opts=from_opts,
826                 to_opts=opts,
827                 target_fields=self.foreign_related_fields,
828                 join_field=self,
829                 m2m=False,
830                 direct=True,
831                 filtered_relation=filtered_relation,
832             )
833         ]
834 
835     @cached_property
836     def path_infos(self):
837         return self.get_path_info()
838 
839     def get_reverse_path_info(self, filtered_relation=None):
840         """Get path from the related model to this field's model."""
841         opts = self.model._meta
842         from_opts = self.remote_field.model._meta
843         return [
844             PathInfo(
845                 from_opts=from_opts,
846                 to_opts=opts,
847                 target_fields=(opts.pk,),
848                 join_field=self.remote_field,
849                 m2m=not self.unique,
850                 direct=False,
851                 filtered_relation=filtered_relation,
852             )
853         ]
854 
855     @cached_property
856     def reverse_path_infos(self):
857         return self.get_reverse_path_info()
858 
859     @classmethod
860     @functools.lru_cache(maxsize=None)
861     def get_class_lookups(cls):
862         bases = inspect.getmro(cls)
863         bases = bases[: bases.index(ForeignObject) + 1]
864         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
865         return cls.merge_dicts(class_lookups)
866 
867     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
868         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
869         setattr(cls, self.name, self.forward_related_accessor_class(self))
870 
871     def contribute_to_related_class(self, cls, related):
872         # Internal FK's - i.e., those with a related name ending with '+' -
873         # and swapped models don't get a related descriptor.
874         if (
875             not self.remote_field.is_hidden()
876             and not related.related_model._meta.swapped
877         ):
878             setattr(
879                 cls._meta.concrete_model,
880                 related.get_accessor_name(),
881                 self.related_accessor_class(related),
882             )
883             # While 'limit_choices_to' might be a callable, simply pass
884             # it along for later - this is too early because it's still
885             # model load time.
886             if self.remote_field.limit_choices_to:
887                 cls._meta.related_fkey_lookups.append(
888                     self.remote_field.limit_choices_to
889                 )
890 
891 
892 ForeignObject.register_lookup(RelatedIn)
893 ForeignObject.register_lookup(RelatedExact)
894 ForeignObject.register_lookup(RelatedLessThan)
895 ForeignObject.register_lookup(RelatedGreaterThan)
896 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
897 ForeignObject.register_lookup(RelatedLessThanOrEqual)
898 ForeignObject.register_lookup(RelatedIsNull)
899 
900 
901 class ForeignKey(ForeignObject):
902     """
903     Provide a many-to-one relation by adding a column to the local model
904     to hold the remote value.
905 
906     By default ForeignKey will target the pk of the remote model but this
907     behavior can be changed by using the ``to_field`` argument.
908     """
909 
910     descriptor_class = ForeignKeyDeferredAttribute
911     # Field flags
912     many_to_many = False
913     many_to_one = True
914     one_to_many = False
915     one_to_one = False
916 
917     rel_class = ManyToOneRel
918 
919     empty_strings_allowed = False
920     default_error_messages = {
921         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
922     }
923     description = _("Foreign Key (type determined by related field)")
924 
925     def __init__(
926         self,
927         to,
928         on_delete,
929         related_name=None,
930         related_query_name=None,
931         limit_choices_to=None,
932         parent_link=False,
933         to_field=None,
934         db_constraint=True,
935         **kwargs,
936     ):
937         try:
938             to._meta.model_name
939         except AttributeError:
940             if not isinstance(to, str):
941                 raise TypeError(
942                     "%s(%r) is invalid. First parameter to ForeignKey must be "
943                     "either a model, a model name, or the string %r"
944                     % (
945                         self.__class__.__name__,
946                         to,
947                         RECURSIVE_RELATIONSHIP_CONSTANT,
948                     )
949                 )
950         else:
951             # For backwards compatibility purposes, we need to *try* and set
952             # the to_field during FK construction. It won't be guaranteed to
953             # be correct until contribute_to_class is called. Refs #12190.
954             to_field = to_field or (to._meta.pk and to._meta.pk.name)
955         if not callable(on_delete):
956             raise TypeError("on_delete must be callable.")
957 
958         kwargs["rel"] = self.rel_class(
959             self,
960             to,
961             to_field,
962             related_name=related_name,
963             related_query_name=related_query_name,
964             limit_choices_to=limit_choices_to,
965             parent_link=parent_link,
966             on_delete=on_delete,
967         )
968         kwargs.setdefault("db_index", True)
969 
970         super().__init__(
971             to,
972             on_delete,
973             related_name=related_name,
974             related_query_name=related_query_name,
975             limit_choices_to=limit_choices_to,
976             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
977             to_fields=[to_field],
978             **kwargs,
979         )
980         self.db_constraint = db_constraint
981 
982     def __class_getitem__(cls, *args, **kwargs):
983         return cls
984 
985     def check(self, **kwargs):
986         return [
987             *super().check(**kwargs),
988             *self._check_on_delete(),
989             *self._check_unique(),
990         ]
991 
992     def _check_on_delete(self):
993         on_delete = getattr(self.remote_field, "on_delete", None)
994         if on_delete == SET_NULL and not self.null:
995             return [
996                 checks.Error(
997                     "Field specifies on_delete=SET_NULL, but cannot be null.",
998                     hint=(
999                         "Set null=True argument on the field, or change the on_delete "
1000                         "rule."
1001                     ),
1002                     obj=self,
1003                     id="fields.E320",
1004                 )
1005             ]
1006         elif on_delete == SET_DEFAULT and not self.has_default():
1007             return [
1008                 checks.Error(
1009                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1010                     hint="Set a default value, or change the on_delete rule.",
1011                     obj=self,
1012                     id="fields.E321",
1013                 )
1014             ]
1015         else:
1016             return []
1017 
1018     def _check_unique(self, **kwargs):
1019         return (
1020             [
1021                 checks.Warning(
1022                     "Setting unique=True on a ForeignKey has the same effect as using "
1023                     "a OneToOneField.",
1024                     hint=(
1025                         "ForeignKey(unique=True) is usually better served by a "
1026                         "OneToOneField."
1027                     ),
1028                     obj=self,
1029                     id="fields.W342",
1030                 )
1031             ]
1032             if self.unique
1033             else []
1034         )
1035 
1036     def deconstruct(self):
1037         name, path, args, kwargs = super().deconstruct()
1038         del kwargs["to_fields"]
1039         del kwargs["from_fields"]
1040         # Handle the simpler arguments
1041         if self.db_index:
1042             del kwargs["db_index"]
1043         else:
1044             kwargs["db_index"] = False
1045         if self.db_constraint is not True:
1046             kwargs["db_constraint"] = self.db_constraint
1047         # Rel needs more work.
1048         to_meta = getattr(self.remote_field.model, "_meta", None)
1049         if self.remote_field.field_name and (
1050             not to_meta
1051             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1052         ):
1053             kwargs["to_field"] = self.remote_field.field_name
1054         return name, path, args, kwargs
1055 
1056     def to_python(self, value):
1057         return self.target_field.to_python(value)
1058 
1059     @property
1060     def target_field(self):
1061         return self.foreign_related_fields[0]
1062 
1063     def get_reverse_path_info(self, filtered_relation=None):
1064         """Get path from the related model to this field's model."""
1065         opts = self.model._meta
1066         from_opts = self.remote_field.model._meta
1067         return [
1068             PathInfo(
1069                 from_opts=from_opts,
1070                 to_opts=opts,
1071                 target_fields=(opts.pk,),
1072                 join_field=self.remote_field,
1073                 m2m=not self.unique,
1074                 direct=False,
1075                 filtered_relation=filtered_relation,
1076             )
1077         ]
1078 
1079     def validate(self, value, model_instance):
1080         if self.remote_field.parent_link:
1081             return
1082         super().validate(value, model_instance)
1083         if value is None:
1084             return
1085 
1086         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1087         qs = self.remote_field.model._base_manager.using(using).filter(
1088             **{self.remote_field.field_name: value}
1089         )
1090         qs = qs.complex_filter(self.get_limit_choices_to())
1091         if not qs.exists():
1092             raise exceptions.ValidationError(
1093                 self.error_messages["invalid"],
1094                 code="invalid",
1095                 params={
1096                     "model": self.remote_field.model._meta.verbose_name,
1097                     "pk": value,
1098                     "field": self.remote_field.field_name,
1099                     "value": value,
1100                 },  # 'pk' is included for backwards compatibility
1101             )
1102 
1103     def resolve_related_fields(self):
1104         related_fields = super().resolve_related_fields()
1105         for from_field, to_field in related_fields:
1106             if (
1107                 to_field
1108                 and to_field.model != self.remote_field.model._meta.concrete_model
1109             ):
1110                 raise exceptions.FieldError(
1111                     "'%s.%s' refers to field '%s' which is not local to model "
1112                     "'%s'."
1113                     % (
1114                         self.model._meta.label,
1115                         self.name,
1116                         to_field.name,
1117                         self.remote_field.model._meta.concrete_model._meta.label,
1118                     )
1119                 )
1120         return related_fields
1121 
1122     def get_attname(self):
1123         return "%s_id" % self.name
1124 
1125     def get_attname_column(self):
1126         attname = self.get_attname()
1127         column = self.db_column or attname
1128         return attname, column
1129 
1130     def get_default(self):
1131         """Return the to_field if the default value is an object."""
1132         field_default = super().get_default()
1133         if isinstance(field_default, self.remote_field.model):
1134             return getattr(field_default, self.target_field.attname)
1135         return field_default
1136 
1137     def get_db_prep_save(self, value, connection):
1138         if value is None or (
1139             value == ""
1140             and (
1141                 not self.target_field.empty_strings_allowed
1142                 or connection.features.interprets_empty_strings_as_nulls
1143             )
1144         ):
1145             return None
1146         else:
1147             return self.target_field.get_db_prep_save(value, connection=connection)
1148 
1149     def get_db_prep_value(self, value, connection, prepared=False):
1150         return self.target_field.get_db_prep_value(value, connection, prepared)
1151 
1152     def get_prep_value(self, value):
1153         return self.target_field.get_prep_value(value)
1154 
1155     def contribute_to_related_class(self, cls, related):
1156         super().contribute_to_related_class(cls, related)
1157         if self.remote_field.field_name is None:
1158             self.remote_field.field_name = cls._meta.pk.name
1159 
1160     def formfield(self, *, using=None, **kwargs):
1161         if isinstance(self.remote_field.model, str):
1162             raise ValueError(
1163                 "Cannot create form field for %r yet, because "
1164                 "its related model %r has not been loaded yet"
1165                 % (self.name, self.remote_field.model)
1166             )
1167         return super().formfield(
1168             **{
1169                 "form_class": forms.ModelChoiceField,
1170                 "queryset": self.remote_field.model._default_manager.using(using),
1171                 "to_field_name": self.remote_field.field_name,
1172                 **kwargs,
1173                 "blank": self.blank,
1174             }
1175         )
1176 
1177     def db_check(self, connection):
1178         return None
1179 
1180     def db_type(self, connection):
1181         return self.target_field.rel_db_type(connection=connection)
1182 
1183     def db_parameters(self, connection):
1184         target_db_parameters = self.target_field.db_parameters(connection)
1185         return {
1186             "type": self.db_type(connection),
1187             "check": self.db_check(connection),
1188             "collation": target_db_parameters.get("collation"),
1189         }
1190 
1191     def convert_empty_strings(self, value, expression, connection):
1192         if (not value) and isinstance(value, str):
1193             return None
1194         return value
1195 
1196     def get_db_converters(self, connection):
1197         converters = super().get_db_converters(connection)
1198         if connection.features.interprets_empty_strings_as_nulls:
1199             converters += [self.convert_empty_strings]
1200         return converters
1201 
1202     def get_col(self, alias, output_field=None):
1203         if output_field is None:
1204             output_field = self.target_field
1205             while isinstance(output_field, ForeignKey):
1206                 output_field = output_field.target_field
1207                 if output_field is self:
1208                     raise ValueError("Cannot resolve output_field.")
1209         return super().get_col(alias, output_field)
1210 
1211 
1212 class OneToOneField(ForeignKey):
1213     """
1214     A OneToOneField is essentially the same as a ForeignKey, with the exception
1215     that it always carries a "unique" constraint with it and the reverse
1216     relation always returns the object pointed to (since there will only ever
1217     be one), rather than returning a list.
1218     """
1219 
1220     # Field flags
1221     many_to_many = False
1222     many_to_one = False
1223     one_to_many = False
1224     one_to_one = True
1225 
1226     related_accessor_class = ReverseOneToOneDescriptor
1227     forward_related_accessor_class = ForwardOneToOneDescriptor
1228     rel_class = OneToOneRel
1229 
1230     description = _("One-to-one relationship")
1231 
1232     def __init__(self, to, on_delete, to_field=None, **kwargs):
1233         kwargs["unique"] = True
1234         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1235 
1236     def deconstruct(self):
1237         name, path, args, kwargs = super().deconstruct()
1238         if "unique" in kwargs:
1239             del kwargs["unique"]
1240         return name, path, args, kwargs
1241 
1242     def formfield(self, **kwargs):
1243         if self.remote_field.parent_link:
1244             return None
1245         return super().formfield(**kwargs)
1246 
1247     def save_form_data(self, instance, data):
1248         if isinstance(data, self.remote_field.model):
1249             setattr(instance, self.name, data)
1250         else:
1251             setattr(instance, self.attname, data)
1252             # Remote field object must be cleared otherwise Model.save()
1253             # will reassign attname using the related object pk.
1254             if data is None:
1255                 setattr(instance, self.name, data)
1256 
1257     def _check_unique(self, **kwargs):
1258         # Override ForeignKey since check isn't applicable here.
1259         return []
1260 
1261 
1262 def create_many_to_many_intermediary_model(field, klass):
1263     from django.db import models
1264 
1265     def set_managed(model, related, through):
1266         through._meta.managed = model._meta.managed or related._meta.managed
1267 
1268     to_model = resolve_relation(klass, field.remote_field.model)
1269     name = "%s_%s" % (klass._meta.object_name, field.name)
1270     lazy_related_operation(set_managed, klass, to_model, name)
1271 
1272     to = make_model_tuple(to_model)[1]
1273     from_ = klass._meta.model_name
1274     if to == from_:
1275         to = "to_%s" % to
1276         from_ = "from_%s" % from_
1277 
1278     meta = type(
1279         "Meta",
1280         (),
1281         {
1282             "db_table": field._get_m2m_db_table(klass._meta),
1283             "auto_created": klass,
1284             "app_label": klass._meta.app_label,
1285             "db_tablespace": klass._meta.db_tablespace,
1286             "unique_together": (from_, to),
1287             "verbose_name": _("%(from)s-%(to)s relationship")
1288             % {"from": from_, "to": to},
1289             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1290             % {"from": from_, "to": to},
1291             "apps": field.model._meta.apps,
1292         },
1293     )
1294     # Construct and return the new class.
1295     return type(
1296         name,
1297         (models.Model,),
1298         {
1299             "Meta": meta,
1300             "__module__": klass.__module__,
1301             from_: models.ForeignKey(
1302                 klass,
1303                 related_name="%s+" % name,
1304                 db_tablespace=field.db_tablespace,
1305                 db_constraint=field.remote_field.db_constraint,
1306                 on_delete=CASCADE,
1307             ),
1308             to: models.ForeignKey(
1309                 to_model,
1310                 related_name="%s+" % name,
1311                 db_tablespace=field.db_tablespace,
1312                 db_constraint=field.remote_field.db_constraint,
1313                 on_delete=CASCADE,
1314             ),
1315         },
1316     )
1317 
1318 
1319 class ManyToManyField(RelatedField):
1320     """
1321     Provide a many-to-many relation by using an intermediary model that
1322     holds two ForeignKey fields pointed at the two sides of the relation.
1323 
1324     Unless a ``through`` model was provided, ManyToManyField will use the
1325     create_many_to_many_intermediary_model factory to automatically generate
1326     the intermediary model.
1327     """
1328 
1329     # Field flags
1330     many_to_many = True
1331     many_to_one = False
1332     one_to_many = False
1333     one_to_one = False
1334 
1335     rel_class = ManyToManyRel
1336 
1337     description = _("Many-to-many relationship")
1338 
1339     def __init__(
1340         self,
1341         to,
1342         related_name=None,
1343         related_query_name=None,
1344         limit_choices_to=None,
1345         symmetrical=None,
1346         through=None,
1347         through_fields=None,
1348         db_constraint=True,
1349         db_table=None,
1350         swappable=True,
1351         **kwargs,
1352     ):
1353         try:
1354             to._meta
1355         except AttributeError:
1356             if not isinstance(to, str):
1357                 raise TypeError(
1358                     "%s(%r) is invalid. First parameter to ManyToManyField "
1359                     "must be either a model, a model name, or the string %r"
1360                     % (
1361                         self.__class__.__name__,
1362                         to,
1363                         RECURSIVE_RELATIONSHIP_CONSTANT,
1364                     )
1365                 )
1366 
1367         if symmetrical is None:
1368             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1369 
1370         if through is not None and db_table is not None:
1371             raise ValueError(
1372                 "Cannot specify a db_table if an intermediary model is used."
1373             )
1374 
1375         kwargs["rel"] = self.rel_class(
1376             self,
1377             to,
1378             related_name=related_name,
1379             related_query_name=related_query_name,
1380             limit_choices_to=limit_choices_to,
1381             symmetrical=symmetrical,
1382             through=through,
1383             through_fields=through_fields,
1384             db_constraint=db_constraint,
1385         )
1386         self.has_null_arg = "null" in kwargs
1387 
1388         super().__init__(
1389             related_name=related_name,
1390             related_query_name=related_query_name,
1391             limit_choices_to=limit_choices_to,
1392             **kwargs,
1393         )
1394 
1395         self.db_table = db_table
1396         self.swappable = swappable
1397 
1398     def check(self, **kwargs):
1399         return [
1400             *super().check(**kwargs),
1401             *self._check_unique(**kwargs),
1402             *self._check_relationship_model(**kwargs),
1403             *self._check_ignored_options(**kwargs),
1404             *self._check_table_uniqueness(**kwargs),
1405         ]
1406 
1407     def _check_unique(self, **kwargs):
1408         if self.unique:
1409             return [
1410                 checks.Error(
1411                     "ManyToManyFields cannot be unique.",
1412                     obj=self,
1413                     id="fields.E330",
1414                 )
1415             ]
1416         return []
1417 
1418     def _check_ignored_options(self, **kwargs):
1419         warnings = []
1420 
1421         if self.has_null_arg:
1422             warnings.append(
1423                 checks.Warning(
1424                     "null has no effect on ManyToManyField.",
1425                     obj=self,
1426                     id="fields.W340",
1427                 )
1428             )
1429 
1430         if self._validators:
1431             warnings.append(
1432                 checks.Warning(
1433                     "ManyToManyField does not support validators.",
1434                     obj=self,
1435                     id="fields.W341",
1436                 )
1437             )
1438         if self.remote_field.symmetrical and self._related_name:
1439             warnings.append(
1440                 checks.Warning(
1441                     "related_name has no effect on ManyToManyField "
1442                     'with a symmetrical relationship, e.g. to "self".',
1443                     obj=self,
1444                     id="fields.W345",
1445                 )
1446             )
1447 
1448         return warnings
1449 
1450     def _check_relationship_model(self, from_model=None, **kwargs):
1451         if hasattr(self.remote_field.through, "_meta"):
1452             qualified_model_name = "%s.%s" % (
1453                 self.remote_field.through._meta.app_label,
1454                 self.remote_field.through.__name__,
1455             )
1456         else:
1457             qualified_model_name = self.remote_field.through
1458 
1459         errors = []
1460 
1461         if self.remote_field.through not in self.opts.apps.get_models(
1462             include_auto_created=True
1463         ):
1464             # The relationship model is not installed.
1465             errors.append(
1466                 checks.Error(
1467                     "Field specifies a many-to-many relation through model "
1468                     "'%s', which has not been installed." % qualified_model_name,
1469                     obj=self,
1470                     id="fields.E331",
1471                 )
1472             )
1473 
1474         else:
1475             assert from_model is not None, (
1476                 "ManyToManyField with intermediate "
1477                 "tables cannot be checked if you don't pass the model "
1478                 "where the field is attached to."
1479             )
1480             # Set some useful local variables
1481             to_model = resolve_relation(from_model, self.remote_field.model)
1482             from_model_name = from_model._meta.object_name
1483             if isinstance(to_model, str):
1484                 to_model_name = to_model
1485             else:
1486                 to_model_name = to_model._meta.object_name
1487             relationship_model_name = self.remote_field.through._meta.object_name
1488             self_referential = from_model == to_model
1489             # Count foreign keys in intermediate model
1490             if self_referential:
1491                 seen_self = sum(
1492                     from_model == getattr(field.remote_field, "model", None)
1493                     for field in self.remote_field.through._meta.fields
1494                 )
1495 
1496                 if seen_self > 2 and not self.remote_field.through_fields:
1497                     errors.append(
1498                         checks.Error(
1499                             "The model is used as an intermediate model by "
1500                             "'%s', but it has more than two foreign keys "
1501                             "to '%s', which is ambiguous. You must specify "
1502                             "which two foreign keys Django should use via the "
1503                             "through_fields keyword argument."
1504                             % (self, from_model_name),
1505                             hint=(
1506                                 "Use through_fields to specify which two foreign keys "
1507                                 "Django should use."
1508                             ),
1509                             obj=self.remote_field.through,
1510                             id="fields.E333",
1511                         )
1512                     )
1513 
1514             else:
1515                 # Count foreign keys in relationship model
1516                 seen_from = sum(
1517                     from_model == getattr(field.remote_field, "model", None)
1518                     for field in self.remote_field.through._meta.fields
1519                 )
1520                 seen_to = sum(
1521                     to_model == getattr(field.remote_field, "model", None)
1522                     for field in self.remote_field.through._meta.fields
1523                 )
1524 
1525                 if seen_from > 1 and not self.remote_field.through_fields:
1526                     errors.append(
1527                         checks.Error(
1528                             (
1529                                 "The model is used as an intermediate model by "
1530                                 "'%s', but it has more than one foreign key "
1531                                 "from '%s', which is ambiguous. You must specify "
1532                                 "which foreign key Django should use via the "
1533                                 "through_fields keyword argument."
1534                             )
1535                             % (self, from_model_name),
1536                             hint=(
1537                                 "If you want to create a recursive relationship, "
1538                                 'use ManyToManyField("%s", through="%s").'
1539                             )
1540                             % (
1541                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1542                                 relationship_model_name,
1543                             ),
1544                             obj=self,
1545                             id="fields.E334",
1546                         )
1547                     )
1548 
1549                 if seen_to > 1 and not self.remote_field.through_fields:
1550                     errors.append(
1551                         checks.Error(
1552                             "The model is used as an intermediate model by "
1553                             "'%s', but it has more than one foreign key "
1554                             "to '%s', which is ambiguous. You must specify "
1555                             "which foreign key Django should use via the "
1556                             "through_fields keyword argument." % (self, to_model_name),
1557                             hint=(
1558                                 "If you want to create a recursive relationship, "
1559                                 'use ManyToManyField("%s", through="%s").'
1560                             )
1561                             % (
1562                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1563                                 relationship_model_name,
1564                             ),
1565                             obj=self,
1566                             id="fields.E335",
1567                         )
1568                     )
1569 
1570                 if seen_from == 0 or seen_to == 0:
1571                     errors.append(
1572                         checks.Error(
1573                             "The model is used as an intermediate model by "
1574                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1575                             % (self, from_model_name, to_model_name),
1576                             obj=self.remote_field.through,
1577                             id="fields.E336",
1578                         )
1579                     )
1580 
1581         # Validate `through_fields`.
1582         if self.remote_field.through_fields is not None:
1583             # Validate that we're given an iterable of at least two items
1584             # and that none of them is "falsy".
1585             if not (
1586                 len(self.remote_field.through_fields) >= 2
1587                 and self.remote_field.through_fields[0]
1588                 and self.remote_field.through_fields[1]
1589             ):
1590                 errors.append(
1591                     checks.Error(
1592                         "Field specifies 'through_fields' but does not provide "
1593                         "the names of the two link fields that should be used "
1594                         "for the relation through model '%s'." % qualified_model_name,
1595                         hint=(
1596                             "Make sure you specify 'through_fields' as "
1597                             "through_fields=('field1', 'field2')"
1598                         ),
1599                         obj=self,
1600                         id="fields.E337",
1601                     )
1602                 )
1603 
1604             # Validate the given through fields -- they should be actual
1605             # fields on the through model, and also be foreign keys to the
1606             # expected models.
1607             else:
1608                 assert from_model is not None, (
1609                     "ManyToManyField with intermediate "
1610                     "tables cannot be checked if you don't pass the model "
1611                     "where the field is attached to."
1612                 )
1613 
1614                 source, through, target = (
1615                     from_model,
1616                     self.remote_field.through,
1617                     self.remote_field.model,
1618                 )
1619                 source_field_name, target_field_name = self.remote_field.through_fields[
1620                     :2
1621                 ]
1622 
1623                 for field_name, related_model in (
1624                     (source_field_name, source),
1625                     (target_field_name, target),
1626                 ):
1627 
1628                     possible_field_names = []
1629                     for f in through._meta.fields:
1630                         if (
1631                             hasattr(f, "remote_field")
1632                             and getattr(f.remote_field, "model", None) == related_model
1633                         ):
1634                             possible_field_names.append(f.name)
1635                     if possible_field_names:
1636                         hint = (
1637                             "Did you mean one of the following foreign keys to '%s': "
1638                             "%s?"
1639                             % (
1640                                 related_model._meta.object_name,
1641                                 ", ".join(possible_field_names),
1642                             )
1643                         )
1644                     else:
1645                         hint = None
1646 
1647                     try:
1648                         field = through._meta.get_field(field_name)
1649                     except exceptions.FieldDoesNotExist:
1650                         errors.append(
1651                             checks.Error(
1652                                 "The intermediary model '%s' has no field '%s'."
1653                                 % (qualified_model_name, field_name),
1654                                 hint=hint,
1655                                 obj=self,
1656                                 id="fields.E338",
1657                             )
1658                         )
1659                     else:
1660                         if not (
1661                             hasattr(field, "remote_field")
1662                             and getattr(field.remote_field, "model", None)
1663                             == related_model
1664                         ):
1665                             errors.append(
1666                                 checks.Error(
1667                                     "'%s.%s' is not a foreign key to '%s'."
1668                                     % (
1669                                         through._meta.object_name,
1670                                         field_name,
1671                                         related_model._meta.object_name,
1672                                     ),
1673                                     hint=hint,
1674                                     obj=self,
1675                                     id="fields.E339",
1676                                 )
1677                             )
1678 
1679         return errors
1680 
1681     def _check_table_uniqueness(self, **kwargs):
1682         if (
1683             isinstance(self.remote_field.through, str)
1684             or not self.remote_field.through._meta.managed
1685         ):
1686             return []
1687         registered_tables = {
1688             model._meta.db_table: model
1689             for model in self.opts.apps.get_models(include_auto_created=True)
1690             if model != self.remote_field.through and model._meta.managed
1691         }
1692         m2m_db_table = self.m2m_db_table()
1693         model = registered_tables.get(m2m_db_table)
1694         # The second condition allows multiple m2m relations on a model if
1695         # some point to a through model that proxies another through model.
1696         if (
1697             model
1698             and model._meta.concrete_model
1699             != self.remote_field.through._meta.concrete_model
1700         ):
1701             if model._meta.auto_created:
1702 
1703                 def _get_field_name(model):
1704                     for field in model._meta.auto_created._meta.many_to_many:
1705                         if field.remote_field.through is model:
1706                             return field.name
1707 
1708                 opts = model._meta.auto_created._meta
1709                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1710             else:
1711                 clashing_obj = model._meta.label
1712             if settings.DATABASE_ROUTERS:
1713                 error_class, error_id = checks.Warning, "fields.W344"
1714                 error_hint = (
1715                     "You have configured settings.DATABASE_ROUTERS. Verify "
1716                     "that the table of %r is correctly routed to a separate "
1717                     "database." % clashing_obj
1718                 )
1719             else:
1720                 error_class, error_id = checks.Error, "fields.E340"
1721                 error_hint = None
1722             return [
1723                 error_class(
1724                     "The field's intermediary table '%s' clashes with the "
1725                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1726                     obj=self,
1727                     hint=error_hint,
1728                     id=error_id,
1729                 )
1730             ]
1731         return []
1732 
1733     def deconstruct(self):
1734         name, path, args, kwargs = super().deconstruct()
1735         # Handle the simpler arguments.
1736         if self.db_table is not None:
1737             kwargs["db_table"] = self.db_table
1738         if self.remote_field.db_constraint is not True:
1739             kwargs["db_constraint"] = self.remote_field.db_constraint
1740         # Lowercase model names as they should be treated as case-insensitive.
1741         if isinstance(self.remote_field.model, str):
1742             if "." in self.remote_field.model:
1743                 app_label, model_name = self.remote_field.model.split(".")
1744                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1745             else:
1746                 kwargs["to"] = self.remote_field.model.lower()
1747         else:
1748             kwargs["to"] = self.remote_field.model._meta.label_lower
1749         if getattr(self.remote_field, "through", None) is not None:
1750             if isinstance(self.remote_field.through, str):
1751                 kwargs["through"] = self.remote_field.through
1752             elif not self.remote_field.through._meta.auto_created:
1753                 kwargs["through"] = self.remote_field.through._meta.label
1754         # If swappable is True, then see if we're actually pointing to the target
1755         # of a swap.
1756         swappable_setting = self.swappable_setting
1757         if swappable_setting is not None:
1758             # If it's already a settings reference, error.
1759             if hasattr(kwargs["to"], "setting_name"):
1760                 if kwargs["to"].setting_name != swappable_setting:
1761                     raise ValueError(
1762                         "Cannot deconstruct a ManyToManyField pointing to a "
1763                         "model that is swapped in place of more than one model "
1764                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1765                     )
1766 
1767             kwargs["to"] = SettingsReference(
1768                 kwargs["to"],
1769                 swappable_setting,
1770             )
1771         return name, path, args, kwargs
1772 
1773     def _get_path_info(self, direct=False, filtered_relation=None):
1774         """Called by both direct and indirect m2m traversal."""
1775         int_model = self.remote_field.through
1776         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1777         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1778         if direct:
1779             join1infos = linkfield1.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield2.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield2.path_infos
1784         else:
1785             join1infos = linkfield2.reverse_path_infos
1786             if filtered_relation:
1787                 join2infos = linkfield1.get_path_info(filtered_relation)
1788             else:
1789                 join2infos = linkfield1.path_infos
1790         # Get join infos between the last model of join 1 and the first model
1791         # of join 2. Assume the only reason these may differ is due to model
1792         # inheritance.
1793         join1_final = join1infos[-1].to_opts
1794         join2_initial = join2infos[0].from_opts
1795         if join1_final is join2_initial:
1796             intermediate_infos = []
1797         elif issubclass(join1_final.model, join2_initial.model):
1798             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1799         else:
1800             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1801 
1802         return [*join1infos, *intermediate_infos, *join2infos]
1803 
1804     def get_path_info(self, filtered_relation=None):
1805         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1806 
1807     @cached_property
1808     def path_infos(self):
1809         return self.get_path_info()
1810 
1811     def get_reverse_path_info(self, filtered_relation=None):
1812         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1813 
1814     @cached_property
1815     def reverse_path_infos(self):
1816         return self.get_reverse_path_info()
1817 
1818     def _get_m2m_db_table(self, opts):
1819         """
1820         Function that can be curried to provide the m2m table name for this
1821         relation.
1822         """
1823         if self.remote_field.through is not None:
1824             return self.remote_field.through._meta.db_table
1825         elif self.db_table:
1826             return self.db_table
1827         else:
1828             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1829             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1830 
1831     def _get_m2m_attr(self, related, attr):
1832         """
1833         Function that can be curried to provide the source accessor or DB
1834         column name for the m2m table.
1835         """
1836         cache_attr = "_m2m_%s_cache" % attr
1837         if hasattr(self, cache_attr):
1838             return getattr(self, cache_attr)
1839         if self.remote_field.through_fields is not None:
1840             link_field_name = self.remote_field.through_fields[0]
1841         else:
1842             link_field_name = None
1843         for f in self.remote_field.through._meta.fields:
1844             if (
1845                 f.is_relation
1846                 and f.remote_field.model == related.related_model
1847                 and (link_field_name is None or link_field_name == f.name)
1848             ):
1849                 setattr(self, cache_attr, getattr(f, attr))
1850                 return getattr(self, cache_attr)
1851 
1852     def _get_m2m_reverse_attr(self, related, attr):
1853         """
1854         Function that can be curried to provide the related accessor or DB
1855         column name for the m2m table.
1856         """
1857         cache_attr = "_m2m_reverse_%s_cache" % attr
1858         if hasattr(self, cache_attr):
1859             return getattr(self, cache_attr)
1860         found = False
1861         if self.remote_field.through_fields is not None:
1862             link_field_name = self.remote_field.through_fields[1]
1863         else:
1864             link_field_name = None
1865         for f in self.remote_field.through._meta.fields:
1866             if f.is_relation and f.remote_field.model == related.model:
1867                 if link_field_name is None and related.related_model == related.model:
1868                     # If this is an m2m-intermediate to self,
1869                     # the first foreign key you find will be
1870                     # the source column. Keep searching for
1871                     # the second foreign key.
1872                     if found:
1873                         setattr(self, cache_attr, getattr(f, attr))
1874                         break
1875                     else:
1876                         found = True
1877                 elif link_field_name is None or link_field_name == f.name:
1878                     setattr(self, cache_attr, getattr(f, attr))
1879                     break
1880         return getattr(self, cache_attr)
1881 
1882     def contribute_to_class(self, cls, name, **kwargs):
1883         # To support multiple relations to self, it's useful to have a non-None
1884         # related name on symmetrical relations for internal reasons. The
1885         # concept doesn't make a lot of sense externally ("you want me to
1886         # specify *what* on my non-reversible relation?!"), so we set it up
1887         # automatically. The funky name reduces the chance of an accidental
1888         # clash.
1889         if self.remote_field.symmetrical and (
1890             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1891             or self.remote_field.model == cls._meta.object_name
1892         ):
1893             self.remote_field.related_name = "%s_rel_+" % name
1894         elif self.remote_field.is_hidden():
1895             # If the backwards relation is disabled, replace the original
1896             # related_name with one generated from the m2m field name. Django
1897             # still uses backwards relations internally and we need to avoid
1898             # clashes between multiple m2m fields with related_name == '+'.
1899             self.remote_field.related_name = "_%s_%s_%s_+" % (
1900                 cls._meta.app_label,
1901                 cls.__name__.lower(),
1902                 name,
1903             )
1904 
1905         super().contribute_to_class(cls, name, **kwargs)
1906 
1907         # The intermediate m2m model is not auto created if:
1908         #  1) There is a manually specified intermediate, or
1909         #  2) The class owning the m2m field is abstract.
1910         #  3) The class owning the m2m field has been swapped out.
1911         if not cls._meta.abstract:
1912             if self.remote_field.through:
1913 
1914                 def resolve_through_model(_, model, field):
1915                     field.remote_field.through = model
1916 
1917                 lazy_related_operation(
1918                     resolve_through_model, cls, self.remote_field.through, field=self
1919                 )
1920             elif not cls._meta.swapped:
1921                 self.remote_field.through = create_many_to_many_intermediary_model(
1922                     self, cls
1923                 )
1924 
1925         # Add the descriptor for the m2m relation.
1926         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1927 
1928         # Set up the accessor for the m2m table name for the relation.
1929         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1930 
1931     def contribute_to_related_class(self, cls, related):
1932         # Internal M2Ms (i.e., those with a related name ending with '+')
1933         # and swapped models don't get a related descriptor.
1934         if (
1935             not self.remote_field.is_hidden()
1936             and not related.related_model._meta.swapped
1937         ):
1938             setattr(
1939                 cls,
1940                 related.get_accessor_name(),
1941                 ManyToManyDescriptor(self.remote_field, reverse=True),
1942             )
1943 
1944         # Set up the accessors for the column names on the m2m table.
1945         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1946         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1947 
1948         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1949         self.m2m_reverse_field_name = partial(
1950             self._get_m2m_reverse_attr, related, "name"
1951         )
1952 
1953         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1954         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1955         get_m2m_reverse_rel = partial(
1956             self._get_m2m_reverse_attr, related, "remote_field"
1957         )
1958         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1959 
1960     def set_attributes_from_rel(self):
1961         pass
1962 
1963     def value_from_object(self, obj):
1964         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1965 
1966     def save_form_data(self, instance, data):
1967         getattr(instance, self.attname).set(data)
1968 
1969     def formfield(self, *, using=None, **kwargs):
1970         defaults = {
1971             "form_class": forms.ModelMultipleChoiceField,
1972             "queryset": self.remote_field.model._default_manager.using(using),
1973             **kwargs,
1974         }
1975         # If initial is passed in, it's a list of related objects, but the
1976         # MultipleChoiceField takes a list of IDs.
1977         if defaults.get("initial") is not None:
1978             initial = defaults["initial"]
1979             if callable(initial):
1980                 initial = initial()
1981             defaults["initial"] = [i.pk for i in initial]
1982         return super().formfield(**defaults)
1983 
1984     def db_check(self, connection):
1985         return None
1986 
1987     def db_type(self, connection):
1988         # A ManyToManyField is not represented by a single column,
1989         # so return None.
1990         return None
1991 
1992     def db_parameters(self, connection):
1993         return {"type": None, "check": None}

</code><intended_behavior>Ensure that when a ManyToManyField targets 'self', Django's migration framework correctly adjusts the underlying database schema, specifically creating or modifying the necessary intermediary table columns to reflect the self-referencing nature of the field.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>migrate</method>
<code>
94     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
95         """
96         Migrate the database up to the given targets.
97 
98         Django first needs to create all project states before a migration is
99         (un)applied and in a second step run all the database operations.
100         """
101         # The django_migrations table must be present to record applied
102         # migrations, but don't create it if there are no migrations to apply.
103         if plan == []:
104             if not self.recorder.has_table():
105                 return self._create_project_state(with_applied_migrations=False)
106         else:
107             self.recorder.ensure_schema()
108 
109         if plan is None:
110             plan = self.migration_plan(targets)
111         # Create the forwards plan Django would follow on an empty database
112         full_plan = self.migration_plan(
113             self.loader.graph.leaf_nodes(), clean_start=True
114         )
115 
116         all_forwards = all(not backwards for mig, backwards in plan)
117         all_backwards = all(backwards for mig, backwards in plan)
118 
119         if not plan:
120             if state is None:
121                 # The resulting state should include applied migrations.
122                 state = self._create_project_state(with_applied_migrations=True)
123         elif all_forwards == all_backwards:
124             # This should only happen if there's a mixed plan
125             raise InvalidMigrationPlan(
126                 "Migration plans with both forwards and backwards migrations "
127                 "are not supported. Please split your migration process into "
128                 "separate plans of only forwards OR backwards migrations.",
129                 plan,
130             )
131         elif all_forwards:
132             if state is None:
133                 # The resulting state should still include applied migrations.
134                 state = self._create_project_state(with_applied_migrations=True)
135             state = self._migrate_all_forwards(
136                 state, plan, full_plan, fake=fake, fake_initial=fake_initial
137             )
138         else:
139             # No need to check for `elif all_backwards` here, as that condition
140             # would always evaluate to true.
141             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
142 
143         self.check_replacements()
144 
145         return state

</code><intended_behavior>The migrate method must ensure that migrations involving changes to a ManyToManyField's target include the correct operations for adjusting the schema, especially when changing from a reference to another model to 'self'. This could involve creating specific checks or operations within the migration planning or execution phases that deal with self-referencing ManyToMany fields.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations
47                     and target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n
58                     for n in self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(
82                 self.loader.graph.leaf_nodes(), clean_start=True
83             )
84             applied_migrations = {
85                 self.loader.graph.nodes[key]
86                 for key in self.loader.applied_migrations
87                 if key in self.loader.graph.nodes
88             }
89             for migration, _ in full_plan:
90                 if migration in applied_migrations:
91                     migration.mutate_state(state, preserve=False)
92         return state
93 
94     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
95         """
96         Migrate the database up to the given targets.
97 
98         Django first needs to create all project states before a migration is
99         (un)applied and in a second step run all the database operations.
100         """
101         # The django_migrations table must be present to record applied
102         # migrations, but don't create it if there are no migrations to apply.
103         if plan == []:
104             if not self.recorder.has_table():
105                 return self._create_project_state(with_applied_migrations=False)
106         else:
107             self.recorder.ensure_schema()
108 
109         if plan is None:
110             plan = self.migration_plan(targets)
111         # Create the forwards plan Django would follow on an empty database
112         full_plan = self.migration_plan(
113             self.loader.graph.leaf_nodes(), clean_start=True
114         )
115 
116         all_forwards = all(not backwards for mig, backwards in plan)
117         all_backwards = all(backwards for mig, backwards in plan)
118 
119         if not plan:
120             if state is None:
121                 # The resulting state should include applied migrations.
122                 state = self._create_project_state(with_applied_migrations=True)
123         elif all_forwards == all_backwards:
124             # This should only happen if there's a mixed plan
125             raise InvalidMigrationPlan(
126                 "Migration plans with both forwards and backwards migrations "
127                 "are not supported. Please split your migration process into "
128                 "separate plans of only forwards OR backwards migrations.",
129                 plan,
130             )
131         elif all_forwards:
132             if state is None:
133                 # The resulting state should still include applied migrations.
134                 state = self._create_project_state(with_applied_migrations=True)
135             state = self._migrate_all_forwards(
136                 state, plan, full_plan, fake=fake, fake_initial=fake_initial
137             )
138         else:
139             # No need to check for `elif all_backwards` here, as that condition
140             # would always evaluate to true.
141             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
142 
143         self.check_replacements()
144 
145         return state
146 
147     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
148         """
149         Take a list of 2-tuples of the form (migration instance, False) and
150         apply them in the order they occur in the full_plan.
151         """
152         migrations_to_run = {m[0] for m in plan}
153         for migration, _ in full_plan:
154             if not migrations_to_run:
155                 # We remove every migration that we applied from these sets so
156                 # that we can bail out once the last migration has been applied
157                 # and don't always run until the very end of the migration
158                 # process.
159                 break
160             if migration in migrations_to_run:
161                 if "apps" not in state.__dict__:
162                     if self.progress_callback:
163                         self.progress_callback("render_start")
164                     state.apps  # Render all -- performance critical
165                     if self.progress_callback:
166                         self.progress_callback("render_success")
167                 state = self.apply_migration(
168                     state, migration, fake=fake, fake_initial=fake_initial
169                 )
170                 migrations_to_run.remove(migration)
171 
172         return state
173 
174     def _migrate_all_backwards(self, plan, full_plan, fake):
175         """
176         Take a list of 2-tuples of the form (migration instance, True) and
177         unapply them in reverse order they occur in the full_plan.
178 
179         Since unapplying a migration requires the project state prior to that
180         migration, Django will compute the migration states before each of them
181         in a first run over the plan and then unapply them in a second run over
182         the plan.
183         """
184         migrations_to_run = {m[0] for m in plan}
185         # Holds all migration states prior to the migrations being unapplied
186         states = {}
187         state = self._create_project_state()
188         applied_migrations = {
189             self.loader.graph.nodes[key]
190             for key in self.loader.applied_migrations
191             if key in self.loader.graph.nodes
192         }
193         if self.progress_callback:
194             self.progress_callback("render_start")
195         for migration, _ in full_plan:
196             if not migrations_to_run:
197                 # We remove every migration that we applied from this set so
198                 # that we can bail out once the last migration has been applied
199                 # and don't always run until the very end of the migration
200                 # process.
201                 break
202             if migration in migrations_to_run:
203                 if "apps" not in state.__dict__:
204                     state.apps  # Render all -- performance critical
205                 # The state before this migration
206                 states[migration] = state
207                 # The old state keeps as-is, we continue with the new state
208                 state = migration.mutate_state(state, preserve=True)
209                 migrations_to_run.remove(migration)
210             elif migration in applied_migrations:
211                 # Only mutate the state if the migration is actually applied
212                 # to make sure the resulting state doesn't include changes
213                 # from unrelated migrations.
214                 migration.mutate_state(state, preserve=False)
215         if self.progress_callback:
216             self.progress_callback("render_success")
217 
218         for migration, _ in plan:
219             self.unapply_migration(states[migration], migration, fake=fake)
220             applied_migrations.remove(migration)
221 
222         # Generate the post migration state by starting from the state before
223         # the last migration is unapplied and mutating it to include all the
224         # remaining applied migrations.
225         last_unapplied_migration = plan[-1][0]
226         state = states[last_unapplied_migration]
227         for index, (migration, _) in enumerate(full_plan):
228             if migration == last_unapplied_migration:
229                 for migration, _ in full_plan[index:]:
230                     if migration in applied_migrations:
231                         migration.mutate_state(state, preserve=False)
232                 break
233 
234         return state
235 
236     def apply_migration(self, state, migration, fake=False, fake_initial=False):
237         """Run a migration forwards."""
238         migration_recorded = False
239         if self.progress_callback:
240             self.progress_callback("apply_start", migration, fake)
241         if not fake:
242             if fake_initial:
243                 # Test to see if this is an already-applied initial migration
244                 applied, state = self.detect_soft_applied(state, migration)
245                 if applied:
246                     fake = True
247             if not fake:
248                 # Alright, do it normally
249                 with self.connection.schema_editor(
250                     atomic=migration.atomic
251                 ) as schema_editor:
252                     state = migration.apply(state, schema_editor)
253                     if not schema_editor.deferred_sql:
254                         self.record_migration(migration)
255                         migration_recorded = True
256         if not migration_recorded:
257             self.record_migration(migration)
258         # Report progress
259         if self.progress_callback:
260             self.progress_callback("apply_success", migration, fake)
261         return state
262 
263     def record_migration(self, migration):
264         # For replacement migrations, record individual statuses
265         if migration.replaces:
266             for app_label, name in migration.replaces:
267                 self.recorder.record_applied(app_label, name)
268         else:
269             self.recorder.record_applied(migration.app_label, migration.name)
270 
271     def unapply_migration(self, state, migration, fake=False):
272         """Run a migration backwards."""
273         if self.progress_callback:
274             self.progress_callback("unapply_start", migration, fake)
275         if not fake:
276             with self.connection.schema_editor(
277                 atomic=migration.atomic
278             ) as schema_editor:
279                 state = migration.unapply(state, schema_editor)
280         # For replacement migrations, also record individual statuses.
281         if migration.replaces:
282             for app_label, name in migration.replaces:
283                 self.recorder.record_unapplied(app_label, name)
284         self.recorder.record_unapplied(migration.app_label, migration.name)
285         # Report progress
286         if self.progress_callback:
287             self.progress_callback("unapply_success", migration, fake)
288         return state
289 
290     def check_replacements(self):
291         """
292         Mark replacement migrations applied if their replaced set all are.
293 
294         Do this unconditionally on every migrate, rather than just when
295         migrations are applied or unapplied, to correctly handle the case
296         when a new squash migration is pushed to a deployment that already had
297         all its replaced migrations applied. In this case no new migration will
298         be applied, but the applied state of the squashed migration must be
299         maintained.
300         """
301         applied = self.recorder.applied_migrations()
302         for key, migration in self.loader.replacements.items():
303             all_applied = all(m in applied for m in migration.replaces)
304             if all_applied and key not in applied:
305                 self.recorder.record_applied(*key)
306 
307     def detect_soft_applied(self, project_state, migration):
308         """
309         Test whether a migration has been implicitly applied - that the
310         tables or columns it would create exist. This is intended only for use
311         on initial migrations (as it only looks for CreateModel and AddField).
312         """
313 
314         def should_skip_detecting_model(migration, model):
315             """
316             No need to detect tables for proxy models, unmanaged models, or
317             models that can't be migrated on the current database.
318             """
319             return (
320                 model._meta.proxy
321                 or not model._meta.managed
322                 or not router.allow_migrate(
323                     self.connection.alias,
324                     migration.app_label,
325                     model_name=model._meta.model_name,
326                 )
327             )
328 
329         if migration.initial is None:
330             # Bail if the migration isn't the first one in its app
331             if any(app == migration.app_label for app, name in migration.dependencies):
332                 return False, project_state
333         elif migration.initial is False:
334             # Bail if it's NOT an initial migration
335             return False, project_state
336 
337         if project_state is None:
338             after_state = self.loader.project_state(
339                 (migration.app_label, migration.name), at_end=True
340             )
341         else:
342             after_state = migration.mutate_state(project_state)
343         apps = after_state.apps
344         found_create_model_migration = False
345         found_add_field_migration = False
346         fold_identifier_case = self.connection.features.ignores_table_name_case
347         with self.connection.cursor() as cursor:
348             existing_table_names = set(
349                 self.connection.introspection.table_names(cursor)
350             )
351             if fold_identifier_case:
352                 existing_table_names = {
353                     name.casefold() for name in existing_table_names
354                 }
355         # Make sure all create model and add field operations are done
356         for operation in migration.operations:
357             if isinstance(operation, migrations.CreateModel):
358                 model = apps.get_model(migration.app_label, operation.name)
359                 if model._meta.swapped:
360                     # We have to fetch the model to test with from the
361                     # main app cache, as it's not a direct dependency.
362                     model = global_apps.get_model(model._meta.swapped)
363                 if should_skip_detecting_model(migration, model):
364                     continue
365                 db_table = model._meta.db_table
366                 if fold_identifier_case:
367                     db_table = db_table.casefold()
368                 if db_table not in existing_table_names:
369                     return False, project_state
370                 found_create_model_migration = True
371             elif isinstance(operation, migrations.AddField):
372                 model = apps.get_model(migration.app_label, operation.model_name)
373                 if model._meta.swapped:
374                     # We have to fetch the model to test with from the
375                     # main app cache, as it's not a direct dependency.
376                     model = global_apps.get_model(model._meta.swapped)
377                 if should_skip_detecting_model(migration, model):
378                     continue
379 
380                 table = model._meta.db_table
381                 field = model._meta.get_field(operation.name)
382 
383                 # Handle implicit many-to-many tables created by AddField.
384                 if field.many_to_many:
385                     through_db_table = field.remote_field.through._meta.db_table
386                     if fold_identifier_case:
387                         through_db_table = through_db_table.casefold()
388                     if through_db_table not in existing_table_names:
389                         return False, project_state
390                     else:
391                         found_add_field_migration = True
392                         continue
393                 with self.connection.cursor() as cursor:
394                     columns = self.connection.introspection.get_table_description(
395                         cursor, table
396                     )
397                 for column in columns:
398                     field_column = field.column
399                     column_name = column.name
400                     if fold_identifier_case:
401                         column_name = column_name.casefold()
402                         field_column = field_column.casefold()
403                     if column_name == field_column:
404                         found_add_field_migration = True
405                         break
406                 else:
407                     return False, project_state
408         # If we get this far and we found at least one CreateModel or AddField
409         # migration, the migration is considered implicitly applied.
410         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 06:29:21.083 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name %= {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_q = Q.create(
411             [
412                 (rh_field.attname, getattr(obj, lh_field.attname))
413                 for lh_field, rh_field in self.related_fields
414             ]
415         )
416         descriptor_filter = self.get_extra_descriptor_filter(obj)
417         if isinstance(descriptor_filter, dict):
418             return base_q & Q(**descriptor_filter)
419         elif descriptor_filter:
420             return base_q & descriptor_filter
421         return base_q
422 
423     @property
424     def swappable_setting(self):
425         """
426         Get the setting that this is powered from for swapping, or None
427         if it's not swapped in / marked with swappable=False.
428         """
429         if self.swappable:
430             # Work out string form of "to"
431             if isinstance(self.remote_field.model, str):
432                 to_string = self.remote_field.model
433             else:
434                 to_string = self.remote_field.model._meta.label
435             return apps.get_swappable_settings_name(to_string)
436         return None
437 
438     def set_attributes_from_rel(self):
439         self.name = self.name or (
440             self.remote_field.model._meta.model_name
441             + "_"
442             + self.remote_field.model._meta.pk.name
443         )
444         if self.verbose_name is None:
445             self.verbose_name = self.remote_field.model._meta.verbose_name
446         self.remote_field.set_field_name()
447 
448     def do_related_class(self, other, cls):
449         self.set_attributes_from_rel()
450         self.contribute_to_related_class(other, self.remote_field)
451 
452     def get_limit_choices_to(self):
453         """
454         Return ``limit_choices_to`` for this model field.
455 
456         If it is a callable, it will be invoked and the result will be
457         returned.
458         """
459         if callable(self.remote_field.limit_choices_to):
460             return self.remote_field.limit_choices_to()
461         return self.remote_field.limit_choices_to
462 
463     def formfield(self, **kwargs):
464         """
465         Pass ``limit_choices_to`` to the field being constructed.
466 
467         Only passes it if there is a type that supports related fields.
468         This is a similar strategy used to pass the ``queryset`` to the field
469         being constructed.
470         """
471         defaults = {}
472         if hasattr(self.remote_field, "get_related_field"):
473             # If this is a callable, do not invoke it here. Just pass
474             # it in the defaults for when the form class will later be
475             # instantiated.
476             limit_choices_to = self.remote_field.limit_choices_to
477             defaults.update(
478                 {
479                     "limit_choices_to": limit_choices_to,
480                 }
481             )
482         defaults.update(kwargs)
483         return super().formfield(**defaults)
484 
485     def related_query_name(self):
486         """
487         Define the name that can be used to identify this related object in a
488         table-spanning query.
489         """
490         return (
491             self.remote_field.related_query_name
492             or self.remote_field.related_name
493             or self.opts.model_name
494         )
495 
496     @property
497     def target_field(self):
498         """
499         When filtering against this relation, return the field on the remote
500         model against which the filtering should happen.
501         """
502         target_fields = self.path_infos[-1].target_fields
503         if len(target_fields) > 1:
504             raise exceptions.FieldError(
505                 "The relation has multiple target fields, but only single target field "
506                 "was asked for"
507             )
508         return target_fields[0]
509 
510     def get_cache_name(self):
511         return self.name
512 
513 
514 class ForeignObject(RelatedField):
515     """
516     Abstraction of the ForeignKey relation to support multi-column relations.
517     """
518 
519     # Field flags
520     many_to_many = False
521     many_to_one = True
522     one_to_many = False
523     one_to_one = False
524 
525     requires_unique_target = True
526     related_accessor_class = ReverseManyToOneDescriptor
527     forward_related_accessor_class = ForwardManyToOneDescriptor
528     rel_class = ForeignObjectRel
529 
530     def __init__(
531         self,
532         to,
533         on_delete,
534         from_fields,
535         to_fields,
536         rel=None,
537         related_name=None,
538         related_query_name=None,
539         limit_choices_to=None,
540         parent_link=False,
541         swappable=True,
542         **kwargs,
543     ):
544 
545         if rel is None:
546             rel = self.rel_class(
547                 self,
548                 to,
549                 related_name=related_name,
550                 related_query_name=related_query_name,
551                 limit_choices_to=limit_choices_to,
552                 parent_link=parent_link,
553                 on_delete=on_delete,
554             )
555 
556         super().__init__(
557             rel=rel,
558             related_name=related_name,
559             related_query_name=related_query_name,
560             limit_choices_to=limit_choices_to,
561             **kwargs,
562         )
563 
564         self.from_fields = from_fields
565         self.to_fields = to_fields
566         self.swappable = swappable
567 
568     def __copy__(self):
569         obj = super().__copy__()
570         # Remove any cached PathInfo values.
571         obj.__dict__.pop("path_infos", None)
572         obj.__dict__.pop("reverse_path_infos", None)
573         return obj
574 
575     def check(self, **kwargs):
576         return [
577             *super().check(**kwargs),
578             *self._check_to_fields_exist(),
579             *self._check_unique_target(),
580         ]
581 
582     def _check_to_fields_exist(self):
583         # Skip nonexistent models.
584         if isinstance(self.remote_field.model, str):
585             return []
586 
587         errors = []
588         for to_field in self.to_fields:
589             if to_field:
590                 try:
591                     self.remote_field.model._meta.get_field(to_field)
592                 except exceptions.FieldDoesNotExist:
593                     errors.append(
594                         checks.Error(
595                             "The to_field '%s' doesn't exist on the related "
596                             "model '%s'."
597                             % (to_field, self.remote_field.model._meta.label),
598                             obj=self,
599                             id="fields.E312",
600                         )
601                     )
602         return errors
603 
604     def _check_unique_target(self):
605         rel_is_string = isinstance(self.remote_field.model, str)
606         if rel_is_string or not self.requires_unique_target:
607             return []
608 
609         try:
610             self.foreign_related_fields
611         except exceptions.FieldDoesNotExist:
612             return []
613 
614         if not self.foreign_related_fields:
615             return []
616 
617         unique_foreign_fields = {
618             frozenset([f.name])
619             for f in self.remote_field.model._meta.get_fields()
620             if getattr(f, "unique", False)
621         }
622         unique_foreign_fields.update(
623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
624         )
625         unique_foreign_fields.update(
626             {
627                 frozenset(uc.fields)
628                 for uc in self.remote_field.model._meta.total_unique_constraints
629             }
630         )
631         foreign_fields = {f.name for f in self.foreign_related_fields}
632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
633 
634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
635             field_combination = ", ".join(
636                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
637             )
638             model_name = self.remote_field.model.__name__
639             return [
640                 checks.Error(
641                     "No subset of the fields %s on model '%s' is unique."
642                     % (field_combination, model_name),
643                     hint=(
644                         "Mark a single field as unique=True or add a set of "
645                         "fields to a unique constraint (via unique_together "
646                         "or a UniqueConstraint (without condition) in the "
647                         "model Meta.constraints)."
648                     ),
649                     obj=self,
650                     id="fields.E310",
651                 )
652             ]
653         elif not has_unique_constraint:
654             field_name = self.foreign_related_fields[0].name
655             model_name = self.remote_field.model.__name__
656             return [
657                 checks.Error(
658                     "'%s.%s' must be unique because it is referenced by "
659                     "a foreign key." % (model_name, field_name),
660                     hint=(
661                         "Add unique=True to this field or add a "
662                         "UniqueConstraint (without condition) in the model "
663                         "Meta.constraints."
664                     ),
665                     obj=self,
666                     id="fields.E311",
667                 )
668             ]
669         else:
670             return []
671 
672     def deconstruct(self):
673         name, path, args, kwargs = super().deconstruct()
674         kwargs["on_delete"] = self.remote_field.on_delete
675         kwargs["from_fields"] = self.from_fields
676         kwargs["to_fields"] = self.to_fields
677 
678         if self.remote_field.parent_link:
679             kwargs["parent_link"] = self.remote_field.parent_link
680         if isinstance(self.remote_field.model, str):
681             if "." in self.remote_field.model:
682                 app_label, model_name = self.remote_field.model.split(".")
683                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
684             else:
685                 kwargs["to"] = self.remote_field.model.lower()
686         else:
687             kwargs["to"] = self.remote_field.model._meta.label_lower
688         # If swappable is True, then see if we're actually pointing to the target
689         # of a swap.
690         swappable_setting = self.swappable_setting
691         if swappable_setting is not None:
692             # If it's already a settings reference, error
693             if hasattr(kwargs["to"], "setting_name"):
694                 if kwargs["to"].setting_name != swappable_setting:
695                     raise ValueError(
696                         "Cannot deconstruct a ForeignKey pointing to a model "
697                         "that is swapped in place of more than one model (%s and %s)"
698                         % (kwargs["to"].setting_name, swappable_setting)
699                     )
700             # Set it
701             kwargs["to"] = SettingsReference(
702                 kwargs["to"],
703                 swappable_setting,
704             )
705         return name, path, args, kwargs
706 
707     def resolve_related_fields(self):
708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
709             raise ValueError(
710                 "Foreign Object from and to fields must be the same non-zero length"
711             )
712         if isinstance(self.remote_field.model, str):
713             raise ValueError(
714                 "Related model %r cannot be resolved" % self.remote_field.model
715             )
716         related_fields = []
717         for index in range(len(self.from_fields)):
718             from_field_name = self.from_fields[index]
719             to_field_name = self.to_fields[index]
720             from_field = (
721                 self
722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
723                 else self.opts.get_field(from_field_name)
724             )
725             to_field = (
726                 self.remote_field.model._meta.pk
727                 if to_field_name is None
728                 else self.remote_field.model._meta.get_field(to_field_name)
729             )
730             related_fields.append((from_field, to_field))
731         return related_fields
732 
733     @cached_property
734     def related_fields(self):
735         return self.resolve_related_fields()
736 
737     @cached_property
738     def reverse_related_fields(self):
739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
740 
741     @cached_property
742     def local_related_fields(self):
743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
744 
745     @cached_property
746     def foreign_related_fields(self):
747         return tuple(
748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
749         )
750 
751     def get_local_related_value(self, instance):
752         return self.get_instance_value_for_fields(instance, self.local_related_fields)
753 
754     def get_foreign_related_value(self, instance):
755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
756 
757     @staticmethod
758     def get_instance_value_for_fields(instance, fields):
759         ret = []
760         opts = instance._meta
761         for field in fields:
762             # Gotcha: in some cases (like fixture loading) a model can have
763             # different values in parent_ptr_id and parent's id. So, use
764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
765             if field.primary_key:
766                 possible_parent_link = opts.get_ancestor_link(field.model)
767                 if (
768                     not possible_parent_link
769                     or possible_parent_link.primary_key
770                     or possible_parent_link.model._meta.abstract
771                 ):
772                     ret.append(instance.pk)
773                     continue
774             ret.append(getattr(instance, field.attname))
775         return tuple(ret)
776 
777     def get_attname_column(self):
778         attname, column = super().get_attname_column()
779         return attname, None
780 
781     def get_joining_columns(self, reverse_join=False):
782         source = self.reverse_related_fields if reverse_join else self.related_fields
783         return tuple(
784             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
785         )
786 
787     def get_reverse_joining_columns(self):
788         return self.get_joining_columns(reverse_join=True)
789 
790     def get_extra_descriptor_filter(self, instance):
791         """
792         Return an extra filter condition for related object fetching when
793         user does 'instance.fieldname', that is the extra filter is used in
794         the descriptor of the field.
795 
796         The filter should be either a dict usable in .filter(**kwargs) call or
797         a Q-object. The condition will be ANDed together with the relation's
798         joining columns.
799 
800         A parallel method is get_extra_restriction() which is used in
801         JOIN and subquery conditions.
802         """
803         return {}
804 
805     def get_extra_restriction(self, alias, related_alias):
806         """
807         Return a pair condition used for joining and subquery pushdown. The
808         condition is something that responds to as_sql(compiler, connection)
809         method.
810 
811         Note that currently referring both the 'alias' and 'related_alias'
812         will not work in some conditions, like subquery pushdown.
813 
814         A parallel method is get_extra_descriptor_filter() which is used in
815         instance.fieldname related object fetching.
816         """
817         return None
818 
819     def get_path_info(self, filtered_relation=None):
820         """Get path from this field to the related model."""
821         opts = self.remote_field.model._meta
822         from_opts = self.model._meta
823         return [
824             PathInfo(
825                 from_opts=from_opts,
826                 to_opts=opts,
827                 target_fields=self.foreign_related_fields,
828                 join_field=self,
829                 m2m=False,
830                 direct=True,
831                 filtered_relation=filtered_relation,
832             )
833         ]
834 
835     @cached_property
836     def path_infos(self):
837         return self.get_path_info()
838 
839     def get_reverse_path_info(self, filtered_relation=None):
840         """Get path from the related model to this field's model."""
841         opts = self.model._meta
842         from_opts = self.remote_field.model._meta
843         return [
844             PathInfo(
845                 from_opts=from_opts,
846                 to_opts=opts,
847                 target_fields=(opts.pk,),
848                 join_field=self.remote_field,
849                 m2m=not self.unique,
850                 direct=False,
851                 filtered_relation=filtered_relation,
852             )
853         ]
854 
855     @cached_property
856     def reverse_path_infos(self):
857         return self.get_reverse_path_info()
858 
859     @classmethod
860     @functools.lru_cache(maxsize=None)
861     def get_class_lookups(cls):
862         bases = inspect.getmro(cls)
863         bases = bases[: bases.index(ForeignObject) + 1]
864         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
865         return cls.merge_dicts(class_lookups)
866 
867     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
868         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
869         setattr(cls, self.name, self.forward_related_accessor_class(self))
870 
871     def contribute_to_related_class(self, cls, related):
872         # Internal FK's - i.e., those with a related name ending with '+' -
873         # and swapped models don't get a related descriptor.
874         if (
875             not self.remote_field.is_hidden()
876             and not related.related_model._meta.swapped
877         ):
878             setattr(
879                 cls._meta.concrete_model,
880                 related.get_accessor_name(),
881                 self.related_accessor_class(related),
882             )
883             # While 'limit_choices_to' might be a callable, simply pass
884             # it along for later - this is too early because it's still
885             # model load time.
886             if self.remote_field.limit_choices_to:
887                 cls._meta.related_fkey_lookups.append(
888                     self.remote_field.limit_choices_to
889                 )
890 
891 
892 ForeignObject.register_lookup(RelatedIn)
893 ForeignObject.register_lookup(RelatedExact)
894 ForeignObject.register_lookup(RelatedLessThan)
895 ForeignObject.register_lookup(RelatedGreaterThan)
896 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
897 ForeignObject.register_lookup(RelatedLessThanOrEqual)
898 ForeignObject.register_lookup(RelatedIsNull)
899 
900 
901 class ForeignKey(ForeignObject):
902     """
903     Provide a many-to-one relation by adding a column to the local model
904     to hold the remote value.
905 
906     By default ForeignKey will target the pk of the remote model but this
907     behavior can be changed by using the ``to_field`` argument.
908     """
909 
910     descriptor_class = ForeignKeyDeferredAttribute
911     # Field flags
912     many_to_many = False
913     many_to_one = True
914     one_to_many = False
915     one_to_one = False
916 
917     rel_class = ManyToOneRel
918 
919     empty_strings_allowed = False
920     default_error_messages = {
921         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
922     }
923     description = _("Foreign Key (type determined by related field)")
924 
925     def __init__(
926         self,
927         to,
928         on_delete,
929         related_name=None,
930         related_query_name=None,
931         limit_choices_to=None,
932         parent_link=False,
933         to_field=None,
934         db_constraint=True,
935         **kwargs,
936     ):
937         try:
938             to._meta.model_name
939         except AttributeError:
940             if not isinstance(to, str):
941                 raise TypeError(
942                     "%s(%r) is invalid. First parameter to ForeignKey must be "
943                     "either a model, a model name, or the string %r"
944                     % (
945                         self.__class__.__name__,
946                         to,
947                         RECURSIVE_RELATIONSHIP_CONSTANT,
948                     )
949                 )
950         else:
951             # For backwards compatibility purposes, we need to *try* and set
952             # the to_field during FK construction. It won't be guaranteed to
953             # be correct until contribute_to_class is called. Refs #12190.
954             to_field = to_field or (to._meta.pk and to._meta.pk.name)
955         if not callable(on_delete):
956             raise TypeError("on_delete must be callable.")
957 
958         kwargs["rel"] = self.rel_class(
959             self,
960             to,
961             to_field,
962             related_name=related_name,
963             related_query_name=related_query_name,
964             limit_choices_to=limit_choices_to,
965             parent_link=parent_link,
966             on_delete=on_delete,
967         )
968         kwargs.setdefault("db_index", True)
969 
970         super().__init__(
971             to,
972             on_delete,
973             related_name=related_name,
974             related_query_name=related_query_name,
975             limit_choices_to=limit_choices_to,
976             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
977             to_fields=[to_field],
978             **kwargs,
979         )
980         self.db_constraint = db_constraint
981 
982     def __class_getitem__(cls, *args, **kwargs):
983         return cls
984 
985     def check(self, **kwargs):
986         return [
987             *super().check(**kwargs),
988             *self._check_on_delete(),
989             *self._check_unique(),
990         ]
991 
992     def _check_on_delete(self):
993         on_delete = getattr(self.remote_field, "on_delete", None)
994         if on_delete == SET_NULL and not self.null:
995             return [
996                 checks.Error(
997                     "Field specifies on_delete=SET_NULL, but cannot be null.",
998                     hint=(
999                         "Set null=True argument on the field, or change the on_delete "
1000                         "rule."
1001                     ),
1002                     obj=self,
1003                     id="fields.E320",
1004                 )
1005             ]
1006         elif on_delete == SET_DEFAULT and not self.has_default():
1007             return [
1008                 checks.Error(
1009                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1010                     hint="Set a default value, or change the on_delete rule.",
1011                     obj=self,
1012                     id="fields.E321",
1013                 )
1014             ]
1015         else:
1016             return []
1017 
1018     def _check_unique(self, **kwargs):
1019         return (
1020             [
1021                 checks.Warning(
1022                     "Setting unique=True on a ForeignKey has the same effect as using "
1023                     "a OneToOneField.",
1024                     hint=(
1025                         "ForeignKey(unique=True) is usually better served by a "
1026                         "OneToOneField."
1027                     ),
1028                     obj=self,
1029                     id="fields.W342",
1030                 )
1031             ]
1032             if self.unique
1033             else []
1034         )
1035 
1036     def deconstruct(self):
1037         name, path, args, kwargs = super().deconstruct()
1038         del kwargs["to_fields"]
1039         del kwargs["from_fields"]
1040         # Handle the simpler arguments
1041         if self.db_index:
1042             del kwargs["db_index"]
1043         else:
1044             kwargs["db_index"] = False
1045         if self.db_constraint is not True:
1046             kwargs["db_constraint"] = self.db_constraint
1047         # Rel needs more work.
1048         to_meta = getattr(self.remote_field.model, "_meta", None)
1049         if self.remote_field.field_name and (
1050             not to_meta
1051             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1052         ):
1053             kwargs["to_field"] = self.remote_field.field_name
1054         return name, path, args, kwargs
1055 
1056     def to_python(self, value):
1057         return self.target_field.to_python(value)
1058 
1059     @property
1060     def target_field(self):
1061         return self.foreign_related_fields[0]
1062 
1063     def get_reverse_path_info(self, filtered_relation=None):
1064         """Get path from the related model to this field's model."""
1065         opts = self.model._meta
1066         from_opts = self.remote_field.model._meta
1067         return [
1068             PathInfo(
1069                 from_opts=from_opts,
1070                 to_opts=opts,
1071                 target_fields=(opts.pk,),
1072                 join_field=self.remote_field,
1073                 m2m=not self.unique,
1074                 direct=False,
1075                 filtered_relation=filtered_relation,
1076             )
1077         ]
1078 
1079     def validate(self, value, model_instance):
1080         if self.remote_field.parent_link:
1081             return
1082         super().validate(value, model_instance)
1083         if value is None:
1084             return
1085 
1086         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1087         qs = self.remote_field.model._base_manager.using(using).filter(
1088             **{self.remote_field.field_name: value}
1089         )
1090         qs = qs.complex_filter(self.get_limit_choices_to())
1091         if not qs.exists():
1092             raise exceptions.ValidationError(
1093                 self.error_messages["invalid"],
1094                 code="invalid",
1095                 params={
1096                     "model": self.remote_field.model._meta.verbose_name,
1097                     "pk": value,
1098                     "field": self.remote_field.field_name,
1099                     "value": value,
1100                 },  # 'pk' is included for backwards compatibility
1101             )
1102 
1103     def resolve_related_fields(self):
1104         related_fields = super().resolve_related_fields()
1105         for from_field, to_field in related_fields:
1106             if (
1107                 to_field
1108                 and to_field.model != self.remote_field.model._meta.concrete_model
1109             ):
1110                 raise exceptions.FieldError(
1111                     "'%s.%s' refers to field '%s' which is not local to model "
1112                     "'%s'."
1113                     % (
1114                         self.model._meta.label,
1115                         self.name,
1116                         to_field.name,
1117                         self.remote_field.model._meta.concrete_model._meta.label,
1118                     )
1119                 )
1120         return related_fields
1121 
1122     def get_attname(self):
1123         return "%s_id" % self.name
1124 
1125     def get_attname_column(self):
1126         attname = self.get_attname()
1127         column = self.db_column or attname
1128         return attname, column
1129 
1130     def get_default(self):
1131         """Return the to_field if the default value is an object."""
1132         field_default = super().get_default()
1133         if isinstance(field_default, self.remote_field.model):
1134             return getattr(field_default, self.target_field.attname)
1135         return field_default
1136 
1137     def get_db_prep_save(self, value, connection):
1138         if value is None or (
1139             value == ""
1140             and (
1141                 not self.target_field.empty_strings_allowed
1142                 or connection.features.interprets_empty_strings_as_nulls
1143             )
1144         ):
1145             return None
1146         else:
1147             return self.target_field.get_db_prep_save(value, connection=connection)
1148 
1149     def get_db_prep_value(self, value, connection, prepared=False):
1150         return self.target_field.get_db_prep_value(value, connection, prepared)
1151 
1152     def get_prep_value(self, value):
1153         return self.target_field.get_prep_value(value)
1154 
1155     def contribute_to_related_class(self, cls, related):
1156         super().contribute_to_related_class(cls, related)
1157         if self.remote_field.field_name is None:
1158             self.remote_field.field_name = cls._meta.pk.name
1159 
1160     def formfield(self, *, using=None, **kwargs):
1161         if isinstance(self.remote_field.model, str):
1162             raise ValueError(
1163                 "Cannot create form field for %r yet, because "
1164                 "its related model %r has not been loaded yet"
1165                 % (self.name, self.remote_field.model)
1166             )
1167         return super().formfield(
1168             **{
1169                 "form_class": forms.ModelChoiceField,
1170                 "queryset": self.remote_field.model._default_manager.using(using),
1171                 "to_field_name": self.remote_field.field_name,
1172                 **kwargs,
1173                 "blank": self.blank,
1174             }
1175         )
1176 
1177     def db_check(self, connection):
1178         return None
1179 
1180     def db_type(self, connection):
1181         return self.target_field.rel_db_type(connection=connection)
1182 
1183     def db_parameters(self, connection):
1184         target_db_parameters = self.target_field.db_parameters(connection)
1185         return {
1186             "type": self.db_type(connection),
1187             "check": self.db_check(connection),
1188             "collation": target_db_parameters.get("collation"),
1189         }
1190 
1191     def convert_empty_strings(self, value, expression, connection):
1192         if (not value) and isinstance(value, str):
1193             return None
1194         return value
1195 
1196     def get_db_converters(self, connection):
1197         converters = super().get_db_converters(connection)
1198         if connection.features.interprets_empty_strings_as_nulls:
1199             converters += [self.convert_empty_strings]
1200         return converters
1201 
1202     def get_col(self, alias, output_field=None):
1203         if output_field is None:
1204             output_field = self.target_field
1205             while isinstance(output_field, ForeignKey):
1206                 output_field = output_field.target_field
1207                 if output_field is self:
1208                     raise ValueError("Cannot resolve output_field.")
1209         return super().get_col(alias, output_field)
1210 
1211 
1212 class OneToOneField(ForeignKey):
1213     """
1214     A OneToOneField is essentially the same as a ForeignKey, with the exception
1215     that it always carries a "unique" constraint with it and the reverse
1216     relation always returns the object pointed to (since there will only ever
1217     be one), rather than returning a list.
1218     """
1219 
1220     # Field flags
1221     many_to_many = False
1222     many_to_one = False
1223     one_to_many = False
1224     one_to_one = True
1225 
1226     related_accessor_class = ReverseOneToOneDescriptor
1227     forward_related_accessor_class = ForwardOneToOneDescriptor
1228     rel_class = OneToOneRel
1229 
1230     description = _("One-to-one relationship")
1231 
1232     def __init__(self, to, on_delete, to_field=None, **kwargs):
1233         kwargs["unique"] = True
1234         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1235 
1236     def deconstruct(self):
1237         name, path, args, kwargs = super().deconstruct()
1238         if "unique" in kwargs:
1239             del kwargs["unique"]
1240         return name, path, args, kwargs
1241 
1242     def formfield(self, **kwargs):
1243         if self.remote_field.parent_link:
1244             return None
1245         return super().formfield(**kwargs)
1246 
1247     def save_form_data(self, instance, data):
1248         if isinstance(data, self.remote_field.model):
1249             setattr(instance, self.name, data)
1250         else:
1251             setattr(instance, self.attname, data)
1252             # Remote field object must be cleared otherwise Model.save()
1253             # will reassign attname using the related object pk.
1254             if data is None:
1255                 setattr(instance, self.name, data)
1256 
1257     def _check_unique(self, **kwargs):
1258         # Override ForeignKey since check isn't applicable here.
1259         return []
1260 
1261 
1262 def create_many_to_many_intermediary_model(field, klass):
1263     from django.db import models
1264 
1265     def set_managed(model, related, through):
1266         through._meta.managed = model._meta.managed or related._meta.managed
1267 
1268     to_model = resolve_relation(klass, field.remote_field.model)
1269     name = "%s_%s" % (klass._meta.object_name, field.name)
1270     lazy_related_operation(set_managed, klass, to_model, name)
1271 
1272     to = make_model_tuple(to_model)[1]
1273     from_ = klass._meta.model_name
1274     if to == from_:
1275         to = "to_%s" % to
1276         from_ = "from_%s" % from_
1277 
1278     meta = type(
1279         "Meta",
1280         (),
1281         {
1282             "db_table": field._get_m2m_db_table(klass._meta),
1283             "auto_created": klass,
1284             "app_label": klass._meta.app_label,
1285             "db_tablespace": klass._meta.db_tablespace,
1286             "unique_together": (from_, to),
1287             "verbose_name": _("%(from)s-%(to)s relationship")
1288             % {"from": from_, "to": to},
1289             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1290             % {"from": from_, "to": to},
1291             "apps": field.model._meta.apps,
1292         },
1293     )
1294     # Construct and return the new class.
1295     return type(
1296         name,
1297         (models.Model,),
1298         {
1299             "Meta": meta,
1300             "__module__": klass.__module__,
1301             from_: models.ForeignKey(
1302                 klass,
1303                 related_name="%s+" % name,
1304                 db_tablespace=field.db_tablespace,
1305                 db_constraint=field.remote_field.db_constraint,
1306                 on_delete=CASCADE,
1307             ),
1308             to: models.ForeignKey(
1309                 to_model,
1310                 related_name="%s+" % name,
1311                 db_tablespace=field.db_tablespace,
1312                 db_constraint=field.remote_field.db_constraint,
1313                 on_delete=CASCADE,
1314             ),
1315         },
1316     )
1317 
1318 
1319 class ManyToManyField(RelatedField):
1320     """
1321     Provide a many-to-many relation by using an intermediary model that
1322     holds two ForeignKey fields pointed at the two sides of the relation.
1323 
1324     Unless a ``through`` model was provided, ManyToManyField will use the
1325     create_many_to_many_intermediary_model factory to automatically generate
1326     the intermediary model.
1327     """
1328 
1329     # Field flags
1330     many_to_many = True
1331     many_to_one = False
1332     one_to_many = False
1333     one_to_one = False
1334 
1335     rel_class = ManyToManyRel
1336 
1337     description = _("Many-to-many relationship")
1338 
1339     def __init__(
1340         self,
1341         to,
1342         related_name=None,
1343         related_query_name=None,
1344         limit_choices_to=None,
1345         symmetrical=None,
1346         through=None,
1347         through_fields=None,
1348         db_constraint=True,
1349         db_table=None,
1350         swappable=True,
1351         **kwargs,
1352     ):
1353         try:
1354             to._meta
1355         except AttributeError:
1356             if not isinstance(to, str):
1357                 raise TypeError(
1358                     "%s(%r) is invalid. First parameter to ManyToManyField "
1359                     "must be either a model, a model name, or the string %r"
1360                     % (
1361                         self.__class__.__name__,
1362                         to,
1363                         RECURSIVE_RELATIONSHIP_CONSTANT,
1364                     )
1365                 )
1366 
1367         if symmetrical is None:
1368             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1369 
1370         if through is not None and db_table is not None:
1371             raise ValueError(
1372                 "Cannot specify a db_table if an intermediary model is used."
1373             )
1374 
1375         kwargs["rel"] = self.rel_class(
1376             self,
1377             to,
1378             related_name=related_name,
1379             related_query_name=related_query_name,
1380             limit_choices_to=limit_choices_to,
1381             symmetrical=symmetrical,
1382             through=through,
1383             through_fields=through_fields,
1384             db_constraint=db_constraint,
1385         )
1386         self.has_null_arg = "null" in kwargs
1387 
1388         super().__init__(
1389             related_name=related_name,
1390             related_query_name=related_query_name,
1391             limit_choices_to=limit_choices_to,
1392             **kwargs,
1393         )
1394 
1395         self.db_table = db_table
1396         self.swappable = swappable
1397 
1398     def check(self, **kwargs):
1399         return [
1400             *super().check(**kwargs),
1401             *self._check_unique(**kwargs),
1402             *self._check_relationship_model(**kwargs),
1403             *self._check_ignored_options(**kwargs),
1404             *self._check_table_uniqueness(**kwargs),
1405         ]
1406 
1407     def _check_unique(self, **kwargs):
1408         if self.unique:
1409             return [
1410                 checks.Error(
1411                     "ManyToManyFields cannot be unique.",
1412                     obj=self,
1413                     id="fields.E330",
1414                 )
1415             ]
1416         return []
1417 
1418     def _check_ignored_options(self, **kwargs):
1419         warnings = []
1420 
1421         if self.has_null_arg:
1422             warnings.append(
1423                 checks.Warning(
1424                     "null has no effect on ManyToManyField.",
1425                     obj=self,
1426                     id="fields.W340",
1427                 )
1428             )
1429 
1430         if self._validators:
1431             warnings.append(
1432                 checks.Warning(
1433                     "ManyToManyField does not support validators.",
1434                     obj=self,
1435                     id="fields.W341",
1436                 )
1437             )
1438         if self.remote_field.symmetrical and self._related_name:
1439             warnings.append(
1440                 checks.Warning(
1441                     "related_name has no effect on ManyToManyField "
1442                     'with a symmetrical relationship, e.g. to "self".',
1443                     obj=self,
1444                     id="fields.W345",
1445                 )
1446             )
1447 
1448         return warnings
1449 
1450     def _check_relationship_model(self, from_model=None, **kwargs):
1451         if hasattr(self.remote_field.through, "_meta"):
1452             qualified_model_name = "%s.%s" % (
1453                 self.remote_field.through._meta.app_label,
1454                 self.remote_field.through.__name__,
1455             )
1456         else:
1457             qualified_model_name = self.remote_field.through
1458 
1459         errors = []
1460 
1461         if self.remote_field.through not in self.opts.apps.get_models(
1462             include_auto_created=True
1463         ):
1464             # The relationship model is not installed.
1465             errors.append(
1466                 checks.Error(
1467                     "Field specifies a many-to-many relation through model "
1468                     "'%s', which has not been installed." % qualified_model_name,
1469                     obj=self,
1470                     id="fields.E331",
1471                 )
1472             )
1473 
1474         else:
1475             assert from_model is not None, (
1476                 "ManyToManyField with intermediate "
1477                 "tables cannot be checked if you don't pass the model "
1478                 "where the field is attached to."
1479             )
1480             # Set some useful local variables
1481             to_model = resolve_relation(from_model, self.remote_field.model)
1482             from_model_name = from_model._meta.object_name
1483             if isinstance(to_model, str):
1484                 to_model_name = to_model
1485             else:
1486                 to_model_name = to_model._meta.object_name
1487             relationship_model_name = self.remote_field.through._meta.object_name
1488             self_referential = from_model == to_model
1489             # Count foreign keys in intermediate model
1490             if self_referential:
1491                 seen_self = sum(
1492                     from_model == getattr(field.remote_field, "model", None)
1493                     for field in self.remote_field.through._meta.fields
1494                 )
1495 
1496                 if seen_self > 2 and not self.remote_field.through_fields:
1497                     errors.append(
1498                         checks.Error(
1499                             "The model is used as an intermediate model by "
1500                             "'%s', but it has more than two foreign keys "
1501                             "to '%s', which is ambiguous. You must specify "
1502                             "which two foreign keys Django should use via the "
1503                             "through_fields keyword argument."
1504                             % (self, from_model_name),
1505                             hint=(
1506                                 "Use through_fields to specify which two foreign keys "
1507                                 "Django should use."
1508                             ),
1509                             obj=self.remote_field.through,
1510                             id="fields.E333",
1511                         )
1512                     )
1513 
1514             else:
1515                 # Count foreign keys in relationship model
1516                 seen_from = sum(
1517                     from_model == getattr(field.remote_field, "model", None)
1518                     for field in self.remote_field.through._meta.fields
1519                 )
1520                 seen_to = sum(
1521                     to_model == getattr(field.remote_field, "model", None)
1522                     for field in self.remote_field.through._meta.fields
1523                 )
1524 
1525                 if seen_from > 1 and not self.remote_field.through_fields:
1526                     errors.append(
1527                         checks.Error(
1528                             (
1529                                 "The model is used as an intermediate model by "
1530                                 "'%s', but it has more than one foreign key "
1531                                 "from '%s', which is ambiguous. You must specify "
1532                                 "which foreign key Django should use via the "
1533                                 "through_fields keyword argument."
1534                             )
1535                             % (self, from_model_name),
1536                             hint=(
1537                                 "If you want to create a recursive relationship, "
1538                                 'use ManyToManyField("%s", through="%s").'
1539                             )
1540                             % (
1541                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1542                                 relationship_model_name,
1543                             ),
1544                             obj=self,
1545                             id="fields.E334",
1546                         )
1547                     )
1548 
1549                 if seen_to > 1 and not self.remote_field.through_fields:
1550                     errors.append(
1551                         checks.Error(
1552                             "The model is used as an intermediate model by "
1553                             "'%s', but it has more than one foreign key "
1554                             "to '%s', which is ambiguous. You must specify "
1555                             "which foreign key Django should use via the "
1556                             "through_fields keyword argument." % (self, to_model_name),
1557                             hint=(
1558                                 "If you want to create a recursive relationship, "
1559                                 'use ManyToManyField("%s", through="%s").'
1560                             )
1561                             % (
1562                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1563                                 relationship_model_name,
1564                             ),
1565                             obj=self,
1566                             id="fields.E335",
1567                         )
1568                     )
1569 
1570                 if seen_from == 0 or seen_to == 0:
1571                     errors.append(
1572                         checks.Error(
1573                             "The model is used as an intermediate model by "
1574                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1575                             % (self, from_model_name, to_model_name),
1576                             obj=self.remote_field.through,
1577                             id="fields.E336",
1578                         )
1579                     )
1580 
1581         # Validate `through_fields`.
1582         if self.remote_field.through_fields is not None:
1583             # Validate that we're given an iterable of at least two items
1584             # and that none of them is "falsy".
1585             if not (
1586                 len(self.remote_field.through_fields) >= 2
1587                 and self.remote_field.through_fields[0]
1588                 and self.remote_field.through_fields[1]
1589             ):
1590                 errors.append(
1591                     checks.Error(
1592                         "Field specifies 'through_fields' but does not provide "
1593                         "the names of the two link fields that should be used "
1594                         "for the relation through model '%s'." % qualified_model_name,
1595                         hint=(
1596                             "Make sure you specify 'through_fields' as "
1597                             "through_fields=('field1', 'field2')"
1598                         ),
1599                         obj=self,
1600                         id="fields.E337",
1601                     )
1602                 )
1603 
1604             # Validate the given through fields -- they should be actual
1605             # fields on the through model, and also be foreign keys to the
1606             # expected models.
1607             else:
1608                 assert from_model is not None, (
1609                     "ManyToManyField with intermediate "
1610                     "tables cannot be checked if you don't pass the model "
1611                     "where the field is attached to."
1612                 )
1613 
1614                 source, through, target = (
1615                     from_model,
1616                     self.remote_field.through,
1617                     self.remote_field.model,
1618                 )
1619                 source_field_name, target_field_name = self.remote_field.through_fields[
1620                     :2
1621                 ]
1622 
1623                 for field_name, related_model in (
1624                     (source_field_name, source),
1625                     (target_field_name, target),
1626                 ):
1627 
1628                     possible_field_names = []
1629                     for f in through._meta.fields:
1630                         if (
1631                             hasattr(f, "remote_field")
1632                             and getattr(f.remote_field, "model", None) == related_model
1633                         ):
1634                             possible_field_names.append(f.name)
1635                     if possible_field_names:
1636                         hint = (
1637                             "Did you mean one of the following foreign keys to '%s': "
1638                             "%s?"
1639                             % (
1640                                 related_model._meta.object_name,
1641                                 ", ".join(possible_field_names),
1642                             )
1643                         )
1644                     else:
1645                         hint = None
1646 
1647                     try:
1648                         field = through._meta.get_field(field_name)
1649                     except exceptions.FieldDoesNotExist:
1650                         errors.append(
1651                             checks.Error(
1652                                 "The intermediary model '%s' has no field '%s'."
1653                                 % (qualified_model_name, field_name),
1654                                 hint=hint,
1655                                 obj=self,
1656                                 id="fields.E338",
1657                             )
1658                         )
1659                     else:
1660                         if not (
1661                             hasattr(field, "remote_field")
1662                             and getattr(field.remote_field, "model", None)
1663                             == related_model
1664                         ):
1665                             errors.append(
1666                                 checks.Error(
1667                                     "'%s.%s' is not a foreign key to '%s'."
1668                                     % (
1669                                         through._meta.object_name,
1670                                         field_name,
1671                                         related_model._meta.object_name,
1672                                     ),
1673                                     hint=hint,
1674                                     obj=self,
1675                                     id="fields.E339",
1676                                 )
1677                             )
1678 
1679         return errors
1680 
1681     def _check_table_uniqueness(self, **kwargs):
1682         if (
1683             isinstance(self.remote_field.through, str)
1684             or not self.remote_field.through._meta.managed
1685         ):
1686             return []
1687         registered_tables = {
1688             model._meta.db_table: model
1689             for model in self.opts.apps.get_models(include_auto_created=True)
1690             if model != self.remote_field.through and model._meta.managed
1691         }
1692         m2m_db_table = self.m2m_db_table()
1693         model = registered_tables.get(m2m_db_table)
1694         # The second condition allows multiple m2m relations on a model if
1695         # some point to a through model that proxies another through model.
1696         if (
1697             model
1698             and model._meta.concrete_model
1699             != self.remote_field.through._meta.concrete_model
1700         ):
1701             if model._meta.auto_created:
1702 
1703                 def _get_field_name(model):
1704                     for field in model._meta.auto_created._meta.many_to_many:
1705                         if field.remote_field.through is model:
1706                             return field.name
1707 
1708                 opts = model._meta.auto_created._meta
1709                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1710             else:
1711                 clashing_obj = model._meta.label
1712             if settings.DATABASE_ROUTERS:
1713                 error_class, error_id = checks.Warning, "fields.W344"
1714                 error_hint = (
1715                     "You have configured settings.DATABASE_ROUTERS. Verify "
1716                     "that the table of %r is correctly routed to a separate "
1717                     "database." % clashing_obj
1718                 )
1719             else:
1720                 error_class, error_id = checks.Error, "fields.E340"
1721                 error_hint = None
1722             return [
1723                 error_class(
1724                     "The field's intermediary table '%s' clashes with the "
1725                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1726                     obj=self,
1727                     hint=error_hint,
1728                     id=error_id,
1729                 )
1730             ]
1731         return []
1732 
1733     def deconstruct(self):
1734         name, path, args, kwargs = super().deconstruct()
1735         # Handle the simpler arguments.
1736         if self.db_table is not None:
1737             kwargs["db_table"] = self.db_table
1738         if self.remote_field.db_constraint is not True:
1739             kwargs["db_constraint"] = self.remote_field.db_constraint
1740         # Lowercase model names as they should be treated as case-insensitive.
1741         if isinstance(self.remote_field.model, str):
1742             if "." in self.remote_field.model:
1743                 app_label, model_name = self.remote_field.model.split(".")
1744                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1745             else:
1746                 kwargs["to"] = self.remote_field.model.lower()
1747         else:
1748             kwargs["to"] = self.remote_field.model._meta.label_lower
1749         if getattr(self.remote_field, "through", None) is not None:
1750             if isinstance(self.remote_field.through, str):
1751                 kwargs["through"] = self.remote_field.through
1752             elif not self.remote_field.through._meta.auto_created:
1753                 kwargs["through"] = self.remote_field.through._meta.label
1754         # If swappable is True, then see if we're actually pointing to the target
1755         # of a swap.
1756         swappable_setting = self.swappable_setting
1757         if swappable_setting is not None:
1758             # If it's already a settings reference, error.
1759             if hasattr(kwargs["to"], "setting_name"):
1760                 if kwargs["to"].setting_name != swappable_setting:
1761                     raise ValueError(
1762                         "Cannot deconstruct a ManyToManyField pointing to a "
1763                         "model that is swapped in place of more than one model "
1764                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1765                     )
1766 
1767             kwargs["to"] = SettingsReference(
1768                 kwargs["to"],
1769                 swappable_setting,
1770             )
1771         return name, path, args, kwargs
1772 
1773     def _get_path_info(self, direct=False, filtered_relation=None):
1774         """Called by both direct and indirect m2m traversal."""
1775         int_model = self.remote_field.through
1776         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1777         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1778         if direct:
1779             join1infos = linkfield1.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield2.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield2.path_infos
1784         else:
1785             join1infos = linkfield2.reverse_path_infos
1786             if filtered_relation:
1787                 join2infos = linkfield1.get_path_info(filtered_relation)
1788             else:
1789                 join2infos = linkfield1.path_infos
1790         # Get join infos between the last model of join 1 and the first model
1791         # of join 2. Assume the only reason these may differ is due to model
1792         # inheritance.
1793         join1_final = join1infos[-1].to_opts
1794         join2_initial = join2infos[0].from_opts
1795         if join1_final is join2_initial:
1796             intermediate_infos = []
1797         elif issubclass(join1_final.model, join2_initial.model):
1798             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1799         else:
1800             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1801 
1802         return [*join1infos, *intermediate_infos, *join2infos]
1803 
1804     def get_path_info(self, filtered_relation=None):
1805         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1806 
1807     @cached_property
1808     def path_infos(self):
1809         return self.get_path_info()
1810 
1811     def get_reverse_path_info(self, filtered_relation=None):
1812         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1813 
1814     @cached_property
1815     def reverse_path_infos(self):
1816         return self.get_reverse_path_info()
1817 
1818     def _get_m2m_db_table(self, opts):
1819         """
1820         Function that can be curried to provide the m2m table name for this
1821         relation.
1822         """
1823         if self.remote_field.through is not None:
1824             return self.remote_field.through._meta.db_table
1825         elif self.db_table:
1826             return self.db_table
1827         else:
1828             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1829             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1830 
1831     def _get_m2m_attr(self, related, attr):
1832         """
1833         Function that can be curried to provide the source accessor or DB
1834         column name for the m2m table.
1835         """
1836         cache_attr = "_m2m_%s_cache" % attr
1837         if hasattr(self, cache_attr):
1838             return getattr(self, cache_attr)
1839         if self.remote_field.through_fields is not None:
1840             link_field_name = self.remote_field.through_fields[0]
1841         else:
1842             link_field_name = None
1843         for f in self.remote_field.through._meta.fields:
1844             if (
1845                 f.is_relation
1846                 and f.remote_field.model == related.related_model
1847                 and (link_field_name is None or link_field_name == f.name)
1848             ):
1849                 setattr(self, cache_attr, getattr(f, attr))
1850                 return getattr(self, cache_attr)
1851 
1852     def _get_m2m_reverse_attr(self, related, attr):
1853         """
1854         Function that can be curried to provide the related accessor or DB
1855         column name for the m2m table.
1856         """
1857         cache_attr = "_m2m_reverse_%s_cache" % attr
1858         if hasattr(self, cache_attr):
1859             return getattr(self, cache_attr)
1860         found = False
1861         if self.remote_field.through_fields is not None:
1862             link_field_name = self.remote_field.through_fields[1]
1863         else:
1864             link_field_name = None
1865         for f in self.remote_field.through._meta.fields:
1866             if f.is_relation and f.remote_field.model == related.model:
1867                 if link_field_name is None and related.related_model == related.model:
1868                     # If this is an m2m-intermediate to self,
1869                     # the first foreign key you find will be
1870                     # the source column. Keep searching for
1871                     # the second foreign key.
1872                     if found:
1873                         setattr(self, cache_attr, getattr(f, attr))
1874                         break
1875                     else:
1876                         found = True
1877                 elif link_field_name is None or link_field_name == f.name:
1878                     setattr(self, cache_attr, getattr(f, attr))
1879                     break
1880         return getattr(self, cache_attr)
1881 
1882     def contribute_to_class(self, cls, name, **kwargs):
1883         # To support multiple relations to self, it's useful to have a non-None
1884         # related name on symmetrical relations for internal reasons. The
1885         # concept doesn't make a lot of sense externally ("you want me to
1886         # specify *what* on my non-reversible relation?!"), so we set it up
1887         # automatically. The funky name reduces the chance of an accidental
1888         # clash.
1889         if self.remote_field.symmetrical and (
1890             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1891             or self.remote_field.model == cls._meta.object_name
1892         ):
1893             self.remote_field.related_name = "%s_rel_+" % name
1894         elif self.remote_field.is_hidden():
1895             # If the backwards relation is disabled, replace the original
1896             # related_name with one generated from the m2m field name. Django
1897             # still uses backwards relations internally and we need to avoid
1898             # clashes between multiple m2m fields with related_name == '+'.
1899             self.remote_field.related_name = "_%s_%s_%s_+" % (
1900                 cls._meta.app_label,
1901                 cls.__name__.lower(),
1902                 name,
1903             )
1904 
1905         super().contribute_to_class(cls, name, **kwargs)
1906 
1907         # The intermediate m2m model is not auto created if:
1908         #  1) There is a manually specified intermediate, or
1909         #  2) The class owning the m2m field is abstract.
1910         #  3) The class owning the m2m field has been swapped out.
1911         if not cls._meta.abstract:
1912             if self.remote_field.through:
1913 
1914                 def resolve_through_model(_, model, field):
1915                     field.remote_field.through = model
1916 
1917                 lazy_related_operation(
1918                     resolve_through_model, cls, self.remote_field.through, field=self
1919                 )
1920             elif not cls._meta.swapped:
1921                 self.remote_field.through = create_many_to_many_intermediary_model(
1922                     self, cls
1923                 )
1924 
1925         # Add the descriptor for the m2m relation.
1926         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1927 
1928         # Set up the accessor for the m2m table name for the relation.
1929         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1930 
1931     def contribute_to_related_class(self, cls, related):
1932         # Internal M2Ms (i.e., those with a related name ending with '+')
1933         # and swapped models don't get a related descriptor.
1934         if (
1935             not self.remote_field.is_hidden()
1936             and not related.related_model._meta.swapped
1937         ):
1938             setattr(
1939                 cls,
1940                 related.get_accessor_name(),
1941                 ManyToManyDescriptor(self.remote_field, reverse=True),
1942             )
1943 
1944         # Set up the accessors for the column names on the m2m table.
1945         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1946         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1947 
1948         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1949         self.m2m_reverse_field_name = partial(
1950             self._get_m2m_reverse_attr, related, "name"
1951         )
1952 
1953         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1954         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1955         get_m2m_reverse_rel = partial(
1956             self._get_m2m_reverse_attr, related, "remote_field"
1957         )
1958         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1959 
1960     def set_attributes_from_rel(self):
1961         pass
1962 
1963     def value_from_object(self, obj):
1964         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1965 
1966     def save_form_data(self, instance, data):
1967         getattr(instance, self.attname).set(data)
1968 
1969     def formfield(self, *, using=None, **kwargs):
1970         defaults = {
1971             "form_class": forms.ModelMultipleChoiceField,
1972             "queryset": self.remote_field.model._default_manager.using(using),
1973             **kwargs,
1974         }
1975         # If initial is passed in, it's a list of related objects, but the
1976         # MultipleChoiceField takes a list of IDs.
1977         if defaults.get("initial") is not None:
1978             initial = defaults["initial"]
1979             if callable(initial):
1980                 initial = initial()
1981             defaults["initial"] = [i.pk for i in initial]
1982         return super().formfield(**defaults)
1983 
1984     def db_check(self, connection):
1985         return None
1986 
1987     def db_type(self, connection):
1988         # A ManyToManyField is not represented by a single column,
1989         # so return None.
1990         return None
1991 
1992     def db_parameters(self, connection):
1993         return {"type": None, "check": None}

</code><intended_behavior>Ensure that when a ManyToManyField targets 'self', Django's migration framework correctly adjusts the underlying database schema, specifically creating or modifying the necessary intermediary table columns to reflect the self-referencing nature of the field.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>migrate</method>
<code>
94     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
95         """
96         Migrate the database up to the given targets.
97 
98         Django first needs to create all project states before a migration is
99         (un)applied and in a second step run all the database operations.
100         """
101         # The django_migrations table must be present to record applied
102         # migrations, but don't create it if there are no migrations to apply.
103         if plan == []:
104             if not self.recorder.has_table():
105                 return self._create_project_state(with_applied_migrations=False)
106         else:
107             self.recorder.ensure_schema()
108 
109         if plan is None:
110             plan = self.migration_plan(targets)
111         # Create the forwards plan Django would follow on an empty database
112         full_plan = self.migration_plan(
113             self.loader.graph.leaf_nodes(), clean_start=True
114         )
115 
116         all_forwards = all(not backwards for mig, backwards in plan)
117         all_backwards = all(backwards for mig, backwards in plan)
118 
119         if not plan:
120             if state is None:
121                 # The resulting state should include applied migrations.
122                 state = self._create_project_state(with_applied_migrations=True)
123         elif all_forwards == all_backwards:
124             # This should only happen if there's a mixed plan
125             raise InvalidMigrationPlan(
126                 "Migration plans with both forwards and backwards migrations "
127                 "are not supported. Please split your migration process into "
128                 "separate plans of only forwards OR backwards migrations.",
129                 plan,
130             )
131         elif all_forwards:
132             if state is None:
133                 # The resulting state should still include applied migrations.
134                 state = self._create_project_state(with_applied_migrations=True)
135             state = self._migrate_all_forwards(
136                 state, plan, full_plan, fake=fake, fake_initial=fake_initial
137             )
138         else:
139             # No need to check for `elif all_backwards` here, as that condition
140             # would always evaluate to true.
141             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
142 
143         self.check_replacements()
144 
145         return state

</code><intended_behavior>The migrate method must ensure that migrations involving changes to a ManyToManyField's target include the correct operations for adjusting the schema, especially when changing from a reference to another model to 'self'. This could involve creating specific checks or operations within the migration planning or execution phases that deal with self-referencing ManyToMany fields.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations
47                     and target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n
58                     for n in self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(
82                 self.loader.graph.leaf_nodes(), clean_start=True
83             )
84             applied_migrations = {
85                 self.loader.graph.nodes[key]
86                 for key in self.loader.applied_migrations
87                 if key in self.loader.graph.nodes
88             }
89             for migration, _ in full_plan:
90                 if migration in applied_migrations:
91                     migration.mutate_state(state, preserve=False)
92         return state
93 
94     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
95         """
96         Migrate the database up to the given targets.
97 
98         Django first needs to create all project states before a migration is
99         (un)applied and in a second step run all the database operations.
100         """
101         # The django_migrations table must be present to record applied
102         # migrations, but don't create it if there are no migrations to apply.
103         if plan == []:
104             if not self.recorder.has_table():
105                 return self._create_project_state(with_applied_migrations=False)
106         else:
107             self.recorder.ensure_schema()
108 
109         if plan is None:
110             plan = self.migration_plan(targets)
111         # Create the forwards plan Django would follow on an empty database
112         full_plan = self.migration_plan(
113             self.loader.graph.leaf_nodes(), clean_start=True
114         )
115 
116         all_forwards = all(not backwards for mig, backwards in plan)
117         all_backwards = all(backwards for mig, backwards in plan)
118 
119         if not plan:
120             if state is None:
121                 # The resulting state should include applied migrations.
122                 state = self._create_project_state(with_applied_migrations=True)
123         elif all_forwards == all_backwards:
124             # This should only happen if there's a mixed plan
125             raise InvalidMigrationPlan(
126                 "Migration plans with both forwards and backwards migrations "
127                 "are not supported. Please split your migration process into "
128                 "separate plans of only forwards OR backwards migrations.",
129                 plan,
130             )
131         elif all_forwards:
132             if state is None:
133                 # The resulting state should still include applied migrations.
134                 state = self._create_project_state(with_applied_migrations=True)
135             state = self._migrate_all_forwards(
136                 state, plan, full_plan, fake=fake, fake_initial=fake_initial
137             )
138         else:
139             # No need to check for `elif all_backwards` here, as that condition
140             # would always evaluate to true.
141             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
142 
143         self.check_replacements()
144 
145         return state
146 
147     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
148         """
149         Take a list of 2-tuples of the form (migration instance, False) and
150         apply them in the order they occur in the full_plan.
151         """
152         migrations_to_run = {m[0] for m in plan}
153         for migration, _ in full_plan:
154             if not migrations_to_run:
155                 # We remove every migration that we applied from these sets so
156                 # that we can bail out once the last migration has been applied
157                 # and don't always run until the very end of the migration
158                 # process.
159                 break
160             if migration in migrations_to_run:
161                 if "apps" not in state.__dict__:
162                     if self.progress_callback:
163                         self.progress_callback("render_start")
164                     state.apps  # Render all -- performance critical
165                     if self.progress_callback:
166                         self.progress_callback("render_success")
167                 state = self.apply_migration(
168                     state, migration, fake=fake, fake_initial=fake_initial
169                 )
170                 migrations_to_run.remove(migration)
171 
172         return state
173 
174     def _migrate_all_backwards(self, plan, full_plan, fake):
175         """
176         Take a list of 2-tuples of the form (migration instance, True) and
177         unapply them in reverse order they occur in the full_plan.
178 
179         Since unapplying a migration requires the project state prior to that
180         migration, Django will compute the migration states before each of them
181         in a first run over the plan and then unapply them in a second run over
182         the plan.
183         """
184         migrations_to_run = {m[0] for m in plan}
185         # Holds all migration states prior to the migrations being unapplied
186         states = {}
187         state = self._create_project_state()
188         applied_migrations = {
189             self.loader.graph.nodes[key]
190             for key in self.loader.applied_migrations
191             if key in self.loader.graph.nodes
192         }
193         if self.progress_callback:
194             self.progress_callback("render_start")
195         for migration, _ in full_plan:
196             if not migrations_to_run:
197                 # We remove every migration that we applied from this set so
198                 # that we can bail out once the last migration has been applied
199                 # and don't always run until the very end of the migration
200                 # process.
201                 break
202             if migration in migrations_to_run:
203                 if "apps" not in state.__dict__:
204                     state.apps  # Render all -- performance critical
205                 # The state before this migration
206                 states[migration] = state
207                 # The old state keeps as-is, we continue with the new state
208                 state = migration.mutate_state(state, preserve=True)
209                 migrations_to_run.remove(migration)
210             elif migration in applied_migrations:
211                 # Only mutate the state if the migration is actually applied
212                 # to make sure the resulting state doesn't include changes
213                 # from unrelated migrations.
214                 migration.mutate_state(state, preserve=False)
215         if self.progress_callback:
216             self.progress_callback("render_success")
217 
218         for migration, _ in plan:
219             self.unapply_migration(states[migration], migration, fake=fake)
220             applied_migrations.remove(migration)
221 
222         # Generate the post migration state by starting from the state before
223         # the last migration is unapplied and mutating it to include all the
224         # remaining applied migrations.
225         last_unapplied_migration = plan[-1][0]
226         state = states[last_unapplied_migration]
227         for index, (migration, _) in enumerate(full_plan):
228             if migration == last_unapplied_migration:
229                 for migration, _ in full_plan[index:]:
230                     if migration in applied_migrations:
231                         migration.mutate_state(state, preserve=False)
232                 break
233 
234         return state
235 
236     def apply_migration(self, state, migration, fake=False, fake_initial=False):
237         """Run a migration forwards."""
238         migration_recorded = False
239         if self.progress_callback:
240             self.progress_callback("apply_start", migration, fake)
241         if not fake:
242             if fake_initial:
243                 # Test to see if this is an already-applied initial migration
244                 applied, state = self.detect_soft_applied(state, migration)
245                 if applied:
246                     fake = True
247             if not fake:
248                 # Alright, do it normally
249                 with self.connection.schema_editor(
250                     atomic=migration.atomic
251                 ) as schema_editor:
252                     state = migration.apply(state, schema_editor)
253                     if not schema_editor.deferred_sql:
254                         self.record_migration(migration)
255                         migration_recorded = True
256         if not migration_recorded:
257             self.record_migration(migration)
258         # Report progress
259         if self.progress_callback:
260             self.progress_callback("apply_success", migration, fake)
261         return state
262 
263     def record_migration(self, migration):
264         # For replacement migrations, record individual statuses
265         if migration.replaces:
266             for app_label, name in migration.replaces:
267                 self.recorder.record_applied(app_label, name)
268         else:
269             self.recorder.record_applied(migration.app_label, migration.name)
270 
271     def unapply_migration(self, state, migration, fake=False):
272         """Run a migration backwards."""
273         if self.progress_callback:
274             self.progress_callback("unapply_start", migration, fake)
275         if not fake:
276             with self.connection.schema_editor(
277                 atomic=migration.atomic
278             ) as schema_editor:
279                 state = migration.unapply(state, schema_editor)
280         # For replacement migrations, also record individual statuses.
281         if migration.replaces:
282             for app_label, name in migration.replaces:
283                 self.recorder.record_unapplied(app_label, name)
284         self.recorder.record_unapplied(migration.app_label, migration.name)
285         # Report progress
286         if self.progress_callback:
287             self.progress_callback("unapply_success", migration, fake)
288         return state
289 
290     def check_replacements(self):
291         """
292         Mark replacement migrations applied if their replaced set all are.
293 
294         Do this unconditionally on every migrate, rather than just when
295         migrations are applied or unapplied, to correctly handle the case
296         when a new squash migration is pushed to a deployment that already had
297         all its replaced migrations applied. In this case no new migration will
298         be applied, but the applied state of the squashed migration must be
299         maintained.
300         """
301         applied = self.recorder.applied_migrations()
302         for key, migration in self.loader.replacements.items():
303             all_applied = all(m in applied for m in migration.replaces)
304             if all_applied and key not in applied:
305                 self.recorder.record_applied(*key)
306 
307     def detect_soft_applied(self, project_state, migration):
308         """
309         Test whether a migration has been implicitly applied - that the
310         tables or columns it would create exist. This is intended only for use
311         on initial migrations (as it only looks for CreateModel and AddField).
312         """
313 
314         def should_skip_detecting_model(migration, model):
315             """
316             No need to detect tables for proxy models, unmanaged models, or
317             models that can't be migrated on the current database.
318             """
319             return (
320                 model._meta.proxy
321                 or not model._meta.managed
322                 or not router.allow_migrate(
323                     self.connection.alias,
324                     migration.app_label,
325                     model_name=model._meta.model_name,
326                 )
327             )
328 
329         if migration.initial is None:
330             # Bail if the migration isn't the first one in its app
331             if any(app == migration.app_label for app, name in migration.dependencies):
332                 return False, project_state
333         elif migration.initial is False:
334             # Bail if it's NOT an initial migration
335             return False, project_state
336 
337         if project_state is None:
338             after_state = self.loader.project_state(
339                 (migration.app_label, migration.name), at_end=True
340             )
341         else:
342             after_state = migration.mutate_state(project_state)
343         apps = after_state.apps
344         found_create_model_migration = False
345         found_add_field_migration = False
346         fold_identifier_case = self.connection.features.ignores_table_name_case
347         with self.connection.cursor() as cursor:
348             existing_table_names = set(
349                 self.connection.introspection.table_names(cursor)
350             )
351             if fold_identifier_case:
352                 existing_table_names = {
353                     name.casefold() for name in existing_table_names
354                 }
355         # Make sure all create model and add field operations are done
356         for operation in migration.operations:
357             if isinstance(operation, migrations.CreateModel):
358                 model = apps.get_model(migration.app_label, operation.name)
359                 if model._meta.swapped:
360                     # We have to fetch the model to test with from the
361                     # main app cache, as it's not a direct dependency.
362                     model = global_apps.get_model(model._meta.swapped)
363                 if should_skip_detecting_model(migration, model):
364                     continue
365                 db_table = model._meta.db_table
366                 if fold_identifier_case:
367                     db_table = db_table.casefold()
368                 if db_table not in existing_table_names:
369                     return False, project_state
370                 found_create_model_migration = True
371             elif isinstance(operation, migrations.AddField):
372                 model = apps.get_model(migration.app_label, operation.model_name)
373                 if model._meta.swapped:
374                     # We have to fetch the model to test with from the
375                     # main app cache, as it's not a direct dependency.
376                     model = global_apps.get_model(model._meta.swapped)
377                 if should_skip_detecting_model(migration, model):
378                     continue
379 
380                 table = model._meta.db_table
381                 field = model._meta.get_field(operation.name)
382 
383                 # Handle implicit many-to-many tables created by AddField.
384                 if field.many_to_many:
385                     through_db_table = field.remote_field.through._meta.db_table
386                     if fold_identifier_case:
387                         through_db_table = through_db_table.casefold()
388                     if through_db_table not in existing_table_names:
389                         return False, project_state
390                     else:
391                         found_add_field_migration = True
392                         continue
393                 with self.connection.cursor() as cursor:
394                     columns = self.connection.introspection.get_table_description(
395                         cursor, table
396                     )
397                 for column in columns:
398                     field_column = field.column
399                     column_name = column.name
400                     if fold_identifier_case:
401                         column_name = column_name.casefold()
402                         field_column = field_column.casefold()
403                     if column_name == field_column:
404                         found_add_field_migration = True
405                         break
406                 else:
407                     return False, project_state
408         # If we get this far and we found at least one CreateModel or AddField
409         # migration, the migration is considered implicitly applied.
410         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 06:29:21.084 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 06:29:21.084 | INFO     | Search-only: skipping patch selection
2025-10-15 06:29:21.234 | INFO     | Task django__django-16281 completed successfully.
2025-10-15 06:29:21.234 | INFO     | No patch generated. You can try running ACR again.
