[
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__6.2/sphinx/domains/python.py",
        "start": 131,
        "end": 253,
        "class_name": null,
        "method_name": "_parse_annotation",
        "code": "131 def _parse_annotation(annotation: str, env: BuildEnvironment | None) -> list[Node]:\n132     \"\"\"Parse type annotation.\"\"\"\n133     def unparse(node: ast.AST) -> list[Node]:\n134         if isinstance(node, ast.Attribute):\n135             return [nodes.Text(f\"{unparse(node.value)[0]}.{node.attr}\")]\n136         if isinstance(node, ast.BinOp):\n137             result: list[Node] = unparse(node.left)\n138             result.extend(unparse(node.op))\n139             result.extend(unparse(node.right))\n140             return result\n141         if isinstance(node, ast.BitOr):\n142             return [addnodes.desc_sig_space(),\n143                     addnodes.desc_sig_punctuation('', '|'),\n144                     addnodes.desc_sig_space()]\n145         if isinstance(node, ast.Constant):\n146             if node.value is Ellipsis:\n147                 return [addnodes.desc_sig_punctuation('', \"...\")]\n148             if isinstance(node.value, bool):\n149                 return [addnodes.desc_sig_keyword('', repr(node.value))]\n150             if isinstance(node.value, int):\n151                 return [addnodes.desc_sig_literal_number('', repr(node.value))]\n152             if isinstance(node.value, str):\n153                 return [addnodes.desc_sig_literal_string('', repr(node.value))]\n154             else:\n155                 # handles None, which is further handled by type_to_xref later\n156                 # and fallback for other types that should be converted\n157                 return [nodes.Text(repr(node.value))]\n158         if isinstance(node, ast.Expr):\n159             return unparse(node.value)\n160         if isinstance(node, ast.Index):\n161             return unparse(node.value)\n162         if isinstance(node, ast.Invert):\n163             return [addnodes.desc_sig_punctuation('', '~')]\n164         if isinstance(node, ast.List):\n165             result = [addnodes.desc_sig_punctuation('', '[')]\n166             if node.elts:\n167                 # check if there are elements in node.elts to only pop the\n168                 # last element of result if the for-loop was run at least\n169                 # once\n170                 for elem in node.elts:\n171                     result.extend(unparse(elem))\n172                     result.append(addnodes.desc_sig_punctuation('', ','))\n173                     result.append(addnodes.desc_sig_space())\n174                 result.pop()\n175                 result.pop()\n176             result.append(addnodes.desc_sig_punctuation('', ']'))\n177             return result\n178         if isinstance(node, ast.Module):\n179             return sum((unparse(e) for e in node.body), [])\n180         if isinstance(node, ast.Name):\n181             return [nodes.Text(node.id)]\n182         if isinstance(node, ast.Subscript):\n183             if getattr(node.value, 'id', '') in {'Optional', 'Union'}:\n184                 return _unparse_pep_604_annotation(node)\n185             result = unparse(node.value)\n186             result.append(addnodes.desc_sig_punctuation('', '['))\n187             result.extend(unparse(node.slice))\n188             result.append(addnodes.desc_sig_punctuation('', ']'))\n189 \n190             # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal\n191             if result[0] in ('Literal', 'typing.Literal'):\n192                 for i, subnode in enumerate(result[1:], start=1):\n193                     if isinstance(subnode, nodes.Text):\n194                         result[i] = nodes.literal('', '', subnode)\n195             return result\n196         if isinstance(node, ast.UnaryOp):\n197             return unparse(node.op) + unparse(node.operand)\n198         if isinstance(node, ast.Tuple):\n199             if node.elts:\n200                 result = []\n201                 for elem in node.elts:\n202                     result.extend(unparse(elem))\n203                     result.append(addnodes.desc_sig_punctuation('', ','))\n204                     result.append(addnodes.desc_sig_space())\n205                 result.pop()\n206                 result.pop()\n207             else:\n208                 result = [addnodes.desc_sig_punctuation('', '('),\n209                           addnodes.desc_sig_punctuation('', ')')]\n210 \n211             return result\n212         raise SyntaxError  # unsupported syntax\n213 \n214     def _unparse_pep_604_annotation(node: ast.Subscript) -> list[Node]:\n215         subscript = node.slice\n216         if isinstance(subscript, ast.Index):\n217             # py38 only\n218             subscript = subscript.value  # type: ignore[assignment]\n219 \n220         flattened: list[Node] = []\n221         if isinstance(subscript, ast.Tuple):\n222             flattened.extend(unparse(subscript.elts[0]))\n223             for elt in subscript.elts[1:]:\n224                 flattened.extend(unparse(ast.BitOr()))\n225                 flattened.extend(unparse(elt))\n226         else:\n227             # e.g. a Union[] inside an Optional[]\n228             flattened.extend(unparse(subscript))\n229 \n230         if getattr(node.value, 'id', '') == 'Optional':\n231             flattened.extend(unparse(ast.BitOr()))\n232             flattened.append(nodes.Text('None'))\n233 \n234         return flattened\n235 \n236     try:\n237         tree = ast.parse(annotation, type_comments=True)\n238         result: list[Node] = []\n239         for node in unparse(tree):\n240             if isinstance(node, nodes.literal):\n241                 result.append(node[0])\n242             elif isinstance(node, nodes.Text) and node.strip():\n243                 if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and\n244                         result[-1].astext() == '~'):\n245                     result.pop()\n246                     result.append(type_to_xref(str(node), env, suppress_prefix=True))\n247                 else:\n248                     result.append(type_to_xref(str(node), env))\n249             else:\n250                 result.append(node)\n251         return result\n252     except SyntaxError:\n253         return [type_to_xref(annotation, env)]\n",
        "intended_behavior": "The `_parse_annotation` method needs to be enhanced to incorporate cleaner formatting for `Union`, `Optional`, `Literal`, and constants in line with PEP 604 and the specific improvements requested in the issue. These enhancements include:\n\n- For `Union` type annotations, directly handle AST nodes representing the union (e.g., `ast.BinOp` nodes with `ast.BitOr` operators) to output `X | Y` instead of `Union[X, Y]`.\n- For `Optional` type annotations, detect patterns matching `Optional[X]` and transform them into `X | None`.\n- For `Literal` type annotations, simplify the display of literals by removing the \"Literal\" preamble and displaying the values directly, applying normal Python syntax highlighting to these literals to differentiate them clearly in the documentation.\n- Maintain the existing functionality for all other types of annotations not specifically mentioned in the issue, ensuring that the solution is backward compatible and does not negatively impact the formatting of other types of annotations.\n- Implement these changes behind a configuration option, allowing Sphinx users to opt-in to this new style of type annotation display. This would likely involve adding a new configuration parameter and modifying the Sphinx build environment to conditionally apply these formatting rules based on the user's configuration.\n\nThe modifications should focus on extending or adapting the inner functions within `_parse_annotation`, such as the `unparse` function and possibly introducing a new helper function (like the existing `_unparse_pep_604_annotation`) to encapsulate the logic for handling `Union` and `Optional` in the PEP 604 style, ensuring the code remains readable and maintainable.\n\nAdditionally, attention should be given to correctly integrating these changes with the rest of the Sphinx build process, particularly in how type annotations are processed and displayed in the generated documentation, to ensure a seamless user experience and no disruption to existing documentation projects not opting into this new formatting."
    }
]