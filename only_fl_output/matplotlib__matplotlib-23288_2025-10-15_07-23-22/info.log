2025-10-15 07:23:22.318 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:23:25.769 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=445, output_tokens=12, cost=0.004810
2025-10-15 07:23:45.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=625, output_tokens=635, cost=0.025300
2025-10-15 07:23:47.144 | INFO     | registered non reproducing test 0
2025-10-15 07:24:00.586 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1548, output_tokens=612, cost=0.033840
2025-10-15 07:24:01.994 | INFO     | registered non reproducing test 1
2025-10-15 07:24:21.721 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1542, output_tokens=626, cost=0.034200
2025-10-15 07:24:23.107 | INFO     | registered non reproducing test 2
2025-10-15 07:24:23.107 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 07:24:23.112 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:24:30.591 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=278, cost=0.015870
2025-10-15 07:24:30.597 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:24:33.682 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=632, output_tokens=66, cost=0.008300
2025-10-15 07:24:33.683 | DEBUG    | Extracted a valid json.
2025-10-15 07:24:33.683 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"savefig\")",
        "search_code(\"plt.text\")",
        "search_code(\"url\")",
        "search_class(\"PDFPages\")",
        "search_method_in_class(\"draw_text\", \"PDFPages\")"
    ],
    "bug_locations": []
}
2025-10-15 07:24:34.038 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:24:34.039 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:24:51.677 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2288, output_tokens=716, cost=0.044360
2025-10-15 07:24:51.684 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:25:00.872 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3220, output_tokens=338, cost=0.042340
2025-10-15 07:25:00.877 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:25:05.568 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=150, cost=0.011420
2025-10-15 07:25:05.569 | DEBUG    | Extracted a valid json.
2025-10-15 07:25:05.569 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/backends/backend_pdf.py",
            "class": "",
            "method": "",
            "intended_behavior": "The method responsible for rendering text with URLs in PDFs should account for the text's rotation by correctly implementing the 'QuadPoints' in addition to the 'Rect' for link annotations. This implementation should allow the clickable area to correctly rotate with the text, matching its visual orientation. This enhancement must maintain backward compatibility by also providing a 'Rect' that encompasses the rotated text's footprint, ensuring that viewers not supporting 'QuadPoints' still offer a functional (though potentially less precise) clickable area."
        }
    ]
}
2025-10-15 07:25:05.579 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/backends/backend_pdf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A PDF Matplotlib backend.
3 
4 Author: Jouni K Sepp√§nen <jks@iki.fi> and others.
5 """
6 
7 import codecs
8 from datetime import datetime
9 from enum import Enum
10 from functools import total_ordering
11 from io import BytesIO
12 import itertools
13 import logging
14 import math
15 import os
16 import re
17 import string
18 import struct
19 import sys
20 import time
21 import types
22 import warnings
23 import zlib
24 
25 import numpy as np
26 from PIL import Image
27 
28 import matplotlib as mpl
29 from matplotlib import _api, _text_helpers, _type1font, cbook, dviread
30 from matplotlib._pylab_helpers import Gcf
31 from matplotlib.backend_bases import (
32     _Backend, FigureCanvasBase, FigureManagerBase, GraphicsContextBase,
33     RendererBase)
34 from matplotlib.backends.backend_mixed import MixedModeRenderer
35 from matplotlib.figure import Figure
36 from matplotlib.font_manager import findfont, get_font
37 from matplotlib._afm import AFM
38 from matplotlib.ft2font import (FIXED_WIDTH, ITALIC, LOAD_NO_SCALE,
39                                 LOAD_NO_HINTING, KERNING_UNFITTED, FT2Font)
40 from matplotlib.transforms import Affine2D, BboxBase
41 from matplotlib.path import Path
42 from matplotlib.dates import UTC
43 from matplotlib import _path
44 from . import _backend_pdf_ps
45 
46 _log = logging.getLogger(__name__)
47 
48 # Overview
49 #
50 # The low-level knowledge about pdf syntax lies mainly in the pdfRepr
51 # function and the classes Reference, Name, Operator, and Stream.  The
52 # PdfFile class knows about the overall structure of pdf documents.
53 # It provides a "write" method for writing arbitrary strings in the
54 # file, and an "output" method that passes objects through the pdfRepr
55 # function before writing them in the file.  The output method is
56 # called by the RendererPdf class, which contains the various draw_foo
57 # methods.  RendererPdf contains a GraphicsContextPdf instance, and
58 # each draw_foo calls self.check_gc before outputting commands.  This
59 # method checks whether the pdf graphics state needs to be modified
60 # and outputs the necessary commands.  GraphicsContextPdf represents
61 # the graphics state, and its "delta" method returns the commands that
62 # modify the state.
63 
64 # Add "pdf.use14corefonts: True" in your configuration file to use only
65 # the 14 PDF core fonts. These fonts do not need to be embedded; every
66 # PDF viewing application is required to have them. This results in very
67 # light PDF files you can use directly in LaTeX or ConTeXt documents
68 # generated with pdfTeX, without any conversion.
69 
70 # These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,
71 # Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,
72 # Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,
73 # Times-BoldItalic, Symbol, ZapfDingbats.
74 #
75 # Some tricky points:
76 #
77 # 1. The clip path can only be widened by popping from the state
78 # stack.  Thus the state must be pushed onto the stack before narrowing
79 # the clip path.  This is taken care of by GraphicsContextPdf.
80 #
81 # 2. Sometimes it is necessary to refer to something (e.g., font,
82 # image, or extended graphics state, which contains the alpha value)
83 # in the page stream by a name that needs to be defined outside the
84 # stream.  PdfFile provides the methods fontName, imageObject, and
85 # alphaState for this purpose.  The implementations of these methods
86 # should perhaps be generalized.
87 
88 # TODOs:
89 #
90 # * encoding of fonts, including mathtext fonts and Unicode support
91 # * TTF support has lots of small TODOs, e.g., how do you know if a font
92 #   is serif/sans-serif, or symbolic/non-symbolic?
93 # * draw_quad_mesh
94 
95 
96 @_api.deprecated("3.6", alternative="Vendor the code")
97 def fill(strings, linelen=75):
98     return _fill(strings, linelen=linelen)
99 
100 
101 def _fill(strings, linelen=75):
102     """
103     Make one string from sequence of strings, with whitespace in between.
104 
105     The whitespace is chosen to form lines of at most *linelen* characters,
106     if possible.
107     """
108     currpos = 0
109     lasti = 0
110     result = []
111     for i, s in enumerate(strings):
112         length = len(s)
113         if currpos + length < linelen:
114             currpos += length + 1
115         else:
116             result.append(b' '.join(strings[lasti:i]))
117             lasti = i
118             currpos = length
119     result.append(b' '.join(strings[lasti:]))
120     return b'\n'.join(result)
121 
122 # PDF strings are supposed to be able to include any eight-bit data,
123 # except that unbalanced parens and backslashes must be escaped by a
124 # backslash. However, sf bug #2708559 shows that the carriage return
125 # character may get read as a newline; these characters correspond to
126 # \gamma and \Omega in TeX's math font encoding. Escaping them fixes
127 # the bug.
128 _string_escape_regex = re.compile(br'([\\()\r\n])')
129 
130 
131 def _string_escape(match):
132     m = match.group(0)
133     if m in br'\()':
134         return b'\\' + m
135     elif m == b'\n':
136         return br'\n'
137     elif m == b'\r':
138         return br'\r'
139     assert False
140 
141 
142 def _create_pdf_info_dict(backend, metadata):
143     """
144     Create a PDF infoDict based on user-supplied metadata.
145 
146     A default ``Creator``, ``Producer``, and ``CreationDate`` are added, though
147     the user metadata may override it. The date may be the current time, or a
148     time set by the ``SOURCE_DATE_EPOCH`` environment variable.
149 
150     Metadata is verified to have the correct keys and their expected types. Any
151     unknown keys/types will raise a warning.
152 
153     Parameters
154     ----------
155     backend : str
156         The name of the backend to use in the Producer value.
157 
158     metadata : dict[str, Union[str, datetime, Name]]
159         A dictionary of metadata supplied by the user with information
160         following the PDF specification, also defined in
161         `~.backend_pdf.PdfPages` below.
162 
163         If any value is *None*, then the key will be removed. This can be used
164         to remove any pre-defined values.
165 
166     Returns
167     -------
168     dict[str, Union[str, datetime, Name]]
169         A validated dictionary of metadata.
170     """
171 
172     # get source date from SOURCE_DATE_EPOCH, if set
173     # See https://reproducible-builds.org/specs/source-date-epoch/
174     source_date_epoch = os.getenv("SOURCE_DATE_EPOCH")
175     if source_date_epoch:
176         source_date = datetime.utcfromtimestamp(int(source_date_epoch))
177         source_date = source_date.replace(tzinfo=UTC)
178     else:
179         source_date = datetime.today()
180 
181     info = {
182         'Creator': f'Matplotlib v{mpl.__version__}, https://matplotlib.org',
183         'Producer': f'Matplotlib {backend} backend v{mpl.__version__}',
184         'CreationDate': source_date,
185         **metadata
186     }
187     info = {k: v for (k, v) in info.items() if v is not None}
188 
189     def is_string_like(x):
190         return isinstance(x, str)
191     is_string_like.text_for_warning = "an instance of str"
192 
193     def is_date(x):
194         return isinstance(x, datetime)
195     is_date.text_for_warning = "an instance of datetime.datetime"
196 
197     def check_trapped(x):
198         if isinstance(x, Name):
199             return x.name in (b'True', b'False', b'Unknown')
200         else:
201             return x in ('True', 'False', 'Unknown')
202     check_trapped.text_for_warning = 'one of {"True", "False", "Unknown"}'
203 
204     keywords = {
205         'Title': is_string_like,
206         'Author': is_string_like,
207         'Subject': is_string_like,
208         'Keywords': is_string_like,
209         'Creator': is_string_like,
210         'Producer': is_string_like,
211         'CreationDate': is_date,
212         'ModDate': is_date,
213         'Trapped': check_trapped,
214     }
215     for k in info:
216         if k not in keywords:
217             _api.warn_external(f'Unknown infodict keyword: {k!r}. '
218                                f'Must be one of {set(keywords)!r}.')
219         elif not keywords[k](info[k]):
220             _api.warn_external(f'Bad value for infodict keyword {k}. '
221                                f'Got {info[k]!r} which is not '
222                                f'{keywords[k].text_for_warning}.')
223     if 'Trapped' in info:
224         info['Trapped'] = Name(info['Trapped'])
225 
226     return info
227 
228 
229 def _datetime_to_pdf(d):
230     """
231     Convert a datetime to a PDF string representing it.
232 
233     Used for PDF and PGF.
234     """
235     r = d.strftime('D:%Y%m%d%H%M%S')
236     z = d.utcoffset()
237     if z is not None:
238         z = z.seconds
239     else:
240         if time.daylight:
241             z = time.altzone
242         else:
243             z = time.timezone
244     if z == 0:
245         r += 'Z'
246     elif z < 0:
247         r += "+%02d'%02d'" % ((-z) // 3600, (-z) % 3600)
248     else:
249         r += "-%02d'%02d'" % (z // 3600, z % 3600)
250     return r
251 
252 
253 def pdfRepr(obj):
254     """Map Python objects to PDF syntax."""
255 
256     # Some objects defined later have their own pdfRepr method.
257     if hasattr(obj, 'pdfRepr'):
258         return obj.pdfRepr()
259 
260     # Floats. PDF does not have exponential notation (1.0e-10) so we
261     # need to use %f with some precision.  Perhaps the precision
262     # should adapt to the magnitude of the number?
263     elif isinstance(obj, (float, np.floating)):
264         if not np.isfinite(obj):
265             raise ValueError("Can only output finite numbers in PDF")
266         r = b"%.10f" % obj
267         return r.rstrip(b'0').rstrip(b'.')
268 
269     # Booleans. Needs to be tested before integers since
270     # isinstance(True, int) is true.
271     elif isinstance(obj, bool):
272         return [b'false', b'true'][obj]
273 
274     # Integers are written as such.
275     elif isinstance(obj, (int, np.integer)):
276         return b"%d" % obj
277 
278     # Unicode strings are encoded in UTF-16BE with byte-order mark.
279     elif isinstance(obj, str):
280         try:
281             # But maybe it's really ASCII?
282             s = obj.encode('ASCII')
283             return pdfRepr(s)
284         except UnicodeEncodeError:
285             s = codecs.BOM_UTF16_BE + obj.encode('UTF-16BE')
286             return pdfRepr(s)
287 
288     # Strings are written in parentheses, with backslashes and parens
289     # escaped. Actually balanced parens are allowed, but it is
290     # simpler to escape them all. TODO: cut long strings into lines;
291     # I believe there is some maximum line length in PDF.
292     elif isinstance(obj, bytes):
293         return b'(' + _string_escape_regex.sub(_string_escape, obj) + b')'
294 
295     # Dictionaries. The keys must be PDF names, so if we find strings
296     # there, we make Name objects from them. The values may be
297     # anything, so the caller must ensure that PDF names are
298     # represented as Name objects.
299     elif isinstance(obj, dict):
300         return _fill([
301             b"<<",
302             *[Name(k).pdfRepr() + b" " + pdfRepr(v) for k, v in obj.items()],
303             b">>",
304         ])
305 
306     # Lists.
307     elif isinstance(obj, (list, tuple)):
308         return _fill([b"[", *[pdfRepr(val) for val in obj], b"]"])
309 
310     # The null keyword.
311     elif obj is None:
312         return b'null'
313 
314     # A date.
315     elif isinstance(obj, datetime):
316         return pdfRepr(_datetime_to_pdf(obj))
317 
318     # A bounding box
319     elif isinstance(obj, BboxBase):
320         return _fill([pdfRepr(val) for val in obj.bounds])
321 
322     else:
323         raise TypeError("Don't know a PDF representation for {} objects"
324                         .format(type(obj)))
325 
326 
327 def _font_supports_glyph(fonttype, glyph):
328     """
329     Returns True if the font is able to provide codepoint *glyph* in a PDF.
330 
331     For a Type 3 font, this method returns True only for single-byte
332     characters. For Type 42 fonts this method return True if the character is
333     from the Basic Multilingual Plane.
334     """
335     if fonttype == 3:
336         return glyph <= 255
337     if fonttype == 42:
338         return glyph <= 65535
339     raise NotImplementedError()
340 
341 
342 class Reference:
343     """
344     PDF reference object.
345 
346     Use PdfFile.reserveObject() to create References.
347     """
348 
349     def __init__(self, id):
350         self.id = id
351 
352     def __repr__(self):
353         return "<Reference %d>" % self.id
354 
355     def pdfRepr(self):
356         return b"%d 0 R" % self.id
357 
358     def write(self, contents, file):
359         write = file.write
360         write(b"%d 0 obj\n" % self.id)
361         write(pdfRepr(contents))
362         write(b"\nendobj\n")
363 
364 
365 @total_ordering
366 class Name:
367     """PDF name object."""
368     __slots__ = ('name',)
369     _hexify = {c: '#%02x' % c
370                for c in {*range(256)} - {*range(ord('!'), ord('~') + 1)}}
371 
372     def __init__(self, name):
373         if isinstance(name, Name):
374             self.name = name.name
375         else:
376             if isinstance(name, bytes):
377                 name = name.decode('ascii')
378             self.name = name.translate(self._hexify).encode('ascii')
379 
380     def __repr__(self):
381         return "<Name %s>" % self.name
382 
383     def __str__(self):
384         return '/' + self.name.decode('ascii')
385 
386     def __eq__(self, other):
387         return isinstance(other, Name) and self.name == other.name
388 
389     def __lt__(self, other):
390         return isinstance(other, Name) and self.name < other.name
391 
392     def __hash__(self):
393         return hash(self.name)
394 
395     @staticmethod
396     @_api.deprecated("3.6")
397     def hexify(match):
398         return '#%02x' % ord(match.group())
399 
400     def pdfRepr(self):
401         return b'/' + self.name
402 
403 
404 @_api.deprecated("3.6")
405 class Operator:
406     __slots__ = ('op',)
407 
408     def __init__(self, op):
409         self.op = op
410 
411     def __repr__(self):
412         return '<Operator %s>' % self.op
413 
414     def pdfRepr(self):
415         return self.op
416 
417 
418 class Verbatim:
419     """Store verbatim PDF command content for later inclusion in the stream."""
420     def __init__(self, x):
421         self._x = x
422 
423     def pdfRepr(self):
424         return self._x
425 
426 
427 class Op(Enum):
428     """PDF operators (not an exhaustive list)."""
429 
430     close_fill_stroke = b'b'
431     fill_stroke = b'B'
432     fill = b'f'
433     closepath = b'h'
434     close_stroke = b's'
435     stroke = b'S'
436     endpath = b'n'
437     begin_text = b'BT'
438     end_text = b'ET'
439     curveto = b'c'
440     rectangle = b're'
441     lineto = b'l'
442     moveto = b'm'
443     concat_matrix = b'cm'
444     use_xobject = b'Do'
445     setgray_stroke = b'G'
446     setgray_nonstroke = b'g'
447     setrgb_stroke = b'RG'
448     setrgb_nonstroke = b'rg'
449     setcolorspace_stroke = b'CS'
450     setcolorspace_nonstroke = b'cs'
451     setcolor_stroke = b'SCN'
452     setcolor_nonstroke = b'scn'
453     setdash = b'd'
454     setlinejoin = b'j'
455     setlinecap = b'J'
456     setgstate = b'gs'
457     gsave = b'q'
458     grestore = b'Q'
459     textpos = b'Td'
460     selectfont = b'Tf'
461     textmatrix = b'Tm'
462     show = b'Tj'
463     showkern = b'TJ'
464     setlinewidth = b'w'
465     clip = b'W'
466     shading = b'sh'
467 
468     op = _api.deprecated('3.6')(property(lambda self: self.value))
469 
470     def pdfRepr(self):
471         return self.value
472 
473     @classmethod
474     def paint_path(cls, fill, stroke):
475         """
476         Return the PDF operator to paint a path.
477 
478         Parameters
479         ----------
480         fill : bool
481             Fill the path with the fill color.
482         stroke : bool
483             Stroke the outline of the path with the line color.
484         """
485         if stroke:
486             if fill:
487                 return cls.fill_stroke
488             else:
489                 return cls.stroke
490         else:
491             if fill:
492                 return cls.fill
493             else:
494                 return cls.endpath
495 
496 
497 class Stream:
498     """
499     PDF stream object.
500 
501     This has no pdfRepr method. Instead, call begin(), then output the
502     contents of the stream by calling write(), and finally call end().
503     """
504     __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')
505 
506     def __init__(self, id, len, file, extra=None, png=None):
507         """
508         Parameters
509         ----------
510         id : int
511             Object id of the stream.
512         len : Reference or None
513             An unused Reference object for the length of the stream;
514             None means to use a memory buffer so the length can be inlined.
515         file : PdfFile
516             The underlying object to write the stream to.
517         extra : dict from Name to anything, or None
518             Extra key-value pairs to include in the stream header.
519         png : dict or None
520             If the data is already png encoded, the decode parameters.
521         """
522         self.id = id            # object id
523         self.len = len          # id of length object
524         self.pdfFile = file
525         self.file = file.fh      # file to which the stream is written
526         self.compressobj = None  # compression object
527         if extra is None:
528             self.extra = dict()
529         else:
530             self.extra = extra.copy()
531         if png is not None:
532             self.extra.update({'Filter':      Name('FlateDecode'),
533                                'DecodeParms': png})
534 
535         self.pdfFile.recordXref(self.id)
536         if mpl.rcParams['pdf.compression'] and not png:
537             self.compressobj = zlib.compressobj(
538                 mpl.rcParams['pdf.compression'])
539         if self.len is None:
540             self.file = BytesIO()
541         else:
542             self._writeHeader()
543             self.pos = self.file.tell()
544 
545     def _writeHeader(self):
546         write = self.file.write
547         write(b"%d 0 obj\n" % self.id)
548         dict = self.extra
549         dict['Length'] = self.len
550         if mpl.rcParams['pdf.compression']:
551             dict['Filter'] = Name('FlateDecode')
552 
553         write(pdfRepr(dict))
554         write(b"\nstream\n")
555 
556     def end(self):
557         """Finalize stream."""
558 
559         self._flush()
560         if self.len is None:
561             contents = self.file.getvalue()
562             self.len = len(contents)
563             self.file = self.pdfFile.fh
564             self._writeHeader()
565             self.file.write(contents)
566             self.file.write(b"\nendstream\nendobj\n")
567         else:
568             length = self.file.tell() - self.pos
569             self.file.write(b"\nendstream\nendobj\n")
570             self.pdfFile.writeObject(self.len, length)
571 
572     def write(self, data):
573         """Write some data on the stream."""
574 
575         if self.compressobj is None:
576             self.file.write(data)
577         else:
578             compressed = self.compressobj.compress(data)
579             self.file.write(compressed)
580 
581     def _flush(self):
582         """Flush the compression object."""
583 
584         if self.compressobj is not None:
585             compressed = self.compressobj.flush()
586             self.file.write(compressed)
587             self.compressobj = None
588 
589 
590 def _get_pdf_charprocs(font_path, glyph_ids):
591     font = get_font(font_path, hinting_factor=1)
592     conv = 1000 / font.units_per_EM  # Conversion to PS units (1/1000's).
593     procs = {}
594     for glyph_id in glyph_ids:
595         g = font.load_glyph(glyph_id, LOAD_NO_SCALE)
596         # NOTE: We should be using round(), but instead use
597         # "(x+.5).astype(int)" to keep backcompat with the old ttconv code
598         # (this is different for negative x's).
599         d1 = (np.array([g.horiAdvance, 0, *g.bbox]) * conv + .5).astype(int)
600         v, c = font.get_path()
601         v = (v * 64).astype(int)  # Back to TrueType's internal units (1/64's).
602         # Backcompat with old ttconv code: control points between two quads are
603         # omitted if they are exactly at the midpoint between the control of
604         # the quad before and the quad after, but ttconv used to interpolate
605         # *after* conversion to PS units, causing floating point errors.  Here
606         # we reproduce ttconv's logic, detecting these "implicit" points and
607         # re-interpolating them.  Note that occasionally (e.g. with DejaVu Sans
608         # glyph "0") a point detected as "implicit" is actually explicit, and
609         # will thus be shifted by 1.
610         quads, = np.nonzero(c == 3)
611         quads_on = quads[1::2]
612         quads_mid_on = np.array(
613             sorted({*quads_on} & {*(quads - 1)} & {*(quads + 1)}), int)
614         implicit = quads_mid_on[
615             (v[quads_mid_on]  # As above, use astype(int), not // division
616              == ((v[quads_mid_on - 1] + v[quads_mid_on + 1]) / 2).astype(int))
617             .all(axis=1)]
618         if (font.postscript_name, glyph_id) in [
619                 ("DejaVuSerif-Italic", 77),  # j
620                 ("DejaVuSerif-Italic", 135),  # \AA
621         ]:
622             v[:, 0] -= 1  # Hard-coded backcompat (FreeType shifts glyph by 1).
623         v = (v * conv + .5).astype(int)  # As above re: truncation vs rounding.
624         v[implicit] = ((  # Fix implicit points; again, truncate.
625             (v[implicit - 1] + v[implicit + 1]) / 2).astype(int))
626         procs[font.get_glyph_name(glyph_id)] = (
627             " ".join(map(str, d1)).encode("ascii") + b" d1\n"
628             + _path.convert_to_string(
629                 Path(v, c), None, None, False, None, -1,
630                 # no code for quad Beziers triggers auto-conversion to cubics.
631                 [b"m", b"l", b"", b"c", b"h"], True)
632             + b"f")
633     return procs
634 
635 
636 class PdfFile:
637     """PDF file object."""
638 
639     def __init__(self, filename, metadata=None):
640         """
641         Parameters
642         ----------
643         filename : str or path-like or file-like
644             Output target; if a string, a file will be opened for writing.
645 
646         metadata : dict from strings to strings and dates
647             Information dictionary object (see PDF reference section 10.2.1
648             'Document Information Dictionary'), e.g.:
649             ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.
650 
651             The standard keys are 'Title', 'Author', 'Subject', 'Keywords',
652             'Creator', 'Producer', 'CreationDate', 'ModDate', and
653             'Trapped'. Values have been predefined for 'Creator', 'Producer'
654             and 'CreationDate'. They can be removed by setting them to `None`.
655         """
656         super().__init__()
657 
658         self._object_seq = itertools.count(1)  # consumed by reserveObject
659         self.xrefTable = [[0, 65535, 'the zero object']]
660         self.passed_in_file_object = False
661         self.original_file_like = None
662         self.tell_base = 0
663         fh, opened = cbook.to_filehandle(filename, "wb", return_opened=True)
664         if not opened:
665             try:
666                 self.tell_base = filename.tell()
667             except IOError:
668                 fh = BytesIO()
669                 self.original_file_like = filename
670             else:
671                 fh = filename
672                 self.passed_in_file_object = True
673 
674         self.fh = fh
675         self.currentstream = None  # stream object to write to, if any
676         fh.write(b"%PDF-1.4\n")    # 1.4 is the first version to have alpha
677         # Output some eight-bit chars as a comment so various utilities
678         # recognize the file as binary by looking at the first few
679         # lines (see note in section 3.4.1 of the PDF reference).
680         fh.write(b"%\254\334 \253\272\n")
681 
682         self.rootObject = self.reserveObject('root')
683         self.pagesObject = self.reserveObject('pages')
684         self.pageList = []
685         self.fontObject = self.reserveObject('fonts')
686         self._extGStateObject = self.reserveObject('extended graphics states')
687         self.hatchObject = self.reserveObject('tiling patterns')
688         self.gouraudObject = self.reserveObject('Gouraud triangles')
689         self.XObjectObject = self.reserveObject('external objects')
690         self.resourceObject = self.reserveObject('resources')
691 
692         root = {'Type': Name('Catalog'),
693                 'Pages': self.pagesObject}
694         self.writeObject(self.rootObject, root)
695 
696         self.infoDict = _create_pdf_info_dict('pdf', metadata or {})
697 
698         self.fontNames = {}     # maps filenames to internal font names
699         self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))
700         self.dviFontInfo = {}   # maps dvi font names to embedding information
701         # differently encoded Type-1 fonts may share the same descriptor
702         self.type1Descriptors = {}
703         self._character_tracker = _backend_pdf_ps.CharacterTracker()
704 
705         self.alphaStates = {}   # maps alpha values to graphics state objects
706         self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))
707         self._soft_mask_states = {}
708         self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))
709         self._soft_mask_groups = []
710         self.hatchPatterns = {}
711         self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))
712         self.gouraudTriangles = []
713 
714         self._images = {}
715         self._image_seq = (Name(f'I{i}') for i in itertools.count(1))
716 
717         self.markers = {}
718         self.multi_byte_charprocs = {}
719 
720         self.paths = []
721 
722         # A list of annotations for each page. Each entry is a tuple of the
723         # overall Annots object reference that's inserted into the page object,
724         # followed by a list of the actual annotations.
725         self._annotations = []
726         # For annotations added before a page is created; mostly for the
727         # purpose of newTextnote.
728         self.pageAnnotations = []
729 
730         # The PDF spec recommends to include every procset
731         procsets = [Name(x) for x in "PDF Text ImageB ImageC ImageI".split()]
732 
733         # Write resource dictionary.
734         # Possibly TODO: more general ExtGState (graphics state dictionaries)
735         #                ColorSpace Pattern Shading Properties
736         resources = {'Font': self.fontObject,
737                      'XObject': self.XObjectObject,
738                      'ExtGState': self._extGStateObject,
739                      'Pattern': self.hatchObject,
740                      'Shading': self.gouraudObject,
741                      'ProcSet': procsets}
742         self.writeObject(self.resourceObject, resources)
743 
744     def newPage(self, width, height):
745         self.endStream()
746 
747         self.width, self.height = width, height
748         contentObject = self.reserveObject('page contents')
749         annotsObject = self.reserveObject('annotations')
750         thePage = {'Type': Name('Page'),
751                    'Parent': self.pagesObject,
752                    'Resources': self.resourceObject,
753                    'MediaBox': [0, 0, 72 * width, 72 * height],
754                    'Contents': contentObject,
755                    'Annots': annotsObject,
756                    }
757         pageObject = self.reserveObject('page')
758         self.writeObject(pageObject, thePage)
759         self.pageList.append(pageObject)
760         self._annotations.append((annotsObject, self.pageAnnotations))
761 
762         self.beginStream(contentObject.id,
763                          self.reserveObject('length of content stream'))
764         # Initialize the pdf graphics state to match the default Matplotlib
765         # graphics context (colorspace and joinstyle).
766         self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)
767         self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)
768         self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)
769 
770         # Clear the list of annotations for the next page
771         self.pageAnnotations = []
772 
773     def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):
774         # Create a new annotation of type text
775         theNote = {'Type': Name('Annot'),
776                    'Subtype': Name('Text'),
777                    'Contents': text,
778                    'Rect': positionRect,
779                    }
780         self.pageAnnotations.append(theNote)
781 
782     def _get_subsetted_psname(self, ps_name, charmap):
783         def toStr(n, base):
784             if n < base:
785                 return string.ascii_uppercase[n]
786             else:
787                 return (
788                     toStr(n // base, base) + string.ascii_uppercase[n % base]
789                 )
790 
791         # encode to string using base 26
792         hashed = hash(frozenset(charmap.keys())) % ((sys.maxsize + 1) * 2)
793         prefix = toStr(hashed, 26)
794 
795         # get first 6 characters from prefix
796         return prefix[:6] + "+" + ps_name
797 
798     def finalize(self):
799         """Write out the various deferred objects and the pdf end matter."""
800 
801         self.endStream()
802         self._write_annotations()
803         self.writeFonts()
804         self.writeExtGSTates()
805         self._write_soft_mask_groups()
806         self.writeHatches()
807         self.writeGouraudTriangles()
808         xobjects = {
809             name: ob for image, name, ob in self._images.values()}
810         for tup in self.markers.values():
811             xobjects[tup[0]] = tup[1]
812         for name, value in self.multi_byte_charprocs.items():
813             xobjects[name] = value
814         for name, path, trans, ob, join, cap, padding, filled, stroked \
815                 in self.paths:
816             xobjects[name] = ob
817         self.writeObject(self.XObjectObject, xobjects)
818         self.writeImages()
819         self.writeMarkers()
820         self.writePathCollectionTemplates()
821         self.writeObject(self.pagesObject,
822                          {'Type': Name('Pages'),
823                           'Kids': self.pageList,
824                           'Count': len(self.pageList)})
825         self.writeInfoDict()
826 
827         # Finalize the file
828         self.writeXref()
829         self.writeTrailer()
830 
831     def close(self):
832         """Flush all buffers and free all resources."""
833 
834         self.endStream()
835         if self.passed_in_file_object:
836             self.fh.flush()
837         else:
838             if self.original_file_like is not None:
839                 self.original_file_like.write(self.fh.getvalue())
840             self.fh.close()
841 
842     def write(self, data):
843         if self.currentstream is None:
844             self.fh.write(data)
845         else:
846             self.currentstream.write(data)
847 
848     def output(self, *data):
849         self.write(_fill([pdfRepr(x) for x in data]))
850         self.write(b'\n')
851 
852     def beginStream(self, id, len, extra=None, png=None):
853         assert self.currentstream is None
854         self.currentstream = Stream(id, len, self, extra, png)
855 
856     def endStream(self):
857         if self.currentstream is not None:
858             self.currentstream.end()
859             self.currentstream = None
860 
861     def outputStream(self, ref, data, *, extra=None):
862         self.beginStream(ref.id, None, extra)
863         self.currentstream.write(data)
864         self.endStream()
865 
866     def _write_annotations(self):
867         for annotsObject, annotations in self._annotations:
868             self.writeObject(annotsObject, annotations)
869 
870     def fontName(self, fontprop):
871         """
872         Select a font based on fontprop and return a name suitable for
873         Op.selectfont. If fontprop is a string, it will be interpreted
874         as the filename of the font.
875         """
876 
877         if isinstance(fontprop, str):
878             filename = fontprop
879         elif mpl.rcParams['pdf.use14corefonts']:
880             filename = findfont(
881                 fontprop, fontext='afm', directory=RendererPdf._afm_font_dir)
882         else:
883             filename = findfont(fontprop)
884 
885         Fx = self.fontNames.get(filename)
886         if Fx is None:
887             Fx = next(self._internal_font_seq)
888             self.fontNames[filename] = Fx
889             _log.debug('Assigning font %s = %r', Fx, filename)
890 
891         return Fx
892 
893     def dviFontName(self, dvifont):
894         """
895         Given a dvi font object, return a name suitable for Op.selectfont.
896         This registers the font information in ``self.dviFontInfo`` if not yet
897         registered.
898         """
899 
900         dvi_info = self.dviFontInfo.get(dvifont.texname)
901         if dvi_info is not None:
902             return dvi_info.pdfname
903 
904         tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))
905         psfont = tex_font_map[dvifont.texname]
906         if psfont.filename is None:
907             raise ValueError(
908                 "No usable font file found for {} (TeX: {}); "
909                 "the font may lack a Type-1 version"
910                 .format(psfont.psname, dvifont.texname))
911 
912         pdfname = next(self._internal_font_seq)
913         _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)
914         self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(
915             dvifont=dvifont,
916             pdfname=pdfname,
917             fontfile=psfont.filename,
918             basefont=psfont.psname,
919             encodingfile=psfont.encoding,
920             effects=psfont.effects)
921         return pdfname
922 
923     def writeFonts(self):
924         fonts = {}
925         for dviname, info in sorted(self.dviFontInfo.items()):
926             Fx = info.pdfname
927             _log.debug('Embedding Type-1 font %s from dvi.', dviname)
928             fonts[Fx] = self._embedTeXFont(info)
929         for filename in sorted(self.fontNames):
930             Fx = self.fontNames[filename]
931             _log.debug('Embedding font %s.', filename)
932             if filename.endswith('.afm'):
933                 # from pdf.use14corefonts
934                 _log.debug('Writing AFM font.')
935                 fonts[Fx] = self._write_afm_font(filename)
936             else:
937                 # a normal TrueType font
938                 _log.debug('Writing TrueType font.')
939                 chars = self._character_tracker.used.get(filename)
940                 if chars:
941                     fonts[Fx] = self.embedTTF(filename, chars)
942         self.writeObject(self.fontObject, fonts)
943 
944     def _write_afm_font(self, filename):
945         with open(filename, 'rb') as fh:
946             font = AFM(fh)
947         fontname = font.get_fontname()
948         fontdict = {'Type': Name('Font'),
949                     'Subtype': Name('Type1'),
950                     'BaseFont': Name(fontname),
951                     'Encoding': Name('WinAnsiEncoding')}
952         fontdictObject = self.reserveObject('font dictionary')
953         self.writeObject(fontdictObject, fontdict)
954         return fontdictObject
955 
956     def _embedTeXFont(self, fontinfo):
957         _log.debug('Embedding TeX font %s - fontinfo=%s',
958                    fontinfo.dvifont.texname, fontinfo.__dict__)
959 
960         # Widths
961         widthsObject = self.reserveObject('font widths')
962         self.writeObject(widthsObject, fontinfo.dvifont.widths)
963 
964         # Font dictionary
965         fontdictObject = self.reserveObject('font dictionary')
966         fontdict = {
967             'Type':      Name('Font'),
968             'Subtype':   Name('Type1'),
969             'FirstChar': 0,
970             'LastChar':  len(fontinfo.dvifont.widths) - 1,
971             'Widths':    widthsObject,
972             }
973 
974         # Encoding (if needed)
975         if fontinfo.encodingfile is not None:
976             fontdict['Encoding'] = {
977                 'Type': Name('Encoding'),
978                 'Differences': [
979                     0, *map(Name, dviread._parse_enc(fontinfo.encodingfile))],
980             }
981 
982         # If no file is specified, stop short
983         if fontinfo.fontfile is None:
984             _log.warning(
985                 "Because of TeX configuration (pdftex.map, see updmap option "
986                 "pdftexDownloadBase14) the font %s is not embedded. This is "
987                 "deprecated as of PDF 1.5 and it may cause the consumer "
988                 "application to show something that was not intended.",
989                 fontinfo.basefont)
990             fontdict['BaseFont'] = Name(fontinfo.basefont)
991             self.writeObject(fontdictObject, fontdict)
992             return fontdictObject
993 
994         # We have a font file to embed - read it in and apply any effects
995         t1font = _type1font.Type1Font(fontinfo.fontfile)
996         if fontinfo.effects:
997             t1font = t1font.transform(fontinfo.effects)
998         fontdict['BaseFont'] = Name(t1font.prop['FontName'])
999 
1000         # Font descriptors may be shared between differently encoded
1001         # Type-1 fonts, so only create a new descriptor if there is no
1002         # existing descriptor for this font.
1003         effects = (fontinfo.effects.get('slant', 0.0),
1004                    fontinfo.effects.get('extend', 1.0))
1005         fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))
1006         if fontdesc is None:
1007             fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)
1008             self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc
1009         fontdict['FontDescriptor'] = fontdesc
1010 
1011         self.writeObject(fontdictObject, fontdict)
1012         return fontdictObject
1013 
1014     def createType1Descriptor(self, t1font, fontfile):
1015         # Create and write the font descriptor and the font file
1016         # of a Type-1 font
1017         fontdescObject = self.reserveObject('font descriptor')
1018         fontfileObject = self.reserveObject('font file')
1019 
1020         italic_angle = t1font.prop['ItalicAngle']
1021         fixed_pitch = t1font.prop['isFixedPitch']
1022 
1023         flags = 0
1024         # fixed width
1025         if fixed_pitch:
1026             flags |= 1 << 0
1027         # TODO: serif
1028         if 0:
1029             flags |= 1 << 1
1030         # TODO: symbolic (most TeX fonts are)
1031         if 1:
1032             flags |= 1 << 2
1033         # non-symbolic
1034         else:
1035             flags |= 1 << 5
1036         # italic
1037         if italic_angle:
1038             flags |= 1 << 6
1039         # TODO: all caps
1040         if 0:
1041             flags |= 1 << 16
1042         # TODO: small caps
1043         if 0:
1044             flags |= 1 << 17
1045         # TODO: force bold
1046         if 0:
1047             flags |= 1 << 18
1048 
1049         ft2font = get_font(fontfile)
1050 
1051         descriptor = {
1052             'Type':        Name('FontDescriptor'),
1053             'FontName':    Name(t1font.prop['FontName']),
1054             'Flags':       flags,
1055             'FontBBox':    ft2font.bbox,
1056             'ItalicAngle': italic_angle,
1057             'Ascent':      ft2font.ascender,
1058             'Descent':     ft2font.descender,
1059             'CapHeight':   1000,  # TODO: find this out
1060             'XHeight':     500,  # TODO: this one too
1061             'FontFile':    fontfileObject,
1062             'FontFamily':  t1font.prop['FamilyName'],
1063             'StemV':       50,  # TODO
1064             # (see also revision 3874; but not all TeX distros have AFM files!)
1065             # 'FontWeight': a number where 400 = Regular, 700 = Bold
1066             }
1067 
1068         self.writeObject(fontdescObject, descriptor)
1069 
1070         self.outputStream(fontfileObject, b"".join(t1font.parts[:2]),
1071                           extra={'Length1': len(t1font.parts[0]),
1072                                  'Length2': len(t1font.parts[1]),
1073                                  'Length3': 0})
1074 
1075         return fontdescObject
1076 
1077     def _get_xobject_glyph_name(self, filename, glyph_name):
1078         Fx = self.fontName(filename)
1079         return "-".join([
1080             Fx.name.decode(),
1081             os.path.splitext(os.path.basename(filename))[0],
1082             glyph_name])
1083 
1084     _identityToUnicodeCMap = b"""/CIDInit /ProcSet findresource begin
1085 12 dict begin
1086 begincmap
1087 /CIDSystemInfo
1088 << /Registry (Adobe)
1089    /Ordering (UCS)
1090    /Supplement 0
1091 >> def
1092 /CMapName /Adobe-Identity-UCS def
1093 /CMapType 2 def
1094 1 begincodespacerange
1095 <0000> <ffff>
1096 endcodespacerange
1097 %d beginbfrange
1098 %s
1099 endbfrange
1100 endcmap
1101 CMapName currentdict /CMap defineresource pop
1102 end
1103 end"""
1104 
1105     def embedTTF(self, filename, characters):
1106         """Embed the TTF font from the named file into the document."""
1107 
1108         font = get_font(filename)
1109         fonttype = mpl.rcParams['pdf.fonttype']
1110 
1111         def cvt(length, upe=font.units_per_EM, nearest=True):
1112             """Convert font coordinates to PDF glyph coordinates."""
1113             value = length / upe * 1000
1114             if nearest:
1115                 return round(value)
1116             # Best(?) to round away from zero for bounding boxes and the like.
1117             if value < 0:
1118                 return math.floor(value)
1119             else:
1120                 return math.ceil(value)
1121 
1122         def embedTTFType3(font, characters, descriptor):
1123             """The Type 3-specific part of embedding a Truetype font"""
1124             widthsObject = self.reserveObject('font widths')
1125             fontdescObject = self.reserveObject('font descriptor')
1126             fontdictObject = self.reserveObject('font dictionary')
1127             charprocsObject = self.reserveObject('character procs')
1128             differencesArray = []
1129             firstchar, lastchar = 0, 255
1130             bbox = [cvt(x, nearest=False) for x in font.bbox]
1131 
1132             fontdict = {
1133                 'Type': Name('Font'),
1134                 'BaseFont': ps_name,
1135                 'FirstChar': firstchar,
1136                 'LastChar': lastchar,
1137                 'FontDescriptor': fontdescObject,
1138                 'Subtype': Name('Type3'),
1139                 'Name': descriptor['FontName'],
1140                 'FontBBox': bbox,
1141                 'FontMatrix': [.001, 0, 0, .001, 0, 0],
1142                 'CharProcs': charprocsObject,
1143                 'Encoding': {
1144                     'Type': Name('Encoding'),
1145                     'Differences': differencesArray},
1146                 'Widths': widthsObject
1147                 }
1148 
1149             from encodings import cp1252
1150 
1151             # Make the "Widths" array
1152             def get_char_width(charcode):
1153                 s = ord(cp1252.decoding_table[charcode])
1154                 width = font.load_char(
1155                     s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance
1156                 return cvt(width)
1157 
1158             with warnings.catch_warnings():
1159                 # Ignore 'Required glyph missing from current font' warning
1160                 # from ft2font: here we're just building the widths table, but
1161                 # the missing glyphs may not even be used in the actual string.
1162                 warnings.filterwarnings("ignore")
1163                 widths = [get_char_width(charcode)
1164                           for charcode in range(firstchar, lastchar+1)]
1165             descriptor['MaxWidth'] = max(widths)
1166 
1167             # Make the "Differences" array, sort the ccodes < 255 from
1168             # the multi-byte ccodes, and build the whole set of glyph ids
1169             # that we need from this font.
1170             glyph_ids = []
1171             differences = []
1172             multi_byte_chars = set()
1173             for c in characters:
1174                 ccode = c
1175                 gind = font.get_char_index(ccode)
1176                 glyph_ids.append(gind)
1177                 glyph_name = font.get_glyph_name(gind)
1178                 if ccode <= 255:
1179                     differences.append((ccode, glyph_name))
1180                 else:
1181                     multi_byte_chars.add(glyph_name)
1182             differences.sort()
1183 
1184             last_c = -2
1185             for c, name in differences:
1186                 if c != last_c + 1:
1187                     differencesArray.append(c)
1188                 differencesArray.append(Name(name))
1189                 last_c = c
1190 
1191             # Make the charprocs array.
1192             rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)
1193             charprocs = {}
1194             for charname in sorted(rawcharprocs):
1195                 stream = rawcharprocs[charname]
1196                 charprocDict = {}
1197                 # The 2-byte characters are used as XObjects, so they
1198                 # need extra info in their dictionary
1199                 if charname in multi_byte_chars:
1200                     charprocDict = {'Type': Name('XObject'),
1201                                     'Subtype': Name('Form'),
1202                                     'BBox': bbox}
1203                     # Each glyph includes bounding box information,
1204                     # but xpdf and ghostscript can't handle it in a
1205                     # Form XObject (they segfault!!!), so we remove it
1206                     # from the stream here.  It's not needed anyway,
1207                     # since the Form XObject includes it in its BBox
1208                     # value.
1209                     stream = stream[stream.find(b"d1") + 2:]
1210                 charprocObject = self.reserveObject('charProc')
1211                 self.outputStream(charprocObject, stream, extra=charprocDict)
1212 
1213                 # Send the glyphs with ccode > 255 to the XObject dictionary,
1214                 # and the others to the font itself
1215                 if charname in multi_byte_chars:
1216                     name = self._get_xobject_glyph_name(filename, charname)
1217                     self.multi_byte_charprocs[name] = charprocObject
1218                 else:
1219                     charprocs[charname] = charprocObject
1220 
1221             # Write everything out
1222             self.writeObject(fontdictObject, fontdict)
1223             self.writeObject(fontdescObject, descriptor)
1224             self.writeObject(widthsObject, widths)
1225             self.writeObject(charprocsObject, charprocs)
1226 
1227             return fontdictObject
1228 
1229         def embedTTFType42(font, characters, descriptor):
1230             """The Type 42-specific part of embedding a Truetype font"""
1231             fontdescObject = self.reserveObject('font descriptor')
1232             cidFontDictObject = self.reserveObject('CID font dictionary')
1233             type0FontDictObject = self.reserveObject('Type 0 font dictionary')
1234             cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')
1235             fontfileObject = self.reserveObject('font file stream')
1236             wObject = self.reserveObject('Type 0 widths')
1237             toUnicodeMapObject = self.reserveObject('ToUnicode map')
1238 
1239             subset_str = "".join(chr(c) for c in characters)
1240             _log.debug("SUBSET %s characters: %s", filename, subset_str)
1241             fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)
1242             _log.debug(
1243                 "SUBSET %s %d -> %d", filename,
1244                 os.stat(filename).st_size, fontdata.getbuffer().nbytes
1245             )
1246 
1247             # We need this ref for XObjects
1248             full_font = font
1249 
1250             # reload the font object from the subset
1251             # (all the necessary data could probably be obtained directly
1252             # using fontLib.ttLib)
1253             font = FT2Font(fontdata)
1254 
1255             cidFontDict = {
1256                 'Type': Name('Font'),
1257                 'Subtype': Name('CIDFontType2'),
1258                 'BaseFont': ps_name,
1259                 'CIDSystemInfo': {
1260                     'Registry': 'Adobe',
1261                     'Ordering': 'Identity',
1262                     'Supplement': 0},
1263                 'FontDescriptor': fontdescObject,
1264                 'W': wObject,
1265                 'CIDToGIDMap': cidToGidMapObject
1266                 }
1267 
1268             type0FontDict = {
1269                 'Type': Name('Font'),
1270                 'Subtype': Name('Type0'),
1271                 'BaseFont': ps_name,
1272                 'Encoding': Name('Identity-H'),
1273                 'DescendantFonts': [cidFontDictObject],
1274                 'ToUnicode': toUnicodeMapObject
1275                 }
1276 
1277             # Make fontfile stream
1278             descriptor['FontFile2'] = fontfileObject
1279             self.outputStream(
1280                 fontfileObject, fontdata.getvalue(),
1281                 extra={'Length1': fontdata.getbuffer().nbytes})
1282 
1283             # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap
1284             # at the same time
1285             cid_to_gid_map = ['\0'] * 65536
1286             widths = []
1287             max_ccode = 0
1288             for c in characters:
1289                 ccode = c
1290                 gind = font.get_char_index(ccode)
1291                 glyph = font.load_char(ccode,
1292                                        flags=LOAD_NO_SCALE | LOAD_NO_HINTING)
1293                 widths.append((ccode, cvt(glyph.horiAdvance)))
1294                 if ccode < 65536:
1295                     cid_to_gid_map[ccode] = chr(gind)
1296                 max_ccode = max(ccode, max_ccode)
1297             widths.sort()
1298             cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]
1299 
1300             last_ccode = -2
1301             w = []
1302             max_width = 0
1303             unicode_groups = []
1304             for ccode, width in widths:
1305                 if ccode != last_ccode + 1:
1306                     w.append(ccode)
1307                     w.append([width])
1308                     unicode_groups.append([ccode, ccode])
1309                 else:
1310                     w[-1].append(width)
1311                     unicode_groups[-1][1] = ccode
1312                 max_width = max(max_width, width)
1313                 last_ccode = ccode
1314 
1315             unicode_bfrange = []
1316             for start, end in unicode_groups:
1317                 # Ensure the CID map contains only chars from BMP
1318                 if start > 65535:
1319                     continue
1320                 end = min(65535, end)
1321 
1322                 unicode_bfrange.append(
1323                     b"<%04x> <%04x> [%s]" %
1324                     (start, end,
1325                      b" ".join(b"<%04x>" % x for x in range(start, end+1))))
1326             unicode_cmap = (self._identityToUnicodeCMap %
1327                             (len(unicode_groups), b"\n".join(unicode_bfrange)))
1328 
1329             # Add XObjects for unsupported chars
1330             glyph_ids = []
1331             for ccode in characters:
1332                 if not _font_supports_glyph(fonttype, ccode):
1333                     gind = full_font.get_char_index(ccode)
1334                     glyph_ids.append(gind)
1335 
1336             bbox = [cvt(x, nearest=False) for x in full_font.bbox]
1337             rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)
1338             for charname in sorted(rawcharprocs):
1339                 stream = rawcharprocs[charname]
1340                 charprocDict = {'Type': Name('XObject'),
1341                                 'Subtype': Name('Form'),
1342                                 'BBox': bbox}
1343                 # Each glyph includes bounding box information,
1344                 # but xpdf and ghostscript can't handle it in a
1345                 # Form XObject (they segfault!!!), so we remove it
1346                 # from the stream here.  It's not needed anyway,
1347                 # since the Form XObject includes it in its BBox
1348                 # value.
1349                 stream = stream[stream.find(b"d1") + 2:]
1350                 charprocObject = self.reserveObject('charProc')
1351                 self.outputStream(charprocObject, stream, extra=charprocDict)
1352 
1353                 name = self._get_xobject_glyph_name(filename, charname)
1354                 self.multi_byte_charprocs[name] = charprocObject
1355 
1356             # CIDToGIDMap stream
1357             cid_to_gid_map = "".join(cid_to_gid_map).encode("utf-16be")
1358             self.outputStream(cidToGidMapObject, cid_to_gid_map)
1359 
1360             # ToUnicode CMap
1361             self.outputStream(toUnicodeMapObject, unicode_cmap)
1362 
1363             descriptor['MaxWidth'] = max_width
1364 
1365             # Write everything out
1366             self.writeObject(cidFontDictObject, cidFontDict)
1367             self.writeObject(type0FontDictObject, type0FontDict)
1368             self.writeObject(fontdescObject, descriptor)
1369             self.writeObject(wObject, w)
1370 
1371             return type0FontDictObject
1372 
1373         # Beginning of main embedTTF function...
1374 
1375         ps_name = self._get_subsetted_psname(
1376             font.postscript_name,
1377             font.get_charmap()
1378         )
1379         ps_name = ps_name.encode('ascii', 'replace')
1380         ps_name = Name(ps_name)
1381         pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}
1382         post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}
1383         ff = font.face_flags
1384         sf = font.style_flags
1385 
1386         flags = 0
1387         symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')
1388         if ff & FIXED_WIDTH:
1389             flags |= 1 << 0
1390         if 0:  # TODO: serif
1391             flags |= 1 << 1
1392         if symbolic:
1393             flags |= 1 << 2
1394         else:
1395             flags |= 1 << 5
1396         if sf & ITALIC:
1397             flags |= 1 << 6
1398         if 0:  # TODO: all caps
1399             flags |= 1 << 16
1400         if 0:  # TODO: small caps
1401             flags |= 1 << 17
1402         if 0:  # TODO: force bold
1403             flags |= 1 << 18
1404 
1405         descriptor = {
1406             'Type': Name('FontDescriptor'),
1407             'FontName': ps_name,
1408             'Flags': flags,
1409             'FontBBox': [cvt(x, nearest=False) for x in font.bbox],
1410             'Ascent': cvt(font.ascender, nearest=False),
1411             'Descent': cvt(font.descender, nearest=False),
1412             'CapHeight': cvt(pclt['capHeight'], nearest=False),
1413             'XHeight': cvt(pclt['xHeight']),
1414             'ItalicAngle': post['italicAngle'][1],  # ???
1415             'StemV': 0  # ???
1416             }
1417 
1418         if fonttype == 3:
1419             return embedTTFType3(font, characters, descriptor)
1420         elif fonttype == 42:
1421             return embedTTFType42(font, characters, descriptor)
1422 
1423     def alphaState(self, alpha):
1424         """Return name of an ExtGState that sets alpha to the given value."""
1425 
1426         state = self.alphaStates.get(alpha, None)
1427         if state is not None:
1428             return state[0]
1429 
1430         name = next(self._alpha_state_seq)
1431         self.alphaStates[alpha] = \
1432             (name, {'Type': Name('ExtGState'),
1433                     'CA': alpha[0], 'ca': alpha[1]})
1434         return name
1435 
1436     def _soft_mask_state(self, smask):
1437         """
1438         Return an ExtGState that sets the soft mask to the given shading.
1439 
1440         Parameters
1441         ----------
1442         smask : Reference
1443             Reference to a shading in DeviceGray color space, whose luminosity
1444             is to be used as the alpha channel.
1445 
1446         Returns
1447         -------
1448         Name
1449         """
1450 
1451         state = self._soft_mask_states.get(smask, None)
1452         if state is not None:
1453             return state[0]
1454 
1455         name = next(self._soft_mask_seq)
1456         groupOb = self.reserveObject('transparency group for soft mask')
1457         self._soft_mask_states[smask] = (
1458             name,
1459             {
1460                 'Type': Name('ExtGState'),
1461                 'AIS': False,
1462                 'SMask': {
1463                     'Type': Name('Mask'),
1464                     'S': Name('Luminosity'),
1465                     'BC': [1],
1466                     'G': groupOb
1467                 }
1468             }
1469         )
1470         self._soft_mask_groups.append((
1471             groupOb,
1472             {
1473                 'Type': Name('XObject'),
1474                 'Subtype': Name('Form'),
1475                 'FormType': 1,
1476                 'Group': {
1477                     'S': Name('Transparency'),
1478                     'CS': Name('DeviceGray')
1479                 },
1480                 'Matrix': [1, 0, 0, 1, 0, 0],
1481                 'Resources': {'Shading': {'S': smask}},
1482                 'BBox': [0, 0, 1, 1]
1483             },
1484             [Name('S'), Op.shading]
1485         ))
1486         return name
1487 
1488     def writeExtGSTates(self):
1489         self.writeObject(
1490             self._extGStateObject,
1491             dict([
1492                 *self.alphaStates.values(),
1493                 *self._soft_mask_states.values()
1494             ])
1495         )
1496 
1497     def _write_soft_mask_groups(self):
1498         for ob, attributes, content in self._soft_mask_groups:
1499             self.beginStream(ob.id, None, attributes)
1500             self.output(*content)
1501             self.endStream()
1502 
1503     def hatchPattern(self, hatch_style):
1504         # The colors may come in as numpy arrays, which aren't hashable
1505         if hatch_style is not None:
1506             edge, face, hatch = hatch_style
1507             if edge is not None:
1508                 edge = tuple(edge)
1509             if face is not None:
1510                 face = tuple(face)
1511             hatch_style = (edge, face, hatch)
1512 
1513         pattern = self.hatchPatterns.get(hatch_style, None)
1514         if pattern is not None:
1515             return pattern
1516 
1517         name = next(self._hatch_pattern_seq)
1518         self.hatchPatterns[hatch_style] = name
1519         return name
1520 
1521     def writeHatches(self):
1522         hatchDict = dict()
1523         sidelen = 72.0
1524         for hatch_style, name in self.hatchPatterns.items():
1525             ob = self.reserveObject('hatch pattern')
1526             hatchDict[name] = ob
1527             res = {'Procsets':
1528                    [Name(x) for x in "PDF Text ImageB ImageC ImageI".split()]}
1529             self.beginStream(
1530                 ob.id, None,
1531                 {'Type': Name('Pattern'),
1532                  'PatternType': 1, 'PaintType': 1, 'TilingType': 1,
1533                  'BBox': [0, 0, sidelen, sidelen],
1534                  'XStep': sidelen, 'YStep': sidelen,
1535                  'Resources': res,
1536                  # Change origin to match Agg at top-left.
1537                  'Matrix': [1, 0, 0, 1, 0, self.height * 72]})
1538 
1539             stroke_rgb, fill_rgb, hatch = hatch_style
1540             self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],
1541                         Op.setrgb_stroke)
1542             if fill_rgb is not None:
1543                 self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],
1544                             Op.setrgb_nonstroke,
1545                             0, 0, sidelen, sidelen, Op.rectangle,
1546                             Op.fill)
1547 
1548             self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)
1549 
1550             self.output(*self.pathOperations(
1551                 Path.hatch(hatch),
1552                 Affine2D().scale(sidelen),
1553                 simplify=False))
1554             self.output(Op.fill_stroke)
1555 
1556             self.endStream()
1557         self.writeObject(self.hatchObject, hatchDict)
1558 
1559     def addGouraudTriangles(self, points, colors):
1560         """
1561         Add a Gouraud triangle shading.
1562 
1563         Parameters
1564         ----------
1565         points : np.ndarray
1566             Triangle vertices, shape (n, 3, 2)
1567             where n = number of triangles, 3 = vertices, 2 = x, y.
1568         colors : np.ndarray
1569             Vertex colors, shape (n, 3, 1) or (n, 3, 4)
1570             as with points, but last dimension is either (gray,)
1571             or (r, g, b, alpha).
1572 
1573         Returns
1574         -------
1575         Name, Reference
1576         """
1577         name = Name('GT%d' % len(self.gouraudTriangles))
1578         ob = self.reserveObject(f'Gouraud triangle {name}')
1579         self.gouraudTriangles.append((name, ob, points, colors))
1580         return name, ob
1581 
1582     def writeGouraudTriangles(self):
1583         gouraudDict = dict()
1584         for name, ob, points, colors in self.gouraudTriangles:
1585             gouraudDict[name] = ob
1586             shape = points.shape
1587             flat_points = points.reshape((shape[0] * shape[1], 2))
1588             colordim = colors.shape[2]
1589             assert colordim in (1, 4)
1590             flat_colors = colors.reshape((shape[0] * shape[1], colordim))
1591             if colordim == 4:
1592                 # strip the alpha channel
1593                 colordim = 3
1594             points_min = np.min(flat_points, axis=0) - (1 << 8)
1595             points_max = np.max(flat_points, axis=0) + (1 << 8)
1596             factor = 0xffffffff / (points_max - points_min)
1597 
1598             self.beginStream(
1599                 ob.id, None,
1600                 {'ShadingType': 4,
1601                  'BitsPerCoordinate': 32,
1602                  'BitsPerComponent': 8,
1603                  'BitsPerFlag': 8,
1604                  'ColorSpace': Name(
1605                      'DeviceRGB' if colordim == 3 else 'DeviceGray'
1606                  ),
1607                  'AntiAlias': False,
1608                  'Decode': ([points_min[0], points_max[0],
1609                              points_min[1], points_max[1]]
1610                             + [0, 1] * colordim),
1611                  })
1612 
1613             streamarr = np.empty(
1614                 (shape[0] * shape[1],),
1615                 dtype=[('flags', 'u1'),
1616                        ('points', '>u4', (2,)),
1617                        ('colors', 'u1', (colordim,))])
1618             streamarr['flags'] = 0
1619             streamarr['points'] = (flat_points - points_min) * factor
1620             streamarr['colors'] = flat_colors[:, :colordim] * 255.0
1621 
1622             self.write(streamarr.tobytes())
1623             self.endStream()
1624         self.writeObject(self.gouraudObject, gouraudDict)
1625 
1626     def imageObject(self, image):
1627         """Return name of an image XObject representing the given image."""
1628 
1629         entry = self._images.get(id(image), None)
1630         if entry is not None:
1631             return entry[1]
1632 
1633         name = next(self._image_seq)
1634         ob = self.reserveObject(f'image {name}')
1635         self._images[id(image)] = (image, name, ob)
1636         return name
1637 
1638     def _unpack(self, im):
1639         """
1640         Unpack image array *im* into ``(data, alpha)``, which have shape
1641         ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or
1642         alpha), except that alpha is None if the image is fully opaque.
1643         """
1644         im = im[::-1]
1645         if im.ndim == 2:
1646             return im, None
1647         else:
1648             rgb = im[:, :, :3]
1649             rgb = np.array(rgb, order='C')
1650             # PDF needs a separate alpha image
1651             if im.shape[2] == 4:
1652                 alpha = im[:, :, 3][..., None]
1653                 if np.all(alpha == 255):
1654                     alpha = None
1655                 else:
1656                     alpha = np.array(alpha, order='C')
1657             else:
1658                 alpha = None
1659             return rgb, alpha
1660 
1661     def _writePng(self, img):
1662         """
1663         Write the image *img* into the pdf file using png
1664         predictors with Flate compression.
1665         """
1666         buffer = BytesIO()
1667         img.save(buffer, format="png")
1668         buffer.seek(8)
1669         png_data = b''
1670         bit_depth = palette = None
1671         while True:
1672             length, type = struct.unpack(b'!L4s', buffer.read(8))
1673             if type in [b'IHDR', b'PLTE', b'IDAT']:
1674                 data = buffer.read(length)
1675                 if len(data) != length:
1676                     raise RuntimeError("truncated data")
1677                 if type == b'IHDR':
1678                     bit_depth = int(data[8])
1679                 elif type == b'PLTE':
1680                     palette = data
1681                 elif type == b'IDAT':
1682                     png_data += data
1683             elif type == b'IEND':
1684                 break
1685             else:
1686                 buffer.seek(length, 1)
1687             buffer.seek(4, 1)   # skip CRC
1688         return png_data, bit_depth, palette
1689 
1690     def _writeImg(self, data, id, smask=None):
1691         """
1692         Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or
1693         ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask
1694         (alpha channel) *smask*, which should be either None or a ``(height,
1695         width, 1)`` array.
1696         """
1697         height, width, color_channels = data.shape
1698         obj = {'Type': Name('XObject'),
1699                'Subtype': Name('Image'),
1700                'Width': width,
1701                'Height': height,
1702                'ColorSpace': Name({1: 'DeviceGray',
1703                                    3: 'DeviceRGB'}[color_channels]),
1704                'BitsPerComponent': 8}
1705         if smask:
1706             obj['SMask'] = smask
1707         if mpl.rcParams['pdf.compression']:
1708             if data.shape[-1] == 1:
1709                 data = data.squeeze(axis=-1)
1710             img = Image.fromarray(data)
1711             img_colors = img.getcolors(maxcolors=256)
1712             if color_channels == 3 and img_colors is not None:
1713                 # Convert to indexed color if there are 256 colors or fewer
1714                 # This can significantly reduce the file size
1715                 num_colors = len(img_colors)
1716                 # These constants were converted to IntEnums and deprecated in
1717                 # Pillow 9.2
1718                 dither = getattr(Image, 'Dither', Image).NONE
1719                 pmode = getattr(Image, 'Palette', Image).ADAPTIVE
1720                 img = img.convert(
1721                     mode='P', dither=dither, palette=pmode, colors=num_colors
1722                 )
1723                 png_data, bit_depth, palette = self._writePng(img)
1724                 if bit_depth is None or palette is None:
1725                     raise RuntimeError("invalid PNG header")
1726                 palette = palette[:num_colors * 3]  # Trim padding
1727                 obj['ColorSpace'] = Verbatim(
1728                     b'[/Indexed /DeviceRGB %d %s]'
1729                     % (num_colors - 1, pdfRepr(palette)))
1730                 obj['BitsPerComponent'] = bit_depth
1731                 color_channels = 1
1732             else:
1733                 png_data, _, _ = self._writePng(img)
1734             png = {'Predictor': 10, 'Colors': color_channels, 'Columns': width}
1735         else:
1736             png = None
1737         self.beginStream(
1738             id,
1739             self.reserveObject('length of image stream'),
1740             obj,
1741             png=png
1742             )
1743         if png:
1744             self.currentstream.write(png_data)
1745         else:
1746             self.currentstream.write(data.tobytes())
1747         self.endStream()
1748 
1749     def writeImages(self):
1750         for img, name, ob in self._images.values():
1751             data, adata = self._unpack(img)
1752             if adata is not None:
1753                 smaskObject = self.reserveObject("smask")
1754                 self._writeImg(adata, smaskObject.id)
1755             else:
1756                 smaskObject = None
1757             self._writeImg(data, ob.id, smaskObject)
1758 
1759     def markerObject(self, path, trans, fill, stroke, lw, joinstyle,
1760                      capstyle):
1761         """Return name of a marker XObject representing the given path."""
1762         # self.markers used by markerObject, writeMarkers, close:
1763         # mapping from (path operations, fill?, stroke?) to
1764         #   [name, object reference, bounding box, linewidth]
1765         # This enables different draw_markers calls to share the XObject
1766         # if the gc is sufficiently similar: colors etc can vary, but
1767         # the choices of whether to fill and whether to stroke cannot.
1768         # We need a bounding box enclosing all of the XObject path,
1769         # but since line width may vary, we store the maximum of all
1770         # occurring line widths in self.markers.
1771         # close() is somewhat tightly coupled in that it expects the
1772         # first two components of each value in self.markers to be the
1773         # name and object reference.
1774         pathops = self.pathOperations(path, trans, simplify=False)
1775         key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)
1776         result = self.markers.get(key)
1777         if result is None:
1778             name = Name('M%d' % len(self.markers))
1779             ob = self.reserveObject('marker %d' % len(self.markers))
1780             bbox = path.get_extents(trans)
1781             self.markers[key] = [name, ob, bbox, lw]
1782         else:
1783             if result[-1] < lw:
1784                 result[-1] = lw
1785             name = result[0]
1786         return name
1787 
1788     def writeMarkers(self):
1789         for ((pathops, fill, stroke, joinstyle, capstyle),
1790              (name, ob, bbox, lw)) in self.markers.items():
1791             # bbox wraps the exact limits of the control points, so half a line
1792             # will appear outside it. If the join style is miter and the line
1793             # is not parallel to the edge, then the line will extend even
1794             # further. From the PDF specification, Section 8.4.3.5, the miter
1795             # limit is miterLength / lineWidth and from Table 52, the default
1796             # is 10. With half the miter length outside, that works out to the
1797             # following padding:
1798             bbox = bbox.padded(lw * 5)
1799             self.beginStream(
1800                 ob.id, None,
1801                 {'Type': Name('XObject'), 'Subtype': Name('Form'),
1802                  'BBox': list(bbox.extents)})
1803             self.output(GraphicsContextPdf.joinstyles[joinstyle],
1804                         Op.setlinejoin)
1805             self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)
1806             self.output(*pathops)
1807             self.output(Op.paint_path(fill, stroke))
1808             self.endStream()
1809 
1810     def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):
1811         name = Name('P%d' % len(self.paths))
1812         ob = self.reserveObject('path %d' % len(self.paths))
1813         self.paths.append(
1814             (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),
1815              padding, filled, stroked))
1816         return name
1817 
1818     def writePathCollectionTemplates(self):
1819         for (name, path, trans, ob, joinstyle, capstyle, padding, filled,
1820              stroked) in self.paths:
1821             pathops = self.pathOperations(path, trans, simplify=False)
1822             bbox = path.get_extents(trans)
1823             if not np.all(np.isfinite(bbox.extents)):
1824                 extents = [0, 0, 0, 0]
1825             else:
1826                 bbox = bbox.padded(padding)
1827                 extents = list(bbox.extents)
1828             self.beginStream(
1829                 ob.id, None,
1830                 {'Type': Name('XObject'), 'Subtype': Name('Form'),
1831                  'BBox': extents})
1832             self.output(GraphicsContextPdf.joinstyles[joinstyle],
1833                         Op.setlinejoin)
1834             self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)
1835             self.output(*pathops)
1836             self.output(Op.paint_path(filled, stroked))
1837             self.endStream()
1838 
1839     @staticmethod
1840     def pathOperations(path, transform, clip=None, simplify=None, sketch=None):
1841         return [Verbatim(_path.convert_to_string(
1842             path, transform, clip, simplify, sketch,
1843             6,
1844             [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,
1845              Op.closepath.value],
1846             True))]
1847 
1848     def writePath(self, path, transform, clip=False, sketch=None):
1849         if clip:
1850             clip = (0.0, 0.0, self.width * 72, self.height * 72)
1851             simplify = path.should_simplify
1852         else:
1853             clip = None
1854             simplify = False
1855         cmds = self.pathOperations(path, transform, clip, simplify=simplify,
1856                                    sketch=sketch)
1857         self.output(*cmds)
1858 
1859     def reserveObject(self, name=''):
1860         """
1861         Reserve an ID for an indirect object.
1862 
1863         The name is used for debugging in case we forget to print out
1864         the object with writeObject.
1865         """
1866         id = next(self._object_seq)
1867         self.xrefTable.append([None, 0, name])
1868         return Reference(id)
1869 
1870     def recordXref(self, id):
1871         self.xrefTable[id][0] = self.fh.tell() - self.tell_base
1872 
1873     def writeObject(self, object, contents):
1874         self.recordXref(object.id)
1875         object.write(contents, self)
1876 
1877     def writeXref(self):
1878         """Write out the xref table."""
1879         self.startxref = self.fh.tell() - self.tell_base
1880         self.write(b"xref\n0 %d\n" % len(self.xrefTable))
1881         for i, (offset, generation, name) in enumerate(self.xrefTable):
1882             if offset is None:
1883                 raise AssertionError(
1884                     'No offset for object %d (%s)' % (i, name))
1885             else:
1886                 key = b"f" if name == 'the zero object' else b"n"
1887                 text = b"%010d %05d %b \n" % (offset, generation, key)
1888                 self.write(text)
1889 
1890     def writeInfoDict(self):
1891         """Write out the info dictionary, checking it for good form"""
1892 
1893         self.infoObject = self.reserveObject('info')
1894         self.writeObject(self.infoObject, self.infoDict)
1895 
1896     def writeTrailer(self):
1897         """Write out the PDF trailer."""
1898 
1899         self.write(b"trailer\n")
1900         self.write(pdfRepr(
1901             {'Size': len(self.xrefTable),
1902              'Root': self.rootObject,
1903              'Info': self.infoObject}))
1904         # Could add 'ID'
1905         self.write(b"\nstartxref\n%d\n%%%%EOF\n" % self.startxref)
1906 
1907 
1908 class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):
1909 
1910     _afm_font_dir = cbook._get_data_path("fonts/pdfcorefonts")
1911     _use_afm_rc_name = "pdf.use14corefonts"
1912 
1913     def __init__(self, file, image_dpi, height, width):
1914         super().__init__(width, height)
1915         self.file = file
1916         self.gc = self.new_gc()
1917         self.image_dpi = image_dpi
1918 
1919     def finalize(self):
1920         self.file.output(*self.gc.finalize())
1921 
1922     def check_gc(self, gc, fillcolor=None):
1923         orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))
1924         gc._fillcolor = fillcolor
1925 
1926         orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))
1927 
1928         if gc.get_rgb() is None:
1929             # It should not matter what color here since linewidth should be
1930             # 0 unless affected by global settings in rcParams, hence setting
1931             # zero alpha just in case.
1932             gc.set_foreground((0, 0, 0, 0), isRGBA=True)
1933 
1934         if gc._forced_alpha:
1935             gc._effective_alphas = (gc._alpha, gc._alpha)
1936         elif fillcolor is None or len(fillcolor) < 4:
1937             gc._effective_alphas = (gc._rgb[3], 1.0)
1938         else:
1939             gc._effective_alphas = (gc._rgb[3], fillcolor[3])
1940 
1941         delta = self.gc.delta(gc)
1942         if delta:
1943             self.file.output(*delta)
1944 
1945         # Restore gc to avoid unwanted side effects
1946         gc._fillcolor = orig_fill
1947         gc._effective_alphas = orig_alphas
1948 
1949     def get_image_magnification(self):
1950         return self.image_dpi/72.0
1951 
1952     def draw_image(self, gc, x, y, im, transform=None):
1953         # docstring inherited
1954 
1955         h, w = im.shape[:2]
1956         if w == 0 or h == 0:
1957             return
1958 
1959         if transform is None:
1960             # If there's no transform, alpha has already been applied
1961             gc.set_alpha(1.0)
1962 
1963         self.check_gc(gc)
1964 
1965         w = 72.0 * w / self.image_dpi
1966         h = 72.0 * h / self.image_dpi
1967 
1968         imob = self.file.imageObject(im)
1969 
1970         if transform is None:
1971             self.file.output(Op.gsave,
1972                              w, 0, 0, h, x, y, Op.concat_matrix,
1973                              imob, Op.use_xobject, Op.grestore)
1974         else:
1975             tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()
1976 
1977             self.file.output(Op.gsave,
1978                              1, 0, 0, 1, x, y, Op.concat_matrix,
1979                              tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,
1980                              imob, Op.use_xobject, Op.grestore)
1981 
1982     def draw_path(self, gc, path, transform, rgbFace=None):
1983         # docstring inherited
1984         self.check_gc(gc, rgbFace)
1985         self.file.writePath(
1986             path, transform,
1987             rgbFace is None and gc.get_hatch_path() is None,
1988             gc.get_sketch_params())
1989         self.file.output(self.gc.paint())
1990 
1991     def draw_path_collection(self, gc, master_transform, paths, all_transforms,
1992                              offsets, offsetTrans, facecolors, edgecolors,
1993                              linewidths, linestyles, antialiaseds, urls,
1994                              offset_position):
1995         # We can only reuse the objects if the presence of fill and
1996         # stroke (and the amount of alpha for each) is the same for
1997         # all of them
1998         can_do_optimization = True
1999         facecolors = np.asarray(facecolors)
2000         edgecolors = np.asarray(edgecolors)
2001 
2002         if not len(facecolors):
2003             filled = False
2004             can_do_optimization = not gc.get_hatch()
2005         else:
2006             if np.all(facecolors[:, 3] == facecolors[0, 3]):
2007                 filled = facecolors[0, 3] != 0.0
2008             else:
2009                 can_do_optimization = False
2010 
2011         if not len(edgecolors):
2012             stroked = False
2013         else:
2014             if np.all(np.asarray(linewidths) == 0.0):
2015                 stroked = False
2016             elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):
2017                 stroked = edgecolors[0, 3] != 0.0
2018             else:
2019                 can_do_optimization = False
2020 
2021         # Is the optimization worth it? Rough calculation:
2022         # cost of emitting a path in-line is len_path * uses_per_path
2023         # cost of XObject is len_path + 5 for the definition,
2024         #    uses_per_path for the uses
2025         len_path = len(paths[0].vertices) if len(paths) > 0 else 0
2026         uses_per_path = self._iter_collection_uses_per_path(
2027             paths, all_transforms, offsets, facecolors, edgecolors)
2028         should_do_optimization = \
2029             len_path + uses_per_path + 5 < len_path * uses_per_path
2030 
2031         if (not can_do_optimization) or (not should_do_optimization):
2032             return RendererBase.draw_path_collection(
2033                 self, gc, master_transform, paths, all_transforms,
2034                 offsets, offsetTrans, facecolors, edgecolors,
2035                 linewidths, linestyles, antialiaseds, urls,
2036                 offset_position)
2037 
2038         padding = np.max(linewidths)
2039         path_codes = []
2040         for i, (path, transform) in enumerate(self._iter_collection_raw_paths(
2041                 master_transform, paths, all_transforms)):
2042             name = self.file.pathCollectionObject(
2043                 gc, path, transform, padding, filled, stroked)
2044             path_codes.append(name)
2045 
2046         output = self.file.output
2047         output(*self.gc.push())
2048         lastx, lasty = 0, 0
2049         for xo, yo, path_id, gc0, rgbFace in self._iter_collection(
2050                 gc, master_transform, all_transforms, path_codes, offsets,
2051                 offsetTrans, facecolors, edgecolors, linewidths, linestyles,
2052                 antialiaseds, urls, offset_position):
2053 
2054             self.check_gc(gc0, rgbFace)
2055             dx, dy = xo - lastx, yo - lasty
2056             output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,
2057                    Op.use_xobject)
2058             lastx, lasty = xo, yo
2059         output(*self.gc.pop())
2060 
2061     def draw_markers(self, gc, marker_path, marker_trans, path, trans,
2062                      rgbFace=None):
2063         # docstring inherited
2064 
2065         # Same logic as in draw_path_collection
2066         len_marker_path = len(marker_path)
2067         uses = len(path)
2068         if len_marker_path * uses < len_marker_path + uses + 5:
2069             RendererBase.draw_markers(self, gc, marker_path, marker_trans,
2070                                       path, trans, rgbFace)
2071             return
2072 
2073         self.check_gc(gc, rgbFace)
2074         fill = gc.fill(rgbFace)
2075         stroke = gc.stroke()
2076 
2077         output = self.file.output
2078         marker = self.file.markerObject(
2079             marker_path, marker_trans, fill, stroke, self.gc._linewidth,
2080             gc.get_joinstyle(), gc.get_capstyle())
2081 
2082         output(Op.gsave)
2083         lastx, lasty = 0, 0
2084         for vertices, code in path.iter_segments(
2085                 trans,
2086                 clip=(0, 0, self.file.width*72, self.file.height*72),
2087                 simplify=False):
2088             if len(vertices):
2089                 x, y = vertices[-2:]
2090                 if not (0 <= x <= self.file.width * 72
2091                         and 0 <= y <= self.file.height * 72):
2092                     continue
2093                 dx, dy = x - lastx, y - lasty
2094                 output(1, 0, 0, 1, dx, dy, Op.concat_matrix,
2095                        marker, Op.use_xobject)
2096                 lastx, lasty = x, y
2097         output(Op.grestore)
2098 
2099     def draw_gouraud_triangle(self, gc, points, colors, trans):
2100         self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),
2101                                     colors.reshape((1, 3, 4)), trans)
2102 
2103     def draw_gouraud_triangles(self, gc, points, colors, trans):
2104         assert len(points) == len(colors)
2105         if len(points) == 0:
2106             return
2107         assert points.ndim == 3
2108         assert points.shape[1] == 3
2109         assert points.shape[2] == 2
2110         assert colors.ndim == 3
2111         assert colors.shape[1] == 3
2112         assert colors.shape[2] in (1, 4)
2113 
2114         shape = points.shape
2115         points = points.reshape((shape[0] * shape[1], 2))
2116         tpoints = trans.transform(points)
2117         tpoints = tpoints.reshape(shape)
2118         name, _ = self.file.addGouraudTriangles(tpoints, colors)
2119         output = self.file.output
2120 
2121         if colors.shape[2] == 1:
2122             # grayscale
2123             gc.set_alpha(1.0)
2124             self.check_gc(gc)
2125             output(name, Op.shading)
2126             return
2127 
2128         alpha = colors[0, 0, 3]
2129         if np.allclose(alpha, colors[:, :, 3]):
2130             # single alpha value
2131             gc.set_alpha(alpha)
2132             self.check_gc(gc)
2133             output(name, Op.shading)
2134         else:
2135             # varying alpha: use a soft mask
2136             alpha = colors[:, :, 3][:, :, None]
2137             _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)
2138             gstate = self.file._soft_mask_state(smask_ob)
2139             output(Op.gsave, gstate, Op.setgstate,
2140                    name, Op.shading,
2141                    Op.grestore)
2142 
2143     def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):
2144         if angle == oldangle == 0:
2145             self.file.output(x - oldx, y - oldy, Op.textpos)
2146         else:
2147             angle = math.radians(angle)
2148             self.file.output(math.cos(angle), math.sin(angle),
2149                              -math.sin(angle), math.cos(angle),
2150                              x, y, Op.textmatrix)
2151             self.file.output(0, 0, Op.textpos)
2152 
2153     def draw_mathtext(self, gc, x, y, s, prop, angle):
2154         # TODO: fix positioning and encoding
2155         width, height, descent, glyphs, rects = \
2156             self._text2path.mathtext_parser.parse(s, 72, prop)
2157 
2158         if gc.get_url() is not None:
2159             link_annotation = {
2160                 'Type': Name('Annot'),
2161                 'Subtype': Name('Link'),
2162                 'Rect': (x, y, x + width, y + height),
2163                 'Border': [0, 0, 0],
2164                 'A': {
2165                     'S': Name('URI'),
2166                     'URI': gc.get_url(),
2167                 },
2168             }
2169             self.file._annotations[-1][1].append(link_annotation)
2170 
2171         fonttype = mpl.rcParams['pdf.fonttype']
2172 
2173         # Set up a global transformation matrix for the whole math expression
2174         a = math.radians(angle)
2175         self.file.output(Op.gsave)
2176         self.file.output(math.cos(a), math.sin(a),
2177                          -math.sin(a), math.cos(a),
2178                          x, y, Op.concat_matrix)
2179 
2180         self.check_gc(gc, gc._rgb)
2181         prev_font = None, None
2182         oldx, oldy = 0, 0
2183         unsupported_chars = []
2184 
2185         self.file.output(Op.begin_text)
2186         for font, fontsize, num, ox, oy in glyphs:
2187             self.file._character_tracker.track_glyph(font, num)
2188             fontname = font.fname
2189             if not _font_supports_glyph(fonttype, num):
2190                 # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in
2191                 # Type 42) must be emitted separately (below).
2192                 unsupported_chars.append((font, fontsize, ox, oy, num))
2193             else:
2194                 self._setup_textpos(ox, oy, 0, oldx, oldy)
2195                 oldx, oldy = ox, oy
2196                 if (fontname, fontsize) != prev_font:
2197                     self.file.output(self.file.fontName(fontname), fontsize,
2198                                      Op.selectfont)
2199                     prev_font = fontname, fontsize
2200                 self.file.output(self.encode_string(chr(num), fonttype),
2201                                  Op.show)
2202         self.file.output(Op.end_text)
2203 
2204         for font, fontsize, ox, oy, num in unsupported_chars:
2205             self._draw_xobject_glyph(
2206                 font, fontsize, font.get_char_index(num), ox, oy)
2207 
2208         # Draw any horizontal lines in the math layout
2209         for ox, oy, width, height in rects:
2210             self.file.output(Op.gsave, ox, oy, width, height,
2211                              Op.rectangle, Op.fill, Op.grestore)
2212 
2213         # Pop off the global transformation
2214         self.file.output(Op.grestore)
2215 
2216     def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):
2217         # docstring inherited
2218         texmanager = self.get_texmanager()
2219         fontsize = prop.get_size_in_points()
2220         dvifile = texmanager.make_dvi(s, fontsize)
2221         with dviread.Dvi(dvifile, 72) as dvi:
2222             page, = dvi
2223 
2224         if gc.get_url() is not None:
2225             link_annotation = {
2226                 'Type': Name('Annot'),
2227                 'Subtype': Name('Link'),
2228                 'Rect': (x, y, x + page.width, y + page.height),
2229                 'Border': [0, 0, 0],
2230                 'A': {
2231                     'S': Name('URI'),
2232                     'URI': gc.get_url(),
2233                 },
2234             }
2235             self.file._annotations[-1][1].append(link_annotation)
2236 
2237         # Gather font information and do some setup for combining
2238         # characters into strings. The variable seq will contain a
2239         # sequence of font and text entries. A font entry is a list
2240         # ['font', name, size] where name is a Name object for the
2241         # font. A text entry is ['text', x, y, glyphs, x+w] where x
2242         # and y are the starting coordinates, w is the width, and
2243         # glyphs is a list; in this phase it will always contain just
2244         # one one-character string, but later it may have longer
2245         # strings interspersed with kern amounts.
2246         oldfont, seq = None, []
2247         for x1, y1, dvifont, glyph, width in page.text:
2248             if dvifont != oldfont:
2249                 pdfname = self.file.dviFontName(dvifont)
2250                 seq += [['font', pdfname, dvifont.size]]
2251                 oldfont = dvifont
2252             seq += [['text', x1, y1, [bytes([glyph])], x1+width]]
2253 
2254         # Find consecutive text strings with constant y coordinate and
2255         # combine into a sequence of strings and kerns, or just one
2256         # string (if any kerns would be less than 0.1 points).
2257         i, curx, fontsize = 0, 0, None
2258         while i < len(seq)-1:
2259             elt, nxt = seq[i:i+2]
2260             if elt[0] == 'font':
2261                 fontsize = elt[2]
2262             elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:
2263                 offset = elt[4] - nxt[1]
2264                 if abs(offset) < 0.1:
2265                     elt[3][-1] += nxt[3][0]
2266                     elt[4] += nxt[4]-nxt[1]
2267                 else:
2268                     elt[3] += [offset*1000.0/fontsize, nxt[3][0]]
2269                     elt[4] = nxt[4]
2270                 del seq[i+1]
2271                 continue
2272             i += 1
2273 
2274         # Create a transform to map the dvi contents to the canvas.
2275         mytrans = Affine2D().rotate_deg(angle).translate(x, y)
2276 
2277         # Output the text.
2278         self.check_gc(gc, gc._rgb)
2279         self.file.output(Op.begin_text)
2280         curx, cury, oldx, oldy = 0, 0, 0, 0
2281         for elt in seq:
2282             if elt[0] == 'font':
2283                 self.file.output(elt[1], elt[2], Op.selectfont)
2284             elif elt[0] == 'text':
2285                 curx, cury = mytrans.transform((elt[1], elt[2]))
2286                 self._setup_textpos(curx, cury, angle, oldx, oldy)
2287                 oldx, oldy = curx, cury
2288                 if len(elt[3]) == 1:
2289                     self.file.output(elt[3][0], Op.show)
2290                 else:
2291                     self.file.output(elt[3], Op.showkern)
2292             else:
2293                 assert False
2294         self.file.output(Op.end_text)
2295 
2296         # Then output the boxes (e.g., variable-length lines of square
2297         # roots).
2298         boxgc = self.new_gc()
2299         boxgc.copy_properties(gc)
2300         boxgc.set_linewidth(0)
2301         pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,
2302                    Path.CLOSEPOLY]
2303         for x1, y1, h, w in page.boxes:
2304             path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],
2305                          [0, 0]], pathops)
2306             self.draw_path(boxgc, path, mytrans, gc._rgb)
2307 
2308     def encode_string(self, s, fonttype):
2309         if fonttype in (1, 3):
2310             return s.encode('cp1252', 'replace')
2311         return s.encode('utf-16be', 'replace')
2312 
2313     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):
2314         # docstring inherited
2315 
2316         # TODO: combine consecutive texts into one BT/ET delimited section
2317 
2318         self.check_gc(gc, gc._rgb)
2319         if ismath:
2320             return self.draw_mathtext(gc, x, y, s, prop, angle)
2321 
2322         fontsize = prop.get_size_in_points()
2323 
2324         if mpl.rcParams['pdf.use14corefonts']:
2325             font = self._get_font_afm(prop)
2326             fonttype = 1
2327         else:
2328             font = self._get_font_ttf(prop)
2329             self.file._character_tracker.track(font, s)
2330             fonttype = mpl.rcParams['pdf.fonttype']
2331 
2332         if gc.get_url() is not None:
2333             font.set_text(s)
2334             width, height = font.get_width_height()
2335             link_annotation = {
2336                 'Type': Name('Annot'),
2337                 'Subtype': Name('Link'),
2338                 'Rect': (x, y, x + width / 64, y + height / 64),
2339                 'Border': [0, 0, 0],
2340                 'A': {
2341                     'S': Name('URI'),
2342                     'URI': gc.get_url(),
2343                 },
2344             }
2345             self.file._annotations[-1][1].append(link_annotation)
2346 
2347         # If fonttype is neither 3 nor 42, emit the whole string at once
2348         # without manual kerning.
2349         if fonttype not in [3, 42]:
2350             self.file.output(Op.begin_text,
2351                              self.file.fontName(prop), fontsize, Op.selectfont)
2352             self._setup_textpos(x, y, angle)
2353             self.file.output(self.encode_string(s, fonttype),
2354                              Op.show, Op.end_text)
2355 
2356         # A sequence of characters is broken into multiple chunks. The chunking
2357         # serves two purposes:
2358         #   - For Type 3 fonts, there is no way to access multibyte characters,
2359         #     as they cannot have a CIDMap.  Therefore, in this case we break
2360         #     the string into chunks, where each chunk contains either a string
2361         #     of consecutive 1-byte characters or a single multibyte character.
2362         #   - A sequence of 1-byte characters is split into chunks to allow for
2363         #     kerning adjustments between consecutive chunks.
2364         #
2365         # Each chunk is emitted with a separate command: 1-byte characters use
2366         # the regular text show command (TJ) with appropriate kerning between
2367         # chunks, whereas multibyte characters use the XObject command (Do).
2368         else:
2369             # List of (start_x, [prev_kern, char, char, ...]), w/o zero kerns.
2370             singlebyte_chunks = []
2371             # List of (start_x, glyph_index).
2372             multibyte_glyphs = []
2373             prev_was_multibyte = True
2374             for item in _text_helpers.layout(
2375                     s, font, kern_mode=KERNING_UNFITTED):
2376                 if _font_supports_glyph(fonttype, ord(item.char)):
2377                     if prev_was_multibyte:
2378                         singlebyte_chunks.append((item.x, []))
2379                     if item.prev_kern:
2380                         singlebyte_chunks[-1][1].append(item.prev_kern)
2381                     singlebyte_chunks[-1][1].append(item.char)
2382                     prev_was_multibyte = False
2383                 else:
2384                     multibyte_glyphs.append((item.x, item.glyph_idx))
2385                     prev_was_multibyte = True
2386             # Do the rotation and global translation as a single matrix
2387             # concatenation up front
2388             self.file.output(Op.gsave)
2389             a = math.radians(angle)
2390             self.file.output(math.cos(a), math.sin(a),
2391                              -math.sin(a), math.cos(a),
2392                              x, y, Op.concat_matrix)
2393             # Emit all the 1-byte characters in a BT/ET group.
2394             self.file.output(Op.begin_text,
2395                              self.file.fontName(prop), fontsize, Op.selectfont)
2396             prev_start_x = 0
2397             for start_x, kerns_or_chars in singlebyte_chunks:
2398                 self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)
2399                 self.file.output(
2400                     # See pdf spec "Text space details" for the 1000/fontsize
2401                     # (aka. 1000/T_fs) factor.
2402                     [-1000 * next(group) / fontsize if tp == float  # a kern
2403                      else self.encode_string("".join(group), fonttype)
2404                      for tp, group in itertools.groupby(kerns_or_chars, type)],
2405                     Op.showkern)
2406                 prev_start_x = start_x
2407             self.file.output(Op.end_text)
2408             # Then emit all the multibyte characters, one at a time.
2409             for start_x, glyph_idx in multibyte_glyphs:
2410                 self._draw_xobject_glyph(font, fontsize, glyph_idx, start_x, 0)
2411             self.file.output(Op.grestore)
2412 
2413     def _draw_xobject_glyph(self, font, fontsize, glyph_idx, x, y):
2414         """Draw a multibyte character from a Type 3 font as an XObject."""
2415         glyph_name = font.get_glyph_name(glyph_idx)
2416         name = self.file._get_xobject_glyph_name(font.fname, glyph_name)
2417         self.file.output(
2418             Op.gsave,
2419             0.001 * fontsize, 0, 0, 0.001 * fontsize, x, y, Op.concat_matrix,
2420             Name(name), Op.use_xobject,
2421             Op.grestore,
2422         )
2423 
2424     def new_gc(self):
2425         # docstring inherited
2426         return GraphicsContextPdf(self.file)
2427 
2428 
2429 class GraphicsContextPdf(GraphicsContextBase):
2430 
2431     def __init__(self, file):
2432         super().__init__()
2433         self._fillcolor = (0.0, 0.0, 0.0)
2434         self._effective_alphas = (1.0, 1.0)
2435         self.file = file
2436         self.parent = None
2437 
2438     def __repr__(self):
2439         d = dict(self.__dict__)
2440         del d['file']
2441         del d['parent']
2442         return repr(d)
2443 
2444     def stroke(self):
2445         """
2446         Predicate: does the path need to be stroked (its outline drawn)?
2447         This tests for the various conditions that disable stroking
2448         the path, in which case it would presumably be filled.
2449         """
2450         # _linewidth > 0: in pdf a line of width 0 is drawn at minimum
2451         #   possible device width, but e.g., agg doesn't draw at all
2452         return (self._linewidth > 0 and self._alpha > 0 and
2453                 (len(self._rgb) <= 3 or self._rgb[3] != 0.0))
2454 
2455     def fill(self, *args):
2456         """
2457         Predicate: does the path need to be filled?
2458 
2459         An optional argument can be used to specify an alternative
2460         _fillcolor, as needed by RendererPdf.draw_markers.
2461         """
2462         if len(args):
2463             _fillcolor = args[0]
2464         else:
2465             _fillcolor = self._fillcolor
2466         return (self._hatch or
2467                 (_fillcolor is not None and
2468                  (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))
2469 
2470     def paint(self):
2471         """
2472         Return the appropriate pdf operator to cause the path to be
2473         stroked, filled, or both.
2474         """
2475         return Op.paint_path(self.fill(), self.stroke())
2476 
2477     capstyles = {'butt': 0, 'round': 1, 'projecting': 2}
2478     joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}
2479 
2480     def capstyle_cmd(self, style):
2481         return [self.capstyles[style], Op.setlinecap]
2482 
2483     def joinstyle_cmd(self, style):
2484         return [self.joinstyles[style], Op.setlinejoin]
2485 
2486     def linewidth_cmd(self, width):
2487         return [width, Op.setlinewidth]
2488 
2489     def dash_cmd(self, dashes):
2490         offset, dash = dashes
2491         if dash is None:
2492             dash = []
2493             offset = 0
2494         return [list(dash), offset, Op.setdash]
2495 
2496     def alpha_cmd(self, alpha, forced, effective_alphas):
2497         name = self.file.alphaState(effective_alphas)
2498         return [name, Op.setgstate]
2499 
2500     def hatch_cmd(self, hatch, hatch_color):
2501         if not hatch:
2502             if self._fillcolor is not None:
2503                 return self.fillcolor_cmd(self._fillcolor)
2504             else:
2505                 return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]
2506         else:
2507             hatch_style = (hatch_color, self._fillcolor, hatch)
2508             name = self.file.hatchPattern(hatch_style)
2509             return [Name('Pattern'), Op.setcolorspace_nonstroke,
2510                     name, Op.setcolor_nonstroke]
2511 
2512     def rgb_cmd(self, rgb):
2513         if mpl.rcParams['pdf.inheritcolor']:
2514             return []
2515         if rgb[0] == rgb[1] == rgb[2]:
2516             return [rgb[0], Op.setgray_stroke]
2517         else:
2518             return [*rgb[:3], Op.setrgb_stroke]
2519 
2520     def fillcolor_cmd(self, rgb):
2521         if rgb is None or mpl.rcParams['pdf.inheritcolor']:
2522             return []
2523         elif rgb[0] == rgb[1] == rgb[2]:
2524             return [rgb[0], Op.setgray_nonstroke]
2525         else:
2526             return [*rgb[:3], Op.setrgb_nonstroke]
2527 
2528     def push(self):
2529         parent = GraphicsContextPdf(self.file)
2530         parent.copy_properties(self)
2531         parent.parent = self.parent
2532         self.parent = parent
2533         return [Op.gsave]
2534 
2535     def pop(self):
2536         assert self.parent is not None
2537         self.copy_properties(self.parent)
2538         self.parent = self.parent.parent
2539         return [Op.grestore]
2540 
2541     def clip_cmd(self, cliprect, clippath):
2542         """Set clip rectangle. Calls `.pop()` and `.push()`."""
2543         cmds = []
2544         # Pop graphics state until we hit the right one or the stack is empty
2545         while ((self._cliprect, self._clippath) != (cliprect, clippath)
2546                 and self.parent is not None):
2547             cmds.extend(self.pop())
2548         # Unless we hit the right one, set the clip polygon
2549         if ((self._cliprect, self._clippath) != (cliprect, clippath) or
2550                 self.parent is None):
2551             cmds.extend(self.push())
2552             if self._cliprect != cliprect:
2553                 cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])
2554             if self._clippath != clippath:
2555                 path, affine = clippath.get_transformed_path_and_affine()
2556                 cmds.extend(
2557                     PdfFile.pathOperations(path, affine, simplify=False) +
2558                     [Op.clip, Op.endpath])
2559         return cmds
2560 
2561     commands = (
2562         # must come first since may pop
2563         (('_cliprect', '_clippath'), clip_cmd),
2564         (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),
2565         (('_capstyle',), capstyle_cmd),
2566         (('_fillcolor',), fillcolor_cmd),
2567         (('_joinstyle',), joinstyle_cmd),
2568         (('_linewidth',), linewidth_cmd),
2569         (('_dashes',), dash_cmd),
2570         (('_rgb',), rgb_cmd),
2571         # must come after fillcolor and rgb
2572         (('_hatch', '_hatch_color'), hatch_cmd),
2573         )
2574 
2575     def delta(self, other):
2576         """
2577         Copy properties of other into self and return PDF commands
2578         needed to transform self into other.
2579         """
2580         cmds = []
2581         fill_performed = False
2582         for params, cmd in self.commands:
2583             different = False
2584             for p in params:
2585                 ours = getattr(self, p)
2586                 theirs = getattr(other, p)
2587                 try:
2588                     if ours is None or theirs is None:
2589                         different = ours is not theirs
2590                     else:
2591                         different = bool(ours != theirs)
2592                 except ValueError:
2593                     ours = np.asarray(ours)
2594                     theirs = np.asarray(theirs)
2595                     different = (ours.shape != theirs.shape or
2596                                  np.any(ours != theirs))
2597                 if different:
2598                     break
2599 
2600             # Need to update hatching if we also updated fillcolor
2601             if params == ('_hatch', '_hatch_color') and fill_performed:
2602                 different = True
2603 
2604             if different:
2605                 if params == ('_fillcolor',):
2606                     fill_performed = True
2607                 theirs = [getattr(other, p) for p in params]
2608                 cmds.extend(cmd(self, *theirs))
2609                 for p in params:
2610                     setattr(self, p, getattr(other, p))
2611         return cmds
2612 
2613     def copy_properties(self, other):
2614         """
2615         Copy properties of other into self.
2616         """
2617         super().copy_properties(other)
2618         fillcolor = getattr(other, '_fillcolor', self._fillcolor)
2619         effective_alphas = getattr(other, '_effective_alphas',
2620                                    self._effective_alphas)
2621         self._fillcolor = fillcolor
2622         self._effective_alphas = effective_alphas
2623 
2624     def finalize(self):
2625         """
2626         Make sure every pushed graphics state is popped.
2627         """
2628         cmds = []
2629         while self.parent is not None:
2630             cmds.extend(self.pop())
2631         return cmds
2632 
2633 
2634 class PdfPages:
2635     """
2636     A multi-page PDF file.
2637 
2638     Examples
2639     --------
2640     >>> import matplotlib.pyplot as plt
2641     >>> # Initialize:
2642     >>> with PdfPages('foo.pdf') as pdf:
2643     ...     # As many times as you like, create a figure fig and save it:
2644     ...     fig = plt.figure()
2645     ...     pdf.savefig(fig)
2646     ...     # When no figure is specified the current figure is saved
2647     ...     pdf.savefig()
2648 
2649     Notes
2650     -----
2651     In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid
2652     confusion when using `~.pyplot.savefig` and forgetting the format argument.
2653     """
2654     __slots__ = ('_file', 'keep_empty')
2655 
2656     def __init__(self, filename, keep_empty=True, metadata=None):
2657         """
2658         Create a new PdfPages object.
2659 
2660         Parameters
2661         ----------
2662         filename : str or path-like or file-like
2663             Plots using `PdfPages.savefig` will be written to a file at this
2664             location. The file is opened at once and any older file with the
2665             same name is overwritten.
2666 
2667         keep_empty : bool, optional
2668             If set to False, then empty pdf files will be deleted automatically
2669             when closed.
2670 
2671         metadata : dict, optional
2672             Information dictionary object (see PDF reference section 10.2.1
2673             'Document Information Dictionary'), e.g.:
2674             ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.
2675 
2676             The standard keys are 'Title', 'Author', 'Subject', 'Keywords',
2677             'Creator', 'Producer', 'CreationDate', 'ModDate', and
2678             'Trapped'. Values have been predefined for 'Creator', 'Producer'
2679             and 'CreationDate'. They can be removed by setting them to `None`.
2680         """
2681         self._file = PdfFile(filename, metadata=metadata)
2682         self.keep_empty = keep_empty
2683 
2684     def __enter__(self):
2685         return self
2686 
2687     def __exit__(self, exc_type, exc_val, exc_tb):
2688         self.close()
2689 
2690     def close(self):
2691         """
2692         Finalize this object, making the underlying file a complete
2693         PDF file.
2694         """
2695         self._file.finalize()
2696         self._file.close()
2697         if (self.get_pagecount() == 0 and not self.keep_empty and
2698                 not self._file.passed_in_file_object):
2699             os.remove(self._file.fh.name)
2700         self._file = None
2701 
2702     def infodict(self):
2703         """
2704         Return a modifiable information dictionary object
2705         (see PDF reference section 10.2.1 'Document Information
2706         Dictionary').
2707         """
2708         return self._file.infoDict
2709 
2710     def savefig(self, figure=None, **kwargs):
2711         """
2712         Save a `.Figure` to this file as a new page.
2713 
2714         Any other keyword arguments are passed to `~.Figure.savefig`.
2715 
2716         Parameters
2717         ----------
2718         figure : `.Figure` or int, default: the active figure
2719             The figure, or index of the figure, that is saved to the file.
2720         """
2721         if not isinstance(figure, Figure):
2722             if figure is None:
2723                 manager = Gcf.get_active()
2724             else:
2725                 manager = Gcf.get_fig_manager(figure)
2726             if manager is None:
2727                 raise ValueError("No figure {}".format(figure))
2728             figure = manager.canvas.figure
2729         # Force use of pdf backend, as PdfPages is tightly coupled with it.
2730         try:
2731             orig_canvas = figure.canvas
2732             figure.canvas = FigureCanvasPdf(figure)
2733             figure.savefig(self, format="pdf", **kwargs)
2734         finally:
2735             figure.canvas = orig_canvas
2736 
2737     def get_pagecount(self):
2738         """Return the current number of pages in the multipage pdf file."""
2739         return len(self._file.pageList)
2740 
2741     def attach_note(self, text, positionRect=[-100, -100, 0, 0]):
2742         """
2743         Add a new text note to the page to be saved next. The optional
2744         positionRect specifies the position of the new note on the
2745         page. It is outside the page per default to make sure it is
2746         invisible on printouts.
2747         """
2748         self._file.newTextnote(text, positionRect)
2749 
2750 
2751 class FigureCanvasPdf(FigureCanvasBase):
2752     # docstring inherited
2753 
2754     fixed_dpi = 72
2755     filetypes = {'pdf': 'Portable Document Format'}
2756 
2757     def get_default_filetype(self):
2758         return 'pdf'
2759 
2760     def print_pdf(self, filename, *,
2761                   bbox_inches_restore=None, metadata=None):
2762 
2763         dpi = self.figure.dpi
2764         self.figure.dpi = 72  # there are 72 pdf points to an inch
2765         width, height = self.figure.get_size_inches()
2766         if isinstance(filename, PdfPages):
2767             file = filename._file
2768         else:
2769             file = PdfFile(filename, metadata=metadata)
2770         try:
2771             file.newPage(width, height)
2772             renderer = MixedModeRenderer(
2773                 self.figure, width, height, dpi,
2774                 RendererPdf(file, dpi, height, width),
2775                 bbox_inches_restore=bbox_inches_restore)
2776             self.figure.draw(renderer)
2777             renderer.finalize()
2778             if not isinstance(filename, PdfPages):
2779                 file.finalize()
2780         finally:
2781             if isinstance(filename, PdfPages):  # finish off this page
2782                 file.endStream()
2783             else:            # we opened the file above; now finish it off
2784                 file.close()
2785 
2786     def draw(self):
2787         self.figure.draw_without_rendering()
2788         return super().draw()
2789 
2790 
2791 FigureManagerPdf = FigureManagerBase
2792 
2793 
2794 @_Backend.export
2795 class _BackendPdf(_Backend):
2796     FigureCanvas = FigureCanvasPdf

</code><intended_behavior>The method responsible for rendering text with URLs in PDFs should account for the text's rotation by correctly implementing the 'QuadPoints' in addition to the 'Rect' for link annotations. This implementation should allow the clickable area to correctly rotate with the text, matching its visual orientation. This enhancement must maintain backward compatibility by also providing a 'Rect' that encompasses the rotated text's footprint, ensuring that viewers not supporting 'QuadPoints' still offer a functional (though potentially less precise) clickable area.</intended_behavior>]
2025-10-15 07:25:05.579 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/backends/backend_pdf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A PDF Matplotlib backend.
3 
4 Author: Jouni K Sepp√§nen <jks@iki.fi> and others.
5 """
6 
7 import codecs
8 from datetime import datetime
9 from enum import Enum
10 from functools import total_ordering
11 from io import BytesIO
12 import itertools
13 import logging
14 import math
15 import os
16 import re
17 import string
18 import struct
19 import sys
20 import time
21 import types
22 import warnings
23 import zlib
24 
25 import numpy as np
26 from PIL import Image
27 
28 import matplotlib as mpl
29 from matplotlib import _api, _text_helpers, _type1font, cbook, dviread
30 from matplotlib._pylab_helpers import Gcf
31 from matplotlib.backend_bases import (
32     _Backend, FigureCanvasBase, FigureManagerBase, GraphicsContextBase,
33     RendererBase)
34 from matplotlib.backends.backend_mixed import MixedModeRenderer
35 from matplotlib.figure import Figure
36 from matplotlib.font_manager import findfont, get_font
37 from matplotlib._afm import AFM
38 from matplotlib.ft2font import (FIXED_WIDTH, ITALIC, LOAD_NO_SCALE,
39                                 LOAD_NO_HINTING, KERNING_UNFITTED, FT2Font)
40 from matplotlib.transforms import Affine2D, BboxBase
41 from matplotlib.path import Path
42 from matplotlib.dates import UTC
43 from matplotlib import _path
44 from . import _backend_pdf_ps
45 
46 _log = logging.getLogger(__name__)
47 
48 # Overview
49 #
50 # The low-level knowledge about pdf syntax lies mainly in the pdfRepr
51 # function and the classes Reference, Name, Operator, and Stream.  The
52 # PdfFile class knows about the overall structure of pdf documents.
53 # It provides a "write" method for writing arbitrary strings in the
54 # file, and an "output" method that passes objects through the pdfRepr
55 # function before writing them in the file.  The output method is
56 # called by the RendererPdf class, which contains the various draw_foo
57 # methods.  RendererPdf contains a GraphicsContextPdf instance, and
58 # each draw_foo calls self.check_gc before outputting commands.  This
59 # method checks whether the pdf graphics state needs to be modified
60 # and outputs the necessary commands.  GraphicsContextPdf represents
61 # the graphics state, and its "delta" method returns the commands that
62 # modify the state.
63 
64 # Add "pdf.use14corefonts: True" in your configuration file to use only
65 # the 14 PDF core fonts. These fonts do not need to be embedded; every
66 # PDF viewing application is required to have them. This results in very
67 # light PDF files you can use directly in LaTeX or ConTeXt documents
68 # generated with pdfTeX, without any conversion.
69 
70 # These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,
71 # Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,
72 # Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,
73 # Times-BoldItalic, Symbol, ZapfDingbats.
74 #
75 # Some tricky points:
76 #
77 # 1. The clip path can only be widened by popping from the state
78 # stack.  Thus the state must be pushed onto the stack before narrowing
79 # the clip path.  This is taken care of by GraphicsContextPdf.
80 #
81 # 2. Sometimes it is necessary to refer to something (e.g., font,
82 # image, or extended graphics state, which contains the alpha value)
83 # in the page stream by a name that needs to be defined outside the
84 # stream.  PdfFile provides the methods fontName, imageObject, and
85 # alphaState for this purpose.  The implementations of these methods
86 # should perhaps be generalized.
87 
88 # TODOs:
89 #
90 # * encoding of fonts, including mathtext fonts and Unicode support
91 # * TTF support has lots of small TODOs, e.g., how do you know if a font
92 #   is serif/sans-serif, or symbolic/non-symbolic?
93 # * draw_quad_mesh
94 
95 
96 @_api.deprecated("3.6", alternative="Vendor the code")
97 def fill(strings, linelen=75):
98     return _fill(strings, linelen=linelen)
99 
100 
101 def _fill(strings, linelen=75):
102     """
103     Make one string from sequence of strings, with whitespace in between.
104 
105     The whitespace is chosen to form lines of at most *linelen* characters,
106     if possible.
107     """
108     currpos = 0
109     lasti = 0
110     result = []
111     for i, s in enumerate(strings):
112         length = len(s)
113         if currpos + length < linelen:
114             currpos += length + 1
115         else:
116             result.append(b' '.join(strings[lasti:i]))
117             lasti = i
118             currpos = length
119     result.append(b' '.join(strings[lasti:]))
120     return b'\n'.join(result)
121 
122 # PDF strings are supposed to be able to include any eight-bit data,
123 # except that unbalanced parens and backslashes must be escaped by a
124 # backslash. However, sf bug #2708559 shows that the carriage return
125 # character may get read as a newline; these characters correspond to
126 # \gamma and \Omega in TeX's math font encoding. Escaping them fixes
127 # the bug.
128 _string_escape_regex = re.compile(br'([\\()\r\n])')
129 
130 
131 def _string_escape(match):
132     m = match.group(0)
133     if m in br'\()':
134         return b'\\' + m
135     elif m == b'\n':
136         return br'\n'
137     elif m == b'\r':
138         return br'\r'
139     assert False
140 
141 
142 def _create_pdf_info_dict(backend, metadata):
143     """
144     Create a PDF infoDict based on user-supplied metadata.
145 
146     A default ``Creator``, ``Producer``, and ``CreationDate`` are added, though
147     the user metadata may override it. The date may be the current time, or a
148     time set by the ``SOURCE_DATE_EPOCH`` environment variable.
149 
150     Metadata is verified to have the correct keys and their expected types. Any
151     unknown keys/types will raise a warning.
152 
153     Parameters
154     ----------
155     backend : str
156         The name of the backend to use in the Producer value.
157 
158     metadata : dict[str, Union[str, datetime, Name]]
159         A dictionary of metadata supplied by the user with information
160         following the PDF specification, also defined in
161         `~.backend_pdf.PdfPages` below.
162 
163         If any value is *None*, then the key will be removed. This can be used
164         to remove any pre-defined values.
165 
166     Returns
167     -------
168     dict[str, Union[str, datetime, Name]]
169         A validated dictionary of metadata.
170     """
171 
172     # get source date from SOURCE_DATE_EPOCH, if set
173     # See https://reproducible-builds.org/specs/source-date-epoch/
174     source_date_epoch = os.getenv("SOURCE_DATE_EPOCH")
175     if source_date_epoch:
176         source_date = datetime.utcfromtimestamp(int(source_date_epoch))
177         source_date = source_date.replace(tzinfo=UTC)
178     else:
179         source_date = datetime.today()
180 
181     info = {
182         'Creator': f'Matplotlib v{mpl.__version__}, https://matplotlib.org',
183         'Producer': f'Matplotlib {backend} backend v{mpl.__version__}',
184         'CreationDate': source_date,
185         **metadata
186     }
187     info = {k: v for (k, v) in info.items() if v is not None}
188 
189     def is_string_like(x):
190         return isinstance(x, str)
191     is_string_like.text_for_warning = "an instance of str"
192 
193     def is_date(x):
194         return isinstance(x, datetime)
195     is_date.text_for_warning = "an instance of datetime.datetime"
196 
197     def check_trapped(x):
198         if isinstance(x, Name):
199             return x.name in (b'True', b'False', b'Unknown')
200         else:
201             return x in ('True', 'False', 'Unknown')
202     check_trapped.text_for_warning = 'one of {"True", "False", "Unknown"}'
203 
204     keywords = {
205         'Title': is_string_like,
206         'Author': is_string_like,
207         'Subject': is_string_like,
208         'Keywords': is_string_like,
209         'Creator': is_string_like,
210         'Producer': is_string_like,
211         'CreationDate': is_date,
212         'ModDate': is_date,
213         'Trapped': check_trapped,
214     }
215     for k in info:
216         if k not in keywords:
217             _api.warn_external(f'Unknown infodict keyword: {k!r}. '
218                                f'Must be one of {set(keywords)!r}.')
219         elif not keywords[k](info[k]):
220             _api.warn_external(f'Bad value for infodict keyword {k}. '
221                                f'Got {info[k]!r} which is not '
222                                f'{keywords[k].text_for_warning}.')
223     if 'Trapped' in info:
224         info['Trapped'] = Name(info['Trapped'])
225 
226     return info
227 
228 
229 def _datetime_to_pdf(d):
230     """
231     Convert a datetime to a PDF string representing it.
232 
233     Used for PDF and PGF.
234     """
235     r = d.strftime('D:%Y%m%d%H%M%S')
236     z = d.utcoffset()
237     if z is not None:
238         z = z.seconds
239     else:
240         if time.daylight:
241             z = time.altzone
242         else:
243             z = time.timezone
244     if z == 0:
245         r += 'Z'
246     elif z < 0:
247         r += "+%02d'%02d'" % ((-z) // 3600, (-z) % 3600)
248     else:
249         r += "-%02d'%02d'" % (z // 3600, z % 3600)
250     return r
251 
252 
253 def pdfRepr(obj):
254     """Map Python objects to PDF syntax."""
255 
256     # Some objects defined later have their own pdfRepr method.
257     if hasattr(obj, 'pdfRepr'):
258         return obj.pdfRepr()
259 
260     # Floats. PDF does not have exponential notation (1.0e-10) so we
261     # need to use %f with some precision.  Perhaps the precision
262     # should adapt to the magnitude of the number?
263     elif isinstance(obj, (float, np.floating)):
264         if not np.isfinite(obj):
265             raise ValueError("Can only output finite numbers in PDF")
266         r = b"%.10f" % obj
267         return r.rstrip(b'0').rstrip(b'.')
268 
269     # Booleans. Needs to be tested before integers since
270     # isinstance(True, int) is true.
271     elif isinstance(obj, bool):
272         return [b'false', b'true'][obj]
273 
274     # Integers are written as such.
275     elif isinstance(obj, (int, np.integer)):
276         return b"%d" % obj
277 
278     # Unicode strings are encoded in UTF-16BE with byte-order mark.
279     elif isinstance(obj, str):
280         try:
281             # But maybe it's really ASCII?
282             s = obj.encode('ASCII')
283             return pdfRepr(s)
284         except UnicodeEncodeError:
285             s = codecs.BOM_UTF16_BE + obj.encode('UTF-16BE')
286             return pdfRepr(s)
287 
288     # Strings are written in parentheses, with backslashes and parens
289     # escaped. Actually balanced parens are allowed, but it is
290     # simpler to escape them all. TODO: cut long strings into lines;
291     # I believe there is some maximum line length in PDF.
292     elif isinstance(obj, bytes):
293         return b'(' + _string_escape_regex.sub(_string_escape, obj) + b')'
294 
295     # Dictionaries. The keys must be PDF names, so if we find strings
296     # there, we make Name objects from them. The values may be
297     # anything, so the caller must ensure that PDF names are
298     # represented as Name objects.
299     elif isinstance(obj, dict):
300         return _fill([
301             b"<<",
302             *[Name(k).pdfRepr() + b" " + pdfRepr(v) for k, v in obj.items()],
303             b">>",
304         ])
305 
306     # Lists.
307     elif isinstance(obj, (list, tuple)):
308         return _fill([b"[", *[pdfRepr(val) for val in obj], b"]"])
309 
310     # The null keyword.
311     elif obj is None:
312         return b'null'
313 
314     # A date.
315     elif isinstance(obj, datetime):
316         return pdfRepr(_datetime_to_pdf(obj))
317 
318     # A bounding box
319     elif isinstance(obj, BboxBase):
320         return _fill([pdfRepr(val) for val in obj.bounds])
321 
322     else:
323         raise TypeError("Don't know a PDF representation for {} objects"
324                         .format(type(obj)))
325 
326 
327 def _font_supports_glyph(fonttype, glyph):
328     """
329     Returns True if the font is able to provide codepoint *glyph* in a PDF.
330 
331     For a Type 3 font, this method returns True only for single-byte
332     characters. For Type 42 fonts this method return True if the character is
333     from the Basic Multilingual Plane.
334     """
335     if fonttype == 3:
336         return glyph <= 255
337     if fonttype == 42:
338         return glyph <= 65535
339     raise NotImplementedError()
340 
341 
342 class Reference:
343     """
344     PDF reference object.
345 
346     Use PdfFile.reserveObject() to create References.
347     """
348 
349     def __init__(self, id):
350         self.id = id
351 
352     def __repr__(self):
353         return "<Reference %d>" % self.id
354 
355     def pdfRepr(self):
356         return b"%d 0 R" % self.id
357 
358     def write(self, contents, file):
359         write = file.write
360         write(b"%d 0 obj\n" % self.id)
361         write(pdfRepr(contents))
362         write(b"\nendobj\n")
363 
364 
365 @total_ordering
366 class Name:
367     """PDF name object."""
368     __slots__ = ('name',)
369     _hexify = {c: '#%02x' % c
370                for c in {*range(256)} - {*range(ord('!'), ord('~') + 1)}}
371 
372     def __init__(self, name):
373         if isinstance(name, Name):
374             self.name = name.name
375         else:
376             if isinstance(name, bytes):
377                 name = name.decode('ascii')
378             self.name = name.translate(self._hexify).encode('ascii')
379 
380     def __repr__(self):
381         return "<Name %s>" % self.name
382 
383     def __str__(self):
384         return '/' + self.name.decode('ascii')
385 
386     def __eq__(self, other):
387         return isinstance(other, Name) and self.name == other.name
388 
389     def __lt__(self, other):
390         return isinstance(other, Name) and self.name < other.name
391 
392     def __hash__(self):
393         return hash(self.name)
394 
395     @staticmethod
396     @_api.deprecated("3.6")
397     def hexify(match):
398         return '#%02x' % ord(match.group())
399 
400     def pdfRepr(self):
401         return b'/' + self.name
402 
403 
404 @_api.deprecated("3.6")
405 class Operator:
406     __slots__ = ('op',)
407 
408     def __init__(self, op):
409         self.op = op
410 
411     def __repr__(self):
412         return '<Operator %s>' % self.op
413 
414     def pdfRepr(self):
415         return self.op
416 
417 
418 class Verbatim:
419     """Store verbatim PDF command content for later inclusion in the stream."""
420     def __init__(self, x):
421         self._x = x
422 
423     def pdfRepr(self):
424         return self._x
425 
426 
427 class Op(Enum):
428     """PDF operators (not an exhaustive list)."""
429 
430     close_fill_stroke = b'b'
431     fill_stroke = b'B'
432     fill = b'f'
433     closepath = b'h'
434     close_stroke = b's'
435     stroke = b'S'
436     endpath = b'n'
437     begin_text = b'BT'
438     end_text = b'ET'
439     curveto = b'c'
440     rectangle = b're'
441     lineto = b'l'
442     moveto = b'm'
443     concat_matrix = b'cm'
444     use_xobject = b'Do'
445     setgray_stroke = b'G'
446     setgray_nonstroke = b'g'
447     setrgb_stroke = b'RG'
448     setrgb_nonstroke = b'rg'
449     setcolorspace_stroke = b'CS'
450     setcolorspace_nonstroke = b'cs'
451     setcolor_stroke = b'SCN'
452     setcolor_nonstroke = b'scn'
453     setdash = b'd'
454     setlinejoin = b'j'
455     setlinecap = b'J'
456     setgstate = b'gs'
457     gsave = b'q'
458     grestore = b'Q'
459     textpos = b'Td'
460     selectfont = b'Tf'
461     textmatrix = b'Tm'
462     show = b'Tj'
463     showkern = b'TJ'
464     setlinewidth = b'w'
465     clip = b'W'
466     shading = b'sh'
467 
468     op = _api.deprecated('3.6')(property(lambda self: self.value))
469 
470     def pdfRepr(self):
471         return self.value
472 
473     @classmethod
474     def paint_path(cls, fill, stroke):
475         """
476         Return the PDF operator to paint a path.
477 
478         Parameters
479         ----------
480         fill : bool
481             Fill the path with the fill color.
482         stroke : bool
483             Stroke the outline of the path with the line color.
484         """
485         if stroke:
486             if fill:
487                 return cls.fill_stroke
488             else:
489                 return cls.stroke
490         else:
491             if fill:
492                 return cls.fill
493             else:
494                 return cls.endpath
495 
496 
497 class Stream:
498     """
499     PDF stream object.
500 
501     This has no pdfRepr method. Instead, call begin(), then output the
502     contents of the stream by calling write(), and finally call end().
503     """
504     __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')
505 
506     def __init__(self, id, len, file, extra=None, png=None):
507         """
508         Parameters
509         ----------
510         id : int
511             Object id of the stream.
512         len : Reference or None
513             An unused Reference object for the length of the stream;
514             None means to use a memory buffer so the length can be inlined.
515         file : PdfFile
516             The underlying object to write the stream to.
517         extra : dict from Name to anything, or None
518             Extra key-value pairs to include in the stream header.
519         png : dict or None
520             If the data is already png encoded, the decode parameters.
521         """
522         self.id = id            # object id
523         self.len = len          # id of length object
524         self.pdfFile = file
525         self.file = file.fh      # file to which the stream is written
526         self.compressobj = None  # compression object
527         if extra is None:
528             self.extra = dict()
529         else:
530             self.extra = extra.copy()
531         if png is not None:
532             self.extra.update({'Filter':      Name('FlateDecode'),
533                                'DecodeParms': png})
534 
535         self.pdfFile.recordXref(self.id)
536         if mpl.rcParams['pdf.compression'] and not png:
537             self.compressobj = zlib.compressobj(
538                 mpl.rcParams['pdf.compression'])
539         if self.len is None:
540             self.file = BytesIO()
541         else:
542             self._writeHeader()
543             self.pos = self.file.tell()
544 
545     def _writeHeader(self):
546         write = self.file.write
547         write(b"%d 0 obj\n" % self.id)
548         dict = self.extra
549         dict['Length'] = self.len
550         if mpl.rcParams['pdf.compression']:
551             dict['Filter'] = Name('FlateDecode')
552 
553         write(pdfRepr(dict))
554         write(b"\nstream\n")
555 
556     def end(self):
557         """Finalize stream."""
558 
559         self._flush()
560         if self.len is None:
561             contents = self.file.getvalue()
562             self.len = len(contents)
563             self.file = self.pdfFile.fh
564             self._writeHeader()
565             self.file.write(contents)
566             self.file.write(b"\nendstream\nendobj\n")
567         else:
568             length = self.file.tell() - self.pos
569             self.file.write(b"\nendstream\nendobj\n")
570             self.pdfFile.writeObject(self.len, length)
571 
572     def write(self, data):
573         """Write some data on the stream."""
574 
575         if self.compressobj is None:
576             self.file.write(data)
577         else:
578             compressed = self.compressobj.compress(data)
579             self.file.write(compressed)
580 
581     def _flush(self):
582         """Flush the compression object."""
583 
584         if self.compressobj is not None:
585             compressed = self.compressobj.flush()
586             self.file.write(compressed)
587             self.compressobj = None
588 
589 
590 def _get_pdf_charprocs(font_path, glyph_ids):
591     font = get_font(font_path, hinting_factor=1)
592     conv = 1000 / font.units_per_EM  # Conversion to PS units (1/1000's).
593     procs = {}
594     for glyph_id in glyph_ids:
595         g = font.load_glyph(glyph_id, LOAD_NO_SCALE)
596         # NOTE: We should be using round(), but instead use
597         # "(x+.5).astype(int)" to keep backcompat with the old ttconv code
598         # (this is different for negative x's).
599         d1 = (np.array([g.horiAdvance, 0, *g.bbox]) * conv + .5).astype(int)
600         v, c = font.get_path()
601         v = (v * 64).astype(int)  # Back to TrueType's internal units (1/64's).
602         # Backcompat with old ttconv code: control points between two quads are
603         # omitted if they are exactly at the midpoint between the control of
604         # the quad before and the quad after, but ttconv used to interpolate
605         # *after* conversion to PS units, causing floating point errors.  Here
606         # we reproduce ttconv's logic, detecting these "implicit" points and
607         # re-interpolating them.  Note that occasionally (e.g. with DejaVu Sans
608         # glyph "0") a point detected as "implicit" is actually explicit, and
609         # will thus be shifted by 1.
610         quads, = np.nonzero(c == 3)
611         quads_on = quads[1::2]
612         quads_mid_on = np.array(
613             sorted({*quads_on} & {*(quads - 1)} & {*(quads + 1)}), int)
614         implicit = quads_mid_on[
615             (v[quads_mid_on]  # As above, use astype(int), not // division
616              == ((v[quads_mid_on - 1] + v[quads_mid_on + 1]) / 2).astype(int))
617             .all(axis=1)]
618         if (font.postscript_name, glyph_id) in [
619                 ("DejaVuSerif-Italic", 77),  # j
620                 ("DejaVuSerif-Italic", 135),  # \AA
621         ]:
622             v[:, 0] -= 1  # Hard-coded backcompat (FreeType shifts glyph by 1).
623         v = (v * conv + .5).astype(int)  # As above re: truncation vs rounding.
624         v[implicit] = ((  # Fix implicit points; again, truncate.
625             (v[implicit - 1] + v[implicit + 1]) / 2).astype(int))
626         procs[font.get_glyph_name(glyph_id)] = (
627             " ".join(map(str, d1)).encode("ascii") + b" d1\n"
628             + _path.convert_to_string(
629                 Path(v, c), None, None, False, None, -1,
630                 # no code for quad Beziers triggers auto-conversion to cubics.
631                 [b"m", b"l", b"", b"c", b"h"], True)
632             + b"f")
633     return procs
634 
635 
636 class PdfFile:
637     """PDF file object."""
638 
639     def __init__(self, filename, metadata=None):
640         """
641         Parameters
642         ----------
643         filename : str or path-like or file-like
644             Output target; if a string, a file will be opened for writing.
645 
646         metadata : dict from strings to strings and dates
647             Information dictionary object (see PDF reference section 10.2.1
648             'Document Information Dictionary'), e.g.:
649             ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.
650 
651             The standard keys are 'Title', 'Author', 'Subject', 'Keywords',
652             'Creator', 'Producer', 'CreationDate', 'ModDate', and
653             'Trapped'. Values have been predefined for 'Creator', 'Producer'
654             and 'CreationDate'. They can be removed by setting them to `None`.
655         """
656         super().__init__()
657 
658         self._object_seq = itertools.count(1)  # consumed by reserveObject
659         self.xrefTable = [[0, 65535, 'the zero object']]
660         self.passed_in_file_object = False
661         self.original_file_like = None
662         self.tell_base = 0
663         fh, opened = cbook.to_filehandle(filename, "wb", return_opened=True)
664         if not opened:
665             try:
666                 self.tell_base = filename.tell()
667             except IOError:
668                 fh = BytesIO()
669                 self.original_file_like = filename
670             else:
671                 fh = filename
672                 self.passed_in_file_object = True
673 
674         self.fh = fh
675         self.currentstream = None  # stream object to write to, if any
676         fh.write(b"%PDF-1.4\n")    # 1.4 is the first version to have alpha
677         # Output some eight-bit chars as a comment so various utilities
678         # recognize the file as binary by looking at the first few
679         # lines (see note in section 3.4.1 of the PDF reference).
680         fh.write(b"%\254\334 \253\272\n")
681 
682         self.rootObject = self.reserveObject('root')
683         self.pagesObject = self.reserveObject('pages')
684         self.pageList = []
685         self.fontObject = self.reserveObject('fonts')
686         self._extGStateObject = self.reserveObject('extended graphics states')
687         self.hatchObject = self.reserveObject('tiling patterns')
688         self.gouraudObject = self.reserveObject('Gouraud triangles')
689         self.XObjectObject = self.reserveObject('external objects')
690         self.resourceObject = self.reserveObject('resources')
691 
692         root = {'Type': Name('Catalog'),
693                 'Pages': self.pagesObject}
694         self.writeObject(self.rootObject, root)
695 
696         self.infoDict = _create_pdf_info_dict('pdf', metadata or {})
697 
698         self.fontNames = {}     # maps filenames to internal font names
699         self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))
700         self.dviFontInfo = {}   # maps dvi font names to embedding information
701         # differently encoded Type-1 fonts may share the same descriptor
702         self.type1Descriptors = {}
703         self._character_tracker = _backend_pdf_ps.CharacterTracker()
704 
705         self.alphaStates = {}   # maps alpha values to graphics state objects
706         self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))
707         self._soft_mask_states = {}
708         self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))
709         self._soft_mask_groups = []
710         self.hatchPatterns = {}
711         self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))
712         self.gouraudTriangles = []
713 
714         self._images = {}
715         self._image_seq = (Name(f'I{i}') for i in itertools.count(1))
716 
717         self.markers = {}
718         self.multi_byte_charprocs = {}
719 
720         self.paths = []
721 
722         # A list of annotations for each page. Each entry is a tuple of the
723         # overall Annots object reference that's inserted into the page object,
724         # followed by a list of the actual annotations.
725         self._annotations = []
726         # For annotations added before a page is created; mostly for the
727         # purpose of newTextnote.
728         self.pageAnnotations = []
729 
730         # The PDF spec recommends to include every procset
731         procsets = [Name(x) for x in "PDF Text ImageB ImageC ImageI".split()]
732 
733         # Write resource dictionary.
734         # Possibly TODO: more general ExtGState (graphics state dictionaries)
735         #                ColorSpace Pattern Shading Properties
736         resources = {'Font': self.fontObject,
737                      'XObject': self.XObjectObject,
738                      'ExtGState': self._extGStateObject,
739                      'Pattern': self.hatchObject,
740                      'Shading': self.gouraudObject,
741                      'ProcSet': procsets}
742         self.writeObject(self.resourceObject, resources)
743 
744     def newPage(self, width, height):
745         self.endStream()
746 
747         self.width, self.height = width, height
748         contentObject = self.reserveObject('page contents')
749         annotsObject = self.reserveObject('annotations')
750         thePage = {'Type': Name('Page'),
751                    'Parent': self.pagesObject,
752                    'Resources': self.resourceObject,
753                    'MediaBox': [0, 0, 72 * width, 72 * height],
754                    'Contents': contentObject,
755                    'Annots': annotsObject,
756                    }
757         pageObject = self.reserveObject('page')
758         self.writeObject(pageObject, thePage)
759         self.pageList.append(pageObject)
760         self._annotations.append((annotsObject, self.pageAnnotations))
761 
762         self.beginStream(contentObject.id,
763                          self.reserveObject('length of content stream'))
764         # Initialize the pdf graphics state to match the default Matplotlib
765         # graphics context (colorspace and joinstyle).
766         self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)
767         self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)
768         self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)
769 
770         # Clear the list of annotations for the next page
771         self.pageAnnotations = []
772 
773     def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):
774         # Create a new annotation of type text
775         theNote = {'Type': Name('Annot'),
776                    'Subtype': Name('Text'),
777                    'Contents': text,
778                    'Rect': positionRect,
779                    }
780         self.pageAnnotations.append(theNote)
781 
782     def _get_subsetted_psname(self, ps_name, charmap):
783         def toStr(n, base):
784             if n < base:
785                 return string.ascii_uppercase[n]
786             else:
787                 return (
788                     toStr(n // base, base) + string.ascii_uppercase[n % base]
789                 )
790 
791         # encode to string using base 26
792         hashed = hash(frozenset(charmap.keys())) % ((sys.maxsize + 1) * 2)
793         prefix = toStr(hashed, 26)
794 
795         # get first 6 characters from prefix
796         return prefix[:6] + "+" + ps_name
797 
798     def finalize(self):
799         """Write out the various deferred objects and the pdf end matter."""
800 
801         self.endStream()
802         self._write_annotations()
803         self.writeFonts()
804         self.writeExtGSTates()
805         self._write_soft_mask_groups()
806         self.writeHatches()
807         self.writeGouraudTriangles()
808         xobjects = {
809             name: ob for image, name, ob in self._images.values()}
810         for tup in self.markers.values():
811             xobjects[tup[0]] = tup[1]
812         for name, value in self.multi_byte_charprocs.items():
813             xobjects[name] = value
814         for name, path, trans, ob, join, cap, padding, filled, stroked \
815                 in self.paths:
816             xobjects[name] = ob
817         self.writeObject(self.XObjectObject, xobjects)
818         self.writeImages()
819         self.writeMarkers()
820         self.writePathCollectionTemplates()
821         self.writeObject(self.pagesObject,
822                          {'Type': Name('Pages'),
823                           'Kids': self.pageList,
824                           'Count': len(self.pageList)})
825         self.writeInfoDict()
826 
827         # Finalize the file
828         self.writeXref()
829         self.writeTrailer()
830 
831     def close(self):
832         """Flush all buffers and free all resources."""
833 
834         self.endStream()
835         if self.passed_in_file_object:
836             self.fh.flush()
837         else:
838             if self.original_file_like is not None:
839                 self.original_file_like.write(self.fh.getvalue())
840             self.fh.close()
841 
842     def write(self, data):
843         if self.currentstream is None:
844             self.fh.write(data)
845         else:
846             self.currentstream.write(data)
847 
848     def output(self, *data):
849         self.write(_fill([pdfRepr(x) for x in data]))
850         self.write(b'\n')
851 
852     def beginStream(self, id, len, extra=None, png=None):
853         assert self.currentstream is None
854         self.currentstream = Stream(id, len, self, extra, png)
855 
856     def endStream(self):
857         if self.currentstream is not None:
858             self.currentstream.end()
859             self.currentstream = None
860 
861     def outputStream(self, ref, data, *, extra=None):
862         self.beginStream(ref.id, None, extra)
863         self.currentstream.write(data)
864         self.endStream()
865 
866     def _write_annotations(self):
867         for annotsObject, annotations in self._annotations:
868             self.writeObject(annotsObject, annotations)
869 
870     def fontName(self, fontprop):
871         """
872         Select a font based on fontprop and return a name suitable for
873         Op.selectfont. If fontprop is a string, it will be interpreted
874         as the filename of the font.
875         """
876 
877         if isinstance(fontprop, str):
878             filename = fontprop
879         elif mpl.rcParams['pdf.use14corefonts']:
880             filename = findfont(
881                 fontprop, fontext='afm', directory=RendererPdf._afm_font_dir)
882         else:
883             filename = findfont(fontprop)
884 
885         Fx = self.fontNames.get(filename)
886         if Fx is None:
887             Fx = next(self._internal_font_seq)
888             self.fontNames[filename] = Fx
889             _log.debug('Assigning font %s = %r', Fx, filename)
890 
891         return Fx
892 
893     def dviFontName(self, dvifont):
894         """
895         Given a dvi font object, return a name suitable for Op.selectfont.
896         This registers the font information in ``self.dviFontInfo`` if not yet
897         registered.
898         """
899 
900         dvi_info = self.dviFontInfo.get(dvifont.texname)
901         if dvi_info is not None:
902             return dvi_info.pdfname
903 
904         tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))
905         psfont = tex_font_map[dvifont.texname]
906         if psfont.filename is None:
907             raise ValueError(
908                 "No usable font file found for {} (TeX: {}); "
909                 "the font may lack a Type-1 version"
910                 .format(psfont.psname, dvifont.texname))
911 
912         pdfname = next(self._internal_font_seq)
913         _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)
914         self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(
915             dvifont=dvifont,
916             pdfname=pdfname,
917             fontfile=psfont.filename,
918             basefont=psfont.psname,
919             encodingfile=psfont.encoding,
920             effects=psfont.effects)
921         return pdfname
922 
923     def writeFonts(self):
924         fonts = {}
925         for dviname, info in sorted(self.dviFontInfo.items()):
926             Fx = info.pdfname
927             _log.debug('Embedding Type-1 font %s from dvi.', dviname)
928             fonts[Fx] = self._embedTeXFont(info)
929         for filename in sorted(self.fontNames):
930             Fx = self.fontNames[filename]
931             _log.debug('Embedding font %s.', filename)
932             if filename.endswith('.afm'):
933                 # from pdf.use14corefonts
934                 _log.debug('Writing AFM font.')
935                 fonts[Fx] = self._write_afm_font(filename)
936             else:
937                 # a normal TrueType font
938                 _log.debug('Writing TrueType font.')
939                 chars = self._character_tracker.used.get(filename)
940                 if chars:
941                     fonts[Fx] = self.embedTTF(filename, chars)
942         self.writeObject(self.fontObject, fonts)
943 
944     def _write_afm_font(self, filename):
945         with open(filename, 'rb') as fh:
946             font = AFM(fh)
947         fontname = font.get_fontname()
948         fontdict = {'Type': Name('Font'),
949                     'Subtype': Name('Type1'),
950                     'BaseFont': Name(fontname),
951                     'Encoding': Name('WinAnsiEncoding')}
952         fontdictObject = self.reserveObject('font dictionary')
953         self.writeObject(fontdictObject, fontdict)
954         return fontdictObject
955 
956     def _embedTeXFont(self, fontinfo):
957         _log.debug('Embedding TeX font %s - fontinfo=%s',
958                    fontinfo.dvifont.texname, fontinfo.__dict__)
959 
960         # Widths
961         widthsObject = self.reserveObject('font widths')
962         self.writeObject(widthsObject, fontinfo.dvifont.widths)
963 
964         # Font dictionary
965         fontdictObject = self.reserveObject('font dictionary')
966         fontdict = {
967             'Type':      Name('Font'),
968             'Subtype':   Name('Type1'),
969             'FirstChar': 0,
970             'LastChar':  len(fontinfo.dvifont.widths) - 1,
971             'Widths':    widthsObject,
972             }
973 
974         # Encoding (if needed)
975         if fontinfo.encodingfile is not None:
976             fontdict['Encoding'] = {
977                 'Type': Name('Encoding'),
978                 'Differences': [
979                     0, *map(Name, dviread._parse_enc(fontinfo.encodingfile))],
980             }
981 
982         # If no file is specified, stop short
983         if fontinfo.fontfile is None:
984             _log.warning(
985                 "Because of TeX configuration (pdftex.map, see updmap option "
986                 "pdftexDownloadBase14) the font %s is not embedded. This is "
987                 "deprecated as of PDF 1.5 and it may cause the consumer "
988                 "application to show something that was not intended.",
989                 fontinfo.basefont)
990             fontdict['BaseFont'] = Name(fontinfo.basefont)
991             self.writeObject(fontdictObject, fontdict)
992             return fontdictObject
993 
994         # We have a font file to embed - read it in and apply any effects
995         t1font = _type1font.Type1Font(fontinfo.fontfile)
996         if fontinfo.effects:
997             t1font = t1font.transform(fontinfo.effects)
998         fontdict['BaseFont'] = Name(t1font.prop['FontName'])
999 
1000         # Font descriptors may be shared between differently encoded
1001         # Type-1 fonts, so only create a new descriptor if there is no
1002         # existing descriptor for this font.
1003         effects = (fontinfo.effects.get('slant', 0.0),
1004                    fontinfo.effects.get('extend', 1.0))
1005         fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))
1006         if fontdesc is None:
1007             fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)
1008             self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc
1009         fontdict['FontDescriptor'] = fontdesc
1010 
1011         self.writeObject(fontdictObject, fontdict)
1012         return fontdictObject
1013 
1014     def createType1Descriptor(self, t1font, fontfile):
1015         # Create and write the font descriptor and the font file
1016         # of a Type-1 font
1017         fontdescObject = self.reserveObject('font descriptor')
1018         fontfileObject = self.reserveObject('font file')
1019 
1020         italic_angle = t1font.prop['ItalicAngle']
1021         fixed_pitch = t1font.prop['isFixedPitch']
1022 
1023         flags = 0
1024         # fixed width
1025         if fixed_pitch:
1026             flags |= 1 << 0
1027         # TODO: serif
1028         if 0:
1029             flags |= 1 << 1
1030         # TODO: symbolic (most TeX fonts are)
1031         if 1:
1032             flags |= 1 << 2
1033         # non-symbolic
1034         else:
1035             flags |= 1 << 5
1036         # italic
1037         if italic_angle:
1038             flags |= 1 << 6
1039         # TODO: all caps
1040         if 0:
1041             flags |= 1 << 16
1042         # TODO: small caps
1043         if 0:
1044             flags |= 1 << 17
1045         # TODO: force bold
1046         if 0:
1047             flags |= 1 << 18
1048 
1049         ft2font = get_font(fontfile)
1050 
1051         descriptor = {
1052             'Type':        Name('FontDescriptor'),
1053             'FontName':    Name(t1font.prop['FontName']),
1054             'Flags':       flags,
1055             'FontBBox':    ft2font.bbox,
1056             'ItalicAngle': italic_angle,
1057             'Ascent':      ft2font.ascender,
1058             'Descent':     ft2font.descender,
1059             'CapHeight':   1000,  # TODO: find this out
1060             'XHeight':     500,  # TODO: this one too
1061             'FontFile':    fontfileObject,
1062             'FontFamily':  t1font.prop['FamilyName'],
1063             'StemV':       50,  # TODO
1064             # (see also revision 3874; but not all TeX distros have AFM files!)
1065             # 'FontWeight': a number where 400 = Regular, 700 = Bold
1066             }
1067 
1068         self.writeObject(fontdescObject, descriptor)
1069 
1070         self.outputStream(fontfileObject, b"".join(t1font.parts[:2]),
1071                           extra={'Length1': len(t1font.parts[0]),
1072                                  'Length2': len(t1font.parts[1]),
1073                                  'Length3': 0})
1074 
1075         return fontdescObject
1076 
1077     def _get_xobject_glyph_name(self, filename, glyph_name):
1078         Fx = self.fontName(filename)
1079         return "-".join([
1080             Fx.name.decode(),
1081             os.path.splitext(os.path.basename(filename))[0],
1082             glyph_name])
1083 
1084     _identityToUnicodeCMap = b"""/CIDInit /ProcSet findresource begin
1085 12 dict begin
1086 begincmap
1087 /CIDSystemInfo
1088 << /Registry (Adobe)
1089    /Ordering (UCS)
1090    /Supplement 0
1091 >> def
1092 /CMapName /Adobe-Identity-UCS def
1093 /CMapType 2 def
1094 1 begincodespacerange
1095 <0000> <ffff>
1096 endcodespacerange
1097 %d beginbfrange
1098 %s
1099 endbfrange
1100 endcmap
1101 CMapName currentdict /CMap defineresource pop
1102 end
1103 end"""
1104 
1105     def embedTTF(self, filename, characters):
1106         """Embed the TTF font from the named file into the document."""
1107 
1108         font = get_font(filename)
1109         fonttype = mpl.rcParams['pdf.fonttype']
1110 
1111         def cvt(length, upe=font.units_per_EM, nearest=True):
1112             """Convert font coordinates to PDF glyph coordinates."""
1113             value = length / upe * 1000
1114             if nearest:
1115                 return round(value)
1116             # Best(?) to round away from zero for bounding boxes and the like.
1117             if value < 0:
1118                 return math.floor(value)
1119             else:
1120                 return math.ceil(value)
1121 
1122         def embedTTFType3(font, characters, descriptor):
1123             """The Type 3-specific part of embedding a Truetype font"""
1124             widthsObject = self.reserveObject('font widths')
1125             fontdescObject = self.reserveObject('font descriptor')
1126             fontdictObject = self.reserveObject('font dictionary')
1127             charprocsObject = self.reserveObject('character procs')
1128             differencesArray = []
1129             firstchar, lastchar = 0, 255
1130             bbox = [cvt(x, nearest=False) for x in font.bbox]
1131 
1132             fontdict = {
1133                 'Type': Name('Font'),
1134                 'BaseFont': ps_name,
1135                 'FirstChar': firstchar,
1136                 'LastChar': lastchar,
1137                 'FontDescriptor': fontdescObject,
1138                 'Subtype': Name('Type3'),
1139                 'Name': descriptor['FontName'],
1140                 'FontBBox': bbox,
1141                 'FontMatrix': [.001, 0, 0, .001, 0, 0],
1142                 'CharProcs': charprocsObject,
1143                 'Encoding': {
1144                     'Type': Name('Encoding'),
1145                     'Differences': differencesArray},
1146                 'Widths': widthsObject
1147                 }
1148 
1149             from encodings import cp1252
1150 
1151             # Make the "Widths" array
1152             def get_char_width(charcode):
1153                 s = ord(cp1252.decoding_table[charcode])
1154                 width = font.load_char(
1155                     s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance
1156                 return cvt(width)
1157 
1158             with warnings.catch_warnings():
1159                 # Ignore 'Required glyph missing from current font' warning
1160                 # from ft2font: here we're just building the widths table, but
1161                 # the missing glyphs may not even be used in the actual string.
1162                 warnings.filterwarnings("ignore")
1163                 widths = [get_char_width(charcode)
1164                           for charcode in range(firstchar, lastchar+1)]
1165             descriptor['MaxWidth'] = max(widths)
1166 
1167             # Make the "Differences" array, sort the ccodes < 255 from
1168             # the multi-byte ccodes, and build the whole set of glyph ids
1169             # that we need from this font.
1170             glyph_ids = []
1171             differences = []
1172             multi_byte_chars = set()
1173             for c in characters:
1174                 ccode = c
1175                 gind = font.get_char_index(ccode)
1176                 glyph_ids.append(gind)
1177                 glyph_name = font.get_glyph_name(gind)
1178                 if ccode <= 255:
1179                     differences.append((ccode, glyph_name))
1180                 else:
1181                     multi_byte_chars.add(glyph_name)
1182             differences.sort()
1183 
1184             last_c = -2
1185             for c, name in differences:
1186                 if c != last_c + 1:
1187                     differencesArray.append(c)
1188                 differencesArray.append(Name(name))
1189                 last_c = c
1190 
1191             # Make the charprocs array.
1192             rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)
1193             charprocs = {}
1194             for charname in sorted(rawcharprocs):
1195                 stream = rawcharprocs[charname]
1196                 charprocDict = {}
1197                 # The 2-byte characters are used as XObjects, so they
1198                 # need extra info in their dictionary
1199                 if charname in multi_byte_chars:
1200                     charprocDict = {'Type': Name('XObject'),
1201                                     'Subtype': Name('Form'),
1202                                     'BBox': bbox}
1203                     # Each glyph includes bounding box information,
1204                     # but xpdf and ghostscript can't handle it in a
1205                     # Form XObject (they segfault!!!), so we remove it
1206                     # from the stream here.  It's not needed anyway,
1207                     # since the Form XObject includes it in its BBox
1208                     # value.
1209                     stream = stream[stream.find(b"d1") + 2:]
1210                 charprocObject = self.reserveObject('charProc')
1211                 self.outputStream(charprocObject, stream, extra=charprocDict)
1212 
1213                 # Send the glyphs with ccode > 255 to the XObject dictionary,
1214                 # and the others to the font itself
1215                 if charname in multi_byte_chars:
1216                     name = self._get_xobject_glyph_name(filename, charname)
1217                     self.multi_byte_charprocs[name] = charprocObject
1218                 else:
1219                     charprocs[charname] = charprocObject
1220 
1221             # Write everything out
1222             self.writeObject(fontdictObject, fontdict)
1223             self.writeObject(fontdescObject, descriptor)
1224             self.writeObject(widthsObject, widths)
1225             self.writeObject(charprocsObject, charprocs)
1226 
1227             return fontdictObject
1228 
1229         def embedTTFType42(font, characters, descriptor):
1230             """The Type 42-specific part of embedding a Truetype font"""
1231             fontdescObject = self.reserveObject('font descriptor')
1232             cidFontDictObject = self.reserveObject('CID font dictionary')
1233             type0FontDictObject = self.reserveObject('Type 0 font dictionary')
1234             cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')
1235             fontfileObject = self.reserveObject('font file stream')
1236             wObject = self.reserveObject('Type 0 widths')
1237             toUnicodeMapObject = self.reserveObject('ToUnicode map')
1238 
1239             subset_str = "".join(chr(c) for c in characters)
1240             _log.debug("SUBSET %s characters: %s", filename, subset_str)
1241             fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)
1242             _log.debug(
1243                 "SUBSET %s %d -> %d", filename,
1244                 os.stat(filename).st_size, fontdata.getbuffer().nbytes
1245             )
1246 
1247             # We need this ref for XObjects
1248             full_font = font
1249 
1250             # reload the font object from the subset
1251             # (all the necessary data could probably be obtained directly
1252             # using fontLib.ttLib)
1253             font = FT2Font(fontdata)
1254 
1255             cidFontDict = {
1256                 'Type': Name('Font'),
1257                 'Subtype': Name('CIDFontType2'),
1258                 'BaseFont': ps_name,
1259                 'CIDSystemInfo': {
1260                     'Registry': 'Adobe',
1261                     'Ordering': 'Identity',
1262                     'Supplement': 0},
1263                 'FontDescriptor': fontdescObject,
1264                 'W': wObject,
1265                 'CIDToGIDMap': cidToGidMapObject
1266                 }
1267 
1268             type0FontDict = {
1269                 'Type': Name('Font'),
1270                 'Subtype': Name('Type0'),
1271                 'BaseFont': ps_name,
1272                 'Encoding': Name('Identity-H'),
1273                 'DescendantFonts': [cidFontDictObject],
1274                 'ToUnicode': toUnicodeMapObject
1275                 }
1276 
1277             # Make fontfile stream
1278             descriptor['FontFile2'] = fontfileObject
1279             self.outputStream(
1280                 fontfileObject, fontdata.getvalue(),
1281                 extra={'Length1': fontdata.getbuffer().nbytes})
1282 
1283             # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap
1284             # at the same time
1285             cid_to_gid_map = ['\0'] * 65536
1286             widths = []
1287             max_ccode = 0
1288             for c in characters:
1289                 ccode = c
1290                 gind = font.get_char_index(ccode)
1291                 glyph = font.load_char(ccode,
1292                                        flags=LOAD_NO_SCALE | LOAD_NO_HINTING)
1293                 widths.append((ccode, cvt(glyph.horiAdvance)))
1294                 if ccode < 65536:
1295                     cid_to_gid_map[ccode] = chr(gind)
1296                 max_ccode = max(ccode, max_ccode)
1297             widths.sort()
1298             cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]
1299 
1300             last_ccode = -2
1301             w = []
1302             max_width = 0
1303             unicode_groups = []
1304             for ccode, width in widths:
1305                 if ccode != last_ccode + 1:
1306                     w.append(ccode)
1307                     w.append([width])
1308                     unicode_groups.append([ccode, ccode])
1309                 else:
1310                     w[-1].append(width)
1311                     unicode_groups[-1][1] = ccode
1312                 max_width = max(max_width, width)
1313                 last_ccode = ccode
1314 
1315             unicode_bfrange = []
1316             for start, end in unicode_groups:
1317                 # Ensure the CID map contains only chars from BMP
1318                 if start > 65535:
1319                     continue
1320                 end = min(65535, end)
1321 
1322                 unicode_bfrange.append(
1323                     b"<%04x> <%04x> [%s]" %
1324                     (start, end,
1325                      b" ".join(b"<%04x>" % x for x in range(start, end+1))))
1326             unicode_cmap = (self._identityToUnicodeCMap %
1327                             (len(unicode_groups), b"\n".join(unicode_bfrange)))
1328 
1329             # Add XObjects for unsupported chars
1330             glyph_ids = []
1331             for ccode in characters:
1332                 if not _font_supports_glyph(fonttype, ccode):
1333                     gind = full_font.get_char_index(ccode)
1334                     glyph_ids.append(gind)
1335 
1336             bbox = [cvt(x, nearest=False) for x in full_font.bbox]
1337             rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)
1338             for charname in sorted(rawcharprocs):
1339                 stream = rawcharprocs[charname]
1340                 charprocDict = {'Type': Name('XObject'),
1341                                 'Subtype': Name('Form'),
1342                                 'BBox': bbox}
1343                 # Each glyph includes bounding box information,
1344                 # but xpdf and ghostscript can't handle it in a
1345                 # Form XObject (they segfault!!!), so we remove it
1346                 # from the stream here.  It's not needed anyway,
1347                 # since the Form XObject includes it in its BBox
1348                 # value.
1349                 stream = stream[stream.find(b"d1") + 2:]
1350                 charprocObject = self.reserveObject('charProc')
1351                 self.outputStream(charprocObject, stream, extra=charprocDict)
1352 
1353                 name = self._get_xobject_glyph_name(filename, charname)
1354                 self.multi_byte_charprocs[name] = charprocObject
1355 
1356             # CIDToGIDMap stream
1357             cid_to_gid_map = "".join(cid_to_gid_map).encode("utf-16be")
1358             self.outputStream(cidToGidMapObject, cid_to_gid_map)
1359 
1360             # ToUnicode CMap
1361             self.outputStream(toUnicodeMapObject, unicode_cmap)
1362 
1363             descriptor['MaxWidth'] = max_width
1364 
1365             # Write everything out
1366             self.writeObject(cidFontDictObject, cidFontDict)
1367             self.writeObject(type0FontDictObject, type0FontDict)
1368             self.writeObject(fontdescObject, descriptor)
1369             self.writeObject(wObject, w)
1370 
1371             return type0FontDictObject
1372 
1373         # Beginning of main embedTTF function...
1374 
1375         ps_name = self._get_subsetted_psname(
1376             font.postscript_name,
1377             font.get_charmap()
1378         )
1379         ps_name = ps_name.encode('ascii', 'replace')
1380         ps_name = Name(ps_name)
1381         pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}
1382         post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}
1383         ff = font.face_flags
1384         sf = font.style_flags
1385 
1386         flags = 0
1387         symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')
1388         if ff & FIXED_WIDTH:
1389             flags |= 1 << 0
1390         if 0:  # TODO: serif
1391             flags |= 1 << 1
1392         if symbolic:
1393             flags |= 1 << 2
1394         else:
1395             flags |= 1 << 5
1396         if sf & ITALIC:
1397             flags |= 1 << 6
1398         if 0:  # TODO: all caps
1399             flags |= 1 << 16
1400         if 0:  # TODO: small caps
1401             flags |= 1 << 17
1402         if 0:  # TODO: force bold
1403             flags |= 1 << 18
1404 
1405         descriptor = {
1406             'Type': Name('FontDescriptor'),
1407             'FontName': ps_name,
1408             'Flags': flags,
1409             'FontBBox': [cvt(x, nearest=False) for x in font.bbox],
1410             'Ascent': cvt(font.ascender, nearest=False),
1411             'Descent': cvt(font.descender, nearest=False),
1412             'CapHeight': cvt(pclt['capHeight'], nearest=False),
1413             'XHeight': cvt(pclt['xHeight']),
1414             'ItalicAngle': post['italicAngle'][1],  # ???
1415             'StemV': 0  # ???
1416             }
1417 
1418         if fonttype == 3:
1419             return embedTTFType3(font, characters, descriptor)
1420         elif fonttype == 42:
1421             return embedTTFType42(font, characters, descriptor)
1422 
1423     def alphaState(self, alpha):
1424         """Return name of an ExtGState that sets alpha to the given value."""
1425 
1426         state = self.alphaStates.get(alpha, None)
1427         if state is not None:
1428             return state[0]
1429 
1430         name = next(self._alpha_state_seq)
1431         self.alphaStates[alpha] = \
1432             (name, {'Type': Name('ExtGState'),
1433                     'CA': alpha[0], 'ca': alpha[1]})
1434         return name
1435 
1436     def _soft_mask_state(self, smask):
1437         """
1438         Return an ExtGState that sets the soft mask to the given shading.
1439 
1440         Parameters
1441         ----------
1442         smask : Reference
1443             Reference to a shading in DeviceGray color space, whose luminosity
1444             is to be used as the alpha channel.
1445 
1446         Returns
1447         -------
1448         Name
1449         """
1450 
1451         state = self._soft_mask_states.get(smask, None)
1452         if state is not None:
1453             return state[0]
1454 
1455         name = next(self._soft_mask_seq)
1456         groupOb = self.reserveObject('transparency group for soft mask')
1457         self._soft_mask_states[smask] = (
1458             name,
1459             {
1460                 'Type': Name('ExtGState'),
1461                 'AIS': False,
1462                 'SMask': {
1463                     'Type': Name('Mask'),
1464                     'S': Name('Luminosity'),
1465                     'BC': [1],
1466                     'G': groupOb
1467                 }
1468             }
1469         )
1470         self._soft_mask_groups.append((
1471             groupOb,
1472             {
1473                 'Type': Name('XObject'),
1474                 'Subtype': Name('Form'),
1475                 'FormType': 1,
1476                 'Group': {
1477                     'S': Name('Transparency'),
1478                     'CS': Name('DeviceGray')
1479                 },
1480                 'Matrix': [1, 0, 0, 1, 0, 0],
1481                 'Resources': {'Shading': {'S': smask}},
1482                 'BBox': [0, 0, 1, 1]
1483             },
1484             [Name('S'), Op.shading]
1485         ))
1486         return name
1487 
1488     def writeExtGSTates(self):
1489         self.writeObject(
1490             self._extGStateObject,
1491             dict([
1492                 *self.alphaStates.values(),
1493                 *self._soft_mask_states.values()
1494             ])
1495         )
1496 
1497     def _write_soft_mask_groups(self):
1498         for ob, attributes, content in self._soft_mask_groups:
1499             self.beginStream(ob.id, None, attributes)
1500             self.output(*content)
1501             self.endStream()
1502 
1503     def hatchPattern(self, hatch_style):
1504         # The colors may come in as numpy arrays, which aren't hashable
1505         if hatch_style is not None:
1506             edge, face, hatch = hatch_style
1507             if edge is not None:
1508                 edge = tuple(edge)
1509             if face is not None:
1510                 face = tuple(face)
1511             hatch_style = (edge, face, hatch)
1512 
1513         pattern = self.hatchPatterns.get(hatch_style, None)
1514         if pattern is not None:
1515             return pattern
1516 
1517         name = next(self._hatch_pattern_seq)
1518         self.hatchPatterns[hatch_style] = name
1519         return name
1520 
1521     def writeHatches(self):
1522         hatchDict = dict()
1523         sidelen = 72.0
1524         for hatch_style, name in self.hatchPatterns.items():
1525             ob = self.reserveObject('hatch pattern')
1526             hatchDict[name] = ob
1527             res = {'Procsets':
1528                    [Name(x) for x in "PDF Text ImageB ImageC ImageI".split()]}
1529             self.beginStream(
1530                 ob.id, None,
1531                 {'Type': Name('Pattern'),
1532                  'PatternType': 1, 'PaintType': 1, 'TilingType': 1,
1533                  'BBox': [0, 0, sidelen, sidelen],
1534                  'XStep': sidelen, 'YStep': sidelen,
1535                  'Resources': res,
1536                  # Change origin to match Agg at top-left.
1537                  'Matrix': [1, 0, 0, 1, 0, self.height * 72]})
1538 
1539             stroke_rgb, fill_rgb, hatch = hatch_style
1540             self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],
1541                         Op.setrgb_stroke)
1542             if fill_rgb is not None:
1543                 self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],
1544                             Op.setrgb_nonstroke,
1545                             0, 0, sidelen, sidelen, Op.rectangle,
1546                             Op.fill)
1547 
1548             self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)
1549 
1550             self.output(*self.pathOperations(
1551                 Path.hatch(hatch),
1552                 Affine2D().scale(sidelen),
1553                 simplify=False))
1554             self.output(Op.fill_stroke)
1555 
1556             self.endStream()
1557         self.writeObject(self.hatchObject, hatchDict)
1558 
1559     def addGouraudTriangles(self, points, colors):
1560         """
1561         Add a Gouraud triangle shading.
1562 
1563         Parameters
1564         ----------
1565         points : np.ndarray
1566             Triangle vertices, shape (n, 3, 2)
1567             where n = number of triangles, 3 = vertices, 2 = x, y.
1568         colors : np.ndarray
1569             Vertex colors, shape (n, 3, 1) or (n, 3, 4)
1570             as with points, but last dimension is either (gray,)
1571             or (r, g, b, alpha).
1572 
1573         Returns
1574         -------
1575         Name, Reference
1576         """
1577         name = Name('GT%d' % len(self.gouraudTriangles))
1578         ob = self.reserveObject(f'Gouraud triangle {name}')
1579         self.gouraudTriangles.append((name, ob, points, colors))
1580         return name, ob
1581 
1582     def writeGouraudTriangles(self):
1583         gouraudDict = dict()
1584         for name, ob, points, colors in self.gouraudTriangles:
1585             gouraudDict[name] = ob
1586             shape = points.shape
1587             flat_points = points.reshape((shape[0] * shape[1], 2))
1588             colordim = colors.shape[2]
1589             assert colordim in (1, 4)
1590             flat_colors = colors.reshape((shape[0] * shape[1], colordim))
1591             if colordim == 4:
1592                 # strip the alpha channel
1593                 colordim = 3
1594             points_min = np.min(flat_points, axis=0) - (1 << 8)
1595             points_max = np.max(flat_points, axis=0) + (1 << 8)
1596             factor = 0xffffffff / (points_max - points_min)
1597 
1598             self.beginStream(
1599                 ob.id, None,
1600                 {'ShadingType': 4,
1601                  'BitsPerCoordinate': 32,
1602                  'BitsPerComponent': 8,
1603                  'BitsPerFlag': 8,
1604                  'ColorSpace': Name(
1605                      'DeviceRGB' if colordim == 3 else 'DeviceGray'
1606                  ),
1607                  'AntiAlias': False,
1608                  'Decode': ([points_min[0], points_max[0],
1609                              points_min[1], points_max[1]]
1610                             + [0, 1] * colordim),
1611                  })
1612 
1613             streamarr = np.empty(
1614                 (shape[0] * shape[1],),
1615                 dtype=[('flags', 'u1'),
1616                        ('points', '>u4', (2,)),
1617                        ('colors', 'u1', (colordim,))])
1618             streamarr['flags'] = 0
1619             streamarr['points'] = (flat_points - points_min) * factor
1620             streamarr['colors'] = flat_colors[:, :colordim] * 255.0
1621 
1622             self.write(streamarr.tobytes())
1623             self.endStream()
1624         self.writeObject(self.gouraudObject, gouraudDict)
1625 
1626     def imageObject(self, image):
1627         """Return name of an image XObject representing the given image."""
1628 
1629         entry = self._images.get(id(image), None)
1630         if entry is not None:
1631             return entry[1]
1632 
1633         name = next(self._image_seq)
1634         ob = self.reserveObject(f'image {name}')
1635         self._images[id(image)] = (image, name, ob)
1636         return name
1637 
1638     def _unpack(self, im):
1639         """
1640         Unpack image array *im* into ``(data, alpha)``, which have shape
1641         ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or
1642         alpha), except that alpha is None if the image is fully opaque.
1643         """
1644         im = im[::-1]
1645         if im.ndim == 2:
1646             return im, None
1647         else:
1648             rgb = im[:, :, :3]
1649             rgb = np.array(rgb, order='C')
1650             # PDF needs a separate alpha image
1651             if im.shape[2] == 4:
1652                 alpha = im[:, :, 3][..., None]
1653                 if np.all(alpha == 255):
1654                     alpha = None
1655                 else:
1656                     alpha = np.array(alpha, order='C')
1657             else:
1658                 alpha = None
1659             return rgb, alpha
1660 
1661     def _writePng(self, img):
1662         """
1663         Write the image *img* into the pdf file using png
1664         predictors with Flate compression.
1665         """
1666         buffer = BytesIO()
1667         img.save(buffer, format="png")
1668         buffer.seek(8)
1669         png_data = b''
1670         bit_depth = palette = None
1671         while True:
1672             length, type = struct.unpack(b'!L4s', buffer.read(8))
1673             if type in [b'IHDR', b'PLTE', b'IDAT']:
1674                 data = buffer.read(length)
1675                 if len(data) != length:
1676                     raise RuntimeError("truncated data")
1677                 if type == b'IHDR':
1678                     bit_depth = int(data[8])
1679                 elif type == b'PLTE':
1680                     palette = data
1681                 elif type == b'IDAT':
1682                     png_data += data
1683             elif type == b'IEND':
1684                 break
1685             else:
1686                 buffer.seek(length, 1)
1687             buffer.seek(4, 1)   # skip CRC
1688         return png_data, bit_depth, palette
1689 
1690     def _writeImg(self, data, id, smask=None):
1691         """
1692         Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or
1693         ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask
1694         (alpha channel) *smask*, which should be either None or a ``(height,
1695         width, 1)`` array.
1696         """
1697         height, width, color_channels = data.shape
1698         obj = {'Type': Name('XObject'),
1699                'Subtype': Name('Image'),
1700                'Width': width,
1701                'Height': height,
1702                'ColorSpace': Name({1: 'DeviceGray',
1703                                    3: 'DeviceRGB'}[color_channels]),
1704                'BitsPerComponent': 8}
1705         if smask:
1706             obj['SMask'] = smask
1707         if mpl.rcParams['pdf.compression']:
1708             if data.shape[-1] == 1:
1709                 data = data.squeeze(axis=-1)
1710             img = Image.fromarray(data)
1711             img_colors = img.getcolors(maxcolors=256)
1712             if color_channels == 3 and img_colors is not None:
1713                 # Convert to indexed color if there are 256 colors or fewer
1714                 # This can significantly reduce the file size
1715                 num_colors = len(img_colors)
1716                 # These constants were converted to IntEnums and deprecated in
1717                 # Pillow 9.2
1718                 dither = getattr(Image, 'Dither', Image).NONE
1719                 pmode = getattr(Image, 'Palette', Image).ADAPTIVE
1720                 img = img.convert(
1721                     mode='P', dither=dither, palette=pmode, colors=num_colors
1722                 )
1723                 png_data, bit_depth, palette = self._writePng(img)
1724                 if bit_depth is None or palette is None:
1725                     raise RuntimeError("invalid PNG header")
1726                 palette = palette[:num_colors * 3]  # Trim padding
1727                 obj['ColorSpace'] = Verbatim(
1728                     b'[/Indexed /DeviceRGB %d %s]'
1729                     % (num_colors - 1, pdfRepr(palette)))
1730                 obj['BitsPerComponent'] = bit_depth
1731                 color_channels = 1
1732             else:
1733                 png_data, _, _ = self._writePng(img)
1734             png = {'Predictor': 10, 'Colors': color_channels, 'Columns': width}
1735         else:
1736             png = None
1737         self.beginStream(
1738             id,
1739             self.reserveObject('length of image stream'),
1740             obj,
1741             png=png
1742             )
1743         if png:
1744             self.currentstream.write(png_data)
1745         else:
1746             self.currentstream.write(data.tobytes())
1747         self.endStream()
1748 
1749     def writeImages(self):
1750         for img, name, ob in self._images.values():
1751             data, adata = self._unpack(img)
1752             if adata is not None:
1753                 smaskObject = self.reserveObject("smask")
1754                 self._writeImg(adata, smaskObject.id)
1755             else:
1756                 smaskObject = None
1757             self._writeImg(data, ob.id, smaskObject)
1758 
1759     def markerObject(self, path, trans, fill, stroke, lw, joinstyle,
1760                      capstyle):
1761         """Return name of a marker XObject representing the given path."""
1762         # self.markers used by markerObject, writeMarkers, close:
1763         # mapping from (path operations, fill?, stroke?) to
1764         #   [name, object reference, bounding box, linewidth]
1765         # This enables different draw_markers calls to share the XObject
1766         # if the gc is sufficiently similar: colors etc can vary, but
1767         # the choices of whether to fill and whether to stroke cannot.
1768         # We need a bounding box enclosing all of the XObject path,
1769         # but since line width may vary, we store the maximum of all
1770         # occurring line widths in self.markers.
1771         # close() is somewhat tightly coupled in that it expects the
1772         # first two components of each value in self.markers to be the
1773         # name and object reference.
1774         pathops = self.pathOperations(path, trans, simplify=False)
1775         key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)
1776         result = self.markers.get(key)
1777         if result is None:
1778             name = Name('M%d' % len(self.markers))
1779             ob = self.reserveObject('marker %d' % len(self.markers))
1780             bbox = path.get_extents(trans)
1781             self.markers[key] = [name, ob, bbox, lw]
1782         else:
1783             if result[-1] < lw:
1784                 result[-1] = lw
1785             name = result[0]
1786         return name
1787 
1788     def writeMarkers(self):
1789         for ((pathops, fill, stroke, joinstyle, capstyle),
1790              (name, ob, bbox, lw)) in self.markers.items():
1791             # bbox wraps the exact limits of the control points, so half a line
1792             # will appear outside it. If the join style is miter and the line
1793             # is not parallel to the edge, then the line will extend even
1794             # further. From the PDF specification, Section 8.4.3.5, the miter
1795             # limit is miterLength / lineWidth and from Table 52, the default
1796             # is 10. With half the miter length outside, that works out to the
1797             # following padding:
1798             bbox = bbox.padded(lw * 5)
1799             self.beginStream(
1800                 ob.id, None,
1801                 {'Type': Name('XObject'), 'Subtype': Name('Form'),
1802                  'BBox': list(bbox.extents)})
1803             self.output(GraphicsContextPdf.joinstyles[joinstyle],
1804                         Op.setlinejoin)
1805             self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)
1806             self.output(*pathops)
1807             self.output(Op.paint_path(fill, stroke))
1808             self.endStream()
1809 
1810     def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):
1811         name = Name('P%d' % len(self.paths))
1812         ob = self.reserveObject('path %d' % len(self.paths))
1813         self.paths.append(
1814             (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),
1815              padding, filled, stroked))
1816         return name
1817 
1818     def writePathCollectionTemplates(self):
1819         for (name, path, trans, ob, joinstyle, capstyle, padding, filled,
1820              stroked) in self.paths:
1821             pathops = self.pathOperations(path, trans, simplify=False)
1822             bbox = path.get_extents(trans)
1823             if not np.all(np.isfinite(bbox.extents)):
1824                 extents = [0, 0, 0, 0]
1825             else:
1826                 bbox = bbox.padded(padding)
1827                 extents = list(bbox.extents)
1828             self.beginStream(
1829                 ob.id, None,
1830                 {'Type': Name('XObject'), 'Subtype': Name('Form'),
1831                  'BBox': extents})
1832             self.output(GraphicsContextPdf.joinstyles[joinstyle],
1833                         Op.setlinejoin)
1834             self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)
1835             self.output(*pathops)
1836             self.output(Op.paint_path(filled, stroked))
1837             self.endStream()
1838 
1839     @staticmethod
1840     def pathOperations(path, transform, clip=None, simplify=None, sketch=None):
1841         return [Verbatim(_path.convert_to_string(
1842             path, transform, clip, simplify, sketch,
1843             6,
1844             [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,
1845              Op.closepath.value],
1846             True))]
1847 
1848     def writePath(self, path, transform, clip=False, sketch=None):
1849         if clip:
1850             clip = (0.0, 0.0, self.width * 72, self.height * 72)
1851             simplify = path.should_simplify
1852         else:
1853             clip = None
1854             simplify = False
1855         cmds = self.pathOperations(path, transform, clip, simplify=simplify,
1856                                    sketch=sketch)
1857         self.output(*cmds)
1858 
1859     def reserveObject(self, name=''):
1860         """
1861         Reserve an ID for an indirect object.
1862 
1863         The name is used for debugging in case we forget to print out
1864         the object with writeObject.
1865         """
1866         id = next(self._object_seq)
1867         self.xrefTable.append([None, 0, name])
1868         return Reference(id)
1869 
1870     def recordXref(self, id):
1871         self.xrefTable[id][0] = self.fh.tell() - self.tell_base
1872 
1873     def writeObject(self, object, contents):
1874         self.recordXref(object.id)
1875         object.write(contents, self)
1876 
1877     def writeXref(self):
1878         """Write out the xref table."""
1879         self.startxref = self.fh.tell() - self.tell_base
1880         self.write(b"xref\n0 %d\n" % len(self.xrefTable))
1881         for i, (offset, generation, name) in enumerate(self.xrefTable):
1882             if offset is None:
1883                 raise AssertionError(
1884                     'No offset for object %d (%s)' % (i, name))
1885             else:
1886                 key = b"f" if name == 'the zero object' else b"n"
1887                 text = b"%010d %05d %b \n" % (offset, generation, key)
1888                 self.write(text)
1889 
1890     def writeInfoDict(self):
1891         """Write out the info dictionary, checking it for good form"""
1892 
1893         self.infoObject = self.reserveObject('info')
1894         self.writeObject(self.infoObject, self.infoDict)
1895 
1896     def writeTrailer(self):
1897         """Write out the PDF trailer."""
1898 
1899         self.write(b"trailer\n")
1900         self.write(pdfRepr(
1901             {'Size': len(self.xrefTable),
1902              'Root': self.rootObject,
1903              'Info': self.infoObject}))
1904         # Could add 'ID'
1905         self.write(b"\nstartxref\n%d\n%%%%EOF\n" % self.startxref)
1906 
1907 
1908 class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):
1909 
1910     _afm_font_dir = cbook._get_data_path("fonts/pdfcorefonts")
1911     _use_afm_rc_name = "pdf.use14corefonts"
1912 
1913     def __init__(self, file, image_dpi, height, width):
1914         super().__init__(width, height)
1915         self.file = file
1916         self.gc = self.new_gc()
1917         self.image_dpi = image_dpi
1918 
1919     def finalize(self):
1920         self.file.output(*self.gc.finalize())
1921 
1922     def check_gc(self, gc, fillcolor=None):
1923         orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))
1924         gc._fillcolor = fillcolor
1925 
1926         orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))
1927 
1928         if gc.get_rgb() is None:
1929             # It should not matter what color here since linewidth should be
1930             # 0 unless affected by global settings in rcParams, hence setting
1931             # zero alpha just in case.
1932             gc.set_foreground((0, 0, 0, 0), isRGBA=True)
1933 
1934         if gc._forced_alpha:
1935             gc._effective_alphas = (gc._alpha, gc._alpha)
1936         elif fillcolor is None or len(fillcolor) < 4:
1937             gc._effective_alphas = (gc._rgb[3], 1.0)
1938         else:
1939             gc._effective_alphas = (gc._rgb[3], fillcolor[3])
1940 
1941         delta = self.gc.delta(gc)
1942         if delta:
1943             self.file.output(*delta)
1944 
1945         # Restore gc to avoid unwanted side effects
1946         gc._fillcolor = orig_fill
1947         gc._effective_alphas = orig_alphas
1948 
1949     def get_image_magnification(self):
1950         return self.image_dpi/72.0
1951 
1952     def draw_image(self, gc, x, y, im, transform=None):
1953         # docstring inherited
1954 
1955         h, w = im.shape[:2]
1956         if w == 0 or h == 0:
1957             return
1958 
1959         if transform is None:
1960             # If there's no transform, alpha has already been applied
1961             gc.set_alpha(1.0)
1962 
1963         self.check_gc(gc)
1964 
1965         w = 72.0 * w / self.image_dpi
1966         h = 72.0 * h / self.image_dpi
1967 
1968         imob = self.file.imageObject(im)
1969 
1970         if transform is None:
1971             self.file.output(Op.gsave,
1972                              w, 0, 0, h, x, y, Op.concat_matrix,
1973                              imob, Op.use_xobject, Op.grestore)
1974         else:
1975             tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()
1976 
1977             self.file.output(Op.gsave,
1978                              1, 0, 0, 1, x, y, Op.concat_matrix,
1979                              tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,
1980                              imob, Op.use_xobject, Op.grestore)
1981 
1982     def draw_path(self, gc, path, transform, rgbFace=None):
1983         # docstring inherited
1984         self.check_gc(gc, rgbFace)
1985         self.file.writePath(
1986             path, transform,
1987             rgbFace is None and gc.get_hatch_path() is None,
1988             gc.get_sketch_params())
1989         self.file.output(self.gc.paint())
1990 
1991     def draw_path_collection(self, gc, master_transform, paths, all_transforms,
1992                              offsets, offsetTrans, facecolors, edgecolors,
1993                              linewidths, linestyles, antialiaseds, urls,
1994                              offset_position):
1995         # We can only reuse the objects if the presence of fill and
1996         # stroke (and the amount of alpha for each) is the same for
1997         # all of them
1998         can_do_optimization = True
1999         facecolors = np.asarray(facecolors)
2000         edgecolors = np.asarray(edgecolors)
2001 
2002         if not len(facecolors):
2003             filled = False
2004             can_do_optimization = not gc.get_hatch()
2005         else:
2006             if np.all(facecolors[:, 3] == facecolors[0, 3]):
2007                 filled = facecolors[0, 3] != 0.0
2008             else:
2009                 can_do_optimization = False
2010 
2011         if not len(edgecolors):
2012             stroked = False
2013         else:
2014             if np.all(np.asarray(linewidths) == 0.0):
2015                 stroked = False
2016             elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):
2017                 stroked = edgecolors[0, 3] != 0.0
2018             else:
2019                 can_do_optimization = False
2020 
2021         # Is the optimization worth it? Rough calculation:
2022         # cost of emitting a path in-line is len_path * uses_per_path
2023         # cost of XObject is len_path + 5 for the definition,
2024         #    uses_per_path for the uses
2025         len_path = len(paths[0].vertices) if len(paths) > 0 else 0
2026         uses_per_path = self._iter_collection_uses_per_path(
2027             paths, all_transforms, offsets, facecolors, edgecolors)
2028         should_do_optimization = \
2029             len_path + uses_per_path + 5 < len_path * uses_per_path
2030 
2031         if (not can_do_optimization) or (not should_do_optimization):
2032             return RendererBase.draw_path_collection(
2033                 self, gc, master_transform, paths, all_transforms,
2034                 offsets, offsetTrans, facecolors, edgecolors,
2035                 linewidths, linestyles, antialiaseds, urls,
2036                 offset_position)
2037 
2038         padding = np.max(linewidths)
2039         path_codes = []
2040         for i, (path, transform) in enumerate(self._iter_collection_raw_paths(
2041                 master_transform, paths, all_transforms)):
2042             name = self.file.pathCollectionObject(
2043                 gc, path, transform, padding, filled, stroked)
2044             path_codes.append(name)
2045 
2046         output = self.file.output
2047         output(*self.gc.push())
2048         lastx, lasty = 0, 0
2049         for xo, yo, path_id, gc0, rgbFace in self._iter_collection(
2050                 gc, master_transform, all_transforms, path_codes, offsets,
2051                 offsetTrans, facecolors, edgecolors, linewidths, linestyles,
2052                 antialiaseds, urls, offset_position):
2053 
2054             self.check_gc(gc0, rgbFace)
2055             dx, dy = xo - lastx, yo - lasty
2056             output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,
2057                    Op.use_xobject)
2058             lastx, lasty = xo, yo
2059         output(*self.gc.pop())
2060 
2061     def draw_markers(self, gc, marker_path, marker_trans, path, trans,
2062                      rgbFace=None):
2063         # docstring inherited
2064 
2065         # Same logic as in draw_path_collection
2066         len_marker_path = len(marker_path)
2067         uses = len(path)
2068         if len_marker_path * uses < len_marker_path + uses + 5:
2069             RendererBase.draw_markers(self, gc, marker_path, marker_trans,
2070                                       path, trans, rgbFace)
2071             return
2072 
2073         self.check_gc(gc, rgbFace)
2074         fill = gc.fill(rgbFace)
2075         stroke = gc.stroke()
2076 
2077         output = self.file.output
2078         marker = self.file.markerObject(
2079             marker_path, marker_trans, fill, stroke, self.gc._linewidth,
2080             gc.get_joinstyle(), gc.get_capstyle())
2081 
2082         output(Op.gsave)
2083         lastx, lasty = 0, 0
2084         for vertices, code in path.iter_segments(
2085                 trans,
2086                 clip=(0, 0, self.file.width*72, self.file.height*72),
2087                 simplify=False):
2088             if len(vertices):
2089                 x, y = vertices[-2:]
2090                 if not (0 <= x <= self.file.width * 72
2091                         and 0 <= y <= self.file.height * 72):
2092                     continue
2093                 dx, dy = x - lastx, y - lasty
2094                 output(1, 0, 0, 1, dx, dy, Op.concat_matrix,
2095                        marker, Op.use_xobject)
2096                 lastx, lasty = x, y
2097         output(Op.grestore)
2098 
2099     def draw_gouraud_triangle(self, gc, points, colors, trans):
2100         self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),
2101                                     colors.reshape((1, 3, 4)), trans)
2102 
2103     def draw_gouraud_triangles(self, gc, points, colors, trans):
2104         assert len(points) == len(colors)
2105         if len(points) == 0:
2106             return
2107         assert points.ndim == 3
2108         assert points.shape[1] == 3
2109         assert points.shape[2] == 2
2110         assert colors.ndim == 3
2111         assert colors.shape[1] == 3
2112         assert colors.shape[2] in (1, 4)
2113 
2114         shape = points.shape
2115         points = points.reshape((shape[0] * shape[1], 2))
2116         tpoints = trans.transform(points)
2117         tpoints = tpoints.reshape(shape)
2118         name, _ = self.file.addGouraudTriangles(tpoints, colors)
2119         output = self.file.output
2120 
2121         if colors.shape[2] == 1:
2122             # grayscale
2123             gc.set_alpha(1.0)
2124             self.check_gc(gc)
2125             output(name, Op.shading)
2126             return
2127 
2128         alpha = colors[0, 0, 3]
2129         if np.allclose(alpha, colors[:, :, 3]):
2130             # single alpha value
2131             gc.set_alpha(alpha)
2132             self.check_gc(gc)
2133             output(name, Op.shading)
2134         else:
2135             # varying alpha: use a soft mask
2136             alpha = colors[:, :, 3][:, :, None]
2137             _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)
2138             gstate = self.file._soft_mask_state(smask_ob)
2139             output(Op.gsave, gstate, Op.setgstate,
2140                    name, Op.shading,
2141                    Op.grestore)
2142 
2143     def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):
2144         if angle == oldangle == 0:
2145             self.file.output(x - oldx, y - oldy, Op.textpos)
2146         else:
2147             angle = math.radians(angle)
2148             self.file.output(math.cos(angle), math.sin(angle),
2149                              -math.sin(angle), math.cos(angle),
2150                              x, y, Op.textmatrix)
2151             self.file.output(0, 0, Op.textpos)
2152 
2153     def draw_mathtext(self, gc, x, y, s, prop, angle):
2154         # TODO: fix positioning and encoding
2155         width, height, descent, glyphs, rects = \
2156             self._text2path.mathtext_parser.parse(s, 72, prop)
2157 
2158         if gc.get_url() is not None:
2159             link_annotation = {
2160                 'Type': Name('Annot'),
2161                 'Subtype': Name('Link'),
2162                 'Rect': (x, y, x + width, y + height),
2163                 'Border': [0, 0, 0],
2164                 'A': {
2165                     'S': Name('URI'),
2166                     'URI': gc.get_url(),
2167                 },
2168             }
2169             self.file._annotations[-1][1].append(link_annotation)
2170 
2171         fonttype = mpl.rcParams['pdf.fonttype']
2172 
2173         # Set up a global transformation matrix for the whole math expression
2174         a = math.radians(angle)
2175         self.file.output(Op.gsave)
2176         self.file.output(math.cos(a), math.sin(a),
2177                          -math.sin(a), math.cos(a),
2178                          x, y, Op.concat_matrix)
2179 
2180         self.check_gc(gc, gc._rgb)
2181         prev_font = None, None
2182         oldx, oldy = 0, 0
2183         unsupported_chars = []
2184 
2185         self.file.output(Op.begin_text)
2186         for font, fontsize, num, ox, oy in glyphs:
2187             self.file._character_tracker.track_glyph(font, num)
2188             fontname = font.fname
2189             if not _font_supports_glyph(fonttype, num):
2190                 # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in
2191                 # Type 42) must be emitted separately (below).
2192                 unsupported_chars.append((font, fontsize, ox, oy, num))
2193             else:
2194                 self._setup_textpos(ox, oy, 0, oldx, oldy)
2195                 oldx, oldy = ox, oy
2196                 if (fontname, fontsize) != prev_font:
2197                     self.file.output(self.file.fontName(fontname), fontsize,
2198                                      Op.selectfont)
2199                     prev_font = fontname, fontsize
2200                 self.file.output(self.encode_string(chr(num), fonttype),
2201                                  Op.show)
2202         self.file.output(Op.end_text)
2203 
2204         for font, fontsize, ox, oy, num in unsupported_chars:
2205             self._draw_xobject_glyph(
2206                 font, fontsize, font.get_char_index(num), ox, oy)
2207 
2208         # Draw any horizontal lines in the math layout
2209         for ox, oy, width, height in rects:
2210             self.file.output(Op.gsave, ox, oy, width, height,
2211                              Op.rectangle, Op.fill, Op.grestore)
2212 
2213         # Pop off the global transformation
2214         self.file.output(Op.grestore)
2215 
2216     def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):
2217         # docstring inherited
2218         texmanager = self.get_texmanager()
2219         fontsize = prop.get_size_in_points()
2220         dvifile = texmanager.make_dvi(s, fontsize)
2221         with dviread.Dvi(dvifile, 72) as dvi:
2222             page, = dvi
2223 
2224         if gc.get_url() is not None:
2225             link_annotation = {
2226                 'Type': Name('Annot'),
2227                 'Subtype': Name('Link'),
2228                 'Rect': (x, y, x + page.width, y + page.height),
2229                 'Border': [0, 0, 0],
2230                 'A': {
2231                     'S': Name('URI'),
2232                     'URI': gc.get_url(),
2233                 },
2234             }
2235             self.file._annotations[-1][1].append(link_annotation)
2236 
2237         # Gather font information and do some setup for combining
2238         # characters into strings. The variable seq will contain a
2239         # sequence of font and text entries. A font entry is a list
2240         # ['font', name, size] where name is a Name object for the
2241         # font. A text entry is ['text', x, y, glyphs, x+w] where x
2242         # and y are the starting coordinates, w is the width, and
2243         # glyphs is a list; in this phase it will always contain just
2244         # one one-character string, but later it may have longer
2245         # strings interspersed with kern amounts.
2246         oldfont, seq = None, []
2247         for x1, y1, dvifont, glyph, width in page.text:
2248             if dvifont != oldfont:
2249                 pdfname = self.file.dviFontName(dvifont)
2250                 seq += [['font', pdfname, dvifont.size]]
2251                 oldfont = dvifont
2252             seq += [['text', x1, y1, [bytes([glyph])], x1+width]]
2253 
2254         # Find consecutive text strings with constant y coordinate and
2255         # combine into a sequence of strings and kerns, or just one
2256         # string (if any kerns would be less than 0.1 points).
2257         i, curx, fontsize = 0, 0, None
2258         while i < len(seq)-1:
2259             elt, nxt = seq[i:i+2]
2260             if elt[0] == 'font':
2261                 fontsize = elt[2]
2262             elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:
2263                 offset = elt[4] - nxt[1]
2264                 if abs(offset) < 0.1:
2265                     elt[3][-1] += nxt[3][0]
2266                     elt[4] += nxt[4]-nxt[1]
2267                 else:
2268                     elt[3] += [offset*1000.0/fontsize, nxt[3][0]]
2269                     elt[4] = nxt[4]
2270                 del seq[i+1]
2271                 continue
2272             i += 1
2273 
2274         # Create a transform to map the dvi contents to the canvas.
2275         mytrans = Affine2D().rotate_deg(angle).translate(x, y)
2276 
2277         # Output the text.
2278         self.check_gc(gc, gc._rgb)
2279         self.file.output(Op.begin_text)
2280         curx, cury, oldx, oldy = 0, 0, 0, 0
2281         for elt in seq:
2282             if elt[0] == 'font':
2283                 self.file.output(elt[1], elt[2], Op.selectfont)
2284             elif elt[0] == 'text':
2285                 curx, cury = mytrans.transform((elt[1], elt[2]))
2286                 self._setup_textpos(curx, cury, angle, oldx, oldy)
2287                 oldx, oldy = curx, cury
2288                 if len(elt[3]) == 1:
2289                     self.file.output(elt[3][0], Op.show)
2290                 else:
2291                     self.file.output(elt[3], Op.showkern)
2292             else:
2293                 assert False
2294         self.file.output(Op.end_text)
2295 
2296         # Then output the boxes (e.g., variable-length lines of square
2297         # roots).
2298         boxgc = self.new_gc()
2299         boxgc.copy_properties(gc)
2300         boxgc.set_linewidth(0)
2301         pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,
2302                    Path.CLOSEPOLY]
2303         for x1, y1, h, w in page.boxes:
2304             path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],
2305                          [0, 0]], pathops)
2306             self.draw_path(boxgc, path, mytrans, gc._rgb)
2307 
2308     def encode_string(self, s, fonttype):
2309         if fonttype in (1, 3):
2310             return s.encode('cp1252', 'replace')
2311         return s.encode('utf-16be', 'replace')
2312 
2313     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):
2314         # docstring inherited
2315 
2316         # TODO: combine consecutive texts into one BT/ET delimited section
2317 
2318         self.check_gc(gc, gc._rgb)
2319         if ismath:
2320             return self.draw_mathtext(gc, x, y, s, prop, angle)
2321 
2322         fontsize = prop.get_size_in_points()
2323 
2324         if mpl.rcParams['pdf.use14corefonts']:
2325             font = self._get_font_afm(prop)
2326             fonttype = 1
2327         else:
2328             font = self._get_font_ttf(prop)
2329             self.file._character_tracker.track(font, s)
2330             fonttype = mpl.rcParams['pdf.fonttype']
2331 
2332         if gc.get_url() is not None:
2333             font.set_text(s)
2334             width, height = font.get_width_height()
2335             link_annotation = {
2336                 'Type': Name('Annot'),
2337                 'Subtype': Name('Link'),
2338                 'Rect': (x, y, x + width / 64, y + height / 64),
2339                 'Border': [0, 0, 0],
2340                 'A': {
2341                     'S': Name('URI'),
2342                     'URI': gc.get_url(),
2343                 },
2344             }
2345             self.file._annotations[-1][1].append(link_annotation)
2346 
2347         # If fonttype is neither 3 nor 42, emit the whole string at once
2348         # without manual kerning.
2349         if fonttype not in [3, 42]:
2350             self.file.output(Op.begin_text,
2351                              self.file.fontName(prop), fontsize, Op.selectfont)
2352             self._setup_textpos(x, y, angle)
2353             self.file.output(self.encode_string(s, fonttype),
2354                              Op.show, Op.end_text)
2355 
2356         # A sequence of characters is broken into multiple chunks. The chunking
2357         # serves two purposes:
2358         #   - For Type 3 fonts, there is no way to access multibyte characters,
2359         #     as they cannot have a CIDMap.  Therefore, in this case we break
2360         #     the string into chunks, where each chunk contains either a string
2361         #     of consecutive 1-byte characters or a single multibyte character.
2362         #   - A sequence of 1-byte characters is split into chunks to allow for
2363         #     kerning adjustments between consecutive chunks.
2364         #
2365         # Each chunk is emitted with a separate command: 1-byte characters use
2366         # the regular text show command (TJ) with appropriate kerning between
2367         # chunks, whereas multibyte characters use the XObject command (Do).
2368         else:
2369             # List of (start_x, [prev_kern, char, char, ...]), w/o zero kerns.
2370             singlebyte_chunks = []
2371             # List of (start_x, glyph_index).
2372             multibyte_glyphs = []
2373             prev_was_multibyte = True
2374             for item in _text_helpers.layout(
2375                     s, font, kern_mode=KERNING_UNFITTED):
2376                 if _font_supports_glyph(fonttype, ord(item.char)):
2377                     if prev_was_multibyte:
2378                         singlebyte_chunks.append((item.x, []))
2379                     if item.prev_kern:
2380                         singlebyte_chunks[-1][1].append(item.prev_kern)
2381                     singlebyte_chunks[-1][1].append(item.char)
2382                     prev_was_multibyte = False
2383                 else:
2384                     multibyte_glyphs.append((item.x, item.glyph_idx))
2385                     prev_was_multibyte = True
2386             # Do the rotation and global translation as a single matrix
2387             # concatenation up front
2388             self.file.output(Op.gsave)
2389             a = math.radians(angle)
2390             self.file.output(math.cos(a), math.sin(a),
2391                              -math.sin(a), math.cos(a),
2392                              x, y, Op.concat_matrix)
2393             # Emit all the 1-byte characters in a BT/ET group.
2394             self.file.output(Op.begin_text,
2395                              self.file.fontName(prop), fontsize, Op.selectfont)
2396             prev_start_x = 0
2397             for start_x, kerns_or_chars in singlebyte_chunks:
2398                 self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)
2399                 self.file.output(
2400                     # See pdf spec "Text space details" for the 1000/fontsize
2401                     # (aka. 1000/T_fs) factor.
2402                     [-1000 * next(group) / fontsize if tp == float  # a kern
2403                      else self.encode_string("".join(group), fonttype)
2404                      for tp, group in itertools.groupby(kerns_or_chars, type)],
2405                     Op.showkern)
2406                 prev_start_x = start_x
2407             self.file.output(Op.end_text)
2408             # Then emit all the multibyte characters, one at a time.
2409             for start_x, glyph_idx in multibyte_glyphs:
2410                 self._draw_xobject_glyph(font, fontsize, glyph_idx, start_x, 0)
2411             self.file.output(Op.grestore)
2412 
2413     def _draw_xobject_glyph(self, font, fontsize, glyph_idx, x, y):
2414         """Draw a multibyte character from a Type 3 font as an XObject."""
2415         glyph_name = font.get_glyph_name(glyph_idx)
2416         name = self.file._get_xobject_glyph_name(font.fname, glyph_name)
2417         self.file.output(
2418             Op.gsave,
2419             0.001 * fontsize, 0, 0, 0.001 * fontsize, x, y, Op.concat_matrix,
2420             Name(name), Op.use_xobject,
2421             Op.grestore,
2422         )
2423 
2424     def new_gc(self):
2425         # docstring inherited
2426         return GraphicsContextPdf(self.file)
2427 
2428 
2429 class GraphicsContextPdf(GraphicsContextBase):
2430 
2431     def __init__(self, file):
2432         super().__init__()
2433         self._fillcolor = (0.0, 0.0, 0.0)
2434         self._effective_alphas = (1.0, 1.0)
2435         self.file = file
2436         self.parent = None
2437 
2438     def __repr__(self):
2439         d = dict(self.__dict__)
2440         del d['file']
2441         del d['parent']
2442         return repr(d)
2443 
2444     def stroke(self):
2445         """
2446         Predicate: does the path need to be stroked (its outline drawn)?
2447         This tests for the various conditions that disable stroking
2448         the path, in which case it would presumably be filled.
2449         """
2450         # _linewidth > 0: in pdf a line of width 0 is drawn at minimum
2451         #   possible device width, but e.g., agg doesn't draw at all
2452         return (self._linewidth > 0 and self._alpha > 0 and
2453                 (len(self._rgb) <= 3 or self._rgb[3] != 0.0))
2454 
2455     def fill(self, *args):
2456         """
2457         Predicate: does the path need to be filled?
2458 
2459         An optional argument can be used to specify an alternative
2460         _fillcolor, as needed by RendererPdf.draw_markers.
2461         """
2462         if len(args):
2463             _fillcolor = args[0]
2464         else:
2465             _fillcolor = self._fillcolor
2466         return (self._hatch or
2467                 (_fillcolor is not None and
2468                  (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))
2469 
2470     def paint(self):
2471         """
2472         Return the appropriate pdf operator to cause the path to be
2473         stroked, filled, or both.
2474         """
2475         return Op.paint_path(self.fill(), self.stroke())
2476 
2477     capstyles = {'butt': 0, 'round': 1, 'projecting': 2}
2478     joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}
2479 
2480     def capstyle_cmd(self, style):
2481         return [self.capstyles[style], Op.setlinecap]
2482 
2483     def joinstyle_cmd(self, style):
2484         return [self.joinstyles[style], Op.setlinejoin]
2485 
2486     def linewidth_cmd(self, width):
2487         return [width, Op.setlinewidth]
2488 
2489     def dash_cmd(self, dashes):
2490         offset, dash = dashes
2491         if dash is None:
2492             dash = []
2493             offset = 0
2494         return [list(dash), offset, Op.setdash]
2495 
2496     def alpha_cmd(self, alpha, forced, effective_alphas):
2497         name = self.file.alphaState(effective_alphas)
2498         return [name, Op.setgstate]
2499 
2500     def hatch_cmd(self, hatch, hatch_color):
2501         if not hatch:
2502             if self._fillcolor is not None:
2503                 return self.fillcolor_cmd(self._fillcolor)
2504             else:
2505                 return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]
2506         else:
2507             hatch_style = (hatch_color, self._fillcolor, hatch)
2508             name = self.file.hatchPattern(hatch_style)
2509             return [Name('Pattern'), Op.setcolorspace_nonstroke,
2510                     name, Op.setcolor_nonstroke]
2511 
2512     def rgb_cmd(self, rgb):
2513         if mpl.rcParams['pdf.inheritcolor']:
2514             return []
2515         if rgb[0] == rgb[1] == rgb[2]:
2516             return [rgb[0], Op.setgray_stroke]
2517         else:
2518             return [*rgb[:3], Op.setrgb_stroke]
2519 
2520     def fillcolor_cmd(self, rgb):
2521         if rgb is None or mpl.rcParams['pdf.inheritcolor']:
2522             return []
2523         elif rgb[0] == rgb[1] == rgb[2]:
2524             return [rgb[0], Op.setgray_nonstroke]
2525         else:
2526             return [*rgb[:3], Op.setrgb_nonstroke]
2527 
2528     def push(self):
2529         parent = GraphicsContextPdf(self.file)
2530         parent.copy_properties(self)
2531         parent.parent = self.parent
2532         self.parent = parent
2533         return [Op.gsave]
2534 
2535     def pop(self):
2536         assert self.parent is not None
2537         self.copy_properties(self.parent)
2538         self.parent = self.parent.parent
2539         return [Op.grestore]
2540 
2541     def clip_cmd(self, cliprect, clippath):
2542         """Set clip rectangle. Calls `.pop()` and `.push()`."""
2543         cmds = []
2544         # Pop graphics state until we hit the right one or the stack is empty
2545         while ((self._cliprect, self._clippath) != (cliprect, clippath)
2546                 and self.parent is not None):
2547             cmds.extend(self.pop())
2548         # Unless we hit the right one, set the clip polygon
2549         if ((self._cliprect, self._clippath) != (cliprect, clippath) or
2550                 self.parent is None):
2551             cmds.extend(self.push())
2552             if self._cliprect != cliprect:
2553                 cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])
2554             if self._clippath != clippath:
2555                 path, affine = clippath.get_transformed_path_and_affine()
2556                 cmds.extend(
2557                     PdfFile.pathOperations(path, affine, simplify=False) +
2558                     [Op.clip, Op.endpath])
2559         return cmds
2560 
2561     commands = (
2562         # must come first since may pop
2563         (('_cliprect', '_clippath'), clip_cmd),
2564         (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),
2565         (('_capstyle',), capstyle_cmd),
2566         (('_fillcolor',), fillcolor_cmd),
2567         (('_joinstyle',), joinstyle_cmd),
2568         (('_linewidth',), linewidth_cmd),
2569         (('_dashes',), dash_cmd),
2570         (('_rgb',), rgb_cmd),
2571         # must come after fillcolor and rgb
2572         (('_hatch', '_hatch_color'), hatch_cmd),
2573         )
2574 
2575     def delta(self, other):
2576         """
2577         Copy properties of other into self and return PDF commands
2578         needed to transform self into other.
2579         """
2580         cmds = []
2581         fill_performed = False
2582         for params, cmd in self.commands:
2583             different = False
2584             for p in params:
2585                 ours = getattr(self, p)
2586                 theirs = getattr(other, p)
2587                 try:
2588                     if ours is None or theirs is None:
2589                         different = ours is not theirs
2590                     else:
2591                         different = bool(ours != theirs)
2592                 except ValueError:
2593                     ours = np.asarray(ours)
2594                     theirs = np.asarray(theirs)
2595                     different = (ours.shape != theirs.shape or
2596                                  np.any(ours != theirs))
2597                 if different:
2598                     break
2599 
2600             # Need to update hatching if we also updated fillcolor
2601             if params == ('_hatch', '_hatch_color') and fill_performed:
2602                 different = True
2603 
2604             if different:
2605                 if params == ('_fillcolor',):
2606                     fill_performed = True
2607                 theirs = [getattr(other, p) for p in params]
2608                 cmds.extend(cmd(self, *theirs))
2609                 for p in params:
2610                     setattr(self, p, getattr(other, p))
2611         return cmds
2612 
2613     def copy_properties(self, other):
2614         """
2615         Copy properties of other into self.
2616         """
2617         super().copy_properties(other)
2618         fillcolor = getattr(other, '_fillcolor', self._fillcolor)
2619         effective_alphas = getattr(other, '_effective_alphas',
2620                                    self._effective_alphas)
2621         self._fillcolor = fillcolor
2622         self._effective_alphas = effective_alphas
2623 
2624     def finalize(self):
2625         """
2626         Make sure every pushed graphics state is popped.
2627         """
2628         cmds = []
2629         while self.parent is not None:
2630             cmds.extend(self.pop())
2631         return cmds
2632 
2633 
2634 class PdfPages:
2635     """
2636     A multi-page PDF file.
2637 
2638     Examples
2639     --------
2640     >>> import matplotlib.pyplot as plt
2641     >>> # Initialize:
2642     >>> with PdfPages('foo.pdf') as pdf:
2643     ...     # As many times as you like, create a figure fig and save it:
2644     ...     fig = plt.figure()
2645     ...     pdf.savefig(fig)
2646     ...     # When no figure is specified the current figure is saved
2647     ...     pdf.savefig()
2648 
2649     Notes
2650     -----
2651     In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid
2652     confusion when using `~.pyplot.savefig` and forgetting the format argument.
2653     """
2654     __slots__ = ('_file', 'keep_empty')
2655 
2656     def __init__(self, filename, keep_empty=True, metadata=None):
2657         """
2658         Create a new PdfPages object.
2659 
2660         Parameters
2661         ----------
2662         filename : str or path-like or file-like
2663             Plots using `PdfPages.savefig` will be written to a file at this
2664             location. The file is opened at once and any older file with the
2665             same name is overwritten.
2666 
2667         keep_empty : bool, optional
2668             If set to False, then empty pdf files will be deleted automatically
2669             when closed.
2670 
2671         metadata : dict, optional
2672             Information dictionary object (see PDF reference section 10.2.1
2673             'Document Information Dictionary'), e.g.:
2674             ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.
2675 
2676             The standard keys are 'Title', 'Author', 'Subject', 'Keywords',
2677             'Creator', 'Producer', 'CreationDate', 'ModDate', and
2678             'Trapped'. Values have been predefined for 'Creator', 'Producer'
2679             and 'CreationDate'. They can be removed by setting them to `None`.
2680         """
2681         self._file = PdfFile(filename, metadata=metadata)
2682         self.keep_empty = keep_empty
2683 
2684     def __enter__(self):
2685         return self
2686 
2687     def __exit__(self, exc_type, exc_val, exc_tb):
2688         self.close()
2689 
2690     def close(self):
2691         """
2692         Finalize this object, making the underlying file a complete
2693         PDF file.
2694         """
2695         self._file.finalize()
2696         self._file.close()
2697         if (self.get_pagecount() == 0 and not self.keep_empty and
2698                 not self._file.passed_in_file_object):
2699             os.remove(self._file.fh.name)
2700         self._file = None
2701 
2702     def infodict(self):
2703         """
2704         Return a modifiable information dictionary object
2705         (see PDF reference section 10.2.1 'Document Information
2706         Dictionary').
2707         """
2708         return self._file.infoDict
2709 
2710     def savefig(self, figure=None, **kwargs):
2711         """
2712         Save a `.Figure` to this file as a new page.
2713 
2714         Any other keyword arguments are passed to `~.Figure.savefig`.
2715 
2716         Parameters
2717         ----------
2718         figure : `.Figure` or int, default: the active figure
2719             The figure, or index of the figure, that is saved to the file.
2720         """
2721         if not isinstance(figure, Figure):
2722             if figure is None:
2723                 manager = Gcf.get_active()
2724             else:
2725                 manager = Gcf.get_fig_manager(figure)
2726             if manager is None:
2727                 raise ValueError("No figure {}".format(figure))
2728             figure = manager.canvas.figure
2729         # Force use of pdf backend, as PdfPages is tightly coupled with it.
2730         try:
2731             orig_canvas = figure.canvas
2732             figure.canvas = FigureCanvasPdf(figure)
2733             figure.savefig(self, format="pdf", **kwargs)
2734         finally:
2735             figure.canvas = orig_canvas
2736 
2737     def get_pagecount(self):
2738         """Return the current number of pages in the multipage pdf file."""
2739         return len(self._file.pageList)
2740 
2741     def attach_note(self, text, positionRect=[-100, -100, 0, 0]):
2742         """
2743         Add a new text note to the page to be saved next. The optional
2744         positionRect specifies the position of the new note on the
2745         page. It is outside the page per default to make sure it is
2746         invisible on printouts.
2747         """
2748         self._file.newTextnote(text, positionRect)
2749 
2750 
2751 class FigureCanvasPdf(FigureCanvasBase):
2752     # docstring inherited
2753 
2754     fixed_dpi = 72
2755     filetypes = {'pdf': 'Portable Document Format'}
2756 
2757     def get_default_filetype(self):
2758         return 'pdf'
2759 
2760     def print_pdf(self, filename, *,
2761                   bbox_inches_restore=None, metadata=None):
2762 
2763         dpi = self.figure.dpi
2764         self.figure.dpi = 72  # there are 72 pdf points to an inch
2765         width, height = self.figure.get_size_inches()
2766         if isinstance(filename, PdfPages):
2767             file = filename._file
2768         else:
2769             file = PdfFile(filename, metadata=metadata)
2770         try:
2771             file.newPage(width, height)
2772             renderer = MixedModeRenderer(
2773                 self.figure, width, height, dpi,
2774                 RendererPdf(file, dpi, height, width),
2775                 bbox_inches_restore=bbox_inches_restore)
2776             self.figure.draw(renderer)
2777             renderer.finalize()
2778             if not isinstance(filename, PdfPages):
2779                 file.finalize()
2780         finally:
2781             if isinstance(filename, PdfPages):  # finish off this page
2782                 file.endStream()
2783             else:            # we opened the file above; now finish it off
2784                 file.close()
2785 
2786     def draw(self):
2787         self.figure.draw_without_rendering()
2788         return super().draw()
2789 
2790 
2791 FigureManagerPdf = FigureManagerBase
2792 
2793 
2794 @_Backend.export
2795 class _BackendPdf(_Backend):
2796     FigureCanvas = FigureCanvasPdf

</code><intended_behavior>The method responsible for rendering text with URLs in PDFs should account for the text's rotation by correctly implementing the 'QuadPoints' in addition to the 'Rect' for link annotations. This implementation should allow the clickable area to correctly rotate with the text, matching its visual orientation. This enhancement must maintain backward compatibility by also providing a 'Rect' that encompasses the rotated text's footprint, ensuring that viewers not supporting 'QuadPoints' still offer a functional (though potentially less precise) clickable area.</intended_behavior>]
2025-10-15 07:25:05.580 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:25:05.580 | INFO     | Search-only: skipping patch selection
2025-10-15 07:25:05.735 | INFO     | Task matplotlib__matplotlib-23288 completed successfully.
2025-10-15 07:25:05.736 | INFO     | No patch generated. You can try running ACR again.
