2025-10-15 07:06:46.118 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:06:49.522 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=306, output_tokens=12, cost=0.003420
2025-10-15 07:07:01.112 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=433, cost=0.017850
2025-10-15 07:07:02.146 | INFO     | registered non reproducing test 0
2025-10-15 07:07:17.899 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1306, output_tokens=539, cost=0.029230
2025-10-15 07:07:18.852 | INFO     | registered non reproducing test 1
2025-10-15 07:07:30.971 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1416, output_tokens=495, cost=0.029010
2025-10-15 07:07:31.932 | INFO     | registered non reproducing test 2
2025-10-15 07:07:31.932 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 07:07:31.938 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:07:40.252 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=594, output_tokens=255, cost=0.013590
2025-10-15 07:07:40.257 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:07:43.271 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=609, output_tokens=43, cost=0.007380
2025-10-15 07:07:43.272 | DEBUG    | Extracted a valid json.
2025-10-15 07:07:43.272 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"savefig\")",
        "search_method(\"subplots\")",
        "search_code(\"libpng\")"
    ],
    "bug_locations": []
}
2025-10-15 07:07:43.385 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:07:43.386 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:08:01.897 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6655, output_tokens=645, cost=0.085900
2025-10-15 07:08:01.909 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:08:13.339 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7516, output_tokens=381, cost=0.086590
2025-10-15 07:08:13.347 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:08:22.158 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=735, output_tokens=333, cost=0.017340
2025-10-15 07:08:22.159 | DEBUG    | Extracted a valid json.
2025-10-15 07:08:22.159 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "subplots",
            "intended_behavior": "This method should include validation for the `figsize` argument to ensure that both width and height are positive numbers. Since it currently allows creating figures with zero or negative dimensions, leading to errors when saving, a check should be introduced early in the method. If invalid dimensions are specified, it should raise a `ValueError` with a clear message indicating that both width and height must be greater than zero. This preserves the method's functionality while preventing the creation of figures with dimensions that are not valid for rendering or saving."
        },
        {
            "file": "lib/matplotlib/figure.py",
            "class": "",
            "method": "savefig",
            "intended_behavior": "The `savefig` method across its various implementations should include a pre-save validation process that checks if the figure dimensions (width and height) are valid (i.e., greater than zero). If the dimensions are not valid, it should raise an informative `RuntimeError` or a `ValueError` explaining that saving a figure requires both width and height to be positive numbers. This change will prevent unhandled low-level errors (e.g., from libpng) by catching the issue at the matplotlib level, thereby providing a more informative error message to the user. This intended behavior also maintains the functionality of the method while enforcing a check that aligns with the requirements of dependent libraries like libpng."
        }
    ]
}
2025-10-15 07:08:22.179 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>subplots</method>
<code>
1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,
1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):
1427         """
1428         Add a set of subplots to this figure.
1429 
1430         This utility wrapper makes it convenient to create common layouts of
1431         subplots in a single call.
1432 
1433         Parameters
1434         ----------
1435         nrows, ncols : int, optional, default: 1
1436             Number of rows/columns of the subplot grid.
1437 
1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)
1440             axes:
1441 
1442                 - True or 'all': x- or y-axis will be shared among all
1443                   subplots.
1444                 - False or 'none': each subplot x- or y-axis will be
1445                   independent.
1446                 - 'row': each subplot row will share an x- or y-axis.
1447                 - 'col': each subplot column will share an x- or y-axis.
1448 
1449             When subplots have a shared x-axis along a column, only the x tick
1450             labels of the bottom subplot are created. Similarly, when subplots
1451             have a shared y-axis along a row, only the y tick labels of the
1452             first column subplot are created. To later turn other subplots'
1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
1454 
1455         squeeze : bool, optional, default: True
1456             - If True, extra dimensions are squeezed out from the returned
1457               array of Axes:
1458 
1459                 - if only one subplot is constructed (nrows=ncols=1), the
1460                   resulting single Axes object is returned as a scalar.
1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1462                   object array of Axes objects.
1463                 - for NxM, subplots with N>1 and M>1 are returned
1464                   as a 2D array.
1465 
1466             - If False, no squeezing at all is done: the returned Axes object
1467               is always a 2D array containing Axes instances, even if it ends
1468               up being 1x1.
1469 
1470         subplot_kw : dict, optional
1471             Dict with keywords passed to the
1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create
1473             each subplot.
1474 
1475         gridspec_kw : dict, optional
1476             Dict with keywords passed to the
1477             `~matplotlib.gridspec.GridSpec` constructor used to create
1478             the grid the subplots are placed on.
1479 
1480         Returns
1481         -------
1482         ax : `~.axes.Axes` object or array of Axes objects.
1483             *ax* can be either a single `~matplotlib.axes.Axes` object or
1484             an array of Axes objects if more than one subplot was created. The
1485             dimensions of the resulting array can be controlled with the
1486             squeeze keyword, see above.
1487 
1488         Examples
1489         --------
1490         ::
1491 
1492             # First create some toy data:
1493             x = np.linspace(0, 2*np.pi, 400)
1494             y = np.sin(x**2)
1495 
1496             # Create a figure
1497             plt.figure()
1498 
1499             # Creates a subplot
1500             ax = fig.subplots()
1501             ax.plot(x, y)
1502             ax.set_title('Simple plot')
1503 
1504             # Creates two subplots and unpacks the output array immediately
1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)
1506             ax1.plot(x, y)
1507             ax1.set_title('Sharing Y axis')
1508             ax2.scatter(x, y)
1509 
1510             # Creates four polar axes, and accesses them through the
1511             # returned array
1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))
1513             axes[0, 0].plot(x, y)
1514             axes[1, 1].scatter(x, y)
1515 
1516             # Share a X axis with each column of subplots
1517             fig.subplots(2, 2, sharex='col')
1518 
1519             # Share a Y axis with each row of subplots
1520             fig.subplots(2, 2, sharey='row')
1521 
1522             # Share both X and Y axes with all subplots
1523             fig.subplots(2, 2, sharex='all', sharey='all')
1524 
1525             # Note that this is the same as
1526             fig.subplots(2, 2, sharex=True, sharey=True)
1527 
1528             See Also
1529             --------
1530             .pyplot.subplots
1531             .Figure.add_subplot
1532             .pyplot.subplot
1533             """
1534 
1535         if isinstance(sharex, bool):
1536             sharex = "all" if sharex else "none"
1537         if isinstance(sharey, bool):
1538             sharey = "all" if sharey else "none"
1539         # This check was added because it is very easy to type
1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.
1541         # In most cases, no error will ever occur, but mysterious behavior
1542         # will result because what was intended to be the subplot index is
1543         # instead treated as a bool for sharex.
1544         if isinstance(sharex, Integral):
1545             cbook._warn_external(
1546                 "sharex argument to subplots() was an integer.  Did you "
1547                 "intend to use subplot() (without 's')?")
1548         cbook._check_in_list(["all", "row", "col", "none"],
1549                              sharex=sharex, sharey=sharey)
1550         if subplot_kw is None:
1551             subplot_kw = {}
1552         if gridspec_kw is None:
1553             gridspec_kw = {}
1554         # don't mutate kwargs passed by user...
1555         subplot_kw = subplot_kw.copy()
1556         gridspec_kw = gridspec_kw.copy()
1557 
1558         if self.get_constrained_layout():
1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)
1560         else:
1561             # this should turn constrained_layout off if we don't want it
1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)
1563         self._gridspecs.append(gs)
1564 
1565         # Create array to hold all axes.
1566         axarr = np.empty((nrows, ncols), dtype=object)
1567         for row in range(nrows):
1568             for col in range(ncols):
1569                 shared_with = {"none": None, "all": axarr[0, 0],
1570                                "row": axarr[row, 0], "col": axarr[0, col]}
1571                 subplot_kw["sharex"] = shared_with[sharex]
1572                 subplot_kw["sharey"] = shared_with[sharey]
1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)
1574 
1575         # turn off redundant tick labeling
1576         if sharex in ["col", "all"]:
1577             # turn off all but the bottom row
1578             for ax in axarr[:-1, :].flat:
1579                 ax.xaxis.set_tick_params(which='both',
1580                                          labelbottom=False, labeltop=False)
1581                 ax.xaxis.offsetText.set_visible(False)
1582         if sharey in ["row", "all"]:
1583             # turn off all but the first column
1584             for ax in axarr[:, 1:].flat:
1585                 ax.yaxis.set_tick_params(which='both',
1586                                          labelleft=False, labelright=False)
1587                 ax.yaxis.offsetText.set_visible(False)
1588 
1589         if squeeze:
1590             # Discarding unneeded dimensions that equal 1.  If we only have one
1591             # subplot, just return it instead of a 1-element array.
1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()
1593         else:
1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1595             return axarr

</code><intended_behavior>This method should include validation for the `figsize` argument to ensure that both width and height are positive numbers. Since it currently allows creating figures with zero or negative dimensions, leading to errors when saving, a check should be introduced early in the method. If invalid dimensions are specified, it should raise a `ValueError` with a clear message indicating that both width and height must be greater than zero. This preserves the method's functionality while preventing the creation of figures with dimensions that are not valid for rendering or saving.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
245 class Figure(Artist):
246     """
247     The top level container for all the plot elements.
248 
249     The Figure instance supports callbacks through a *callbacks* attribute
250     which is a `.CallbackRegistry` instance.  The events you can connect to
251     are 'dpi_changed', and the callback will be called with ``func(fig)`` where
252     fig is the `Figure` instance.
253 
254     Attributes
255     ----------
256     patch
257         The `.Rectangle` instance representing the figure background patch.
258 
259     suppressComposite
260         For multiple figure images, the figure will make composite images
261         depending on the renderer option_image_nocomposite function.  If
262         *suppressComposite* is a boolean, this will override the renderer.
263     """
264 
265     def __str__(self):
266         return "Figure(%gx%g)" % tuple(self.bbox.size)
267 
268     def __repr__(self):
269         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
270             clsname=self.__class__.__name__,
271             h=self.bbox.size[0], w=self.bbox.size[1],
272             naxes=len(self.axes),
273         )
274 
275     def __init__(self,
276                  figsize=None,
277                  dpi=None,
278                  facecolor=None,
279                  edgecolor=None,
280                  linewidth=0.0,
281                  frameon=None,
282                  subplotpars=None,  # default to rc
283                  tight_layout=None,  # default to rc figure.autolayout
284                  constrained_layout=None,  # default to rc
285                                           #figure.constrained_layout.use
286                  ):
287         """
288         Parameters
289         ----------
290         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
291             Figure dimension ``(width, height)`` in inches.
292 
293         dpi : float, default: :rc:`figure.dpi`
294             Dots per inch.
295 
296         facecolor : default: :rc:`figure.facecolor`
297             The figure patch facecolor.
298 
299         edgecolor : default: :rc:`figure.edgecolor`
300             The figure patch edge color.
301 
302         linewidth : float
303             The linewidth of the frame (i.e. the edge linewidth of the figure
304             patch).
305 
306         frameon : bool, default: :rc:`figure.frameon`
307             If ``False``, suppress drawing the figure background patch.
308 
309         subplotpars : :class:`SubplotParams`
310             Subplot parameters. If not given, the default subplot
311             parameters :rc:`figure.subplot.*` are used.
312 
313         tight_layout : bool or dict, default: :rc:`figure.autolayout`
314             If ``False`` use *subplotpars*. If ``True`` adjust subplot
315             parameters using `.tight_layout` with default padding.
316             When providing a dict containing the keys ``pad``, ``w_pad``,
317             ``h_pad``, and ``rect``, the default `.tight_layout` paddings
318             will be overridden.
319 
320         constrained_layout : bool
321             If ``True`` use constrained layout to adjust positioning of plot
322             elements.  Like ``tight_layout``, but designed to be more
323             flexible.  See
324             :doc:`/tutorials/intermediate/constrainedlayout_guide`
325             for examples.  (Note: does not work with :meth:`.subplot` or
326             :meth:`.subplot2grid`.)
327             Defaults to :rc:`figure.constrained_layout.use`.
328         """
329         super().__init__()
330         # remove the non-figure artist _axes property
331         # as it makes no sense for a figure to be _in_ an axes
332         # this is used by the property methods in the artist base class
333         # which are over-ridden in this class
334         del self._axes
335         self.callbacks = cbook.CallbackRegistry()
336 
337         if figsize is None:
338             figsize = rcParams['figure.figsize']
339         if dpi is None:
340             dpi = rcParams['figure.dpi']
341         if facecolor is None:
342             facecolor = rcParams['figure.facecolor']
343         if edgecolor is None:
344             edgecolor = rcParams['figure.edgecolor']
345         if frameon is None:
346             frameon = rcParams['figure.frameon']
347 
348         if not np.isfinite(figsize).all():
349             raise ValueError('figure size must be finite not '
350                              '{}'.format(figsize))
351         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
352 
353         self.dpi_scale_trans = Affine2D().scale(dpi, dpi)
354         # do not use property as it will trigger
355         self._dpi = dpi
356         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
357 
358         self.transFigure = BboxTransformTo(self.bbox)
359 
360         self.patch = Rectangle(
361             xy=(0, 0), width=1, height=1,
362             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
363             visible=frameon)
364         self._set_artist_props(self.patch)
365         self.patch.set_antialiased(False)
366 
367         FigureCanvasBase(self)  # Set self.canvas.
368         self._suptitle = None
369 
370         if subplotpars is None:
371             subplotpars = SubplotParams()
372 
373         self.subplotpars = subplotpars
374         # constrained_layout:
375         self._layoutbox = None
376         # set in set_constrained_layout_pads()
377         self.set_constrained_layout(constrained_layout)
378 
379         self.set_tight_layout(tight_layout)
380 
381         self._axstack = AxesStack()  # track all figure axes and current axes
382         self.clf()
383         self._cachedRenderer = None
384 
385         # groupers to keep track of x and y labels we want to align.
386         # see self.align_xlabels and self.align_ylabels and
387         # axis._get_tick_boxes_siblings
388         self._align_xlabel_grp = cbook.Grouper()
389         self._align_ylabel_grp = cbook.Grouper()
390 
391         # list of child gridspecs for this figure
392         self._gridspecs = []
393 
394     # TODO: I'd like to dynamically add the _repr_html_ method
395     # to the figure in the right context, but then IPython doesn't
396     # use it, for some reason.
397 
398     def _repr_html_(self):
399         # We can't use "isinstance" here, because then we'd end up importing
400         # webagg unconditionally.
401         if 'WebAgg' in type(self.canvas).__name__:
402             from matplotlib.backends import backend_webagg
403             return backend_webagg.ipython_inline_display(self)
404 
405     def show(self, warn=True):
406         """
407         If using a GUI backend with pyplot, display the figure window.
408 
409         If the figure was not created using
410         :func:`~matplotlib.pyplot.figure`, it will lack a
411         :class:`~matplotlib.backend_bases.FigureManagerBase`, and
412         will raise an AttributeError.
413 
414         .. warning::
415             This does not manage an GUI event loop. Consequently, the figure
416             may only be shown briefly or not shown at all if you or your
417             environment are not managing an event loop.
418 
419             Proper use cases for `.Figure.show` include running this from a
420             GUI application or an IPython shell.
421 
422             If you're running a pure python shell or executing a non-GUI
423             python script, you should use `matplotlib.pyplot.show` instead,
424             which takes care of managing the event loop for you.
425 
426         Parameters
427         ----------
428         warn : bool
429             If ``True`` and we are not running headless (i.e. on Linux with an
430             unset DISPLAY), issue warning when called on a non-GUI backend.
431         """
432         try:
433             manager = getattr(self.canvas, 'manager')
434         except AttributeError as err:
435             raise AttributeError("%s\n"
436                                  "Figure.show works only "
437                                  "for figures managed by pyplot, normally "
438                                  "created by pyplot.figure()." % err)
439 
440         if manager is not None:
441             try:
442                 manager.show()
443                 return
444             except NonGuiException:
445                 pass
446         if (backends._get_running_interactive_framework() != "headless"
447                 and warn):
448             cbook._warn_external('Matplotlib is currently using %s, which is '
449                                  'a non-GUI backend, so cannot show the '
450                                  'figure.' % get_backend())
451 
452     def _get_axes(self):
453         return self._axstack.as_list()
454 
455     axes = property(fget=_get_axes,
456                     doc="List of axes in the Figure. You can access the "
457                         "axes in the Figure through this list. "
458                         "Do not modify the list itself. Instead, use "
459                         "`~Figure.add_axes`, `~.Figure.subplot` or "
460                         "`~.Figure.delaxes` to add or remove an axes.")
461 
462     def _get_dpi(self):
463         return self._dpi
464 
465     def _set_dpi(self, dpi, forward=True):
466         """
467         Parameters
468         ----------
469         dpi : float
470 
471         forward : bool
472             Passed on to `~.Figure.set_size_inches`
473         """
474         self._dpi = dpi
475         self.dpi_scale_trans.clear().scale(dpi, dpi)
476         w, h = self.get_size_inches()
477         self.set_size_inches(w, h, forward=forward)
478         self.callbacks.process('dpi_changed', self)
479 
480     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
481 
482     def get_tight_layout(self):
483         """Return whether `.tight_layout` is called when drawing."""
484         return self._tight
485 
486     def set_tight_layout(self, tight):
487         """
488         Set whether and how `.tight_layout` is called when drawing.
489 
490         Parameters
491         ----------
492         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
493             If a bool, sets whether to call `.tight_layout` upon drawing.
494             If ``None``, use the ``figure.autolayout`` rcparam instead.
495             If a dict, pass it as kwargs to `.tight_layout`, overriding the
496             default paddings.
497         """
498         if tight is None:
499             tight = rcParams['figure.autolayout']
500         self._tight = bool(tight)
501         self._tight_parameters = tight if isinstance(tight, dict) else {}
502         self.stale = True
503 
504     def get_constrained_layout(self):
505         """
506         Return a boolean: True means constrained layout is being used.
507 
508         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
509         """
510         return self._constrained
511 
512     def set_constrained_layout(self, constrained):
513         """
514         Set whether ``constrained_layout`` is used upon drawing. If None,
515         the rcParams['figure.constrained_layout.use'] value will be used.
516 
517         When providing a dict containing the keys `w_pad`, `h_pad`
518         the default ``constrained_layout`` paddings will be
519         overridden.  These pads are in inches and default to 3.0/72.0.
520         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
521 
522         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
523 
524         Parameters
525         ----------
526         constrained : bool or dict or None
527         """
528         self._constrained_layout_pads = dict()
529         self._constrained_layout_pads['w_pad'] = None
530         self._constrained_layout_pads['h_pad'] = None
531         self._constrained_layout_pads['wspace'] = None
532         self._constrained_layout_pads['hspace'] = None
533         if constrained is None:
534             constrained = rcParams['figure.constrained_layout.use']
535         self._constrained = bool(constrained)
536         if isinstance(constrained, dict):
537             self.set_constrained_layout_pads(**constrained)
538         else:
539             self.set_constrained_layout_pads()
540 
541         self.stale = True
542 
543     def set_constrained_layout_pads(self, **kwargs):
544         """
545         Set padding for ``constrained_layout``.  Note the kwargs can be passed
546         as a dictionary ``fig.set_constrained_layout(**paddict)``.
547 
548         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
549 
550         Parameters
551         ----------
552 
553         w_pad : scalar
554             Width padding in inches.  This is the pad around axes
555             and is meant to make sure there is enough room for fonts to
556             look good.  Defaults to 3 pts = 0.04167 inches
557 
558         h_pad : scalar
559             Height padding in inches. Defaults to 3 pts.
560 
561         wspace : scalar
562             Width padding between subplots, expressed as a fraction of the
563             subplot width.  The total padding ends up being w_pad + wspace.
564 
565         hspace : scalar
566             Height padding between subplots, expressed as a fraction of the
567             subplot width. The total padding ends up being h_pad + hspace.
568 
569         """
570 
571         todo = ['w_pad', 'h_pad', 'wspace', 'hspace']
572         for td in todo:
573             if td in kwargs and kwargs[td] is not None:
574                 self._constrained_layout_pads[td] = kwargs[td]
575             else:
576                 self._constrained_layout_pads[td] = (
577                     rcParams['figure.constrained_layout.' + td])
578 
579     def get_constrained_layout_pads(self, relative=False):
580         """
581         Get padding for ``constrained_layout``.
582 
583         Returns a list of `w_pad, h_pad` in inches and
584         `wspace` and `hspace` as fractions of the subplot.
585 
586         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
587 
588         Parameters
589         ----------
590 
591         relative : boolean
592             If `True`, then convert from inches to figure relative.
593         """
594         w_pad = self._constrained_layout_pads['w_pad']
595         h_pad = self._constrained_layout_pads['h_pad']
596         wspace = self._constrained_layout_pads['wspace']
597         hspace = self._constrained_layout_pads['hspace']
598 
599         if relative and (w_pad is not None or h_pad is not None):
600             renderer0 = layoutbox.get_renderer(self)
601             dpi = renderer0.dpi
602             w_pad = w_pad * dpi / renderer0.width
603             h_pad = h_pad * dpi / renderer0.height
604 
605         return w_pad, h_pad, wspace, hspace
606 
607     def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right', which=None):
608         """
609         Date ticklabels often overlap, so it is useful to rotate them
610         and right align them.  Also, a common use case is a number of
611         subplots with shared xaxes where the x-axis is date data.  The
612         ticklabels are often long, and it helps to rotate them on the
613         bottom subplot and turn them off on other subplots, as well as
614         turn off xlabels.
615 
616         Parameters
617         ----------
618         bottom : scalar
619             The bottom of the subplots for :meth:`subplots_adjust`.
620 
621         rotation : angle in degrees
622             The rotation of the xtick labels.
623 
624         ha : string
625             The horizontal alignment of the xticklabels.
626 
627         which : {None, 'major', 'minor', 'both'}
628             Selects which ticklabels to rotate. Default is None which works
629             the same as major.
630         """
631         allsubplots = all(hasattr(ax, 'is_last_row') for ax in self.axes)
632         if len(self.axes) == 1:
633             for label in self.axes[0].get_xticklabels(which=which):
634                 label.set_ha(ha)
635                 label.set_rotation(rotation)
636         else:
637             if allsubplots:
638                 for ax in self.get_axes():
639                     if ax.is_last_row():
640                         for label in ax.get_xticklabels(which=which):
641                             label.set_ha(ha)
642                             label.set_rotation(rotation)
643                     else:
644                         for label in ax.get_xticklabels(which=which):
645                             label.set_visible(False)
646                         ax.set_xlabel('')
647 
648         if allsubplots:
649             self.subplots_adjust(bottom=bottom)
650         self.stale = True
651 
652     def get_children(self):
653         """Get a list of artists contained in the figure."""
654         return [self.patch,
655                 *self.artists,
656                 *self.axes,
657                 *self.lines,
658                 *self.patches,
659                 *self.texts,
660                 *self.images,
661                 *self.legends]
662 
663     def contains(self, mouseevent):
664         """
665         Test whether the mouse event occurred on the figure.
666 
667         Returns
668         -------
669             bool, {}
670         """
671         if self._contains is not None:
672             return self._contains(self, mouseevent)
673         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
674         return inside, {}
675 
676     def get_window_extent(self, *args, **kwargs):
677         """
678         Return the figure bounding box in display space. Arguments are ignored.
679         """
680         return self.bbox
681 
682     def suptitle(self, t, **kwargs):
683         """
684         Add a centered title to the figure.
685 
686         Parameters
687         ----------
688         t : str
689             The title text.
690 
691         x : float, default 0.5
692             The x location of the text in figure coordinates.
693 
694         y : float, default 0.98
695             The y location of the text in figure coordinates.
696 
697         horizontalalignment, ha : {'center', 'left', right'}, default: 'center'
698             The horizontal alignment of the text relative to (*x*, *y*).
699 
700         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
701 default: 'top'
702             The vertical alignment of the text relative to (*x*, *y*).
703 
704         fontsize, size : default: :rc:`figure.titlesize`
705             The font size of the text. See `.Text.set_size` for possible
706             values.
707 
708         fontweight, weight : default: :rc:`figure.titleweight`
709             The font weight of the text. See `.Text.set_weight` for possible
710             values.
711 
712 
713         Returns
714         -------
715             text
716                 The `.Text` instance of the title.
717 
718 
719         Other Parameters
720         ----------------
721         fontproperties : None or dict, optional
722             A dict of font properties. If *fontproperties* is given the
723             default values for font size and weight are taken from the
724             `FontProperties` defaults. :rc:`figure.titlesize` and
725             :rc:`figure.titleweight` are ignored in this case.
726 
727         **kwargs
728             Additional kwargs are :class:`matplotlib.text.Text` properties.
729 
730 
731         Examples
732         --------
733 
734         >>> fig.suptitle('This is the figure title', fontsize=12)
735         """
736         manual_position = ('x' in kwargs or 'y' in kwargs)
737 
738         x = kwargs.pop('x', 0.5)
739         y = kwargs.pop('y', 0.98)
740 
741         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
742             kwargs['horizontalalignment'] = 'center'
743         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
744             kwargs['verticalalignment'] = 'top'
745 
746         if 'fontproperties' not in kwargs:
747             if 'fontsize' not in kwargs and 'size' not in kwargs:
748                 kwargs['size'] = rcParams['figure.titlesize']
749             if 'fontweight' not in kwargs and 'weight' not in kwargs:
750                 kwargs['weight'] = rcParams['figure.titleweight']
751 
752         sup = self.text(x, y, t, **kwargs)
753         if self._suptitle is not None:
754             self._suptitle.set_text(t)
755             self._suptitle.set_position((x, y))
756             self._suptitle.update_from(sup)
757             sup.remove()
758         else:
759             self._suptitle = sup
760             self._suptitle._layoutbox = None
761             if self._layoutbox is not None and not manual_position:
762                 w_pad, h_pad, wspace, hspace =  \
763                         self.get_constrained_layout_pads(relative=True)
764                 figlb = self._layoutbox
765                 self._suptitle._layoutbox = layoutbox.LayoutBox(
766                         parent=figlb, artist=self._suptitle,
767                         name=figlb.name+'.suptitle')
768                 # stack the suptitle on top of all the children.
769                 # Some day this should be on top of all the children in the
770                 # gridspec only.
771                 for child in figlb.children:
772                     if child is not self._suptitle._layoutbox:
773                         layoutbox.vstack([self._suptitle._layoutbox,
774                                           child],
775                                          padding=h_pad*2., strength='required')
776         self.stale = True
777         return self._suptitle
778 
779     def set_canvas(self, canvas):
780         """
781         Set the canvas that contains the figure
782 
783         Parameters
784         ----------
785         canvas : FigureCanvas
786         """
787         self.canvas = canvas
788 
789     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
790                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
791         """
792         Add a non-resampled image to the figure.
793 
794         The image is attached to the lower or upper left corner depending on
795         *origin*.
796 
797         Parameters
798         ----------
799         X
800             The image data. This is an array of one of the following shapes:
801 
802             - MxN: luminance (grayscale) values
803             - MxNx3: RGB values
804             - MxNx4: RGBA values
805 
806         xo, yo : int
807             The *x*/*y* image offset in pixels.
808 
809         alpha : None or float
810             The alpha blending value.
811 
812         norm : :class:`matplotlib.colors.Normalize`
813             A :class:`.Normalize` instance to map the luminance to the
814             interval [0, 1].
815 
816         cmap : str or :class:`matplotlib.colors.Colormap`
817             The colormap to use. Default: :rc:`image.cmap`.
818 
819         vmin, vmax : scalar
820             If *norm* is not given, these values set the data limits for the
821             colormap.
822 
823         origin : {'upper', 'lower'}
824             Indicates where the [0, 0] index of the array is in the upper left
825             or lower left corner of the axes. Defaults to :rc:`image.origin`.
826 
827         resize : bool
828             If *True*, resize the figure to match the given image size.
829 
830         Returns
831         -------
832         :class:`matplotlib.image.FigureImage`
833 
834         Other Parameters
835         ----------------
836         **kwargs
837             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
838 
839         Notes
840         -----
841         figimage complements the axes image
842         (:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled
843         to fit the current axes.  If you want a resampled image to
844         fill the entire figure, you can define an
845         :class:`~matplotlib.axes.Axes` with extent [0,0,1,1].
846 
847 
848         Examples::
849 
850             f = plt.figure()
851             nx = int(f.get_figwidth() * f.dpi)
852             ny = int(f.get_figheight() * f.dpi)
853             data = np.random.random((ny, nx))
854             f.figimage(data)
855             plt.show()
856 
857         """
858         if resize:
859             dpi = self.get_dpi()
860             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
861             self.set_size_inches(figsize, forward=True)
862 
863         im = mimage.FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)
864         im.stale_callback = _stale_figure_callback
865 
866         im.set_array(X)
867         im.set_alpha(alpha)
868         if norm is None:
869             im.set_clim(vmin, vmax)
870         self.images.append(im)
871         im._remove_method = self.images.remove
872         self.stale = True
873         return im
874 
875     def set_size_inches(self, w, h=None, forward=True):
876         """Set the figure size in inches.
877 
878         Call signatures::
879 
880              fig.set_size_inches(w, h)  # OR
881              fig.set_size_inches((w, h))
882 
883         optional kwarg *forward=True* will cause the canvas size to be
884         automatically updated; e.g., you can resize the figure window
885         from the shell
886 
887         ACCEPTS: a (w, h) tuple with w, h in inches
888 
889         See Also
890         --------
891         matplotlib.Figure.get_size_inches
892         """
893 
894         # the width and height have been passed in as a tuple to the first
895         # argument, so unpack them
896         if h is None:
897             w, h = w
898         if not all(np.isfinite(_) for _ in (w, h)):
899             raise ValueError('figure size must be finite not '
900                              '({}, {})'.format(w, h))
901         self.bbox_inches.p1 = w, h
902 
903         if forward:
904             canvas = getattr(self, 'canvas')
905             if canvas is not None:
906                 ratio = getattr(self.canvas, '_dpi_ratio', 1)
907                 dpival = self.dpi / ratio
908                 canvasw = w * dpival
909                 canvash = h * dpival
910                 manager = getattr(self.canvas, 'manager', None)
911                 if manager is not None:
912                     manager.resize(int(canvasw), int(canvash))
913         self.stale = True
914 
915     def get_size_inches(self):
916         """
917         Returns the current size of the figure in inches.
918 
919         Returns
920         -------
921         size : ndarray
922            The size (width, height) of the figure in inches.
923 
924         See Also
925         --------
926         matplotlib.Figure.set_size_inches
927         """
928         return np.array(self.bbox_inches.p1)
929 
930     def get_edgecolor(self):
931         """Get the edge color of the Figure rectangle."""
932         return self.patch.get_edgecolor()
933 
934     def get_facecolor(self):
935         """Get the face color of the Figure rectangle."""
936         return self.patch.get_facecolor()
937 
938     def get_figwidth(self):
939         """Return the figure width as a float."""
940         return self.bbox_inches.width
941 
942     def get_figheight(self):
943         """Return the figure height as a float."""
944         return self.bbox_inches.height
945 
946     def get_dpi(self):
947         """Return the resolution in dots per inch as a float."""
948         return self.dpi
949 
950     def get_frameon(self):
951         """
952         Return the figure's background patch visibility, i.e.
953         whether the figure background will be drawn. Equivalent to
954         ``Figure.patch.get_visible()``.
955         """
956         return self.patch.get_visible()
957 
958     def set_edgecolor(self, color):
959         """
960         Set the edge color of the Figure rectangle.
961 
962         Parameters
963         ----------
964         color : color
965         """
966         self.patch.set_edgecolor(color)
967 
968     def set_facecolor(self, color):
969         """
970         Set the face color of the Figure rectangle.
971 
972         Parameters
973         ----------
974         color : color
975         """
976         self.patch.set_facecolor(color)
977 
978     def set_dpi(self, val):
979         """
980         Set the resolution of the figure in dots-per-inch.
981 
982         Parameters
983         ----------
984         val : float
985         """
986         self.dpi = val
987         self.stale = True
988 
989     def set_figwidth(self, val, forward=True):
990         """
991         Set the width of the figure in inches.
992 
993         Parameters
994         ----------
995         val : float
996         forward : bool
997         """
998         self.set_size_inches(val, self.get_figheight(), forward=forward)
999 
1000     def set_figheight(self, val, forward=True):
1001         """
1002         Set the height of the figure in inches.
1003 
1004         Parameters
1005         ----------
1006         val : float
1007         forward : bool
1008         """
1009         self.set_size_inches(self.get_figwidth(), val, forward=forward)
1010 
1011     def set_frameon(self, b):
1012         """
1013         Set the figure's background patch visibility, i.e.
1014         whether the figure background will be drawn. Equivalent to
1015         ``Figure.patch.set_visible()``.
1016 
1017         Parameters
1018         ----------
1019         b : bool
1020         """
1021         self.patch.set_visible(b)
1022         self.stale = True
1023 
1024     frameon = property(get_frameon, set_frameon)
1025 
1026     def delaxes(self, ax):
1027         """
1028         Remove the `~matplotlib.axes.Axes` *ax* from the figure and update the
1029         current axes.
1030         """
1031         self._axstack.remove(ax)
1032         for func in self._axobservers:
1033             func(self)
1034         self.stale = True
1035 
1036     def add_artist(self, artist, clip=False):
1037         """
1038         Add any :class:`~matplotlib.artist.Artist` to the figure.
1039 
1040         Usually artists are added to axes objects using
1041         :meth:`matplotlib.axes.Axes.add_artist`, but use this method in the
1042         rare cases that adding directly to the figure is necessary.
1043 
1044         Parameters
1045         ----------
1046         artist : `~matplotlib.artist.Artist`
1047             The artist to add to the figure. If the added artist has no
1048             transform previously set, its transform will be set to
1049             ``figure.transFigure``.
1050         clip : bool, optional, default ``False``
1051             An optional parameter ``clip`` determines whether the added artist
1052             should be clipped by the figure patch. Default is *False*,
1053             i.e. no clipping.
1054 
1055         Returns
1056         -------
1057         artist : The added `~matplotlib.artist.Artist`
1058         """
1059         artist.set_figure(self)
1060         self.artists.append(artist)
1061         artist._remove_method = self.artists.remove
1062 
1063         if not artist.is_transform_set():
1064             artist.set_transform(self.transFigure)
1065 
1066         if clip:
1067             artist.set_clip_path(self.patch)
1068 
1069         self.stale = True
1070         return artist
1071 
1072     def _make_key(self, *args, **kwargs):
1073         """Make a hashable key out of args and kwargs."""
1074 
1075         def fixitems(items):
1076             # items may have arrays and lists in them, so convert them
1077             # to tuples for the key
1078             ret = []
1079             for k, v in items:
1080                 # some objects can define __getitem__ without being
1081                 # iterable and in those cases the conversion to tuples
1082                 # will fail. So instead of using the np.iterable(v) function
1083                 # we simply try and convert to a tuple, and proceed if not.
1084                 try:
1085                     v = tuple(v)
1086                 except Exception:
1087                     pass
1088                 ret.append((k, v))
1089             return tuple(ret)
1090 
1091         def fixlist(args):
1092             ret = []
1093             for a in args:
1094                 if np.iterable(a):
1095                     a = tuple(a)
1096                 ret.append(a)
1097             return tuple(ret)
1098 
1099         key = fixlist(args), fixitems(kwargs.items())
1100         return key
1101 
1102     def _process_projection_requirements(
1103             self, *args, polar=False, projection=None, **kwargs):
1104         """
1105         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1106 
1107             (axes_proj_class, proj_class_kwargs, proj_stack_key)
1108 
1109         which can be used for new axes initialization/identification.
1110         """
1111         if polar:
1112             if projection is not None and projection != 'polar':
1113                 raise ValueError(
1114                     "polar=True, yet projection=%r. "
1115                     "Only one of these arguments should be supplied." %
1116                     projection)
1117             projection = 'polar'
1118 
1119         if isinstance(projection, str) or projection is None:
1120             projection_class = projections.get_projection_class(projection)
1121         elif hasattr(projection, '_as_mpl_axes'):
1122             projection_class, extra_kwargs = projection._as_mpl_axes()
1123             kwargs.update(**extra_kwargs)
1124         else:
1125             raise TypeError('projection must be a string, None or implement a '
1126                             '_as_mpl_axes method. Got %r' % projection)
1127 
1128         # Make the key without projection kwargs, this is used as a unique
1129         # lookup for axes instances
1130         key = self._make_key(*args, **kwargs)
1131 
1132         return projection_class, kwargs, key
1133 
1134     @docstring.dedent_interpd
1135     def add_axes(self, *args, **kwargs):
1136         """
1137         Add an axes to the figure.
1138 
1139         Call signatures::
1140 
1141             add_axes(rect, projection=None, polar=False, **kwargs)
1142             add_axes(ax)
1143 
1144         Parameters
1145         ----------
1146 
1147         rect : sequence of float
1148             The dimensions [left, bottom, width, height] of the new axes. All
1149             quantities are in fractions of figure width and height.
1150 
1151         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1152 'polar', 'rectilinear', str}, optional
1153             The projection type of the `~.axes.Axes`. *str* is the name of
1154             a custom projection, see `~matplotlib.projections`. The default
1155             None results in a 'rectilinear' projection.
1156 
1157         polar : boolean, optional
1158             If True, equivalent to projection='polar'.
1159 
1160         sharex, sharey : `~.axes.Axes`, optional
1161             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1162             The axis will have the same limits, ticks, and scale as the axis
1163             of the shared axes.
1164 
1165         label : str
1166             A label for the returned axes.
1167 
1168         Other Parameters
1169         ----------------
1170         **kwargs
1171             This method also takes the keyword arguments for
1172             the returned axes class. The keyword arguments for the
1173             rectilinear axes class `~.axes.Axes` can be found in
1174             the following table but there might also be other keyword
1175             arguments if another projection is used, see the actual axes
1176             class.
1177             %(Axes)s
1178 
1179         Returns
1180         -------
1181         axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
1182             The returned axes class depends on the projection used. It is
1183             `~.axes.Axes` if rectilinear projection are used and
1184             `.projections.polar.PolarAxes` if polar projection
1185             are used.
1186 
1187         Notes
1188         -----
1189         If the figure already has an axes with key (*args*,
1190         *kwargs*) then it will simply make that axes current and
1191         return it.  This behavior is deprecated. Meanwhile, if you do
1192         not want this behavior (i.e., you want to force the creation of a
1193         new axes), you must use a unique set of args and kwargs.  The axes
1194         *label* attribute has been exposed for this purpose: if you want
1195         two axes that are otherwise identical to be added to the figure,
1196         make sure you give them unique labels.
1197 
1198         In rare circumstances, `.add_axes` may be called with a single
1199         argument, a axes instance already created in the present figure but
1200         not in the figure's list of axes.
1201 
1202         See Also
1203         --------
1204         .Figure.add_subplot
1205         .pyplot.subplot
1206         .pyplot.axes
1207         .Figure.subplots
1208         .pyplot.subplots
1209 
1210         Examples
1211         --------
1212         Some simple examples::
1213 
1214             rect = l, b, w, h
1215             fig = plt.figure()
1216             fig.add_axes(rect,label=label1)
1217             fig.add_axes(rect,label=label2)
1218             fig.add_axes(rect, frameon=False, facecolor='g')
1219             fig.add_axes(rect, polar=True)
1220             ax=fig.add_axes(rect, projection='polar')
1221             fig.delaxes(ax)
1222             fig.add_axes(ax)
1223         """
1224 
1225         if not len(args):
1226             return
1227 
1228         # shortcut the projection "key" modifications later on, if an axes
1229         # with the exact args/kwargs exists, return it immediately.
1230         key = self._make_key(*args, **kwargs)
1231         ax = self._axstack.get(key)
1232         if ax is not None:
1233             self.sca(ax)
1234             return ax
1235 
1236         if isinstance(args[0], Axes):
1237             a = args[0]
1238             if a.get_figure() is not self:
1239                 raise ValueError(
1240                     "The Axes must have been created in the present figure")
1241         else:
1242             rect = args[0]
1243             if not np.isfinite(rect).all():
1244                 raise ValueError('all entries in rect must be finite '
1245                                  'not {}'.format(rect))
1246             projection_class, kwargs, key = \
1247                 self._process_projection_requirements(*args, **kwargs)
1248 
1249             # check that an axes of this type doesn't already exist, if it
1250             # does, set it as active and return it
1251             ax = self._axstack.get(key)
1252             if isinstance(ax, projection_class):
1253                 self.sca(ax)
1254                 return ax
1255 
1256             # create the new axes using the axes class given
1257             a = projection_class(self, rect, **kwargs)
1258 
1259         return self._add_axes_internal(key, a)
1260 
1261     @docstring.dedent_interpd
1262     def add_subplot(self, *args, **kwargs):
1263         """
1264         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
1265 
1266         Call signatures::
1267 
1268            add_subplot(nrows, ncols, index, **kwargs)
1269            add_subplot(pos, **kwargs)
1270            add_subplot(ax)
1271 
1272         Parameters
1273         ----------
1274         *args
1275             Either a 3-digit integer or three separate integers
1276             describing the position of the subplot. If the three
1277             integers are *nrows*, *ncols*, and *index* in order, the
1278             subplot will take the *index* position on a grid with *nrows*
1279             rows and *ncols* columns. *index* starts at 1 in the upper left
1280             corner and increases to the right.
1281 
1282             *pos* is a three digit integer, where the first digit is the
1283             number of rows, the second the number of columns, and the third
1284             the index of the subplot. i.e. fig.add_subplot(235) is the same as
1285             fig.add_subplot(2, 3, 5). Note that all integers must be less than
1286             10 for this form to work.
1287 
1288         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1289 'polar', 'rectilinear', str}, optional
1290             The projection type of the subplot (`~.axes.Axes`). *str* is the
1291             name of a custom projection, see `~matplotlib.projections`. The
1292             default None results in a 'rectilinear' projection.
1293 
1294         polar : boolean, optional
1295             If True, equivalent to projection='polar'.
1296 
1297         sharex, sharey : `~.axes.Axes`, optional
1298             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1299             The axis will have the same limits, ticks, and scale as the axis
1300             of the shared axes.
1301 
1302         label : str
1303             A label for the returned axes.
1304 
1305         Other Parameters
1306         ----------------
1307         **kwargs
1308             This method also takes the keyword arguments for
1309             the returned axes base class. The keyword arguments for the
1310             rectilinear base class `~.axes.Axes` can be found in
1311             the following table but there might also be other keyword
1312             arguments if another projection is used.
1313             %(Axes)s
1314 
1315         Returns
1316         -------
1317         axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a \
1318                subclass of `~.axes.Axes`)
1319 
1320             The axes of the subplot. The returned axes base class depends on
1321             the projection used. It is `~.axes.Axes` if rectilinear projection
1322             are used and `.projections.polar.PolarAxes` if polar projection
1323             are used. The returned axes is then a subplot subclass of the
1324             base class.
1325 
1326         Notes
1327         -----
1328         If the figure already has a subplot with key (*args*,
1329         *kwargs*) then it will simply make that subplot current and
1330         return it.  This behavior is deprecated. Meanwhile, if you do
1331         not want this behavior (i.e., you want to force the creation of a
1332         new subplot), you must use a unique set of args and kwargs.  The axes
1333         *label* attribute has been exposed for this purpose: if you want
1334         two subplots that are otherwise identical to be added to the figure,
1335         make sure you give them unique labels.
1336 
1337         In rare circumstances, `.add_subplot` may be called with a single
1338         argument, a subplot axes instance already created in the
1339         present figure but not in the figure's list of axes.
1340 
1341         See Also
1342         --------
1343         .Figure.add_axes
1344         .pyplot.subplot
1345         .pyplot.axes
1346         .Figure.subplots
1347         .pyplot.subplots
1348 
1349         Examples
1350         --------
1351         ::
1352 
1353             fig = plt.figure()
1354             fig.add_subplot(221)
1355 
1356             # equivalent but more general
1357             ax1 = fig.add_subplot(2, 2, 1)
1358 
1359             # add a subplot with no frame
1360             ax2 = fig.add_subplot(222, frameon=False)
1361 
1362             # add a polar subplot
1363             fig.add_subplot(223, projection='polar')
1364 
1365             # add a red subplot that share the x-axis with ax1
1366             fig.add_subplot(224, sharex=ax1, facecolor='red')
1367 
1368             #delete x2 from the figure
1369             fig.delaxes(ax2)
1370 
1371             #add x2 to the figure again
1372             fig.add_subplot(ax2)
1373         """
1374         if not len(args):
1375             args = (1, 1, 1)
1376 
1377         if len(args) == 1 and isinstance(args[0], Integral):
1378             if not 100 <= args[0] <= 999:
1379                 raise ValueError("Integer subplot specification must be a "
1380                                  "three-digit number, not {}".format(args[0]))
1381             args = tuple(map(int, str(args[0])))
1382 
1383         if isinstance(args[0], SubplotBase):
1384 
1385             a = args[0]
1386             if a.get_figure() is not self:
1387                 raise ValueError(
1388                     "The Subplot must have been created in the present figure")
1389             # make a key for the subplot (which includes the axes object id
1390             # in the hash)
1391             key = self._make_key(*args, **kwargs)
1392         else:
1393             projection_class, kwargs, key = \
1394                 self._process_projection_requirements(*args, **kwargs)
1395 
1396             # try to find the axes with this key in the stack
1397             ax = self._axstack.get(key)
1398 
1399             if ax is not None:
1400                 if isinstance(ax, projection_class):
1401                     # the axes already existed, so set it as active & return
1402                     self.sca(ax)
1403                     return ax
1404                 else:
1405                     # Undocumented convenience behavior:
1406                     # subplot(111); subplot(111, projection='polar')
1407                     # will replace the first with the second.
1408                     # Without this, add_subplot would be simpler and
1409                     # more similar to add_axes.
1410                     self._axstack.remove(ax)
1411 
1412             a = subplot_class_factory(projection_class)(self, *args, **kwargs)
1413 
1414         return self._add_axes_internal(key, a)
1415 
1416     def _add_axes_internal(self, key, ax):
1417         """Private helper for `add_axes` and `add_subplot`."""
1418         self._axstack.add(key, ax)
1419         self.sca(ax)
1420         ax._remove_method = self._remove_ax
1421         self.stale = True
1422         ax.stale_callback = _stale_figure_callback
1423         return ax
1424 
1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,
1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):
1427         """
1428         Add a set of subplots to this figure.
1429 
1430         This utility wrapper makes it convenient to create common layouts of
1431         subplots in a single call.
1432 
1433         Parameters
1434         ----------
1435         nrows, ncols : int, optional, default: 1
1436             Number of rows/columns of the subplot grid.
1437 
1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)
1440             axes:
1441 
1442                 - True or 'all': x- or y-axis will be shared among all
1443                   subplots.
1444                 - False or 'none': each subplot x- or y-axis will be
1445                   independent.
1446                 - 'row': each subplot row will share an x- or y-axis.
1447                 - 'col': each subplot column will share an x- or y-axis.
1448 
1449             When subplots have a shared x-axis along a column, only the x tick
1450             labels of the bottom subplot are created. Similarly, when subplots
1451             have a shared y-axis along a row, only the y tick labels of the
1452             first column subplot are created. To later turn other subplots'
1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
1454 
1455         squeeze : bool, optional, default: True
1456             - If True, extra dimensions are squeezed out from the returned
1457               array of Axes:
1458 
1459                 - if only one subplot is constructed (nrows=ncols=1), the
1460                   resulting single Axes object is returned as a scalar.
1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1462                   object array of Axes objects.
1463                 - for NxM, subplots with N>1 and M>1 are returned
1464                   as a 2D array.
1465 
1466             - If False, no squeezing at all is done: the returned Axes object
1467               is always a 2D array containing Axes instances, even if it ends
1468               up being 1x1.
1469 
1470         subplot_kw : dict, optional
1471             Dict with keywords passed to the
1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create
1473             each subplot.
1474 
1475         gridspec_kw : dict, optional
1476             Dict with keywords passed to the
1477             `~matplotlib.gridspec.GridSpec` constructor used to create
1478             the grid the subplots are placed on.
1479 
1480         Returns
1481         -------
1482         ax : `~.axes.Axes` object or array of Axes objects.
1483             *ax* can be either a single `~matplotlib.axes.Axes` object or
1484             an array of Axes objects if more than one subplot was created. The
1485             dimensions of the resulting array can be controlled with the
1486             squeeze keyword, see above.
1487 
1488         Examples
1489         --------
1490         ::
1491 
1492             # First create some toy data:
1493             x = np.linspace(0, 2*np.pi, 400)
1494             y = np.sin(x**2)
1495 
1496             # Create a figure
1497             plt.figure()
1498 
1499             # Creates a subplot
1500             ax = fig.subplots()
1501             ax.plot(x, y)
1502             ax.set_title('Simple plot')
1503 
1504             # Creates two subplots and unpacks the output array immediately
1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)
1506             ax1.plot(x, y)
1507             ax1.set_title('Sharing Y axis')
1508             ax2.scatter(x, y)
1509 
1510             # Creates four polar axes, and accesses them through the
1511             # returned array
1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))
1513             axes[0, 0].plot(x, y)
1514             axes[1, 1].scatter(x, y)
1515 
1516             # Share a X axis with each column of subplots
1517             fig.subplots(2, 2, sharex='col')
1518 
1519             # Share a Y axis with each row of subplots
1520             fig.subplots(2, 2, sharey='row')
1521 
1522             # Share both X and Y axes with all subplots
1523             fig.subplots(2, 2, sharex='all', sharey='all')
1524 
1525             # Note that this is the same as
1526             fig.subplots(2, 2, sharex=True, sharey=True)
1527 
1528             See Also
1529             --------
1530             .pyplot.subplots
1531             .Figure.add_subplot
1532             .pyplot.subplot
1533             """
1534 
1535         if isinstance(sharex, bool):
1536             sharex = "all" if sharex else "none"
1537         if isinstance(sharey, bool):
1538             sharey = "all" if sharey else "none"
1539         # This check was added because it is very easy to type
1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.
1541         # In most cases, no error will ever occur, but mysterious behavior
1542         # will result because what was intended to be the subplot index is
1543         # instead treated as a bool for sharex.
1544         if isinstance(sharex, Integral):
1545             cbook._warn_external(
1546                 "sharex argument to subplots() was an integer.  Did you "
1547                 "intend to use subplot() (without 's')?")
1548         cbook._check_in_list(["all", "row", "col", "none"],
1549                              sharex=sharex, sharey=sharey)
1550         if subplot_kw is None:
1551             subplot_kw = {}
1552         if gridspec_kw is None:
1553             gridspec_kw = {}
1554         # don't mutate kwargs passed by user...
1555         subplot_kw = subplot_kw.copy()
1556         gridspec_kw = gridspec_kw.copy()
1557 
1558         if self.get_constrained_layout():
1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)
1560         else:
1561             # this should turn constrained_layout off if we don't want it
1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)
1563         self._gridspecs.append(gs)
1564 
1565         # Create array to hold all axes.
1566         axarr = np.empty((nrows, ncols), dtype=object)
1567         for row in range(nrows):
1568             for col in range(ncols):
1569                 shared_with = {"none": None, "all": axarr[0, 0],
1570                                "row": axarr[row, 0], "col": axarr[0, col]}
1571                 subplot_kw["sharex"] = shared_with[sharex]
1572                 subplot_kw["sharey"] = shared_with[sharey]
1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)
1574 
1575         # turn off redundant tick labeling
1576         if sharex in ["col", "all"]:
1577             # turn off all but the bottom row
1578             for ax in axarr[:-1, :].flat:
1579                 ax.xaxis.set_tick_params(which='both',
1580                                          labelbottom=False, labeltop=False)
1581                 ax.xaxis.offsetText.set_visible(False)
1582         if sharey in ["row", "all"]:
1583             # turn off all but the first column
1584             for ax in axarr[:, 1:].flat:
1585                 ax.yaxis.set_tick_params(which='both',
1586                                          labelleft=False, labelright=False)
1587                 ax.yaxis.offsetText.set_visible(False)
1588 
1589         if squeeze:
1590             # Discarding unneeded dimensions that equal 1.  If we only have one
1591             # subplot, just return it instead of a 1-element array.
1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()
1593         else:
1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1595             return axarr
1596 
1597     def _remove_ax(self, ax):
1598         def _reset_loc_form(axis):
1599             axis.set_major_formatter(axis.get_major_formatter())
1600             axis.set_major_locator(axis.get_major_locator())
1601             axis.set_minor_formatter(axis.get_minor_formatter())
1602             axis.set_minor_locator(axis.get_minor_locator())
1603 
1604         def _break_share_link(ax, grouper):
1605             siblings = grouper.get_siblings(ax)
1606             if len(siblings) > 1:
1607                 grouper.remove(ax)
1608                 for last_ax in siblings:
1609                     if ax is not last_ax:
1610                         return last_ax
1611             return None
1612 
1613         self.delaxes(ax)
1614         last_ax = _break_share_link(ax, ax._shared_y_axes)
1615         if last_ax is not None:
1616             _reset_loc_form(last_ax.yaxis)
1617 
1618         last_ax = _break_share_link(ax, ax._shared_x_axes)
1619         if last_ax is not None:
1620             _reset_loc_form(last_ax.xaxis)
1621 
1622     def clf(self, keep_observers=False):
1623         """
1624         Clear the figure.
1625 
1626         Set *keep_observers* to True if, for example,
1627         a gui widget is tracking the axes in the figure.
1628         """
1629         self.suppressComposite = None
1630         self.callbacks = cbook.CallbackRegistry()
1631 
1632         for ax in tuple(self.axes):  # Iterate over the copy.
1633             ax.cla()
1634             self.delaxes(ax)         # removes ax from self._axstack
1635 
1636         toolbar = getattr(self.canvas, 'toolbar', None)
1637         if toolbar is not None:
1638             toolbar.update()
1639         self._axstack.clear()
1640         self.artists = []
1641         self.lines = []
1642         self.patches = []
1643         self.texts = []
1644         self.images = []
1645         self.legends = []
1646         if not keep_observers:
1647             self._axobservers = []
1648         self._suptitle = None
1649         if self.get_constrained_layout():
1650             layoutbox.nonetree(self._layoutbox)
1651         self.stale = True
1652 
1653     def clear(self, keep_observers=False):
1654         """
1655         Clear the figure -- synonym for :meth:`clf`.
1656         """
1657         self.clf(keep_observers=keep_observers)
1658 
1659     @allow_rasterization
1660     def draw(self, renderer):
1661         """
1662         Render the figure using :class:`matplotlib.backend_bases.RendererBase`
1663         instance *renderer*.
1664         """
1665 
1666         # draw the figure bounding box, perhaps none for white figure
1667         if not self.get_visible():
1668             return
1669 
1670         artists = self.get_children()
1671         artists.remove(self.patch)
1672         artists = sorted(
1673             (artist for artist in artists if not artist.get_animated()),
1674             key=lambda artist: artist.get_zorder())
1675 
1676         for ax in self.axes:
1677             locator = ax.get_axes_locator()
1678             if locator:
1679                 pos = locator(ax, renderer)
1680                 ax.apply_aspect(pos)
1681             else:
1682                 ax.apply_aspect()
1683 
1684             for child in ax.get_children():
1685                 if hasattr(child, 'apply_aspect'):
1686                     locator = child.get_axes_locator()
1687                     if locator:
1688                         pos = locator(child, renderer)
1689                         child.apply_aspect(pos)
1690                     else:
1691                         child.apply_aspect()
1692 
1693         try:
1694             renderer.open_group('figure')
1695             if self.get_constrained_layout() and self.axes:
1696                 self.execute_constrained_layout(renderer)
1697             if self.get_tight_layout() and self.axes:
1698                 try:
1699                     self.tight_layout(renderer,
1700                                       **self._tight_parameters)
1701                 except ValueError:
1702                     pass
1703                     # ValueError can occur when resizing a window.
1704 
1705             self.patch.draw(renderer)
1706             mimage._draw_list_compositing_images(
1707                 renderer, self, artists, self.suppressComposite)
1708 
1709             renderer.close_group('figure')
1710         finally:
1711             self.stale = False
1712 
1713         self._cachedRenderer = renderer
1714         self.canvas.draw_event(renderer)
1715 
1716     def draw_artist(self, a):
1717         """
1718         Draw :class:`matplotlib.artist.Artist` instance *a* only.
1719         This is available only after the figure is drawn.
1720         """
1721         if self._cachedRenderer is None:
1722             raise AttributeError("draw_artist can only be used after an "
1723                                  "initial draw which caches the renderer")
1724         a.draw(self._cachedRenderer)
1725 
1726     def get_axes(self):
1727         """
1728         Return a list of axes in the Figure. You can access and modify the
1729         axes in the Figure through this list.
1730 
1731         Do not modify the list itself. Instead, use `~Figure.add_axes`,
1732         `~.Figure.subplot` or `~.Figure.delaxes` to add or remove an axes.
1733 
1734         Note: This is equivalent to the property `~.Figure.axes`.
1735         """
1736         return self.axes
1737 
1738     # Note: in the docstring below, the newlines in the examples after the
1739     # calls to legend() allow replacing it with figlegend() to generate the
1740     # docstring of pyplot.figlegend.
1741 
1742     @docstring.dedent_interpd
1743     def legend(self, *args, **kwargs):
1744         """
1745         Place a legend on the figure.
1746 
1747         To make a legend from existing artists on every axes::
1748 
1749           legend()
1750 
1751         To make a legend for a list of lines and labels::
1752 
1753           legend(
1754               (line1, line2, line3),
1755               ('label1', 'label2', 'label3'),
1756               loc='upper right')
1757 
1758         These can also be specified by keyword::
1759 
1760           legend(
1761               handles=(line1, line2, line3),
1762               labels=('label1', 'label2', 'label3'),
1763               loc='upper right')
1764 
1765         Parameters
1766         ----------
1767 
1768         handles : sequence of `.Artist`, optional
1769             A list of Artists (lines, patches) to be added to the legend.
1770             Use this together with *labels*, if you need full control on what
1771             is shown in the legend and the automatic mechanism described above
1772             is not sufficient.
1773 
1774             The length of handles and labels should be the same in this
1775             case. If they are not, they are truncated to the smaller length.
1776 
1777         labels : sequence of strings, optional
1778             A list of labels to show next to the artists.
1779             Use this together with *handles*, if you need full control on what
1780             is shown in the legend and the automatic mechanism described above
1781             is not sufficient.
1782 
1783         Other Parameters
1784         ----------------
1785 
1786         %(_legend_kw_doc)s
1787 
1788         Returns
1789         -------
1790         :class:`matplotlib.legend.Legend` instance
1791 
1792         Notes
1793         -----
1794         Not all kinds of artist are supported by the legend command. See
1795         :doc:`/tutorials/intermediate/legend_guide` for details.
1796         """
1797 
1798         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1799                 self.axes,
1800                 *args,
1801                 **kwargs)
1802         # check for third arg
1803         if len(extra_args):
1804             # cbook.warn_deprecated(
1805             #     "2.1",
1806             #     message="Figure.legend will accept no more than two "
1807             #     "positional arguments in the future.  Use "
1808             #     "'fig.legend(handles, labels, loc=location)' "
1809             #     "instead.")
1810             # kwargs['loc'] = extra_args[0]
1811             # extra_args = extra_args[1:]
1812             pass
1813         l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)
1814         self.legends.append(l)
1815         l._remove_method = self.legends.remove
1816         self.stale = True
1817         return l
1818 
1819     @cbook._delete_parameter("3.1", "withdash")
1820     @docstring.dedent_interpd
1821     def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):
1822         """
1823         Add text to figure.
1824 
1825         Parameters
1826         ----------
1827         x, y : float
1828             The position to place the text. By default, this is in figure
1829             coordinates, floats in [0, 1]. The coordinate system can be changed
1830             using the *transform* keyword.
1831 
1832         s : str
1833             The text string.
1834 
1835         fontdict : dictionary, optional, default: None
1836             A dictionary to override the default text properties. If fontdict
1837             is None, the defaults are determined by your rc parameters. A
1838             property in *kwargs* override the same property in fontdict.
1839 
1840         withdash : boolean, optional, default: False
1841             Creates a `~matplotlib.text.TextWithDash` instance instead of a
1842             `~matplotlib.text.Text` instance.
1843 
1844         Other Parameters
1845         ----------------
1846         **kwargs : `~matplotlib.text.Text` properties
1847             Other miscellaneous text parameters.
1848             %(Text)s
1849 
1850         Returns
1851         -------
1852         text : `~.text.Text`
1853 
1854         See Also
1855         --------
1856         .Axes.text
1857         .pyplot.text
1858         """
1859         default = dict(transform=self.transFigure)
1860 
1861         if withdash:
1862             text = TextWithDash(x=x, y=y, text=s)
1863         else:
1864             text = Text(x=x, y=y, text=s)
1865 
1866         text.update(default)
1867         if fontdict is not None:
1868             text.update(fontdict)
1869         text.update(kwargs)
1870 
1871         text.set_figure(self)
1872         text.stale_callback = _stale_figure_callback
1873 
1874         self.texts.append(text)
1875         text._remove_method = self.texts.remove
1876         self.stale = True
1877         return text
1878 
1879     def _set_artist_props(self, a):
1880         if a != self:
1881             a.set_figure(self)
1882         a.stale_callback = _stale_figure_callback
1883         a.set_transform(self.transFigure)
1884 
1885     @docstring.dedent_interpd
1886     def gca(self, **kwargs):
1887         """
1888         Get the current axes, creating one if necessary.
1889 
1890         The following kwargs are supported for ensuring the returned axes
1891         adheres to the given projection etc., and for axes creation if
1892         the active axes does not exist:
1893 
1894         %(Axes)s
1895 
1896         """
1897         ckey, cax = self._axstack.current_key_axes()
1898         # if there exists an axes on the stack see if it matches
1899         # the desired axes configuration
1900         if cax is not None:
1901 
1902             # if no kwargs are given just return the current axes
1903             # this is a convenience for gca() on axes such as polar etc.
1904             if not kwargs:
1905                 return cax
1906 
1907             # if the user has specified particular projection detail
1908             # then build up a key which can represent this
1909             else:
1910                 projection_class, _, key = \
1911                     self._process_projection_requirements(**kwargs)
1912 
1913                 # let the returned axes have any gridspec by removing it from
1914                 # the key
1915                 ckey = ckey[1:]
1916                 key = key[1:]
1917 
1918                 # if the cax matches this key then return the axes, otherwise
1919                 # continue and a new axes will be created
1920                 if key == ckey and isinstance(cax, projection_class):
1921                     return cax
1922                 else:
1923                     cbook._warn_external('Requested projection is different '
1924                                          'from current axis projection, '
1925                                          'creating new axis with requested '
1926                                          'projection.')
1927 
1928         # no axes found, so create one which spans the figure
1929         return self.add_subplot(1, 1, 1, **kwargs)
1930 
1931     def sca(self, a):
1932         """Set the current axes to be a and return a."""
1933         self._axstack.bubble(a)
1934         for func in self._axobservers:
1935             func(self)
1936         return a
1937 
1938     def _gci(self):
1939         """
1940         Helper for :func:`~matplotlib.pyplot.gci`. Do not use elsewhere.
1941         """
1942         # Look first for an image in the current Axes:
1943         cax = self._axstack.current_key_axes()[1]
1944         if cax is None:
1945             return None
1946         im = cax._gci()
1947         if im is not None:
1948             return im
1949 
1950         # If there is no image in the current Axes, search for
1951         # one in a previously created Axes.  Whether this makes
1952         # sense is debatable, but it is the documented behavior.
1953         for ax in reversed(self.axes):
1954             im = ax._gci()
1955             if im is not None:
1956                 return im
1957         return None
1958 
1959     def __getstate__(self):
1960         state = super().__getstate__()
1961 
1962         # the axobservers cannot currently be pickled.
1963         # Additionally, the canvas cannot currently be pickled, but this has
1964         # the benefit of meaning that a figure can be detached from one canvas,
1965         # and re-attached to another.
1966         for attr_to_pop in ('_axobservers', 'show',
1967                             'canvas', '_cachedRenderer'):
1968             state.pop(attr_to_pop, None)
1969 
1970         # add version information to the state
1971         state['__mpl_version__'] = _mpl_version
1972 
1973         # check whether the figure manager (if any) is registered with pyplot
1974         from matplotlib import _pylab_helpers
1975         if getattr(self.canvas, 'manager', None) \
1976                 in _pylab_helpers.Gcf.figs.values():
1977             state['_restore_to_pylab'] = True
1978 
1979         # set all the layoutbox information to None.  kiwisolver objects can't
1980         # be pickled, so we lose the layout options at this point.
1981         state.pop('_layoutbox', None)
1982         # suptitle:
1983         if self._suptitle is not None:
1984             self._suptitle._layoutbox = None
1985 
1986         return state
1987 
1988     def __setstate__(self, state):
1989         version = state.pop('__mpl_version__')
1990         restore_to_pylab = state.pop('_restore_to_pylab', False)
1991 
1992         if version != _mpl_version:
1993             cbook._warn_external(
1994                 f"This figure was saved with matplotlib version {version} and "
1995                 f"is unlikely to function correctly.")
1996 
1997         self.__dict__ = state
1998 
1999         # re-initialise some of the unstored state information
2000         self._axobservers = []
2001         self.canvas = None
2002         self._layoutbox = None
2003 
2004         if restore_to_pylab:
2005             # lazy import to avoid circularity
2006             import matplotlib.pyplot as plt
2007             import matplotlib._pylab_helpers as pylab_helpers
2008             allnums = plt.get_fignums()
2009             num = max(allnums) + 1 if allnums else 1
2010             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)
2011 
2012             # XXX The following is a copy and paste from pyplot. Consider
2013             # factoring to pylab_helpers
2014 
2015             if self.get_label():
2016                 mgr.set_window_title(self.get_label())
2017 
2018             # make this figure current on button press event
2019             def make_active(event):
2020                 pylab_helpers.Gcf.set_active(mgr)
2021 
2022             mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',
2023                                                  make_active)
2024 
2025             pylab_helpers.Gcf.set_active(mgr)
2026             self.number = num
2027 
2028             plt.draw_if_interactive()
2029         self.stale = True
2030 
2031     def add_axobserver(self, func):
2032         """Whenever the axes state change, ``func(self)`` will be called."""
2033         self._axobservers.append(func)
2034 
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])
2186 
2187     @docstring.dedent_interpd
2188     def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):
2189         """
2190         Create a colorbar for a ScalarMappable instance, *mappable*.
2191 
2192         Documentation for the pyplot thin wrapper:
2193         %(colorbar_doc)s
2194         """
2195         if ax is None:
2196             ax = self.gca()
2197 
2198         # Store the value of gca so that we can set it back later on.
2199         current_ax = self.gca()
2200 
2201         if cax is None:
2202             if use_gridspec and isinstance(ax, SubplotBase)  \
2203                      and (not self.get_constrained_layout()):
2204                 cax, kw = cbar.make_axes_gridspec(ax, **kw)
2205             else:
2206                 cax, kw = cbar.make_axes(ax, **kw)
2207 
2208         # need to remove kws that cannot be passed to Colorbar
2209         NON_COLORBAR_KEYS = ['fraction', 'pad', 'shrink', 'aspect', 'anchor',
2210                              'panchor']
2211         cb_kw = {k: v for k, v in kw.items() if k not in NON_COLORBAR_KEYS}
2212         cb = cbar.colorbar_factory(cax, mappable, **cb_kw)
2213 
2214         self.sca(current_ax)
2215         self.stale = True
2216         return cb
2217 
2218     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
2219                         wspace=None, hspace=None):
2220         """
2221         Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when
2222         *None*) and update the subplot locations.
2223 
2224         """
2225         if self.get_constrained_layout():
2226             self.set_constrained_layout(False)
2227             cbook._warn_external("This figure was using "
2228                                  "constrained_layout==True, but that is "
2229                                  "incompatible with subplots_adjust and or "
2230                                  "tight_layout: setting "
2231                                  "constrained_layout==False. ")
2232         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
2233         for ax in self.axes:
2234             if not isinstance(ax, SubplotBase):
2235                 # Check if sharing a subplots axis
2236                 if isinstance(ax._sharex, SubplotBase):
2237                     ax._sharex.update_params()
2238                     ax.set_position(ax._sharex.figbox)
2239                 elif isinstance(ax._sharey, SubplotBase):
2240                     ax._sharey.update_params()
2241                     ax.set_position(ax._sharey.figbox)
2242             else:
2243                 ax.update_params()
2244                 ax.set_position(ax.figbox)
2245         self.stale = True
2246 
2247     def ginput(self, n=1, timeout=30, show_clicks=True, mouse_add=1,
2248                mouse_pop=3, mouse_stop=2):
2249         """
2250         Blocking call to interact with a figure.
2251 
2252         Wait until the user clicks *n* times on the figure, and return the
2253         coordinates of each click in a list.
2254 
2255         There are three possible interactions:
2256 
2257         - Add a point.
2258         - Remove the most recently added point.
2259         - Stop the interaction and return the points added so far.
2260 
2261         The actions are assigned to mouse buttons via the arguments
2262         *mouse_add*, *mouse_pop* and *mouse_stop*. Mouse buttons are defined
2263         by the numbers:
2264 
2265         - 1: left mouse button
2266         - 2: middle mouse button
2267         - 3: right mouse button
2268         - None: no mouse button
2269 
2270         Parameters
2271         ----------
2272         n : int, optional, default: 1
2273             Number of mouse clicks to accumulate. If negative, accumulate
2274             clicks until the input is terminated manually.
2275         timeout : scalar, optional, default: 30
2276             Number of seconds to wait before timing out. If zero or negative
2277             will never timeout.
2278         show_clicks : bool, optional, default: False
2279             If True, show a red cross at the location of each click.
2280         mouse_add : {1, 2, 3, None}, optional, default: 1 (left click)
2281             Mouse button used to add points.
2282         mouse_pop : {1, 2, 3, None}, optional, default: 3 (right click)
2283             Mouse button used to remove the most recently added point.
2284         mouse_stop : {1, 2, 3, None}, optional, default: 2 (middle click)
2285             Mouse button used to stop input.
2286 
2287         Returns
2288         -------
2289         points : list of tuples
2290             A list of the clicked (x, y) coordinates.
2291 
2292         Notes
2293         -----
2294         The keyboard can also be used to select points in case your mouse
2295         does not have one or more of the buttons.  The delete and backspace
2296         keys act like right clicking (i.e., remove last point), the enter key
2297         terminates input and any other key (not already used by the window
2298         manager) selects a point.
2299         """
2300         blocking_mouse_input = BlockingMouseInput(self,
2301                                                   mouse_add=mouse_add,
2302                                                   mouse_pop=mouse_pop,
2303                                                   mouse_stop=mouse_stop)
2304         return blocking_mouse_input(n=n, timeout=timeout,
2305                                     show_clicks=show_clicks)
2306 
2307     def waitforbuttonpress(self, timeout=-1):
2308         """
2309         Blocking call to interact with the figure.
2310 
2311         This will return True is a key was pressed, False if a mouse
2312         button was pressed and None if *timeout* was reached without
2313         either being pressed.
2314 
2315         If *timeout* is negative, does not timeout.
2316         """
2317         blocking_input = BlockingKeyMouseInput(self)
2318         return blocking_input(timeout=timeout)
2319 
2320     def get_default_bbox_extra_artists(self):
2321         bbox_artists = [artist for artist in self.get_children()
2322                         if (artist.get_visible() and artist.get_in_layout())]
2323         for ax in self.axes:
2324             if ax.get_visible():
2325                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
2326         # we don't want the figure's patch to influence the bbox calculation
2327         bbox_artists.remove(self.patch)
2328         return bbox_artists
2329 
2330     def get_tightbbox(self, renderer, bbox_extra_artists=None):
2331         """
2332         Return a (tight) bounding box of the figure in inches.
2333 
2334         Artists that have ``artist.set_in_layout(False)`` are not included
2335         in the bbox.
2336 
2337         Parameters
2338         ----------
2339         renderer : `.RendererBase` instance
2340             renderer that will be used to draw the figures (i.e.
2341             ``fig.canvas.get_renderer()``)
2342 
2343         bbox_extra_artists : list of `.Artist` or ``None``
2344             List of artists to include in the tight bounding box.  If
2345             ``None`` (default), then all artist children of each axes are
2346             included in the tight bounding box.
2347 
2348         Returns
2349         -------
2350         bbox : `.BboxBase`
2351             containing the bounding box (in figure inches).
2352         """
2353 
2354         bb = []
2355         if bbox_extra_artists is None:
2356             artists = self.get_default_bbox_extra_artists()
2357         else:
2358             artists = bbox_extra_artists
2359 
2360         for a in artists:
2361             bbox = a.get_tightbbox(renderer)
2362             if bbox is not None and (bbox.width != 0 or bbox.height != 0):
2363                 bb.append(bbox)
2364 
2365         for ax in self.axes:
2366             if ax.get_visible():
2367                 # some axes don't take the bbox_extra_artists kwarg so we
2368                 # need this conditional....
2369                 try:
2370                     bbox = ax.get_tightbbox(renderer,
2371                             bbox_extra_artists=bbox_extra_artists)
2372                 except TypeError:
2373                     bbox = ax.get_tightbbox(renderer)
2374                 bb.append(bbox)
2375         bb = [b for b in bb
2376               if (np.isfinite(b.width) and np.isfinite(b.height)
2377                   and (b.width != 0 or b.height != 0))]
2378 
2379         if len(bb) == 0:
2380             return self.bbox_inches
2381 
2382         _bbox = Bbox.union(bb)
2383 
2384         bbox_inches = TransformedBbox(_bbox,
2385                                       Affine2D().scale(1. / self.dpi))
2386 
2387         return bbox_inches
2388 
2389     def init_layoutbox(self):
2390         """Initialize the layoutbox for use in constrained_layout."""
2391         if self._layoutbox is None:
2392             self._layoutbox = layoutbox.LayoutBox(parent=None,
2393                                      name='figlb',
2394                                      artist=self)
2395             self._layoutbox.constrain_geometry(0., 0., 1., 1.)
2396 
2397     def execute_constrained_layout(self, renderer=None):
2398         """
2399         Use ``layoutbox`` to determine pos positions within axes.
2400 
2401         See also `.set_constrained_layout_pads`.
2402         """
2403 
2404         from matplotlib._constrained_layout import do_constrained_layout
2405 
2406         _log.debug('Executing constrainedlayout')
2407         if self._layoutbox is None:
2408             cbook._warn_external("Calling figure.constrained_layout, but "
2409                                  "figure not setup to do constrained layout. "
2410                                  " You either called GridSpec without the "
2411                                  "fig keyword, you are using plt.subplot, "
2412                                  "or you need to call figure or subplots "
2413                                  "with the constrained_layout=True kwarg.")
2414             return
2415         w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()
2416         # convert to unit-relative lengths
2417         fig = self
2418         width, height = fig.get_size_inches()
2419         w_pad = w_pad / width
2420         h_pad = h_pad / height
2421         if renderer is None:
2422             renderer = layoutbox.get_renderer(fig)
2423         do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)
2424 
2425     def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,
2426                      rect=None):
2427         """
2428         Automatically adjust subplot parameters to give specified padding.
2429 
2430         To exclude an artist on the axes from the bounding box calculation
2431         that determines the subplot parameters (i.e. legend, or annotation),
2432         then set `a.set_in_layout(False)` for that artist.
2433 
2434         Parameters
2435         ----------
2436         renderer : subclass of `~.backend_bases.RendererBase`, optional
2437             Defaults to the renderer for the figure.
2438 
2439         pad : float, optional
2440             Padding between the figure edge and the edges of subplots,
2441             as a fraction of the font size.
2442         h_pad, w_pad : float, optional
2443             Padding (height/width) between edges of adjacent subplots,
2444             as a fraction of the font size.  Defaults to *pad*.
2445         rect : tuple (left, bottom, right, top), optional
2446             A rectangle (left, bottom, right, top) in the normalized
2447             figure coordinate that the whole subplots area (including
2448             labels) will fit into. Default is (0, 0, 1, 1).
2449 
2450         See Also
2451         --------
2452         .Figure.set_tight_layout
2453         .pyplot.tight_layout
2454         """
2455 
2456         from .tight_layout import (
2457             get_renderer, get_subplotspec_list, get_tight_layout_figure)
2458 
2459         subplotspec_list = get_subplotspec_list(self.axes)
2460         if None in subplotspec_list:
2461             cbook._warn_external("This figure includes Axes that are not "
2462                                  "compatible with tight_layout, so results "
2463                                  "might be incorrect.")
2464 
2465         if renderer is None:
2466             renderer = get_renderer(self)
2467 
2468         kwargs = get_tight_layout_figure(
2469             self, self.axes, subplotspec_list, renderer,
2470             pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2471         if kwargs:
2472             self.subplots_adjust(**kwargs)
2473 
2474     def align_xlabels(self, axs=None):
2475         """
2476         Align the ylabels of subplots in the same subplot column if label
2477         alignment is being done automatically (i.e. the label position is
2478         not manually set).
2479 
2480         Alignment persists for draw events after this is called.
2481 
2482         If a label is on the bottom, it is aligned with labels on axes that
2483         also have their label on the bottom and that have the same
2484         bottom-most subplot row.  If the label is on the top,
2485         it is aligned with labels on axes with the same top-most row.
2486 
2487         Parameters
2488         ----------
2489         axs : list of `~matplotlib.axes.Axes`
2490             Optional list of (or ndarray) `~matplotlib.axes.Axes`
2491             to align the xlabels.
2492             Default is to align all axes on the figure.
2493 
2494         See Also
2495         --------
2496         matplotlib.figure.Figure.align_ylabels
2497 
2498         matplotlib.figure.Figure.align_labels
2499 
2500         Notes
2501         -----
2502         This assumes that ``axs`` are from the same `.GridSpec`, so that
2503         their `.SubplotSpec` positions correspond to figure positions.
2504 
2505         Examples
2506         --------
2507         Example with rotated xtick labels::
2508 
2509             fig, axs = plt.subplots(1, 2)
2510             for tick in axs[0].get_xticklabels():
2511                 tick.set_rotation(55)
2512             axs[0].set_xlabel('XLabel 0')
2513             axs[1].set_xlabel('XLabel 1')
2514             fig.align_xlabels()
2515 
2516         """
2517 
2518         if axs is None:
2519             axs = self.axes
2520         axs = np.asarray(axs).ravel()
2521         for ax in axs:
2522             _log.debug(' Working on: %s', ax.get_xlabel())
2523             ss = ax.get_subplotspec()
2524             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2525             labpo = ax.xaxis.get_label_position()  # top or bottom
2526 
2527             # loop through other axes, and search for label positions
2528             # that are same as this one, and that share the appropriate
2529             # row number.
2530             #  Add to a grouper associated with each axes of sibblings.
2531             # This list is inspected in `axis.draw` by
2532             # `axis._update_label_position`.
2533             for axc in axs:
2534                 if axc.xaxis.get_label_position() == labpo:
2535                     ss = axc.get_subplotspec()
2536                     nrows, ncols, rowc0, rowc1, colc, col1 = \
2537                             ss.get_rows_columns()
2538                     if (labpo == 'bottom' and rowc1 == row1 or
2539                         labpo == 'top' and rowc0 == row0):
2540                         # grouper for groups of xlabels to align
2541                         self._align_xlabel_grp.join(ax, axc)
2542 
2543     def align_ylabels(self, axs=None):
2544         """
2545         Align the ylabels of subplots in the same subplot column if label
2546         alignment is being done automatically (i.e. the label position is
2547         not manually set).
2548 
2549         Alignment persists for draw events after this is called.
2550 
2551         If a label is on the left, it is aligned with labels on axes that
2552         also have their label on the left and that have the same
2553         left-most subplot column.  If the label is on the right,
2554         it is aligned with labels on axes with the same right-most column.
2555 
2556         Parameters
2557         ----------
2558         axs : list of `~matplotlib.axes.Axes`
2559             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2560             to align the ylabels.
2561             Default is to align all axes on the figure.
2562 
2563         See Also
2564         --------
2565         matplotlib.figure.Figure.align_xlabels
2566 
2567         matplotlib.figure.Figure.align_labels
2568 
2569         Notes
2570         -----
2571         This assumes that ``axs`` are from the same `.GridSpec`, so that
2572         their `.SubplotSpec` positions correspond to figure positions.
2573 
2574         Examples
2575         --------
2576         Example with large yticks labels::
2577 
2578             fig, axs = plt.subplots(2, 1)
2579             axs[0].plot(np.arange(0, 1000, 50))
2580             axs[0].set_ylabel('YLabel 0')
2581             axs[1].set_ylabel('YLabel 1')
2582             fig.align_ylabels()
2583 
2584         """
2585 
2586         if axs is None:
2587             axs = self.axes
2588         axs = np.asarray(axs).ravel()
2589         for ax in axs:
2590             _log.debug(' Working on: %s', ax.get_ylabel())
2591             ss = ax.get_subplotspec()
2592             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2593             labpo = ax.yaxis.get_label_position()  # left or right
2594             # loop through other axes, and search for label positions
2595             # that are same as this one, and that share the appropriate
2596             # column number.
2597             # Add to a list associated with each axes of sibblings.
2598             # This list is inspected in `axis.draw` by
2599             # `axis._update_label_position`.
2600             for axc in axs:
2601                 if axc != ax:
2602                     if axc.yaxis.get_label_position() == labpo:
2603                         ss = axc.get_subplotspec()
2604                         nrows, ncols, row0, row1, colc0, colc1 = \
2605                                 ss.get_rows_columns()
2606                         if (labpo == 'left' and colc0 == col0 or
2607                             labpo == 'right' and colc1 == col1):
2608                             # grouper for groups of ylabels to align
2609                             self._align_ylabel_grp.join(ax, axc)
2610 
2611     def align_labels(self, axs=None):
2612         """
2613         Align the xlabels and ylabels of subplots with the same subplots
2614         row or column (respectively) if label alignment is being
2615         done automatically (i.e. the label position is not manually set).
2616 
2617         Alignment persists for draw events after this is called.
2618 
2619         Parameters
2620         ----------
2621         axs : list of `~matplotlib.axes.Axes`
2622             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2623             to align the labels.
2624             Default is to align all axes on the figure.
2625 
2626         See Also
2627         --------
2628         matplotlib.figure.Figure.align_xlabels
2629 
2630         matplotlib.figure.Figure.align_ylabels
2631         """
2632         self.align_xlabels(axs=axs)
2633         self.align_ylabels(axs=axs)
2634 
2635     def add_gridspec(self, nrows, ncols, **kwargs):
2636         """
2637         Return a `.GridSpec` that has this figure as a parent.  This allows
2638         complex layout of axes in the figure.
2639 
2640         Parameters
2641         ----------
2642         nrows : int
2643             Number of rows in grid.
2644 
2645         ncols : int
2646             Number or columns in grid.
2647 
2648         Returns
2649         -------
2650         gridspec : `.GridSpec`
2651 
2652         Other Parameters
2653         ----------------
2654         **kwargs
2655             Keyword arguments are passed to `.GridSpec`.
2656 
2657         See Also
2658         --------
2659         matplotlib.pyplot.subplots
2660 
2661         Examples
2662         --------
2663         Adding a subplot that spans two rows::
2664 
2665             fig = plt.figure()
2666             gs = fig.add_gridspec(2, 2)
2667             ax1 = fig.add_subplot(gs[0, 0])
2668             ax2 = fig.add_subplot(gs[1, 0])
2669             # spans two rows:
2670             ax3 = fig.add_subplot(gs[:, 1])
2671 
2672         """
2673 
2674         _ = kwargs.pop('figure', None)  # pop in case user has added this...
2675         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
2676         self._gridspecs.append(gs)
2677         return gs

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>savefig</method>
<code>
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])

</code><intended_behavior>The `savefig` method across its various implementations should include a pre-save validation process that checks if the figure dimensions (width and height) are valid (i.e., greater than zero). If the dimensions are not valid, it should raise an informative `RuntimeError` or a `ValueError` explaining that saving a figure requires both width and height to be positive numbers. This change will prevent unhandled low-level errors (e.g., from libpng) by catching the issue at the matplotlib level, thereby providing a more informative error message to the user. This intended behavior also maintains the functionality of the method while enforcing a check that aligns with the requirements of dependent libraries like libpng.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>savefig</method>
<code>
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])

</code><intended_behavior>The `savefig` method across its various implementations should include a pre-save validation process that checks if the figure dimensions (width and height) are valid (i.e., greater than zero). If the dimensions are not valid, it should raise an informative `RuntimeError` or a `ValueError` explaining that saving a figure requires both width and height to be positive numbers. This change will prevent unhandled low-level errors (e.g., from libpng) by catching the issue at the matplotlib level, thereby providing a more informative error message to the user. This intended behavior also maintains the functionality of the method while enforcing a check that aligns with the requirements of dependent libraries like libpng.</intended_behavior>]
2025-10-15 07:08:22.179 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>subplots</method>
<code>
1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,
1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):
1427         """
1428         Add a set of subplots to this figure.
1429 
1430         This utility wrapper makes it convenient to create common layouts of
1431         subplots in a single call.
1432 
1433         Parameters
1434         ----------
1435         nrows, ncols : int, optional, default: 1
1436             Number of rows/columns of the subplot grid.
1437 
1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)
1440             axes:
1441 
1442                 - True or 'all': x- or y-axis will be shared among all
1443                   subplots.
1444                 - False or 'none': each subplot x- or y-axis will be
1445                   independent.
1446                 - 'row': each subplot row will share an x- or y-axis.
1447                 - 'col': each subplot column will share an x- or y-axis.
1448 
1449             When subplots have a shared x-axis along a column, only the x tick
1450             labels of the bottom subplot are created. Similarly, when subplots
1451             have a shared y-axis along a row, only the y tick labels of the
1452             first column subplot are created. To later turn other subplots'
1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
1454 
1455         squeeze : bool, optional, default: True
1456             - If True, extra dimensions are squeezed out from the returned
1457               array of Axes:
1458 
1459                 - if only one subplot is constructed (nrows=ncols=1), the
1460                   resulting single Axes object is returned as a scalar.
1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1462                   object array of Axes objects.
1463                 - for NxM, subplots with N>1 and M>1 are returned
1464                   as a 2D array.
1465 
1466             - If False, no squeezing at all is done: the returned Axes object
1467               is always a 2D array containing Axes instances, even if it ends
1468               up being 1x1.
1469 
1470         subplot_kw : dict, optional
1471             Dict with keywords passed to the
1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create
1473             each subplot.
1474 
1475         gridspec_kw : dict, optional
1476             Dict with keywords passed to the
1477             `~matplotlib.gridspec.GridSpec` constructor used to create
1478             the grid the subplots are placed on.
1479 
1480         Returns
1481         -------
1482         ax : `~.axes.Axes` object or array of Axes objects.
1483             *ax* can be either a single `~matplotlib.axes.Axes` object or
1484             an array of Axes objects if more than one subplot was created. The
1485             dimensions of the resulting array can be controlled with the
1486             squeeze keyword, see above.
1487 
1488         Examples
1489         --------
1490         ::
1491 
1492             # First create some toy data:
1493             x = np.linspace(0, 2*np.pi, 400)
1494             y = np.sin(x**2)
1495 
1496             # Create a figure
1497             plt.figure()
1498 
1499             # Creates a subplot
1500             ax = fig.subplots()
1501             ax.plot(x, y)
1502             ax.set_title('Simple plot')
1503 
1504             # Creates two subplots and unpacks the output array immediately
1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)
1506             ax1.plot(x, y)
1507             ax1.set_title('Sharing Y axis')
1508             ax2.scatter(x, y)
1509 
1510             # Creates four polar axes, and accesses them through the
1511             # returned array
1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))
1513             axes[0, 0].plot(x, y)
1514             axes[1, 1].scatter(x, y)
1515 
1516             # Share a X axis with each column of subplots
1517             fig.subplots(2, 2, sharex='col')
1518 
1519             # Share a Y axis with each row of subplots
1520             fig.subplots(2, 2, sharey='row')
1521 
1522             # Share both X and Y axes with all subplots
1523             fig.subplots(2, 2, sharex='all', sharey='all')
1524 
1525             # Note that this is the same as
1526             fig.subplots(2, 2, sharex=True, sharey=True)
1527 
1528             See Also
1529             --------
1530             .pyplot.subplots
1531             .Figure.add_subplot
1532             .pyplot.subplot
1533             """
1534 
1535         if isinstance(sharex, bool):
1536             sharex = "all" if sharex else "none"
1537         if isinstance(sharey, bool):
1538             sharey = "all" if sharey else "none"
1539         # This check was added because it is very easy to type
1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.
1541         # In most cases, no error will ever occur, but mysterious behavior
1542         # will result because what was intended to be the subplot index is
1543         # instead treated as a bool for sharex.
1544         if isinstance(sharex, Integral):
1545             cbook._warn_external(
1546                 "sharex argument to subplots() was an integer.  Did you "
1547                 "intend to use subplot() (without 's')?")
1548         cbook._check_in_list(["all", "row", "col", "none"],
1549                              sharex=sharex, sharey=sharey)
1550         if subplot_kw is None:
1551             subplot_kw = {}
1552         if gridspec_kw is None:
1553             gridspec_kw = {}
1554         # don't mutate kwargs passed by user...
1555         subplot_kw = subplot_kw.copy()
1556         gridspec_kw = gridspec_kw.copy()
1557 
1558         if self.get_constrained_layout():
1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)
1560         else:
1561             # this should turn constrained_layout off if we don't want it
1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)
1563         self._gridspecs.append(gs)
1564 
1565         # Create array to hold all axes.
1566         axarr = np.empty((nrows, ncols), dtype=object)
1567         for row in range(nrows):
1568             for col in range(ncols):
1569                 shared_with = {"none": None, "all": axarr[0, 0],
1570                                "row": axarr[row, 0], "col": axarr[0, col]}
1571                 subplot_kw["sharex"] = shared_with[sharex]
1572                 subplot_kw["sharey"] = shared_with[sharey]
1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)
1574 
1575         # turn off redundant tick labeling
1576         if sharex in ["col", "all"]:
1577             # turn off all but the bottom row
1578             for ax in axarr[:-1, :].flat:
1579                 ax.xaxis.set_tick_params(which='both',
1580                                          labelbottom=False, labeltop=False)
1581                 ax.xaxis.offsetText.set_visible(False)
1582         if sharey in ["row", "all"]:
1583             # turn off all but the first column
1584             for ax in axarr[:, 1:].flat:
1585                 ax.yaxis.set_tick_params(which='both',
1586                                          labelleft=False, labelright=False)
1587                 ax.yaxis.offsetText.set_visible(False)
1588 
1589         if squeeze:
1590             # Discarding unneeded dimensions that equal 1.  If we only have one
1591             # subplot, just return it instead of a 1-element array.
1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()
1593         else:
1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1595             return axarr

</code><intended_behavior>This method should include validation for the `figsize` argument to ensure that both width and height are positive numbers. Since it currently allows creating figures with zero or negative dimensions, leading to errors when saving, a check should be introduced early in the method. If invalid dimensions are specified, it should raise a `ValueError` with a clear message indicating that both width and height must be greater than zero. This preserves the method's functionality while preventing the creation of figures with dimensions that are not valid for rendering or saving.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
245 class Figure(Artist):
246     """
247     The top level container for all the plot elements.
248 
249     The Figure instance supports callbacks through a *callbacks* attribute
250     which is a `.CallbackRegistry` instance.  The events you can connect to
251     are 'dpi_changed', and the callback will be called with ``func(fig)`` where
252     fig is the `Figure` instance.
253 
254     Attributes
255     ----------
256     patch
257         The `.Rectangle` instance representing the figure background patch.
258 
259     suppressComposite
260         For multiple figure images, the figure will make composite images
261         depending on the renderer option_image_nocomposite function.  If
262         *suppressComposite* is a boolean, this will override the renderer.
263     """
264 
265     def __str__(self):
266         return "Figure(%gx%g)" % tuple(self.bbox.size)
267 
268     def __repr__(self):
269         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
270             clsname=self.__class__.__name__,
271             h=self.bbox.size[0], w=self.bbox.size[1],
272             naxes=len(self.axes),
273         )
274 
275     def __init__(self,
276                  figsize=None,
277                  dpi=None,
278                  facecolor=None,
279                  edgecolor=None,
280                  linewidth=0.0,
281                  frameon=None,
282                  subplotpars=None,  # default to rc
283                  tight_layout=None,  # default to rc figure.autolayout
284                  constrained_layout=None,  # default to rc
285                                           #figure.constrained_layout.use
286                  ):
287         """
288         Parameters
289         ----------
290         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
291             Figure dimension ``(width, height)`` in inches.
292 
293         dpi : float, default: :rc:`figure.dpi`
294             Dots per inch.
295 
296         facecolor : default: :rc:`figure.facecolor`
297             The figure patch facecolor.
298 
299         edgecolor : default: :rc:`figure.edgecolor`
300             The figure patch edge color.
301 
302         linewidth : float
303             The linewidth of the frame (i.e. the edge linewidth of the figure
304             patch).
305 
306         frameon : bool, default: :rc:`figure.frameon`
307             If ``False``, suppress drawing the figure background patch.
308 
309         subplotpars : :class:`SubplotParams`
310             Subplot parameters. If not given, the default subplot
311             parameters :rc:`figure.subplot.*` are used.
312 
313         tight_layout : bool or dict, default: :rc:`figure.autolayout`
314             If ``False`` use *subplotpars*. If ``True`` adjust subplot
315             parameters using `.tight_layout` with default padding.
316             When providing a dict containing the keys ``pad``, ``w_pad``,
317             ``h_pad``, and ``rect``, the default `.tight_layout` paddings
318             will be overridden.
319 
320         constrained_layout : bool
321             If ``True`` use constrained layout to adjust positioning of plot
322             elements.  Like ``tight_layout``, but designed to be more
323             flexible.  See
324             :doc:`/tutorials/intermediate/constrainedlayout_guide`
325             for examples.  (Note: does not work with :meth:`.subplot` or
326             :meth:`.subplot2grid`.)
327             Defaults to :rc:`figure.constrained_layout.use`.
328         """
329         super().__init__()
330         # remove the non-figure artist _axes property
331         # as it makes no sense for a figure to be _in_ an axes
332         # this is used by the property methods in the artist base class
333         # which are over-ridden in this class
334         del self._axes
335         self.callbacks = cbook.CallbackRegistry()
336 
337         if figsize is None:
338             figsize = rcParams['figure.figsize']
339         if dpi is None:
340             dpi = rcParams['figure.dpi']
341         if facecolor is None:
342             facecolor = rcParams['figure.facecolor']
343         if edgecolor is None:
344             edgecolor = rcParams['figure.edgecolor']
345         if frameon is None:
346             frameon = rcParams['figure.frameon']
347 
348         if not np.isfinite(figsize).all():
349             raise ValueError('figure size must be finite not '
350                              '{}'.format(figsize))
351         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
352 
353         self.dpi_scale_trans = Affine2D().scale(dpi, dpi)
354         # do not use property as it will trigger
355         self._dpi = dpi
356         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
357 
358         self.transFigure = BboxTransformTo(self.bbox)
359 
360         self.patch = Rectangle(
361             xy=(0, 0), width=1, height=1,
362             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
363             visible=frameon)
364         self._set_artist_props(self.patch)
365         self.patch.set_antialiased(False)
366 
367         FigureCanvasBase(self)  # Set self.canvas.
368         self._suptitle = None
369 
370         if subplotpars is None:
371             subplotpars = SubplotParams()
372 
373         self.subplotpars = subplotpars
374         # constrained_layout:
375         self._layoutbox = None
376         # set in set_constrained_layout_pads()
377         self.set_constrained_layout(constrained_layout)
378 
379         self.set_tight_layout(tight_layout)
380 
381         self._axstack = AxesStack()  # track all figure axes and current axes
382         self.clf()
383         self._cachedRenderer = None
384 
385         # groupers to keep track of x and y labels we want to align.
386         # see self.align_xlabels and self.align_ylabels and
387         # axis._get_tick_boxes_siblings
388         self._align_xlabel_grp = cbook.Grouper()
389         self._align_ylabel_grp = cbook.Grouper()
390 
391         # list of child gridspecs for this figure
392         self._gridspecs = []
393 
394     # TODO: I'd like to dynamically add the _repr_html_ method
395     # to the figure in the right context, but then IPython doesn't
396     # use it, for some reason.
397 
398     def _repr_html_(self):
399         # We can't use "isinstance" here, because then we'd end up importing
400         # webagg unconditionally.
401         if 'WebAgg' in type(self.canvas).__name__:
402             from matplotlib.backends import backend_webagg
403             return backend_webagg.ipython_inline_display(self)
404 
405     def show(self, warn=True):
406         """
407         If using a GUI backend with pyplot, display the figure window.
408 
409         If the figure was not created using
410         :func:`~matplotlib.pyplot.figure`, it will lack a
411         :class:`~matplotlib.backend_bases.FigureManagerBase`, and
412         will raise an AttributeError.
413 
414         .. warning::
415             This does not manage an GUI event loop. Consequently, the figure
416             may only be shown briefly or not shown at all if you or your
417             environment are not managing an event loop.
418 
419             Proper use cases for `.Figure.show` include running this from a
420             GUI application or an IPython shell.
421 
422             If you're running a pure python shell or executing a non-GUI
423             python script, you should use `matplotlib.pyplot.show` instead,
424             which takes care of managing the event loop for you.
425 
426         Parameters
427         ----------
428         warn : bool
429             If ``True`` and we are not running headless (i.e. on Linux with an
430             unset DISPLAY), issue warning when called on a non-GUI backend.
431         """
432         try:
433             manager = getattr(self.canvas, 'manager')
434         except AttributeError as err:
435             raise AttributeError("%s\n"
436                                  "Figure.show works only "
437                                  "for figures managed by pyplot, normally "
438                                  "created by pyplot.figure()." % err)
439 
440         if manager is not None:
441             try:
442                 manager.show()
443                 return
444             except NonGuiException:
445                 pass
446         if (backends._get_running_interactive_framework() != "headless"
447                 and warn):
448             cbook._warn_external('Matplotlib is currently using %s, which is '
449                                  'a non-GUI backend, so cannot show the '
450                                  'figure.' % get_backend())
451 
452     def _get_axes(self):
453         return self._axstack.as_list()
454 
455     axes = property(fget=_get_axes,
456                     doc="List of axes in the Figure. You can access the "
457                         "axes in the Figure through this list. "
458                         "Do not modify the list itself. Instead, use "
459                         "`~Figure.add_axes`, `~.Figure.subplot` or "
460                         "`~.Figure.delaxes` to add or remove an axes.")
461 
462     def _get_dpi(self):
463         return self._dpi
464 
465     def _set_dpi(self, dpi, forward=True):
466         """
467         Parameters
468         ----------
469         dpi : float
470 
471         forward : bool
472             Passed on to `~.Figure.set_size_inches`
473         """
474         self._dpi = dpi
475         self.dpi_scale_trans.clear().scale(dpi, dpi)
476         w, h = self.get_size_inches()
477         self.set_size_inches(w, h, forward=forward)
478         self.callbacks.process('dpi_changed', self)
479 
480     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
481 
482     def get_tight_layout(self):
483         """Return whether `.tight_layout` is called when drawing."""
484         return self._tight
485 
486     def set_tight_layout(self, tight):
487         """
488         Set whether and how `.tight_layout` is called when drawing.
489 
490         Parameters
491         ----------
492         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
493             If a bool, sets whether to call `.tight_layout` upon drawing.
494             If ``None``, use the ``figure.autolayout`` rcparam instead.
495             If a dict, pass it as kwargs to `.tight_layout`, overriding the
496             default paddings.
497         """
498         if tight is None:
499             tight = rcParams['figure.autolayout']
500         self._tight = bool(tight)
501         self._tight_parameters = tight if isinstance(tight, dict) else {}
502         self.stale = True
503 
504     def get_constrained_layout(self):
505         """
506         Return a boolean: True means constrained layout is being used.
507 
508         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
509         """
510         return self._constrained
511 
512     def set_constrained_layout(self, constrained):
513         """
514         Set whether ``constrained_layout`` is used upon drawing. If None,
515         the rcParams['figure.constrained_layout.use'] value will be used.
516 
517         When providing a dict containing the keys `w_pad`, `h_pad`
518         the default ``constrained_layout`` paddings will be
519         overridden.  These pads are in inches and default to 3.0/72.0.
520         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
521 
522         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
523 
524         Parameters
525         ----------
526         constrained : bool or dict or None
527         """
528         self._constrained_layout_pads = dict()
529         self._constrained_layout_pads['w_pad'] = None
530         self._constrained_layout_pads['h_pad'] = None
531         self._constrained_layout_pads['wspace'] = None
532         self._constrained_layout_pads['hspace'] = None
533         if constrained is None:
534             constrained = rcParams['figure.constrained_layout.use']
535         self._constrained = bool(constrained)
536         if isinstance(constrained, dict):
537             self.set_constrained_layout_pads(**constrained)
538         else:
539             self.set_constrained_layout_pads()
540 
541         self.stale = True
542 
543     def set_constrained_layout_pads(self, **kwargs):
544         """
545         Set padding for ``constrained_layout``.  Note the kwargs can be passed
546         as a dictionary ``fig.set_constrained_layout(**paddict)``.
547 
548         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
549 
550         Parameters
551         ----------
552 
553         w_pad : scalar
554             Width padding in inches.  This is the pad around axes
555             and is meant to make sure there is enough room for fonts to
556             look good.  Defaults to 3 pts = 0.04167 inches
557 
558         h_pad : scalar
559             Height padding in inches. Defaults to 3 pts.
560 
561         wspace : scalar
562             Width padding between subplots, expressed as a fraction of the
563             subplot width.  The total padding ends up being w_pad + wspace.
564 
565         hspace : scalar
566             Height padding between subplots, expressed as a fraction of the
567             subplot width. The total padding ends up being h_pad + hspace.
568 
569         """
570 
571         todo = ['w_pad', 'h_pad', 'wspace', 'hspace']
572         for td in todo:
573             if td in kwargs and kwargs[td] is not None:
574                 self._constrained_layout_pads[td] = kwargs[td]
575             else:
576                 self._constrained_layout_pads[td] = (
577                     rcParams['figure.constrained_layout.' + td])
578 
579     def get_constrained_layout_pads(self, relative=False):
580         """
581         Get padding for ``constrained_layout``.
582 
583         Returns a list of `w_pad, h_pad` in inches and
584         `wspace` and `hspace` as fractions of the subplot.
585 
586         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
587 
588         Parameters
589         ----------
590 
591         relative : boolean
592             If `True`, then convert from inches to figure relative.
593         """
594         w_pad = self._constrained_layout_pads['w_pad']
595         h_pad = self._constrained_layout_pads['h_pad']
596         wspace = self._constrained_layout_pads['wspace']
597         hspace = self._constrained_layout_pads['hspace']
598 
599         if relative and (w_pad is not None or h_pad is not None):
600             renderer0 = layoutbox.get_renderer(self)
601             dpi = renderer0.dpi
602             w_pad = w_pad * dpi / renderer0.width
603             h_pad = h_pad * dpi / renderer0.height
604 
605         return w_pad, h_pad, wspace, hspace
606 
607     def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right', which=None):
608         """
609         Date ticklabels often overlap, so it is useful to rotate them
610         and right align them.  Also, a common use case is a number of
611         subplots with shared xaxes where the x-axis is date data.  The
612         ticklabels are often long, and it helps to rotate them on the
613         bottom subplot and turn them off on other subplots, as well as
614         turn off xlabels.
615 
616         Parameters
617         ----------
618         bottom : scalar
619             The bottom of the subplots for :meth:`subplots_adjust`.
620 
621         rotation : angle in degrees
622             The rotation of the xtick labels.
623 
624         ha : string
625             The horizontal alignment of the xticklabels.
626 
627         which : {None, 'major', 'minor', 'both'}
628             Selects which ticklabels to rotate. Default is None which works
629             the same as major.
630         """
631         allsubplots = all(hasattr(ax, 'is_last_row') for ax in self.axes)
632         if len(self.axes) == 1:
633             for label in self.axes[0].get_xticklabels(which=which):
634                 label.set_ha(ha)
635                 label.set_rotation(rotation)
636         else:
637             if allsubplots:
638                 for ax in self.get_axes():
639                     if ax.is_last_row():
640                         for label in ax.get_xticklabels(which=which):
641                             label.set_ha(ha)
642                             label.set_rotation(rotation)
643                     else:
644                         for label in ax.get_xticklabels(which=which):
645                             label.set_visible(False)
646                         ax.set_xlabel('')
647 
648         if allsubplots:
649             self.subplots_adjust(bottom=bottom)
650         self.stale = True
651 
652     def get_children(self):
653         """Get a list of artists contained in the figure."""
654         return [self.patch,
655                 *self.artists,
656                 *self.axes,
657                 *self.lines,
658                 *self.patches,
659                 *self.texts,
660                 *self.images,
661                 *self.legends]
662 
663     def contains(self, mouseevent):
664         """
665         Test whether the mouse event occurred on the figure.
666 
667         Returns
668         -------
669             bool, {}
670         """
671         if self._contains is not None:
672             return self._contains(self, mouseevent)
673         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
674         return inside, {}
675 
676     def get_window_extent(self, *args, **kwargs):
677         """
678         Return the figure bounding box in display space. Arguments are ignored.
679         """
680         return self.bbox
681 
682     def suptitle(self, t, **kwargs):
683         """
684         Add a centered title to the figure.
685 
686         Parameters
687         ----------
688         t : str
689             The title text.
690 
691         x : float, default 0.5
692             The x location of the text in figure coordinates.
693 
694         y : float, default 0.98
695             The y location of the text in figure coordinates.
696 
697         horizontalalignment, ha : {'center', 'left', right'}, default: 'center'
698             The horizontal alignment of the text relative to (*x*, *y*).
699 
700         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
701 default: 'top'
702             The vertical alignment of the text relative to (*x*, *y*).
703 
704         fontsize, size : default: :rc:`figure.titlesize`
705             The font size of the text. See `.Text.set_size` for possible
706             values.
707 
708         fontweight, weight : default: :rc:`figure.titleweight`
709             The font weight of the text. See `.Text.set_weight` for possible
710             values.
711 
712 
713         Returns
714         -------
715             text
716                 The `.Text` instance of the title.
717 
718 
719         Other Parameters
720         ----------------
721         fontproperties : None or dict, optional
722             A dict of font properties. If *fontproperties* is given the
723             default values for font size and weight are taken from the
724             `FontProperties` defaults. :rc:`figure.titlesize` and
725             :rc:`figure.titleweight` are ignored in this case.
726 
727         **kwargs
728             Additional kwargs are :class:`matplotlib.text.Text` properties.
729 
730 
731         Examples
732         --------
733 
734         >>> fig.suptitle('This is the figure title', fontsize=12)
735         """
736         manual_position = ('x' in kwargs or 'y' in kwargs)
737 
738         x = kwargs.pop('x', 0.5)
739         y = kwargs.pop('y', 0.98)
740 
741         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
742             kwargs['horizontalalignment'] = 'center'
743         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
744             kwargs['verticalalignment'] = 'top'
745 
746         if 'fontproperties' not in kwargs:
747             if 'fontsize' not in kwargs and 'size' not in kwargs:
748                 kwargs['size'] = rcParams['figure.titlesize']
749             if 'fontweight' not in kwargs and 'weight' not in kwargs:
750                 kwargs['weight'] = rcParams['figure.titleweight']
751 
752         sup = self.text(x, y, t, **kwargs)
753         if self._suptitle is not None:
754             self._suptitle.set_text(t)
755             self._suptitle.set_position((x, y))
756             self._suptitle.update_from(sup)
757             sup.remove()
758         else:
759             self._suptitle = sup
760             self._suptitle._layoutbox = None
761             if self._layoutbox is not None and not manual_position:
762                 w_pad, h_pad, wspace, hspace =  \
763                         self.get_constrained_layout_pads(relative=True)
764                 figlb = self._layoutbox
765                 self._suptitle._layoutbox = layoutbox.LayoutBox(
766                         parent=figlb, artist=self._suptitle,
767                         name=figlb.name+'.suptitle')
768                 # stack the suptitle on top of all the children.
769                 # Some day this should be on top of all the children in the
770                 # gridspec only.
771                 for child in figlb.children:
772                     if child is not self._suptitle._layoutbox:
773                         layoutbox.vstack([self._suptitle._layoutbox,
774                                           child],
775                                          padding=h_pad*2., strength='required')
776         self.stale = True
777         return self._suptitle
778 
779     def set_canvas(self, canvas):
780         """
781         Set the canvas that contains the figure
782 
783         Parameters
784         ----------
785         canvas : FigureCanvas
786         """
787         self.canvas = canvas
788 
789     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
790                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
791         """
792         Add a non-resampled image to the figure.
793 
794         The image is attached to the lower or upper left corner depending on
795         *origin*.
796 
797         Parameters
798         ----------
799         X
800             The image data. This is an array of one of the following shapes:
801 
802             - MxN: luminance (grayscale) values
803             - MxNx3: RGB values
804             - MxNx4: RGBA values
805 
806         xo, yo : int
807             The *x*/*y* image offset in pixels.
808 
809         alpha : None or float
810             The alpha blending value.
811 
812         norm : :class:`matplotlib.colors.Normalize`
813             A :class:`.Normalize` instance to map the luminance to the
814             interval [0, 1].
815 
816         cmap : str or :class:`matplotlib.colors.Colormap`
817             The colormap to use. Default: :rc:`image.cmap`.
818 
819         vmin, vmax : scalar
820             If *norm* is not given, these values set the data limits for the
821             colormap.
822 
823         origin : {'upper', 'lower'}
824             Indicates where the [0, 0] index of the array is in the upper left
825             or lower left corner of the axes. Defaults to :rc:`image.origin`.
826 
827         resize : bool
828             If *True*, resize the figure to match the given image size.
829 
830         Returns
831         -------
832         :class:`matplotlib.image.FigureImage`
833 
834         Other Parameters
835         ----------------
836         **kwargs
837             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
838 
839         Notes
840         -----
841         figimage complements the axes image
842         (:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled
843         to fit the current axes.  If you want a resampled image to
844         fill the entire figure, you can define an
845         :class:`~matplotlib.axes.Axes` with extent [0,0,1,1].
846 
847 
848         Examples::
849 
850             f = plt.figure()
851             nx = int(f.get_figwidth() * f.dpi)
852             ny = int(f.get_figheight() * f.dpi)
853             data = np.random.random((ny, nx))
854             f.figimage(data)
855             plt.show()
856 
857         """
858         if resize:
859             dpi = self.get_dpi()
860             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
861             self.set_size_inches(figsize, forward=True)
862 
863         im = mimage.FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)
864         im.stale_callback = _stale_figure_callback
865 
866         im.set_array(X)
867         im.set_alpha(alpha)
868         if norm is None:
869             im.set_clim(vmin, vmax)
870         self.images.append(im)
871         im._remove_method = self.images.remove
872         self.stale = True
873         return im
874 
875     def set_size_inches(self, w, h=None, forward=True):
876         """Set the figure size in inches.
877 
878         Call signatures::
879 
880              fig.set_size_inches(w, h)  # OR
881              fig.set_size_inches((w, h))
882 
883         optional kwarg *forward=True* will cause the canvas size to be
884         automatically updated; e.g., you can resize the figure window
885         from the shell
886 
887         ACCEPTS: a (w, h) tuple with w, h in inches
888 
889         See Also
890         --------
891         matplotlib.Figure.get_size_inches
892         """
893 
894         # the width and height have been passed in as a tuple to the first
895         # argument, so unpack them
896         if h is None:
897             w, h = w
898         if not all(np.isfinite(_) for _ in (w, h)):
899             raise ValueError('figure size must be finite not '
900                              '({}, {})'.format(w, h))
901         self.bbox_inches.p1 = w, h
902 
903         if forward:
904             canvas = getattr(self, 'canvas')
905             if canvas is not None:
906                 ratio = getattr(self.canvas, '_dpi_ratio', 1)
907                 dpival = self.dpi / ratio
908                 canvasw = w * dpival
909                 canvash = h * dpival
910                 manager = getattr(self.canvas, 'manager', None)
911                 if manager is not None:
912                     manager.resize(int(canvasw), int(canvash))
913         self.stale = True
914 
915     def get_size_inches(self):
916         """
917         Returns the current size of the figure in inches.
918 
919         Returns
920         -------
921         size : ndarray
922            The size (width, height) of the figure in inches.
923 
924         See Also
925         --------
926         matplotlib.Figure.set_size_inches
927         """
928         return np.array(self.bbox_inches.p1)
929 
930     def get_edgecolor(self):
931         """Get the edge color of the Figure rectangle."""
932         return self.patch.get_edgecolor()
933 
934     def get_facecolor(self):
935         """Get the face color of the Figure rectangle."""
936         return self.patch.get_facecolor()
937 
938     def get_figwidth(self):
939         """Return the figure width as a float."""
940         return self.bbox_inches.width
941 
942     def get_figheight(self):
943         """Return the figure height as a float."""
944         return self.bbox_inches.height
945 
946     def get_dpi(self):
947         """Return the resolution in dots per inch as a float."""
948         return self.dpi
949 
950     def get_frameon(self):
951         """
952         Return the figure's background patch visibility, i.e.
953         whether the figure background will be drawn. Equivalent to
954         ``Figure.patch.get_visible()``.
955         """
956         return self.patch.get_visible()
957 
958     def set_edgecolor(self, color):
959         """
960         Set the edge color of the Figure rectangle.
961 
962         Parameters
963         ----------
964         color : color
965         """
966         self.patch.set_edgecolor(color)
967 
968     def set_facecolor(self, color):
969         """
970         Set the face color of the Figure rectangle.
971 
972         Parameters
973         ----------
974         color : color
975         """
976         self.patch.set_facecolor(color)
977 
978     def set_dpi(self, val):
979         """
980         Set the resolution of the figure in dots-per-inch.
981 
982         Parameters
983         ----------
984         val : float
985         """
986         self.dpi = val
987         self.stale = True
988 
989     def set_figwidth(self, val, forward=True):
990         """
991         Set the width of the figure in inches.
992 
993         Parameters
994         ----------
995         val : float
996         forward : bool
997         """
998         self.set_size_inches(val, self.get_figheight(), forward=forward)
999 
1000     def set_figheight(self, val, forward=True):
1001         """
1002         Set the height of the figure in inches.
1003 
1004         Parameters
1005         ----------
1006         val : float
1007         forward : bool
1008         """
1009         self.set_size_inches(self.get_figwidth(), val, forward=forward)
1010 
1011     def set_frameon(self, b):
1012         """
1013         Set the figure's background patch visibility, i.e.
1014         whether the figure background will be drawn. Equivalent to
1015         ``Figure.patch.set_visible()``.
1016 
1017         Parameters
1018         ----------
1019         b : bool
1020         """
1021         self.patch.set_visible(b)
1022         self.stale = True
1023 
1024     frameon = property(get_frameon, set_frameon)
1025 
1026     def delaxes(self, ax):
1027         """
1028         Remove the `~matplotlib.axes.Axes` *ax* from the figure and update the
1029         current axes.
1030         """
1031         self._axstack.remove(ax)
1032         for func in self._axobservers:
1033             func(self)
1034         self.stale = True
1035 
1036     def add_artist(self, artist, clip=False):
1037         """
1038         Add any :class:`~matplotlib.artist.Artist` to the figure.
1039 
1040         Usually artists are added to axes objects using
1041         :meth:`matplotlib.axes.Axes.add_artist`, but use this method in the
1042         rare cases that adding directly to the figure is necessary.
1043 
1044         Parameters
1045         ----------
1046         artist : `~matplotlib.artist.Artist`
1047             The artist to add to the figure. If the added artist has no
1048             transform previously set, its transform will be set to
1049             ``figure.transFigure``.
1050         clip : bool, optional, default ``False``
1051             An optional parameter ``clip`` determines whether the added artist
1052             should be clipped by the figure patch. Default is *False*,
1053             i.e. no clipping.
1054 
1055         Returns
1056         -------
1057         artist : The added `~matplotlib.artist.Artist`
1058         """
1059         artist.set_figure(self)
1060         self.artists.append(artist)
1061         artist._remove_method = self.artists.remove
1062 
1063         if not artist.is_transform_set():
1064             artist.set_transform(self.transFigure)
1065 
1066         if clip:
1067             artist.set_clip_path(self.patch)
1068 
1069         self.stale = True
1070         return artist
1071 
1072     def _make_key(self, *args, **kwargs):
1073         """Make a hashable key out of args and kwargs."""
1074 
1075         def fixitems(items):
1076             # items may have arrays and lists in them, so convert them
1077             # to tuples for the key
1078             ret = []
1079             for k, v in items:
1080                 # some objects can define __getitem__ without being
1081                 # iterable and in those cases the conversion to tuples
1082                 # will fail. So instead of using the np.iterable(v) function
1083                 # we simply try and convert to a tuple, and proceed if not.
1084                 try:
1085                     v = tuple(v)
1086                 except Exception:
1087                     pass
1088                 ret.append((k, v))
1089             return tuple(ret)
1090 
1091         def fixlist(args):
1092             ret = []
1093             for a in args:
1094                 if np.iterable(a):
1095                     a = tuple(a)
1096                 ret.append(a)
1097             return tuple(ret)
1098 
1099         key = fixlist(args), fixitems(kwargs.items())
1100         return key
1101 
1102     def _process_projection_requirements(
1103             self, *args, polar=False, projection=None, **kwargs):
1104         """
1105         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1106 
1107             (axes_proj_class, proj_class_kwargs, proj_stack_key)
1108 
1109         which can be used for new axes initialization/identification.
1110         """
1111         if polar:
1112             if projection is not None and projection != 'polar':
1113                 raise ValueError(
1114                     "polar=True, yet projection=%r. "
1115                     "Only one of these arguments should be supplied." %
1116                     projection)
1117             projection = 'polar'
1118 
1119         if isinstance(projection, str) or projection is None:
1120             projection_class = projections.get_projection_class(projection)
1121         elif hasattr(projection, '_as_mpl_axes'):
1122             projection_class, extra_kwargs = projection._as_mpl_axes()
1123             kwargs.update(**extra_kwargs)
1124         else:
1125             raise TypeError('projection must be a string, None or implement a '
1126                             '_as_mpl_axes method. Got %r' % projection)
1127 
1128         # Make the key without projection kwargs, this is used as a unique
1129         # lookup for axes instances
1130         key = self._make_key(*args, **kwargs)
1131 
1132         return projection_class, kwargs, key
1133 
1134     @docstring.dedent_interpd
1135     def add_axes(self, *args, **kwargs):
1136         """
1137         Add an axes to the figure.
1138 
1139         Call signatures::
1140 
1141             add_axes(rect, projection=None, polar=False, **kwargs)
1142             add_axes(ax)
1143 
1144         Parameters
1145         ----------
1146 
1147         rect : sequence of float
1148             The dimensions [left, bottom, width, height] of the new axes. All
1149             quantities are in fractions of figure width and height.
1150 
1151         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1152 'polar', 'rectilinear', str}, optional
1153             The projection type of the `~.axes.Axes`. *str* is the name of
1154             a custom projection, see `~matplotlib.projections`. The default
1155             None results in a 'rectilinear' projection.
1156 
1157         polar : boolean, optional
1158             If True, equivalent to projection='polar'.
1159 
1160         sharex, sharey : `~.axes.Axes`, optional
1161             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1162             The axis will have the same limits, ticks, and scale as the axis
1163             of the shared axes.
1164 
1165         label : str
1166             A label for the returned axes.
1167 
1168         Other Parameters
1169         ----------------
1170         **kwargs
1171             This method also takes the keyword arguments for
1172             the returned axes class. The keyword arguments for the
1173             rectilinear axes class `~.axes.Axes` can be found in
1174             the following table but there might also be other keyword
1175             arguments if another projection is used, see the actual axes
1176             class.
1177             %(Axes)s
1178 
1179         Returns
1180         -------
1181         axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
1182             The returned axes class depends on the projection used. It is
1183             `~.axes.Axes` if rectilinear projection are used and
1184             `.projections.polar.PolarAxes` if polar projection
1185             are used.
1186 
1187         Notes
1188         -----
1189         If the figure already has an axes with key (*args*,
1190         *kwargs*) then it will simply make that axes current and
1191         return it.  This behavior is deprecated. Meanwhile, if you do
1192         not want this behavior (i.e., you want to force the creation of a
1193         new axes), you must use a unique set of args and kwargs.  The axes
1194         *label* attribute has been exposed for this purpose: if you want
1195         two axes that are otherwise identical to be added to the figure,
1196         make sure you give them unique labels.
1197 
1198         In rare circumstances, `.add_axes` may be called with a single
1199         argument, a axes instance already created in the present figure but
1200         not in the figure's list of axes.
1201 
1202         See Also
1203         --------
1204         .Figure.add_subplot
1205         .pyplot.subplot
1206         .pyplot.axes
1207         .Figure.subplots
1208         .pyplot.subplots
1209 
1210         Examples
1211         --------
1212         Some simple examples::
1213 
1214             rect = l, b, w, h
1215             fig = plt.figure()
1216             fig.add_axes(rect,label=label1)
1217             fig.add_axes(rect,label=label2)
1218             fig.add_axes(rect, frameon=False, facecolor='g')
1219             fig.add_axes(rect, polar=True)
1220             ax=fig.add_axes(rect, projection='polar')
1221             fig.delaxes(ax)
1222             fig.add_axes(ax)
1223         """
1224 
1225         if not len(args):
1226             return
1227 
1228         # shortcut the projection "key" modifications later on, if an axes
1229         # with the exact args/kwargs exists, return it immediately.
1230         key = self._make_key(*args, **kwargs)
1231         ax = self._axstack.get(key)
1232         if ax is not None:
1233             self.sca(ax)
1234             return ax
1235 
1236         if isinstance(args[0], Axes):
1237             a = args[0]
1238             if a.get_figure() is not self:
1239                 raise ValueError(
1240                     "The Axes must have been created in the present figure")
1241         else:
1242             rect = args[0]
1243             if not np.isfinite(rect).all():
1244                 raise ValueError('all entries in rect must be finite '
1245                                  'not {}'.format(rect))
1246             projection_class, kwargs, key = \
1247                 self._process_projection_requirements(*args, **kwargs)
1248 
1249             # check that an axes of this type doesn't already exist, if it
1250             # does, set it as active and return it
1251             ax = self._axstack.get(key)
1252             if isinstance(ax, projection_class):
1253                 self.sca(ax)
1254                 return ax
1255 
1256             # create the new axes using the axes class given
1257             a = projection_class(self, rect, **kwargs)
1258 
1259         return self._add_axes_internal(key, a)
1260 
1261     @docstring.dedent_interpd
1262     def add_subplot(self, *args, **kwargs):
1263         """
1264         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
1265 
1266         Call signatures::
1267 
1268            add_subplot(nrows, ncols, index, **kwargs)
1269            add_subplot(pos, **kwargs)
1270            add_subplot(ax)
1271 
1272         Parameters
1273         ----------
1274         *args
1275             Either a 3-digit integer or three separate integers
1276             describing the position of the subplot. If the three
1277             integers are *nrows*, *ncols*, and *index* in order, the
1278             subplot will take the *index* position on a grid with *nrows*
1279             rows and *ncols* columns. *index* starts at 1 in the upper left
1280             corner and increases to the right.
1281 
1282             *pos* is a three digit integer, where the first digit is the
1283             number of rows, the second the number of columns, and the third
1284             the index of the subplot. i.e. fig.add_subplot(235) is the same as
1285             fig.add_subplot(2, 3, 5). Note that all integers must be less than
1286             10 for this form to work.
1287 
1288         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1289 'polar', 'rectilinear', str}, optional
1290             The projection type of the subplot (`~.axes.Axes`). *str* is the
1291             name of a custom projection, see `~matplotlib.projections`. The
1292             default None results in a 'rectilinear' projection.
1293 
1294         polar : boolean, optional
1295             If True, equivalent to projection='polar'.
1296 
1297         sharex, sharey : `~.axes.Axes`, optional
1298             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1299             The axis will have the same limits, ticks, and scale as the axis
1300             of the shared axes.
1301 
1302         label : str
1303             A label for the returned axes.
1304 
1305         Other Parameters
1306         ----------------
1307         **kwargs
1308             This method also takes the keyword arguments for
1309             the returned axes base class. The keyword arguments for the
1310             rectilinear base class `~.axes.Axes` can be found in
1311             the following table but there might also be other keyword
1312             arguments if another projection is used.
1313             %(Axes)s
1314 
1315         Returns
1316         -------
1317         axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a \
1318                subclass of `~.axes.Axes`)
1319 
1320             The axes of the subplot. The returned axes base class depends on
1321             the projection used. It is `~.axes.Axes` if rectilinear projection
1322             are used and `.projections.polar.PolarAxes` if polar projection
1323             are used. The returned axes is then a subplot subclass of the
1324             base class.
1325 
1326         Notes
1327         -----
1328         If the figure already has a subplot with key (*args*,
1329         *kwargs*) then it will simply make that subplot current and
1330         return it.  This behavior is deprecated. Meanwhile, if you do
1331         not want this behavior (i.e., you want to force the creation of a
1332         new subplot), you must use a unique set of args and kwargs.  The axes
1333         *label* attribute has been exposed for this purpose: if you want
1334         two subplots that are otherwise identical to be added to the figure,
1335         make sure you give them unique labels.
1336 
1337         In rare circumstances, `.add_subplot` may be called with a single
1338         argument, a subplot axes instance already created in the
1339         present figure but not in the figure's list of axes.
1340 
1341         See Also
1342         --------
1343         .Figure.add_axes
1344         .pyplot.subplot
1345         .pyplot.axes
1346         .Figure.subplots
1347         .pyplot.subplots
1348 
1349         Examples
1350         --------
1351         ::
1352 
1353             fig = plt.figure()
1354             fig.add_subplot(221)
1355 
1356             # equivalent but more general
1357             ax1 = fig.add_subplot(2, 2, 1)
1358 
1359             # add a subplot with no frame
1360             ax2 = fig.add_subplot(222, frameon=False)
1361 
1362             # add a polar subplot
1363             fig.add_subplot(223, projection='polar')
1364 
1365             # add a red subplot that share the x-axis with ax1
1366             fig.add_subplot(224, sharex=ax1, facecolor='red')
1367 
1368             #delete x2 from the figure
1369             fig.delaxes(ax2)
1370 
1371             #add x2 to the figure again
1372             fig.add_subplot(ax2)
1373         """
1374         if not len(args):
1375             args = (1, 1, 1)
1376 
1377         if len(args) == 1 and isinstance(args[0], Integral):
1378             if not 100 <= args[0] <= 999:
1379                 raise ValueError("Integer subplot specification must be a "
1380                                  "three-digit number, not {}".format(args[0]))
1381             args = tuple(map(int, str(args[0])))
1382 
1383         if isinstance(args[0], SubplotBase):
1384 
1385             a = args[0]
1386             if a.get_figure() is not self:
1387                 raise ValueError(
1388                     "The Subplot must have been created in the present figure")
1389             # make a key for the subplot (which includes the axes object id
1390             # in the hash)
1391             key = self._make_key(*args, **kwargs)
1392         else:
1393             projection_class, kwargs, key = \
1394                 self._process_projection_requirements(*args, **kwargs)
1395 
1396             # try to find the axes with this key in the stack
1397             ax = self._axstack.get(key)
1398 
1399             if ax is not None:
1400                 if isinstance(ax, projection_class):
1401                     # the axes already existed, so set it as active & return
1402                     self.sca(ax)
1403                     return ax
1404                 else:
1405                     # Undocumented convenience behavior:
1406                     # subplot(111); subplot(111, projection='polar')
1407                     # will replace the first with the second.
1408                     # Without this, add_subplot would be simpler and
1409                     # more similar to add_axes.
1410                     self._axstack.remove(ax)
1411 
1412             a = subplot_class_factory(projection_class)(self, *args, **kwargs)
1413 
1414         return self._add_axes_internal(key, a)
1415 
1416     def _add_axes_internal(self, key, ax):
1417         """Private helper for `add_axes` and `add_subplot`."""
1418         self._axstack.add(key, ax)
1419         self.sca(ax)
1420         ax._remove_method = self._remove_ax
1421         self.stale = True
1422         ax.stale_callback = _stale_figure_callback
1423         return ax
1424 
1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,
1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):
1427         """
1428         Add a set of subplots to this figure.
1429 
1430         This utility wrapper makes it convenient to create common layouts of
1431         subplots in a single call.
1432 
1433         Parameters
1434         ----------
1435         nrows, ncols : int, optional, default: 1
1436             Number of rows/columns of the subplot grid.
1437 
1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)
1440             axes:
1441 
1442                 - True or 'all': x- or y-axis will be shared among all
1443                   subplots.
1444                 - False or 'none': each subplot x- or y-axis will be
1445                   independent.
1446                 - 'row': each subplot row will share an x- or y-axis.
1447                 - 'col': each subplot column will share an x- or y-axis.
1448 
1449             When subplots have a shared x-axis along a column, only the x tick
1450             labels of the bottom subplot are created. Similarly, when subplots
1451             have a shared y-axis along a row, only the y tick labels of the
1452             first column subplot are created. To later turn other subplots'
1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
1454 
1455         squeeze : bool, optional, default: True
1456             - If True, extra dimensions are squeezed out from the returned
1457               array of Axes:
1458 
1459                 - if only one subplot is constructed (nrows=ncols=1), the
1460                   resulting single Axes object is returned as a scalar.
1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1462                   object array of Axes objects.
1463                 - for NxM, subplots with N>1 and M>1 are returned
1464                   as a 2D array.
1465 
1466             - If False, no squeezing at all is done: the returned Axes object
1467               is always a 2D array containing Axes instances, even if it ends
1468               up being 1x1.
1469 
1470         subplot_kw : dict, optional
1471             Dict with keywords passed to the
1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create
1473             each subplot.
1474 
1475         gridspec_kw : dict, optional
1476             Dict with keywords passed to the
1477             `~matplotlib.gridspec.GridSpec` constructor used to create
1478             the grid the subplots are placed on.
1479 
1480         Returns
1481         -------
1482         ax : `~.axes.Axes` object or array of Axes objects.
1483             *ax* can be either a single `~matplotlib.axes.Axes` object or
1484             an array of Axes objects if more than one subplot was created. The
1485             dimensions of the resulting array can be controlled with the
1486             squeeze keyword, see above.
1487 
1488         Examples
1489         --------
1490         ::
1491 
1492             # First create some toy data:
1493             x = np.linspace(0, 2*np.pi, 400)
1494             y = np.sin(x**2)
1495 
1496             # Create a figure
1497             plt.figure()
1498 
1499             # Creates a subplot
1500             ax = fig.subplots()
1501             ax.plot(x, y)
1502             ax.set_title('Simple plot')
1503 
1504             # Creates two subplots and unpacks the output array immediately
1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)
1506             ax1.plot(x, y)
1507             ax1.set_title('Sharing Y axis')
1508             ax2.scatter(x, y)
1509 
1510             # Creates four polar axes, and accesses them through the
1511             # returned array
1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))
1513             axes[0, 0].plot(x, y)
1514             axes[1, 1].scatter(x, y)
1515 
1516             # Share a X axis with each column of subplots
1517             fig.subplots(2, 2, sharex='col')
1518 
1519             # Share a Y axis with each row of subplots
1520             fig.subplots(2, 2, sharey='row')
1521 
1522             # Share both X and Y axes with all subplots
1523             fig.subplots(2, 2, sharex='all', sharey='all')
1524 
1525             # Note that this is the same as
1526             fig.subplots(2, 2, sharex=True, sharey=True)
1527 
1528             See Also
1529             --------
1530             .pyplot.subplots
1531             .Figure.add_subplot
1532             .pyplot.subplot
1533             """
1534 
1535         if isinstance(sharex, bool):
1536             sharex = "all" if sharex else "none"
1537         if isinstance(sharey, bool):
1538             sharey = "all" if sharey else "none"
1539         # This check was added because it is very easy to type
1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.
1541         # In most cases, no error will ever occur, but mysterious behavior
1542         # will result because what was intended to be the subplot index is
1543         # instead treated as a bool for sharex.
1544         if isinstance(sharex, Integral):
1545             cbook._warn_external(
1546                 "sharex argument to subplots() was an integer.  Did you "
1547                 "intend to use subplot() (without 's')?")
1548         cbook._check_in_list(["all", "row", "col", "none"],
1549                              sharex=sharex, sharey=sharey)
1550         if subplot_kw is None:
1551             subplot_kw = {}
1552         if gridspec_kw is None:
1553             gridspec_kw = {}
1554         # don't mutate kwargs passed by user...
1555         subplot_kw = subplot_kw.copy()
1556         gridspec_kw = gridspec_kw.copy()
1557 
1558         if self.get_constrained_layout():
1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)
1560         else:
1561             # this should turn constrained_layout off if we don't want it
1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)
1563         self._gridspecs.append(gs)
1564 
1565         # Create array to hold all axes.
1566         axarr = np.empty((nrows, ncols), dtype=object)
1567         for row in range(nrows):
1568             for col in range(ncols):
1569                 shared_with = {"none": None, "all": axarr[0, 0],
1570                                "row": axarr[row, 0], "col": axarr[0, col]}
1571                 subplot_kw["sharex"] = shared_with[sharex]
1572                 subplot_kw["sharey"] = shared_with[sharey]
1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)
1574 
1575         # turn off redundant tick labeling
1576         if sharex in ["col", "all"]:
1577             # turn off all but the bottom row
1578             for ax in axarr[:-1, :].flat:
1579                 ax.xaxis.set_tick_params(which='both',
1580                                          labelbottom=False, labeltop=False)
1581                 ax.xaxis.offsetText.set_visible(False)
1582         if sharey in ["row", "all"]:
1583             # turn off all but the first column
1584             for ax in axarr[:, 1:].flat:
1585                 ax.yaxis.set_tick_params(which='both',
1586                                          labelleft=False, labelright=False)
1587                 ax.yaxis.offsetText.set_visible(False)
1588 
1589         if squeeze:
1590             # Discarding unneeded dimensions that equal 1.  If we only have one
1591             # subplot, just return it instead of a 1-element array.
1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()
1593         else:
1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1595             return axarr
1596 
1597     def _remove_ax(self, ax):
1598         def _reset_loc_form(axis):
1599             axis.set_major_formatter(axis.get_major_formatter())
1600             axis.set_major_locator(axis.get_major_locator())
1601             axis.set_minor_formatter(axis.get_minor_formatter())
1602             axis.set_minor_locator(axis.get_minor_locator())
1603 
1604         def _break_share_link(ax, grouper):
1605             siblings = grouper.get_siblings(ax)
1606             if len(siblings) > 1:
1607                 grouper.remove(ax)
1608                 for last_ax in siblings:
1609                     if ax is not last_ax:
1610                         return last_ax
1611             return None
1612 
1613         self.delaxes(ax)
1614         last_ax = _break_share_link(ax, ax._shared_y_axes)
1615         if last_ax is not None:
1616             _reset_loc_form(last_ax.yaxis)
1617 
1618         last_ax = _break_share_link(ax, ax._shared_x_axes)
1619         if last_ax is not None:
1620             _reset_loc_form(last_ax.xaxis)
1621 
1622     def clf(self, keep_observers=False):
1623         """
1624         Clear the figure.
1625 
1626         Set *keep_observers* to True if, for example,
1627         a gui widget is tracking the axes in the figure.
1628         """
1629         self.suppressComposite = None
1630         self.callbacks = cbook.CallbackRegistry()
1631 
1632         for ax in tuple(self.axes):  # Iterate over the copy.
1633             ax.cla()
1634             self.delaxes(ax)         # removes ax from self._axstack
1635 
1636         toolbar = getattr(self.canvas, 'toolbar', None)
1637         if toolbar is not None:
1638             toolbar.update()
1639         self._axstack.clear()
1640         self.artists = []
1641         self.lines = []
1642         self.patches = []
1643         self.texts = []
1644         self.images = []
1645         self.legends = []
1646         if not keep_observers:
1647             self._axobservers = []
1648         self._suptitle = None
1649         if self.get_constrained_layout():
1650             layoutbox.nonetree(self._layoutbox)
1651         self.stale = True
1652 
1653     def clear(self, keep_observers=False):
1654         """
1655         Clear the figure -- synonym for :meth:`clf`.
1656         """
1657         self.clf(keep_observers=keep_observers)
1658 
1659     @allow_rasterization
1660     def draw(self, renderer):
1661         """
1662         Render the figure using :class:`matplotlib.backend_bases.RendererBase`
1663         instance *renderer*.
1664         """
1665 
1666         # draw the figure bounding box, perhaps none for white figure
1667         if not self.get_visible():
1668             return
1669 
1670         artists = self.get_children()
1671         artists.remove(self.patch)
1672         artists = sorted(
1673             (artist for artist in artists if not artist.get_animated()),
1674             key=lambda artist: artist.get_zorder())
1675 
1676         for ax in self.axes:
1677             locator = ax.get_axes_locator()
1678             if locator:
1679                 pos = locator(ax, renderer)
1680                 ax.apply_aspect(pos)
1681             else:
1682                 ax.apply_aspect()
1683 
1684             for child in ax.get_children():
1685                 if hasattr(child, 'apply_aspect'):
1686                     locator = child.get_axes_locator()
1687                     if locator:
1688                         pos = locator(child, renderer)
1689                         child.apply_aspect(pos)
1690                     else:
1691                         child.apply_aspect()
1692 
1693         try:
1694             renderer.open_group('figure')
1695             if self.get_constrained_layout() and self.axes:
1696                 self.execute_constrained_layout(renderer)
1697             if self.get_tight_layout() and self.axes:
1698                 try:
1699                     self.tight_layout(renderer,
1700                                       **self._tight_parameters)
1701                 except ValueError:
1702                     pass
1703                     # ValueError can occur when resizing a window.
1704 
1705             self.patch.draw(renderer)
1706             mimage._draw_list_compositing_images(
1707                 renderer, self, artists, self.suppressComposite)
1708 
1709             renderer.close_group('figure')
1710         finally:
1711             self.stale = False
1712 
1713         self._cachedRenderer = renderer
1714         self.canvas.draw_event(renderer)
1715 
1716     def draw_artist(self, a):
1717         """
1718         Draw :class:`matplotlib.artist.Artist` instance *a* only.
1719         This is available only after the figure is drawn.
1720         """
1721         if self._cachedRenderer is None:
1722             raise AttributeError("draw_artist can only be used after an "
1723                                  "initial draw which caches the renderer")
1724         a.draw(self._cachedRenderer)
1725 
1726     def get_axes(self):
1727         """
1728         Return a list of axes in the Figure. You can access and modify the
1729         axes in the Figure through this list.
1730 
1731         Do not modify the list itself. Instead, use `~Figure.add_axes`,
1732         `~.Figure.subplot` or `~.Figure.delaxes` to add or remove an axes.
1733 
1734         Note: This is equivalent to the property `~.Figure.axes`.
1735         """
1736         return self.axes
1737 
1738     # Note: in the docstring below, the newlines in the examples after the
1739     # calls to legend() allow replacing it with figlegend() to generate the
1740     # docstring of pyplot.figlegend.
1741 
1742     @docstring.dedent_interpd
1743     def legend(self, *args, **kwargs):
1744         """
1745         Place a legend on the figure.
1746 
1747         To make a legend from existing artists on every axes::
1748 
1749           legend()
1750 
1751         To make a legend for a list of lines and labels::
1752 
1753           legend(
1754               (line1, line2, line3),
1755               ('label1', 'label2', 'label3'),
1756               loc='upper right')
1757 
1758         These can also be specified by keyword::
1759 
1760           legend(
1761               handles=(line1, line2, line3),
1762               labels=('label1', 'label2', 'label3'),
1763               loc='upper right')
1764 
1765         Parameters
1766         ----------
1767 
1768         handles : sequence of `.Artist`, optional
1769             A list of Artists (lines, patches) to be added to the legend.
1770             Use this together with *labels*, if you need full control on what
1771             is shown in the legend and the automatic mechanism described above
1772             is not sufficient.
1773 
1774             The length of handles and labels should be the same in this
1775             case. If they are not, they are truncated to the smaller length.
1776 
1777         labels : sequence of strings, optional
1778             A list of labels to show next to the artists.
1779             Use this together with *handles*, if you need full control on what
1780             is shown in the legend and the automatic mechanism described above
1781             is not sufficient.
1782 
1783         Other Parameters
1784         ----------------
1785 
1786         %(_legend_kw_doc)s
1787 
1788         Returns
1789         -------
1790         :class:`matplotlib.legend.Legend` instance
1791 
1792         Notes
1793         -----
1794         Not all kinds of artist are supported by the legend command. See
1795         :doc:`/tutorials/intermediate/legend_guide` for details.
1796         """
1797 
1798         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1799                 self.axes,
1800                 *args,
1801                 **kwargs)
1802         # check for third arg
1803         if len(extra_args):
1804             # cbook.warn_deprecated(
1805             #     "2.1",
1806             #     message="Figure.legend will accept no more than two "
1807             #     "positional arguments in the future.  Use "
1808             #     "'fig.legend(handles, labels, loc=location)' "
1809             #     "instead.")
1810             # kwargs['loc'] = extra_args[0]
1811             # extra_args = extra_args[1:]
1812             pass
1813         l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)
1814         self.legends.append(l)
1815         l._remove_method = self.legends.remove
1816         self.stale = True
1817         return l
1818 
1819     @cbook._delete_parameter("3.1", "withdash")
1820     @docstring.dedent_interpd
1821     def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):
1822         """
1823         Add text to figure.
1824 
1825         Parameters
1826         ----------
1827         x, y : float
1828             The position to place the text. By default, this is in figure
1829             coordinates, floats in [0, 1]. The coordinate system can be changed
1830             using the *transform* keyword.
1831 
1832         s : str
1833             The text string.
1834 
1835         fontdict : dictionary, optional, default: None
1836             A dictionary to override the default text properties. If fontdict
1837             is None, the defaults are determined by your rc parameters. A
1838             property in *kwargs* override the same property in fontdict.
1839 
1840         withdash : boolean, optional, default: False
1841             Creates a `~matplotlib.text.TextWithDash` instance instead of a
1842             `~matplotlib.text.Text` instance.
1843 
1844         Other Parameters
1845         ----------------
1846         **kwargs : `~matplotlib.text.Text` properties
1847             Other miscellaneous text parameters.
1848             %(Text)s
1849 
1850         Returns
1851         -------
1852         text : `~.text.Text`
1853 
1854         See Also
1855         --------
1856         .Axes.text
1857         .pyplot.text
1858         """
1859         default = dict(transform=self.transFigure)
1860 
1861         if withdash:
1862             text = TextWithDash(x=x, y=y, text=s)
1863         else:
1864             text = Text(x=x, y=y, text=s)
1865 
1866         text.update(default)
1867         if fontdict is not None:
1868             text.update(fontdict)
1869         text.update(kwargs)
1870 
1871         text.set_figure(self)
1872         text.stale_callback = _stale_figure_callback
1873 
1874         self.texts.append(text)
1875         text._remove_method = self.texts.remove
1876         self.stale = True
1877         return text
1878 
1879     def _set_artist_props(self, a):
1880         if a != self:
1881             a.set_figure(self)
1882         a.stale_callback = _stale_figure_callback
1883         a.set_transform(self.transFigure)
1884 
1885     @docstring.dedent_interpd
1886     def gca(self, **kwargs):
1887         """
1888         Get the current axes, creating one if necessary.
1889 
1890         The following kwargs are supported for ensuring the returned axes
1891         adheres to the given projection etc., and for axes creation if
1892         the active axes does not exist:
1893 
1894         %(Axes)s
1895 
1896         """
1897         ckey, cax = self._axstack.current_key_axes()
1898         # if there exists an axes on the stack see if it matches
1899         # the desired axes configuration
1900         if cax is not None:
1901 
1902             # if no kwargs are given just return the current axes
1903             # this is a convenience for gca() on axes such as polar etc.
1904             if not kwargs:
1905                 return cax
1906 
1907             # if the user has specified particular projection detail
1908             # then build up a key which can represent this
1909             else:
1910                 projection_class, _, key = \
1911                     self._process_projection_requirements(**kwargs)
1912 
1913                 # let the returned axes have any gridspec by removing it from
1914                 # the key
1915                 ckey = ckey[1:]
1916                 key = key[1:]
1917 
1918                 # if the cax matches this key then return the axes, otherwise
1919                 # continue and a new axes will be created
1920                 if key == ckey and isinstance(cax, projection_class):
1921                     return cax
1922                 else:
1923                     cbook._warn_external('Requested projection is different '
1924                                          'from current axis projection, '
1925                                          'creating new axis with requested '
1926                                          'projection.')
1927 
1928         # no axes found, so create one which spans the figure
1929         return self.add_subplot(1, 1, 1, **kwargs)
1930 
1931     def sca(self, a):
1932         """Set the current axes to be a and return a."""
1933         self._axstack.bubble(a)
1934         for func in self._axobservers:
1935             func(self)
1936         return a
1937 
1938     def _gci(self):
1939         """
1940         Helper for :func:`~matplotlib.pyplot.gci`. Do not use elsewhere.
1941         """
1942         # Look first for an image in the current Axes:
1943         cax = self._axstack.current_key_axes()[1]
1944         if cax is None:
1945             return None
1946         im = cax._gci()
1947         if im is not None:
1948             return im
1949 
1950         # If there is no image in the current Axes, search for
1951         # one in a previously created Axes.  Whether this makes
1952         # sense is debatable, but it is the documented behavior.
1953         for ax in reversed(self.axes):
1954             im = ax._gci()
1955             if im is not None:
1956                 return im
1957         return None
1958 
1959     def __getstate__(self):
1960         state = super().__getstate__()
1961 
1962         # the axobservers cannot currently be pickled.
1963         # Additionally, the canvas cannot currently be pickled, but this has
1964         # the benefit of meaning that a figure can be detached from one canvas,
1965         # and re-attached to another.
1966         for attr_to_pop in ('_axobservers', 'show',
1967                             'canvas', '_cachedRenderer'):
1968             state.pop(attr_to_pop, None)
1969 
1970         # add version information to the state
1971         state['__mpl_version__'] = _mpl_version
1972 
1973         # check whether the figure manager (if any) is registered with pyplot
1974         from matplotlib import _pylab_helpers
1975         if getattr(self.canvas, 'manager', None) \
1976                 in _pylab_helpers.Gcf.figs.values():
1977             state['_restore_to_pylab'] = True
1978 
1979         # set all the layoutbox information to None.  kiwisolver objects can't
1980         # be pickled, so we lose the layout options at this point.
1981         state.pop('_layoutbox', None)
1982         # suptitle:
1983         if self._suptitle is not None:
1984             self._suptitle._layoutbox = None
1985 
1986         return state
1987 
1988     def __setstate__(self, state):
1989         version = state.pop('__mpl_version__')
1990         restore_to_pylab = state.pop('_restore_to_pylab', False)
1991 
1992         if version != _mpl_version:
1993             cbook._warn_external(
1994                 f"This figure was saved with matplotlib version {version} and "
1995                 f"is unlikely to function correctly.")
1996 
1997         self.__dict__ = state
1998 
1999         # re-initialise some of the unstored state information
2000         self._axobservers = []
2001         self.canvas = None
2002         self._layoutbox = None
2003 
2004         if restore_to_pylab:
2005             # lazy import to avoid circularity
2006             import matplotlib.pyplot as plt
2007             import matplotlib._pylab_helpers as pylab_helpers
2008             allnums = plt.get_fignums()
2009             num = max(allnums) + 1 if allnums else 1
2010             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)
2011 
2012             # XXX The following is a copy and paste from pyplot. Consider
2013             # factoring to pylab_helpers
2014 
2015             if self.get_label():
2016                 mgr.set_window_title(self.get_label())
2017 
2018             # make this figure current on button press event
2019             def make_active(event):
2020                 pylab_helpers.Gcf.set_active(mgr)
2021 
2022             mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',
2023                                                  make_active)
2024 
2025             pylab_helpers.Gcf.set_active(mgr)
2026             self.number = num
2027 
2028             plt.draw_if_interactive()
2029         self.stale = True
2030 
2031     def add_axobserver(self, func):
2032         """Whenever the axes state change, ``func(self)`` will be called."""
2033         self._axobservers.append(func)
2034 
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])
2186 
2187     @docstring.dedent_interpd
2188     def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):
2189         """
2190         Create a colorbar for a ScalarMappable instance, *mappable*.
2191 
2192         Documentation for the pyplot thin wrapper:
2193         %(colorbar_doc)s
2194         """
2195         if ax is None:
2196             ax = self.gca()
2197 
2198         # Store the value of gca so that we can set it back later on.
2199         current_ax = self.gca()
2200 
2201         if cax is None:
2202             if use_gridspec and isinstance(ax, SubplotBase)  \
2203                      and (not self.get_constrained_layout()):
2204                 cax, kw = cbar.make_axes_gridspec(ax, **kw)
2205             else:
2206                 cax, kw = cbar.make_axes(ax, **kw)
2207 
2208         # need to remove kws that cannot be passed to Colorbar
2209         NON_COLORBAR_KEYS = ['fraction', 'pad', 'shrink', 'aspect', 'anchor',
2210                              'panchor']
2211         cb_kw = {k: v for k, v in kw.items() if k not in NON_COLORBAR_KEYS}
2212         cb = cbar.colorbar_factory(cax, mappable, **cb_kw)
2213 
2214         self.sca(current_ax)
2215         self.stale = True
2216         return cb
2217 
2218     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
2219                         wspace=None, hspace=None):
2220         """
2221         Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when
2222         *None*) and update the subplot locations.
2223 
2224         """
2225         if self.get_constrained_layout():
2226             self.set_constrained_layout(False)
2227             cbook._warn_external("This figure was using "
2228                                  "constrained_layout==True, but that is "
2229                                  "incompatible with subplots_adjust and or "
2230                                  "tight_layout: setting "
2231                                  "constrained_layout==False. ")
2232         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
2233         for ax in self.axes:
2234             if not isinstance(ax, SubplotBase):
2235                 # Check if sharing a subplots axis
2236                 if isinstance(ax._sharex, SubplotBase):
2237                     ax._sharex.update_params()
2238                     ax.set_position(ax._sharex.figbox)
2239                 elif isinstance(ax._sharey, SubplotBase):
2240                     ax._sharey.update_params()
2241                     ax.set_position(ax._sharey.figbox)
2242             else:
2243                 ax.update_params()
2244                 ax.set_position(ax.figbox)
2245         self.stale = True
2246 
2247     def ginput(self, n=1, timeout=30, show_clicks=True, mouse_add=1,
2248                mouse_pop=3, mouse_stop=2):
2249         """
2250         Blocking call to interact with a figure.
2251 
2252         Wait until the user clicks *n* times on the figure, and return the
2253         coordinates of each click in a list.
2254 
2255         There are three possible interactions:
2256 
2257         - Add a point.
2258         - Remove the most recently added point.
2259         - Stop the interaction and return the points added so far.
2260 
2261         The actions are assigned to mouse buttons via the arguments
2262         *mouse_add*, *mouse_pop* and *mouse_stop*. Mouse buttons are defined
2263         by the numbers:
2264 
2265         - 1: left mouse button
2266         - 2: middle mouse button
2267         - 3: right mouse button
2268         - None: no mouse button
2269 
2270         Parameters
2271         ----------
2272         n : int, optional, default: 1
2273             Number of mouse clicks to accumulate. If negative, accumulate
2274             clicks until the input is terminated manually.
2275         timeout : scalar, optional, default: 30
2276             Number of seconds to wait before timing out. If zero or negative
2277             will never timeout.
2278         show_clicks : bool, optional, default: False
2279             If True, show a red cross at the location of each click.
2280         mouse_add : {1, 2, 3, None}, optional, default: 1 (left click)
2281             Mouse button used to add points.
2282         mouse_pop : {1, 2, 3, None}, optional, default: 3 (right click)
2283             Mouse button used to remove the most recently added point.
2284         mouse_stop : {1, 2, 3, None}, optional, default: 2 (middle click)
2285             Mouse button used to stop input.
2286 
2287         Returns
2288         -------
2289         points : list of tuples
2290             A list of the clicked (x, y) coordinates.
2291 
2292         Notes
2293         -----
2294         The keyboard can also be used to select points in case your mouse
2295         does not have one or more of the buttons.  The delete and backspace
2296         keys act like right clicking (i.e., remove last point), the enter key
2297         terminates input and any other key (not already used by the window
2298         manager) selects a point.
2299         """
2300         blocking_mouse_input = BlockingMouseInput(self,
2301                                                   mouse_add=mouse_add,
2302                                                   mouse_pop=mouse_pop,
2303                                                   mouse_stop=mouse_stop)
2304         return blocking_mouse_input(n=n, timeout=timeout,
2305                                     show_clicks=show_clicks)
2306 
2307     def waitforbuttonpress(self, timeout=-1):
2308         """
2309         Blocking call to interact with the figure.
2310 
2311         This will return True is a key was pressed, False if a mouse
2312         button was pressed and None if *timeout* was reached without
2313         either being pressed.
2314 
2315         If *timeout* is negative, does not timeout.
2316         """
2317         blocking_input = BlockingKeyMouseInput(self)
2318         return blocking_input(timeout=timeout)
2319 
2320     def get_default_bbox_extra_artists(self):
2321         bbox_artists = [artist for artist in self.get_children()
2322                         if (artist.get_visible() and artist.get_in_layout())]
2323         for ax in self.axes:
2324             if ax.get_visible():
2325                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
2326         # we don't want the figure's patch to influence the bbox calculation
2327         bbox_artists.remove(self.patch)
2328         return bbox_artists
2329 
2330     def get_tightbbox(self, renderer, bbox_extra_artists=None):
2331         """
2332         Return a (tight) bounding box of the figure in inches.
2333 
2334         Artists that have ``artist.set_in_layout(False)`` are not included
2335         in the bbox.
2336 
2337         Parameters
2338         ----------
2339         renderer : `.RendererBase` instance
2340             renderer that will be used to draw the figures (i.e.
2341             ``fig.canvas.get_renderer()``)
2342 
2343         bbox_extra_artists : list of `.Artist` or ``None``
2344             List of artists to include in the tight bounding box.  If
2345             ``None`` (default), then all artist children of each axes are
2346             included in the tight bounding box.
2347 
2348         Returns
2349         -------
2350         bbox : `.BboxBase`
2351             containing the bounding box (in figure inches).
2352         """
2353 
2354         bb = []
2355         if bbox_extra_artists is None:
2356             artists = self.get_default_bbox_extra_artists()
2357         else:
2358             artists = bbox_extra_artists
2359 
2360         for a in artists:
2361             bbox = a.get_tightbbox(renderer)
2362             if bbox is not None and (bbox.width != 0 or bbox.height != 0):
2363                 bb.append(bbox)
2364 
2365         for ax in self.axes:
2366             if ax.get_visible():
2367                 # some axes don't take the bbox_extra_artists kwarg so we
2368                 # need this conditional....
2369                 try:
2370                     bbox = ax.get_tightbbox(renderer,
2371                             bbox_extra_artists=bbox_extra_artists)
2372                 except TypeError:
2373                     bbox = ax.get_tightbbox(renderer)
2374                 bb.append(bbox)
2375         bb = [b for b in bb
2376               if (np.isfinite(b.width) and np.isfinite(b.height)
2377                   and (b.width != 0 or b.height != 0))]
2378 
2379         if len(bb) == 0:
2380             return self.bbox_inches
2381 
2382         _bbox = Bbox.union(bb)
2383 
2384         bbox_inches = TransformedBbox(_bbox,
2385                                       Affine2D().scale(1. / self.dpi))
2386 
2387         return bbox_inches
2388 
2389     def init_layoutbox(self):
2390         """Initialize the layoutbox for use in constrained_layout."""
2391         if self._layoutbox is None:
2392             self._layoutbox = layoutbox.LayoutBox(parent=None,
2393                                      name='figlb',
2394                                      artist=self)
2395             self._layoutbox.constrain_geometry(0., 0., 1., 1.)
2396 
2397     def execute_constrained_layout(self, renderer=None):
2398         """
2399         Use ``layoutbox`` to determine pos positions within axes.
2400 
2401         See also `.set_constrained_layout_pads`.
2402         """
2403 
2404         from matplotlib._constrained_layout import do_constrained_layout
2405 
2406         _log.debug('Executing constrainedlayout')
2407         if self._layoutbox is None:
2408             cbook._warn_external("Calling figure.constrained_layout, but "
2409                                  "figure not setup to do constrained layout. "
2410                                  " You either called GridSpec without the "
2411                                  "fig keyword, you are using plt.subplot, "
2412                                  "or you need to call figure or subplots "
2413                                  "with the constrained_layout=True kwarg.")
2414             return
2415         w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()
2416         # convert to unit-relative lengths
2417         fig = self
2418         width, height = fig.get_size_inches()
2419         w_pad = w_pad / width
2420         h_pad = h_pad / height
2421         if renderer is None:
2422             renderer = layoutbox.get_renderer(fig)
2423         do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)
2424 
2425     def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,
2426                      rect=None):
2427         """
2428         Automatically adjust subplot parameters to give specified padding.
2429 
2430         To exclude an artist on the axes from the bounding box calculation
2431         that determines the subplot parameters (i.e. legend, or annotation),
2432         then set `a.set_in_layout(False)` for that artist.
2433 
2434         Parameters
2435         ----------
2436         renderer : subclass of `~.backend_bases.RendererBase`, optional
2437             Defaults to the renderer for the figure.
2438 
2439         pad : float, optional
2440             Padding between the figure edge and the edges of subplots,
2441             as a fraction of the font size.
2442         h_pad, w_pad : float, optional
2443             Padding (height/width) between edges of adjacent subplots,
2444             as a fraction of the font size.  Defaults to *pad*.
2445         rect : tuple (left, bottom, right, top), optional
2446             A rectangle (left, bottom, right, top) in the normalized
2447             figure coordinate that the whole subplots area (including
2448             labels) will fit into. Default is (0, 0, 1, 1).
2449 
2450         See Also
2451         --------
2452         .Figure.set_tight_layout
2453         .pyplot.tight_layout
2454         """
2455 
2456         from .tight_layout import (
2457             get_renderer, get_subplotspec_list, get_tight_layout_figure)
2458 
2459         subplotspec_list = get_subplotspec_list(self.axes)
2460         if None in subplotspec_list:
2461             cbook._warn_external("This figure includes Axes that are not "
2462                                  "compatible with tight_layout, so results "
2463                                  "might be incorrect.")
2464 
2465         if renderer is None:
2466             renderer = get_renderer(self)
2467 
2468         kwargs = get_tight_layout_figure(
2469             self, self.axes, subplotspec_list, renderer,
2470             pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2471         if kwargs:
2472             self.subplots_adjust(**kwargs)
2473 
2474     def align_xlabels(self, axs=None):
2475         """
2476         Align the ylabels of subplots in the same subplot column if label
2477         alignment is being done automatically (i.e. the label position is
2478         not manually set).
2479 
2480         Alignment persists for draw events after this is called.
2481 
2482         If a label is on the bottom, it is aligned with labels on axes that
2483         also have their label on the bottom and that have the same
2484         bottom-most subplot row.  If the label is on the top,
2485         it is aligned with labels on axes with the same top-most row.
2486 
2487         Parameters
2488         ----------
2489         axs : list of `~matplotlib.axes.Axes`
2490             Optional list of (or ndarray) `~matplotlib.axes.Axes`
2491             to align the xlabels.
2492             Default is to align all axes on the figure.
2493 
2494         See Also
2495         --------
2496         matplotlib.figure.Figure.align_ylabels
2497 
2498         matplotlib.figure.Figure.align_labels
2499 
2500         Notes
2501         -----
2502         This assumes that ``axs`` are from the same `.GridSpec`, so that
2503         their `.SubplotSpec` positions correspond to figure positions.
2504 
2505         Examples
2506         --------
2507         Example with rotated xtick labels::
2508 
2509             fig, axs = plt.subplots(1, 2)
2510             for tick in axs[0].get_xticklabels():
2511                 tick.set_rotation(55)
2512             axs[0].set_xlabel('XLabel 0')
2513             axs[1].set_xlabel('XLabel 1')
2514             fig.align_xlabels()
2515 
2516         """
2517 
2518         if axs is None:
2519             axs = self.axes
2520         axs = np.asarray(axs).ravel()
2521         for ax in axs:
2522             _log.debug(' Working on: %s', ax.get_xlabel())
2523             ss = ax.get_subplotspec()
2524             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2525             labpo = ax.xaxis.get_label_position()  # top or bottom
2526 
2527             # loop through other axes, and search for label positions
2528             # that are same as this one, and that share the appropriate
2529             # row number.
2530             #  Add to a grouper associated with each axes of sibblings.
2531             # This list is inspected in `axis.draw` by
2532             # `axis._update_label_position`.
2533             for axc in axs:
2534                 if axc.xaxis.get_label_position() == labpo:
2535                     ss = axc.get_subplotspec()
2536                     nrows, ncols, rowc0, rowc1, colc, col1 = \
2537                             ss.get_rows_columns()
2538                     if (labpo == 'bottom' and rowc1 == row1 or
2539                         labpo == 'top' and rowc0 == row0):
2540                         # grouper for groups of xlabels to align
2541                         self._align_xlabel_grp.join(ax, axc)
2542 
2543     def align_ylabels(self, axs=None):
2544         """
2545         Align the ylabels of subplots in the same subplot column if label
2546         alignment is being done automatically (i.e. the label position is
2547         not manually set).
2548 
2549         Alignment persists for draw events after this is called.
2550 
2551         If a label is on the left, it is aligned with labels on axes that
2552         also have their label on the left and that have the same
2553         left-most subplot column.  If the label is on the right,
2554         it is aligned with labels on axes with the same right-most column.
2555 
2556         Parameters
2557         ----------
2558         axs : list of `~matplotlib.axes.Axes`
2559             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2560             to align the ylabels.
2561             Default is to align all axes on the figure.
2562 
2563         See Also
2564         --------
2565         matplotlib.figure.Figure.align_xlabels
2566 
2567         matplotlib.figure.Figure.align_labels
2568 
2569         Notes
2570         -----
2571         This assumes that ``axs`` are from the same `.GridSpec`, so that
2572         their `.SubplotSpec` positions correspond to figure positions.
2573 
2574         Examples
2575         --------
2576         Example with large yticks labels::
2577 
2578             fig, axs = plt.subplots(2, 1)
2579             axs[0].plot(np.arange(0, 1000, 50))
2580             axs[0].set_ylabel('YLabel 0')
2581             axs[1].set_ylabel('YLabel 1')
2582             fig.align_ylabels()
2583 
2584         """
2585 
2586         if axs is None:
2587             axs = self.axes
2588         axs = np.asarray(axs).ravel()
2589         for ax in axs:
2590             _log.debug(' Working on: %s', ax.get_ylabel())
2591             ss = ax.get_subplotspec()
2592             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2593             labpo = ax.yaxis.get_label_position()  # left or right
2594             # loop through other axes, and search for label positions
2595             # that are same as this one, and that share the appropriate
2596             # column number.
2597             # Add to a list associated with each axes of sibblings.
2598             # This list is inspected in `axis.draw` by
2599             # `axis._update_label_position`.
2600             for axc in axs:
2601                 if axc != ax:
2602                     if axc.yaxis.get_label_position() == labpo:
2603                         ss = axc.get_subplotspec()
2604                         nrows, ncols, row0, row1, colc0, colc1 = \
2605                                 ss.get_rows_columns()
2606                         if (labpo == 'left' and colc0 == col0 or
2607                             labpo == 'right' and colc1 == col1):
2608                             # grouper for groups of ylabels to align
2609                             self._align_ylabel_grp.join(ax, axc)
2610 
2611     def align_labels(self, axs=None):
2612         """
2613         Align the xlabels and ylabels of subplots with the same subplots
2614         row or column (respectively) if label alignment is being
2615         done automatically (i.e. the label position is not manually set).
2616 
2617         Alignment persists for draw events after this is called.
2618 
2619         Parameters
2620         ----------
2621         axs : list of `~matplotlib.axes.Axes`
2622             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2623             to align the labels.
2624             Default is to align all axes on the figure.
2625 
2626         See Also
2627         --------
2628         matplotlib.figure.Figure.align_xlabels
2629 
2630         matplotlib.figure.Figure.align_ylabels
2631         """
2632         self.align_xlabels(axs=axs)
2633         self.align_ylabels(axs=axs)
2634 
2635     def add_gridspec(self, nrows, ncols, **kwargs):
2636         """
2637         Return a `.GridSpec` that has this figure as a parent.  This allows
2638         complex layout of axes in the figure.
2639 
2640         Parameters
2641         ----------
2642         nrows : int
2643             Number of rows in grid.
2644 
2645         ncols : int
2646             Number or columns in grid.
2647 
2648         Returns
2649         -------
2650         gridspec : `.GridSpec`
2651 
2652         Other Parameters
2653         ----------------
2654         **kwargs
2655             Keyword arguments are passed to `.GridSpec`.
2656 
2657         See Also
2658         --------
2659         matplotlib.pyplot.subplots
2660 
2661         Examples
2662         --------
2663         Adding a subplot that spans two rows::
2664 
2665             fig = plt.figure()
2666             gs = fig.add_gridspec(2, 2)
2667             ax1 = fig.add_subplot(gs[0, 0])
2668             ax2 = fig.add_subplot(gs[1, 0])
2669             # spans two rows:
2670             ax3 = fig.add_subplot(gs[:, 1])
2671 
2672         """
2673 
2674         _ = kwargs.pop('figure', None)  # pop in case user has added this...
2675         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
2676         self._gridspecs.append(gs)
2677         return gs

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>savefig</method>
<code>
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])

</code><intended_behavior>The `savefig` method across its various implementations should include a pre-save validation process that checks if the figure dimensions (width and height) are valid (i.e., greater than zero). If the dimensions are not valid, it should raise an informative `RuntimeError` or a `ValueError` explaining that saving a figure requires both width and height to be positive numbers. This change will prevent unhandled low-level errors (e.g., from libpng) by catching the issue at the matplotlib level, thereby providing a more informative error message to the user. This intended behavior also maintains the functionality of the method while enforcing a check that aligns with the requirements of dependent libraries like libpng.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>savefig</method>
<code>
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])

</code><intended_behavior>The `savefig` method across its various implementations should include a pre-save validation process that checks if the figure dimensions (width and height) are valid (i.e., greater than zero). If the dimensions are not valid, it should raise an informative `RuntimeError` or a `ValueError` explaining that saving a figure requires both width and height to be positive numbers. This change will prevent unhandled low-level errors (e.g., from libpng) by catching the issue at the matplotlib level, thereby providing a more informative error message to the user. This intended behavior also maintains the functionality of the method while enforcing a check that aligns with the requirements of dependent libraries like libpng.</intended_behavior>]
2025-10-15 07:08:22.180 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:08:22.180 | INFO     | Search-only: skipping patch selection
2025-10-15 07:08:22.263 | INFO     | Task matplotlib__matplotlib-13859 completed successfully.
2025-10-15 07:08:22.264 | INFO     | No patch generated. You can try running ACR again.
