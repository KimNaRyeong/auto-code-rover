[
    {
        "rel_file_path": "django/template/loader_tags.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/template/loader_tags.py",
        "start": 162,
        "end": 188,
        "class_name": "IncludeNode",
        "method_name": "render",
        "code": "162     def render(self, context):\n163         \"\"\"\n164         Render the specified template and context. Cache the template object\n165         in render_context to avoid reparsing and loading when used in a for\n166         loop.\n167         \"\"\"\n168         template = self.template.resolve(context)\n169         # Does this quack like a Template?\n170         if not callable(getattr(template, 'render', None)):\n171             # If not, try the cache and get_template().\n172             template_name = template\n173             cache = context.render_context.dicts[0].setdefault(self, {})\n174             template = cache.get(template_name)\n175             if template is None:\n176                 template = context.template.engine.get_template(template_name)\n177                 cache[template_name] = template\n178         # Use the base.Template of a backends.django.Template.\n179         elif hasattr(template, 'template'):\n180             template = template.template\n181         values = {\n182             name: var.resolve(context)\n183             for name, var in self.extra_context.items()\n184         }\n185         if self.isolated_context:\n186             return template.render(context.new(values))\n187         with context.push(**values):\n188             return template.render(context)\n",
        "intended_behavior": "This method should be updated to use `select_template` whenever the template to be included is specified as a list of possible templates. The current implementation utilizes `get_template`, which does not support lists and can only handle a single template name. To resolve the issue while preserving existing functionality, the method should: Check if the resolved template variable (`self.template.resolve(context)`) is a list. If it is a list, use `select_template` instead of `get_template` to select the first existing template from the list. Ensure that the original single-template functionality remains unchanged for backward compatibility. This means keeping the logic for when a single template name is resolved (not a list), it should still use `get_template` as it currently does. All other aspects of the `render` method should remain the same, ensuring that template rendering still respects the current context or a new, isolated context if specified by `self.isolated_context`."
    },
    {
        "rel_file_path": "django/template/loader_tags.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/template/loader_tags.py",
        "start": 153,
        "end": 188,
        "class_name": "IncludeNode",
        "method_name": null,
        "code": "153 class IncludeNode(Node):\n154     context_key = '__include_context'\n155 \n156     def __init__(self, template, *args, extra_context=None, isolated_context=False, **kwargs):\n157         self.template = template\n158         self.extra_context = extra_context or {}\n159         self.isolated_context = isolated_context\n160         super().__init__(*args, **kwargs)\n161 \n162     def render(self, context):\n163         \"\"\"\n164         Render the specified template and context. Cache the template object\n165         in render_context to avoid reparsing and loading when used in a for\n166         loop.\n167         \"\"\"\n168         template = self.template.resolve(context)\n169         # Does this quack like a Template?\n170         if not callable(getattr(template, 'render', None)):\n171             # If not, try the cache and get_template().\n172             template_name = template\n173             cache = context.render_context.dicts[0].setdefault(self, {})\n174             template = cache.get(template_name)\n175             if template is None:\n176                 template = context.template.engine.get_template(template_name)\n177                 cache[template_name] = template\n178         # Use the base.Template of a backends.django.Template.\n179         elif hasattr(template, 'template'):\n180             template = template.template\n181         values = {\n182             name: var.resolve(context)\n183             for name, var in self.extra_context.items()\n184         }\n185         if self.isolated_context:\n186             return template.render(context.new(values))\n187         with context.push(**values):\n188             return template.render(context)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]