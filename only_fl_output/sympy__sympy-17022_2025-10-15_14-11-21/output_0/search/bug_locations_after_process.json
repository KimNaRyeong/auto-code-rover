[
    {
        "rel_file_path": "sympy/utilities/lambdify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/utilities/lambdify.py",
        "start": 177,
        "end": 795,
        "class_name": null,
        "method_name": "lambdify",
        "code": "177 def lambdify(args, expr, modules=None, printer=None, use_imps=True,\n178              dummify=False):\n179     \"\"\"\n180     Translates a SymPy expression into an equivalent numeric function\n181 \n182     For example, to convert the SymPy expression ``sin(x) + cos(x)`` to an\n183     equivalent NumPy function that numerically evaluates it:\n184 \n185     >>> from sympy import sin, cos, symbols, lambdify\n186     >>> import numpy as np\n187     >>> x = symbols('x')\n188     >>> expr = sin(x) + cos(x)\n189     >>> expr\n190     sin(x) + cos(x)\n191     >>> f = lambdify(x, expr, 'numpy')\n192     >>> a = np.array([1, 2])\n193     >>> f(a)\n194     [1.38177329 0.49315059]\n195 \n196     The primary purpose of this function is to provide a bridge from SymPy\n197     expressions to numerical libraries such as NumPy, SciPy, NumExpr, mpmath,\n198     and tensorflow. In general, SymPy functions do not work with objects from\n199     other libraries, such as NumPy arrays, and functions from numeric\n200     libraries like NumPy or mpmath do not work on SymPy expressions.\n201     ``lambdify`` bridges the two by converting a SymPy expression to an\n202     equivalent numeric function.\n203 \n204     The basic workflow with ``lambdify`` is to first create a SymPy expression\n205     representing whatever mathematical function you wish to evaluate. This\n206     should be done using only SymPy functions and expressions. Then, use\n207     ``lambdify`` to convert this to an equivalent function for numerical\n208     evaluation. For instance, above we created ``expr`` using the SymPy symbol\n209     ``x`` and SymPy functions ``sin`` and ``cos``, then converted it to an\n210     equivalent NumPy function ``f``, and called it on a NumPy array ``a``.\n211 \n212     .. warning::\n213        This function uses ``exec``, and thus shouldn't be used on unsanitized\n214        input.\n215 \n216     Arguments\n217     =========\n218 \n219     The first argument of ``lambdify`` is a variable or list of variables in\n220     the expression. Variable lists may be nested. Variables can be Symbols,\n221     undefined functions, or matrix symbols. The order and nesting of the\n222     variables corresponds to the order and nesting of the parameters passed to\n223     the lambdified function. For instance,\n224 \n225     >>> from sympy.abc import x, y, z\n226     >>> f = lambdify([x, (y, z)], x + y + z)\n227     >>> f(1, (2, 3))\n228     6\n229 \n230     The second argument of ``lambdify`` is the expression, list of\n231     expressions, or matrix to be evaluated. Lists may be nested. If the\n232     expression is a list, the output will also be a list.\n233 \n234     >>> f = lambdify(x, [x, [x + 1, x + 2]])\n235     >>> f(1)\n236     [1, [2, 3]]\n237 \n238     If it is a matrix, an array will be returned (for the NumPy module).\n239 \n240     >>> from sympy import Matrix\n241     >>> f = lambdify(x, Matrix([x, x + 1]))\n242     >>> f(1)\n243     [[1]\n244      [2]]\n245 \n246     Note that the argument order here, variables then expression, is used to\n247     emulate the Python ``lambda`` keyword. ``lambdify(x, expr)`` works\n248     (roughly) like ``lambda x: expr`` (see :ref:`lambdify-how-it-works` below).\n249 \n250     The third argument, ``modules`` is optional. If not specified, ``modules``\n251     defaults to ``[\"scipy\", \"numpy\"]`` if SciPy is installed, ``[\"numpy\"]`` if\n252     only NumPy is installed, and ``[\"math\", \"mpmath\", \"sympy\"]`` if neither is\n253     installed. That is, SymPy functions are replaced as far as possible by\n254     either ``scipy`` or ``numpy`` functions if available, and Python's\n255     standard library ``math``, or ``mpmath`` functions otherwise.\n256 \n257     ``modules`` can be one of the following types\n258 \n259      - the strings ``\"math\"``, ``\"mpmath\"``, ``\"numpy\"``, ``\"numexpr\"``,\n260        ``\"scipy\"``, ``\"sympy\"``, or ``\"tensorflow\"``. This uses the\n261        corresponding printer and namespace mapping for that module.\n262      - a module (e.g., ``math``). This uses the global namespace of the\n263        module. If the module is one of the above known modules, it will also\n264        use the corresponding printer and namespace mapping (i.e.,\n265        ``modules=numpy`` is equivalent to ``modules=\"numpy\"``).\n266      - a dictionary that maps names of SymPy functions to arbitrary functions\n267        (e.g., ``{'sin': custom_sin}``).\n268      - a list that contains a mix of the arguments above, with higher priority\n269        given to entries appearing first (e.g., to use the NumPy module but\n270        override the ``sin`` function with a custom version, you can use\n271        ``[{'sin': custom_sin}, 'numpy']``).\n272 \n273     The ``dummify`` keyword argument controls whether or not the variables in\n274     the provided expression that are not valid Python identifiers are\n275     substituted with dummy symbols. This allows for undefined functions like\n276     ``Function('f')(t)`` to be supplied as arguments. By default, the\n277     variables are only dummified if they are not valid Python identifiers. Set\n278     ``dummify=True`` to replace all arguments with dummy symbols (if ``args``\n279     is not a string) - for example, to ensure that the arguments do not\n280     redefine any built-in names.\n281 \n282     .. _lambdify-how-it-works:\n283 \n284     How it works\n285     ============\n286 \n287     When using this function, it helps a great deal to have an idea of what it\n288     is doing. At its core, lambdify is nothing more than a namespace\n289     translation, on top of a special printer that makes some corner cases work\n290     properly.\n291 \n292     To understand lambdify, first we must properly understand how Python\n293     namespaces work. Say we had two files. One called ``sin_cos_sympy.py``,\n294     with\n295 \n296     .. code:: python\n297 \n298         # sin_cos_sympy.py\n299 \n300         from sympy import sin, cos\n301 \n302         def sin_cos(x):\n303             return sin(x) + cos(x)\n304 \n305 \n306     and one called ``sin_cos_numpy.py`` with\n307 \n308     .. code:: python\n309 \n310         # sin_cos_numpy.py\n311 \n312         from numpy import sin, cos\n313 \n314         def sin_cos(x):\n315             return sin(x) + cos(x)\n316 \n317     The two files define an identical function ``sin_cos``. However, in the\n318     first file, ``sin`` and ``cos`` are defined as the SymPy ``sin`` and\n319     ``cos``. In the second, they are defined as the NumPy versions.\n320 \n321     If we were to import the first file and use the ``sin_cos`` function, we\n322     would get something like\n323 \n324     >>> from sin_cos_sympy import sin_cos # doctest: +SKIP\n325     >>> sin_cos(1) # doctest: +SKIP\n326     cos(1) + sin(1)\n327 \n328     On the other hand, if we imported ``sin_cos`` from the second file, we\n329     would get\n330 \n331     >>> from sin_cos_numpy import sin_cos # doctest: +SKIP\n332     >>> sin_cos(1) # doctest: +SKIP\n333     1.38177329068\n334 \n335     In the first case we got a symbolic output, because it used the symbolic\n336     ``sin`` and ``cos`` functions from SymPy. In the second, we got a numeric\n337     result, because ``sin_cos`` used the numeric ``sin`` and ``cos`` functions\n338     from NumPy. But notice that the versions of ``sin`` and ``cos`` that were\n339     used was not inherent to the ``sin_cos`` function definition. Both\n340     ``sin_cos`` definitions are exactly the same. Rather, it was based on the\n341     names defined at the module where the ``sin_cos`` function was defined.\n342 \n343     The key point here is that when function in Python references a name that\n344     is not defined in the function, that name is looked up in the \"global\"\n345     namespace of the module where that function is defined.\n346 \n347     Now, in Python, we can emulate this behavior without actually writing a\n348     file to disk using the ``exec`` function. ``exec`` takes a string\n349     containing a block of Python code, and a dictionary that should contain\n350     the global variables of the module. It then executes the code \"in\" that\n351     dictionary, as if it were the module globals. The following is equivalent\n352     to the ``sin_cos`` defined in ``sin_cos_sympy.py``:\n353 \n354     >>> import sympy\n355     >>> module_dictionary = {'sin': sympy.sin, 'cos': sympy.cos}\n356     >>> exec('''\n357     ... def sin_cos(x):\n358     ...     return sin(x) + cos(x)\n359     ... ''', module_dictionary)\n360     >>> sin_cos = module_dictionary['sin_cos']\n361     >>> sin_cos(1)\n362     cos(1) + sin(1)\n363 \n364     and similarly with ``sin_cos_numpy``:\n365 \n366     >>> import numpy\n367     >>> module_dictionary = {'sin': numpy.sin, 'cos': numpy.cos}\n368     >>> exec('''\n369     ... def sin_cos(x):\n370     ...     return sin(x) + cos(x)\n371     ... ''', module_dictionary)\n372     >>> sin_cos = module_dictionary['sin_cos']\n373     >>> sin_cos(1)\n374     1.38177329068\n375 \n376     So now we can get an idea of how ``lambdify`` works. The name \"lambdify\"\n377     comes from the fact that we can think of something like ``lambdify(x,\n378     sin(x) + cos(x), 'numpy')`` as ``lambda x: sin(x) + cos(x)``, where\n379     ``sin`` and ``cos`` come from the ``numpy`` namespace. This is also why\n380     the symbols argument is first in ``lambdify``, as opposed to most SymPy\n381     functions where it comes after the expression: to better mimic the\n382     ``lambda`` keyword.\n383 \n384     ``lambdify`` takes the input expression (like ``sin(x) + cos(x)``) and\n385 \n386     1. Converts it to a string\n387     2. Creates a module globals dictionary based on the modules that are\n388        passed in (by default, it uses the NumPy module)\n389     3. Creates the string ``\"def func({vars}): return {expr}\"``, where ``{vars}`` is the\n390        list of variables separated by commas, and ``{expr}`` is the string\n391        created in step 1., then ``exec``s that string with the module globals\n392        namespace and returns ``func``.\n393 \n394     In fact, functions returned by ``lambdify`` support inspection. So you can\n395     see exactly how they are defined by using ``inspect.getsource``, or ``??`` if you\n396     are using IPython or the Jupyter notebook.\n397 \n398     >>> f = lambdify(x, sin(x) + cos(x))\n399     >>> import inspect\n400     >>> print(inspect.getsource(f))\n401     def _lambdifygenerated(x):\n402         return (sin(x) + cos(x))\n403 \n404     This shows us the source code of the function, but not the namespace it\n405     was defined in. We can inspect that by looking at the ``__globals__``\n406     attribute of ``f``:\n407 \n408     >>> f.__globals__['sin']\n409     <ufunc 'sin'>\n410     >>> f.__globals__['cos']\n411     <ufunc 'cos'>\n412     >>> f.__globals__['sin'] is numpy.sin\n413     True\n414 \n415     This shows us that ``sin`` and ``cos`` in the namespace of ``f`` will be\n416     ``numpy.sin`` and ``numpy.cos``.\n417 \n418     Note that there are some convenience layers in each of these steps, but at\n419     the core, this is how ``lambdify`` works. Step 1 is done using the\n420     ``LambdaPrinter`` printers defined in the printing module (see\n421     :mod:`sympy.printing.lambdarepr`). This allows different SymPy expressions\n422     to define how they should be converted to a string for different modules.\n423     You can change which printer ``lambdify`` uses by passing a custom printer\n424     in to the ``printer`` argument.\n425 \n426     Step 2 is augmented by certain translations. There are default\n427     translations for each module, but you can provide your own by passing a\n428     list to the ``modules`` argument. For instance,\n429 \n430     >>> def mysin(x):\n431     ...     print('taking the sin of', x)\n432     ...     return numpy.sin(x)\n433     ...\n434     >>> f = lambdify(x, sin(x), [{'sin': mysin}, 'numpy'])\n435     >>> f(1)\n436     taking the sin of 1\n437     0.8414709848078965\n438 \n439     The globals dictionary is generated from the list by merging the\n440     dictionary ``{'sin': mysin}`` and the module dictionary for NumPy. The\n441     merging is done so that earlier items take precedence, which is why\n442     ``mysin`` is used above instead of ``numpy.sin``.\n443 \n444     If you want to modify the way ``lambdify`` works for a given function, it\n445     is usually easiest to do so by modifying the globals dictionary as such.\n446     In more complicated cases, it may be necessary to create and pass in a\n447     custom printer.\n448 \n449     Finally, step 3 is augmented with certain convenience operations, such as\n450     the addition of a docstring.\n451 \n452     Understanding how ``lambdify`` works can make it easier to avoid certain\n453     gotchas when using it. For instance, a common mistake is to create a\n454     lambdified function for one module (say, NumPy), and pass it objects from\n455     another (say, a SymPy expression).\n456 \n457     For instance, say we create\n458 \n459     >>> from sympy.abc import x\n460     >>> f = lambdify(x, x + 1, 'numpy')\n461 \n462     Now if we pass in a NumPy array, we get that array plus 1\n463 \n464     >>> import numpy\n465     >>> a = numpy.array([1, 2])\n466     >>> f(a)\n467     [2 3]\n468 \n469     But what happens if you make the mistake of passing in a SymPy expression\n470     instead of a NumPy array:\n471 \n472     >>> f(x + 1)\n473     x + 2\n474 \n475     This worked, but it was only by accident. Now take a different lambdified\n476     function:\n477 \n478     >>> from sympy import sin\n479     >>> g = lambdify(x, x + sin(x), 'numpy')\n480 \n481     This works as expected on NumPy arrays:\n482 \n483     >>> g(a)\n484     [1.84147098 2.90929743]\n485 \n486     But if we try to pass in a SymPy expression, it fails\n487 \n488     >>> g(x + 1)\n489     Traceback (most recent call last):\n490     ...\n491     AttributeError: 'Add' object has no attribute 'sin'\n492 \n493     Now, let's look at what happened. The reason this fails is that ``g``\n494     calls ``numpy.sin`` on the input expression, and ``numpy.sin`` does not\n495     know how to operate on a SymPy object. **As a general rule, NumPy\n496     functions do not know how to operate on SymPy expressions, and SymPy\n497     functions do not know how to operate on NumPy arrays. This is why lambdify\n498     exists: to provide a bridge between SymPy and NumPy.**\n499 \n500     However, why is it that ``f`` did work? That's because ``f`` doesn't call\n501     any functions, it only adds 1. So the resulting function that is created,\n502     ``def _lambdifygenerated(x): return x + 1`` does not depend on the globals\n503     namespace it is defined in. Thus it works, but only by accident. A future\n504     version of ``lambdify`` may remove this behavior.\n505 \n506     Be aware that certain implementation details described here may change in\n507     future versions of SymPy. The API of passing in custom modules and\n508     printers will not change, but the details of how a lambda function is\n509     created may change. However, the basic idea will remain the same, and\n510     understanding it will be helpful to understanding the behavior of\n511     lambdify.\n512 \n513     **In general: you should create lambdified functions for one module (say,\n514     NumPy), and only pass it input types that are compatible with that module\n515     (say, NumPy arrays).** Remember that by default, if the ``module``\n516     argument is not provided, ``lambdify`` creates functions using the NumPy\n517     and SciPy namespaces.\n518 \n519     Examples\n520     ========\n521 \n522     >>> from sympy.utilities.lambdify import implemented_function\n523     >>> from sympy import sqrt, sin, Matrix\n524     >>> from sympy import Function\n525     >>> from sympy.abc import w, x, y, z\n526 \n527     >>> f = lambdify(x, x**2)\n528     >>> f(2)\n529     4\n530     >>> f = lambdify((x, y, z), [z, y, x])\n531     >>> f(1,2,3)\n532     [3, 2, 1]\n533     >>> f = lambdify(x, sqrt(x))\n534     >>> f(4)\n535     2.0\n536     >>> f = lambdify((x, y), sin(x*y)**2)\n537     >>> f(0, 5)\n538     0.0\n539     >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')\n540     >>> row(1, 2)\n541     Matrix([[1, 3]])\n542 \n543     ``lambdify`` can be used to translate SymPy expressions into mpmath\n544     functions. This may be preferable to using ``evalf`` (which uses mpmath on\n545     the backend) in some cases.\n546 \n547     >>> import mpmath\n548     >>> f = lambdify(x, sin(x), 'mpmath')\n549     >>> f(1)\n550     0.8414709848078965\n551 \n552     Tuple arguments are handled and the lambdified function should\n553     be called with the same type of arguments as were used to create\n554     the function:\n555 \n556     >>> f = lambdify((x, (y, z)), x + y)\n557     >>> f(1, (2, 4))\n558     3\n559 \n560     The ``flatten`` function can be used to always work with flattened\n561     arguments:\n562 \n563     >>> from sympy.utilities.iterables import flatten\n564     >>> args = w, (x, (y, z))\n565     >>> vals = 1, (2, (3, 4))\n566     >>> f = lambdify(flatten(args), w + x + y + z)\n567     >>> f(*flatten(vals))\n568     10\n569 \n570     Functions present in ``expr`` can also carry their own numerical\n571     implementations, in a callable attached to the ``_imp_`` attribute. This\n572     can be used with undefined functions using the ``implemented_function``\n573     factory:\n574 \n575     >>> f = implemented_function(Function('f'), lambda x: x+1)\n576     >>> func = lambdify(x, f(x))\n577     >>> func(4)\n578     5\n579 \n580     ``lambdify`` always prefers ``_imp_`` implementations to implementations\n581     in other namespaces, unless the ``use_imps`` input parameter is False.\n582 \n583     Usage with Tensorflow:\n584 \n585     >>> import tensorflow as tf\n586     >>> from sympy import Max, sin\n587     >>> f = Max(x, sin(x))\n588     >>> func = lambdify(x, f, 'tensorflow')\n589     >>> result = func(tf.constant(1.0))\n590     >>> print(result) # a tf.Tensor representing the result of the calculation\n591     Tensor(\"Maximum:0\", shape=(), dtype=float32)\n592     >>> sess = tf.Session()\n593     >>> sess.run(result) # compute result\n594     1.0\n595     >>> var = tf.Variable(1.0)\n596     >>> sess.run(tf.global_variables_initializer())\n597     >>> sess.run(func(var)) # also works for tf.Variable and tf.Placeholder\n598     1.0\n599     >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor\n600     >>> sess.run(func(tensor))\n601     [[1. 2.]\n602      [3. 4.]]\n603 \n604     Notes\n605     =====\n606 \n607     - For functions involving large array calculations, numexpr can provide a\n608       significant speedup over numpy. Please note that the available functions\n609       for numexpr are more limited than numpy but can be expanded with\n610       ``implemented_function`` and user defined subclasses of Function. If\n611       specified, numexpr may be the only option in modules. The official list\n612       of numexpr functions can be found at:\n613       https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions\n614 \n615     - In previous versions of SymPy, ``lambdify`` replaced ``Matrix`` with\n616       ``numpy.matrix`` by default. As of SymPy 1.0 ``numpy.array`` is the\n617       default. To get the old default behavior you must pass in\n618       ``[{'ImmutableDenseMatrix':  numpy.matrix}, 'numpy']`` to the\n619       ``modules`` kwarg.\n620 \n621       >>> from sympy import lambdify, Matrix\n622       >>> from sympy.abc import x, y\n623       >>> import numpy\n624       >>> array2mat = [{'ImmutableDenseMatrix': numpy.matrix}, 'numpy']\n625       >>> f = lambdify((x, y), Matrix([x, y]), modules=array2mat)\n626       >>> f(1, 2)\n627       [[1]\n628        [2]]\n629 \n630     - In the above examples, the generated functions can accept scalar\n631       values or numpy arrays as arguments.  However, in some cases\n632       the generated function relies on the input being a numpy array:\n633 \n634       >>> from sympy import Piecewise\n635       >>> from sympy.utilities.pytest import ignore_warnings\n636       >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"numpy\")\n637 \n638       >>> with ignore_warnings(RuntimeWarning):\n639       ...     f(numpy.array([-1, 0, 1, 2]))\n640       [-1.   0.   1.   0.5]\n641 \n642       >>> f(0)\n643       Traceback (most recent call last):\n644           ...\n645       ZeroDivisionError: division by zero\n646 \n647       In such cases, the input should be wrapped in a numpy array:\n648 \n649       >>> with ignore_warnings(RuntimeWarning):\n650       ...     float(f(numpy.array([0])))\n651       0.0\n652 \n653       Or if numpy functionality is not required another module can be used:\n654 \n655       >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"math\")\n656       >>> f(0)\n657       0\n658 \n659     \"\"\"\n660     from sympy.core.symbol import Symbol\n661 \n662     # If the user hasn't specified any modules, use what is available.\n663     if modules is None:\n664         try:\n665             _import(\"scipy\")\n666         except ImportError:\n667             try:\n668                 _import(\"numpy\")\n669             except ImportError:\n670                 # Use either numpy (if available) or python.math where possible.\n671                 # XXX: This leads to different behaviour on different systems and\n672                 #      might be the reason for irreproducible errors.\n673                 modules = [\"math\", \"mpmath\", \"sympy\"]\n674             else:\n675                 modules = [\"numpy\"]\n676         else:\n677             modules = [\"scipy\", \"numpy\"]\n678 \n679     # Get the needed namespaces.\n680     namespaces = []\n681     # First find any function implementations\n682     if use_imps:\n683         namespaces.append(_imp_namespace(expr))\n684     # Check for dict before iterating\n685     if isinstance(modules, (dict, string_types)) or not hasattr(modules, '__iter__'):\n686         namespaces.append(modules)\n687     else:\n688         # consistency check\n689         if _module_present('numexpr', modules) and len(modules) > 1:\n690             raise TypeError(\"numexpr must be the only item in 'modules'\")\n691         namespaces += list(modules)\n692     # fill namespace with first having highest priority\n693     namespace = {}\n694     for m in namespaces[::-1]:\n695         buf = _get_namespace(m)\n696         namespace.update(buf)\n697 \n698     if hasattr(expr, \"atoms\"):\n699         #Try if you can extract symbols from the expression.\n700         #Move on if expr.atoms in not implemented.\n701         syms = expr.atoms(Symbol)\n702         for term in syms:\n703             namespace.update({str(term): term})\n704 \n705     if printer is None:\n706         if _module_present('mpmath', namespaces):\n707             from sympy.printing.pycode import MpmathPrinter as Printer\n708         elif _module_present('scipy', namespaces):\n709             from sympy.printing.pycode import SciPyPrinter as Printer\n710         elif _module_present('numpy', namespaces):\n711             from sympy.printing.pycode import NumPyPrinter as Printer\n712         elif _module_present('numexpr', namespaces):\n713             from sympy.printing.lambdarepr import NumExprPrinter as Printer\n714         elif _module_present('tensorflow', namespaces):\n715             from sympy.printing.tensorflow import TensorflowPrinter as Printer\n716         elif _module_present('sympy', namespaces):\n717             from sympy.printing.pycode import SymPyPrinter as Printer\n718         else:\n719             from sympy.printing.pycode import PythonCodePrinter as Printer\n720         user_functions = {}\n721         for m in namespaces[::-1]:\n722             if isinstance(m, dict):\n723                 for k in m:\n724                     user_functions[k] = k\n725         printer = Printer({'fully_qualified_modules': False, 'inline': True,\n726                            'allow_unknown_functions': True,\n727                            'user_functions': user_functions})\n728 \n729     # Get the names of the args, for creating a docstring\n730     if not iterable(args):\n731         args = (args,)\n732     names = []\n733     # Grab the callers frame, for getting the names by inspection (if needed)\n734     callers_local_vars = inspect.currentframe().f_back.f_locals.items()\n735     for n, var in enumerate(args):\n736         if hasattr(var, 'name'):\n737             names.append(var.name)\n738         else:\n739             # It's an iterable. Try to get name by inspection of calling frame.\n740             name_list = [var_name for var_name, var_val in callers_local_vars\n741                     if var_val is var]\n742             if len(name_list) == 1:\n743                 names.append(name_list[0])\n744             else:\n745                 # Cannot infer name with certainty. arg_# will have to do.\n746                 names.append('arg_' + str(n))\n747 \n748     # Create the function definition code and execute it\n749     funcname = '_lambdifygenerated'\n750     if _module_present('tensorflow', namespaces):\n751         funcprinter = _TensorflowEvaluatorPrinter(printer, dummify)\n752     else:\n753         funcprinter = _EvaluatorPrinter(printer, dummify)\n754     funcstr = funcprinter.doprint(funcname, args, expr)\n755 \n756     # Collect the module imports from the code printers.\n757     imp_mod_lines = []\n758     for mod, keys in (getattr(printer, 'module_imports', None) or {}).items():\n759         for k in keys:\n760             if k not in namespace:\n761                 imp_mod_lines.append(\"from %s import %s\" % (mod, k))\n762     for ln in imp_mod_lines:\n763         exec_(ln, {}, namespace)\n764 \n765     # Provide lambda expression with builtins, and compatible implementation of range\n766     namespace.update({'builtins':builtins, 'range':range})\n767 \n768     funclocals = {}\n769     global _lambdify_generated_counter\n770     filename = '<lambdifygenerated-%s>' % _lambdify_generated_counter\n771     _lambdify_generated_counter += 1\n772     c = compile(funcstr, filename, 'exec')\n773     exec_(c, namespace, funclocals)\n774     # mtime has to be None or else linecache.checkcache will remove it\n775     linecache.cache[filename] = (len(funcstr), None, funcstr.splitlines(True), filename)\n776 \n777     func = funclocals[funcname]\n778 \n779     # Apply the docstring\n780     sig = \"func({0})\".format(\", \".join(str(i) for i in names))\n781     sig = textwrap.fill(sig, subsequent_indent=' '*8)\n782     expr_str = str(expr)\n783     if len(expr_str) > 78:\n784         expr_str = textwrap.wrap(expr_str, 75)[0] + '...'\n785     func.__doc__ = (\n786         \"Created with lambdify. Signature:\\n\\n\"\n787         \"{sig}\\n\\n\"\n788         \"Expression:\\n\\n\"\n789         \"{expr}\\n\\n\"\n790         \"Source code:\\n\\n\"\n791         \"{src}\\n\\n\"\n792         \"Imported modules:\\n\\n\"\n793         \"{imp_mods}\"\n794         ).format(sig=sig, expr=expr_str, src=funcstr, imp_mods='\\n'.join(imp_mod_lines))\n795     return func\n",
        "intended_behavior": "The `lambdify` function needs to correctly distinguish between the symbolic `Identity` matrix and the complex unit `I`. This could be achieved by enhancing the namespace translation and string conversion processes inside `lambdify` to ensure that `Identity` matrices are properly translated into a function that adds an identity matrix of appropriate dimensions in the numeric library being used, such as NumPy. This requires a conditional check or a more sophisticated mapping for symbols that have ambiguous representations between symbolic and numeric contexts. Ideally, a specific case for handling `Identity(n)` should be added to prevent it from being interpreted as `1j`."
    },
    {
        "rel_file_path": "sympy/printing/pycode.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/printing/pycode.py",
        "start": 1,
        "end": 756,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Python code printers\n3 \n4 This module contains python code printers for plain python as well as NumPy & SciPy enabled code.\n5 \"\"\"\n6 \n7 \n8 from collections import defaultdict\n9 from itertools import chain\n10 from sympy.core import S\n11 from .precedence import precedence\n12 from .codeprinter import CodePrinter\n13 \n14 _kw_py2and3 = {\n15     'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif',\n16     'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in',\n17     'is', 'lambda', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while',\n18     'with', 'yield', 'None'  # 'None' is actually not in Python 2's keyword.kwlist\n19 }\n20 _kw_only_py2 = {'exec', 'print'}\n21 _kw_only_py3 = {'False', 'nonlocal', 'True'}\n22 \n23 _known_functions = {\n24     'Abs': 'abs',\n25 }\n26 _known_functions_math = {\n27     'acos': 'acos',\n28     'acosh': 'acosh',\n29     'asin': 'asin',\n30     'asinh': 'asinh',\n31     'atan': 'atan',\n32     'atan2': 'atan2',\n33     'atanh': 'atanh',\n34     'ceiling': 'ceil',\n35     'cos': 'cos',\n36     'cosh': 'cosh',\n37     'erf': 'erf',\n38     'erfc': 'erfc',\n39     'exp': 'exp',\n40     'expm1': 'expm1',\n41     'factorial': 'factorial',\n42     'floor': 'floor',\n43     'gamma': 'gamma',\n44     'hypot': 'hypot',\n45     'loggamma': 'lgamma',\n46     'log': 'log',\n47     'ln': 'log',\n48     'log10': 'log10',\n49     'log1p': 'log1p',\n50     'log2': 'log2',\n51     'sin': 'sin',\n52     'sinh': 'sinh',\n53     'Sqrt': 'sqrt',\n54     'tan': 'tan',\n55     'tanh': 'tanh'\n56 }  # Not used from ``math``: [copysign isclose isfinite isinf isnan ldexp frexp pow modf\n57 # radians trunc fmod fsum gcd degrees fabs]\n58 _known_constants_math = {\n59     'Exp1': 'e',\n60     'Pi': 'pi',\n61     'E': 'e'\n62     # Only in python >= 3.5:\n63     # 'Infinity': 'inf',\n64     # 'NaN': 'nan'\n65 }\n66 \n67 def _print_known_func(self, expr):\n68     known = self.known_functions[expr.__class__.__name__]\n69     return '{name}({args})'.format(name=self._module_format(known),\n70                                    args=', '.join(map(lambda arg: self._print(arg), expr.args)))\n71 \n72 \n73 def _print_known_const(self, expr):\n74     known = self.known_constants[expr.__class__.__name__]\n75     return self._module_format(known)\n76 \n77 \n78 class AbstractPythonCodePrinter(CodePrinter):\n79     printmethod = \"_pythoncode\"\n80     language = \"Python\"\n81     standard = \"python3\"\n82     reserved_words = _kw_py2and3.union(_kw_only_py3)\n83     modules = None  # initialized to a set in __init__\n84     tab = '    '\n85     _kf = dict(chain(\n86         _known_functions.items(),\n87         [(k, 'math.' + v) for k, v in _known_functions_math.items()]\n88     ))\n89     _kc = {k: 'math.'+v for k, v in _known_constants_math.items()}\n90     _operators = {'and': 'and', 'or': 'or', 'not': 'not'}\n91     _default_settings = dict(\n92         CodePrinter._default_settings,\n93         user_functions={},\n94         precision=17,\n95         inline=True,\n96         fully_qualified_modules=True,\n97         contract=False\n98     )\n99 \n100     def __init__(self, settings=None):\n101         super(AbstractPythonCodePrinter, self).__init__(settings)\n102         self.module_imports = defaultdict(set)\n103         self.known_functions = dict(self._kf, **(settings or {}).get(\n104             'user_functions', {}))\n105         self.known_constants = dict(self._kc, **(settings or {}).get(\n106             'user_constants', {}))\n107 \n108     def _declare_number_const(self, name, value):\n109         return \"%s = %s\" % (name, value)\n110 \n111     def _module_format(self, fqn, register=True):\n112         parts = fqn.split('.')\n113         if register and len(parts) > 1:\n114             self.module_imports['.'.join(parts[:-1])].add(parts[-1])\n115 \n116         if self._settings['fully_qualified_modules']:\n117             return fqn\n118         else:\n119             return fqn.split('(')[0].split('[')[0].split('.')[-1]\n120 \n121     def _format_code(self, lines):\n122         return lines\n123 \n124     def _get_statement(self, codestring):\n125         return \"{}\".format(codestring)\n126 \n127     def _get_comment(self, text):\n128         return \"  # {0}\".format(text)\n129 \n130     def _expand_fold_binary_op(self, op, args):\n131         \"\"\"\n132         This method expands a fold on binary operations.\n133 \n134         ``functools.reduce`` is an example of a folded operation.\n135 \n136         For example, the expression\n137 \n138         `A + B + C + D`\n139 \n140         is folded into\n141 \n142         `((A + B) + C) + D`\n143         \"\"\"\n144         if len(args) == 1:\n145             return self._print(args[0])\n146         else:\n147             return \"%s(%s, %s)\" % (\n148                 self._module_format(op),\n149                 self._expand_fold_binary_op(op, args[:-1]),\n150                 self._print(args[-1]),\n151             )\n152 \n153     def _expand_reduce_binary_op(self, op, args):\n154         \"\"\"\n155         This method expands a reductin on binary operations.\n156 \n157         Notice: this is NOT the same as ``functools.reduce``.\n158 \n159         For example, the expression\n160 \n161         `A + B + C + D`\n162 \n163         is reduced into:\n164 \n165         `(A + B) + (C + D)`\n166         \"\"\"\n167         if len(args) == 1:\n168             return self._print(args[0])\n169         else:\n170             N = len(args)\n171             Nhalf = N // 2\n172             return \"%s(%s, %s)\" % (\n173                 self._module_format(op),\n174                 self._expand_reduce_binary_op(args[:Nhalf]),\n175                 self._expand_reduce_binary_op(args[Nhalf:]),\n176             )\n177 \n178     def _get_einsum_string(self, subranks, contraction_indices):\n179         letters = self._get_letter_generator_for_einsum()\n180         contraction_string = \"\"\n181         counter = 0\n182         d = {j: min(i) for i in contraction_indices for j in i}\n183         indices = []\n184         for rank_arg in subranks:\n185             lindices = []\n186             for i in range(rank_arg):\n187                 if counter in d:\n188                     lindices.append(d[counter])\n189                 else:\n190                     lindices.append(counter)\n191                 counter += 1\n192             indices.append(lindices)\n193         mapping = {}\n194         letters_free = []\n195         letters_dum = []\n196         for i in indices:\n197             for j in i:\n198                 if j not in mapping:\n199                     l = next(letters)\n200                     mapping[j] = l\n201                 else:\n202                     l = mapping[j]\n203                 contraction_string += l\n204                 if j in d:\n205                     if l not in letters_dum:\n206                         letters_dum.append(l)\n207                 else:\n208                     letters_free.append(l)\n209             contraction_string += \",\"\n210         contraction_string = contraction_string[:-1]\n211         return contraction_string, letters_free, letters_dum\n212 \n213     def _print_NaN(self, expr):\n214         return \"float('nan')\"\n215 \n216     def _print_Infinity(self, expr):\n217         return \"float('inf')\"\n218 \n219     def _print_NegativeInfinity(self, expr):\n220         return \"float('-inf')\"\n221 \n222     def _print_ComplexInfinity(self, expr):\n223         return self._print_NaN(expr)\n224 \n225     def _print_Mod(self, expr):\n226         PREC = precedence(expr)\n227         return ('{0} % {1}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n228 \n229     def _print_Piecewise(self, expr):\n230         result = []\n231         i = 0\n232         for arg in expr.args:\n233             e = arg.expr\n234             c = arg.cond\n235             if i == 0:\n236                 result.append('(')\n237             result.append('(')\n238             result.append(self._print(e))\n239             result.append(')')\n240             result.append(' if ')\n241             result.append(self._print(c))\n242             result.append(' else ')\n243             i += 1\n244         result = result[:-1]\n245         if result[-1] == 'True':\n246             result = result[:-2]\n247             result.append(')')\n248         else:\n249             result.append(' else None)')\n250         return ''.join(result)\n251 \n252     def _print_Relational(self, expr):\n253         \"Relational printer for Equality and Unequality\"\n254         op = {\n255             '==' :'equal',\n256             '!=' :'not_equal',\n257             '<'  :'less',\n258             '<=' :'less_equal',\n259             '>'  :'greater',\n260             '>=' :'greater_equal',\n261         }\n262         if expr.rel_op in op:\n263             lhs = self._print(expr.lhs)\n264             rhs = self._print(expr.rhs)\n265             return '({lhs} {op} {rhs})'.format(op=expr.rel_op, lhs=lhs, rhs=rhs)\n266         return super(AbstractPythonCodePrinter, self)._print_Relational(expr)\n267 \n268     def _print_ITE(self, expr):\n269         from sympy.functions.elementary.piecewise import Piecewise\n270         return self._print(expr.rewrite(Piecewise))\n271 \n272     def _print_Sum(self, expr):\n273         loops = (\n274             'for {i} in range({a}, {b}+1)'.format(\n275                 i=self._print(i),\n276                 a=self._print(a),\n277                 b=self._print(b))\n278             for i, a, b in expr.limits)\n279         return '(builtins.sum({function} {loops}))'.format(\n280             function=self._print(expr.function),\n281             loops=' '.join(loops))\n282 \n283     def _print_ImaginaryUnit(self, expr):\n284         return '1j'\n285 \n286     def _print_MatrixBase(self, expr):\n287         name = expr.__class__.__name__\n288         func = self.known_functions.get(name, name)\n289         return \"%s(%s)\" % (func, self._print(expr.tolist()))\n290 \n291     _print_SparseMatrix = \\\n292         _print_MutableSparseMatrix = \\\n293         _print_ImmutableSparseMatrix = \\\n294         _print_Matrix = \\\n295         _print_DenseMatrix = \\\n296         _print_MutableDenseMatrix = \\\n297         _print_ImmutableMatrix = \\\n298         _print_ImmutableDenseMatrix = \\\n299         lambda self, expr: self._print_MatrixBase(expr)\n300 \n301     def _indent_codestring(self, codestring):\n302         return '\\n'.join([self.tab + line for line in codestring.split('\\n')])\n303 \n304     def _print_FunctionDefinition(self, fd):\n305         body = '\\n'.join(map(lambda arg: self._print(arg), fd.body))\n306         return \"def {name}({parameters}):\\n{body}\".format(\n307             name=self._print(fd.name),\n308             parameters=', '.join([self._print(var.symbol) for var in fd.parameters]),\n309             body=self._indent_codestring(body)\n310         )\n311 \n312     def _print_While(self, whl):\n313         body = '\\n'.join(map(lambda arg: self._print(arg), whl.body))\n314         return \"while {cond}:\\n{body}\".format(\n315             cond=self._print(whl.condition),\n316             body=self._indent_codestring(body)\n317         )\n318 \n319     def _print_Declaration(self, decl):\n320         return '%s = %s' % (\n321             self._print(decl.variable.symbol),\n322             self._print(decl.variable.value)\n323         )\n324 \n325     def _print_Return(self, ret):\n326         arg, = ret.args\n327         return 'return %s' % self._print(arg)\n328 \n329     def _print_Print(self, prnt):\n330         print_args = ', '.join(map(lambda arg: self._print(arg), prnt.print_args))\n331         if prnt.format_string != None: # Must be '!= None', cannot be 'is not None'\n332             print_args = '{0} % ({1})'.format(\n333                 self._print(prnt.format_string), print_args)\n334         if prnt.file != None: # Must be '!= None', cannot be 'is not None'\n335             print_args += ', file=%s' % self._print(prnt.file)\n336         return 'print(%s)' % print_args\n337 \n338     def _print_Stream(self, strm):\n339         if str(strm.name) == 'stdout':\n340             return self._module_format('sys.stdout')\n341         elif str(strm.name) == 'stderr':\n342             return self._module_format('sys.stderr')\n343         else:\n344             return self._print(strm.name)\n345 \n346     def _print_NoneToken(self, arg):\n347         return 'None'\n348 \n349 \n350 class PythonCodePrinter(AbstractPythonCodePrinter):\n351 \n352     def _print_sign(self, e):\n353         return '(0.0 if {e} == 0 else {f}(1, {e}))'.format(\n354             f=self._module_format('math.copysign'), e=self._print(e.args[0]))\n355 \n356     def _print_Not(self, expr):\n357         PREC = precedence(expr)\n358         return self._operators['not'] + self.parenthesize(expr.args[0], PREC)\n359 \n360     def _print_Indexed(self, expr):\n361         base = expr.args[0]\n362         index = expr.args[1:]\n363         return \"{}[{}]\".format(str(base), \", \".join([self._print(ind) for ind in index]))\n364 \n365 \n366 for k in PythonCodePrinter._kf:\n367     setattr(PythonCodePrinter, '_print_%s' % k, _print_known_func)\n368 \n369 for k in _known_constants_math:\n370     setattr(PythonCodePrinter, '_print_%s' % k, _print_known_const)\n371 \n372 \n373 def pycode(expr, **settings):\n374     \"\"\" Converts an expr to a string of Python code\n375 \n376     Parameters\n377     ==========\n378 \n379     expr : Expr\n380         A SymPy expression.\n381     fully_qualified_modules : bool\n382         Whether or not to write out full module names of functions\n383         (``math.sin`` vs. ``sin``). default: ``True``.\n384 \n385     Examples\n386     ========\n387 \n388     >>> from sympy import tan, Symbol\n389     >>> from sympy.printing.pycode import pycode\n390     >>> pycode(tan(Symbol('x')) + 1)\n391     'math.tan(x) + 1'\n392 \n393     \"\"\"\n394     return PythonCodePrinter(settings).doprint(expr)\n395 \n396 \n397 _not_in_mpmath = 'log1p log2'.split()\n398 _in_mpmath = [(k, v) for k, v in _known_functions_math.items() if k not in _not_in_mpmath]\n399 _known_functions_mpmath = dict(_in_mpmath, **{\n400     'sign': 'sign',\n401 })\n402 _known_constants_mpmath = {\n403     'Pi': 'pi'\n404 }\n405 \n406 \n407 class MpmathPrinter(PythonCodePrinter):\n408     \"\"\"\n409     Lambda printer for mpmath which maintains precision for floats\n410     \"\"\"\n411     printmethod = \"_mpmathcode\"\n412 \n413     _kf = dict(chain(\n414         _known_functions.items(),\n415         [(k, 'mpmath.' + v) for k, v in _known_functions_mpmath.items()]\n416     ))\n417 \n418     def _print_Float(self, e):\n419         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that\n420         # the caller of the lambdified function will have set it to sufficient\n421         # precision to match the Floats in the expression.\n422 \n423         # Remove 'mpz' if gmpy is installed.\n424         args = str(tuple(map(int, e._mpf_)))\n425         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)\n426 \n427 \n428     def _print_Rational(self, e):\n429         return '{0}({1})/{0}({2})'.format(\n430             self._module_format('mpmath.mpf'),\n431             e.p,\n432             e.q,\n433             )\n434 \n435     def _print_uppergamma(self, e):\n436         return \"{0}({1}, {2}, {3})\".format(\n437             self._module_format('mpmath.gammainc'),\n438             self._print(e.args[0]),\n439             self._print(e.args[1]),\n440             self._module_format('mpmath.inf'))\n441 \n442     def _print_lowergamma(self, e):\n443         return \"{0}({1}, 0, {2})\".format(\n444             self._module_format('mpmath.gammainc'),\n445             self._print(e.args[0]),\n446             self._print(e.args[1]))\n447 \n448     def _print_log2(self, e):\n449         return '{0}({1})/{0}(2)'.format(\n450             self._module_format('mpmath.log'), self._print(e.args[0]))\n451 \n452     def _print_log1p(self, e):\n453         return '{0}({1}+1)'.format(\n454             self._module_format('mpmath.log'), self._print(e.args[0]))\n455 \n456 for k in MpmathPrinter._kf:\n457     setattr(MpmathPrinter, '_print_%s' % k, _print_known_func)\n458 \n459 for k in _known_constants_mpmath:\n460     setattr(MpmathPrinter, '_print_%s' % k, _print_known_const)\n461 \n462 \n463 _not_in_numpy = 'erf erfc factorial gamma loggamma'.split()\n464 _in_numpy = [(k, v) for k, v in _known_functions_math.items() if k not in _not_in_numpy]\n465 _known_functions_numpy = dict(_in_numpy, **{\n466     'acos': 'arccos',\n467     'acosh': 'arccosh',\n468     'asin': 'arcsin',\n469     'asinh': 'arcsinh',\n470     'atan': 'arctan',\n471     'atan2': 'arctan2',\n472     'atanh': 'arctanh',\n473     'exp2': 'exp2',\n474     'sign': 'sign',\n475 })\n476 \n477 \n478 class NumPyPrinter(PythonCodePrinter):\n479     \"\"\"\n480     Numpy printer which handles vectorized piecewise functions,\n481     logical operators, etc.\n482     \"\"\"\n483     printmethod = \"_numpycode\"\n484 \n485     _kf = dict(chain(\n486         PythonCodePrinter._kf.items(),\n487         [(k, 'numpy.' + v) for k, v in _known_functions_numpy.items()]\n488     ))\n489     _kc = {k: 'numpy.'+v for k, v in _known_constants_math.items()}\n490 \n491 \n492     def _print_seq(self, seq):\n493         \"General sequence printer: converts to tuple\"\n494         # Print tuples here instead of lists because numba supports\n495         #     tuples in nopython mode.\n496         delimiter=', '\n497         return '({},)'.format(delimiter.join(self._print(item) for item in seq))\n498 \n499     def _print_MatMul(self, expr):\n500         \"Matrix multiplication printer\"\n501         if expr.as_coeff_matrices()[0] is not S(1):\n502             expr_list = expr.as_coeff_matrices()[1]+[(expr.as_coeff_matrices()[0])]\n503             return '({0})'.format(').dot('.join(self._print(i) for i in expr_list))\n504         return '({0})'.format(').dot('.join(self._print(i) for i in expr.args))\n505 \n506     def _print_MatPow(self, expr):\n507         \"Matrix power printer\"\n508         return '{0}({1}, {2})'.format(self._module_format('numpy.linalg.matrix_power'),\n509             self._print(expr.args[0]), self._print(expr.args[1]))\n510 \n511     def _print_Inverse(self, expr):\n512         \"Matrix inverse printer\"\n513         return '{0}({1})'.format(self._module_format('numpy.linalg.inv'),\n514             self._print(expr.args[0]))\n515 \n516     def _print_DotProduct(self, expr):\n517         # DotProduct allows any shape order, but numpy.dot does matrix\n518         # multiplication, so we have to make sure it gets 1 x n by n x 1.\n519         arg1, arg2 = expr.args\n520         if arg1.shape[0] != 1:\n521             arg1 = arg1.T\n522         if arg2.shape[1] != 1:\n523             arg2 = arg2.T\n524 \n525         return \"%s(%s, %s)\" % (self._module_format('numpy.dot'),\n526                                self._print(arg1),\n527                                self._print(arg2))\n528 \n529     def _print_Piecewise(self, expr):\n530         \"Piecewise function printer\"\n531         exprs = '[{0}]'.format(','.join(self._print(arg.expr) for arg in expr.args))\n532         conds = '[{0}]'.format(','.join(self._print(arg.cond) for arg in expr.args))\n533         # If [default_value, True] is a (expr, cond) sequence in a Piecewise object\n534         #     it will behave the same as passing the 'default' kwarg to select()\n535         #     *as long as* it is the last element in expr.args.\n536         # If this is not the case, it may be triggered prematurely.\n537         return '{0}({1}, {2}, default=numpy.nan)'.format(self._module_format('numpy.select'), conds, exprs)\n538 \n539     def _print_Relational(self, expr):\n540         \"Relational printer for Equality and Unequality\"\n541         op = {\n542             '==' :'equal',\n543             '!=' :'not_equal',\n544             '<'  :'less',\n545             '<=' :'less_equal',\n546             '>'  :'greater',\n547             '>=' :'greater_equal',\n548         }\n549         if expr.rel_op in op:\n550             lhs = self._print(expr.lhs)\n551             rhs = self._print(expr.rhs)\n552             return '{op}({lhs}, {rhs})'.format(op=self._module_format('numpy.'+op[expr.rel_op]),\n553                                                lhs=lhs, rhs=rhs)\n554         return super(NumPyPrinter, self)._print_Relational(expr)\n555 \n556     def _print_And(self, expr):\n557         \"Logical And printer\"\n558         # We have to override LambdaPrinter because it uses Python 'and' keyword.\n559         # If LambdaPrinter didn't define it, we could use StrPrinter's\n560         # version of the function and add 'logical_and' to NUMPY_TRANSLATIONS.\n561         return '{0}.reduce(({1}))'.format(self._module_format('numpy.logical_and'), ','.join(self._print(i) for i in expr.args))\n562 \n563     def _print_Or(self, expr):\n564         \"Logical Or printer\"\n565         # We have to override LambdaPrinter because it uses Python 'or' keyword.\n566         # If LambdaPrinter didn't define it, we could use StrPrinter's\n567         # version of the function and add 'logical_or' to NUMPY_TRANSLATIONS.\n568         return '{0}.reduce(({1}))'.format(self._module_format('numpy.logical_or'), ','.join(self._print(i) for i in expr.args))\n569 \n570     def _print_Not(self, expr):\n571         \"Logical Not printer\"\n572         # We have to override LambdaPrinter because it uses Python 'not' keyword.\n573         # If LambdaPrinter didn't define it, we would still have to define our\n574         #     own because StrPrinter doesn't define it.\n575         return '{0}({1})'.format(self._module_format('numpy.logical_not'), ','.join(self._print(i) for i in expr.args))\n576 \n577     def _print_Min(self, expr):\n578         return '{0}(({1}))'.format(self._module_format('numpy.amin'), ','.join(self._print(i) for i in expr.args))\n579 \n580     def _print_Max(self, expr):\n581         return '{0}(({1}))'.format(self._module_format('numpy.amax'), ','.join(self._print(i) for i in expr.args))\n582 \n583     def _print_Pow(self, expr):\n584         if expr.exp == 0.5:\n585             return '{0}({1})'.format(self._module_format('numpy.sqrt'), self._print(expr.base))\n586         else:\n587             return super(NumPyPrinter, self)._print_Pow(expr)\n588 \n589     def _print_arg(self, expr):\n590         return \"%s(%s)\" % (self._module_format('numpy.angle'), self._print(expr.args[0]))\n591 \n592     def _print_im(self, expr):\n593         return \"%s(%s)\" % (self._module_format('numpy.imag'), self._print(expr.args[0]))\n594 \n595     def _print_Mod(self, expr):\n596         return \"%s(%s)\" % (self._module_format('numpy.mod'), ', '.join(\n597             map(lambda arg: self._print(arg), expr.args)))\n598 \n599     def _print_re(self, expr):\n600         return \"%s(%s)\" % (self._module_format('numpy.real'), self._print(expr.args[0]))\n601 \n602     def _print_sinc(self, expr):\n603         return \"%s(%s)\" % (self._module_format('numpy.sinc'), self._print(expr.args[0]/S.Pi))\n604 \n605     def _print_MatrixBase(self, expr):\n606         func = self.known_functions.get(expr.__class__.__name__, None)\n607         if func is None:\n608             func = self._module_format('numpy.array')\n609         return \"%s(%s)\" % (func, self._print(expr.tolist()))\n610 \n611     def _print_BlockMatrix(self, expr):\n612         return '{0}({1})'.format(self._module_format('numpy.block'),\n613                                  self._print(expr.args[0].tolist()))\n614 \n615     def _print_CodegenArrayTensorProduct(self, expr):\n616         array_list = [j for i, arg in enumerate(expr.args) for j in\n617                 (self._print(arg), \"[%i, %i]\" % (2*i, 2*i+1))]\n618         return \"%s(%s)\" % (self._module_format('numpy.einsum'), \", \".join(array_list))\n619 \n620     def _print_CodegenArrayContraction(self, expr):\n621         from sympy.codegen.array_utils import CodegenArrayTensorProduct\n622         base = expr.expr\n623         contraction_indices = expr.contraction_indices\n624         if not contraction_indices:\n625             return self._print(base)\n626         if isinstance(base, CodegenArrayTensorProduct):\n627             counter = 0\n628             d = {j: min(i) for i in contraction_indices for j in i}\n629             indices = []\n630             for rank_arg in base.subranks:\n631                 lindices = []\n632                 for i in range(rank_arg):\n633                     if counter in d:\n634                         lindices.append(d[counter])\n635                     else:\n636                         lindices.append(counter)\n637                     counter += 1\n638                 indices.append(lindices)\n639             elems = [\"%s, %s\" % (self._print(arg), ind) for arg, ind in zip(base.args, indices)]\n640             return \"%s(%s)\" % (\n641                 self._module_format('numpy.einsum'),\n642                 \", \".join(elems)\n643             )\n644         raise NotImplementedError()\n645 \n646     def _print_CodegenArrayDiagonal(self, expr):\n647         diagonal_indices = list(expr.diagonal_indices)\n648         if len(diagonal_indices) > 1:\n649             # TODO: this should be handled in sympy.codegen.array_utils,\n650             # possibly by creating the possibility of unfolding the\n651             # CodegenArrayDiagonal object into nested ones. Same reasoning for\n652             # the array contraction.\n653             raise NotImplementedError\n654         if len(diagonal_indices[0]) != 2:\n655             raise NotImplementedError\n656         return \"%s(%s, 0, axis1=%s, axis2=%s)\" % (\n657             self._module_format(\"numpy.diagonal\"),\n658             self._print(expr.expr),\n659             diagonal_indices[0][0],\n660             diagonal_indices[0][1],\n661         )\n662 \n663     def _print_CodegenArrayPermuteDims(self, expr):\n664         return \"%s(%s, %s)\" % (\n665             self._module_format(\"numpy.transpose\"),\n666             self._print(expr.expr),\n667             self._print(expr.permutation.args[0]),\n668         )\n669 \n670     def _print_CodegenArrayElementwiseAdd(self, expr):\n671         return self._expand_fold_binary_op('numpy.add', expr.args)\n672 \n673 \n674 for k in NumPyPrinter._kf:\n675     setattr(NumPyPrinter, '_print_%s' % k, _print_known_func)\n676 \n677 for k in NumPyPrinter._kc:\n678     setattr(NumPyPrinter, '_print_%s' % k, _print_known_const)\n679 \n680 \n681 _known_functions_scipy_special = {\n682     'erf': 'erf',\n683     'erfc': 'erfc',\n684     'besselj': 'jv',\n685     'bessely': 'yv',\n686     'besseli': 'iv',\n687     'besselk': 'kv',\n688     'factorial': 'factorial',\n689     'gamma': 'gamma',\n690     'loggamma': 'gammaln',\n691     'digamma': 'psi',\n692     'RisingFactorial': 'poch',\n693     'jacobi': 'eval_jacobi',\n694     'gegenbauer': 'eval_gegenbauer',\n695     'chebyshevt': 'eval_chebyt',\n696     'chebyshevu': 'eval_chebyu',\n697     'legendre': 'eval_legendre',\n698     'hermite': 'eval_hermite',\n699     'laguerre': 'eval_laguerre',\n700     'assoc_laguerre': 'eval_genlaguerre',\n701 }\n702 \n703 _known_constants_scipy_constants = {\n704     'GoldenRatio': 'golden_ratio',\n705     'Pi': 'pi',\n706     'E': 'e'\n707 }\n708 \n709 class SciPyPrinter(NumPyPrinter):\n710 \n711     _kf = dict(chain(\n712         NumPyPrinter._kf.items(),\n713         [(k, 'scipy.special.' + v) for k, v in _known_functions_scipy_special.items()]\n714     ))\n715     _kc = {k: 'scipy.constants.' + v for k, v in _known_constants_scipy_constants.items()}\n716 \n717     def _print_SparseMatrix(self, expr):\n718         i, j, data = [], [], []\n719         for (r, c), v in expr._smat.items():\n720             i.append(r)\n721             j.append(c)\n722             data.append(v)\n723 \n724         return \"{name}({data}, ({i}, {j}), shape={shape})\".format(\n725             name=self._module_format('scipy.sparse.coo_matrix'),\n726             data=data, i=i, j=j, shape=expr.shape\n727         )\n728 \n729     _print_ImmutableSparseMatrix = _print_SparseMatrix\n730 \n731     # SciPy's lpmv has a different order of arguments from assoc_legendre\n732     def _print_assoc_legendre(self, expr):\n733         return \"{0}({2}, {1}, {3})\".format(\n734             self._module_format('scipy.special.lpmv'),\n735             self._print(expr.args[0]),\n736             self._print(expr.args[1]),\n737             self._print(expr.args[2]))\n738 \n739 for k in SciPyPrinter._kf:\n740     setattr(SciPyPrinter, '_print_%s' % k, _print_known_func)\n741 \n742 for k in SciPyPrinter._kc:\n743     setattr(SciPyPrinter, '_print_%s' % k, _print_known_const)\n744 \n745 \n746 class SymPyPrinter(PythonCodePrinter):\n747 \n748     _kf = {k: 'sympy.' + v for k, v in chain(\n749         _known_functions.items(),\n750         _known_functions_math.items()\n751     )}\n752 \n753     def _print_Function(self, expr):\n754         mod = expr.func.__module__ or ''\n755         return '%s(%s)' % (self._module_format(mod + ('.' if mod else '') + expr.func.__name__),\n756                            ', '.join(map(lambda arg: self._print(arg), expr.args)))\n",
        "intended_behavior": "The printing functionality for `Identity` matrices within the `NumPyPrinter` class (or whichever specific printer `lambdify` utilizes for converting SymPy expressions to NumPy functions) should explicitly convert `Identity(n)` matrices into NumPy syntax for creating identity matrices (`numpy.eye(n)`). The printer should have a clear and unambiguous rule for printing `Identity` matrices that differentiates them from the notation for the imaginary unit `I`, ensuring the generated code reflects the intention of adding an identity matrix rather than complex numbers to the elements of the array."
    }
]