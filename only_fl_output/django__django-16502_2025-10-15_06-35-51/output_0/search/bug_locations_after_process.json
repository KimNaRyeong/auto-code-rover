[
    {
        "rel_file_path": "django/core/servers/basehttp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/core/servers/basehttp.py",
        "start": 1,
        "end": 246,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).\n3 \n4 Based on wsgiref.simple_server which is part of the standard library since 2.5.\n5 \n6 This is a simple server for use in testing or debugging Django apps. It hasn't\n7 been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!\n8 \"\"\"\n9 \n10 import logging\n11 import socket\n12 import socketserver\n13 import sys\n14 from wsgiref import simple_server\n15 \n16 from django.core.exceptions import ImproperlyConfigured\n17 from django.core.handlers.wsgi import LimitedStream\n18 from django.core.wsgi import get_wsgi_application\n19 from django.db import connections\n20 from django.utils.module_loading import import_string\n21 \n22 __all__ = (\"WSGIServer\", \"WSGIRequestHandler\")\n23 \n24 logger = logging.getLogger(\"django.server\")\n25 \n26 \n27 def get_internal_wsgi_application():\n28     \"\"\"\n29     Load and return the WSGI application as configured by the user in\n30     ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,\n31     this will be the ``application`` object in ``projectname/wsgi.py``.\n32 \n33     This function, and the ``WSGI_APPLICATION`` setting itself, are only useful\n34     for Django's internal server (runserver); external WSGI servers should just\n35     be configured to point to the correct application object directly.\n36 \n37     If settings.WSGI_APPLICATION is not set (is ``None``), return\n38     whatever ``django.core.wsgi.get_wsgi_application`` returns.\n39     \"\"\"\n40     from django.conf import settings\n41 \n42     app_path = getattr(settings, \"WSGI_APPLICATION\")\n43     if app_path is None:\n44         return get_wsgi_application()\n45 \n46     try:\n47         return import_string(app_path)\n48     except ImportError as err:\n49         raise ImproperlyConfigured(\n50             \"WSGI application '%s' could not be loaded; \"\n51             \"Error importing module.\" % app_path\n52         ) from err\n53 \n54 \n55 def is_broken_pipe_error():\n56     exc_type, _, _ = sys.exc_info()\n57     return issubclass(\n58         exc_type,\n59         (\n60             BrokenPipeError,\n61             ConnectionAbortedError,\n62             ConnectionResetError,\n63         ),\n64     )\n65 \n66 \n67 class WSGIServer(simple_server.WSGIServer):\n68     \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n69 \n70     request_queue_size = 10\n71 \n72     def __init__(self, *args, ipv6=False, allow_reuse_address=True, **kwargs):\n73         if ipv6:\n74             self.address_family = socket.AF_INET6\n75         self.allow_reuse_address = allow_reuse_address\n76         super().__init__(*args, **kwargs)\n77 \n78     def handle_error(self, request, client_address):\n79         if is_broken_pipe_error():\n80             logger.info(\"- Broken pipe from %s\", client_address)\n81         else:\n82             super().handle_error(request, client_address)\n83 \n84 \n85 class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n86     \"\"\"A threaded version of the WSGIServer\"\"\"\n87 \n88     daemon_threads = True\n89 \n90     def __init__(self, *args, connections_override=None, **kwargs):\n91         super().__init__(*args, **kwargs)\n92         self.connections_override = connections_override\n93 \n94     # socketserver.ThreadingMixIn.process_request() passes this method as\n95     # the target to a new Thread object.\n96     def process_request_thread(self, request, client_address):\n97         if self.connections_override:\n98             # Override this thread's database connections with the ones\n99             # provided by the parent thread.\n100             for alias, conn in self.connections_override.items():\n101                 connections[alias] = conn\n102         super().process_request_thread(request, client_address)\n103 \n104     def _close_connections(self):\n105         # Used for mocking in tests.\n106         connections.close_all()\n107 \n108     def close_request(self, request):\n109         self._close_connections()\n110         super().close_request(request)\n111 \n112 \n113 class ServerHandler(simple_server.ServerHandler):\n114     http_version = \"1.1\"\n115 \n116     def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n117         \"\"\"\n118         Use a LimitedStream so that unread request data will be ignored at\n119         the end of the request. WSGIRequest uses a LimitedStream but it\n120         shouldn't discard the data since the upstream servers usually do this.\n121         This fix applies only for testserver/runserver.\n122         \"\"\"\n123         try:\n124             content_length = int(environ.get(\"CONTENT_LENGTH\"))\n125         except (ValueError, TypeError):\n126             content_length = 0\n127         super().__init__(\n128             LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs\n129         )\n130 \n131     def cleanup_headers(self):\n132         super().cleanup_headers()\n133         # HTTP/1.1 requires support for persistent connections. Send 'close' if\n134         # the content length is unknown to prevent clients from reusing the\n135         # connection.\n136         if \"Content-Length\" not in self.headers:\n137             self.headers[\"Connection\"] = \"close\"\n138         # Persistent connections require threading server.\n139         elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n140             self.headers[\"Connection\"] = \"close\"\n141         # Mark the connection for closing if it's set as such above or if the\n142         # application sent the header.\n143         if self.headers.get(\"Connection\") == \"close\":\n144             self.request_handler.close_connection = True\n145 \n146     def close(self):\n147         self.get_stdin().read()\n148         super().close()\n149 \n150 \n151 class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n152     protocol_version = \"HTTP/1.1\"\n153 \n154     def address_string(self):\n155         # Short-circuit parent method to not call socket.getfqdn\n156         return self.client_address[0]\n157 \n158     def log_message(self, format, *args):\n159         extra = {\n160             \"request\": self.request,\n161             \"server_time\": self.log_date_time_string(),\n162         }\n163         if args[1][0] == \"4\":\n164             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n165             if args[0].startswith(\"\\x16\\x03\"):\n166                 extra[\"status_code\"] = 500\n167                 logger.error(\n168                     \"You're accessing the development server over HTTPS, but \"\n169                     \"it only supports HTTP.\",\n170                     extra=extra,\n171                 )\n172                 return\n173 \n174         if args[1].isdigit() and len(args[1]) == 3:\n175             status_code = int(args[1])\n176             extra[\"status_code\"] = status_code\n177 \n178             if status_code >= 500:\n179                 level = logger.error\n180             elif status_code >= 400:\n181                 level = logger.warning\n182             else:\n183                 level = logger.info\n184         else:\n185             level = logger.info\n186 \n187         level(format, *args, extra=extra)\n188 \n189     def get_environ(self):\n190         # Strip all headers with underscores in the name before constructing\n191         # the WSGI environ. This prevents header-spoofing based on ambiguity\n192         # between underscores and dashes both normalized to underscores in WSGI\n193         # env vars. Nginx and Apache 2.4+ both do this as well.\n194         for k in self.headers:\n195             if \"_\" in k:\n196                 del self.headers[k]\n197 \n198         return super().get_environ()\n199 \n200     def handle(self):\n201         self.close_connection = True\n202         self.handle_one_request()\n203         while not self.close_connection:\n204             self.handle_one_request()\n205         try:\n206             self.connection.shutdown(socket.SHUT_WR)\n207         except (AttributeError, OSError):\n208             pass\n209 \n210     def handle_one_request(self):\n211         \"\"\"Copy of WSGIRequestHandler.handle() but with different ServerHandler\"\"\"\n212         self.raw_requestline = self.rfile.readline(65537)\n213         if len(self.raw_requestline) > 65536:\n214             self.requestline = \"\"\n215             self.request_version = \"\"\n216             self.command = \"\"\n217             self.send_error(414)\n218             return\n219 \n220         if not self.parse_request():  # An error code has been sent, just exit\n221             return\n222 \n223         handler = ServerHandler(\n224             self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n225         )\n226         handler.request_handler = self  # backpointer for logging & connection closing\n227         handler.run(self.server.get_app())\n228 \n229 \n230 def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):\n231     server_address = (addr, port)\n232     if threading:\n233         httpd_cls = type(\"WSGIServer\", (socketserver.ThreadingMixIn, server_cls), {})\n234     else:\n235         httpd_cls = server_cls\n236     httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)\n237     if threading:\n238         # ThreadingMixIn.daemon_threads indicates how threads will behave on an\n239         # abrupt shutdown; like quitting the server by the user or restarting\n240         # by the auto-reloader. True means the server will not wait for thread\n241         # termination before it quits. This will make auto-reloader faster\n242         # and will prevent the need to kill the server manually if a thread\n243         # isn't terminating correctly.\n244         httpd.daemon_threads = True\n245     httpd.set_app(wsgi_handler)\n246     httpd.serve_forever()\n",
        "intended_behavior": "Reviewing the code for how HTTP HEAD requests are handled could provide insights into the issue with Django development server's response to such requests."
    }
]