2025-10-15 09:33:21.069 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 09:33:23.264 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=384, output_tokens=12, cost=0.004200
2025-10-15 09:33:23.265 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 09:33:23.270 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:33:31.387 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=693, output_tokens=260, cost=0.014730
2025-10-15 09:33:31.394 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:33:34.391 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=614, output_tokens=51, cost=0.007670
2025-10-15 09:33:34.393 | DEBUG    | Extracted a valid json.
2025-10-15 09:33:34.393 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"pytest_configure\")",
        "search_code(\"PytestDeprecationWarning: The hookimpl\")",
        "search_code(\"hookimpl\")"
    ],
    "bug_locations": []
}
2025-10-15 09:33:34.535 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 09:33:34.535 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 09:33:59.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2185, output_tokens=863, cost=0.047740
2025-10-15 09:33:59.129 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:34:10.990 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3264, output_tokens=430, cost=0.045540
2025-10-15 09:34:10.997 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:34:21.632 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=784, output_tokens=406, cost=0.020020
2025-10-15 09:34:21.633 | DEBUG    | Extracted a valid json.
2025-10-15 09:34:21.633 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "src/_pytest/hookspec.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely defines the `pytest_configure` hookspec or related mechanisms. To resolve the issue, the code that triggers the `PytestDeprecationWarning` for old-style `hookimpl` usage within this file (or within the system that processes these hookspecs) should be enhanced. It should not only check for and warn about deprecated usage but also include information about the source of the deprecation (i.e., the plugin or file defining the deprecated hook). This enhancement might involve capturing the `__file__` attribute of the function or module when the `hookimpl` is registered and including that information in the warning message. Preserving Existing Functionality: The update should maintain all existing functionality surrounding hook registration and warning issuance. The primary change is to augment the warning message with location information, without affecting the registration or execution of hooks themselves."
        },
        {
            "file": "src/_pytest/config/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Since this file deals with the configuration of pytest, including the loading and registration of plugins, it's a plausible location where enhancements could be made to improve the issue at hand. Specifically, during the process where plugins are scanned for hook implementations, the system could be enhanced to record more detailed location information. When a deprecated `hookimpl` is found, the system should emit a `PytestDeprecationWarning` that includes this detailed location information, making it easier for users to identify and correct the source of the deprecation. Preserving Existing Functionality: The mechanism for loading, registering, and managing plugins and their hook implementations should remain untouched in terms of functionality. The enhancement should only extend the information provided in warnings related to deprecated hook usage."
        }
    ]
}
2025-10-15 09:34:21.646 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/hookspec.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Hook specifications for pytest plugins which are invoked by pytest itself
2 and by builtin plugins."""
3 from pathlib import Path
4 from typing import Any
5 from typing import Dict
6 from typing import List
7 from typing import Mapping
8 from typing import Optional
9 from typing import Sequence
10 from typing import Tuple
11 from typing import TYPE_CHECKING
12 from typing import Union
13 
14 from pluggy import HookspecMarker
15 
16 from _pytest.deprecated import WARNING_CMDLINE_PREPARSE_HOOK
17 
18 if TYPE_CHECKING:
19     import pdb
20     import warnings
21     from typing_extensions import Literal
22 
23     from _pytest._code.code import ExceptionRepr
24     from _pytest.code import ExceptionInfo
25     from _pytest.config import Config
26     from _pytest.config import ExitCode
27     from _pytest.config import PytestPluginManager
28     from _pytest.config import _PluggyPlugin
29     from _pytest.config.argparsing import Parser
30     from _pytest.fixtures import FixtureDef
31     from _pytest.fixtures import SubRequest
32     from _pytest.main import Session
33     from _pytest.nodes import Collector
34     from _pytest.nodes import Item
35     from _pytest.outcomes import Exit
36     from _pytest.python import Class
37     from _pytest.python import Function
38     from _pytest.python import Metafunc
39     from _pytest.python import Module
40     from _pytest.reports import CollectReport
41     from _pytest.reports import TestReport
42     from _pytest.runner import CallInfo
43     from _pytest.terminal import TerminalReporter
44     from _pytest.compat import LEGACY_PATH
45 
46 
47 hookspec = HookspecMarker("pytest")
48 
49 # -------------------------------------------------------------------------
50 # Initialization hooks called for every plugin
51 # -------------------------------------------------------------------------
52 
53 
54 @hookspec(historic=True)
55 def pytest_addhooks(pluginmanager: "PytestPluginManager") -> None:
56     """Called at plugin registration time to allow adding new hooks via a call to
57     ``pluginmanager.add_hookspecs(module_or_class, prefix)``.
58 
59     :param pytest.PytestPluginManager pluginmanager: The pytest plugin manager.
60 
61     .. note::
62         This hook is incompatible with ``hookwrapper=True``.
63     """
64 
65 
66 @hookspec(historic=True)
67 def pytest_plugin_registered(
68     plugin: "_PluggyPlugin", manager: "PytestPluginManager"
69 ) -> None:
70     """A new pytest plugin got registered.
71 
72     :param plugin: The plugin module or instance.
73     :param pytest.PytestPluginManager manager: pytest plugin manager.
74 
75     .. note::
76         This hook is incompatible with ``hookwrapper=True``.
77     """
78 
79 
80 @hookspec(historic=True)
81 def pytest_addoption(parser: "Parser", pluginmanager: "PytestPluginManager") -> None:
82     """Register argparse-style options and ini-style config values,
83     called once at the beginning of a test run.
84 
85     .. note::
86 
87         This function should be implemented only in plugins or ``conftest.py``
88         files situated at the tests root directory due to how pytest
89         :ref:`discovers plugins during startup <pluginorder>`.
90 
91     :param pytest.Parser parser:
92         To add command line options, call
93         :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.
94         To add ini-file values call :py:func:`parser.addini(...)
95         <pytest.Parser.addini>`.
96 
97     :param pytest.PytestPluginManager pluginmanager:
98         The pytest plugin manager, which can be used to install :py:func:`hookspec`'s
99         or :py:func:`hookimpl`'s and allow one plugin to call another plugin's hooks
100         to change how command line options are added.
101 
102     Options can later be accessed through the
103     :py:class:`config <pytest.Config>` object, respectively:
104 
105     - :py:func:`config.getoption(name) <pytest.Config.getoption>` to
106       retrieve the value of a command line option.
107 
108     - :py:func:`config.getini(name) <pytest.Config.getini>` to retrieve
109       a value read from an ini-style file.
110 
111     The config object is passed around on many internal objects via the ``.config``
112     attribute or can be retrieved as the ``pytestconfig`` fixture.
113 
114     .. note::
115         This hook is incompatible with ``hookwrapper=True``.
116     """
117 
118 
119 @hookspec(historic=True)
120 def pytest_configure(config: "Config") -> None:
121     """Allow plugins and conftest files to perform initial configuration.
122 
123     This hook is called for every plugin and initial conftest file
124     after command line options have been parsed.
125 
126     After that, the hook is called for other conftest files as they are
127     imported.
128 
129     .. note::
130         This hook is incompatible with ``hookwrapper=True``.
131 
132     :param pytest.Config config: The pytest config object.
133     """
134 
135 
136 # -------------------------------------------------------------------------
137 # Bootstrapping hooks called for plugins registered early enough:
138 # internal and 3rd party plugins.
139 # -------------------------------------------------------------------------
140 
141 
142 @hookspec(firstresult=True)
143 def pytest_cmdline_parse(
144     pluginmanager: "PytestPluginManager", args: List[str]
145 ) -> Optional["Config"]:
146     """Return an initialized :class:`~pytest.Config`, parsing the specified args.
147 
148     Stops at first non-None result, see :ref:`firstresult`.
149 
150     .. note::
151         This hook will only be called for plugin classes passed to the
152         ``plugins`` arg when using `pytest.main`_ to perform an in-process
153         test run.
154 
155     :param pluginmanager: The pytest plugin manager.
156     :param args: List of arguments passed on the command line.
157     :returns: A pytest config object.
158     """
159 
160 
161 @hookspec(warn_on_impl=WARNING_CMDLINE_PREPARSE_HOOK)
162 def pytest_cmdline_preparse(config: "Config", args: List[str]) -> None:
163     """(**Deprecated**) modify command line arguments before option parsing.
164 
165     This hook is considered deprecated and will be removed in a future pytest version. Consider
166     using :hook:`pytest_load_initial_conftests` instead.
167 
168     .. note::
169         This hook will not be called for ``conftest.py`` files, only for setuptools plugins.
170 
171     :param config: The pytest config object.
172     :param args: Arguments passed on the command line.
173     """
174 
175 
176 @hookspec(firstresult=True)
177 def pytest_cmdline_main(config: "Config") -> Optional[Union["ExitCode", int]]:
178     """Called for performing the main command line action. The default
179     implementation will invoke the configure hooks and runtest_mainloop.
180 
181     Stops at first non-None result, see :ref:`firstresult`.
182 
183     :param config: The pytest config object.
184     :returns: The exit code.
185     """
186 
187 
188 def pytest_load_initial_conftests(
189     early_config: "Config", parser: "Parser", args: List[str]
190 ) -> None:
191     """Called to implement the loading of initial conftest files ahead
192     of command line option parsing.
193 
194     .. note::
195         This hook will not be called for ``conftest.py`` files, only for setuptools plugins.
196 
197     :param early_config: The pytest config object.
198     :param args: Arguments passed on the command line.
199     :param parser: To add command line options.
200     """
201 
202 
203 # -------------------------------------------------------------------------
204 # collection hooks
205 # -------------------------------------------------------------------------
206 
207 
208 @hookspec(firstresult=True)
209 def pytest_collection(session: "Session") -> Optional[object]:
210     """Perform the collection phase for the given session.
211 
212     Stops at first non-None result, see :ref:`firstresult`.
213     The return value is not used, but only stops further processing.
214 
215     The default collection phase is this (see individual hooks for full details):
216 
217     1. Starting from ``session`` as the initial collector:
218 
219       1. ``pytest_collectstart(collector)``
220       2. ``report = pytest_make_collect_report(collector)``
221       3. ``pytest_exception_interact(collector, call, report)`` if an interactive exception occurred
222       4. For each collected node:
223 
224         1. If an item, ``pytest_itemcollected(item)``
225         2. If a collector, recurse into it.
226 
227       5. ``pytest_collectreport(report)``
228 
229     2. ``pytest_collection_modifyitems(session, config, items)``
230 
231       1. ``pytest_deselected(items)`` for any deselected items (may be called multiple times)
232 
233     3. ``pytest_collection_finish(session)``
234     4. Set ``session.items`` to the list of collected items
235     5. Set ``session.testscollected`` to the number of collected items
236 
237     You can implement this hook to only perform some action before collection,
238     for example the terminal plugin uses it to start displaying the collection
239     counter (and returns `None`).
240 
241     :param session: The pytest session object.
242     """
243 
244 
245 def pytest_collection_modifyitems(
246     session: "Session", config: "Config", items: List["Item"]
247 ) -> None:
248     """Called after collection has been performed. May filter or re-order
249     the items in-place.
250 
251     :param session: The pytest session object.
252     :param config: The pytest config object.
253     :param items: List of item objects.
254     """
255 
256 
257 def pytest_collection_finish(session: "Session") -> None:
258     """Called after collection has been performed and modified.
259 
260     :param session: The pytest session object.
261     """
262 
263 
264 @hookspec(firstresult=True)
265 def pytest_ignore_collect(
266     collection_path: Path, path: "LEGACY_PATH", config: "Config"
267 ) -> Optional[bool]:
268     """Return True to prevent considering this path for collection.
269 
270     This hook is consulted for all files and directories prior to calling
271     more specific hooks.
272 
273     Stops at first non-None result, see :ref:`firstresult`.
274 
275     :param collection_path: The path to analyze.
276     :param path: The path to analyze (deprecated).
277     :param config: The pytest config object.
278 
279     .. versionchanged:: 7.0.0
280         The ``collection_path`` parameter was added as a :class:`pathlib.Path`
281         equivalent of the ``path`` parameter. The ``path`` parameter
282         has been deprecated.
283     """
284 
285 
286 def pytest_collect_file(
287     file_path: Path, path: "LEGACY_PATH", parent: "Collector"
288 ) -> "Optional[Collector]":
289     """Create a :class:`~pytest.Collector` for the given path, or None if not relevant.
290 
291     The new node needs to have the specified ``parent`` as a parent.
292 
293     :param file_path: The path to analyze.
294     :param path: The path to collect (deprecated).
295 
296     .. versionchanged:: 7.0.0
297         The ``file_path`` parameter was added as a :class:`pathlib.Path`
298         equivalent of the ``path`` parameter. The ``path`` parameter
299         has been deprecated.
300     """
301 
302 
303 # logging hooks for collection
304 
305 
306 def pytest_collectstart(collector: "Collector") -> None:
307     """Collector starts collecting.
308 
309     :param collector:
310         The collector.
311     """
312 
313 
314 def pytest_itemcollected(item: "Item") -> None:
315     """We just collected a test item.
316 
317     :param item:
318         The item.
319     """
320 
321 
322 def pytest_collectreport(report: "CollectReport") -> None:
323     """Collector finished collecting.
324 
325     :param report:
326         The collect report.
327     """
328 
329 
330 def pytest_deselected(items: Sequence["Item"]) -> None:
331     """Called for deselected test items, e.g. by keyword.
332 
333     May be called multiple times.
334 
335     :param items:
336         The items.
337     """
338 
339 
340 @hookspec(firstresult=True)
341 def pytest_make_collect_report(collector: "Collector") -> "Optional[CollectReport]":
342     """Perform :func:`collector.collect() <pytest.Collector.collect>` and return
343     a :class:`~pytest.CollectReport`.
344 
345     Stops at first non-None result, see :ref:`firstresult`.
346 
347     :param collector:
348         The collector.
349     """
350 
351 
352 # -------------------------------------------------------------------------
353 # Python test function related hooks
354 # -------------------------------------------------------------------------
355 
356 
357 @hookspec(firstresult=True)
358 def pytest_pycollect_makemodule(
359     module_path: Path, path: "LEGACY_PATH", parent
360 ) -> Optional["Module"]:
361     """Return a :class:`pytest.Module` collector or None for the given path.
362 
363     This hook will be called for each matching test module path.
364     The :hook:`pytest_collect_file` hook needs to be used if you want to
365     create test modules for files that do not match as a test module.
366 
367     Stops at first non-None result, see :ref:`firstresult`.
368 
369     :param module_path: The path of the module to collect.
370     :param path: The path of the module to collect (deprecated).
371 
372     .. versionchanged:: 7.0.0
373         The ``module_path`` parameter was added as a :class:`pathlib.Path`
374         equivalent of the ``path`` parameter.
375 
376         The ``path`` parameter has been deprecated in favor of ``fspath``.
377     """
378 
379 
380 @hookspec(firstresult=True)
381 def pytest_pycollect_makeitem(
382     collector: Union["Module", "Class"], name: str, obj: object
383 ) -> Union[None, "Item", "Collector", List[Union["Item", "Collector"]]]:
384     """Return a custom item/collector for a Python object in a module, or None.
385 
386     Stops at first non-None result, see :ref:`firstresult`.
387 
388     :param collector:
389         The module/class collector.
390     :param name:
391         The name of the object in the module/class.
392     :param obj:
393         The object.
394     :returns:
395         The created items/collectors.
396     """
397 
398 
399 @hookspec(firstresult=True)
400 def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
401     """Call underlying test function.
402 
403     Stops at first non-None result, see :ref:`firstresult`.
404 
405     :param pyfuncitem:
406         The function item.
407     """
408 
409 
410 def pytest_generate_tests(metafunc: "Metafunc") -> None:
411     """Generate (multiple) parametrized calls to a test function.
412 
413     :param metafunc:
414         The :class:`~pytest.Metafunc` helper for the test function.
415     """
416 
417 
418 @hookspec(firstresult=True)
419 def pytest_make_parametrize_id(
420     config: "Config", val: object, argname: str
421 ) -> Optional[str]:
422     """Return a user-friendly string representation of the given ``val``
423     that will be used by @pytest.mark.parametrize calls, or None if the hook
424     doesn't know about ``val``.
425 
426     The parameter name is available as ``argname``, if required.
427 
428     Stops at first non-None result, see :ref:`firstresult`.
429 
430     :param config: The pytest config object.
431     :param val: The parametrized value.
432     :param str argname: The automatic parameter name produced by pytest.
433     """
434 
435 
436 # -------------------------------------------------------------------------
437 # runtest related hooks
438 # -------------------------------------------------------------------------
439 
440 
441 @hookspec(firstresult=True)
442 def pytest_runtestloop(session: "Session") -> Optional[object]:
443     """Perform the main runtest loop (after collection finished).
444 
445     The default hook implementation performs the runtest protocol for all items
446     collected in the session (``session.items``), unless the collection failed
447     or the ``collectonly`` pytest option is set.
448 
449     If at any point :py:func:`pytest.exit` is called, the loop is
450     terminated immediately.
451 
452     If at any point ``session.shouldfail`` or ``session.shouldstop`` are set, the
453     loop is terminated after the runtest protocol for the current item is finished.
454 
455     :param session: The pytest session object.
456 
457     Stops at first non-None result, see :ref:`firstresult`.
458     The return value is not used, but only stops further processing.
459     """
460 
461 
462 @hookspec(firstresult=True)
463 def pytest_runtest_protocol(
464     item: "Item", nextitem: "Optional[Item]"
465 ) -> Optional[object]:
466     """Perform the runtest protocol for a single test item.
467 
468     The default runtest protocol is this (see individual hooks for full details):
469 
470     - ``pytest_runtest_logstart(nodeid, location)``
471 
472     - Setup phase:
473         - ``call = pytest_runtest_setup(item)`` (wrapped in ``CallInfo(when="setup")``)
474         - ``report = pytest_runtest_makereport(item, call)``
475         - ``pytest_runtest_logreport(report)``
476         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred
477 
478     - Call phase, if the the setup passed and the ``setuponly`` pytest option is not set:
479         - ``call = pytest_runtest_call(item)`` (wrapped in ``CallInfo(when="call")``)
480         - ``report = pytest_runtest_makereport(item, call)``
481         - ``pytest_runtest_logreport(report)``
482         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred
483 
484     - Teardown phase:
485         - ``call = pytest_runtest_teardown(item, nextitem)`` (wrapped in ``CallInfo(when="teardown")``)
486         - ``report = pytest_runtest_makereport(item, call)``
487         - ``pytest_runtest_logreport(report)``
488         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred
489 
490     - ``pytest_runtest_logfinish(nodeid, location)``
491 
492     :param item: Test item for which the runtest protocol is performed.
493     :param nextitem: The scheduled-to-be-next test item (or None if this is the end my friend).
494 
495     Stops at first non-None result, see :ref:`firstresult`.
496     The return value is not used, but only stops further processing.
497     """
498 
499 
500 def pytest_runtest_logstart(
501     nodeid: str, location: Tuple[str, Optional[int], str]
502 ) -> None:
503     """Called at the start of running the runtest protocol for a single item.
504 
505     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
506 
507     :param nodeid: Full node ID of the item.
508     :param location: A tuple of ``(filename, lineno, testname)``.
509     """
510 
511 
512 def pytest_runtest_logfinish(
513     nodeid: str, location: Tuple[str, Optional[int], str]
514 ) -> None:
515     """Called at the end of running the runtest protocol for a single item.
516 
517     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
518 
519     :param nodeid: Full node ID of the item.
520     :param location: A tuple of ``(filename, lineno, testname)``.
521     """
522 
523 
524 def pytest_runtest_setup(item: "Item") -> None:
525     """Called to perform the setup phase for a test item.
526 
527     The default implementation runs ``setup()`` on ``item`` and all of its
528     parents (which haven't been setup yet). This includes obtaining the
529     values of fixtures required by the item (which haven't been obtained
530     yet).
531 
532     :param item:
533         The item.
534     """
535 
536 
537 def pytest_runtest_call(item: "Item") -> None:
538     """Called to run the test for test item (the call phase).
539 
540     The default implementation calls ``item.runtest()``.
541 
542     :param item:
543         The item.
544     """
545 
546 
547 def pytest_runtest_teardown(item: "Item", nextitem: Optional["Item"]) -> None:
548     """Called to perform the teardown phase for a test item.
549 
550     The default implementation runs the finalizers and calls ``teardown()``
551     on ``item`` and all of its parents (which need to be torn down). This
552     includes running the teardown phase of fixtures required by the item (if
553     they go out of scope).
554 
555     :param item:
556         The item.
557     :param nextitem:
558         The scheduled-to-be-next test item (None if no further test item is
559         scheduled). This argument is used to perform exact teardowns, i.e.
560         calling just enough finalizers so that nextitem only needs to call
561         setup functions.
562     """
563 
564 
565 @hookspec(firstresult=True)
566 def pytest_runtest_makereport(
567     item: "Item", call: "CallInfo[None]"
568 ) -> Optional["TestReport"]:
569     """Called to create a :class:`~pytest.TestReport` for each of
570     the setup, call and teardown runtest phases of a test item.
571 
572     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
573 
574     :param item: The item.
575     :param call: The :class:`~pytest.CallInfo` for the phase.
576 
577     Stops at first non-None result, see :ref:`firstresult`.
578     """
579 
580 
581 def pytest_runtest_logreport(report: "TestReport") -> None:
582     """Process the :class:`~pytest.TestReport` produced for each
583     of the setup, call and teardown runtest phases of an item.
584 
585     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
586     """
587 
588 
589 @hookspec(firstresult=True)
590 def pytest_report_to_serializable(
591     config: "Config",
592     report: Union["CollectReport", "TestReport"],
593 ) -> Optional[Dict[str, Any]]:
594     """Serialize the given report object into a data structure suitable for
595     sending over the wire, e.g. converted to JSON.
596 
597     :param config: The pytest config object.
598     :param report: The report.
599     """
600 
601 
602 @hookspec(firstresult=True)
603 def pytest_report_from_serializable(
604     config: "Config",
605     data: Dict[str, Any],
606 ) -> Optional[Union["CollectReport", "TestReport"]]:
607     """Restore a report object previously serialized with
608     :hook:`pytest_report_to_serializable`.
609 
610     :param config: The pytest config object.
611     """
612 
613 
614 # -------------------------------------------------------------------------
615 # Fixture related hooks
616 # -------------------------------------------------------------------------
617 
618 
619 @hookspec(firstresult=True)
620 def pytest_fixture_setup(
621     fixturedef: "FixtureDef[Any]", request: "SubRequest"
622 ) -> Optional[object]:
623     """Perform fixture setup execution.
624 
625     :param fixturdef:
626         The fixture definition object.
627     :param request:
628         The fixture request object.
629     :returns:
630         The return value of the call to the fixture function.
631 
632     Stops at first non-None result, see :ref:`firstresult`.
633 
634     .. note::
635         If the fixture function returns None, other implementations of
636         this hook function will continue to be called, according to the
637         behavior of the :ref:`firstresult` option.
638     """
639 
640 
641 def pytest_fixture_post_finalizer(
642     fixturedef: "FixtureDef[Any]", request: "SubRequest"
643 ) -> None:
644     """Called after fixture teardown, but before the cache is cleared, so
645     the fixture result ``fixturedef.cached_result`` is still available (not
646     ``None``).
647 
648     :param fixturdef:
649         The fixture definition object.
650     :param request:
651         The fixture request object.
652     """
653 
654 
655 # -------------------------------------------------------------------------
656 # test session related hooks
657 # -------------------------------------------------------------------------
658 
659 
660 def pytest_sessionstart(session: "Session") -> None:
661     """Called after the ``Session`` object has been created and before performing collection
662     and entering the run test loop.
663 
664     :param session: The pytest session object.
665     """
666 
667 
668 def pytest_sessionfinish(
669     session: "Session",
670     exitstatus: Union[int, "ExitCode"],
671 ) -> None:
672     """Called after whole test run finished, right before returning the exit status to the system.
673 
674     :param session: The pytest session object.
675     :param exitstatus: The status which pytest will return to the system.
676     """
677 
678 
679 def pytest_unconfigure(config: "Config") -> None:
680     """Called before test process is exited.
681 
682     :param config: The pytest config object.
683     """
684 
685 
686 # -------------------------------------------------------------------------
687 # hooks for customizing the assert methods
688 # -------------------------------------------------------------------------
689 
690 
691 def pytest_assertrepr_compare(
692     config: "Config", op: str, left: object, right: object
693 ) -> Optional[List[str]]:
694     """Return explanation for comparisons in failing assert expressions.
695 
696     Return None for no custom explanation, otherwise return a list
697     of strings. The strings will be joined by newlines but any newlines
698     *in* a string will be escaped. Note that all but the first line will
699     be indented slightly, the intention is for the first line to be a summary.
700 
701     :param config: The pytest config object.
702     :param op: The operator, e.g. `"=="`, `"!="`, `"not in"`.
703     :param left: The left operand.
704     :param right: The right operand.
705     """
706 
707 
708 def pytest_assertion_pass(item: "Item", lineno: int, orig: str, expl: str) -> None:
709     """Called whenever an assertion passes.
710 
711     .. versionadded:: 5.0
712 
713     Use this hook to do some processing after a passing assertion.
714     The original assertion information is available in the `orig` string
715     and the pytest introspected assertion information is available in the
716     `expl` string.
717 
718     This hook must be explicitly enabled by the ``enable_assertion_pass_hook``
719     ini-file option:
720 
721     .. code-block:: ini
722 
723         [pytest]
724         enable_assertion_pass_hook=true
725 
726     You need to **clean the .pyc** files in your project directory and interpreter libraries
727     when enabling this option, as assertions will require to be re-written.
728 
729     :param item: pytest item object of current test.
730     :param lineno: Line number of the assert statement.
731     :param orig: String with the original assertion.
732     :param expl: String with the assert explanation.
733     """
734 
735 
736 # -------------------------------------------------------------------------
737 # Hooks for influencing reporting (invoked from _pytest_terminal).
738 # -------------------------------------------------------------------------
739 
740 
741 def pytest_report_header(
742     config: "Config", start_path: Path, startdir: "LEGACY_PATH"
743 ) -> Union[str, List[str]]:
744     """Return a string or list of strings to be displayed as header info for terminal reporting.
745 
746     :param config: The pytest config object.
747     :param start_path: The starting dir.
748     :param startdir: The starting dir (deprecated).
749 
750     .. note::
751 
752         Lines returned by a plugin are displayed before those of plugins which
753         ran before it.
754         If you want to have your line(s) displayed first, use
755         :ref:`trylast=True <plugin-hookorder>`.
756 
757     .. note::
758 
759         This function should be implemented only in plugins or ``conftest.py``
760         files situated at the tests root directory due to how pytest
761         :ref:`discovers plugins during startup <pluginorder>`.
762 
763     .. versionchanged:: 7.0.0
764         The ``start_path`` parameter was added as a :class:`pathlib.Path`
765         equivalent of the ``startdir`` parameter. The ``startdir`` parameter
766         has been deprecated.
767     """
768 
769 
770 def pytest_report_collectionfinish(
771     config: "Config",
772     start_path: Path,
773     startdir: "LEGACY_PATH",
774     items: Sequence["Item"],
775 ) -> Union[str, List[str]]:
776     """Return a string or list of strings to be displayed after collection
777     has finished successfully.
778 
779     These strings will be displayed after the standard "collected X items" message.
780 
781     .. versionadded:: 3.2
782 
783     :param config: The pytest config object.
784     :param start_path: The starting dir.
785     :param startdir: The starting dir (deprecated).
786     :param items: List of pytest items that are going to be executed; this list should not be modified.
787 
788     .. note::
789 
790         Lines returned by a plugin are displayed before those of plugins which
791         ran before it.
792         If you want to have your line(s) displayed first, use
793         :ref:`trylast=True <plugin-hookorder>`.
794 
795     .. versionchanged:: 7.0.0
796         The ``start_path`` parameter was added as a :class:`pathlib.Path`
797         equivalent of the ``startdir`` parameter. The ``startdir`` parameter
798         has been deprecated.
799     """
800 
801 
802 @hookspec(firstresult=True)
803 def pytest_report_teststatus(
804     report: Union["CollectReport", "TestReport"], config: "Config"
805 ) -> Tuple[str, str, Union[str, Mapping[str, bool]]]:
806     """Return result-category, shortletter and verbose word for status
807     reporting.
808 
809     The result-category is a category in which to count the result, for
810     example "passed", "skipped", "error" or the empty string.
811 
812     The shortletter is shown as testing progresses, for example ".", "s",
813     "E" or the empty string.
814 
815     The verbose word is shown as testing progresses in verbose mode, for
816     example "PASSED", "SKIPPED", "ERROR" or the empty string.
817 
818     pytest may style these implicitly according to the report outcome.
819     To provide explicit styling, return a tuple for the verbose word,
820     for example ``"rerun", "R", ("RERUN", {"yellow": True})``.
821 
822     :param report: The report object whose status is to be returned.
823     :param config: The pytest config object.
824     :returns: The test status.
825 
826     Stops at first non-None result, see :ref:`firstresult`.
827     """
828 
829 
830 def pytest_terminal_summary(
831     terminalreporter: "TerminalReporter",
832     exitstatus: "ExitCode",
833     config: "Config",
834 ) -> None:
835     """Add a section to terminal summary reporting.
836 
837     :param terminalreporter: The internal terminal reporter object.
838     :param exitstatus: The exit status that will be reported back to the OS.
839     :param config: The pytest config object.
840 
841     .. versionadded:: 4.2
842         The ``config`` parameter.
843     """
844 
845 
846 @hookspec(historic=True)
847 def pytest_warning_recorded(
848     warning_message: "warnings.WarningMessage",
849     when: "Literal['config', 'collect', 'runtest']",
850     nodeid: str,
851     location: Optional[Tuple[str, int, str]],
852 ) -> None:
853     """Process a warning captured by the internal pytest warnings plugin.
854 
855     :param warning_message:
856         The captured warning. This is the same object produced by :py:func:`warnings.catch_warnings`, and contains
857         the same attributes as the parameters of :py:func:`warnings.showwarning`.
858 
859     :param when:
860         Indicates when the warning was captured. Possible values:
861 
862         * ``"config"``: during pytest configuration/initialization stage.
863         * ``"collect"``: during test collection.
864         * ``"runtest"``: during test execution.
865 
866     :param nodeid:
867         Full id of the item.
868 
869     :param location:
870         When available, holds information about the execution context of the captured
871         warning (filename, linenumber, function). ``function`` evaluates to <module>
872         when the execution context is at the module level.
873 
874     .. versionadded:: 6.0
875     """
876 
877 
878 # -------------------------------------------------------------------------
879 # Hooks for influencing skipping
880 # -------------------------------------------------------------------------
881 
882 
883 def pytest_markeval_namespace(config: "Config") -> Dict[str, Any]:
884     """Called when constructing the globals dictionary used for
885     evaluating string conditions in xfail/skipif markers.
886 
887     This is useful when the condition for a marker requires
888     objects that are expensive or impossible to obtain during
889     collection time, which is required by normal boolean
890     conditions.
891 
892     .. versionadded:: 6.2
893 
894     :param config: The pytest config object.
895     :returns: A dictionary of additional globals to add.
896     """
897 
898 
899 # -------------------------------------------------------------------------
900 # error handling and internal debugging hooks
901 # -------------------------------------------------------------------------
902 
903 
904 def pytest_internalerror(
905     excrepr: "ExceptionRepr",
906     excinfo: "ExceptionInfo[BaseException]",
907 ) -> Optional[bool]:
908     """Called for internal errors.
909 
910     Return True to suppress the fallback handling of printing an
911     INTERNALERROR message directly to sys.stderr.
912 
913     :param excrepr: The exception repr object.
914     :param excinfo: The exception info.
915     """
916 
917 
918 def pytest_keyboard_interrupt(
919     excinfo: "ExceptionInfo[Union[KeyboardInterrupt, Exit]]",
920 ) -> None:
921     """Called for keyboard interrupt.
922 
923     :param excinfo: The exception info.
924     """
925 
926 
927 def pytest_exception_interact(
928     node: Union["Item", "Collector"],
929     call: "CallInfo[Any]",
930     report: Union["CollectReport", "TestReport"],
931 ) -> None:
932     """Called when an exception was raised which can potentially be
933     interactively handled.
934 
935     May be called during collection (see :hook:`pytest_make_collect_report`),
936     in which case ``report`` is a :class:`CollectReport`.
937 
938     May be called during runtest of an item (see :hook:`pytest_runtest_protocol`),
939     in which case ``report`` is a :class:`TestReport`.
940 
941     This hook is not called if the exception that was raised is an internal
942     exception like ``skip.Exception``.
943 
944     :param node:
945         The item or collector.
946     :param call:
947         The call information. Contains the exception.
948     :param report:
949         The collection or test report.
950     """
951 
952 
953 def pytest_enter_pdb(config: "Config", pdb: "pdb.Pdb") -> None:
954     """Called upon pdb.set_trace().
955 
956     Can be used by plugins to take special action just before the python
957     debugger enters interactive mode.
958 
959     :param config: The pytest config object.
960     :param pdb: The Pdb instance.
961     """
962 
963 
964 def pytest_leave_pdb(config: "Config", pdb: "pdb.Pdb") -> None:
965     """Called when leaving pdb (e.g. with continue after pdb.set_trace()).
966 
967     Can be used by plugins to take special action just after the python
968     debugger leaves interactive mode.
969 
970     :param config: The pytest config object.
971     :param pdb: The Pdb instance.
972     """

</code><intended_behavior>This file likely defines the `pytest_configure` hookspec or related mechanisms. To resolve the issue, the code that triggers the `PytestDeprecationWarning` for old-style `hookimpl` usage within this file (or within the system that processes these hookspecs) should be enhanced. It should not only check for and warn about deprecated usage but also include information about the source of the deprecation (i.e., the plugin or file defining the deprecated hook). This enhancement might involve capturing the `__file__` attribute of the function or module when the `hookimpl` is registered and including that information in the warning message. Preserving Existing Functionality: The update should maintain all existing functionality surrounding hook registration and warning issuance. The primary change is to augment the warning message with location information, without affecting the registration or execution of hooks themselves.</intended_behavior>, <file>src/_pytest/config/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Command line options, ini-file and conftest.py processing."""
2 import argparse
3 import collections.abc
4 import copy
5 import enum
6 import glob
7 import inspect
8 import os
9 import re
10 import shlex
11 import sys
12 import types
13 import warnings
14 from functools import lru_cache
15 from pathlib import Path
16 from textwrap import dedent
17 from types import FunctionType
18 from types import TracebackType
19 from typing import Any
20 from typing import Callable
21 from typing import cast
22 from typing import Dict
23 from typing import Generator
24 from typing import IO
25 from typing import Iterable
26 from typing import Iterator
27 from typing import List
28 from typing import Optional
29 from typing import Sequence
30 from typing import Set
31 from typing import TextIO
32 from typing import Tuple
33 from typing import Type
34 from typing import TYPE_CHECKING
35 from typing import Union
36 
37 import attr
38 from pluggy import HookimplMarker
39 from pluggy import HookspecMarker
40 from pluggy import PluginManager
41 
42 import _pytest._code
43 import _pytest.deprecated
44 import _pytest.hookspec
45 from .exceptions import PrintHelp as PrintHelp
46 from .exceptions import UsageError as UsageError
47 from .findpaths import determine_setup
48 from _pytest._code import ExceptionInfo
49 from _pytest._code import filter_traceback
50 from _pytest._io import TerminalWriter
51 from _pytest.compat import final
52 from _pytest.compat import importlib_metadata
53 from _pytest.outcomes import fail
54 from _pytest.outcomes import Skipped
55 from _pytest.pathlib import absolutepath
56 from _pytest.pathlib import bestrelpath
57 from _pytest.pathlib import import_path
58 from _pytest.pathlib import ImportMode
59 from _pytest.pathlib import resolve_package_path
60 from _pytest.stash import Stash
61 from _pytest.warning_types import PytestConfigWarning
62 from _pytest.warning_types import warn_explicit_for
63 
64 if TYPE_CHECKING:
65 
66     from _pytest._code.code import _TracebackStyle
67     from _pytest.terminal import TerminalReporter
68     from .argparsing import Argument
69 
70 
71 _PluggyPlugin = object
72 """A type to represent plugin objects.
73 
74 Plugins can be any namespace, so we can't narrow it down much, but we use an
75 alias to make the intent clear.
76 
77 Ideally this type would be provided by pluggy itself.
78 """
79 
80 
81 hookimpl = HookimplMarker("pytest")
82 hookspec = HookspecMarker("pytest")
83 
84 
85 @final
86 class ExitCode(enum.IntEnum):
87     """Encodes the valid exit codes by pytest.
88 
89     Currently users and plugins may supply other exit codes as well.
90 
91     .. versionadded:: 5.0
92     """
93 
94     #: Tests passed.
95     OK = 0
96     #: Tests failed.
97     TESTS_FAILED = 1
98     #: pytest was interrupted.
99     INTERRUPTED = 2
100     #: An internal error got in the way.
101     INTERNAL_ERROR = 3
102     #: pytest was misused.
103     USAGE_ERROR = 4
104     #: pytest couldn't find tests.
105     NO_TESTS_COLLECTED = 5
106 
107 
108 class ConftestImportFailure(Exception):
109     def __init__(
110         self,
111         path: Path,
112         excinfo: Tuple[Type[Exception], Exception, TracebackType],
113     ) -> None:
114         super().__init__(path, excinfo)
115         self.path = path
116         self.excinfo = excinfo
117 
118     def __str__(self) -> str:
119         return "{}: {} (from {})".format(
120             self.excinfo[0].__name__, self.excinfo[1], self.path
121         )
122 
123 
124 def filter_traceback_for_conftest_import_failure(
125     entry: _pytest._code.TracebackEntry,
126 ) -> bool:
127     """Filter tracebacks entries which point to pytest internals or importlib.
128 
129     Make a special case for importlib because we use it to import test modules and conftest files
130     in _pytest.pathlib.import_path.
131     """
132     return filter_traceback(entry) and "importlib" not in str(entry.path).split(os.sep)
133 
134 
135 def main(
136     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
137     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
138 ) -> Union[int, ExitCode]:
139     """Perform an in-process test run.
140 
141     :param args: List of command line arguments.
142     :param plugins: List of plugin objects to be auto-registered during initialization.
143 
144     :returns: An exit code.
145     """
146     try:
147         try:
148             config = _prepareconfig(args, plugins)
149         except ConftestImportFailure as e:
150             exc_info = ExceptionInfo.from_exc_info(e.excinfo)
151             tw = TerminalWriter(sys.stderr)
152             tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
153             exc_info.traceback = exc_info.traceback.filter(
154                 filter_traceback_for_conftest_import_failure
155             )
156             exc_repr = (
157                 exc_info.getrepr(style="short", chain=False)
158                 if exc_info.traceback
159                 else exc_info.exconly()
160             )
161             formatted_tb = str(exc_repr)
162             for line in formatted_tb.splitlines():
163                 tw.line(line.rstrip(), red=True)
164             return ExitCode.USAGE_ERROR
165         else:
166             try:
167                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
168                     config=config
169                 )
170                 try:
171                     return ExitCode(ret)
172                 except ValueError:
173                     return ret
174             finally:
175                 config._ensure_unconfigure()
176     except UsageError as e:
177         tw = TerminalWriter(sys.stderr)
178         for msg in e.args:
179             tw.line(f"ERROR: {msg}\n", red=True)
180         return ExitCode.USAGE_ERROR
181 
182 
183 def console_main() -> int:
184     """The CLI entry point of pytest.
185 
186     This function is not meant for programmable use; use `main()` instead.
187     """
188     # https://docs.python.org/3/library/signal.html#note-on-sigpipe
189     try:
190         code = main()
191         sys.stdout.flush()
192         return code
193     except BrokenPipeError:
194         # Python flushes standard streams on exit; redirect remaining output
195         # to devnull to avoid another BrokenPipeError at shutdown
196         devnull = os.open(os.devnull, os.O_WRONLY)
197         os.dup2(devnull, sys.stdout.fileno())
198         return 1  # Python exits with error code 1 on EPIPE
199 
200 
201 class cmdline:  # compatibility namespace
202     main = staticmethod(main)
203 
204 
205 def filename_arg(path: str, optname: str) -> str:
206     """Argparse type validator for filename arguments.
207 
208     :path: Path of filename.
209     :optname: Name of the option.
210     """
211     if os.path.isdir(path):
212         raise UsageError(f"{optname} must be a filename, given: {path}")
213     return path
214 
215 
216 def directory_arg(path: str, optname: str) -> str:
217     """Argparse type validator for directory arguments.
218 
219     :path: Path of directory.
220     :optname: Name of the option.
221     """
222     if not os.path.isdir(path):
223         raise UsageError(f"{optname} must be a directory, given: {path}")
224     return path
225 
226 
227 # Plugins that cannot be disabled via "-p no:X" currently.
228 essential_plugins = (
229     "mark",
230     "main",
231     "runner",
232     "fixtures",
233     "helpconfig",  # Provides -p.
234 )
235 
236 default_plugins = essential_plugins + (
237     "python",
238     "terminal",
239     "debugging",
240     "unittest",
241     "capture",
242     "skipping",
243     "legacypath",
244     "tmpdir",
245     "monkeypatch",
246     "recwarn",
247     "pastebin",
248     "nose",
249     "assertion",
250     "junitxml",
251     "doctest",
252     "cacheprovider",
253     "freeze_support",
254     "setuponly",
255     "setupplan",
256     "stepwise",
257     "warnings",
258     "logging",
259     "reports",
260     "python_path",
261     *(["unraisableexception", "threadexception"] if sys.version_info >= (3, 8) else []),
262     "faulthandler",
263 )
264 
265 builtin_plugins = set(default_plugins)
266 builtin_plugins.add("pytester")
267 builtin_plugins.add("pytester_assertions")
268 
269 
270 def get_config(
271     args: Optional[List[str]] = None,
272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
273 ) -> "Config":
274     # subsequent calls to main will create a fresh instance
275     pluginmanager = PytestPluginManager()
276     config = Config(
277         pluginmanager,
278         invocation_params=Config.InvocationParams(
279             args=args or (),
280             plugins=plugins,
281             dir=Path.cwd(),
282         ),
283     )
284 
285     if args is not None:
286         # Handle any "-p no:plugin" args.
287         pluginmanager.consider_preparse(args, exclude_only=True)
288 
289     for spec in default_plugins:
290         pluginmanager.import_plugin(spec)
291 
292     return config
293 
294 
295 def get_plugin_manager() -> "PytestPluginManager":
296     """Obtain a new instance of the
297     :py:class:`pytest.PytestPluginManager`, with default plugins
298     already loaded.
299 
300     This function can be used by integration with other tools, like hooking
301     into pytest to run tests into an IDE.
302     """
303     return get_config().pluginmanager
304 
305 
306 def _prepareconfig(
307     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
309 ) -> "Config":
310     if args is None:
311         args = sys.argv[1:]
312     elif isinstance(args, os.PathLike):
313         args = [os.fspath(args)]
314     elif not isinstance(args, list):
315         msg = (  # type:ignore[unreachable]
316             "`args` parameter expected to be a list of strings, got: {!r} (type: {})"
317         )
318         raise TypeError(msg.format(args, type(args)))
319 
320     config = get_config(args, plugins)
321     pluginmanager = config.pluginmanager
322     try:
323         if plugins:
324             for plugin in plugins:
325                 if isinstance(plugin, str):
326                     pluginmanager.consider_pluginarg(plugin)
327                 else:
328                     pluginmanager.register(plugin)
329         config = pluginmanager.hook.pytest_cmdline_parse(
330             pluginmanager=pluginmanager, args=args
331         )
332         return config
333     except BaseException:
334         config._ensure_unconfigure()
335         raise
336 
337 
338 def _get_directory(path: Path) -> Path:
339     """Get the directory of a path - itself if already a directory."""
340     if path.is_file():
341         return path.parent
342     else:
343         return path
344 
345 
346 def _get_legacy_hook_marks(
347     method: Any,
348     hook_type: str,
349     opt_names: Tuple[str, ...],
350 ) -> Dict[str, bool]:
351     if TYPE_CHECKING:
352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias
353         assert inspect.isroutine(method)
354     known_marks: set[str] = {m.name for m in getattr(method, "pytestmark", [])}
355     must_warn: list[str] = []
356     opts: dict[str, bool] = {}
357     for opt_name in opt_names:
358         opt_attr = getattr(method, opt_name, AttributeError)
359         if opt_attr is not AttributeError:
360             must_warn.append(f"{opt_name}={opt_attr}")
361             opts[opt_name] = True
362         elif opt_name in known_marks:
363             must_warn.append(f"{opt_name}=True")
364             opts[opt_name] = True
365         else:
366             opts[opt_name] = False
367     if must_warn:
368         hook_opts = ", ".join(must_warn)
369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(
370             type=hook_type,
371             fullname=method.__qualname__,
372             hook_opts=hook_opts,
373         )
374         warn_explicit_for(cast(FunctionType, method), message)
375     return opts
376 
377 
378 @final
379 class PytestPluginManager(PluginManager):
380     """A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with
381     additional pytest-specific functionality:
382 
383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and
384       ``pytest_plugins`` global variables found in plugins being loaded.
385     * ``conftest.py`` loading during start-up.
386     """
387 
388     def __init__(self) -> None:
389         import _pytest.assertion
390 
391         super().__init__("pytest")
392 
393         # -- State related to local conftest plugins.
394         # All loaded conftest modules.
395         self._conftest_plugins: Set[types.ModuleType] = set()
396         # All conftest modules applicable for a directory.
397         # This includes the directory's own conftest modules as well
398         # as those of its parent directories.
399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}
400         # Cutoff directory above which conftests are no longer discovered.
401         self._confcutdir: Optional[Path] = None
402         # If set, conftest loading is skipped.
403         self._noconftest = False
404 
405         # _getconftestmodules()'s call to _get_directory() causes a stat
406         # storm when it's called potentially thousands of times in a test
407         # session (#9478), often with the same path, so cache it.
408         self._get_directory = lru_cache(256)(_get_directory)
409 
410         self._duplicatepaths: Set[Path] = set()
411 
412         # plugins that were explicitly skipped with pytest.skip
413         # list of (module name, skip reason)
414         # previously we would issue a warning when a plugin was skipped, but
415         # since we refactored warnings as first citizens of Config, they are
416         # just stored here to be used later.
417         self.skipped_plugins: List[Tuple[str, str]] = []
418 
419         self.add_hookspecs(_pytest.hookspec)
420         self.register(self)
421         if os.environ.get("PYTEST_DEBUG"):
422             err: IO[str] = sys.stderr
423             encoding: str = getattr(err, "encoding", "utf8")
424             try:
425                 err = open(
426                     os.dup(err.fileno()),
427                     mode=err.mode,
428                     buffering=1,
429                     encoding=encoding,
430                 )
431             except Exception:
432                 pass
433             self.trace.root.setwriter(err.write)
434             self.enable_tracing()
435 
436         # Config._consider_importhook will set a real object if required.
437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()
438         # Used to know when we are importing conftests after the pytest_configure stage.
439         self._configured = False
440 
441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):
442         # pytest hooks are always prefixed with "pytest_",
443         # so we avoid accessing possibly non-readable attributes
444         # (see issue #1073).
445         if not name.startswith("pytest_"):
446             return
447         # Ignore names which can not be hooks.
448         if name == "pytest_plugins":
449             return
450 
451         opts = super().parse_hookimpl_opts(plugin, name)
452         if opts is not None:
453             return opts
454 
455         method = getattr(plugin, name)
456         # Consider only actual functions for hooks (#3775).
457         if not inspect.isroutine(method):
458             return
459         # Collect unmarked hooks as long as they have the `pytest_' prefix.
460         return _get_legacy_hook_marks(
461             method, "impl", ("tryfirst", "trylast", "optionalhook", "hookwrapper")
462         )
463 
464     def parse_hookspec_opts(self, module_or_class, name: str):
465         opts = super().parse_hookspec_opts(module_or_class, name)
466         if opts is None:
467             method = getattr(module_or_class, name)
468             if name.startswith("pytest_"):
469                 opts = _get_legacy_hook_marks(
470                     method,
471                     "spec",
472                     ("firstresult", "historic"),
473                 )
474         return opts
475 
476     def register(
477         self, plugin: _PluggyPlugin, name: Optional[str] = None
478     ) -> Optional[str]:
479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
480             warnings.warn(
481                 PytestConfigWarning(
482                     "{} plugin has been merged into the core, "
483                     "please remove it from your requirements.".format(
484                         name.replace("_", "-")
485                     )
486                 )
487             )
488             return None
489         ret: Optional[str] = super().register(plugin, name)
490         if ret:
491             self.hook.pytest_plugin_registered.call_historic(
492                 kwargs=dict(plugin=plugin, manager=self)
493             )
494 
495             if isinstance(plugin, types.ModuleType):
496                 self.consider_module(plugin)
497         return ret
498 
499     def getplugin(self, name: str):
500         # Support deprecated naming because plugins (xdist e.g.) use it.
501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)
502         return plugin
503 
504     def hasplugin(self, name: str) -> bool:
505         """Return whether a plugin with the given name is registered."""
506         return bool(self.get_plugin(name))
507 
508     def pytest_configure(self, config: "Config") -> None:
509         """:meta private:"""
510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)
511         # we should remove tryfirst/trylast as markers.
512         config.addinivalue_line(
513             "markers",
514             "tryfirst: mark a hook implementation function such that the "
515             "plugin machinery will try to call it first/as early as possible.",
516         )
517         config.addinivalue_line(
518             "markers",
519             "trylast: mark a hook implementation function such that the "
520             "plugin machinery will try to call it last/as late as possible.",
521         )
522         self._configured = True
523 
524     #
525     # Internal API for local conftest plugin handling.
526     #
527     def _set_initial_conftests(
528         self, namespace: argparse.Namespace, rootpath: Path
529     ) -> None:
530         """Load initial conftest files given a preparsed "namespace".
531 
532         As conftest files may add their own command line options which have
533         arguments ('--my-opt somepath') we might get some false positives.
534         All builtin and 3rd party plugins will have been loaded, however, so
535         common options will not confuse our logic here.
536         """
537         current = Path.cwd()
538         self._confcutdir = (
539             absolutepath(current / namespace.confcutdir)
540             if namespace.confcutdir
541             else None
542         )
543         self._noconftest = namespace.noconftest
544         self._using_pyargs = namespace.pyargs
545         testpaths = namespace.file_or_dir
546         foundanchor = False
547         for testpath in testpaths:
548             path = str(testpath)
549             # remove node-id syntax
550             i = path.find("::")
551             if i != -1:
552                 path = path[:i]
553             anchor = absolutepath(current / path)
554             if anchor.exists():  # we found some file object
555                 self._try_load_conftest(anchor, namespace.importmode, rootpath)
556                 foundanchor = True
557         if not foundanchor:
558             self._try_load_conftest(current, namespace.importmode, rootpath)
559 
560     def _is_in_confcutdir(self, path: Path) -> bool:
561         """Whether a path is within the confcutdir.
562 
563         When false, should not load conftest.
564         """
565         if self._confcutdir is None:
566             return True
567         return path not in self._confcutdir.parents
568 
569     def _try_load_conftest(
570         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path
571     ) -> None:
572         self._getconftestmodules(anchor, importmode, rootpath)
573         # let's also consider test* subdirs
574         if anchor.is_dir():
575             for x in anchor.glob("test*"):
576                 if x.is_dir():
577                     self._getconftestmodules(x, importmode, rootpath)
578 
579     def _getconftestmodules(
580         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path
581     ) -> Sequence[types.ModuleType]:
582         if self._noconftest:
583             return []
584 
585         directory = self._get_directory(path)
586 
587         # Optimization: avoid repeated searches in the same directory.
588         # Assumes always called with same importmode and rootpath.
589         existing_clist = self._dirpath2confmods.get(directory)
590         if existing_clist is not None:
591             return existing_clist
592 
593         # XXX these days we may rather want to use config.rootpath
594         # and allow users to opt into looking into the rootdir parent
595         # directories instead of requiring to specify confcutdir.
596         clist = []
597         for parent in reversed((directory, *directory.parents)):
598             if self._is_in_confcutdir(parent):
599                 conftestpath = parent / "conftest.py"
600                 if conftestpath.is_file():
601                     mod = self._importconftest(conftestpath, importmode, rootpath)
602                     clist.append(mod)
603         self._dirpath2confmods[directory] = clist
604         return clist
605 
606     def _rget_with_confmod(
607         self,
608         name: str,
609         path: Path,
610         importmode: Union[str, ImportMode],
611         rootpath: Path,
612     ) -> Tuple[types.ModuleType, Any]:
613         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)
614         for mod in reversed(modules):
615             try:
616                 return mod, getattr(mod, name)
617             except AttributeError:
618                 continue
619         raise KeyError(name)
620 
621     def _importconftest(
622         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path
623     ) -> types.ModuleType:
624         existing = self.get_plugin(str(conftestpath))
625         if existing is not None:
626             return cast(types.ModuleType, existing)
627 
628         pkgpath = resolve_package_path(conftestpath)
629         if pkgpath is None:
630             _ensure_removed_sysmodule(conftestpath.stem)
631 
632         try:
633             mod = import_path(conftestpath, mode=importmode, root=rootpath)
634         except Exception as e:
635             assert e.__traceback__ is not None
636             exc_info = (type(e), e, e.__traceback__)
637             raise ConftestImportFailure(conftestpath, exc_info) from e
638 
639         self._check_non_top_pytest_plugins(mod, conftestpath)
640 
641         self._conftest_plugins.add(mod)
642         dirpath = conftestpath.parent
643         if dirpath in self._dirpath2confmods:
644             for path, mods in self._dirpath2confmods.items():
645                 if dirpath in path.parents or path == dirpath:
646                     assert mod not in mods
647                     mods.append(mod)
648         self.trace(f"loading conftestmodule {mod!r}")
649         self.consider_conftest(mod)
650         return mod
651 
652     def _check_non_top_pytest_plugins(
653         self,
654         mod: types.ModuleType,
655         conftestpath: Path,
656     ) -> None:
657         if (
658             hasattr(mod, "pytest_plugins")
659             and self._configured
660             and not self._using_pyargs
661         ):
662             msg = (
663                 "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\n"
664                 "It affects the entire test suite instead of just below the conftest as expected.\n"
665                 "  {}\n"
666                 "Please move it to a top level conftest file at the rootdir:\n"
667                 "  {}\n"
668                 "For more information, visit:\n"
669                 "  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files"
670             )
671             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)
672 
673     #
674     # API for bootstrapping plugin loading
675     #
676     #
677 
678     def consider_preparse(
679         self, args: Sequence[str], *, exclude_only: bool = False
680     ) -> None:
681         """:meta private:"""
682         i = 0
683         n = len(args)
684         while i < n:
685             opt = args[i]
686             i += 1
687             if isinstance(opt, str):
688                 if opt == "-p":
689                     try:
690                         parg = args[i]
691                     except IndexError:
692                         return
693                     i += 1
694                 elif opt.startswith("-p"):
695                     parg = opt[2:]
696                 else:
697                     continue
698                 if exclude_only and not parg.startswith("no:"):
699                     continue
700                 self.consider_pluginarg(parg)
701 
702     def consider_pluginarg(self, arg: str) -> None:
703         """:meta private:"""
704         if arg.startswith("no:"):
705             name = arg[3:]
706             if name in essential_plugins:
707                 raise UsageError("plugin %s cannot be disabled" % name)
708 
709             # PR #4304: remove stepwise if cacheprovider is blocked.
710             if name == "cacheprovider":
711                 self.set_blocked("stepwise")
712                 self.set_blocked("pytest_stepwise")
713 
714             self.set_blocked(name)
715             if not name.startswith("pytest_"):
716                 self.set_blocked("pytest_" + name)
717         else:
718             name = arg
719             # Unblock the plugin.  None indicates that it has been blocked.
720             # There is no interface with pluggy for this.
721             if self._name2plugin.get(name, -1) is None:
722                 del self._name2plugin[name]
723             if not name.startswith("pytest_"):
724                 if self._name2plugin.get("pytest_" + name, -1) is None:
725                     del self._name2plugin["pytest_" + name]
726             self.import_plugin(arg, consider_entry_points=True)
727 
728     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:
729         """:meta private:"""
730         self.register(conftestmodule, name=conftestmodule.__file__)
731 
732     def consider_env(self) -> None:
733         """:meta private:"""
734         self._import_plugin_specs(os.environ.get("PYTEST_PLUGINS"))
735 
736     def consider_module(self, mod: types.ModuleType) -> None:
737         """:meta private:"""
738         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
739 
740     def _import_plugin_specs(
741         self, spec: Union[None, types.ModuleType, str, Sequence[str]]
742     ) -> None:
743         plugins = _get_plugin_specs_as_list(spec)
744         for import_spec in plugins:
745             self.import_plugin(import_spec)
746 
747     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:
748         """Import a plugin with ``modname``.
749 
750         If ``consider_entry_points`` is True, entry point names are also
751         considered to find a plugin.
752         """
753         # Most often modname refers to builtin modules, e.g. "pytester",
754         # "terminal" or "capture".  Those plugins are registered under their
755         # basename for historic purposes but must be imported with the
756         # _pytest prefix.
757         assert isinstance(modname, str), (
758             "module name as text required, got %r" % modname
759         )
760         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
761             return
762 
763         importspec = "_pytest." + modname if modname in builtin_plugins else modname
764         self.rewrite_hook.mark_rewrite(importspec)
765 
766         if consider_entry_points:
767             loaded = self.load_setuptools_entrypoints("pytest11", name=modname)
768             if loaded:
769                 return
770 
771         try:
772             __import__(importspec)
773         except ImportError as e:
774             raise ImportError(
775                 f'Error importing plugin "{modname}": {e.args[0]}'
776             ).with_traceback(e.__traceback__) from e
777 
778         except Skipped as e:
779             self.skipped_plugins.append((modname, e.msg or ""))
780         else:
781             mod = sys.modules[importspec]
782             self.register(mod, modname)
783 
784 
785 def _get_plugin_specs_as_list(
786     specs: Union[None, types.ModuleType, str, Sequence[str]]
787 ) -> List[str]:
788     """Parse a plugins specification into a list of plugin names."""
789     # None means empty.
790     if specs is None:
791         return []
792     # Workaround for #3899 - a submodule which happens to be called "pytest_plugins".
793     if isinstance(specs, types.ModuleType):
794         return []
795     # Comma-separated list.
796     if isinstance(specs, str):
797         return specs.split(",") if specs else []
798     # Direct specification.
799     if isinstance(specs, collections.abc.Sequence):
800         return list(specs)
801     raise UsageError(
802         "Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r"
803         % specs
804     )
805 
806 
807 def _ensure_removed_sysmodule(modname: str) -> None:
808     try:
809         del sys.modules[modname]
810     except KeyError:
811         pass
812 
813 
814 class Notset:
815     def __repr__(self):
816         return "<NOTSET>"
817 
818 
819 notset = Notset()
820 
821 
822 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:
823     """Given an iterable of file names in a source distribution, return the "names" that should
824     be marked for assertion rewrite.
825 
826     For example the package "pytest_mock/__init__.py" should be added as "pytest_mock" in
827     the assertion rewrite mechanism.
828 
829     This function has to deal with dist-info based distributions and egg based distributions
830     (which are still very much in use for "editable" installs).
831 
832     Here are the file names as seen in a dist-info based distribution:
833 
834         pytest_mock/__init__.py
835         pytest_mock/_version.py
836         pytest_mock/plugin.py
837         pytest_mock.egg-info/PKG-INFO
838 
839     Here are the file names as seen in an egg based distribution:
840 
841         src/pytest_mock/__init__.py
842         src/pytest_mock/_version.py
843         src/pytest_mock/plugin.py
844         src/pytest_mock.egg-info/PKG-INFO
845         LICENSE
846         setup.py
847 
848     We have to take in account those two distribution flavors in order to determine which
849     names should be considered for assertion rewriting.
850 
851     More information:
852         https://github.com/pytest-dev/pytest-mock/issues/167
853     """
854     package_files = list(package_files)
855     seen_some = False
856     for fn in package_files:
857         is_simple_module = "/" not in fn and fn.endswith(".py")
858         is_package = fn.count("/") == 1 and fn.endswith("__init__.py")
859         if is_simple_module:
860             module_name, _ = os.path.splitext(fn)
861             # we ignore "setup.py" at the root of the distribution
862             # as well as editable installation finder modules made by setuptools
863             if module_name != "setup" and not module_name.startswith("__editable__"):
864                 seen_some = True
865                 yield module_name
866         elif is_package:
867             package_name = os.path.dirname(fn)
868             seen_some = True
869             yield package_name
870 
871     if not seen_some:
872         # At this point we did not find any packages or modules suitable for assertion
873         # rewriting, so we try again by stripping the first path component (to account for
874         # "src" based source trees for example).
875         # This approach lets us have the common case continue to be fast, as egg-distributions
876         # are rarer.
877         new_package_files = []
878         for fn in package_files:
879             parts = fn.split("/")
880             new_fn = "/".join(parts[1:])
881             if new_fn:
882                 new_package_files.append(new_fn)
883         if new_package_files:
884             yield from _iter_rewritable_modules(new_package_files)
885 
886 
887 def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:
888     return tuple(args)
889 
890 
891 @final
892 class Config:
893     """Access to configuration values, pluginmanager and plugin hooks.
894 
895     :param PytestPluginManager pluginmanager:
896         A pytest PluginManager.
897 
898     :param InvocationParams invocation_params:
899         Object containing parameters regarding the :func:`pytest.main`
900         invocation.
901     """
902 
903     @final
904     @attr.s(frozen=True, auto_attribs=True)
905     class InvocationParams:
906         """Holds parameters passed during :func:`pytest.main`.
907 
908         The object attributes are read-only.
909 
910         .. versionadded:: 5.1
911 
912         .. note::
913 
914             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``
915             ini option are handled by pytest, not being included in the ``args`` attribute.
916 
917             Plugins accessing ``InvocationParams`` must be aware of that.
918         """
919 
920         args: Tuple[str, ...] = attr.ib(converter=_args_converter)
921         """The command-line arguments as passed to :func:`pytest.main`."""
922         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]
923         """Extra plugins, might be `None`."""
924         dir: Path
925         """The directory from which :func:`pytest.main` was invoked."""
926 
927     class ArgsSource(enum.Enum):
928         """Indicates the source of the test arguments.
929 
930         .. versionadded:: 7.2
931         """
932 
933         #: Command line arguments.
934         ARGS = enum.auto()
935         #: Invocation directory.
936         INCOVATION_DIR = enum.auto()
937         #: 'testpaths' configuration value.
938         TESTPATHS = enum.auto()
939 
940     def __init__(
941         self,
942         pluginmanager: PytestPluginManager,
943         *,
944         invocation_params: Optional[InvocationParams] = None,
945     ) -> None:
946         from .argparsing import Parser, FILE_OR_DIR
947 
948         if invocation_params is None:
949             invocation_params = self.InvocationParams(
950                 args=(), plugins=None, dir=Path.cwd()
951             )
952 
953         self.option = argparse.Namespace()
954         """Access to command line option as attributes.
955 
956         :type: argparse.Namespace
957         """
958 
959         self.invocation_params = invocation_params
960         """The parameters with which pytest was invoked.
961 
962         :type: InvocationParams
963         """
964 
965         _a = FILE_OR_DIR
966         self._parser = Parser(
967             usage=f"%(prog)s [options] [{_a}] [{_a}] [...]",
968             processopt=self._processopt,
969             _ispytest=True,
970         )
971         self.pluginmanager = pluginmanager
972         """The plugin manager handles plugin registration and hook invocation.
973 
974         :type: PytestPluginManager
975         """
976 
977         self.stash = Stash()
978         """A place where plugins can store information on the config for their
979         own use.
980 
981         :type: Stash
982         """
983         # Deprecated alias. Was never public. Can be removed in a few releases.
984         self._store = self.stash
985 
986         from .compat import PathAwareHookProxy
987 
988         self.trace = self.pluginmanager.trace.root.get("config")
989         self.hook = PathAwareHookProxy(self.pluginmanager.hook)
990         self._inicache: Dict[str, Any] = {}
991         self._override_ini: Sequence[str] = ()
992         self._opt2dest: Dict[str, str] = {}
993         self._cleanup: List[Callable[[], None]] = []
994         self.pluginmanager.register(self, "pytestconfig")
995         self._configured = False
996         self.hook.pytest_addoption.call_historic(
997             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)
998         )
999 
1000         if TYPE_CHECKING:
1001             from _pytest.cacheprovider import Cache
1002 
1003             self.cache: Optional[Cache] = None
1004 
1005     @property
1006     def rootpath(self) -> Path:
1007         """The path to the :ref:`rootdir <rootdir>`.
1008 
1009         :type: pathlib.Path
1010 
1011         .. versionadded:: 6.1
1012         """
1013         return self._rootpath
1014 
1015     @property
1016     def inipath(self) -> Optional[Path]:
1017         """The path to the :ref:`configfile <configfiles>`.
1018 
1019         :type: Optional[pathlib.Path]
1020 
1021         .. versionadded:: 6.1
1022         """
1023         return self._inipath
1024 
1025     def add_cleanup(self, func: Callable[[], None]) -> None:
1026         """Add a function to be called when the config object gets out of
1027         use (usually coinciding with pytest_unconfigure)."""
1028         self._cleanup.append(func)
1029 
1030     def _do_configure(self) -> None:
1031         assert not self._configured
1032         self._configured = True
1033         with warnings.catch_warnings():
1034             warnings.simplefilter("default")
1035             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))
1036 
1037     def _ensure_unconfigure(self) -> None:
1038         if self._configured:
1039             self._configured = False
1040             self.hook.pytest_unconfigure(config=self)
1041             self.hook.pytest_configure._call_history = []
1042         while self._cleanup:
1043             fin = self._cleanup.pop()
1044             fin()
1045 
1046     def get_terminal_writer(self) -> TerminalWriter:
1047         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(
1048             "terminalreporter"
1049         )
1050         return terminalreporter._tw
1051 
1052     def pytest_cmdline_parse(
1053         self, pluginmanager: PytestPluginManager, args: List[str]
1054     ) -> "Config":
1055         try:
1056             self.parse(args)
1057         except UsageError:
1058 
1059             # Handle --version and --help here in a minimal fashion.
1060             # This gets done via helpconfig normally, but its
1061             # pytest_cmdline_main is not called in case of errors.
1062             if getattr(self.option, "version", False) or "--version" in args:
1063                 from _pytest.helpconfig import showversion
1064 
1065                 showversion(self)
1066             elif (
1067                 getattr(self.option, "help", False) or "--help" in args or "-h" in args
1068             ):
1069                 self._parser._getparser().print_help()
1070                 sys.stdout.write(
1071                     "\nNOTE: displaying only minimal help due to UsageError.\n\n"
1072                 )
1073 
1074             raise
1075 
1076         return self
1077 
1078     def notify_exception(
1079         self,
1080         excinfo: ExceptionInfo[BaseException],
1081         option: Optional[argparse.Namespace] = None,
1082     ) -> None:
1083         if option and getattr(option, "fulltrace", False):
1084             style: _TracebackStyle = "long"
1085         else:
1086             style = "native"
1087         excrepr = excinfo.getrepr(
1088             funcargs=True, showlocals=getattr(option, "showlocals", False), style=style
1089         )
1090         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)
1091         if not any(res):
1092             for line in str(excrepr).split("\n"):
1093                 sys.stderr.write("INTERNALERROR> %s\n" % line)
1094                 sys.stderr.flush()
1095 
1096     def cwd_relative_nodeid(self, nodeid: str) -> str:
1097         # nodeid's are relative to the rootpath, compute relative to cwd.
1098         if self.invocation_params.dir != self.rootpath:
1099             fullpath = self.rootpath / nodeid
1100             nodeid = bestrelpath(self.invocation_params.dir, fullpath)
1101         return nodeid
1102 
1103     @classmethod
1104     def fromdictargs(cls, option_dict, args) -> "Config":
1105         """Constructor usable for subprocesses."""
1106         config = get_config(args)
1107         config.option.__dict__.update(option_dict)
1108         config.parse(args, addopts=False)
1109         for x in config.option.plugins:
1110             config.pluginmanager.consider_pluginarg(x)
1111         return config
1112 
1113     def _processopt(self, opt: "Argument") -> None:
1114         for name in opt._short_opts + opt._long_opts:
1115             self._opt2dest[name] = opt.dest
1116 
1117         if hasattr(opt, "default"):
1118             if not hasattr(self.option, opt.dest):
1119                 setattr(self.option, opt.dest, opt.default)
1120 
1121     @hookimpl(trylast=True)
1122     def pytest_load_initial_conftests(self, early_config: "Config") -> None:
1123         self.pluginmanager._set_initial_conftests(
1124             early_config.known_args_namespace, rootpath=early_config.rootpath
1125         )
1126 
1127     def _initini(self, args: Sequence[str]) -> None:
1128         ns, unknown_args = self._parser.parse_known_and_unknown_args(
1129             args, namespace=copy.copy(self.option)
1130         )
1131         rootpath, inipath, inicfg = determine_setup(
1132             ns.inifilename,
1133             ns.file_or_dir + unknown_args,
1134             rootdir_cmd_arg=ns.rootdir or None,
1135             config=self,
1136         )
1137         self._rootpath = rootpath
1138         self._inipath = inipath
1139         self.inicfg = inicfg
1140         self._parser.extra_info["rootdir"] = str(self.rootpath)
1141         self._parser.extra_info["inifile"] = str(self.inipath)
1142         self._parser.addini("addopts", "Extra command line options", "args")
1143         self._parser.addini("minversion", "Minimally required pytest version")
1144         self._parser.addini(
1145             "required_plugins",
1146             "Plugins that must be present for pytest to run",
1147             type="args",
1148             default=[],
1149         )
1150         self._override_ini = ns.override_ini or ()
1151 
1152     def _consider_importhook(self, args: Sequence[str]) -> None:
1153         """Install the PEP 302 import hook if using assertion rewriting.
1154 
1155         Needs to parse the --assert=<mode> option from the commandline
1156         and find all the installed plugins to mark them for rewriting
1157         by the importhook.
1158         """
1159         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)
1160         mode = getattr(ns, "assertmode", "plain")
1161         if mode == "rewrite":
1162             import _pytest.assertion
1163 
1164             try:
1165                 hook = _pytest.assertion.install_importhook(self)
1166             except SystemError:
1167                 mode = "plain"
1168             else:
1169                 self._mark_plugins_for_rewrite(hook)
1170         self._warn_about_missing_assertion(mode)
1171 
1172     def _mark_plugins_for_rewrite(self, hook) -> None:
1173         """Given an importhook, mark for rewrite any top-level
1174         modules or packages in the distribution package for
1175         all pytest plugins."""
1176         self.pluginmanager.rewrite_hook = hook
1177 
1178         if os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1179             # We don't autoload from setuptools entry points, no need to continue.
1180             return
1181 
1182         package_files = (
1183             str(file)
1184             for dist in importlib_metadata.distributions()
1185             if any(ep.group == "pytest11" for ep in dist.entry_points)
1186             for file in dist.files or []
1187         )
1188 
1189         for name in _iter_rewritable_modules(package_files):
1190             hook.mark_rewrite(name)
1191 
1192     def _validate_args(self, args: List[str], via: str) -> List[str]:
1193         """Validate known args."""
1194         self._parser._config_source_hint = via  # type: ignore
1195         try:
1196             self._parser.parse_known_and_unknown_args(
1197                 args, namespace=copy.copy(self.option)
1198             )
1199         finally:
1200             del self._parser._config_source_hint  # type: ignore
1201 
1202         return args
1203 
1204     def _preparse(self, args: List[str], addopts: bool = True) -> None:
1205         if addopts:
1206             env_addopts = os.environ.get("PYTEST_ADDOPTS", "")
1207             if len(env_addopts):
1208                 args[:] = (
1209                     self._validate_args(shlex.split(env_addopts), "via PYTEST_ADDOPTS")
1210                     + args
1211                 )
1212         self._initini(args)
1213         if addopts:
1214             args[:] = (
1215                 self._validate_args(self.getini("addopts"), "via addopts config") + args
1216             )
1217 
1218         self.known_args_namespace = self._parser.parse_known_args(
1219             args, namespace=copy.copy(self.option)
1220         )
1221         self._checkversion()
1222         self._consider_importhook(args)
1223         self.pluginmanager.consider_preparse(args, exclude_only=False)
1224         if not os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1225             # Don't autoload from setuptools entry point. Only explicitly specified
1226             # plugins are going to be loaded.
1227             self.pluginmanager.load_setuptools_entrypoints("pytest11")
1228         self.pluginmanager.consider_env()
1229 
1230         self.known_args_namespace = self._parser.parse_known_args(
1231             args, namespace=copy.copy(self.known_args_namespace)
1232         )
1233 
1234         self._validate_plugins()
1235         self._warn_about_skipped_plugins()
1236 
1237         if self.known_args_namespace.strict:
1238             self.issue_config_time_warning(
1239                 _pytest.deprecated.STRICT_OPTION, stacklevel=2
1240             )
1241 
1242         if self.known_args_namespace.confcutdir is None and self.inipath is not None:
1243             confcutdir = str(self.inipath.parent)
1244             self.known_args_namespace.confcutdir = confcutdir
1245         try:
1246             self.hook.pytest_load_initial_conftests(
1247                 early_config=self, args=args, parser=self._parser
1248             )
1249         except ConftestImportFailure as e:
1250             if self.known_args_namespace.help or self.known_args_namespace.version:
1251                 # we don't want to prevent --help/--version to work
1252                 # so just let is pass and print a warning at the end
1253                 self.issue_config_time_warning(
1254                     PytestConfigWarning(f"could not load initial conftests: {e.path}"),
1255                     stacklevel=2,
1256                 )
1257             else:
1258                 raise
1259 
1260     @hookimpl(hookwrapper=True)
1261     def pytest_collection(self) -> Generator[None, None, None]:
1262         # Validate invalid ini keys after collection is done so we take in account
1263         # options added by late-loading conftest files.
1264         yield
1265         self._validate_config_options()
1266 
1267     def _checkversion(self) -> None:
1268         import pytest
1269 
1270         minver = self.inicfg.get("minversion", None)
1271         if minver:
1272             # Imported lazily to improve start-up time.
1273             from packaging.version import Version
1274 
1275             if not isinstance(minver, str):
1276                 raise pytest.UsageError(
1277                     "%s: 'minversion' must be a single value" % self.inipath
1278                 )
1279 
1280             if Version(minver) > Version(pytest.__version__):
1281                 raise pytest.UsageError(
1282                     "%s: 'minversion' requires pytest-%s, actual pytest-%s'"
1283                     % (
1284                         self.inipath,
1285                         minver,
1286                         pytest.__version__,
1287                     )
1288                 )
1289 
1290     def _validate_config_options(self) -> None:
1291         for key in sorted(self._get_unknown_ini_keys()):
1292             self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
1293 
1294     def _validate_plugins(self) -> None:
1295         required_plugins = sorted(self.getini("required_plugins"))
1296         if not required_plugins:
1297             return
1298 
1299         # Imported lazily to improve start-up time.
1300         from packaging.version import Version
1301         from packaging.requirements import InvalidRequirement, Requirement
1302 
1303         plugin_info = self.pluginmanager.list_plugin_distinfo()
1304         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}
1305 
1306         missing_plugins = []
1307         for required_plugin in required_plugins:
1308             try:
1309                 req = Requirement(required_plugin)
1310             except InvalidRequirement:
1311                 missing_plugins.append(required_plugin)
1312                 continue
1313 
1314             if req.name not in plugin_dist_info:
1315                 missing_plugins.append(required_plugin)
1316             elif not req.specifier.contains(
1317                 Version(plugin_dist_info[req.name]), prereleases=True
1318             ):
1319                 missing_plugins.append(required_plugin)
1320 
1321         if missing_plugins:
1322             raise UsageError(
1323                 "Missing required plugins: {}".format(", ".join(missing_plugins)),
1324             )
1325 
1326     def _warn_or_fail_if_strict(self, message: str) -> None:
1327         if self.known_args_namespace.strict_config:
1328             raise UsageError(message)
1329 
1330         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)
1331 
1332     def _get_unknown_ini_keys(self) -> List[str]:
1333         parser_inicfg = self._parser._inidict
1334         return [name for name in self.inicfg if name not in parser_inicfg]
1335 
1336     def parse(self, args: List[str], addopts: bool = True) -> None:
1337         # Parse given cmdline arguments into this config object.
1338         assert not hasattr(
1339             self, "args"
1340         ), "can only parse cmdline args at most once per Config object"
1341         self.hook.pytest_addhooks.call_historic(
1342             kwargs=dict(pluginmanager=self.pluginmanager)
1343         )
1344         self._preparse(args, addopts=addopts)
1345         # XXX deprecated hook:
1346         self.hook.pytest_cmdline_preparse(config=self, args=args)
1347         self._parser.after_preparse = True  # type: ignore
1348         try:
1349             source = Config.ArgsSource.ARGS
1350             args = self._parser.parse_setoption(
1351                 args, self.option, namespace=self.option
1352             )
1353             if not args:
1354                 if self.invocation_params.dir == self.rootpath:
1355                     source = Config.ArgsSource.TESTPATHS
1356                     testpaths: List[str] = self.getini("testpaths")
1357                     if self.known_args_namespace.pyargs:
1358                         args = testpaths
1359                     else:
1360                         args = []
1361                         for path in testpaths:
1362                             args.extend(sorted(glob.iglob(path, recursive=True)))
1363                 if not args:
1364                     source = Config.ArgsSource.INCOVATION_DIR
1365                     args = [str(self.invocation_params.dir)]
1366             self.args = args
1367             self.args_source = source
1368         except PrintHelp:
1369             pass
1370 
1371     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:
1372         """Issue and handle a warning during the "configure" stage.
1373 
1374         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``
1375         function because it is not possible to have hookwrappers around ``pytest_configure``.
1376 
1377         This function is mainly intended for plugins that need to issue warnings during
1378         ``pytest_configure`` (or similar stages).
1379 
1380         :param warning: The warning instance.
1381         :param stacklevel: stacklevel forwarded to warnings.warn.
1382         """
1383         if self.pluginmanager.is_blocked("warnings"):
1384             return
1385 
1386         cmdline_filters = self.known_args_namespace.pythonwarnings or []
1387         config_filters = self.getini("filterwarnings")
1388 
1389         with warnings.catch_warnings(record=True) as records:
1390             warnings.simplefilter("always", type(warning))
1391             apply_warning_filters(config_filters, cmdline_filters)
1392             warnings.warn(warning, stacklevel=stacklevel)
1393 
1394         if records:
1395             frame = sys._getframe(stacklevel - 1)
1396             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name
1397             self.hook.pytest_warning_recorded.call_historic(
1398                 kwargs=dict(
1399                     warning_message=records[0],
1400                     when="config",
1401                     nodeid="",
1402                     location=location,
1403                 )
1404             )
1405 
1406     def addinivalue_line(self, name: str, line: str) -> None:
1407         """Add a line to an ini-file option. The option must have been
1408         declared but might not yet be set in which case the line becomes
1409         the first line in its value."""
1410         x = self.getini(name)
1411         assert isinstance(x, list)
1412         x.append(line)  # modifies the cached list inline
1413 
1414     def getini(self, name: str):
1415         """Return configuration value from an :ref:`ini file <configfiles>`.
1416 
1417         If the specified name hasn't been registered through a prior
1418         :func:`parser.addini <pytest.Parser.addini>` call (usually from a
1419         plugin), a ValueError is raised.
1420         """
1421         try:
1422             return self._inicache[name]
1423         except KeyError:
1424             self._inicache[name] = val = self._getini(name)
1425             return val
1426 
1427     # Meant for easy monkeypatching by legacypath plugin.
1428     # Can be inlined back (with no cover removed) once legacypath is gone.
1429     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):
1430         msg = f"unknown configuration type: {type}"
1431         raise ValueError(msg, value)  # pragma: no cover
1432 
1433     def _getini(self, name: str):
1434         try:
1435             description, type, default = self._parser._inidict[name]
1436         except KeyError as e:
1437             raise ValueError(f"unknown configuration value: {name!r}") from e
1438         override_value = self._get_override_ini_value(name)
1439         if override_value is None:
1440             try:
1441                 value = self.inicfg[name]
1442             except KeyError:
1443                 if default is not None:
1444                     return default
1445                 if type is None:
1446                     return ""
1447                 return []
1448         else:
1449             value = override_value
1450         # Coerce the values based on types.
1451         #
1452         # Note: some coercions are only required if we are reading from .ini files, because
1453         # the file format doesn't contain type information, but when reading from toml we will
1454         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).
1455         # For example:
1456         #
1457         #   ini:
1458         #     a_line_list = "tests acceptance"
1459         #   in this case, we need to split the string to obtain a list of strings.
1460         #
1461         #   toml:
1462         #     a_line_list = ["tests", "acceptance"]
1463         #   in this case, we already have a list ready to use.
1464         #
1465         if type == "paths":
1466             # TODO: This assert is probably not valid in all cases.
1467             assert self.inipath is not None
1468             dp = self.inipath.parent
1469             input_values = shlex.split(value) if isinstance(value, str) else value
1470             return [dp / x for x in input_values]
1471         elif type == "args":
1472             return shlex.split(value) if isinstance(value, str) else value
1473         elif type == "linelist":
1474             if isinstance(value, str):
1475                 return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
1476             else:
1477                 return value
1478         elif type == "bool":
1479             return _strtobool(str(value).strip())
1480         elif type == "string":
1481             return value
1482         elif type is None:
1483             return value
1484         else:
1485             return self._getini_unknown_type(name, type, value)
1486 
1487     def _getconftest_pathlist(
1488         self, name: str, path: Path, rootpath: Path
1489     ) -> Optional[List[Path]]:
1490         try:
1491             mod, relroots = self.pluginmanager._rget_with_confmod(
1492                 name, path, self.getoption("importmode"), rootpath
1493             )
1494         except KeyError:
1495             return None
1496         assert mod.__file__ is not None
1497         modpath = Path(mod.__file__).parent
1498         values: List[Path] = []
1499         for relroot in relroots:
1500             if isinstance(relroot, os.PathLike):
1501                 relroot = Path(relroot)
1502             else:
1503                 relroot = relroot.replace("/", os.sep)
1504                 relroot = absolutepath(modpath / relroot)
1505             values.append(relroot)
1506         return values
1507 
1508     def _get_override_ini_value(self, name: str) -> Optional[str]:
1509         value = None
1510         # override_ini is a list of "ini=value" options.
1511         # Always use the last item if multiple values are set for same ini-name,
1512         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.
1513         for ini_config in self._override_ini:
1514             try:
1515                 key, user_ini_value = ini_config.split("=", 1)
1516             except ValueError as e:
1517                 raise UsageError(
1518                     "-o/--override-ini expects option=value style (got: {!r}).".format(
1519                         ini_config
1520                     )
1521                 ) from e
1522             else:
1523                 if key == name:
1524                     value = user_ini_value
1525         return value
1526 
1527     def getoption(self, name: str, default=notset, skip: bool = False):
1528         """Return command line option value.
1529 
1530         :param name: Name of the option.  You may also specify
1531             the literal ``--OPT`` option instead of the "dest" option name.
1532         :param default: Default value if no option of that name exists.
1533         :param skip: If True, raise pytest.skip if option does not exists
1534             or has a None value.
1535         """
1536         name = self._opt2dest.get(name, name)
1537         try:
1538             val = getattr(self.option, name)
1539             if val is None and skip:
1540                 raise AttributeError(name)
1541             return val
1542         except AttributeError as e:
1543             if default is not notset:
1544                 return default
1545             if skip:
1546                 import pytest
1547 
1548                 pytest.skip(f"no {name!r} option found")
1549             raise ValueError(f"no option named {name!r}") from e
1550 
1551     def getvalue(self, name: str, path=None):
1552         """Deprecated, use getoption() instead."""
1553         return self.getoption(name)
1554 
1555     def getvalueorskip(self, name: str, path=None):
1556         """Deprecated, use getoption(skip=True) instead."""
1557         return self.getoption(name, skip=True)
1558 
1559     def _warn_about_missing_assertion(self, mode: str) -> None:
1560         if not _assertion_supported():
1561             if mode == "plain":
1562                 warning_text = (
1563                     "ASSERTIONS ARE NOT EXECUTED"
1564                     " and FAILING TESTS WILL PASS.  Are you"
1565                     " using python -O?"
1566                 )
1567             else:
1568                 warning_text = (
1569                     "assertions not in test modules or"
1570                     " plugins will be ignored"
1571                     " because assert statements are not executed "
1572                     "by the underlying Python interpreter "
1573                     "(are you using python -O?)\n"
1574                 )
1575             self.issue_config_time_warning(
1576                 PytestConfigWarning(warning_text),
1577                 stacklevel=3,
1578             )
1579 
1580     def _warn_about_skipped_plugins(self) -> None:
1581         for module_name, msg in self.pluginmanager.skipped_plugins:
1582             self.issue_config_time_warning(
1583                 PytestConfigWarning(f"skipped plugin {module_name!r}: {msg}"),
1584                 stacklevel=2,
1585             )
1586 
1587 
1588 def _assertion_supported() -> bool:
1589     try:
1590         assert False
1591     except AssertionError:
1592         return True
1593     else:
1594         return False  # type: ignore[unreachable]
1595 
1596 
1597 def create_terminal_writer(
1598     config: Config, file: Optional[TextIO] = None
1599 ) -> TerminalWriter:
1600     """Create a TerminalWriter instance configured according to the options
1601     in the config object.
1602 
1603     Every code which requires a TerminalWriter object and has access to a
1604     config object should use this function.
1605     """
1606     tw = TerminalWriter(file=file)
1607 
1608     if config.option.color == "yes":
1609         tw.hasmarkup = True
1610     elif config.option.color == "no":
1611         tw.hasmarkup = False
1612 
1613     if config.option.code_highlight == "yes":
1614         tw.code_highlight = True
1615     elif config.option.code_highlight == "no":
1616         tw.code_highlight = False
1617 
1618     return tw
1619 
1620 
1621 def _strtobool(val: str) -> bool:
1622     """Convert a string representation of truth to True or False.
1623 
1624     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
1625     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
1626     'val' is anything else.
1627 
1628     .. note:: Copied from distutils.util.
1629     """
1630     val = val.lower()
1631     if val in ("y", "yes", "t", "true", "on", "1"):
1632         return True
1633     elif val in ("n", "no", "f", "false", "off", "0"):
1634         return False
1635     else:
1636         raise ValueError(f"invalid truth value {val!r}")
1637 
1638 
1639 @lru_cache(maxsize=50)
1640 def parse_warning_filter(
1641     arg: str, *, escape: bool
1642 ) -> Tuple["warnings._ActionKind", str, Type[Warning], str, int]:
1643     """Parse a warnings filter string.
1644 
1645     This is copied from warnings._setoption with the following changes:
1646 
1647     * Does not apply the filter.
1648     * Escaping is optional.
1649     * Raises UsageError so we get nice error messages on failure.
1650     """
1651     __tracebackhide__ = True
1652     error_template = dedent(
1653         f"""\
1654         while parsing the following warning configuration:
1655 
1656           {arg}
1657 
1658         This error occurred:
1659 
1660         {{error}}
1661         """
1662     )
1663 
1664     parts = arg.split(":")
1665     if len(parts) > 5:
1666         doc_url = (
1667             "https://docs.python.org/3/library/warnings.html#describing-warning-filters"
1668         )
1669         error = dedent(
1670             f"""\
1671             Too many fields ({len(parts)}), expected at most 5 separated by colons:
1672 
1673               action:message:category:module:line
1674 
1675             For more information please consult: {doc_url}
1676             """
1677         )
1678         raise UsageError(error_template.format(error=error))
1679 
1680     while len(parts) < 5:
1681         parts.append("")
1682     action_, message, category_, module, lineno_ = (s.strip() for s in parts)
1683     try:
1684         action: "warnings._ActionKind" = warnings._getaction(action_)  # type: ignore[attr-defined]
1685     except warnings._OptionError as e:
1686         raise UsageError(error_template.format(error=str(e)))
1687     try:
1688         category: Type[Warning] = _resolve_warning_category(category_)
1689     except Exception:
1690         exc_info = ExceptionInfo.from_current()
1691         exception_text = exc_info.getrepr(style="native")
1692         raise UsageError(error_template.format(error=exception_text))
1693     if message and escape:
1694         message = re.escape(message)
1695     if module and escape:
1696         module = re.escape(module) + r"\Z"
1697     if lineno_:
1698         try:
1699             lineno = int(lineno_)
1700             if lineno < 0:
1701                 raise ValueError("number is negative")
1702         except ValueError as e:
1703             raise UsageError(
1704                 error_template.format(error=f"invalid lineno {lineno_!r}: {e}")
1705             )
1706     else:
1707         lineno = 0
1708     return action, message, category, module, lineno
1709 
1710 
1711 def _resolve_warning_category(category: str) -> Type[Warning]:
1712     """
1713     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)
1714     propagate so we can get access to their tracebacks (#9218).
1715     """
1716     __tracebackhide__ = True
1717     if not category:
1718         return Warning
1719 
1720     if "." not in category:
1721         import builtins as m
1722 
1723         klass = category
1724     else:
1725         module, _, klass = category.rpartition(".")
1726         m = __import__(module, None, None, [klass])
1727     cat = getattr(m, klass)
1728     if not issubclass(cat, Warning):
1729         raise UsageError(f"{cat} is not a Warning subclass")
1730     return cast(Type[Warning], cat)
1731 
1732 
1733 def apply_warning_filters(
1734     config_filters: Iterable[str], cmdline_filters: Iterable[str]
1735 ) -> None:
1736     """Applies pytest-configured filters to the warnings module"""
1737     # Filters should have this precedence: cmdline options, config.
1738     # Filters should be applied in the inverse order of precedence.
1739     for arg in config_filters:
1740         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))
1741 
1742     for arg in cmdline_filters:
1743         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))

</code><intended_behavior>Since this file deals with the configuration of pytest, including the loading and registration of plugins, it's a plausible location where enhancements could be made to improve the issue at hand. Specifically, during the process where plugins are scanned for hook implementations, the system could be enhanced to record more detailed location information. When a deprecated `hookimpl` is found, the system should emit a `PytestDeprecationWarning` that includes this detailed location information, making it easier for users to identify and correct the source of the deprecation. Preserving Existing Functionality: The mechanism for loading, registering, and managing plugins and their hook implementations should remain untouched in terms of functionality. The enhancement should only extend the information provided in warnings related to deprecated hook usage.</intended_behavior>]
2025-10-15 09:34:21.647 | INFO     | Search completed. Bug locations: [<file>src/_pytest/hookspec.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Hook specifications for pytest plugins which are invoked by pytest itself
2 and by builtin plugins."""
3 from pathlib import Path
4 from typing import Any
5 from typing import Dict
6 from typing import List
7 from typing import Mapping
8 from typing import Optional
9 from typing import Sequence
10 from typing import Tuple
11 from typing import TYPE_CHECKING
12 from typing import Union
13 
14 from pluggy import HookspecMarker
15 
16 from _pytest.deprecated import WARNING_CMDLINE_PREPARSE_HOOK
17 
18 if TYPE_CHECKING:
19     import pdb
20     import warnings
21     from typing_extensions import Literal
22 
23     from _pytest._code.code import ExceptionRepr
24     from _pytest.code import ExceptionInfo
25     from _pytest.config import Config
26     from _pytest.config import ExitCode
27     from _pytest.config import PytestPluginManager
28     from _pytest.config import _PluggyPlugin
29     from _pytest.config.argparsing import Parser
30     from _pytest.fixtures import FixtureDef
31     from _pytest.fixtures import SubRequest
32     from _pytest.main import Session
33     from _pytest.nodes import Collector
34     from _pytest.nodes import Item
35     from _pytest.outcomes import Exit
36     from _pytest.python import Class
37     from _pytest.python import Function
38     from _pytest.python import Metafunc
39     from _pytest.python import Module
40     from _pytest.reports import CollectReport
41     from _pytest.reports import TestReport
42     from _pytest.runner import CallInfo
43     from _pytest.terminal import TerminalReporter
44     from _pytest.compat import LEGACY_PATH
45 
46 
47 hookspec = HookspecMarker("pytest")
48 
49 # -------------------------------------------------------------------------
50 # Initialization hooks called for every plugin
51 # -------------------------------------------------------------------------
52 
53 
54 @hookspec(historic=True)
55 def pytest_addhooks(pluginmanager: "PytestPluginManager") -> None:
56     """Called at plugin registration time to allow adding new hooks via a call to
57     ``pluginmanager.add_hookspecs(module_or_class, prefix)``.
58 
59     :param pytest.PytestPluginManager pluginmanager: The pytest plugin manager.
60 
61     .. note::
62         This hook is incompatible with ``hookwrapper=True``.
63     """
64 
65 
66 @hookspec(historic=True)
67 def pytest_plugin_registered(
68     plugin: "_PluggyPlugin", manager: "PytestPluginManager"
69 ) -> None:
70     """A new pytest plugin got registered.
71 
72     :param plugin: The plugin module or instance.
73     :param pytest.PytestPluginManager manager: pytest plugin manager.
74 
75     .. note::
76         This hook is incompatible with ``hookwrapper=True``.
77     """
78 
79 
80 @hookspec(historic=True)
81 def pytest_addoption(parser: "Parser", pluginmanager: "PytestPluginManager") -> None:
82     """Register argparse-style options and ini-style config values,
83     called once at the beginning of a test run.
84 
85     .. note::
86 
87         This function should be implemented only in plugins or ``conftest.py``
88         files situated at the tests root directory due to how pytest
89         :ref:`discovers plugins during startup <pluginorder>`.
90 
91     :param pytest.Parser parser:
92         To add command line options, call
93         :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.
94         To add ini-file values call :py:func:`parser.addini(...)
95         <pytest.Parser.addini>`.
96 
97     :param pytest.PytestPluginManager pluginmanager:
98         The pytest plugin manager, which can be used to install :py:func:`hookspec`'s
99         or :py:func:`hookimpl`'s and allow one plugin to call another plugin's hooks
100         to change how command line options are added.
101 
102     Options can later be accessed through the
103     :py:class:`config <pytest.Config>` object, respectively:
104 
105     - :py:func:`config.getoption(name) <pytest.Config.getoption>` to
106       retrieve the value of a command line option.
107 
108     - :py:func:`config.getini(name) <pytest.Config.getini>` to retrieve
109       a value read from an ini-style file.
110 
111     The config object is passed around on many internal objects via the ``.config``
112     attribute or can be retrieved as the ``pytestconfig`` fixture.
113 
114     .. note::
115         This hook is incompatible with ``hookwrapper=True``.
116     """
117 
118 
119 @hookspec(historic=True)
120 def pytest_configure(config: "Config") -> None:
121     """Allow plugins and conftest files to perform initial configuration.
122 
123     This hook is called for every plugin and initial conftest file
124     after command line options have been parsed.
125 
126     After that, the hook is called for other conftest files as they are
127     imported.
128 
129     .. note::
130         This hook is incompatible with ``hookwrapper=True``.
131 
132     :param pytest.Config config: The pytest config object.
133     """
134 
135 
136 # -------------------------------------------------------------------------
137 # Bootstrapping hooks called for plugins registered early enough:
138 # internal and 3rd party plugins.
139 # -------------------------------------------------------------------------
140 
141 
142 @hookspec(firstresult=True)
143 def pytest_cmdline_parse(
144     pluginmanager: "PytestPluginManager", args: List[str]
145 ) -> Optional["Config"]:
146     """Return an initialized :class:`~pytest.Config`, parsing the specified args.
147 
148     Stops at first non-None result, see :ref:`firstresult`.
149 
150     .. note::
151         This hook will only be called for plugin classes passed to the
152         ``plugins`` arg when using `pytest.main`_ to perform an in-process
153         test run.
154 
155     :param pluginmanager: The pytest plugin manager.
156     :param args: List of arguments passed on the command line.
157     :returns: A pytest config object.
158     """
159 
160 
161 @hookspec(warn_on_impl=WARNING_CMDLINE_PREPARSE_HOOK)
162 def pytest_cmdline_preparse(config: "Config", args: List[str]) -> None:
163     """(**Deprecated**) modify command line arguments before option parsing.
164 
165     This hook is considered deprecated and will be removed in a future pytest version. Consider
166     using :hook:`pytest_load_initial_conftests` instead.
167 
168     .. note::
169         This hook will not be called for ``conftest.py`` files, only for setuptools plugins.
170 
171     :param config: The pytest config object.
172     :param args: Arguments passed on the command line.
173     """
174 
175 
176 @hookspec(firstresult=True)
177 def pytest_cmdline_main(config: "Config") -> Optional[Union["ExitCode", int]]:
178     """Called for performing the main command line action. The default
179     implementation will invoke the configure hooks and runtest_mainloop.
180 
181     Stops at first non-None result, see :ref:`firstresult`.
182 
183     :param config: The pytest config object.
184     :returns: The exit code.
185     """
186 
187 
188 def pytest_load_initial_conftests(
189     early_config: "Config", parser: "Parser", args: List[str]
190 ) -> None:
191     """Called to implement the loading of initial conftest files ahead
192     of command line option parsing.
193 
194     .. note::
195         This hook will not be called for ``conftest.py`` files, only for setuptools plugins.
196 
197     :param early_config: The pytest config object.
198     :param args: Arguments passed on the command line.
199     :param parser: To add command line options.
200     """
201 
202 
203 # -------------------------------------------------------------------------
204 # collection hooks
205 # -------------------------------------------------------------------------
206 
207 
208 @hookspec(firstresult=True)
209 def pytest_collection(session: "Session") -> Optional[object]:
210     """Perform the collection phase for the given session.
211 
212     Stops at first non-None result, see :ref:`firstresult`.
213     The return value is not used, but only stops further processing.
214 
215     The default collection phase is this (see individual hooks for full details):
216 
217     1. Starting from ``session`` as the initial collector:
218 
219       1. ``pytest_collectstart(collector)``
220       2. ``report = pytest_make_collect_report(collector)``
221       3. ``pytest_exception_interact(collector, call, report)`` if an interactive exception occurred
222       4. For each collected node:
223 
224         1. If an item, ``pytest_itemcollected(item)``
225         2. If a collector, recurse into it.
226 
227       5. ``pytest_collectreport(report)``
228 
229     2. ``pytest_collection_modifyitems(session, config, items)``
230 
231       1. ``pytest_deselected(items)`` for any deselected items (may be called multiple times)
232 
233     3. ``pytest_collection_finish(session)``
234     4. Set ``session.items`` to the list of collected items
235     5. Set ``session.testscollected`` to the number of collected items
236 
237     You can implement this hook to only perform some action before collection,
238     for example the terminal plugin uses it to start displaying the collection
239     counter (and returns `None`).
240 
241     :param session: The pytest session object.
242     """
243 
244 
245 def pytest_collection_modifyitems(
246     session: "Session", config: "Config", items: List["Item"]
247 ) -> None:
248     """Called after collection has been performed. May filter or re-order
249     the items in-place.
250 
251     :param session: The pytest session object.
252     :param config: The pytest config object.
253     :param items: List of item objects.
254     """
255 
256 
257 def pytest_collection_finish(session: "Session") -> None:
258     """Called after collection has been performed and modified.
259 
260     :param session: The pytest session object.
261     """
262 
263 
264 @hookspec(firstresult=True)
265 def pytest_ignore_collect(
266     collection_path: Path, path: "LEGACY_PATH", config: "Config"
267 ) -> Optional[bool]:
268     """Return True to prevent considering this path for collection.
269 
270     This hook is consulted for all files and directories prior to calling
271     more specific hooks.
272 
273     Stops at first non-None result, see :ref:`firstresult`.
274 
275     :param collection_path: The path to analyze.
276     :param path: The path to analyze (deprecated).
277     :param config: The pytest config object.
278 
279     .. versionchanged:: 7.0.0
280         The ``collection_path`` parameter was added as a :class:`pathlib.Path`
281         equivalent of the ``path`` parameter. The ``path`` parameter
282         has been deprecated.
283     """
284 
285 
286 def pytest_collect_file(
287     file_path: Path, path: "LEGACY_PATH", parent: "Collector"
288 ) -> "Optional[Collector]":
289     """Create a :class:`~pytest.Collector` for the given path, or None if not relevant.
290 
291     The new node needs to have the specified ``parent`` as a parent.
292 
293     :param file_path: The path to analyze.
294     :param path: The path to collect (deprecated).
295 
296     .. versionchanged:: 7.0.0
297         The ``file_path`` parameter was added as a :class:`pathlib.Path`
298         equivalent of the ``path`` parameter. The ``path`` parameter
299         has been deprecated.
300     """
301 
302 
303 # logging hooks for collection
304 
305 
306 def pytest_collectstart(collector: "Collector") -> None:
307     """Collector starts collecting.
308 
309     :param collector:
310         The collector.
311     """
312 
313 
314 def pytest_itemcollected(item: "Item") -> None:
315     """We just collected a test item.
316 
317     :param item:
318         The item.
319     """
320 
321 
322 def pytest_collectreport(report: "CollectReport") -> None:
323     """Collector finished collecting.
324 
325     :param report:
326         The collect report.
327     """
328 
329 
330 def pytest_deselected(items: Sequence["Item"]) -> None:
331     """Called for deselected test items, e.g. by keyword.
332 
333     May be called multiple times.
334 
335     :param items:
336         The items.
337     """
338 
339 
340 @hookspec(firstresult=True)
341 def pytest_make_collect_report(collector: "Collector") -> "Optional[CollectReport]":
342     """Perform :func:`collector.collect() <pytest.Collector.collect>` and return
343     a :class:`~pytest.CollectReport`.
344 
345     Stops at first non-None result, see :ref:`firstresult`.
346 
347     :param collector:
348         The collector.
349     """
350 
351 
352 # -------------------------------------------------------------------------
353 # Python test function related hooks
354 # -------------------------------------------------------------------------
355 
356 
357 @hookspec(firstresult=True)
358 def pytest_pycollect_makemodule(
359     module_path: Path, path: "LEGACY_PATH", parent
360 ) -> Optional["Module"]:
361     """Return a :class:`pytest.Module` collector or None for the given path.
362 
363     This hook will be called for each matching test module path.
364     The :hook:`pytest_collect_file` hook needs to be used if you want to
365     create test modules for files that do not match as a test module.
366 
367     Stops at first non-None result, see :ref:`firstresult`.
368 
369     :param module_path: The path of the module to collect.
370     :param path: The path of the module to collect (deprecated).
371 
372     .. versionchanged:: 7.0.0
373         The ``module_path`` parameter was added as a :class:`pathlib.Path`
374         equivalent of the ``path`` parameter.
375 
376         The ``path`` parameter has been deprecated in favor of ``fspath``.
377     """
378 
379 
380 @hookspec(firstresult=True)
381 def pytest_pycollect_makeitem(
382     collector: Union["Module", "Class"], name: str, obj: object
383 ) -> Union[None, "Item", "Collector", List[Union["Item", "Collector"]]]:
384     """Return a custom item/collector for a Python object in a module, or None.
385 
386     Stops at first non-None result, see :ref:`firstresult`.
387 
388     :param collector:
389         The module/class collector.
390     :param name:
391         The name of the object in the module/class.
392     :param obj:
393         The object.
394     :returns:
395         The created items/collectors.
396     """
397 
398 
399 @hookspec(firstresult=True)
400 def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
401     """Call underlying test function.
402 
403     Stops at first non-None result, see :ref:`firstresult`.
404 
405     :param pyfuncitem:
406         The function item.
407     """
408 
409 
410 def pytest_generate_tests(metafunc: "Metafunc") -> None:
411     """Generate (multiple) parametrized calls to a test function.
412 
413     :param metafunc:
414         The :class:`~pytest.Metafunc` helper for the test function.
415     """
416 
417 
418 @hookspec(firstresult=True)
419 def pytest_make_parametrize_id(
420     config: "Config", val: object, argname: str
421 ) -> Optional[str]:
422     """Return a user-friendly string representation of the given ``val``
423     that will be used by @pytest.mark.parametrize calls, or None if the hook
424     doesn't know about ``val``.
425 
426     The parameter name is available as ``argname``, if required.
427 
428     Stops at first non-None result, see :ref:`firstresult`.
429 
430     :param config: The pytest config object.
431     :param val: The parametrized value.
432     :param str argname: The automatic parameter name produced by pytest.
433     """
434 
435 
436 # -------------------------------------------------------------------------
437 # runtest related hooks
438 # -------------------------------------------------------------------------
439 
440 
441 @hookspec(firstresult=True)
442 def pytest_runtestloop(session: "Session") -> Optional[object]:
443     """Perform the main runtest loop (after collection finished).
444 
445     The default hook implementation performs the runtest protocol for all items
446     collected in the session (``session.items``), unless the collection failed
447     or the ``collectonly`` pytest option is set.
448 
449     If at any point :py:func:`pytest.exit` is called, the loop is
450     terminated immediately.
451 
452     If at any point ``session.shouldfail`` or ``session.shouldstop`` are set, the
453     loop is terminated after the runtest protocol for the current item is finished.
454 
455     :param session: The pytest session object.
456 
457     Stops at first non-None result, see :ref:`firstresult`.
458     The return value is not used, but only stops further processing.
459     """
460 
461 
462 @hookspec(firstresult=True)
463 def pytest_runtest_protocol(
464     item: "Item", nextitem: "Optional[Item]"
465 ) -> Optional[object]:
466     """Perform the runtest protocol for a single test item.
467 
468     The default runtest protocol is this (see individual hooks for full details):
469 
470     - ``pytest_runtest_logstart(nodeid, location)``
471 
472     - Setup phase:
473         - ``call = pytest_runtest_setup(item)`` (wrapped in ``CallInfo(when="setup")``)
474         - ``report = pytest_runtest_makereport(item, call)``
475         - ``pytest_runtest_logreport(report)``
476         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred
477 
478     - Call phase, if the the setup passed and the ``setuponly`` pytest option is not set:
479         - ``call = pytest_runtest_call(item)`` (wrapped in ``CallInfo(when="call")``)
480         - ``report = pytest_runtest_makereport(item, call)``
481         - ``pytest_runtest_logreport(report)``
482         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred
483 
484     - Teardown phase:
485         - ``call = pytest_runtest_teardown(item, nextitem)`` (wrapped in ``CallInfo(when="teardown")``)
486         - ``report = pytest_runtest_makereport(item, call)``
487         - ``pytest_runtest_logreport(report)``
488         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred
489 
490     - ``pytest_runtest_logfinish(nodeid, location)``
491 
492     :param item: Test item for which the runtest protocol is performed.
493     :param nextitem: The scheduled-to-be-next test item (or None if this is the end my friend).
494 
495     Stops at first non-None result, see :ref:`firstresult`.
496     The return value is not used, but only stops further processing.
497     """
498 
499 
500 def pytest_runtest_logstart(
501     nodeid: str, location: Tuple[str, Optional[int], str]
502 ) -> None:
503     """Called at the start of running the runtest protocol for a single item.
504 
505     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
506 
507     :param nodeid: Full node ID of the item.
508     :param location: A tuple of ``(filename, lineno, testname)``.
509     """
510 
511 
512 def pytest_runtest_logfinish(
513     nodeid: str, location: Tuple[str, Optional[int], str]
514 ) -> None:
515     """Called at the end of running the runtest protocol for a single item.
516 
517     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
518 
519     :param nodeid: Full node ID of the item.
520     :param location: A tuple of ``(filename, lineno, testname)``.
521     """
522 
523 
524 def pytest_runtest_setup(item: "Item") -> None:
525     """Called to perform the setup phase for a test item.
526 
527     The default implementation runs ``setup()`` on ``item`` and all of its
528     parents (which haven't been setup yet). This includes obtaining the
529     values of fixtures required by the item (which haven't been obtained
530     yet).
531 
532     :param item:
533         The item.
534     """
535 
536 
537 def pytest_runtest_call(item: "Item") -> None:
538     """Called to run the test for test item (the call phase).
539 
540     The default implementation calls ``item.runtest()``.
541 
542     :param item:
543         The item.
544     """
545 
546 
547 def pytest_runtest_teardown(item: "Item", nextitem: Optional["Item"]) -> None:
548     """Called to perform the teardown phase for a test item.
549 
550     The default implementation runs the finalizers and calls ``teardown()``
551     on ``item`` and all of its parents (which need to be torn down). This
552     includes running the teardown phase of fixtures required by the item (if
553     they go out of scope).
554 
555     :param item:
556         The item.
557     :param nextitem:
558         The scheduled-to-be-next test item (None if no further test item is
559         scheduled). This argument is used to perform exact teardowns, i.e.
560         calling just enough finalizers so that nextitem only needs to call
561         setup functions.
562     """
563 
564 
565 @hookspec(firstresult=True)
566 def pytest_runtest_makereport(
567     item: "Item", call: "CallInfo[None]"
568 ) -> Optional["TestReport"]:
569     """Called to create a :class:`~pytest.TestReport` for each of
570     the setup, call and teardown runtest phases of a test item.
571 
572     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
573 
574     :param item: The item.
575     :param call: The :class:`~pytest.CallInfo` for the phase.
576 
577     Stops at first non-None result, see :ref:`firstresult`.
578     """
579 
580 
581 def pytest_runtest_logreport(report: "TestReport") -> None:
582     """Process the :class:`~pytest.TestReport` produced for each
583     of the setup, call and teardown runtest phases of an item.
584 
585     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.
586     """
587 
588 
589 @hookspec(firstresult=True)
590 def pytest_report_to_serializable(
591     config: "Config",
592     report: Union["CollectReport", "TestReport"],
593 ) -> Optional[Dict[str, Any]]:
594     """Serialize the given report object into a data structure suitable for
595     sending over the wire, e.g. converted to JSON.
596 
597     :param config: The pytest config object.
598     :param report: The report.
599     """
600 
601 
602 @hookspec(firstresult=True)
603 def pytest_report_from_serializable(
604     config: "Config",
605     data: Dict[str, Any],
606 ) -> Optional[Union["CollectReport", "TestReport"]]:
607     """Restore a report object previously serialized with
608     :hook:`pytest_report_to_serializable`.
609 
610     :param config: The pytest config object.
611     """
612 
613 
614 # -------------------------------------------------------------------------
615 # Fixture related hooks
616 # -------------------------------------------------------------------------
617 
618 
619 @hookspec(firstresult=True)
620 def pytest_fixture_setup(
621     fixturedef: "FixtureDef[Any]", request: "SubRequest"
622 ) -> Optional[object]:
623     """Perform fixture setup execution.
624 
625     :param fixturdef:
626         The fixture definition object.
627     :param request:
628         The fixture request object.
629     :returns:
630         The return value of the call to the fixture function.
631 
632     Stops at first non-None result, see :ref:`firstresult`.
633 
634     .. note::
635         If the fixture function returns None, other implementations of
636         this hook function will continue to be called, according to the
637         behavior of the :ref:`firstresult` option.
638     """
639 
640 
641 def pytest_fixture_post_finalizer(
642     fixturedef: "FixtureDef[Any]", request: "SubRequest"
643 ) -> None:
644     """Called after fixture teardown, but before the cache is cleared, so
645     the fixture result ``fixturedef.cached_result`` is still available (not
646     ``None``).
647 
648     :param fixturdef:
649         The fixture definition object.
650     :param request:
651         The fixture request object.
652     """
653 
654 
655 # -------------------------------------------------------------------------
656 # test session related hooks
657 # -------------------------------------------------------------------------
658 
659 
660 def pytest_sessionstart(session: "Session") -> None:
661     """Called after the ``Session`` object has been created and before performing collection
662     and entering the run test loop.
663 
664     :param session: The pytest session object.
665     """
666 
667 
668 def pytest_sessionfinish(
669     session: "Session",
670     exitstatus: Union[int, "ExitCode"],
671 ) -> None:
672     """Called after whole test run finished, right before returning the exit status to the system.
673 
674     :param session: The pytest session object.
675     :param exitstatus: The status which pytest will return to the system.
676     """
677 
678 
679 def pytest_unconfigure(config: "Config") -> None:
680     """Called before test process is exited.
681 
682     :param config: The pytest config object.
683     """
684 
685 
686 # -------------------------------------------------------------------------
687 # hooks for customizing the assert methods
688 # -------------------------------------------------------------------------
689 
690 
691 def pytest_assertrepr_compare(
692     config: "Config", op: str, left: object, right: object
693 ) -> Optional[List[str]]:
694     """Return explanation for comparisons in failing assert expressions.
695 
696     Return None for no custom explanation, otherwise return a list
697     of strings. The strings will be joined by newlines but any newlines
698     *in* a string will be escaped. Note that all but the first line will
699     be indented slightly, the intention is for the first line to be a summary.
700 
701     :param config: The pytest config object.
702     :param op: The operator, e.g. `"=="`, `"!="`, `"not in"`.
703     :param left: The left operand.
704     :param right: The right operand.
705     """
706 
707 
708 def pytest_assertion_pass(item: "Item", lineno: int, orig: str, expl: str) -> None:
709     """Called whenever an assertion passes.
710 
711     .. versionadded:: 5.0
712 
713     Use this hook to do some processing after a passing assertion.
714     The original assertion information is available in the `orig` string
715     and the pytest introspected assertion information is available in the
716     `expl` string.
717 
718     This hook must be explicitly enabled by the ``enable_assertion_pass_hook``
719     ini-file option:
720 
721     .. code-block:: ini
722 
723         [pytest]
724         enable_assertion_pass_hook=true
725 
726     You need to **clean the .pyc** files in your project directory and interpreter libraries
727     when enabling this option, as assertions will require to be re-written.
728 
729     :param item: pytest item object of current test.
730     :param lineno: Line number of the assert statement.
731     :param orig: String with the original assertion.
732     :param expl: String with the assert explanation.
733     """
734 
735 
736 # -------------------------------------------------------------------------
737 # Hooks for influencing reporting (invoked from _pytest_terminal).
738 # -------------------------------------------------------------------------
739 
740 
741 def pytest_report_header(
742     config: "Config", start_path: Path, startdir: "LEGACY_PATH"
743 ) -> Union[str, List[str]]:
744     """Return a string or list of strings to be displayed as header info for terminal reporting.
745 
746     :param config: The pytest config object.
747     :param start_path: The starting dir.
748     :param startdir: The starting dir (deprecated).
749 
750     .. note::
751 
752         Lines returned by a plugin are displayed before those of plugins which
753         ran before it.
754         If you want to have your line(s) displayed first, use
755         :ref:`trylast=True <plugin-hookorder>`.
756 
757     .. note::
758 
759         This function should be implemented only in plugins or ``conftest.py``
760         files situated at the tests root directory due to how pytest
761         :ref:`discovers plugins during startup <pluginorder>`.
762 
763     .. versionchanged:: 7.0.0
764         The ``start_path`` parameter was added as a :class:`pathlib.Path`
765         equivalent of the ``startdir`` parameter. The ``startdir`` parameter
766         has been deprecated.
767     """
768 
769 
770 def pytest_report_collectionfinish(
771     config: "Config",
772     start_path: Path,
773     startdir: "LEGACY_PATH",
774     items: Sequence["Item"],
775 ) -> Union[str, List[str]]:
776     """Return a string or list of strings to be displayed after collection
777     has finished successfully.
778 
779     These strings will be displayed after the standard "collected X items" message.
780 
781     .. versionadded:: 3.2
782 
783     :param config: The pytest config object.
784     :param start_path: The starting dir.
785     :param startdir: The starting dir (deprecated).
786     :param items: List of pytest items that are going to be executed; this list should not be modified.
787 
788     .. note::
789 
790         Lines returned by a plugin are displayed before those of plugins which
791         ran before it.
792         If you want to have your line(s) displayed first, use
793         :ref:`trylast=True <plugin-hookorder>`.
794 
795     .. versionchanged:: 7.0.0
796         The ``start_path`` parameter was added as a :class:`pathlib.Path`
797         equivalent of the ``startdir`` parameter. The ``startdir`` parameter
798         has been deprecated.
799     """
800 
801 
802 @hookspec(firstresult=True)
803 def pytest_report_teststatus(
804     report: Union["CollectReport", "TestReport"], config: "Config"
805 ) -> Tuple[str, str, Union[str, Mapping[str, bool]]]:
806     """Return result-category, shortletter and verbose word for status
807     reporting.
808 
809     The result-category is a category in which to count the result, for
810     example "passed", "skipped", "error" or the empty string.
811 
812     The shortletter is shown as testing progresses, for example ".", "s",
813     "E" or the empty string.
814 
815     The verbose word is shown as testing progresses in verbose mode, for
816     example "PASSED", "SKIPPED", "ERROR" or the empty string.
817 
818     pytest may style these implicitly according to the report outcome.
819     To provide explicit styling, return a tuple for the verbose word,
820     for example ``"rerun", "R", ("RERUN", {"yellow": True})``.
821 
822     :param report: The report object whose status is to be returned.
823     :param config: The pytest config object.
824     :returns: The test status.
825 
826     Stops at first non-None result, see :ref:`firstresult`.
827     """
828 
829 
830 def pytest_terminal_summary(
831     terminalreporter: "TerminalReporter",
832     exitstatus: "ExitCode",
833     config: "Config",
834 ) -> None:
835     """Add a section to terminal summary reporting.
836 
837     :param terminalreporter: The internal terminal reporter object.
838     :param exitstatus: The exit status that will be reported back to the OS.
839     :param config: The pytest config object.
840 
841     .. versionadded:: 4.2
842         The ``config`` parameter.
843     """
844 
845 
846 @hookspec(historic=True)
847 def pytest_warning_recorded(
848     warning_message: "warnings.WarningMessage",
849     when: "Literal['config', 'collect', 'runtest']",
850     nodeid: str,
851     location: Optional[Tuple[str, int, str]],
852 ) -> None:
853     """Process a warning captured by the internal pytest warnings plugin.
854 
855     :param warning_message:
856         The captured warning. This is the same object produced by :py:func:`warnings.catch_warnings`, and contains
857         the same attributes as the parameters of :py:func:`warnings.showwarning`.
858 
859     :param when:
860         Indicates when the warning was captured. Possible values:
861 
862         * ``"config"``: during pytest configuration/initialization stage.
863         * ``"collect"``: during test collection.
864         * ``"runtest"``: during test execution.
865 
866     :param nodeid:
867         Full id of the item.
868 
869     :param location:
870         When available, holds information about the execution context of the captured
871         warning (filename, linenumber, function). ``function`` evaluates to <module>
872         when the execution context is at the module level.
873 
874     .. versionadded:: 6.0
875     """
876 
877 
878 # -------------------------------------------------------------------------
879 # Hooks for influencing skipping
880 # -------------------------------------------------------------------------
881 
882 
883 def pytest_markeval_namespace(config: "Config") -> Dict[str, Any]:
884     """Called when constructing the globals dictionary used for
885     evaluating string conditions in xfail/skipif markers.
886 
887     This is useful when the condition for a marker requires
888     objects that are expensive or impossible to obtain during
889     collection time, which is required by normal boolean
890     conditions.
891 
892     .. versionadded:: 6.2
893 
894     :param config: The pytest config object.
895     :returns: A dictionary of additional globals to add.
896     """
897 
898 
899 # -------------------------------------------------------------------------
900 # error handling and internal debugging hooks
901 # -------------------------------------------------------------------------
902 
903 
904 def pytest_internalerror(
905     excrepr: "ExceptionRepr",
906     excinfo: "ExceptionInfo[BaseException]",
907 ) -> Optional[bool]:
908     """Called for internal errors.
909 
910     Return True to suppress the fallback handling of printing an
911     INTERNALERROR message directly to sys.stderr.
912 
913     :param excrepr: The exception repr object.
914     :param excinfo: The exception info.
915     """
916 
917 
918 def pytest_keyboard_interrupt(
919     excinfo: "ExceptionInfo[Union[KeyboardInterrupt, Exit]]",
920 ) -> None:
921     """Called for keyboard interrupt.
922 
923     :param excinfo: The exception info.
924     """
925 
926 
927 def pytest_exception_interact(
928     node: Union["Item", "Collector"],
929     call: "CallInfo[Any]",
930     report: Union["CollectReport", "TestReport"],
931 ) -> None:
932     """Called when an exception was raised which can potentially be
933     interactively handled.
934 
935     May be called during collection (see :hook:`pytest_make_collect_report`),
936     in which case ``report`` is a :class:`CollectReport`.
937 
938     May be called during runtest of an item (see :hook:`pytest_runtest_protocol`),
939     in which case ``report`` is a :class:`TestReport`.
940 
941     This hook is not called if the exception that was raised is an internal
942     exception like ``skip.Exception``.
943 
944     :param node:
945         The item or collector.
946     :param call:
947         The call information. Contains the exception.
948     :param report:
949         The collection or test report.
950     """
951 
952 
953 def pytest_enter_pdb(config: "Config", pdb: "pdb.Pdb") -> None:
954     """Called upon pdb.set_trace().
955 
956     Can be used by plugins to take special action just before the python
957     debugger enters interactive mode.
958 
959     :param config: The pytest config object.
960     :param pdb: The Pdb instance.
961     """
962 
963 
964 def pytest_leave_pdb(config: "Config", pdb: "pdb.Pdb") -> None:
965     """Called when leaving pdb (e.g. with continue after pdb.set_trace()).
966 
967     Can be used by plugins to take special action just after the python
968     debugger leaves interactive mode.
969 
970     :param config: The pytest config object.
971     :param pdb: The Pdb instance.
972     """

</code><intended_behavior>This file likely defines the `pytest_configure` hookspec or related mechanisms. To resolve the issue, the code that triggers the `PytestDeprecationWarning` for old-style `hookimpl` usage within this file (or within the system that processes these hookspecs) should be enhanced. It should not only check for and warn about deprecated usage but also include information about the source of the deprecation (i.e., the plugin or file defining the deprecated hook). This enhancement might involve capturing the `__file__` attribute of the function or module when the `hookimpl` is registered and including that information in the warning message. Preserving Existing Functionality: The update should maintain all existing functionality surrounding hook registration and warning issuance. The primary change is to augment the warning message with location information, without affecting the registration or execution of hooks themselves.</intended_behavior>, <file>src/_pytest/config/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Command line options, ini-file and conftest.py processing."""
2 import argparse
3 import collections.abc
4 import copy
5 import enum
6 import glob
7 import inspect
8 import os
9 import re
10 import shlex
11 import sys
12 import types
13 import warnings
14 from functools import lru_cache
15 from pathlib import Path
16 from textwrap import dedent
17 from types import FunctionType
18 from types import TracebackType
19 from typing import Any
20 from typing import Callable
21 from typing import cast
22 from typing import Dict
23 from typing import Generator
24 from typing import IO
25 from typing import Iterable
26 from typing import Iterator
27 from typing import List
28 from typing import Optional
29 from typing import Sequence
30 from typing import Set
31 from typing import TextIO
32 from typing import Tuple
33 from typing import Type
34 from typing import TYPE_CHECKING
35 from typing import Union
36 
37 import attr
38 from pluggy import HookimplMarker
39 from pluggy import HookspecMarker
40 from pluggy import PluginManager
41 
42 import _pytest._code
43 import _pytest.deprecated
44 import _pytest.hookspec
45 from .exceptions import PrintHelp as PrintHelp
46 from .exceptions import UsageError as UsageError
47 from .findpaths import determine_setup
48 from _pytest._code import ExceptionInfo
49 from _pytest._code import filter_traceback
50 from _pytest._io import TerminalWriter
51 from _pytest.compat import final
52 from _pytest.compat import importlib_metadata
53 from _pytest.outcomes import fail
54 from _pytest.outcomes import Skipped
55 from _pytest.pathlib import absolutepath
56 from _pytest.pathlib import bestrelpath
57 from _pytest.pathlib import import_path
58 from _pytest.pathlib import ImportMode
59 from _pytest.pathlib import resolve_package_path
60 from _pytest.stash import Stash
61 from _pytest.warning_types import PytestConfigWarning
62 from _pytest.warning_types import warn_explicit_for
63 
64 if TYPE_CHECKING:
65 
66     from _pytest._code.code import _TracebackStyle
67     from _pytest.terminal import TerminalReporter
68     from .argparsing import Argument
69 
70 
71 _PluggyPlugin = object
72 """A type to represent plugin objects.
73 
74 Plugins can be any namespace, so we can't narrow it down much, but we use an
75 alias to make the intent clear.
76 
77 Ideally this type would be provided by pluggy itself.
78 """
79 
80 
81 hookimpl = HookimplMarker("pytest")
82 hookspec = HookspecMarker("pytest")
83 
84 
85 @final
86 class ExitCode(enum.IntEnum):
87     """Encodes the valid exit codes by pytest.
88 
89     Currently users and plugins may supply other exit codes as well.
90 
91     .. versionadded:: 5.0
92     """
93 
94     #: Tests passed.
95     OK = 0
96     #: Tests failed.
97     TESTS_FAILED = 1
98     #: pytest was interrupted.
99     INTERRUPTED = 2
100     #: An internal error got in the way.
101     INTERNAL_ERROR = 3
102     #: pytest was misused.
103     USAGE_ERROR = 4
104     #: pytest couldn't find tests.
105     NO_TESTS_COLLECTED = 5
106 
107 
108 class ConftestImportFailure(Exception):
109     def __init__(
110         self,
111         path: Path,
112         excinfo: Tuple[Type[Exception], Exception, TracebackType],
113     ) -> None:
114         super().__init__(path, excinfo)
115         self.path = path
116         self.excinfo = excinfo
117 
118     def __str__(self) -> str:
119         return "{}: {} (from {})".format(
120             self.excinfo[0].__name__, self.excinfo[1], self.path
121         )
122 
123 
124 def filter_traceback_for_conftest_import_failure(
125     entry: _pytest._code.TracebackEntry,
126 ) -> bool:
127     """Filter tracebacks entries which point to pytest internals or importlib.
128 
129     Make a special case for importlib because we use it to import test modules and conftest files
130     in _pytest.pathlib.import_path.
131     """
132     return filter_traceback(entry) and "importlib" not in str(entry.path).split(os.sep)
133 
134 
135 def main(
136     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
137     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
138 ) -> Union[int, ExitCode]:
139     """Perform an in-process test run.
140 
141     :param args: List of command line arguments.
142     :param plugins: List of plugin objects to be auto-registered during initialization.
143 
144     :returns: An exit code.
145     """
146     try:
147         try:
148             config = _prepareconfig(args, plugins)
149         except ConftestImportFailure as e:
150             exc_info = ExceptionInfo.from_exc_info(e.excinfo)
151             tw = TerminalWriter(sys.stderr)
152             tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
153             exc_info.traceback = exc_info.traceback.filter(
154                 filter_traceback_for_conftest_import_failure
155             )
156             exc_repr = (
157                 exc_info.getrepr(style="short", chain=False)
158                 if exc_info.traceback
159                 else exc_info.exconly()
160             )
161             formatted_tb = str(exc_repr)
162             for line in formatted_tb.splitlines():
163                 tw.line(line.rstrip(), red=True)
164             return ExitCode.USAGE_ERROR
165         else:
166             try:
167                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
168                     config=config
169                 )
170                 try:
171                     return ExitCode(ret)
172                 except ValueError:
173                     return ret
174             finally:
175                 config._ensure_unconfigure()
176     except UsageError as e:
177         tw = TerminalWriter(sys.stderr)
178         for msg in e.args:
179             tw.line(f"ERROR: {msg}\n", red=True)
180         return ExitCode.USAGE_ERROR
181 
182 
183 def console_main() -> int:
184     """The CLI entry point of pytest.
185 
186     This function is not meant for programmable use; use `main()` instead.
187     """
188     # https://docs.python.org/3/library/signal.html#note-on-sigpipe
189     try:
190         code = main()
191         sys.stdout.flush()
192         return code
193     except BrokenPipeError:
194         # Python flushes standard streams on exit; redirect remaining output
195         # to devnull to avoid another BrokenPipeError at shutdown
196         devnull = os.open(os.devnull, os.O_WRONLY)
197         os.dup2(devnull, sys.stdout.fileno())
198         return 1  # Python exits with error code 1 on EPIPE
199 
200 
201 class cmdline:  # compatibility namespace
202     main = staticmethod(main)
203 
204 
205 def filename_arg(path: str, optname: str) -> str:
206     """Argparse type validator for filename arguments.
207 
208     :path: Path of filename.
209     :optname: Name of the option.
210     """
211     if os.path.isdir(path):
212         raise UsageError(f"{optname} must be a filename, given: {path}")
213     return path
214 
215 
216 def directory_arg(path: str, optname: str) -> str:
217     """Argparse type validator for directory arguments.
218 
219     :path: Path of directory.
220     :optname: Name of the option.
221     """
222     if not os.path.isdir(path):
223         raise UsageError(f"{optname} must be a directory, given: {path}")
224     return path
225 
226 
227 # Plugins that cannot be disabled via "-p no:X" currently.
228 essential_plugins = (
229     "mark",
230     "main",
231     "runner",
232     "fixtures",
233     "helpconfig",  # Provides -p.
234 )
235 
236 default_plugins = essential_plugins + (
237     "python",
238     "terminal",
239     "debugging",
240     "unittest",
241     "capture",
242     "skipping",
243     "legacypath",
244     "tmpdir",
245     "monkeypatch",
246     "recwarn",
247     "pastebin",
248     "nose",
249     "assertion",
250     "junitxml",
251     "doctest",
252     "cacheprovider",
253     "freeze_support",
254     "setuponly",
255     "setupplan",
256     "stepwise",
257     "warnings",
258     "logging",
259     "reports",
260     "python_path",
261     *(["unraisableexception", "threadexception"] if sys.version_info >= (3, 8) else []),
262     "faulthandler",
263 )
264 
265 builtin_plugins = set(default_plugins)
266 builtin_plugins.add("pytester")
267 builtin_plugins.add("pytester_assertions")
268 
269 
270 def get_config(
271     args: Optional[List[str]] = None,
272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
273 ) -> "Config":
274     # subsequent calls to main will create a fresh instance
275     pluginmanager = PytestPluginManager()
276     config = Config(
277         pluginmanager,
278         invocation_params=Config.InvocationParams(
279             args=args or (),
280             plugins=plugins,
281             dir=Path.cwd(),
282         ),
283     )
284 
285     if args is not None:
286         # Handle any "-p no:plugin" args.
287         pluginmanager.consider_preparse(args, exclude_only=True)
288 
289     for spec in default_plugins:
290         pluginmanager.import_plugin(spec)
291 
292     return config
293 
294 
295 def get_plugin_manager() -> "PytestPluginManager":
296     """Obtain a new instance of the
297     :py:class:`pytest.PytestPluginManager`, with default plugins
298     already loaded.
299 
300     This function can be used by integration with other tools, like hooking
301     into pytest to run tests into an IDE.
302     """
303     return get_config().pluginmanager
304 
305 
306 def _prepareconfig(
307     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
309 ) -> "Config":
310     if args is None:
311         args = sys.argv[1:]
312     elif isinstance(args, os.PathLike):
313         args = [os.fspath(args)]
314     elif not isinstance(args, list):
315         msg = (  # type:ignore[unreachable]
316             "`args` parameter expected to be a list of strings, got: {!r} (type: {})"
317         )
318         raise TypeError(msg.format(args, type(args)))
319 
320     config = get_config(args, plugins)
321     pluginmanager = config.pluginmanager
322     try:
323         if plugins:
324             for plugin in plugins:
325                 if isinstance(plugin, str):
326                     pluginmanager.consider_pluginarg(plugin)
327                 else:
328                     pluginmanager.register(plugin)
329         config = pluginmanager.hook.pytest_cmdline_parse(
330             pluginmanager=pluginmanager, args=args
331         )
332         return config
333     except BaseException:
334         config._ensure_unconfigure()
335         raise
336 
337 
338 def _get_directory(path: Path) -> Path:
339     """Get the directory of a path - itself if already a directory."""
340     if path.is_file():
341         return path.parent
342     else:
343         return path
344 
345 
346 def _get_legacy_hook_marks(
347     method: Any,
348     hook_type: str,
349     opt_names: Tuple[str, ...],
350 ) -> Dict[str, bool]:
351     if TYPE_CHECKING:
352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias
353         assert inspect.isroutine(method)
354     known_marks: set[str] = {m.name for m in getattr(method, "pytestmark", [])}
355     must_warn: list[str] = []
356     opts: dict[str, bool] = {}
357     for opt_name in opt_names:
358         opt_attr = getattr(method, opt_name, AttributeError)
359         if opt_attr is not AttributeError:
360             must_warn.append(f"{opt_name}={opt_attr}")
361             opts[opt_name] = True
362         elif opt_name in known_marks:
363             must_warn.append(f"{opt_name}=True")
364             opts[opt_name] = True
365         else:
366             opts[opt_name] = False
367     if must_warn:
368         hook_opts = ", ".join(must_warn)
369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(
370             type=hook_type,
371             fullname=method.__qualname__,
372             hook_opts=hook_opts,
373         )
374         warn_explicit_for(cast(FunctionType, method), message)
375     return opts
376 
377 
378 @final
379 class PytestPluginManager(PluginManager):
380     """A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with
381     additional pytest-specific functionality:
382 
383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and
384       ``pytest_plugins`` global variables found in plugins being loaded.
385     * ``conftest.py`` loading during start-up.
386     """
387 
388     def __init__(self) -> None:
389         import _pytest.assertion
390 
391         super().__init__("pytest")
392 
393         # -- State related to local conftest plugins.
394         # All loaded conftest modules.
395         self._conftest_plugins: Set[types.ModuleType] = set()
396         # All conftest modules applicable for a directory.
397         # This includes the directory's own conftest modules as well
398         # as those of its parent directories.
399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}
400         # Cutoff directory above which conftests are no longer discovered.
401         self._confcutdir: Optional[Path] = None
402         # If set, conftest loading is skipped.
403         self._noconftest = False
404 
405         # _getconftestmodules()'s call to _get_directory() causes a stat
406         # storm when it's called potentially thousands of times in a test
407         # session (#9478), often with the same path, so cache it.
408         self._get_directory = lru_cache(256)(_get_directory)
409 
410         self._duplicatepaths: Set[Path] = set()
411 
412         # plugins that were explicitly skipped with pytest.skip
413         # list of (module name, skip reason)
414         # previously we would issue a warning when a plugin was skipped, but
415         # since we refactored warnings as first citizens of Config, they are
416         # just stored here to be used later.
417         self.skipped_plugins: List[Tuple[str, str]] = []
418 
419         self.add_hookspecs(_pytest.hookspec)
420         self.register(self)
421         if os.environ.get("PYTEST_DEBUG"):
422             err: IO[str] = sys.stderr
423             encoding: str = getattr(err, "encoding", "utf8")
424             try:
425                 err = open(
426                     os.dup(err.fileno()),
427                     mode=err.mode,
428                     buffering=1,
429                     encoding=encoding,
430                 )
431             except Exception:
432                 pass
433             self.trace.root.setwriter(err.write)
434             self.enable_tracing()
435 
436         # Config._consider_importhook will set a real object if required.
437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()
438         # Used to know when we are importing conftests after the pytest_configure stage.
439         self._configured = False
440 
441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):
442         # pytest hooks are always prefixed with "pytest_",
443         # so we avoid accessing possibly non-readable attributes
444         # (see issue #1073).
445         if not name.startswith("pytest_"):
446             return
447         # Ignore names which can not be hooks.
448         if name == "pytest_plugins":
449             return
450 
451         opts = super().parse_hookimpl_opts(plugin, name)
452         if opts is not None:
453             return opts
454 
455         method = getattr(plugin, name)
456         # Consider only actual functions for hooks (#3775).
457         if not inspect.isroutine(method):
458             return
459         # Collect unmarked hooks as long as they have the `pytest_' prefix.
460         return _get_legacy_hook_marks(
461             method, "impl", ("tryfirst", "trylast", "optionalhook", "hookwrapper")
462         )
463 
464     def parse_hookspec_opts(self, module_or_class, name: str):
465         opts = super().parse_hookspec_opts(module_or_class, name)
466         if opts is None:
467             method = getattr(module_or_class, name)
468             if name.startswith("pytest_"):
469                 opts = _get_legacy_hook_marks(
470                     method,
471                     "spec",
472                     ("firstresult", "historic"),
473                 )
474         return opts
475 
476     def register(
477         self, plugin: _PluggyPlugin, name: Optional[str] = None
478     ) -> Optional[str]:
479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
480             warnings.warn(
481                 PytestConfigWarning(
482                     "{} plugin has been merged into the core, "
483                     "please remove it from your requirements.".format(
484                         name.replace("_", "-")
485                     )
486                 )
487             )
488             return None
489         ret: Optional[str] = super().register(plugin, name)
490         if ret:
491             self.hook.pytest_plugin_registered.call_historic(
492                 kwargs=dict(plugin=plugin, manager=self)
493             )
494 
495             if isinstance(plugin, types.ModuleType):
496                 self.consider_module(plugin)
497         return ret
498 
499     def getplugin(self, name: str):
500         # Support deprecated naming because plugins (xdist e.g.) use it.
501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)
502         return plugin
503 
504     def hasplugin(self, name: str) -> bool:
505         """Return whether a plugin with the given name is registered."""
506         return bool(self.get_plugin(name))
507 
508     def pytest_configure(self, config: "Config") -> None:
509         """:meta private:"""
510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)
511         # we should remove tryfirst/trylast as markers.
512         config.addinivalue_line(
513             "markers",
514             "tryfirst: mark a hook implementation function such that the "
515             "plugin machinery will try to call it first/as early as possible.",
516         )
517         config.addinivalue_line(
518             "markers",
519             "trylast: mark a hook implementation function such that the "
520             "plugin machinery will try to call it last/as late as possible.",
521         )
522         self._configured = True
523 
524     #
525     # Internal API for local conftest plugin handling.
526     #
527     def _set_initial_conftests(
528         self, namespace: argparse.Namespace, rootpath: Path
529     ) -> None:
530         """Load initial conftest files given a preparsed "namespace".
531 
532         As conftest files may add their own command line options which have
533         arguments ('--my-opt somepath') we might get some false positives.
534         All builtin and 3rd party plugins will have been loaded, however, so
535         common options will not confuse our logic here.
536         """
537         current = Path.cwd()
538         self._confcutdir = (
539             absolutepath(current / namespace.confcutdir)
540             if namespace.confcutdir
541             else None
542         )
543         self._noconftest = namespace.noconftest
544         self._using_pyargs = namespace.pyargs
545         testpaths = namespace.file_or_dir
546         foundanchor = False
547         for testpath in testpaths:
548             path = str(testpath)
549             # remove node-id syntax
550             i = path.find("::")
551             if i != -1:
552                 path = path[:i]
553             anchor = absolutepath(current / path)
554             if anchor.exists():  # we found some file object
555                 self._try_load_conftest(anchor, namespace.importmode, rootpath)
556                 foundanchor = True
557         if not foundanchor:
558             self._try_load_conftest(current, namespace.importmode, rootpath)
559 
560     def _is_in_confcutdir(self, path: Path) -> bool:
561         """Whether a path is within the confcutdir.
562 
563         When false, should not load conftest.
564         """
565         if self._confcutdir is None:
566             return True
567         return path not in self._confcutdir.parents
568 
569     def _try_load_conftest(
570         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path
571     ) -> None:
572         self._getconftestmodules(anchor, importmode, rootpath)
573         # let's also consider test* subdirs
574         if anchor.is_dir():
575             for x in anchor.glob("test*"):
576                 if x.is_dir():
577                     self._getconftestmodules(x, importmode, rootpath)
578 
579     def _getconftestmodules(
580         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path
581     ) -> Sequence[types.ModuleType]:
582         if self._noconftest:
583             return []
584 
585         directory = self._get_directory(path)
586 
587         # Optimization: avoid repeated searches in the same directory.
588         # Assumes always called with same importmode and rootpath.
589         existing_clist = self._dirpath2confmods.get(directory)
590         if existing_clist is not None:
591             return existing_clist
592 
593         # XXX these days we may rather want to use config.rootpath
594         # and allow users to opt into looking into the rootdir parent
595         # directories instead of requiring to specify confcutdir.
596         clist = []
597         for parent in reversed((directory, *directory.parents)):
598             if self._is_in_confcutdir(parent):
599                 conftestpath = parent / "conftest.py"
600                 if conftestpath.is_file():
601                     mod = self._importconftest(conftestpath, importmode, rootpath)
602                     clist.append(mod)
603         self._dirpath2confmods[directory] = clist
604         return clist
605 
606     def _rget_with_confmod(
607         self,
608         name: str,
609         path: Path,
610         importmode: Union[str, ImportMode],
611         rootpath: Path,
612     ) -> Tuple[types.ModuleType, Any]:
613         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)
614         for mod in reversed(modules):
615             try:
616                 return mod, getattr(mod, name)
617             except AttributeError:
618                 continue
619         raise KeyError(name)
620 
621     def _importconftest(
622         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path
623     ) -> types.ModuleType:
624         existing = self.get_plugin(str(conftestpath))
625         if existing is not None:
626             return cast(types.ModuleType, existing)
627 
628         pkgpath = resolve_package_path(conftestpath)
629         if pkgpath is None:
630             _ensure_removed_sysmodule(conftestpath.stem)
631 
632         try:
633             mod = import_path(conftestpath, mode=importmode, root=rootpath)
634         except Exception as e:
635             assert e.__traceback__ is not None
636             exc_info = (type(e), e, e.__traceback__)
637             raise ConftestImportFailure(conftestpath, exc_info) from e
638 
639         self._check_non_top_pytest_plugins(mod, conftestpath)
640 
641         self._conftest_plugins.add(mod)
642         dirpath = conftestpath.parent
643         if dirpath in self._dirpath2confmods:
644             for path, mods in self._dirpath2confmods.items():
645                 if dirpath in path.parents or path == dirpath:
646                     assert mod not in mods
647                     mods.append(mod)
648         self.trace(f"loading conftestmodule {mod!r}")
649         self.consider_conftest(mod)
650         return mod
651 
652     def _check_non_top_pytest_plugins(
653         self,
654         mod: types.ModuleType,
655         conftestpath: Path,
656     ) -> None:
657         if (
658             hasattr(mod, "pytest_plugins")
659             and self._configured
660             and not self._using_pyargs
661         ):
662             msg = (
663                 "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\n"
664                 "It affects the entire test suite instead of just below the conftest as expected.\n"
665                 "  {}\n"
666                 "Please move it to a top level conftest file at the rootdir:\n"
667                 "  {}\n"
668                 "For more information, visit:\n"
669                 "  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files"
670             )
671             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)
672 
673     #
674     # API for bootstrapping plugin loading
675     #
676     #
677 
678     def consider_preparse(
679         self, args: Sequence[str], *, exclude_only: bool = False
680     ) -> None:
681         """:meta private:"""
682         i = 0
683         n = len(args)
684         while i < n:
685             opt = args[i]
686             i += 1
687             if isinstance(opt, str):
688                 if opt == "-p":
689                     try:
690                         parg = args[i]
691                     except IndexError:
692                         return
693                     i += 1
694                 elif opt.startswith("-p"):
695                     parg = opt[2:]
696                 else:
697                     continue
698                 if exclude_only and not parg.startswith("no:"):
699                     continue
700                 self.consider_pluginarg(parg)
701 
702     def consider_pluginarg(self, arg: str) -> None:
703         """:meta private:"""
704         if arg.startswith("no:"):
705             name = arg[3:]
706             if name in essential_plugins:
707                 raise UsageError("plugin %s cannot be disabled" % name)
708 
709             # PR #4304: remove stepwise if cacheprovider is blocked.
710             if name == "cacheprovider":
711                 self.set_blocked("stepwise")
712                 self.set_blocked("pytest_stepwise")
713 
714             self.set_blocked(name)
715             if not name.startswith("pytest_"):
716                 self.set_blocked("pytest_" + name)
717         else:
718             name = arg
719             # Unblock the plugin.  None indicates that it has been blocked.
720             # There is no interface with pluggy for this.
721             if self._name2plugin.get(name, -1) is None:
722                 del self._name2plugin[name]
723             if not name.startswith("pytest_"):
724                 if self._name2plugin.get("pytest_" + name, -1) is None:
725                     del self._name2plugin["pytest_" + name]
726             self.import_plugin(arg, consider_entry_points=True)
727 
728     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:
729         """:meta private:"""
730         self.register(conftestmodule, name=conftestmodule.__file__)
731 
732     def consider_env(self) -> None:
733         """:meta private:"""
734         self._import_plugin_specs(os.environ.get("PYTEST_PLUGINS"))
735 
736     def consider_module(self, mod: types.ModuleType) -> None:
737         """:meta private:"""
738         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
739 
740     def _import_plugin_specs(
741         self, spec: Union[None, types.ModuleType, str, Sequence[str]]
742     ) -> None:
743         plugins = _get_plugin_specs_as_list(spec)
744         for import_spec in plugins:
745             self.import_plugin(import_spec)
746 
747     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:
748         """Import a plugin with ``modname``.
749 
750         If ``consider_entry_points`` is True, entry point names are also
751         considered to find a plugin.
752         """
753         # Most often modname refers to builtin modules, e.g. "pytester",
754         # "terminal" or "capture".  Those plugins are registered under their
755         # basename for historic purposes but must be imported with the
756         # _pytest prefix.
757         assert isinstance(modname, str), (
758             "module name as text required, got %r" % modname
759         )
760         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
761             return
762 
763         importspec = "_pytest." + modname if modname in builtin_plugins else modname
764         self.rewrite_hook.mark_rewrite(importspec)
765 
766         if consider_entry_points:
767             loaded = self.load_setuptools_entrypoints("pytest11", name=modname)
768             if loaded:
769                 return
770 
771         try:
772             __import__(importspec)
773         except ImportError as e:
774             raise ImportError(
775                 f'Error importing plugin "{modname}": {e.args[0]}'
776             ).with_traceback(e.__traceback__) from e
777 
778         except Skipped as e:
779             self.skipped_plugins.append((modname, e.msg or ""))
780         else:
781             mod = sys.modules[importspec]
782             self.register(mod, modname)
783 
784 
785 def _get_plugin_specs_as_list(
786     specs: Union[None, types.ModuleType, str, Sequence[str]]
787 ) -> List[str]:
788     """Parse a plugins specification into a list of plugin names."""
789     # None means empty.
790     if specs is None:
791         return []
792     # Workaround for #3899 - a submodule which happens to be called "pytest_plugins".
793     if isinstance(specs, types.ModuleType):
794         return []
795     # Comma-separated list.
796     if isinstance(specs, str):
797         return specs.split(",") if specs else []
798     # Direct specification.
799     if isinstance(specs, collections.abc.Sequence):
800         return list(specs)
801     raise UsageError(
802         "Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r"
803         % specs
804     )
805 
806 
807 def _ensure_removed_sysmodule(modname: str) -> None:
808     try:
809         del sys.modules[modname]
810     except KeyError:
811         pass
812 
813 
814 class Notset:
815     def __repr__(self):
816         return "<NOTSET>"
817 
818 
819 notset = Notset()
820 
821 
822 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:
823     """Given an iterable of file names in a source distribution, return the "names" that should
824     be marked for assertion rewrite.
825 
826     For example the package "pytest_mock/__init__.py" should be added as "pytest_mock" in
827     the assertion rewrite mechanism.
828 
829     This function has to deal with dist-info based distributions and egg based distributions
830     (which are still very much in use for "editable" installs).
831 
832     Here are the file names as seen in a dist-info based distribution:
833 
834         pytest_mock/__init__.py
835         pytest_mock/_version.py
836         pytest_mock/plugin.py
837         pytest_mock.egg-info/PKG-INFO
838 
839     Here are the file names as seen in an egg based distribution:
840 
841         src/pytest_mock/__init__.py
842         src/pytest_mock/_version.py
843         src/pytest_mock/plugin.py
844         src/pytest_mock.egg-info/PKG-INFO
845         LICENSE
846         setup.py
847 
848     We have to take in account those two distribution flavors in order to determine which
849     names should be considered for assertion rewriting.
850 
851     More information:
852         https://github.com/pytest-dev/pytest-mock/issues/167
853     """
854     package_files = list(package_files)
855     seen_some = False
856     for fn in package_files:
857         is_simple_module = "/" not in fn and fn.endswith(".py")
858         is_package = fn.count("/") == 1 and fn.endswith("__init__.py")
859         if is_simple_module:
860             module_name, _ = os.path.splitext(fn)
861             # we ignore "setup.py" at the root of the distribution
862             # as well as editable installation finder modules made by setuptools
863             if module_name != "setup" and not module_name.startswith("__editable__"):
864                 seen_some = True
865                 yield module_name
866         elif is_package:
867             package_name = os.path.dirname(fn)
868             seen_some = True
869             yield package_name
870 
871     if not seen_some:
872         # At this point we did not find any packages or modules suitable for assertion
873         # rewriting, so we try again by stripping the first path component (to account for
874         # "src" based source trees for example).
875         # This approach lets us have the common case continue to be fast, as egg-distributions
876         # are rarer.
877         new_package_files = []
878         for fn in package_files:
879             parts = fn.split("/")
880             new_fn = "/".join(parts[1:])
881             if new_fn:
882                 new_package_files.append(new_fn)
883         if new_package_files:
884             yield from _iter_rewritable_modules(new_package_files)
885 
886 
887 def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:
888     return tuple(args)
889 
890 
891 @final
892 class Config:
893     """Access to configuration values, pluginmanager and plugin hooks.
894 
895     :param PytestPluginManager pluginmanager:
896         A pytest PluginManager.
897 
898     :param InvocationParams invocation_params:
899         Object containing parameters regarding the :func:`pytest.main`
900         invocation.
901     """
902 
903     @final
904     @attr.s(frozen=True, auto_attribs=True)
905     class InvocationParams:
906         """Holds parameters passed during :func:`pytest.main`.
907 
908         The object attributes are read-only.
909 
910         .. versionadded:: 5.1
911 
912         .. note::
913 
914             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``
915             ini option are handled by pytest, not being included in the ``args`` attribute.
916 
917             Plugins accessing ``InvocationParams`` must be aware of that.
918         """
919 
920         args: Tuple[str, ...] = attr.ib(converter=_args_converter)
921         """The command-line arguments as passed to :func:`pytest.main`."""
922         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]
923         """Extra plugins, might be `None`."""
924         dir: Path
925         """The directory from which :func:`pytest.main` was invoked."""
926 
927     class ArgsSource(enum.Enum):
928         """Indicates the source of the test arguments.
929 
930         .. versionadded:: 7.2
931         """
932 
933         #: Command line arguments.
934         ARGS = enum.auto()
935         #: Invocation directory.
936         INCOVATION_DIR = enum.auto()
937         #: 'testpaths' configuration value.
938         TESTPATHS = enum.auto()
939 
940     def __init__(
941         self,
942         pluginmanager: PytestPluginManager,
943         *,
944         invocation_params: Optional[InvocationParams] = None,
945     ) -> None:
946         from .argparsing import Parser, FILE_OR_DIR
947 
948         if invocation_params is None:
949             invocation_params = self.InvocationParams(
950                 args=(), plugins=None, dir=Path.cwd()
951             )
952 
953         self.option = argparse.Namespace()
954         """Access to command line option as attributes.
955 
956         :type: argparse.Namespace
957         """
958 
959         self.invocation_params = invocation_params
960         """The parameters with which pytest was invoked.
961 
962         :type: InvocationParams
963         """
964 
965         _a = FILE_OR_DIR
966         self._parser = Parser(
967             usage=f"%(prog)s [options] [{_a}] [{_a}] [...]",
968             processopt=self._processopt,
969             _ispytest=True,
970         )
971         self.pluginmanager = pluginmanager
972         """The plugin manager handles plugin registration and hook invocation.
973 
974         :type: PytestPluginManager
975         """
976 
977         self.stash = Stash()
978         """A place where plugins can store information on the config for their
979         own use.
980 
981         :type: Stash
982         """
983         # Deprecated alias. Was never public. Can be removed in a few releases.
984         self._store = self.stash
985 
986         from .compat import PathAwareHookProxy
987 
988         self.trace = self.pluginmanager.trace.root.get("config")
989         self.hook = PathAwareHookProxy(self.pluginmanager.hook)
990         self._inicache: Dict[str, Any] = {}
991         self._override_ini: Sequence[str] = ()
992         self._opt2dest: Dict[str, str] = {}
993         self._cleanup: List[Callable[[], None]] = []
994         self.pluginmanager.register(self, "pytestconfig")
995         self._configured = False
996         self.hook.pytest_addoption.call_historic(
997             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)
998         )
999 
1000         if TYPE_CHECKING:
1001             from _pytest.cacheprovider import Cache
1002 
1003             self.cache: Optional[Cache] = None
1004 
1005     @property
1006     def rootpath(self) -> Path:
1007         """The path to the :ref:`rootdir <rootdir>`.
1008 
1009         :type: pathlib.Path
1010 
1011         .. versionadded:: 6.1
1012         """
1013         return self._rootpath
1014 
1015     @property
1016     def inipath(self) -> Optional[Path]:
1017         """The path to the :ref:`configfile <configfiles>`.
1018 
1019         :type: Optional[pathlib.Path]
1020 
1021         .. versionadded:: 6.1
1022         """
1023         return self._inipath
1024 
1025     def add_cleanup(self, func: Callable[[], None]) -> None:
1026         """Add a function to be called when the config object gets out of
1027         use (usually coinciding with pytest_unconfigure)."""
1028         self._cleanup.append(func)
1029 
1030     def _do_configure(self) -> None:
1031         assert not self._configured
1032         self._configured = True
1033         with warnings.catch_warnings():
1034             warnings.simplefilter("default")
1035             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))
1036 
1037     def _ensure_unconfigure(self) -> None:
1038         if self._configured:
1039             self._configured = False
1040             self.hook.pytest_unconfigure(config=self)
1041             self.hook.pytest_configure._call_history = []
1042         while self._cleanup:
1043             fin = self._cleanup.pop()
1044             fin()
1045 
1046     def get_terminal_writer(self) -> TerminalWriter:
1047         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(
1048             "terminalreporter"
1049         )
1050         return terminalreporter._tw
1051 
1052     def pytest_cmdline_parse(
1053         self, pluginmanager: PytestPluginManager, args: List[str]
1054     ) -> "Config":
1055         try:
1056             self.parse(args)
1057         except UsageError:
1058 
1059             # Handle --version and --help here in a minimal fashion.
1060             # This gets done via helpconfig normally, but its
1061             # pytest_cmdline_main is not called in case of errors.
1062             if getattr(self.option, "version", False) or "--version" in args:
1063                 from _pytest.helpconfig import showversion
1064 
1065                 showversion(self)
1066             elif (
1067                 getattr(self.option, "help", False) or "--help" in args or "-h" in args
1068             ):
1069                 self._parser._getparser().print_help()
1070                 sys.stdout.write(
1071                     "\nNOTE: displaying only minimal help due to UsageError.\n\n"
1072                 )
1073 
1074             raise
1075 
1076         return self
1077 
1078     def notify_exception(
1079         self,
1080         excinfo: ExceptionInfo[BaseException],
1081         option: Optional[argparse.Namespace] = None,
1082     ) -> None:
1083         if option and getattr(option, "fulltrace", False):
1084             style: _TracebackStyle = "long"
1085         else:
1086             style = "native"
1087         excrepr = excinfo.getrepr(
1088             funcargs=True, showlocals=getattr(option, "showlocals", False), style=style
1089         )
1090         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)
1091         if not any(res):
1092             for line in str(excrepr).split("\n"):
1093                 sys.stderr.write("INTERNALERROR> %s\n" % line)
1094                 sys.stderr.flush()
1095 
1096     def cwd_relative_nodeid(self, nodeid: str) -> str:
1097         # nodeid's are relative to the rootpath, compute relative to cwd.
1098         if self.invocation_params.dir != self.rootpath:
1099             fullpath = self.rootpath / nodeid
1100             nodeid = bestrelpath(self.invocation_params.dir, fullpath)
1101         return nodeid
1102 
1103     @classmethod
1104     def fromdictargs(cls, option_dict, args) -> "Config":
1105         """Constructor usable for subprocesses."""
1106         config = get_config(args)
1107         config.option.__dict__.update(option_dict)
1108         config.parse(args, addopts=False)
1109         for x in config.option.plugins:
1110             config.pluginmanager.consider_pluginarg(x)
1111         return config
1112 
1113     def _processopt(self, opt: "Argument") -> None:
1114         for name in opt._short_opts + opt._long_opts:
1115             self._opt2dest[name] = opt.dest
1116 
1117         if hasattr(opt, "default"):
1118             if not hasattr(self.option, opt.dest):
1119                 setattr(self.option, opt.dest, opt.default)
1120 
1121     @hookimpl(trylast=True)
1122     def pytest_load_initial_conftests(self, early_config: "Config") -> None:
1123         self.pluginmanager._set_initial_conftests(
1124             early_config.known_args_namespace, rootpath=early_config.rootpath
1125         )
1126 
1127     def _initini(self, args: Sequence[str]) -> None:
1128         ns, unknown_args = self._parser.parse_known_and_unknown_args(
1129             args, namespace=copy.copy(self.option)
1130         )
1131         rootpath, inipath, inicfg = determine_setup(
1132             ns.inifilename,
1133             ns.file_or_dir + unknown_args,
1134             rootdir_cmd_arg=ns.rootdir or None,
1135             config=self,
1136         )
1137         self._rootpath = rootpath
1138         self._inipath = inipath
1139         self.inicfg = inicfg
1140         self._parser.extra_info["rootdir"] = str(self.rootpath)
1141         self._parser.extra_info["inifile"] = str(self.inipath)
1142         self._parser.addini("addopts", "Extra command line options", "args")
1143         self._parser.addini("minversion", "Minimally required pytest version")
1144         self._parser.addini(
1145             "required_plugins",
1146             "Plugins that must be present for pytest to run",
1147             type="args",
1148             default=[],
1149         )
1150         self._override_ini = ns.override_ini or ()
1151 
1152     def _consider_importhook(self, args: Sequence[str]) -> None:
1153         """Install the PEP 302 import hook if using assertion rewriting.
1154 
1155         Needs to parse the --assert=<mode> option from the commandline
1156         and find all the installed plugins to mark them for rewriting
1157         by the importhook.
1158         """
1159         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)
1160         mode = getattr(ns, "assertmode", "plain")
1161         if mode == "rewrite":
1162             import _pytest.assertion
1163 
1164             try:
1165                 hook = _pytest.assertion.install_importhook(self)
1166             except SystemError:
1167                 mode = "plain"
1168             else:
1169                 self._mark_plugins_for_rewrite(hook)
1170         self._warn_about_missing_assertion(mode)
1171 
1172     def _mark_plugins_for_rewrite(self, hook) -> None:
1173         """Given an importhook, mark for rewrite any top-level
1174         modules or packages in the distribution package for
1175         all pytest plugins."""
1176         self.pluginmanager.rewrite_hook = hook
1177 
1178         if os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1179             # We don't autoload from setuptools entry points, no need to continue.
1180             return
1181 
1182         package_files = (
1183             str(file)
1184             for dist in importlib_metadata.distributions()
1185             if any(ep.group == "pytest11" for ep in dist.entry_points)
1186             for file in dist.files or []
1187         )
1188 
1189         for name in _iter_rewritable_modules(package_files):
1190             hook.mark_rewrite(name)
1191 
1192     def _validate_args(self, args: List[str], via: str) -> List[str]:
1193         """Validate known args."""
1194         self._parser._config_source_hint = via  # type: ignore
1195         try:
1196             self._parser.parse_known_and_unknown_args(
1197                 args, namespace=copy.copy(self.option)
1198             )
1199         finally:
1200             del self._parser._config_source_hint  # type: ignore
1201 
1202         return args
1203 
1204     def _preparse(self, args: List[str], addopts: bool = True) -> None:
1205         if addopts:
1206             env_addopts = os.environ.get("PYTEST_ADDOPTS", "")
1207             if len(env_addopts):
1208                 args[:] = (
1209                     self._validate_args(shlex.split(env_addopts), "via PYTEST_ADDOPTS")
1210                     + args
1211                 )
1212         self._initini(args)
1213         if addopts:
1214             args[:] = (
1215                 self._validate_args(self.getini("addopts"), "via addopts config") + args
1216             )
1217 
1218         self.known_args_namespace = self._parser.parse_known_args(
1219             args, namespace=copy.copy(self.option)
1220         )
1221         self._checkversion()
1222         self._consider_importhook(args)
1223         self.pluginmanager.consider_preparse(args, exclude_only=False)
1224         if not os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1225             # Don't autoload from setuptools entry point. Only explicitly specified
1226             # plugins are going to be loaded.
1227             self.pluginmanager.load_setuptools_entrypoints("pytest11")
1228         self.pluginmanager.consider_env()
1229 
1230         self.known_args_namespace = self._parser.parse_known_args(
1231             args, namespace=copy.copy(self.known_args_namespace)
1232         )
1233 
1234         self._validate_plugins()
1235         self._warn_about_skipped_plugins()
1236 
1237         if self.known_args_namespace.strict:
1238             self.issue_config_time_warning(
1239                 _pytest.deprecated.STRICT_OPTION, stacklevel=2
1240             )
1241 
1242         if self.known_args_namespace.confcutdir is None and self.inipath is not None:
1243             confcutdir = str(self.inipath.parent)
1244             self.known_args_namespace.confcutdir = confcutdir
1245         try:
1246             self.hook.pytest_load_initial_conftests(
1247                 early_config=self, args=args, parser=self._parser
1248             )
1249         except ConftestImportFailure as e:
1250             if self.known_args_namespace.help or self.known_args_namespace.version:
1251                 # we don't want to prevent --help/--version to work
1252                 # so just let is pass and print a warning at the end
1253                 self.issue_config_time_warning(
1254                     PytestConfigWarning(f"could not load initial conftests: {e.path}"),
1255                     stacklevel=2,
1256                 )
1257             else:
1258                 raise
1259 
1260     @hookimpl(hookwrapper=True)
1261     def pytest_collection(self) -> Generator[None, None, None]:
1262         # Validate invalid ini keys after collection is done so we take in account
1263         # options added by late-loading conftest files.
1264         yield
1265         self._validate_config_options()
1266 
1267     def _checkversion(self) -> None:
1268         import pytest
1269 
1270         minver = self.inicfg.get("minversion", None)
1271         if minver:
1272             # Imported lazily to improve start-up time.
1273             from packaging.version import Version
1274 
1275             if not isinstance(minver, str):
1276                 raise pytest.UsageError(
1277                     "%s: 'minversion' must be a single value" % self.inipath
1278                 )
1279 
1280             if Version(minver) > Version(pytest.__version__):
1281                 raise pytest.UsageError(
1282                     "%s: 'minversion' requires pytest-%s, actual pytest-%s'"
1283                     % (
1284                         self.inipath,
1285                         minver,
1286                         pytest.__version__,
1287                     )
1288                 )
1289 
1290     def _validate_config_options(self) -> None:
1291         for key in sorted(self._get_unknown_ini_keys()):
1292             self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
1293 
1294     def _validate_plugins(self) -> None:
1295         required_plugins = sorted(self.getini("required_plugins"))
1296         if not required_plugins:
1297             return
1298 
1299         # Imported lazily to improve start-up time.
1300         from packaging.version import Version
1301         from packaging.requirements import InvalidRequirement, Requirement
1302 
1303         plugin_info = self.pluginmanager.list_plugin_distinfo()
1304         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}
1305 
1306         missing_plugins = []
1307         for required_plugin in required_plugins:
1308             try:
1309                 req = Requirement(required_plugin)
1310             except InvalidRequirement:
1311                 missing_plugins.append(required_plugin)
1312                 continue
1313 
1314             if req.name not in plugin_dist_info:
1315                 missing_plugins.append(required_plugin)
1316             elif not req.specifier.contains(
1317                 Version(plugin_dist_info[req.name]), prereleases=True
1318             ):
1319                 missing_plugins.append(required_plugin)
1320 
1321         if missing_plugins:
1322             raise UsageError(
1323                 "Missing required plugins: {}".format(", ".join(missing_plugins)),
1324             )
1325 
1326     def _warn_or_fail_if_strict(self, message: str) -> None:
1327         if self.known_args_namespace.strict_config:
1328             raise UsageError(message)
1329 
1330         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)
1331 
1332     def _get_unknown_ini_keys(self) -> List[str]:
1333         parser_inicfg = self._parser._inidict
1334         return [name for name in self.inicfg if name not in parser_inicfg]
1335 
1336     def parse(self, args: List[str], addopts: bool = True) -> None:
1337         # Parse given cmdline arguments into this config object.
1338         assert not hasattr(
1339             self, "args"
1340         ), "can only parse cmdline args at most once per Config object"
1341         self.hook.pytest_addhooks.call_historic(
1342             kwargs=dict(pluginmanager=self.pluginmanager)
1343         )
1344         self._preparse(args, addopts=addopts)
1345         # XXX deprecated hook:
1346         self.hook.pytest_cmdline_preparse(config=self, args=args)
1347         self._parser.after_preparse = True  # type: ignore
1348         try:
1349             source = Config.ArgsSource.ARGS
1350             args = self._parser.parse_setoption(
1351                 args, self.option, namespace=self.option
1352             )
1353             if not args:
1354                 if self.invocation_params.dir == self.rootpath:
1355                     source = Config.ArgsSource.TESTPATHS
1356                     testpaths: List[str] = self.getini("testpaths")
1357                     if self.known_args_namespace.pyargs:
1358                         args = testpaths
1359                     else:
1360                         args = []
1361                         for path in testpaths:
1362                             args.extend(sorted(glob.iglob(path, recursive=True)))
1363                 if not args:
1364                     source = Config.ArgsSource.INCOVATION_DIR
1365                     args = [str(self.invocation_params.dir)]
1366             self.args = args
1367             self.args_source = source
1368         except PrintHelp:
1369             pass
1370 
1371     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:
1372         """Issue and handle a warning during the "configure" stage.
1373 
1374         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``
1375         function because it is not possible to have hookwrappers around ``pytest_configure``.
1376 
1377         This function is mainly intended for plugins that need to issue warnings during
1378         ``pytest_configure`` (or similar stages).
1379 
1380         :param warning: The warning instance.
1381         :param stacklevel: stacklevel forwarded to warnings.warn.
1382         """
1383         if self.pluginmanager.is_blocked("warnings"):
1384             return
1385 
1386         cmdline_filters = self.known_args_namespace.pythonwarnings or []
1387         config_filters = self.getini("filterwarnings")
1388 
1389         with warnings.catch_warnings(record=True) as records:
1390             warnings.simplefilter("always", type(warning))
1391             apply_warning_filters(config_filters, cmdline_filters)
1392             warnings.warn(warning, stacklevel=stacklevel)
1393 
1394         if records:
1395             frame = sys._getframe(stacklevel - 1)
1396             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name
1397             self.hook.pytest_warning_recorded.call_historic(
1398                 kwargs=dict(
1399                     warning_message=records[0],
1400                     when="config",
1401                     nodeid="",
1402                     location=location,
1403                 )
1404             )
1405 
1406     def addinivalue_line(self, name: str, line: str) -> None:
1407         """Add a line to an ini-file option. The option must have been
1408         declared but might not yet be set in which case the line becomes
1409         the first line in its value."""
1410         x = self.getini(name)
1411         assert isinstance(x, list)
1412         x.append(line)  # modifies the cached list inline
1413 
1414     def getini(self, name: str):
1415         """Return configuration value from an :ref:`ini file <configfiles>`.
1416 
1417         If the specified name hasn't been registered through a prior
1418         :func:`parser.addini <pytest.Parser.addini>` call (usually from a
1419         plugin), a ValueError is raised.
1420         """
1421         try:
1422             return self._inicache[name]
1423         except KeyError:
1424             self._inicache[name] = val = self._getini(name)
1425             return val
1426 
1427     # Meant for easy monkeypatching by legacypath plugin.
1428     # Can be inlined back (with no cover removed) once legacypath is gone.
1429     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):
1430         msg = f"unknown configuration type: {type}"
1431         raise ValueError(msg, value)  # pragma: no cover
1432 
1433     def _getini(self, name: str):
1434         try:
1435             description, type, default = self._parser._inidict[name]
1436         except KeyError as e:
1437             raise ValueError(f"unknown configuration value: {name!r}") from e
1438         override_value = self._get_override_ini_value(name)
1439         if override_value is None:
1440             try:
1441                 value = self.inicfg[name]
1442             except KeyError:
1443                 if default is not None:
1444                     return default
1445                 if type is None:
1446                     return ""
1447                 return []
1448         else:
1449             value = override_value
1450         # Coerce the values based on types.
1451         #
1452         # Note: some coercions are only required if we are reading from .ini files, because
1453         # the file format doesn't contain type information, but when reading from toml we will
1454         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).
1455         # For example:
1456         #
1457         #   ini:
1458         #     a_line_list = "tests acceptance"
1459         #   in this case, we need to split the string to obtain a list of strings.
1460         #
1461         #   toml:
1462         #     a_line_list = ["tests", "acceptance"]
1463         #   in this case, we already have a list ready to use.
1464         #
1465         if type == "paths":
1466             # TODO: This assert is probably not valid in all cases.
1467             assert self.inipath is not None
1468             dp = self.inipath.parent
1469             input_values = shlex.split(value) if isinstance(value, str) else value
1470             return [dp / x for x in input_values]
1471         elif type == "args":
1472             return shlex.split(value) if isinstance(value, str) else value
1473         elif type == "linelist":
1474             if isinstance(value, str):
1475                 return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
1476             else:
1477                 return value
1478         elif type == "bool":
1479             return _strtobool(str(value).strip())
1480         elif type == "string":
1481             return value
1482         elif type is None:
1483             return value
1484         else:
1485             return self._getini_unknown_type(name, type, value)
1486 
1487     def _getconftest_pathlist(
1488         self, name: str, path: Path, rootpath: Path
1489     ) -> Optional[List[Path]]:
1490         try:
1491             mod, relroots = self.pluginmanager._rget_with_confmod(
1492                 name, path, self.getoption("importmode"), rootpath
1493             )
1494         except KeyError:
1495             return None
1496         assert mod.__file__ is not None
1497         modpath = Path(mod.__file__).parent
1498         values: List[Path] = []
1499         for relroot in relroots:
1500             if isinstance(relroot, os.PathLike):
1501                 relroot = Path(relroot)
1502             else:
1503                 relroot = relroot.replace("/", os.sep)
1504                 relroot = absolutepath(modpath / relroot)
1505             values.append(relroot)
1506         return values
1507 
1508     def _get_override_ini_value(self, name: str) -> Optional[str]:
1509         value = None
1510         # override_ini is a list of "ini=value" options.
1511         # Always use the last item if multiple values are set for same ini-name,
1512         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.
1513         for ini_config in self._override_ini:
1514             try:
1515                 key, user_ini_value = ini_config.split("=", 1)
1516             except ValueError as e:
1517                 raise UsageError(
1518                     "-o/--override-ini expects option=value style (got: {!r}).".format(
1519                         ini_config
1520                     )
1521                 ) from e
1522             else:
1523                 if key == name:
1524                     value = user_ini_value
1525         return value
1526 
1527     def getoption(self, name: str, default=notset, skip: bool = False):
1528         """Return command line option value.
1529 
1530         :param name: Name of the option.  You may also specify
1531             the literal ``--OPT`` option instead of the "dest" option name.
1532         :param default: Default value if no option of that name exists.
1533         :param skip: If True, raise pytest.skip if option does not exists
1534             or has a None value.
1535         """
1536         name = self._opt2dest.get(name, name)
1537         try:
1538             val = getattr(self.option, name)
1539             if val is None and skip:
1540                 raise AttributeError(name)
1541             return val
1542         except AttributeError as e:
1543             if default is not notset:
1544                 return default
1545             if skip:
1546                 import pytest
1547 
1548                 pytest.skip(f"no {name!r} option found")
1549             raise ValueError(f"no option named {name!r}") from e
1550 
1551     def getvalue(self, name: str, path=None):
1552         """Deprecated, use getoption() instead."""
1553         return self.getoption(name)
1554 
1555     def getvalueorskip(self, name: str, path=None):
1556         """Deprecated, use getoption(skip=True) instead."""
1557         return self.getoption(name, skip=True)
1558 
1559     def _warn_about_missing_assertion(self, mode: str) -> None:
1560         if not _assertion_supported():
1561             if mode == "plain":
1562                 warning_text = (
1563                     "ASSERTIONS ARE NOT EXECUTED"
1564                     " and FAILING TESTS WILL PASS.  Are you"
1565                     " using python -O?"
1566                 )
1567             else:
1568                 warning_text = (
1569                     "assertions not in test modules or"
1570                     " plugins will be ignored"
1571                     " because assert statements are not executed "
1572                     "by the underlying Python interpreter "
1573                     "(are you using python -O?)\n"
1574                 )
1575             self.issue_config_time_warning(
1576                 PytestConfigWarning(warning_text),
1577                 stacklevel=3,
1578             )
1579 
1580     def _warn_about_skipped_plugins(self) -> None:
1581         for module_name, msg in self.pluginmanager.skipped_plugins:
1582             self.issue_config_time_warning(
1583                 PytestConfigWarning(f"skipped plugin {module_name!r}: {msg}"),
1584                 stacklevel=2,
1585             )
1586 
1587 
1588 def _assertion_supported() -> bool:
1589     try:
1590         assert False
1591     except AssertionError:
1592         return True
1593     else:
1594         return False  # type: ignore[unreachable]
1595 
1596 
1597 def create_terminal_writer(
1598     config: Config, file: Optional[TextIO] = None
1599 ) -> TerminalWriter:
1600     """Create a TerminalWriter instance configured according to the options
1601     in the config object.
1602 
1603     Every code which requires a TerminalWriter object and has access to a
1604     config object should use this function.
1605     """
1606     tw = TerminalWriter(file=file)
1607 
1608     if config.option.color == "yes":
1609         tw.hasmarkup = True
1610     elif config.option.color == "no":
1611         tw.hasmarkup = False
1612 
1613     if config.option.code_highlight == "yes":
1614         tw.code_highlight = True
1615     elif config.option.code_highlight == "no":
1616         tw.code_highlight = False
1617 
1618     return tw
1619 
1620 
1621 def _strtobool(val: str) -> bool:
1622     """Convert a string representation of truth to True or False.
1623 
1624     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
1625     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
1626     'val' is anything else.
1627 
1628     .. note:: Copied from distutils.util.
1629     """
1630     val = val.lower()
1631     if val in ("y", "yes", "t", "true", "on", "1"):
1632         return True
1633     elif val in ("n", "no", "f", "false", "off", "0"):
1634         return False
1635     else:
1636         raise ValueError(f"invalid truth value {val!r}")
1637 
1638 
1639 @lru_cache(maxsize=50)
1640 def parse_warning_filter(
1641     arg: str, *, escape: bool
1642 ) -> Tuple["warnings._ActionKind", str, Type[Warning], str, int]:
1643     """Parse a warnings filter string.
1644 
1645     This is copied from warnings._setoption with the following changes:
1646 
1647     * Does not apply the filter.
1648     * Escaping is optional.
1649     * Raises UsageError so we get nice error messages on failure.
1650     """
1651     __tracebackhide__ = True
1652     error_template = dedent(
1653         f"""\
1654         while parsing the following warning configuration:
1655 
1656           {arg}
1657 
1658         This error occurred:
1659 
1660         {{error}}
1661         """
1662     )
1663 
1664     parts = arg.split(":")
1665     if len(parts) > 5:
1666         doc_url = (
1667             "https://docs.python.org/3/library/warnings.html#describing-warning-filters"
1668         )
1669         error = dedent(
1670             f"""\
1671             Too many fields ({len(parts)}), expected at most 5 separated by colons:
1672 
1673               action:message:category:module:line
1674 
1675             For more information please consult: {doc_url}
1676             """
1677         )
1678         raise UsageError(error_template.format(error=error))
1679 
1680     while len(parts) < 5:
1681         parts.append("")
1682     action_, message, category_, module, lineno_ = (s.strip() for s in parts)
1683     try:
1684         action: "warnings._ActionKind" = warnings._getaction(action_)  # type: ignore[attr-defined]
1685     except warnings._OptionError as e:
1686         raise UsageError(error_template.format(error=str(e)))
1687     try:
1688         category: Type[Warning] = _resolve_warning_category(category_)
1689     except Exception:
1690         exc_info = ExceptionInfo.from_current()
1691         exception_text = exc_info.getrepr(style="native")
1692         raise UsageError(error_template.format(error=exception_text))
1693     if message and escape:
1694         message = re.escape(message)
1695     if module and escape:
1696         module = re.escape(module) + r"\Z"
1697     if lineno_:
1698         try:
1699             lineno = int(lineno_)
1700             if lineno < 0:
1701                 raise ValueError("number is negative")
1702         except ValueError as e:
1703             raise UsageError(
1704                 error_template.format(error=f"invalid lineno {lineno_!r}: {e}")
1705             )
1706     else:
1707         lineno = 0
1708     return action, message, category, module, lineno
1709 
1710 
1711 def _resolve_warning_category(category: str) -> Type[Warning]:
1712     """
1713     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)
1714     propagate so we can get access to their tracebacks (#9218).
1715     """
1716     __tracebackhide__ = True
1717     if not category:
1718         return Warning
1719 
1720     if "." not in category:
1721         import builtins as m
1722 
1723         klass = category
1724     else:
1725         module, _, klass = category.rpartition(".")
1726         m = __import__(module, None, None, [klass])
1727     cat = getattr(m, klass)
1728     if not issubclass(cat, Warning):
1729         raise UsageError(f"{cat} is not a Warning subclass")
1730     return cast(Type[Warning], cat)
1731 
1732 
1733 def apply_warning_filters(
1734     config_filters: Iterable[str], cmdline_filters: Iterable[str]
1735 ) -> None:
1736     """Applies pytest-configured filters to the warnings module"""
1737     # Filters should have this precedence: cmdline options, config.
1738     # Filters should be applied in the inverse order of precedence.
1739     for arg in config_filters:
1740         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))
1741 
1742     for arg in cmdline_filters:
1743         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))

</code><intended_behavior>Since this file deals with the configuration of pytest, including the loading and registration of plugins, it's a plausible location where enhancements could be made to improve the issue at hand. Specifically, during the process where plugins are scanned for hook implementations, the system could be enhanced to record more detailed location information. When a deprecated `hookimpl` is found, the system should emit a `PytestDeprecationWarning` that includes this detailed location information, making it easier for users to identify and correct the source of the deprecation. Preserving Existing Functionality: The mechanism for loading, registering, and managing plugins and their hook implementations should remain untouched in terms of functionality. The enhancement should only extend the information provided in warnings related to deprecated hook usage.</intended_behavior>]
2025-10-15 09:34:21.647 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 09:34:21.647 | INFO     | Search-only: skipping patch selection
2025-10-15 09:34:21.709 | INFO     | Task pytest-dev__pytest-10343 completed successfully.
2025-10-15 09:34:21.710 | INFO     | No patch generated. You can try running ACR again.
