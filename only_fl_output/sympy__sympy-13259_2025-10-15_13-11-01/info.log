2025-10-15 13:11:01.625 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 13:11:12.038 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=409, output_tokens=12, cost=0.004450
2025-10-15 13:11:24.628 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=589, output_tokens=534, cost=0.021910
2025-10-15 13:11:26.219 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:11:33.902 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=717, output_tokens=353, cost=0.017760
2025-10-15 13:11:33.911 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:11:36.438 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=51, cost=0.008600
2025-10-15 13:11:36.439 | DEBUG    | Extracted a valid json.
2025-10-15 13:11:36.439 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"simplify\")",
        "search_class(\"Cos\")",
        "search_class(\"Cosh\")",
        "search_class(\"Asinh\")"
    ],
    "bug_locations": []
}
2025-10-15 13:11:36.452 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:11:36.453 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:11:56.351 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1463, output_tokens=689, cost=0.035300
2025-10-15 13:11:56.366 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:11:58.847 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2368, output_tokens=42, cost=0.024940
2025-10-15 13:11:58.850 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:12:01.572 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=396, output_tokens=63, cost=0.005850
2025-10-15 13:12:01.574 | DEBUG    | Extracted a valid json.
2025-10-15 13:12:01.579 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"simplify\", \"sympy/simplify/simplify.py\")",
        "search_code(\"cos\")",
        "search_code(\"cosh\")",
        "search_code(\"asinh\")"
    ],
    "bug_locations": []
}
2025-10-15 13:12:19.238 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:12:19.239 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:12:46.401 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10832, output_tokens=720, cost=0.129920
2025-10-15 13:12:46.408 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:12:58.875 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=11768, output_tokens=431, cost=0.130610
2025-10-15 13:12:58.883 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:13:04.981 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=785, output_tokens=214, cost=0.014270
2025-10-15 13:13:04.982 | DEBUG    | Extracted a valid json.
2025-10-15 13:13:04.988 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/simplify/trigsimp.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure the simplification logic correctly identifies and processes trigonometric functions with complex arguments, particularly avoiding incorrect transformations into cosh functions unless mathematically valid."
        },
        {
            "file": "sympy/functions/elementary/trigonometric.py",
            "class": "",
            "method": "",
            "intended_behavior": "The evaluation and simplification logic should correctly handle complex arguments, avoiding incorrect transformations or assumptions about trigonometric and hyperbolic functions."
        },
        {
            "file": "sympy/functions/elementary/hyperbolic.py",
            "class": "",
            "method": "",
            "intended_behavior": "Review and potentially enhance the logic dealing with the interplay between trigonometric functions and complex arguments to ensure correct application of mathematical principles."
        }
    ]
}
2025-10-15 13:13:04.999 | DEBUG    | Bug location extracted successfully: [<file>sympy/simplify/trigsimp.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core.cache import cacheit
6 from sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,
7     Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)
8 from sympy.core.compatibility import reduce, iterable
9 from sympy.core.numbers import I, Integer
10 from sympy.core.function import count_ops, _mexpand
11 from sympy.functions.elementary.trigonometric import TrigonometricFunction
12 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
13 from sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth
14 
15 from sympy.strategies.core import identity
16 from sympy.strategies.tree import greedy
17 
18 from sympy.polys import Poly
19 from sympy.polys.polyerrors import PolificationFailed
20 from sympy.polys.polytools import groebner
21 from sympy.polys.domains import ZZ
22 from sympy.polys import factor, cancel, parallel_poly_from_expr
23 
24 from sympy.utilities.misc import debug
25 
26 
27 
28 def trigsimp_groebner(expr, hints=[], quick=False, order="grlex",
29                       polynomial=False):
30     """
31     Simplify trigonometric expressions using a groebner basis algorithm.
32 
33     This routine takes a fraction involving trigonometric or hyperbolic
34     expressions, and tries to simplify it. The primary metric is the
35     total degree. Some attempts are made to choose the simplest possible
36     expression of the minimal degree, but this is non-rigorous, and also
37     very slow (see the ``quick=True`` option).
38 
39     If ``polynomial`` is set to True, instead of simplifying numerator and
40     denominator together, this function just brings numerator and denominator
41     into a canonical form. This is much faster, but has potentially worse
42     results. However, if the input is a polynomial, then the result is
43     guaranteed to be an equivalent polynomial of minimal degree.
44 
45     The most important option is hints. Its entries can be any of the
46     following:
47 
48     - a natural number
49     - a function
50     - an iterable of the form (func, var1, var2, ...)
51     - anything else, interpreted as a generator
52 
53     A number is used to indicate that the search space should be increased.
54     A function is used to indicate that said function is likely to occur in a
55     simplified expression.
56     An iterable is used indicate that func(var1 + var2 + ...) is likely to
57     occur in a simplified .
58     An additional generator also indicates that it is likely to occur.
59     (See examples below).
60 
61     This routine carries out various computationally intensive algorithms.
62     The option ``quick=True`` can be used to suppress one particularly slow
63     step (at the expense of potentially more complicated results, but never at
64     the expense of increased total degree).
65 
66     Examples
67     ========
68 
69     >>> from sympy.abc import x, y
70     >>> from sympy import sin, tan, cos, sinh, cosh, tanh
71     >>> from sympy.simplify.trigsimp import trigsimp_groebner
72 
73     Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:
74 
75     >>> ex = sin(x)*cos(x)
76     >>> trigsimp_groebner(ex)
77     sin(x)*cos(x)
78 
79     This is because ``trigsimp_groebner`` only looks for a simplification
80     involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try
81     ``2*x`` by passing ``hints=[2]``:
82 
83     >>> trigsimp_groebner(ex, hints=[2])
84     sin(2*x)/2
85     >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])
86     -cos(2*x)
87 
88     Increasing the search space this way can quickly become expensive. A much
89     faster way is to give a specific expression that is likely to occur:
90 
91     >>> trigsimp_groebner(ex, hints=[sin(2*x)])
92     sin(2*x)/2
93 
94     Hyperbolic expressions are similarly supported:
95 
96     >>> trigsimp_groebner(sinh(2*x)/sinh(x))
97     2*cosh(x)
98 
99     Note how no hints had to be passed, since the expression already involved
100     ``2*x``.
101 
102     The tangent function is also supported. You can either pass ``tan`` in the
103     hints, to indicate that than should be tried whenever cosine or sine are,
104     or you can pass a specific generator:
105 
106     >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])
107     tan(x)
108     >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])
109     tanh(x)
110 
111     Finally, you can use the iterable form to suggest that angle sum formulae
112     should be tried:
113 
114     >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))
115     >>> trigsimp_groebner(ex, hints=[(tan, x, y)])
116     tan(x + y)
117     """
118     # TODO
119     #  - preprocess by replacing everything by funcs we can handle
120     # - optionally use cot instead of tan
121     # - more intelligent hinting.
122     #     For example, if the ideal is small, and we have sin(x), sin(y),
123     #     add sin(x + y) automatically... ?
124     # - algebraic numbers ...
125     # - expressions of lowest degree are not distinguished properly
126     #   e.g. 1 - sin(x)**2
127     # - we could try to order the generators intelligently, so as to influence
128     #   which monomials appear in the quotient basis
129 
130     # THEORY
131     # ------
132     # Ratsimpmodprime above can be used to "simplify" a rational function
133     # modulo a prime ideal. "Simplify" mainly means finding an equivalent
134     # expression of lower total degree.
135     #
136     # We intend to use this to simplify trigonometric functions. To do that,
137     # we need to decide (a) which ring to use, and (b) modulo which ideal to
138     # simplify. In practice, (a) means settling on a list of "generators"
139     # a, b, c, ..., such that the fraction we want to simplify is a rational
140     # function in a, b, c, ..., with coefficients in ZZ (integers).
141     # (2) means that we have to decide what relations to impose on the
142     # generators. There are two practical problems:
143     #   (1) The ideal has to be *prime* (a technical term).
144     #   (2) The relations have to be polynomials in the generators.
145     #
146     # We typically have two kinds of generators:
147     # - trigonometric expressions, like sin(x), cos(5*x), etc
148     # - "everything else", like gamma(x), pi, etc.
149     #
150     # Since this function is trigsimp, we will concentrate on what to do with
151     # trigonometric expressions. We can also simplify hyperbolic expressions,
152     # but the extensions should be clear.
153     #
154     # One crucial point is that all *other* generators really should behave
155     # like indeterminates. In particular if (say) "I" is one of them, then
156     # in fact I**2 + 1 = 0 and we may and will compute non-sensical
157     # expressions. However, we can work with a dummy and add the relation
158     # I**2 + 1 = 0 to our ideal, then substitute back in the end.
159     #
160     # Now regarding trigonometric generators. We split them into groups,
161     # according to the argument of the trigonometric functions. We want to
162     # organise this in such a way that most trigonometric identities apply in
163     # the same group. For example, given sin(x), cos(2*x) and cos(y), we would
164     # group as [sin(x), cos(2*x)] and [cos(y)].
165     #
166     # Our prime ideal will be built in three steps:
167     # (1) For each group, compute a "geometrically prime" ideal of relations.
168     #     Geometrically prime means that it generates a prime ideal in
169     #     CC[gens], not just ZZ[gens].
170     # (2) Take the union of all the generators of the ideals for all groups.
171     #     By the geometric primality condition, this is still prime.
172     # (3) Add further inter-group relations which preserve primality.
173     #
174     # Step (1) works as follows. We will isolate common factors in the
175     # argument, so that all our generators are of the form sin(n*x), cos(n*x)
176     # or tan(n*x), with n an integer. Suppose first there are no tan terms.
177     # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since
178     # X**2 + Y**2 - 1 is irreducible over CC.
179     # Now, if we have a generator sin(n*x), than we can, using trig identities,
180     # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this
181     # relation to the ideal, preserving geometric primality, since the quotient
182     # ring is unchanged.
183     # Thus we have treated all sin and cos terms.
184     # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.
185     # (This requires of course that we already have relations for cos(n*x) and
186     # sin(n*x).) It is not obvious, but it seems that this preserves geometric
187     # primality.
188     # XXX A real proof would be nice. HELP!
189     #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of
190     #     CC[S, C, T]:
191     #     - it suffices to show that the projective closure in CP**3 is
192     #       irreducible
193     #     - using the half-angle substitutions, we can express sin(x), tan(x),
194     #       cos(x) as rational functions in tan(x/2)
195     #     - from this, we get a rational map from CP**1 to our curve
196     #     - this is a morphism, hence the curve is prime
197     #
198     # Step (2) is trivial.
199     #
200     # Step (3) works by adding selected relations of the form
201     # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is
202     # preserved by the same argument as before.
203 
204     def parse_hints(hints):
205         """Split hints into (n, funcs, iterables, gens)."""
206         n = 1
207         funcs, iterables, gens = [], [], []
208         for e in hints:
209             if isinstance(e, (int, Integer)):
210                 n = e
211             elif isinstance(e, FunctionClass):
212                 funcs.append(e)
213             elif iterable(e):
214                 iterables.append((e[0], e[1:]))
215                 # XXX sin(x+2y)?
216                 # Note: we go through polys so e.g.
217                 # sin(-x) -> -sin(x) -> sin(x)
218                 gens.extend(parallel_poly_from_expr(
219                     [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)
220             else:
221                 gens.append(e)
222         return n, funcs, iterables, gens
223 
224     def build_ideal(x, terms):
225         """
226         Build generators for our ideal. Terms is an iterable with elements of
227         the form (fn, coeff), indicating that we have a generator fn(coeff*x).
228 
229         If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed
230         to appear in terms. Similarly for hyperbolic functions. For tan(n*x),
231         sin(n*x) and cos(n*x) are guaranteed.
232         """
233         gens = []
234         I = []
235         y = Dummy('y')
236         for fn, coeff in terms:
237             for c, s, t, rel in (
238                     [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],
239                     [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):
240                 if coeff == 1 and fn in [c, s]:
241                     I.append(rel)
242                 elif fn == t:
243                     I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))
244                 elif fn in [c, s]:
245                     cn = fn(coeff*y).expand(trig=True).subs(y, x)
246                     I.append(fn(coeff*x) - cn)
247         return list(set(I))
248 
249     def analyse_gens(gens, hints):
250         """
251         Analyse the generators ``gens``, using the hints ``hints``.
252 
253         The meaning of ``hints`` is described in the main docstring.
254         Return a new list of generators, and also the ideal we should
255         work with.
256         """
257         # First parse the hints
258         n, funcs, iterables, extragens = parse_hints(hints)
259         debug('n=%s' % n, 'funcs:', funcs, 'iterables:',
260               iterables, 'extragens:', extragens)
261 
262         # We just add the extragens to gens and analyse them as before
263         gens = list(gens)
264         gens.extend(extragens)
265 
266         # remove duplicates
267         funcs = list(set(funcs))
268         iterables = list(set(iterables))
269         gens = list(set(gens))
270 
271         # all the functions we can do anything with
272         allfuncs = {sin, cos, tan, sinh, cosh, tanh}
273         # sin(3*x) -> ((3, x), sin)
274         trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens
275                      if g.func in allfuncs]
276         # Our list of new generators - start with anything that we cannot
277         # work with (i.e. is not a trigonometric term)
278         freegens = [g for g in gens if g.func not in allfuncs]
279         newgens = []
280         trigdict = {}
281         for (coeff, var), fn in trigterms:
282             trigdict.setdefault(var, []).append((coeff, fn))
283         res = [] # the ideal
284 
285         for key, val in trigdict.items():
286             # We have now assembeled a dictionary. Its keys are common
287             # arguments in trigonometric expressions, and values are lists of
288             # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we
289             # need to deal with fn(coeff*x0). We take the rational gcd of the
290             # coeffs, call it ``gcd``. We then use x = x0/gcd as "base symbol",
291             # all other arguments are integral multiples thereof.
292             # We will build an ideal which works with sin(x), cos(x).
293             # If hint tan is provided, also work with tan(x). Moreover, if
294             # n > 1, also work with sin(k*x) for k <= n, and similarly for cos
295             # (and tan if the hint is provided). Finally, any generators which
296             # the ideal does not work with but we need to accomodate (either
297             # because it was in expr or because it was provided as a hint)
298             # we also build into the ideal.
299             # This selection process is expressed in the list ``terms``.
300             # build_ideal then generates the actual relations in our ideal,
301             # from this list.
302             fns = [x[1] for x in val]
303             val = [x[0] for x in val]
304             gcd = reduce(igcd, val)
305             terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]
306             fs = set(funcs + fns)
307             for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):
308                 if any(x in fs for x in (c, s, t)):
309                     fs.add(c)
310                     fs.add(s)
311             for fn in fs:
312                 for k in range(1, n + 1):
313                     terms.append((fn, k))
314             extra = []
315             for fn, v in terms:
316                 if fn == tan:
317                     extra.append((sin, v))
318                     extra.append((cos, v))
319                 if fn in [sin, cos] and tan in fs:
320                     extra.append((tan, v))
321                 if fn == tanh:
322                     extra.append((sinh, v))
323                     extra.append((cosh, v))
324                 if fn in [sinh, cosh] and tanh in fs:
325                     extra.append((tanh, v))
326             terms.extend(extra)
327             x = gcd*Mul(*key)
328             r = build_ideal(x, terms)
329             res.extend(r)
330             newgens.extend(set(fn(v*x) for fn, v in terms))
331 
332         # Add generators for compound expressions from iterables
333         for fn, args in iterables:
334             if fn == tan:
335                 # Tan expressions are recovered from sin and cos.
336                 iterables.extend([(sin, args), (cos, args)])
337             elif fn == tanh:
338                 # Tanh expressions are recovered from sihn and cosh.
339                 iterables.extend([(sinh, args), (cosh, args)])
340             else:
341                 dummys = symbols('d:%i' % len(args), cls=Dummy)
342                 expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))
343                 res.append(fn(Add(*args)) - expr)
344 
345         if myI in gens:
346             res.append(myI**2 + 1)
347             freegens.remove(myI)
348             newgens.append(myI)
349 
350         return res, freegens, newgens
351 
352     myI = Dummy('I')
353     expr = expr.subs(S.ImaginaryUnit, myI)
354     subs = [(myI, S.ImaginaryUnit)]
355 
356     num, denom = cancel(expr).as_numer_denom()
357     try:
358         (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])
359     except PolificationFailed:
360         return expr
361     debug('initial gens:', opt.gens)
362     ideal, freegens, gens = analyse_gens(opt.gens, hints)
363     debug('ideal:', ideal)
364     debug('new gens:', gens, " -- len", len(gens))
365     debug('free gens:', freegens, " -- len", len(gens))
366     # NOTE we force the domain to be ZZ to stop polys from injecting generators
367     #      (which is usually a sign of a bug in the way we build the ideal)
368     if not gens:
369         return expr
370     G = groebner(ideal, order=order, gens=gens, domain=ZZ)
371     debug('groebner basis:', list(G), " -- len", len(G))
372 
373     # If our fraction is a polynomial in the free generators, simplify all
374     # coefficients separately:
375 
376     from sympy.simplify.ratsimp import ratsimpmodprime
377 
378     if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):
379         num = Poly(num, gens=gens+freegens).eject(*gens)
380         res = []
381         for monom, coeff in num.terms():
382             ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)
383             # We compute the transitive closure of all generators that can
384             # be reached from our generators through relations in the ideal.
385             changed = True
386             while changed:
387                 changed = False
388                 for p in ideal:
389                     p = Poly(p)
390                     if not ourgens.issuperset(p.gens) and \
391                        not p.has_only_gens(*set(p.gens).difference(ourgens)):
392                         changed = True
393                         ourgens.update(p.exclude().gens)
394             # NOTE preserve order!
395             realgens = [x for x in gens if x in ourgens]
396             # The generators of the ideal have now been (implicitely) split
397             # into two groups: those involving ourgens and those that don't.
398             # Since we took the transitive closure above, these two groups
399             # live in subgrings generated by a *disjoint* set of variables.
400             # Any sensible groebner basis algorithm will preserve this disjoint
401             # structure (i.e. the elements of the groebner basis can be split
402             # similarly), and and the two subsets of the groebner basis then
403             # form groebner bases by themselves. (For the smaller generating
404             # sets, of course.)
405             ourG = [g.as_expr() for g in G.polys if
406                     g.has_only_gens(*ourgens.intersection(g.gens))]
407             res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \
408                        ratsimpmodprime(coeff/denom, ourG, order=order,
409                                        gens=realgens, quick=quick, domain=ZZ,
410                                        polynomial=polynomial).subs(subs))
411         return Add(*res)
412         # NOTE The following is simpler and has less assumptions on the
413         #      groebner basis algorithm. If the above turns out to be broken,
414         #      use this.
415         return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \
416                      ratsimpmodprime(coeff/denom, list(G), order=order,
417                                      gens=gens, quick=quick, domain=ZZ)
418                      for monom, coeff in num.terms()])
419     else:
420         return ratsimpmodprime(
421             expr, list(G), order=order, gens=freegens+gens,
422             quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)
423 
424 
425 _trigs = (TrigonometricFunction, HyperbolicFunction)
426 
427 
428 def trigsimp(expr, **opts):
429     """
430     reduces expression by using known trig identities
431 
432     Notes
433     =====
434 
435     method:
436     - Determine the method to use. Valid choices are 'matching' (default),
437     'groebner', 'combined', and 'fu'. If 'matching', simplify the
438     expression recursively by targeting common patterns. If 'groebner', apply
439     an experimental groebner basis algorithm. In this case further options
440     are forwarded to ``trigsimp_groebner``, please refer to its docstring.
441     If 'combined', first run the groebner basis algorithm with small
442     default parameters, then run the 'matching' algorithm. 'fu' runs the
443     collection of trigonometric transformations described by Fu, et al.
444     (see the `fu` docstring).
445 
446 
447     Examples
448     ========
449 
450     >>> from sympy import trigsimp, sin, cos, log
451     >>> from sympy.abc import x, y
452     >>> e = 2*sin(x)**2 + 2*cos(x)**2
453     >>> trigsimp(e)
454     2
455 
456     Simplification occurs wherever trigonometric functions are located.
457 
458     >>> trigsimp(log(e))
459     log(2)
460 
461     Using `method="groebner"` (or `"combined"`) might lead to greater
462     simplification.
463 
464     The old trigsimp routine can be accessed as with method 'old'.
465 
466     >>> from sympy import coth, tanh
467     >>> t = 3*tanh(x)**7 - 2/coth(x)**7
468     >>> trigsimp(t, method='old') == t
469     True
470     >>> trigsimp(t)
471     tanh(x)**7
472 
473     """
474     from sympy.simplify.fu import fu
475 
476     expr = sympify(expr)
477 
478     try:
479         return expr._eval_trigsimp(**opts)
480     except AttributeError:
481         pass
482 
483     old = opts.pop('old', False)
484     if not old:
485         opts.pop('deep', None)
486         recursive = opts.pop('recursive', None)
487         method = opts.pop('method', 'matching')
488     else:
489         method = 'old'
490 
491     def groebnersimp(ex, **opts):
492         def traverse(e):
493             if e.is_Atom:
494                 return e
495             args = [traverse(x) for x in e.args]
496             if e.is_Function or e.is_Pow:
497                 args = [trigsimp_groebner(x, **opts) for x in args]
498             return e.func(*args)
499         new = traverse(ex)
500         if not isinstance(new, Expr):
501             return new
502         return trigsimp_groebner(new, **opts)
503 
504     trigsimpfunc = {
505         'fu': (lambda x: fu(x, **opts)),
506         'matching': (lambda x: futrig(x)),
507         'groebner': (lambda x: groebnersimp(x, **opts)),
508         'combined': (lambda x: futrig(groebnersimp(x,
509                                polynomial=True, hints=[2, tan]))),
510         'old': lambda x: trigsimp_old(x, **opts),
511                    }[method]
512 
513     return trigsimpfunc(expr)
514 
515 
516 def exptrigsimp(expr):
517     """
518     Simplifies exponential / trigonometric / hyperbolic functions.
519 
520     Examples
521     ========
522 
523     >>> from sympy import exptrigsimp, exp, cosh, sinh
524     >>> from sympy.abc import z
525 
526     >>> exptrigsimp(exp(z) + exp(-z))
527     2*cosh(z)
528     >>> exptrigsimp(cosh(z) - sinh(z))
529     exp(-z)
530     """
531     from sympy.simplify.fu import hyper_as_trig, TR2i
532     from sympy.simplify.simplify import bottom_up
533 
534     def exp_trig(e):
535         # select the better of e, and e rewritten in terms of exp or trig
536         # functions
537         choices = [e]
538         if e.has(*_trigs):
539             choices.append(e.rewrite(exp))
540         choices.append(e.rewrite(cos))
541         return min(*choices, key=count_ops)
542     newexpr = bottom_up(expr, exp_trig)
543 
544     def f(rv):
545         if not rv.is_Mul:
546             return rv
547         rvd = rv.as_powers_dict()
548         newd = rvd.copy()
549 
550         def signlog(expr, sign=1):
551             if expr is S.Exp1:
552                 return sign, 1
553             elif isinstance(expr, exp):
554                 return sign, expr.args[0]
555             elif sign == 1:
556                 return signlog(-expr, sign=-1)
557             else:
558                 return None, None
559 
560         ee = rvd[S.Exp1]
561         for k in rvd:
562             if k.is_Add and len(k.args) == 2:
563                 # k == c*(1 + sign*E**x)
564                 c = k.args[0]
565                 sign, x = signlog(k.args[1]/c)
566                 if not x:
567                     continue
568                 m = rvd[k]
569                 newd[k] -= m
570                 if ee == -x*m/2:
571                     # sinh and cosh
572                     newd[S.Exp1] -= ee
573                     ee = 0
574                     if sign == 1:
575                         newd[2*c*cosh(x/2)] += m
576                     else:
577                         newd[-2*c*sinh(x/2)] += m
578                 elif newd[1 - sign*S.Exp1**x] == -m:
579                     # tanh
580                     del newd[1 - sign*S.Exp1**x]
581                     if sign == 1:
582                         newd[-c/tanh(x/2)] += m
583                     else:
584                         newd[-c*tanh(x/2)] += m
585                 else:
586                     newd[1 + sign*S.Exp1**x] += m
587                     newd[c] += m
588 
589         return Mul(*[k**newd[k] for k in newd])
590     newexpr = bottom_up(newexpr, f)
591 
592     # sin/cos and sinh/cosh ratios to tan and tanh, respectively
593     if newexpr.has(HyperbolicFunction):
594         e, f = hyper_as_trig(newexpr)
595         newexpr = f(TR2i(e))
596     if newexpr.has(TrigonometricFunction):
597         newexpr = TR2i(newexpr)
598 
599     # can we ever generate an I where there was none previously?
600     if not (newexpr.has(I) and not expr.has(I)):
601         expr = newexpr
602     return expr
603 
604 #-------------------- the old trigsimp routines ---------------------
605 
606 def trigsimp_old(expr, **opts):
607     """
608     reduces expression by using known trig identities
609 
610     Notes
611     =====
612 
613     deep:
614     - Apply trigsimp inside all objects with arguments
615 
616     recursive:
617     - Use common subexpression elimination (cse()) and apply
618     trigsimp recursively (this is quite expensive if the
619     expression is large)
620 
621     method:
622     - Determine the method to use. Valid choices are 'matching' (default),
623     'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the
624     expression recursively by pattern matching. If 'groebner', apply an
625     experimental groebner basis algorithm. In this case further options
626     are forwarded to ``trigsimp_groebner``, please refer to its docstring.
627     If 'combined', first run the groebner basis algorithm with small
628     default parameters, then run the 'matching' algorithm. 'fu' runs the
629     collection of trigonometric transformations described by Fu, et al.
630     (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms
631     that mimic the behavior of `trigsimp`.
632 
633     compare:
634     - show input and output from `trigsimp` and `futrig` when different,
635     but returns the `trigsimp` value.
636 
637     Examples
638     ========
639 
640     >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot
641     >>> from sympy.abc import x, y
642     >>> e = 2*sin(x)**2 + 2*cos(x)**2
643     >>> trigsimp(e, old=True)
644     2
645     >>> trigsimp(log(e), old=True)
646     log(2*sin(x)**2 + 2*cos(x)**2)
647     >>> trigsimp(log(e), deep=True, old=True)
648     log(2)
649 
650     Using `method="groebner"` (or `"combined"`) can sometimes lead to a lot
651     more simplification:
652 
653     >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)
654     >>> trigsimp(e, old=True)
655     (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)
656     >>> trigsimp(e, method="groebner", old=True)
657     2/cos(x)
658 
659     >>> trigsimp(1/cot(x)**2, compare=True, old=True)
660           futrig: tan(x)**2
661     cot(x)**(-2)
662 
663     """
664     old = expr
665     first = opts.pop('first', True)
666     if first:
667         if not expr.has(*_trigs):
668             return expr
669 
670         trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])
671         if len(trigsyms) > 1:
672             d = separatevars(expr)
673             if d.is_Mul:
674                 d = separatevars(d, dict=True) or d
675             if isinstance(d, dict):
676                 expr = 1
677                 for k, v in d.items():
678                     # remove hollow factoring
679                     was = v
680                     v = expand_mul(v)
681                     opts['first'] = False
682                     vnew = trigsimp(v, **opts)
683                     if vnew == v:
684                         vnew = was
685                     expr *= vnew
686                 old = expr
687             else:
688                 if d.is_Add:
689                     for s in trigsyms:
690                         r, e = expr.as_independent(s)
691                         if r:
692                             opts['first'] = False
693                             expr = r + trigsimp(e, **opts)
694                             if not expr.is_Add:
695                                 break
696                     old = expr
697 
698     recursive = opts.pop('recursive', False)
699     deep = opts.pop('deep', False)
700     method = opts.pop('method', 'matching')
701 
702     def groebnersimp(ex, deep, **opts):
703         def traverse(e):
704             if e.is_Atom:
705                 return e
706             args = [traverse(x) for x in e.args]
707             if e.is_Function or e.is_Pow:
708                 args = [trigsimp_groebner(x, **opts) for x in args]
709             return e.func(*args)
710         if deep:
711             ex = traverse(ex)
712         return trigsimp_groebner(ex, **opts)
713 
714     trigsimpfunc = {
715         'matching': (lambda x, d: _trigsimp(x, d)),
716         'groebner': (lambda x, d: groebnersimp(x, d, **opts)),
717         'combined': (lambda x, d: _trigsimp(groebnersimp(x,
718                                        d, polynomial=True, hints=[2, tan]),
719                                    d))
720                    }[method]
721 
722     if recursive:
723         w, g = cse(expr)
724         g = trigsimpfunc(g[0], deep)
725 
726         for sub in reversed(w):
727             g = g.subs(sub[0], sub[1])
728             g = trigsimpfunc(g, deep)
729         result = g
730     else:
731         result = trigsimpfunc(expr, deep)
732 
733     if opts.get('compare', False):
734         f = futrig(old)
735         if f != result:
736             print('\tfutrig:', f)
737 
738     return result
739 
740 
741 def _dotrig(a, b):
742     """Helper to tell whether ``a`` and ``b`` have the same sorts
743     of symbols in them -- no need to test hyperbolic patterns against
744     expressions that have no hyperbolics in them."""
745     return a.func == b.func and (
746         a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or
747         a.has(HyperbolicFunction) and b.has(HyperbolicFunction))
748 
749 
750 _trigpat = None
751 def _trigpats():
752     global _trigpat
753     a, b, c = symbols('a b c', cls=Wild)
754     d = Wild('d', commutative=False)
755 
756     # for the simplifications like sinh/cosh -> tanh:
757     # DO NOT REORDER THE FIRST 14 since these are assumed to be in this
758     # order in _match_div_rewrite.
759     matchers_division = (
760         (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),
761         (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),
762         (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),
763         (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),
764         (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),
765         (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),
766         (a*(cos(b) + 1)**c*(cos(b) - 1)**c,
767             a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),
768         (a*(sin(b) + 1)**c*(sin(b) - 1)**c,
769             a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),
770 
771         (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),
772         (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),
773         (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),
774         (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),
775         (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),
776         (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),
777 
778         (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),
779             tanh(a + b)*c, S.One, S.One),
780     )
781 
782     matchers_add = (
783         (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),
784         (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),
785         (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),
786         (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),
787         (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),
788         (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),
789     )
790 
791     # for cos(x)**2 + sin(x)**2 -> 1
792     matchers_identity = (
793         (a*sin(b)**2, a - a*cos(b)**2),
794         (a*tan(b)**2, a*(1/cos(b))**2 - a),
795         (a*cot(b)**2, a*(1/sin(b))**2 - a),
796         (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),
797         (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),
798         (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),
799 
800         (a*sinh(b)**2, a*cosh(b)**2 - a),
801         (a*tanh(b)**2, a - a*(1/cosh(b))**2),
802         (a*coth(b)**2, a + a*(1/sinh(b))**2),
803         (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),
804         (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),
805         (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),
806 
807     )
808 
809     # Reduce any lingering artifacts, such as sin(x)**2 changing
810     # to 1-cos(x)**2 when sin(x)**2 was "simpler"
811     artifacts = (
812         (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),
813         (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),
814         (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),
815 
816         (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),
817         (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),
818         (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),
819 
820         # same as above but with noncommutative prefactor
821         (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),
822         (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),
823         (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),
824 
825         (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),
826         (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),
827         (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),
828     )
829 
830     _trigpat = (a, b, c, d, matchers_division, matchers_add,
831         matchers_identity, artifacts)
832     return _trigpat
833 
834 
835 def _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):
836     """Helper for _match_div_rewrite.
837 
838     Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)
839     and g(b_) are both positive or if c_ is an integer.
840     """
841     # assert expr.is_Mul and expr.is_commutative and f != g
842     fargs = defaultdict(int)
843     gargs = defaultdict(int)
844     args = []
845     for x in expr.args:
846         if x.is_Pow or x.func in (f, g):
847             b, e = x.as_base_exp()
848             if b.is_positive or e.is_integer:
849                 if b.func == f:
850                     fargs[b.args[0]] += e
851                     continue
852                 elif b.func == g:
853                     gargs[b.args[0]] += e
854                     continue
855         args.append(x)
856     common = set(fargs) & set(gargs)
857     hit = False
858     while common:
859         key = common.pop()
860         fe = fargs.pop(key)
861         ge = gargs.pop(key)
862         if fe == rexp(ge):
863             args.append(h(key)**rexph(fe))
864             hit = True
865         else:
866             fargs[key] = fe
867             gargs[key] = ge
868     if not hit:
869         return expr
870     while fargs:
871         key, e = fargs.popitem()
872         args.append(f(key)**e)
873     while gargs:
874         key, e = gargs.popitem()
875         args.append(g(key)**e)
876     return Mul(*args)
877 
878 
879 _idn = lambda x: x
880 _midn = lambda x: -x
881 _one = lambda x: S.One
882 
883 def _match_div_rewrite(expr, i):
884     """helper for __trigsimp"""
885     if i == 0:
886         expr = _replace_mul_fpowxgpow(expr, sin, cos,
887             _midn, tan, _idn)
888     elif i == 1:
889         expr = _replace_mul_fpowxgpow(expr, tan, cos,
890             _idn, sin, _idn)
891     elif i == 2:
892         expr = _replace_mul_fpowxgpow(expr, cot, sin,
893             _idn, cos, _idn)
894     elif i == 3:
895         expr = _replace_mul_fpowxgpow(expr, tan, sin,
896             _midn, cos, _midn)
897     elif i == 4:
898         expr = _replace_mul_fpowxgpow(expr, cot, cos,
899             _midn, sin, _midn)
900     elif i == 5:
901         expr = _replace_mul_fpowxgpow(expr, cot, tan,
902             _idn, _one, _idn)
903     # i in (6, 7) is skipped
904     elif i == 8:
905         expr = _replace_mul_fpowxgpow(expr, sinh, cosh,
906             _midn, tanh, _idn)
907     elif i == 9:
908         expr = _replace_mul_fpowxgpow(expr, tanh, cosh,
909             _idn, sinh, _idn)
910     elif i == 10:
911         expr = _replace_mul_fpowxgpow(expr, coth, sinh,
912             _idn, cosh, _idn)
913     elif i == 11:
914         expr = _replace_mul_fpowxgpow(expr, tanh, sinh,
915             _midn, cosh, _midn)
916     elif i == 12:
917         expr = _replace_mul_fpowxgpow(expr, coth, cosh,
918             _midn, sinh, _midn)
919     elif i == 13:
920         expr = _replace_mul_fpowxgpow(expr, coth, tanh,
921             _idn, _one, _idn)
922     else:
923         return None
924     return expr
925 
926 
927 def _trigsimp(expr, deep=False):
928     # protect the cache from non-trig patterns; we only allow
929     # trig patterns to enter the cache
930     if expr.has(*_trigs):
931         return __trigsimp(expr, deep)
932     return expr
933 
934 
935 @cacheit
936 def __trigsimp(expr, deep=False):
937     """recursive helper for trigsimp"""
938     from sympy.simplify.fu import TR10i
939 
940     if _trigpat is None:
941         _trigpats()
942     a, b, c, d, matchers_division, matchers_add, \
943     matchers_identity, artifacts = _trigpat
944 
945     if expr.is_Mul:
946         # do some simplifications like sin/cos -> tan:
947         if not expr.is_commutative:
948             com, nc = expr.args_cnc()
949             expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)
950         else:
951             for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):
952                 if not _dotrig(expr, pattern):
953                     continue
954 
955                 newexpr = _match_div_rewrite(expr, i)
956                 if newexpr is not None:
957                     if newexpr != expr:
958                         expr = newexpr
959                         break
960                     else:
961                         continue
962 
963                 # use SymPy matching instead
964                 res = expr.match(pattern)
965                 if res and res.get(c, 0):
966                     if not res[c].is_integer:
967                         ok = ok1.subs(res)
968                         if not ok.is_positive:
969                             continue
970                         ok = ok2.subs(res)
971                         if not ok.is_positive:
972                             continue
973                     # if "a" contains any of trig or hyperbolic funcs with
974                     # argument "b" then skip the simplification
975                     if any(w.args[0] == res[b] for w in res[a].atoms(
976                             TrigonometricFunction, HyperbolicFunction)):
977                         continue
978                     # simplify and finish:
979                     expr = simp.subs(res)
980                     break  # process below
981 
982     if expr.is_Add:
983         args = []
984         for term in expr.args:
985             if not term.is_commutative:
986                 com, nc = term.args_cnc()
987                 nc = Mul._from_args(nc)
988                 term = Mul._from_args(com)
989             else:
990                 nc = S.One
991             term = _trigsimp(term, deep)
992             for pattern, result in matchers_identity:
993                 res = term.match(pattern)
994                 if res is not None:
995                     term = result.subs(res)
996                     break
997             args.append(term*nc)
998         if args != expr.args:
999             expr = Add(*args)
1000             expr = min(expr, expand(expr), key=count_ops)
1001         if expr.is_Add:
1002             for pattern, result in matchers_add:
1003                 if not _dotrig(expr, pattern):
1004                     continue
1005                 expr = TR10i(expr)
1006                 if expr.has(HyperbolicFunction):
1007                     res = expr.match(pattern)
1008                     # if "d" contains any trig or hyperbolic funcs with
1009                     # argument "a" or "b" then skip the simplification;
1010                     # this isn't perfect -- see tests
1011                     if res is None or not (a in res and b in res) or any(
1012                         w.args[0] in (res[a], res[b]) for w in res[d].atoms(
1013                             TrigonometricFunction, HyperbolicFunction)):
1014                         continue
1015                     expr = result.subs(res)
1016                     break
1017 
1018         # Reduce any lingering artifacts, such as sin(x)**2 changing
1019         # to 1 - cos(x)**2 when sin(x)**2 was "simpler"
1020         for pattern, result, ex in artifacts:
1021             if not _dotrig(expr, pattern):
1022                 continue
1023             # Substitute a new wild that excludes some function(s)
1024             # to help influence a better match. This is because
1025             # sometimes, for example, 'a' would match sec(x)**2
1026             a_t = Wild('a', exclude=[ex])
1027             pattern = pattern.subs(a, a_t)
1028             result = result.subs(a, a_t)
1029 
1030             m = expr.match(pattern)
1031             was = None
1032             while m and was != expr:
1033                 was = expr
1034                 if m[a_t] == 0 or \
1035                         -m[a_t] in m[c].args or m[a_t] + m[c] == 0:
1036                     break
1037                 if d in m and m[a_t]*m[d] + m[c] == 0:
1038                     break
1039                 expr = result.subs(m)
1040                 m = expr.match(pattern)
1041                 m.setdefault(c, S.Zero)
1042 
1043     elif expr.is_Mul or expr.is_Pow or deep and expr.args:
1044         expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])
1045 
1046     try:
1047         if not expr.has(*_trigs):
1048             raise TypeError
1049         e = expr.atoms(exp)
1050         new = expr.rewrite(exp, deep=deep)
1051         if new == e:
1052             raise TypeError
1053         fnew = factor(new)
1054         if fnew != new:
1055             new = sorted([new, factor(new)], key=count_ops)[0]
1056         # if all exp that were introduced disappeared then accept it
1057         if not (new.atoms(exp) - e):
1058             expr = new
1059     except TypeError:
1060         pass
1061 
1062     return expr
1063 #------------------- end of old trigsimp routines --------------------
1064 
1065 
1066 def futrig(e, **kwargs):
1067     """Return simplified ``e`` using Fu-like transformations.
1068     This is not the "Fu" algorithm. This is called by default
1069     from ``trigsimp``. By default, hyperbolics subexpressions
1070     will be simplified, but this can be disabled by setting
1071     ``hyper=False``.
1072 
1073     Examples
1074     ========
1075 
1076     >>> from sympy import trigsimp, tan, sinh, tanh
1077     >>> from sympy.simplify.trigsimp import futrig
1078     >>> from sympy.abc import x
1079     >>> trigsimp(1/tan(x)**2)
1080     tan(x)**(-2)
1081 
1082     >>> futrig(sinh(x)/tanh(x))
1083     cosh(x)
1084 
1085     """
1086     from sympy.simplify.fu import hyper_as_trig
1087     from sympy.simplify.simplify import bottom_up
1088 
1089     e = sympify(e)
1090 
1091     if not isinstance(e, Basic):
1092         return e
1093 
1094     if not e.args:
1095         return e
1096 
1097     old = e
1098     e = bottom_up(e, lambda x: _futrig(x, **kwargs))
1099 
1100     if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):
1101         e, f = hyper_as_trig(e)
1102         e = f(_futrig(e))
1103 
1104     if e != old and e.is_Mul and e.args[0].is_Rational:
1105         # redistribute leading coeff on 2-arg Add
1106         e = Mul(*e.as_coeff_Mul())
1107     return e
1108 
1109 
1110 def _futrig(e, **kwargs):
1111     """Helper for futrig."""
1112     from sympy.simplify.fu import (
1113         TR1, TR2, TR3, TR2i, TR10, L, TR10i,
1114         TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,
1115         TR12)
1116     from sympy.core.compatibility import _nodes
1117 
1118     if not e.has(TrigonometricFunction):
1119         return e
1120 
1121     if e.is_Mul:
1122         coeff, e = e.as_independent(TrigonometricFunction)
1123     else:
1124         coeff = S.One
1125 
1126     Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)
1127     trigs = lambda x: x.has(TrigonometricFunction)
1128 
1129     tree = [identity,
1130         (
1131         TR3,  # canonical angles
1132         TR1,  # sec-csc -> cos-sin
1133         TR12,  # expand tan of sum
1134         lambda x: _eapply(factor, x, trigs),
1135         TR2,  # tan-cot -> sin-cos
1136         [identity, lambda x: _eapply(_mexpand, x, trigs)],
1137         TR2i,  # sin-cos ratio -> tan
1138         lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),
1139         TR14,  # factored identities
1140         TR5,  # sin-pow -> cos_pow
1141         TR10,  # sin-cos of sums -> sin-cos prod
1142         TR11, TR6, # reduce double angles and rewrite cos pows
1143         lambda x: _eapply(factor, x, trigs),
1144         TR14,  # factored powers of identities
1145         [identity, lambda x: _eapply(_mexpand, x, trigs)],
1146         TRmorrie,
1147         TR10i,  # sin-cos products > sin-cos of sums
1148         [identity, TR8],  # sin-cos products -> sin-cos of sums
1149         [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan
1150         [
1151             lambda x: _eapply(expand_mul, TR5(x), trigs),
1152             lambda x: _eapply(
1153                 expand_mul, TR15(x), trigs)], # pos/neg powers of sin
1154         [
1155             lambda x:  _eapply(expand_mul, TR6(x), trigs),
1156             lambda x:  _eapply(
1157                 expand_mul, TR16(x), trigs)], # pos/neg powers of cos
1158         TR111,  # tan, sin, cos to neg power -> cot, csc, sec
1159         [identity, TR2i],  # sin-cos ratio to tan
1160         [identity, lambda x: _eapply(
1161             expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc
1162         TR1, TR2, TR2i,
1163         [identity, lambda x: _eapply(
1164             factor_terms, TR12(x), trigs)],  # expand tan of sum
1165         )]
1166     e = greedy(tree, objective=Lops)(e)
1167 
1168     return coeff*e
1169 
1170 
1171 def _is_Expr(e):
1172     """_eapply helper to tell whether ``e`` and all its args
1173     are Exprs."""
1174     if not isinstance(e, Expr):
1175         return False
1176     return all(_is_Expr(i) for i in e.args)
1177 
1178 
1179 def _eapply(func, e, cond=None):
1180     """Apply ``func`` to ``e`` if all args are Exprs else only
1181     apply it to those args that *are* Exprs."""
1182     if not isinstance(e, Expr):
1183         return e
1184     if _is_Expr(e) or not e.args:
1185         return func(e)
1186     return e.func(*[
1187         _eapply(func, ei) if (cond is None or cond(ei)) else ei
1188         for ei in e.args])

</code><intended_behavior>Ensure the simplification logic correctly identifies and processes trigonometric functions with complex arguments, particularly avoiding incorrect transformations into cosh functions unless mathematically valid.</intended_behavior>, <file>sympy/functions/elementary/trigonometric.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core.add import Add
4 from sympy.core.basic import sympify, cacheit
5 from sympy.core.function import Function, ArgumentIndexError
6 from sympy.core.numbers import igcdex, Rational, pi
7 from sympy.core.singleton import S
8 from sympy.core.symbol import Symbol, Wild
9 from sympy.core.logic import fuzzy_not
10 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
11 from sympy.functions.elementary.miscellaneous import sqrt, Min, Max
12 from sympy.functions.elementary.exponential import log, exp
13 from sympy.functions.elementary.integers import floor
14 from sympy.functions.elementary.hyperbolic import (acoth, asinh, atanh, cosh,
15     coth, HyperbolicFunction, sinh, tanh)
16 from sympy.sets.sets import FiniteSet
17 from sympy.utilities.iterables import numbered_symbols
18 from sympy.core.compatibility import range
19 
20 ###############################################################################
21 ########################## TRIGONOMETRIC FUNCTIONS ############################
22 ###############################################################################
23 
24 
25 class TrigonometricFunction(Function):
26     """Base class for trigonometric functions. """
27 
28     unbranched = True
29 
30     def _eval_is_rational(self):
31         s = self.func(*self.args)
32         if s.func == self.func:
33             if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):
34                 return False
35         else:
36             return s.is_rational
37 
38     def _eval_is_algebraic(self):
39         s = self.func(*self.args)
40         if s.func == self.func:
41             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
42                 return False
43             pi_coeff = _pi_coeff(self.args[0])
44             if pi_coeff is not None and pi_coeff.is_rational:
45                 return True
46         else:
47             return s.is_algebraic
48 
49     def _eval_expand_complex(self, deep=True, **hints):
50         re_part, im_part = self.as_real_imag(deep=deep, **hints)
51         return re_part + im_part*S.ImaginaryUnit
52 
53     def _as_real_imag(self, deep=True, **hints):
54         if self.args[0].is_real:
55             if deep:
56                 hints['complex'] = False
57                 return (self.args[0].expand(deep, **hints), S.Zero)
58             else:
59                 return (self.args[0], S.Zero)
60         if deep:
61             re, im = self.args[0].expand(deep, **hints).as_real_imag()
62         else:
63             re, im = self.args[0].as_real_imag()
64         return (re, im)
65 
66     def _period(self, general_period, symbol=None):
67         f = self.args[0]
68         if symbol is None:
69             symbol = tuple(f.free_symbols)[0]
70 
71         if not f.has(symbol):
72             return S.Zero
73 
74         if f == symbol:
75             return general_period
76 
77         if symbol in f.free_symbols:
78             p, q = Wild('p'), Wild('q')
79             if f.is_Mul:
80                 g, h = f.as_independent(symbol)
81                 if h == symbol:
82                     return general_period/abs(g)
83 
84             if f.is_Add:
85                 a, h = f.as_independent(symbol)
86                 g, h = h.as_independent(symbol, as_Add=False)
87                 if h == symbol:
88                     return general_period/abs(g)
89 
90         raise NotImplementedError("Use the periodicity function instead.")
91 
92 
93 def _peeloff_pi(arg):
94     """
95     Split ARG into two parts, a "rest" and a multiple of pi/2.
96     This assumes ARG to be an Add.
97     The multiple of pi returned in the second position is always a Rational.
98 
99     Examples
100     ========
101 
102     >>> from sympy.functions.elementary.trigonometric import _peeloff_pi as peel
103     >>> from sympy import pi
104     >>> from sympy.abc import x, y
105     >>> peel(x + pi/2)
106     (x, pi/2)
107     >>> peel(x + 2*pi/3 + pi*y)
108     (x + pi*y + pi/6, pi/2)
109     """
110     for a in Add.make_args(arg):
111         if a is S.Pi:
112             K = S.One
113             break
114         elif a.is_Mul:
115             K, p = a.as_two_terms()
116             if p is S.Pi and K.is_Rational:
117                 break
118     else:
119         return arg, S.Zero
120 
121     m1 = (K % S.Half) * S.Pi
122     m2 = K*S.Pi - m1
123     return arg - m2, m2
124 
125 
126 def _pi_coeff(arg, cycles=1):
127     """
128     When arg is a Number times pi (e.g. 3*pi/2) then return the Number
129     normalized to be in the range [0, 2], else None.
130 
131     When an even multiple of pi is encountered, if it is multiplying
132     something with known parity then the multiple is returned as 0 otherwise
133     as 2.
134 
135     Examples
136     ========
137 
138     >>> from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
139     >>> from sympy import pi, Dummy
140     >>> from sympy.abc import x, y
141     >>> coeff(3*x*pi)
142     3*x
143     >>> coeff(11*pi/7)
144     11/7
145     >>> coeff(-11*pi/7)
146     3/7
147     >>> coeff(4*pi)
148     0
149     >>> coeff(5*pi)
150     1
151     >>> coeff(5.0*pi)
152     1
153     >>> coeff(5.5*pi)
154     3/2
155     >>> coeff(2 + pi)
156 
157     >>> coeff(2*Dummy(integer=True)*pi)
158     2
159     >>> coeff(2*Dummy(even=True)*pi)
160     0
161     """
162     arg = sympify(arg)
163     if arg is S.Pi:
164         return S.One
165     elif not arg:
166         return S.Zero
167     elif arg.is_Mul:
168         cx = arg.coeff(S.Pi)
169         if cx:
170             c, x = cx.as_coeff_Mul()  # pi is not included as coeff
171             if c.is_Float:
172                 # recast exact binary fractions to Rationals
173                 f = abs(c) % 1
174                 if f != 0:
175                     p = -int(round(log(f, 2).evalf()))
176                     m = 2**p
177                     cm = c*m
178                     i = int(cm)
179                     if i == cm:
180                         c = Rational(i, m)
181                         cx = c*x
182                 else:
183                     c = Rational(int(c))
184                     cx = c*x
185             if x.is_integer:
186                 c2 = c % 2
187                 if c2 == 1:
188                     return x
189                 elif not c2:
190                     if x.is_even is not None:  # known parity
191                         return S.Zero
192                     return S(2)
193                 else:
194                     return c2*x
195             return cx
196 
197 
198 class sin(TrigonometricFunction):
199     """
200     The sine function.
201 
202     Returns the sine of x (measured in radians).
203 
204     Notes
205     =====
206 
207     This function will evaluate automatically in the
208     case x/pi is some rational number [4]_.  For example,
209     if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.
210 
211     Examples
212     ========
213 
214     >>> from sympy import sin, pi
215     >>> from sympy.abc import x
216     >>> sin(x**2).diff(x)
217     2*x*cos(x**2)
218     >>> sin(1).diff(x)
219     0
220     >>> sin(pi)
221     0
222     >>> sin(pi/2)
223     1
224     >>> sin(pi/6)
225     1/2
226     >>> sin(pi/12)
227     -sqrt(2)/4 + sqrt(6)/4
228 
229 
230     See Also
231     ========
232 
233     csc, cos, sec, tan, cot
234     asin, acsc, acos, asec, atan, acot, atan2
235 
236     References
237     ==========
238 
239     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
240     .. [2] http://dlmf.nist.gov/4.14
241     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin
242     .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html
243     """
244 
245     def period(self, symbol=None):
246         return self._period(2*pi, symbol)
247 
248     def fdiff(self, argindex=1):
249         if argindex == 1:
250             return cos(self.args[0])
251         else:
252             raise ArgumentIndexError(self, argindex)
253 
254     @classmethod
255     def eval(cls, arg):
256         from sympy.calculus import AccumBounds
257         if arg.is_Number:
258             if arg is S.NaN:
259                 return S.NaN
260             elif arg is S.Zero:
261                 return S.Zero
262             elif arg is S.Infinity or arg is S.NegativeInfinity:
263                 return AccumBounds(-1, 1)
264 
265         if isinstance(arg, AccumBounds):
266             min, max = arg.min, arg.max
267             d = floor(min/(2*S.Pi))
268             if min is not S.NegativeInfinity:
269                 min = min - d*2*S.Pi
270             if max is not S.Infinity:
271                 max = max - d*2*S.Pi
272             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
273                     is not S.EmptySet and \
274                     AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,
275                         7*S.Pi/2)) is not S.EmptySet:
276                 return AccumBounds(-1, 1)
277             elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
278                     is not S.EmptySet:
279                 return AccumBounds(Min(sin(min), sin(max)), 1)
280             elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \
281                         is not S.EmptySet:
282                 return AccumBounds(-1, Max(sin(min), sin(max)))
283             else:
284                 return AccumBounds(Min(sin(min), sin(max)),
285                                 Max(sin(min), sin(max)))
286 
287         if arg.could_extract_minus_sign():
288             return -cls(-arg)
289 
290         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
291         if i_coeff is not None:
292             return S.ImaginaryUnit * sinh(i_coeff)
293 
294         pi_coeff = _pi_coeff(arg)
295         if pi_coeff is not None:
296             if pi_coeff.is_integer:
297                 return S.Zero
298 
299             if (2*pi_coeff).is_integer:
300                 if pi_coeff.is_even:
301                     return S.Zero
302                 elif pi_coeff.is_even is False:
303                     return S.NegativeOne**(pi_coeff - S.Half)
304 
305             if not pi_coeff.is_Rational:
306                 narg = pi_coeff*S.Pi
307                 if narg != arg:
308                     return cls(narg)
309                 return None
310 
311             # https://github.com/sympy/sympy/issues/6048
312             # transform a sine to a cosine, to avoid redundant code
313             if pi_coeff.is_Rational:
314                 x = pi_coeff % 2
315                 if x > 1:
316                     return -cls((x % 1)*S.Pi)
317                 if 2*x > 1:
318                     return cls((1 - x)*S.Pi)
319                 narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi
320                 result = cos(narg)
321                 if not isinstance(result, cos):
322                     return result
323                 if pi_coeff*S.Pi != arg:
324                     return cls(pi_coeff*S.Pi)
325                 return None
326 
327         if arg.is_Add:
328             x, m = _peeloff_pi(arg)
329             if m:
330                 return sin(m)*cos(x) + cos(m)*sin(x)
331 
332         if arg.func is asin:
333             return arg.args[0]
334 
335         if arg.func is atan:
336             x = arg.args[0]
337             return x / sqrt(1 + x**2)
338 
339         if arg.func is atan2:
340             y, x = arg.args
341             return y / sqrt(x**2 + y**2)
342 
343         if arg.func is acos:
344             x = arg.args[0]
345             return sqrt(1 - x**2)
346 
347         if arg.func is acot:
348             x = arg.args[0]
349             return 1 / (sqrt(1 + 1 / x**2) * x)
350 
351         if arg.func is acsc:
352             x = arg.args[0]
353             return 1 / x
354 
355         if arg.func is asec:
356             x = arg.args[0]
357             return sqrt(1 - 1 / x**2)
358 
359     @staticmethod
360     @cacheit
361     def taylor_term(n, x, *previous_terms):
362         if n < 0 or n % 2 == 0:
363             return S.Zero
364         else:
365             x = sympify(x)
366 
367             if len(previous_terms) > 2:
368                 p = previous_terms[-2]
369                 return -p * x**2 / (n*(n - 1))
370             else:
371                 return (-1)**(n//2) * x**(n)/factorial(n)
372 
373     def _eval_rewrite_as_exp(self, arg):
374         I = S.ImaginaryUnit
375         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
376             arg = arg.func(arg.args[0]).rewrite(exp)
377         return (exp(arg*I) - exp(-arg*I)) / (2*I)
378 
379     def _eval_rewrite_as_Pow(self, arg):
380         if arg.func is log:
381             I = S.ImaginaryUnit
382             x = arg.args[0]
383             return I*x**-I / 2 - I*x**I /2
384 
385     def _eval_rewrite_as_cos(self, arg):
386         return cos(arg - S.Pi / 2, evaluate=False)
387 
388     def _eval_rewrite_as_tan(self, arg):
389         tan_half = tan(S.Half*arg)
390         return 2*tan_half/(1 + tan_half**2)
391 
392     def _eval_rewrite_as_sincos(self, arg):
393         return sin(arg)*cos(arg)/cos(arg)
394 
395     def _eval_rewrite_as_cot(self, arg):
396         cot_half = cot(S.Half*arg)
397         return 2*cot_half/(1 + cot_half**2)
398 
399     def _eval_rewrite_as_pow(self, arg):
400         return self.rewrite(cos).rewrite(pow)
401 
402     def _eval_rewrite_as_sqrt(self, arg):
403         return self.rewrite(cos).rewrite(sqrt)
404 
405     def _eval_rewrite_as_csc(self, arg):
406         return 1/csc(arg)
407 
408     def _eval_rewrite_as_sec(self, arg):
409         return 1 / sec(arg - S.Pi / 2, evaluate=False)
410 
411     def _eval_conjugate(self):
412         return self.func(self.args[0].conjugate())
413 
414     def as_real_imag(self, deep=True, **hints):
415         re, im = self._as_real_imag(deep=deep, **hints)
416         return (sin(re)*cosh(im), cos(re)*sinh(im))
417 
418     def _eval_expand_trig(self, **hints):
419         from sympy import expand_mul
420         from sympy.functions.special.polynomials import chebyshevt, chebyshevu
421         arg = self.args[0]
422         x = None
423         if arg.is_Add:  # TODO, implement more if deep stuff here
424             # TODO: Do this more efficiently for more than two terms
425             x, y = arg.as_two_terms()
426             sx = sin(x, evaluate=False)._eval_expand_trig()
427             sy = sin(y, evaluate=False)._eval_expand_trig()
428             cx = cos(x, evaluate=False)._eval_expand_trig()
429             cy = cos(y, evaluate=False)._eval_expand_trig()
430             return sx*cy + sy*cx
431         else:
432             n, x = arg.as_coeff_Mul(rational=True)
433             if n.is_Integer:  # n will be positive because of .eval
434                 # canonicalization
435 
436                 # See http://mathworld.wolfram.com/Multiple-AngleFormulas.html
437                 if n.is_odd:
438                     return (-1)**((n - 1)/2)*chebyshevt(n, sin(x))
439                 else:
440                     return expand_mul((-1)**(n/2 - 1)*cos(x)*chebyshevu(n -
441                         1, sin(x)), deep=False)
442             pi_coeff = _pi_coeff(arg)
443             if pi_coeff is not None:
444                 if pi_coeff.is_Rational:
445                     return self.rewrite(sqrt)
446         return sin(arg)
447 
448     def _eval_as_leading_term(self, x):
449         from sympy import Order
450         arg = self.args[0].as_leading_term(x)
451 
452         if x in arg.free_symbols and Order(1, x).contains(arg):
453             return arg
454         else:
455             return self.func(arg)
456 
457     def _eval_is_real(self):
458         return self.args[0].is_real
459 
460     def _eval_is_finite(self):
461         arg = self.args[0]
462         if arg.is_real:
463             return True
464 
465 
466 class cos(TrigonometricFunction):
467     """
468     The cosine function.
469 
470     Returns the cosine of x (measured in radians).
471 
472     Notes
473     =====
474 
475     See :func:`sin` for notes about automatic evaluation.
476 
477     Examples
478     ========
479 
480     >>> from sympy import cos, pi
481     >>> from sympy.abc import x
482     >>> cos(x**2).diff(x)
483     -2*x*sin(x**2)
484     >>> cos(1).diff(x)
485     0
486     >>> cos(pi)
487     -1
488     >>> cos(pi/2)
489     0
490     >>> cos(2*pi/3)
491     -1/2
492     >>> cos(pi/12)
493     sqrt(2)/4 + sqrt(6)/4
494 
495     See Also
496     ========
497 
498     sin, csc, sec, tan, cot
499     asin, acsc, acos, asec, atan, acot, atan2
500 
501     References
502     ==========
503 
504     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
505     .. [2] http://dlmf.nist.gov/4.14
506     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos
507     """
508 
509     def period(self, symbol=None):
510         return self._period(2*pi, symbol)
511 
512     def fdiff(self, argindex=1):
513         if argindex == 1:
514             return -sin(self.args[0])
515         else:
516             raise ArgumentIndexError(self, argindex)
517 
518     @classmethod
519     def eval(cls, arg):
520         from sympy.functions.special.polynomials import chebyshevt
521         from sympy.calculus.util import AccumBounds
522         if arg.is_Number:
523             if arg is S.NaN:
524                 return S.NaN
525             elif arg is S.Zero:
526                 return S.One
527             elif arg is S.Infinity or arg is S.NegativeInfinity:
528                 # In this case it is better to return AccumBounds(-1, 1)
529                 # rather than returning S.NaN, since AccumBounds(-1, 1)
530                 # preserves the information that sin(oo) is between
531                 # -1 and 1, where S.NaN does not do that.
532                 return AccumBounds(-1, 1)
533 
534         if isinstance(arg, AccumBounds):
535             return sin(arg + S.Pi/2)
536 
537         if arg.could_extract_minus_sign():
538             return cls(-arg)
539 
540         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
541         if i_coeff is not None:
542             return cosh(i_coeff)
543 
544         pi_coeff = _pi_coeff(arg)
545         if pi_coeff is not None:
546             if pi_coeff.is_integer:
547                 return (S.NegativeOne)**pi_coeff
548 
549             if (2*pi_coeff).is_integer:
550                 if pi_coeff.is_even:
551                     return (S.NegativeOne)**(pi_coeff/2)
552                 elif pi_coeff.is_even is False:
553                     return S.Zero
554 
555             if not pi_coeff.is_Rational:
556                 narg = pi_coeff*S.Pi
557                 if narg != arg:
558                     return cls(narg)
559                 return None
560 
561             # cosine formula #####################
562             # https://github.com/sympy/sympy/issues/6048
563             # explicit calculations are preformed for
564             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120
565             # Some other exact values like cos(k pi/240) can be
566             # calculated using a partial-fraction decomposition
567             # by calling cos( X ).rewrite(sqrt)
568             cst_table_some = {
569                 3: S.Half,
570                 5: (sqrt(5) + 1)/4,
571             }
572             if pi_coeff.is_Rational:
573                 q = pi_coeff.q
574                 p = pi_coeff.p % (2*q)
575                 if p > q:
576                     narg = (pi_coeff - 1)*S.Pi
577                     return -cls(narg)
578                 if 2*p > q:
579                     narg = (1 - pi_coeff)*S.Pi
580                     return -cls(narg)
581 
582                 # If nested sqrt's are worse than un-evaluation
583                 # you can require q to be in (1, 2, 3, 4, 6, 12)
584                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return
585                 # expressions with 2 or fewer sqrt nestings.
586                 table2 = {
587                     12: (3, 4),
588                     20: (4, 5),
589                     30: (5, 6),
590                     15: (6, 10),
591                     24: (6, 8),
592                     40: (8, 10),
593                     60: (20, 30),
594                     120: (40, 60)
595                     }
596                 if q in table2:
597                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]
598                     nvala, nvalb = cls(a), cls(b)
599                     if None == nvala or None == nvalb:
600                         return None
601                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)
602 
603                 if q > 12:
604                     return None
605 
606                 if q in cst_table_some:
607                     cts = cst_table_some[pi_coeff.q]
608                     return chebyshevt(pi_coeff.p, cts).expand()
609 
610                 if 0 == q % 2:
611                     narg = (pi_coeff*2)*S.Pi
612                     nval = cls(narg)
613                     if None == nval:
614                         return None
615                     x = (2*pi_coeff + 1)/2
616                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))
617                     return sign_cos*sqrt( (1 + nval)/2 )
618             return None
619 
620         if arg.is_Add:
621             x, m = _peeloff_pi(arg)
622             if m:
623                 return cos(m)*cos(x) - sin(m)*sin(x)
624 
625         if arg.func is acos:
626             return arg.args[0]
627 
628         if arg.func is atan:
629             x = arg.args[0]
630             return 1 / sqrt(1 + x**2)
631 
632         if arg.func is atan2:
633             y, x = arg.args
634             return x / sqrt(x**2 + y**2)
635 
636         if arg.func is asin:
637             x = arg.args[0]
638             return sqrt(1 - x ** 2)
639 
640         if arg.func is acot:
641             x = arg.args[0]
642             return 1 / sqrt(1 + 1 / x**2)
643 
644         if arg.func is acsc:
645             x = arg.args[0]
646             return sqrt(1 - 1 / x**2)
647 
648         if arg.func is asec:
649             x = arg.args[0]
650             return 1 / x
651 
652     @staticmethod
653     @cacheit
654     def taylor_term(n, x, *previous_terms):
655         if n < 0 or n % 2 == 1:
656             return S.Zero
657         else:
658             x = sympify(x)
659 
660             if len(previous_terms) > 2:
661                 p = previous_terms[-2]
662                 return -p * x**2 / (n*(n - 1))
663             else:
664                 return (-1)**(n//2)*x**(n)/factorial(n)
665 
666     def _eval_rewrite_as_exp(self, arg):
667         I = S.ImaginaryUnit
668         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
669             arg = arg.func(arg.args[0]).rewrite(exp)
670         return (exp(arg*I) + exp(-arg*I)) / 2
671 
672     def _eval_rewrite_as_Pow(self, arg):
673         if arg.func is log:
674             I = S.ImaginaryUnit
675             x = arg.args[0]
676             return x**I/2 + x**-I/2
677 
678     def _eval_rewrite_as_sin(self, arg):
679         return sin(arg + S.Pi / 2, evaluate=False)
680 
681     def _eval_rewrite_as_tan(self, arg):
682         tan_half = tan(S.Half*arg)**2
683         return (1 - tan_half)/(1 + tan_half)
684 
685     def _eval_rewrite_as_sincos(self, arg):
686         return sin(arg)*cos(arg)/sin(arg)
687 
688     def _eval_rewrite_as_cot(self, arg):
689         cot_half = cot(S.Half*arg)**2
690         return (cot_half - 1)/(cot_half + 1)
691 
692     def _eval_rewrite_as_pow(self, arg):
693         return self._eval_rewrite_as_sqrt(arg)
694 
695     def _eval_rewrite_as_sqrt(self, arg):
696         from sympy.functions.special.polynomials import chebyshevt
697 
698         def migcdex(x):
699             # recursive calcuation of gcd and linear combination
700             # for a sequence of integers.
701             # Given  (x1, x2, x3)
702             # Returns (y1, y1, y3, g)
703             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0
704             # Note, that this is only one such linear combination.
705             if len(x) == 1:
706                 return (1, x[0])
707             if len(x) == 2:
708                 return igcdex(x[0], x[-1])
709             g = migcdex(x[1:])
710             u, v, h = igcdex(x[0], g[-1])
711             return tuple([u] + [v*i for i in g[0:-1] ] + [h])
712 
713         def ipartfrac(r, factors=None):
714             from sympy.ntheory import factorint
715             if isinstance(r, int):
716                 return r
717             if not isinstance(r, Rational):
718                 raise TypeError("r is not rational")
719             n = r.q
720             if 2 > r.q*r.q:
721                 return r.q
722 
723             if None == factors:
724                 a = [n//x**y for x, y in factorint(r.q).items()]
725             else:
726                 a = [n//x for x in factors]
727             if len(a) == 1:
728                 return [ r ]
729             h = migcdex(a)
730             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]
731             assert r == sum(ans)
732             return ans
733         pi_coeff = _pi_coeff(arg)
734         if pi_coeff is None:
735             return None
736 
737         if pi_coeff.is_integer:
738             # it was unevaluated
739             return self.func(pi_coeff*S.Pi)
740 
741         if not pi_coeff.is_Rational:
742             return None
743 
744         def _cospi257():
745             """ Express cos(pi/257) explicitly as a function of radicals
746                 Based upon the equations in
747                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals
748                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt
749             """
750             def f1(a, b):
751                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2
752 
753             def f2(a, b):
754                 return (a - sqrt(a**2 + b))/2
755 
756             t1, t2 = f1(-1, 256)
757             z1, z3 = f1(t1, 64)
758             z2, z4 = f1(t2, 64)
759             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))
760             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))
761             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))
762             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))
763             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))
764             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))
765             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))
766             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))
767             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))
768             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))
769             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))
770             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))
771             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))
772             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))
773             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))
774             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))
775             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))
776             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))
777             u1 = -f2(-v1, -4*(v2 + v3))
778             u2 = -f2(-v4, -4*(v5 + v6))
779             w1 = -2*f2(-u1, -4*u2)
780             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)
781 
782         cst_table_some = {
783             3: S.Half,
784             5: (sqrt(5) + 1)/4,
785             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +
786                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))
787                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),
788             257: _cospi257()
789             # 65537 is the only other known Fermat prime and the very
790             # large expression is intentionally omitted from SymPy; see
791             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt
792         }
793 
794         def _fermatCoords(n):
795             # if n can be factored in terms of Fermat primes with
796             # multiplicity of each being 1, return those primes, else
797             # False
798             primes = []
799             for p_i in cst_table_some:
800                 quotient, remainder = divmod(n, p_i)
801                 if remainder == 0:
802                     n = quotient
803                     primes.append(p_i)
804                     if n == 1:
805                         return tuple(primes)
806             return False
807 
808         if pi_coeff.q in cst_table_some:
809             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])
810             if pi_coeff.q < 257:
811                 rv = rv.expand()
812             return rv
813 
814         if not pi_coeff.q % 2:  # recursively remove factors of 2
815             pico2 = pi_coeff*2
816             nval = cos(pico2*S.Pi).rewrite(sqrt)
817             x = (pico2 + 1)/2
818             sign_cos = -1 if int(x) % 2 else 1
819             return sign_cos*sqrt( (1 + nval)/2 )
820 
821         FC = _fermatCoords(pi_coeff.q)
822         if FC:
823             decomp = ipartfrac(pi_coeff, FC)
824             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
825             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
826             return pcls.rewrite(sqrt)
827         else:
828             decomp = ipartfrac(pi_coeff)
829             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
830             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
831             return pcls
832 
833     def _eval_rewrite_as_sec(self, arg):
834         return 1/sec(arg)
835 
836     def _eval_rewrite_as_csc(self, arg):
837         return 1 / sec(arg)._eval_rewrite_as_csc(arg)
838 
839     def _eval_conjugate(self):
840         return self.func(self.args[0].conjugate())
841 
842     def as_real_imag(self, deep=True, **hints):
843         re, im = self._as_real_imag(deep=deep, **hints)
844         return (cos(re)*cosh(im), -sin(re)*sinh(im))
845 
846     def _eval_expand_trig(self, **hints):
847         from sympy.functions.special.polynomials import chebyshevt
848         arg = self.args[0]
849         x = None
850         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms
851             x, y = arg.as_two_terms()
852             sx = sin(x, evaluate=False)._eval_expand_trig()
853             sy = sin(y, evaluate=False)._eval_expand_trig()
854             cx = cos(x, evaluate=False)._eval_expand_trig()
855             cy = cos(y, evaluate=False)._eval_expand_trig()
856             return cx*cy - sx*sy
857         else:
858             coeff, terms = arg.as_coeff_Mul(rational=True)
859             if coeff.is_Integer:
860                 return chebyshevt(coeff, cos(terms))
861             pi_coeff = _pi_coeff(arg)
862             if pi_coeff is not None:
863                 if pi_coeff.is_Rational:
864                     return self.rewrite(sqrt)
865         return cos(arg)
866 
867     def _eval_as_leading_term(self, x):
868         from sympy import Order
869         arg = self.args[0].as_leading_term(x)
870 
871         if x in arg.free_symbols and Order(1, x).contains(arg):
872             return S.One
873         else:
874             return self.func(arg)
875 
876     def _eval_is_real(self):
877         return self.args[0].is_real
878 
879     def _eval_is_finite(self):
880         arg = self.args[0]
881 
882         if arg.is_real:
883             return True
884 
885 
886 class tan(TrigonometricFunction):
887     """
888     The tangent function.
889 
890     Returns the tangent of x (measured in radians).
891 
892     Notes
893     =====
894 
895     See :func:`sin` for notes about automatic evaluation.
896 
897     Examples
898     ========
899 
900     >>> from sympy import tan, pi
901     >>> from sympy.abc import x
902     >>> tan(x**2).diff(x)
903     2*x*(tan(x**2)**2 + 1)
904     >>> tan(1).diff(x)
905     0
906     >>> tan(pi/8).expand()
907     -1 + sqrt(2)
908 
909     See Also
910     ========
911 
912     sin, csc, cos, sec, cot
913     asin, acsc, acos, asec, atan, acot, atan2
914 
915     References
916     ==========
917 
918     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
919     .. [2] http://dlmf.nist.gov/4.14
920     .. [3] http://functions.wolfram.com/ElementaryFunctions/Tan
921     """
922 
923     def period(self, symbol=None):
924         return self._period(pi, symbol)
925 
926     def fdiff(self, argindex=1):
927         if argindex == 1:
928             return S.One + self**2
929         else:
930             raise ArgumentIndexError(self, argindex)
931 
932     def inverse(self, argindex=1):
933         """
934         Returns the inverse of this function.
935         """
936         return atan
937 
938     @classmethod
939     def eval(cls, arg):
940         from sympy.calculus.util import AccumBounds
941         if arg.is_Number:
942             if arg is S.NaN:
943                 return S.NaN
944             elif arg is S.Zero:
945                 return S.Zero
946             elif arg is S.Infinity or arg is S.NegativeInfinity:
947                 return AccumBounds(S.NegativeInfinity, S.Infinity)
948 
949         if isinstance(arg, AccumBounds):
950             min, max = arg.min, arg.max
951             d = floor(min/S.Pi)
952             if min is not S.NegativeInfinity:
953                 min = min - d*S.Pi
954             if max is not S.Infinity:
955                 max = max - d*S.Pi
956             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 3*S.Pi/2)):
957                 return AccumBounds(S.NegativeInfinity, S.Infinity)
958             else:
959                 return AccumBounds(tan(min), tan(max))
960 
961         if arg.could_extract_minus_sign():
962             return -cls(-arg)
963 
964         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
965         if i_coeff is not None:
966             return S.ImaginaryUnit * tanh(i_coeff)
967 
968         pi_coeff = _pi_coeff(arg, 2)
969         if pi_coeff is not None:
970             if pi_coeff.is_integer:
971                 return S.Zero
972 
973             if not pi_coeff.is_Rational:
974                 narg = pi_coeff*S.Pi
975                 if narg != arg:
976                     return cls(narg)
977                 return None
978 
979             if pi_coeff.is_Rational:
980                 if not pi_coeff.q % 2:
981                     narg = pi_coeff*S.Pi*2
982                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
983                     if not isinstance(cresult, cos) \
984                             and not isinstance(sresult, cos):
985                         if sresult == 0:
986                             return S.ComplexInfinity
987                         return (1 - cresult)/sresult
988                 table2 = {
989                     12: (3, 4),
990                     20: (4, 5),
991                     30: (5, 6),
992                     15: (6, 10),
993                     24: (6, 8),
994                     40: (8, 10),
995                     60: (20, 30),
996                     120: (40, 60)
997                     }
998                 q = pi_coeff.q
999                 p = pi_coeff.p % q
1000                 if q in table2:
1001                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
1002                     if None == nvala or None == nvalb:
1003                         return None
1004                     return (nvala - nvalb)/(1 + nvala*nvalb)
1005                 narg = ((pi_coeff + S.Half) % 1 - S.Half)*S.Pi
1006                 # see cos() to specify which expressions should  be
1007                 # expanded automatically in terms of radicals
1008                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1009                 if not isinstance(cresult, cos) \
1010                         and not isinstance(sresult, cos):
1011                     if cresult == 0:
1012                         return S.ComplexInfinity
1013                     return (sresult/cresult)
1014                 if narg != arg:
1015                     return cls(narg)
1016 
1017         if arg.is_Add:
1018             x, m = _peeloff_pi(arg)
1019             if m:
1020                 tanm = tan(m)
1021                 tanx = tan(x)
1022                 if tanm is S.ComplexInfinity:
1023                     return -cot(x)
1024                 return (tanm + tanx)/(1 - tanm*tanx)
1025 
1026         if arg.func is atan:
1027             return arg.args[0]
1028 
1029         if arg.func is atan2:
1030             y, x = arg.args
1031             return y/x
1032 
1033         if arg.func is asin:
1034             x = arg.args[0]
1035             return x / sqrt(1 - x**2)
1036 
1037         if arg.func is acos:
1038             x = arg.args[0]
1039             return sqrt(1 - x**2) / x
1040 
1041         if arg.func is acot:
1042             x = arg.args[0]
1043             return 1 / x
1044 
1045         if arg.func is acsc:
1046             x = arg.args[0]
1047             return 1 / (sqrt(1 - 1 / x**2) * x)
1048 
1049         if arg.func is asec:
1050             x = arg.args[0]
1051             return sqrt(1 - 1 / x**2) * x
1052 
1053     @staticmethod
1054     @cacheit
1055     def taylor_term(n, x, *previous_terms):
1056         from sympy import bernoulli
1057         if n < 0 or n % 2 == 0:
1058             return S.Zero
1059         else:
1060             x = sympify(x)
1061 
1062             a, b = ((n - 1)//2), 2**(n + 1)
1063 
1064             B = bernoulli(n + 1)
1065             F = factorial(n + 1)
1066 
1067             return (-1)**a * b*(b - 1) * B/F * x**n
1068 
1069     def _eval_nseries(self, x, n, logx):
1070         i = self.args[0].limit(x, 0)*2/S.Pi
1071         if i and i.is_Integer:
1072             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1073         return Function._eval_nseries(self, x, n=n, logx=logx)
1074 
1075     def _eval_rewrite_as_Pow(self, arg):
1076         if arg.func is log:
1077             I = S.ImaginaryUnit
1078             x = arg.args[0]
1079             return I*(x**-I - x**I)/(x**-I + x**I)
1080 
1081     def _eval_conjugate(self):
1082         return self.func(self.args[0].conjugate())
1083 
1084     def as_real_imag(self, deep=True, **hints):
1085         re, im = self._as_real_imag(deep=deep, **hints)
1086         if im:
1087             denom = cos(2*re) + cosh(2*im)
1088             return (sin(2*re)/denom, sinh(2*im)/denom)
1089         else:
1090             return (self.func(re), S.Zero)
1091 
1092     def _eval_expand_trig(self, **hints):
1093         from sympy import im, re
1094         arg = self.args[0]
1095         x = None
1096         if arg.is_Add:
1097             from sympy import symmetric_poly
1098             n = len(arg.args)
1099             TX = []
1100             for x in arg.args:
1101                 tx = tan(x, evaluate=False)._eval_expand_trig()
1102                 TX.append(tx)
1103 
1104             Yg = numbered_symbols('Y')
1105             Y = [ next(Yg) for i in range(n) ]
1106 
1107             p = [0, 0]
1108             for i in range(n + 1):
1109                 p[1 - i % 2] += symmetric_poly(i, Y)*(-1)**((i % 4)//2)
1110             return (p[0]/p[1]).subs(list(zip(Y, TX)))
1111 
1112         else:
1113             coeff, terms = arg.as_coeff_Mul(rational=True)
1114             if coeff.is_Integer and coeff > 1:
1115                 I = S.ImaginaryUnit
1116                 z = Symbol('dummy', real=True)
1117                 P = ((1 + I*z)**coeff).expand()
1118                 return (im(P)/re(P)).subs([(z, tan(terms))])
1119         return tan(arg)
1120 
1121     def _eval_rewrite_as_exp(self, arg):
1122         I = S.ImaginaryUnit
1123         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1124             arg = arg.func(arg.args[0]).rewrite(exp)
1125         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1126         return I*(neg_exp - pos_exp)/(neg_exp + pos_exp)
1127 
1128     def _eval_rewrite_as_sin(self, x):
1129         return 2*sin(x)**2/sin(2*x)
1130 
1131     def _eval_rewrite_as_cos(self, x):
1132         return cos(x - S.Pi / 2, evaluate=False) / cos(x)
1133 
1134     def _eval_rewrite_as_sincos(self, arg):
1135         return sin(arg)/cos(arg)
1136 
1137     def _eval_rewrite_as_cot(self, arg):
1138         return 1/cot(arg)
1139 
1140     def _eval_rewrite_as_sec(self, arg):
1141         sin_in_sec_form = sin(arg)._eval_rewrite_as_sec(arg)
1142         cos_in_sec_form = cos(arg)._eval_rewrite_as_sec(arg)
1143         return sin_in_sec_form / cos_in_sec_form
1144 
1145     def _eval_rewrite_as_csc(self, arg):
1146         sin_in_csc_form = sin(arg)._eval_rewrite_as_csc(arg)
1147         cos_in_csc_form = cos(arg)._eval_rewrite_as_csc(arg)
1148         return sin_in_csc_form / cos_in_csc_form
1149 
1150     def _eval_rewrite_as_pow(self, arg):
1151         y = self.rewrite(cos).rewrite(pow)
1152         if y.has(cos):
1153             return None
1154         return y
1155 
1156     def _eval_rewrite_as_sqrt(self, arg):
1157         y = self.rewrite(cos).rewrite(sqrt)
1158         if y.has(cos):
1159             return None
1160         return y
1161 
1162     def _eval_as_leading_term(self, x):
1163         from sympy import Order
1164         arg = self.args[0].as_leading_term(x)
1165 
1166         if x in arg.free_symbols and Order(1, x).contains(arg):
1167             return arg
1168         else:
1169             return self.func(arg)
1170 
1171     def _eval_is_real(self):
1172         return self.args[0].is_real
1173 
1174     def _eval_is_finite(self):
1175         arg = self.args[0]
1176 
1177         if arg.is_imaginary:
1178             return True
1179 
1180 
1181 class cot(TrigonometricFunction):
1182     """
1183     The cotangent function.
1184 
1185     Returns the cotangent of x (measured in radians).
1186 
1187     Notes
1188     =====
1189 
1190     See :func:`sin` for notes about automatic evaluation.
1191 
1192     Examples
1193     ========
1194 
1195     >>> from sympy import cot, pi
1196     >>> from sympy.abc import x
1197     >>> cot(x**2).diff(x)
1198     2*x*(-cot(x**2)**2 - 1)
1199     >>> cot(1).diff(x)
1200     0
1201     >>> cot(pi/12)
1202     sqrt(3) + 2
1203 
1204     See Also
1205     ========
1206 
1207     sin, csc, cos, sec, tan
1208     asin, acsc, acos, asec, atan, acot, atan2
1209 
1210     References
1211     ==========
1212 
1213     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1214     .. [2] http://dlmf.nist.gov/4.14
1215     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cot
1216     """
1217 
1218     def period(self, symbol=None):
1219         return self._period(pi, symbol)
1220 
1221     def fdiff(self, argindex=1):
1222         if argindex == 1:
1223             return S.NegativeOne - self**2
1224         else:
1225             raise ArgumentIndexError(self, argindex)
1226 
1227     def inverse(self, argindex=1):
1228         """
1229         Returns the inverse of this function.
1230         """
1231         return acot
1232 
1233     @classmethod
1234     def eval(cls, arg):
1235         from sympy.calculus.util import AccumBounds
1236         if arg.is_Number:
1237             if arg is S.NaN:
1238                 return S.NaN
1239             if arg is S.Zero:
1240                 return S.ComplexInfinity
1241 
1242         if isinstance(arg, AccumBounds):
1243             return -tan(arg + S.Pi/2)
1244 
1245         if arg.could_extract_minus_sign():
1246             return -cls(-arg)
1247 
1248         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1249         if i_coeff is not None:
1250             return -S.ImaginaryUnit * coth(i_coeff)
1251 
1252         pi_coeff = _pi_coeff(arg, 2)
1253         if pi_coeff is not None:
1254             if pi_coeff.is_integer:
1255                 return S.ComplexInfinity
1256 
1257             if not pi_coeff.is_Rational:
1258                 narg = pi_coeff*S.Pi
1259                 if narg != arg:
1260                     return cls(narg)
1261                 return None
1262 
1263             if pi_coeff.is_Rational:
1264                 if pi_coeff.q > 2 and not pi_coeff.q % 2:
1265                     narg = pi_coeff*S.Pi*2
1266                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1267                     if not isinstance(cresult, cos) \
1268                             and not isinstance(sresult, cos):
1269                         return (1 + cresult)/sresult
1270                 table2 = {
1271                     12: (3, 4),
1272                     20: (4, 5),
1273                     30: (5, 6),
1274                     15: (6, 10),
1275                     24: (6, 8),
1276                     40: (8, 10),
1277                     60: (20, 30),
1278                     120: (40, 60)
1279                     }
1280                 q = pi_coeff.q
1281                 p = pi_coeff.p % q
1282                 if q in table2:
1283                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
1284                     if None == nvala or None == nvalb:
1285                         return None
1286                     return (1 + nvala*nvalb)/(nvalb - nvala)
1287                 narg = (((pi_coeff + S.Half) % 1) - S.Half)*S.Pi
1288                 # see cos() to specify which expressions should be
1289                 # expanded automatically in terms of radicals
1290                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1291                 if not isinstance(cresult, cos) \
1292                         and not isinstance(sresult, cos):
1293                     if sresult == 0:
1294                         return S.ComplexInfinity
1295                     return cresult / sresult
1296                 if narg != arg:
1297                     return cls(narg)
1298 
1299         if arg.is_Add:
1300             x, m = _peeloff_pi(arg)
1301             if m:
1302                 cotm = cot(m)
1303                 if cotm == 0:
1304                     return -tan(x)
1305                 cotx = cot(x)
1306                 if cotm is S.ComplexInfinity:
1307                     return cotx
1308                 if cotm.is_Rational:
1309                     return (cotm*cotx - 1) / (cotm + cotx)
1310             return None
1311 
1312         if arg.func is acot:
1313             return arg.args[0]
1314 
1315         if arg.func is atan:
1316             x = arg.args[0]
1317             return 1 / x
1318 
1319         if arg.func is atan2:
1320             y, x = arg.args
1321             return x/y
1322 
1323         if arg.func is asin:
1324             x = arg.args[0]
1325             return sqrt(1 - x**2) / x
1326 
1327         if arg.func is acos:
1328             x = arg.args[0]
1329             return x / sqrt(1 - x**2)
1330 
1331         if arg.func is acsc:
1332             x = arg.args[0]
1333             return sqrt(1 - 1 / x**2) * x
1334 
1335         if arg.func is asec:
1336             x = arg.args[0]
1337             return 1 / (sqrt(1 - 1 / x**2) * x)
1338 
1339     @staticmethod
1340     @cacheit
1341     def taylor_term(n, x, *previous_terms):
1342         from sympy import bernoulli
1343         if n == 0:
1344             return 1 / sympify(x)
1345         elif n < 0 or n % 2 == 0:
1346             return S.Zero
1347         else:
1348             x = sympify(x)
1349 
1350             B = bernoulli(n + 1)
1351             F = factorial(n + 1)
1352 
1353             return (-1)**((n + 1)//2) * 2**(n + 1) * B/F * x**n
1354 
1355     def _eval_nseries(self, x, n, logx):
1356         i = self.args[0].limit(x, 0)/S.Pi
1357         if i and i.is_Integer:
1358             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1359         return self.rewrite(tan)._eval_nseries(x, n=n, logx=logx)
1360 
1361     def _eval_conjugate(self):
1362         return self.func(self.args[0].conjugate())
1363 
1364     def as_real_imag(self, deep=True, **hints):
1365         re, im = self._as_real_imag(deep=deep, **hints)
1366         if im:
1367             denom = cos(2*re) - cosh(2*im)
1368             return (-sin(2*re)/denom, -sinh(2*im)/denom)
1369         else:
1370             return (self.func(re), S.Zero)
1371 
1372     def _eval_rewrite_as_exp(self, arg):
1373         I = S.ImaginaryUnit
1374         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1375             arg = arg.func(arg.args[0]).rewrite(exp)
1376         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1377         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)
1378 
1379     def _eval_rewrite_as_Pow(self, arg):
1380         if arg.func is log:
1381             I = S.ImaginaryUnit
1382             x = arg.args[0]
1383             return -I*(x**-I + x**I)/(x**-I - x**I)
1384 
1385     def _eval_rewrite_as_sin(self, x):
1386         return 2*sin(2*x)/sin(x)**2
1387 
1388     def _eval_rewrite_as_cos(self, x):
1389         return cos(x) / cos(x - S.Pi / 2, evaluate=False)
1390 
1391     def _eval_rewrite_as_sincos(self, arg):
1392         return cos(arg)/sin(arg)
1393 
1394     def _eval_rewrite_as_tan(self, arg):
1395         return 1/tan(arg)
1396 
1397     def _eval_rewrite_as_sec(self, arg):
1398         cos_in_sec_form = cos(arg)._eval_rewrite_as_sec(arg)
1399         sin_in_sec_form = sin(arg)._eval_rewrite_as_sec(arg)
1400         return cos_in_sec_form / sin_in_sec_form
1401 
1402     def _eval_rewrite_as_csc(self, arg):
1403         cos_in_csc_form = cos(arg)._eval_rewrite_as_csc(arg)
1404         sin_in_csc_form = sin(arg)._eval_rewrite_as_csc(arg)
1405         return cos_in_csc_form / sin_in_csc_form
1406 
1407     def _eval_rewrite_as_pow(self, arg):
1408         y = self.rewrite(cos).rewrite(pow)
1409         if y.has(cos):
1410             return None
1411         return y
1412 
1413     def _eval_rewrite_as_sqrt(self, arg):
1414         y = self.rewrite(cos).rewrite(sqrt)
1415         if y.has(cos):
1416             return None
1417         return y
1418 
1419     def _eval_as_leading_term(self, x):
1420         from sympy import Order
1421         arg = self.args[0].as_leading_term(x)
1422 
1423         if x in arg.free_symbols and Order(1, x).contains(arg):
1424             return 1/arg
1425         else:
1426             return self.func(arg)
1427 
1428     def _eval_is_real(self):
1429         return self.args[0].is_real
1430 
1431     def _eval_expand_trig(self, **hints):
1432         from sympy import im, re
1433         arg = self.args[0]
1434         x = None
1435         if arg.is_Add:
1436             from sympy import symmetric_poly
1437             n = len(arg.args)
1438             CX = []
1439             for x in arg.args:
1440                 cx = cot(x, evaluate=False)._eval_expand_trig()
1441                 CX.append(cx)
1442 
1443             Yg = numbered_symbols('Y')
1444             Y = [ next(Yg) for i in range(n) ]
1445 
1446             p = [0, 0]
1447             for i in range(n, -1, -1):
1448                 p[(n - i) % 2] += symmetric_poly(i, Y)*(-1)**(((n - i) % 4)//2)
1449             return (p[0]/p[1]).subs(list(zip(Y, CX)))
1450         else:
1451             coeff, terms = arg.as_coeff_Mul(rational=True)
1452             if coeff.is_Integer and coeff > 1:
1453                 I = S.ImaginaryUnit
1454                 z = Symbol('dummy', real=True)
1455                 P = ((z + I)**coeff).expand()
1456                 return (re(P)/im(P)).subs([(z, cot(terms))])
1457         return cot(arg)
1458 
1459     def _eval_is_finite(self):
1460         arg = self.args[0]
1461         if arg.is_imaginary:
1462             return True
1463 
1464     def _eval_subs(self, old, new):
1465         if self == old:
1466             return new
1467         arg = self.args[0]
1468         argnew = arg.subs(old, new)
1469         if arg != argnew and (argnew/S.Pi).is_integer:
1470             return S.ComplexInfinity
1471         return cot(argnew)
1472 
1473 
1474 class ReciprocalTrigonometricFunction(TrigonometricFunction):
1475     """Base class for reciprocal functions of trigonometric functions. """
1476 
1477     _reciprocal_of = None       # mandatory, to be defined in subclass
1478 
1479     # _is_even and _is_odd are used for correct evaluation of csc(-x), sec(-x)
1480     # TODO refactor into TrigonometricFunction common parts of
1481     # trigonometric functions eval() like even/odd, func(x+2*k*pi), etc.
1482     _is_even = None  # optional, to be defined in subclass
1483     _is_odd = None   # optional, to be defined in subclass
1484 
1485     @classmethod
1486     def eval(cls, arg):
1487         if arg.could_extract_minus_sign():
1488             if cls._is_even:
1489                 return cls(-arg)
1490             if cls._is_odd:
1491                 return -cls(-arg)
1492 
1493         pi_coeff = _pi_coeff(arg)
1494         if (pi_coeff is not None
1495             and not (2*pi_coeff).is_integer
1496             and pi_coeff.is_Rational):
1497                 q = pi_coeff.q
1498                 p = pi_coeff.p % (2*q)
1499                 if p > q:
1500                     narg = (pi_coeff - 1)*S.Pi
1501                     return -cls(narg)
1502                 if 2*p > q:
1503                     narg = (1 - pi_coeff)*S.Pi
1504                     if cls._is_odd:
1505                         return cls(narg)
1506                     elif cls._is_even:
1507                         return -cls(narg)
1508 
1509         t = cls._reciprocal_of.eval(arg)
1510         if hasattr(arg, 'inverse') and arg.inverse() == cls:
1511             return arg.args[0]
1512         return 1/t if t != None else t
1513 
1514     def _call_reciprocal(self, method_name, *args, **kwargs):
1515         # Calls method_name on _reciprocal_of
1516         o = self._reciprocal_of(self.args[0])
1517         return getattr(o, method_name)(*args, **kwargs)
1518 
1519     def _calculate_reciprocal(self, method_name, *args, **kwargs):
1520         # If calling method_name on _reciprocal_of returns a value != None
1521         # then return the reciprocal of that value
1522         t = self._call_reciprocal(method_name, *args, **kwargs)
1523         return 1/t if t != None else t
1524 
1525     def _rewrite_reciprocal(self, method_name, arg):
1526         # Special handling for rewrite functions. If reciprocal rewrite returns
1527         # unmodified expression, then return None
1528         t = self._call_reciprocal(method_name, arg)
1529         if t != None and t != self._reciprocal_of(arg):
1530             return 1/t
1531 
1532     def _period(self, symbol):
1533         f = self.args[0]
1534         return self._reciprocal_of(f).period(symbol)
1535 
1536     def fdiff(self, argindex=1):
1537         return -self._calculate_reciprocal("fdiff", argindex)/self**2
1538 
1539     def _eval_rewrite_as_exp(self, arg):
1540         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
1541 
1542     def _eval_rewrite_as_Pow(self, arg):
1543         return self._rewrite_reciprocal("_eval_rewrite_as_Pow", arg)
1544 
1545     def _eval_rewrite_as_sin(self, arg):
1546         return self._rewrite_reciprocal("_eval_rewrite_as_sin", arg)
1547 
1548     def _eval_rewrite_as_cos(self, arg):
1549         return self._rewrite_reciprocal("_eval_rewrite_as_cos", arg)
1550 
1551     def _eval_rewrite_as_tan(self, arg):
1552         return self._rewrite_reciprocal("_eval_rewrite_as_tan", arg)
1553 
1554     def _eval_rewrite_as_pow(self, arg):
1555         return self._rewrite_reciprocal("_eval_rewrite_as_pow", arg)
1556 
1557     def _eval_rewrite_as_sqrt(self, arg):
1558         return self._rewrite_reciprocal("_eval_rewrite_as_sqrt", arg)
1559 
1560     def _eval_conjugate(self):
1561         return self.func(self.args[0].conjugate())
1562 
1563     def as_real_imag(self, deep=True, **hints):
1564         return (1/self._reciprocal_of(self.args[0])).as_real_imag(deep,
1565                                                                   **hints)
1566 
1567     def _eval_expand_trig(self, **hints):
1568         return self._calculate_reciprocal("_eval_expand_trig", **hints)
1569 
1570     def _eval_is_real(self):
1571         return self._reciprocal_of(self.args[0])._eval_is_real()
1572 
1573     def _eval_as_leading_term(self, x):
1574         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
1575 
1576     def _eval_is_finite(self):
1577         return (1/self._reciprocal_of(self.args[0])).is_finite
1578 
1579     def _eval_nseries(self, x, n, logx):
1580         return (1/self._reciprocal_of(self.args[0]))._eval_nseries(x, n, logx)
1581 
1582 
1583 class sec(ReciprocalTrigonometricFunction):
1584     """
1585     The secant function.
1586 
1587     Returns the secant of x (measured in radians).
1588 
1589     Notes
1590     =====
1591 
1592     See :func:`sin` for notes about automatic evaluation.
1593 
1594     Examples
1595     ========
1596 
1597     >>> from sympy import sec
1598     >>> from sympy.abc import x
1599     >>> sec(x**2).diff(x)
1600     2*x*tan(x**2)*sec(x**2)
1601     >>> sec(1).diff(x)
1602     0
1603 
1604     See Also
1605     ========
1606 
1607     sin, csc, cos, tan, cot
1608     asin, acsc, acos, asec, atan, acot, atan2
1609 
1610     References
1611     ==========
1612 
1613     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1614     .. [2] http://dlmf.nist.gov/4.14
1615     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sec
1616     """
1617 
1618     _reciprocal_of = cos
1619     _is_even = True
1620 
1621     def period(self, symbol=None):
1622         return self._period(symbol)
1623 
1624     def _eval_rewrite_as_cot(self, arg):
1625         cot_half_sq = cot(arg/2)**2
1626         return (cot_half_sq + 1)/(cot_half_sq - 1)
1627 
1628     def _eval_rewrite_as_cos(self, arg):
1629         return (1/cos(arg))
1630 
1631     def _eval_rewrite_as_sincos(self, arg):
1632         return sin(arg)/(cos(arg)*sin(arg))
1633 
1634     def _eval_rewrite_as_sin(self, arg):
1635         return (1 / cos(arg)._eval_rewrite_as_sin(arg))
1636 
1637     def _eval_rewrite_as_tan(self, arg):
1638         return (1 / cos(arg)._eval_rewrite_as_tan(arg))
1639 
1640     def _eval_rewrite_as_csc(self, arg):
1641         return csc(pi / 2 - arg, evaluate=False)
1642 
1643     def fdiff(self, argindex=1):
1644         if argindex == 1:
1645             return tan(self.args[0])*sec(self.args[0])
1646         else:
1647             raise ArgumentIndexError(self, argindex)
1648 
1649     @staticmethod
1650     @cacheit
1651     def taylor_term(n, x, *previous_terms):
1652         # Reference Formula:
1653         # http://functions.wolfram.com/ElementaryFunctions/Sec/06/01/02/01/
1654         from sympy.functions.combinatorial.numbers import euler
1655         if n < 0 or n % 2 == 1:
1656             return S.Zero
1657         else:
1658             x = sympify(x)
1659             k = n//2
1660             return (-1)**k*euler(2*k)/factorial(2*k)*x**(2*k)
1661 
1662 
1663 class csc(ReciprocalTrigonometricFunction):
1664     """
1665     The cosecant function.
1666 
1667     Returns the cosecant of x (measured in radians).
1668 
1669     Notes
1670     =====
1671 
1672     See :func:`sin` for notes about automatic evaluation.
1673 
1674     Examples
1675     ========
1676 
1677     >>> from sympy import csc
1678     >>> from sympy.abc import x
1679     >>> csc(x**2).diff(x)
1680     -2*x*cot(x**2)*csc(x**2)
1681     >>> csc(1).diff(x)
1682     0
1683 
1684     See Also
1685     ========
1686 
1687     sin, cos, sec, tan, cot
1688     asin, acsc, acos, asec, atan, acot, atan2
1689 
1690     References
1691     ==========
1692 
1693     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1694     .. [2] http://dlmf.nist.gov/4.14
1695     .. [3] http://functions.wolfram.com/ElementaryFunctions/Csc
1696     """
1697 
1698     _reciprocal_of = sin
1699     _is_odd = True
1700 
1701     def period(self, symbol=None):
1702         return self._period(symbol)
1703 
1704     def _eval_rewrite_as_sin(self, arg):
1705         return (1/sin(arg))
1706 
1707     def _eval_rewrite_as_sincos(self, arg):
1708         return cos(arg)/(sin(arg)*cos(arg))
1709 
1710     def _eval_rewrite_as_cot(self, arg):
1711         cot_half = cot(arg/2)
1712         return (1 + cot_half**2)/(2*cot_half)
1713 
1714     def _eval_rewrite_as_cos(self, arg):
1715         return (1 / sin(arg)._eval_rewrite_as_cos(arg))
1716 
1717     def _eval_rewrite_as_sec(self, arg):
1718         return sec(pi / 2 - arg, evaluate=False)
1719 
1720     def _eval_rewrite_as_tan(self, arg):
1721         return (1 / sin(arg)._eval_rewrite_as_tan(arg))
1722 
1723     def fdiff(self, argindex=1):
1724         if argindex == 1:
1725             return -cot(self.args[0])*csc(self.args[0])
1726         else:
1727             raise ArgumentIndexError(self, argindex)
1728 
1729     @staticmethod
1730     @cacheit
1731     def taylor_term(n, x, *previous_terms):
1732         from sympy import bernoulli
1733         if n == 0:
1734             return 1/sympify(x)
1735         elif n < 0 or n % 2 == 0:
1736             return S.Zero
1737         else:
1738             x = sympify(x)
1739             k = n//2 + 1
1740             return ((-1)**(k - 1)*2*(2**(2*k - 1) - 1)*
1741                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))
1742 
1743 
1744 class sinc(TrigonometricFunction):
1745     r"""Represents unnormalized sinc function
1746 
1747     Examples
1748     ========
1749 
1750     >>> from sympy import sinc, oo, jn, Product, Symbol
1751     >>> from sympy.abc import x
1752     >>> sinc(x)
1753     sinc(x)
1754 
1755     * Automated Evaluation
1756 
1757     >>> sinc(0)
1758     1
1759     >>> sinc(oo)
1760     0
1761 
1762     * Differentiation
1763 
1764     >>> sinc(x).diff()
1765     (x*cos(x) - sin(x))/x**2
1766 
1767     * Series Expansion
1768 
1769     >>> sinc(x).series()
1770     1 - x**2/6 + x**4/120 + O(x**6)
1771 
1772     * As zero'th order spherical Bessel Function
1773 
1774     >>> sinc(x).rewrite(jn)
1775     jn(0, x)
1776 
1777     References
1778     ==========
1779 
1780     .. [1] http://en.wikipedia.org/wiki/Sinc_function
1781 
1782     """
1783 
1784     def fdiff(self, argindex=1):
1785         x = self.args[0]
1786         if argindex == 1:
1787             return (x*cos(x) - sin(x)) / x**2
1788         else:
1789             raise ArgumentIndexError(self, argindex)
1790 
1791     @classmethod
1792     def eval(cls, arg):
1793         if arg.is_zero:
1794             return S.One
1795         if arg.is_Number:
1796             if arg in [S.Infinity, -S.Infinity]:
1797                 return S.Zero
1798             elif arg is S.NaN:
1799                 return S.NaN
1800 
1801         if arg is S.ComplexInfinity:
1802             return S.NaN
1803 
1804         if arg.could_extract_minus_sign():
1805             return cls(-arg)
1806 
1807         pi_coeff = _pi_coeff(arg)
1808         if pi_coeff is not None:
1809             if pi_coeff.is_integer:
1810                 if fuzzy_not(arg.is_zero):
1811                     return S.Zero
1812             elif (2*pi_coeff).is_integer:
1813                 return S.NegativeOne**(pi_coeff - S.Half) / arg
1814 
1815     def _eval_nseries(self, x, n, logx):
1816         x = self.args[0]
1817         return (sin(x)/x)._eval_nseries(x, n, logx)
1818 
1819     def _eval_rewrite_as_jn(self, arg):
1820         from sympy.functions.special.bessel import jn
1821         return jn(0, arg)
1822 
1823     def _eval_rewrite_as_sin(self, arg):
1824         return sin(arg) / arg
1825 
1826 
1827 ###############################################################################
1828 ########################### TRIGONOMETRIC INVERSES ############################
1829 ###############################################################################
1830 
1831 
1832 class InverseTrigonometricFunction(Function):
1833     """Base class for inverse trigonometric functions."""
1834 
1835     pass
1836 
1837 
1838 class asin(InverseTrigonometricFunction):
1839     """
1840     The inverse sine function.
1841 
1842     Returns the arcsine of x in radians.
1843 
1844     Notes
1845     =====
1846 
1847     asin(x) will evaluate automatically in the cases oo, -oo, 0, 1,
1848     -1 and for some instances when the result is a rational multiple
1849     of pi (see the eval class method).
1850 
1851     Examples
1852     ========
1853 
1854     >>> from sympy import asin, oo, pi
1855     >>> asin(1)
1856     pi/2
1857     >>> asin(-1)
1858     -pi/2
1859 
1860     See Also
1861     ========
1862 
1863     sin, csc, cos, sec, tan, cot
1864     acsc, acos, asec, atan, acot, atan2
1865 
1866     References
1867     ==========
1868 
1869     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
1870     .. [2] http://dlmf.nist.gov/4.23
1871     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSin
1872     """
1873 
1874     def fdiff(self, argindex=1):
1875         if argindex == 1:
1876             return 1/sqrt(1 - self.args[0]**2)
1877         else:
1878             raise ArgumentIndexError(self, argindex)
1879 
1880     def _eval_is_rational(self):
1881         s = self.func(*self.args)
1882         if s.func == self.func:
1883             if s.args[0].is_rational:
1884                 return False
1885         else:
1886             return s.is_rational
1887 
1888     def _eval_is_positive(self):
1889         if self.args[0].is_positive:
1890             return (self.args[0] - 1).is_negative
1891         if self.args[0].is_negative:
1892             return not (self.args[0] + 1).is_positive
1893 
1894     @classmethod
1895     def eval(cls, arg):
1896         if arg.is_Number:
1897             if arg is S.NaN:
1898                 return S.NaN
1899             elif arg is S.Infinity:
1900                 return S.NegativeInfinity * S.ImaginaryUnit
1901             elif arg is S.NegativeInfinity:
1902                 return S.Infinity * S.ImaginaryUnit
1903             elif arg is S.Zero:
1904                 return S.Zero
1905             elif arg is S.One:
1906                 return S.Pi / 2
1907             elif arg is S.NegativeOne:
1908                 return -S.Pi / 2
1909 
1910         if arg.could_extract_minus_sign():
1911             return -cls(-arg)
1912 
1913         if arg.is_number:
1914             cst_table = {
1915                 sqrt(3)/2: 3,
1916                 -sqrt(3)/2: -3,
1917                 sqrt(2)/2: 4,
1918                 -sqrt(2)/2: -4,
1919                 1/sqrt(2): 4,
1920                 -1/sqrt(2): -4,
1921                 sqrt((5 - sqrt(5))/8): 5,
1922                 -sqrt((5 - sqrt(5))/8): -5,
1923                 S.Half: 6,
1924                 -S.Half: -6,
1925                 sqrt(2 - sqrt(2))/2: 8,
1926                 -sqrt(2 - sqrt(2))/2: -8,
1927                 (sqrt(5) - 1)/4: 10,
1928                 (1 - sqrt(5))/4: -10,
1929                 (sqrt(3) - 1)/sqrt(2**3): 12,
1930                 (1 - sqrt(3))/sqrt(2**3): -12,
1931                 (sqrt(5) + 1)/4: S(10)/3,
1932                 -(sqrt(5) + 1)/4: -S(10)/3
1933             }
1934 
1935             if arg in cst_table:
1936                 return S.Pi / cst_table[arg]
1937 
1938         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1939         if i_coeff is not None:
1940             return S.ImaginaryUnit * asinh(i_coeff)
1941 
1942     @staticmethod
1943     @cacheit
1944     def taylor_term(n, x, *previous_terms):
1945         if n < 0 or n % 2 == 0:
1946             return S.Zero
1947         else:
1948             x = sympify(x)
1949             if len(previous_terms) >= 2 and n > 2:
1950                 p = previous_terms[-2]
1951                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1952             else:
1953                 k = (n - 1) // 2
1954                 R = RisingFactorial(S.Half, k)
1955                 F = factorial(k)
1956                 return R / F * x**n / n
1957 
1958     def _eval_as_leading_term(self, x):
1959         from sympy import Order
1960         arg = self.args[0].as_leading_term(x)
1961 
1962         if x in arg.free_symbols and Order(1, x).contains(arg):
1963             return arg
1964         else:
1965             return self.func(arg)
1966 
1967     def _eval_rewrite_as_acos(self, x):
1968         return S.Pi/2 - acos(x)
1969 
1970     def _eval_rewrite_as_atan(self, x):
1971         return 2*atan(x/(1 + sqrt(1 - x**2)))
1972 
1973     def _eval_rewrite_as_log(self, x):
1974         return -S.ImaginaryUnit*log(S.ImaginaryUnit*x + sqrt(1 - x**2))
1975 
1976     def _eval_rewrite_as_acot(self, arg):
1977         return 2*acot((1 + sqrt(1 - arg**2))/arg)
1978 
1979     def _eval_rewrite_as_asec(self, arg):
1980         return S.Pi/2 - asec(1/arg)
1981 
1982     def _eval_rewrite_as_acsc(self, arg):
1983         return acsc(1/arg)
1984 
1985     def _eval_is_real(self):
1986         x = self.args[0]
1987         return x.is_real and (1 - abs(x)).is_nonnegative
1988 
1989     def inverse(self, argindex=1):
1990         """
1991         Returns the inverse of this function.
1992         """
1993         return sin
1994 
1995 
1996 class acos(InverseTrigonometricFunction):
1997     """
1998     The inverse cosine function.
1999 
2000     Returns the arc cosine of x (measured in radians).
2001 
2002     Notes
2003     =====
2004 
2005     ``acos(x)`` will evaluate automatically in the cases
2006     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
2007 
2008     ``acos(zoo)`` evaluates to ``zoo``
2009     (see note in :py:class`sympy.functions.elementary.trigonometric.asec`)
2010 
2011     Examples
2012     ========
2013 
2014     >>> from sympy import acos, oo, pi
2015     >>> acos(1)
2016     0
2017     >>> acos(0)
2018     pi/2
2019     >>> acos(oo)
2020     oo*I
2021 
2022     See Also
2023     ========
2024 
2025     sin, csc, cos, sec, tan, cot
2026     asin, acsc, asec, atan, acot, atan2
2027 
2028     References
2029     ==========
2030 
2031     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2032     .. [2] http://dlmf.nist.gov/4.23
2033     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCos
2034     """
2035 
2036     def fdiff(self, argindex=1):
2037         if argindex == 1:
2038             return -1/sqrt(1 - self.args[0]**2)
2039         else:
2040             raise ArgumentIndexError(self, argindex)
2041 
2042     def _eval_is_rational(self):
2043         s = self.func(*self.args)
2044         if s.func == self.func:
2045             if s.args[0].is_rational:
2046                 return False
2047         else:
2048             return s.is_rational
2049 
2050     def _eval_is_positive(self):
2051         x = self.args[0]
2052         return (1 - abs(x)).is_nonnegative
2053 
2054     @classmethod
2055     def eval(cls, arg):
2056         if arg.is_Number:
2057             if arg is S.NaN:
2058                 return S.NaN
2059             elif arg is S.Infinity:
2060                 return S.Infinity * S.ImaginaryUnit
2061             elif arg is S.NegativeInfinity:
2062                 return S.NegativeInfinity * S.ImaginaryUnit
2063             elif arg is S.Zero:
2064                 return S.Pi / 2
2065             elif arg is S.One:
2066                 return S.Zero
2067             elif arg is S.NegativeOne:
2068                 return S.Pi
2069 
2070         if arg is S.ComplexInfinity:
2071             return S.ComplexInfinity
2072 
2073         if arg.is_number:
2074             cst_table = {
2075                 S.Half: S.Pi/3,
2076                 -S.Half: 2*S.Pi/3,
2077                 sqrt(2)/2: S.Pi/4,
2078                 -sqrt(2)/2: 3*S.Pi/4,
2079                 1/sqrt(2): S.Pi/4,
2080                 -1/sqrt(2): 3*S.Pi/4,
2081                 sqrt(3)/2: S.Pi/6,
2082                 -sqrt(3)/2: 5*S.Pi/6,
2083             }
2084 
2085             if arg in cst_table:
2086                 return cst_table[arg]
2087 
2088     @staticmethod
2089     @cacheit
2090     def taylor_term(n, x, *previous_terms):
2091         if n == 0:
2092             return S.Pi / 2
2093         elif n < 0 or n % 2 == 0:
2094             return S.Zero
2095         else:
2096             x = sympify(x)
2097             if len(previous_terms) >= 2 and n > 2:
2098                 p = previous_terms[-2]
2099                 return p * (n - 2)**2/(n*(n - 1)) * x**2
2100             else:
2101                 k = (n - 1) // 2
2102                 R = RisingFactorial(S.Half, k)
2103                 F = factorial(k)
2104                 return -R / F * x**n / n
2105 
2106     def _eval_as_leading_term(self, x):
2107         from sympy import Order
2108         arg = self.args[0].as_leading_term(x)
2109 
2110         if x in arg.free_symbols and Order(1, x).contains(arg):
2111             return arg
2112         else:
2113             return self.func(arg)
2114 
2115     def _eval_is_real(self):
2116         x = self.args[0]
2117         return x.is_real and (1 - abs(x)).is_nonnegative
2118 
2119     def _eval_rewrite_as_log(self, x):
2120         return S.Pi/2 + S.ImaginaryUnit * \
2121             log(S.ImaginaryUnit * x + sqrt(1 - x**2))
2122 
2123     def _eval_rewrite_as_asin(self, x):
2124         return S.Pi/2 - asin(x)
2125 
2126     def _eval_rewrite_as_atan(self, x):
2127         return atan(sqrt(1 - x**2)/x) + (S.Pi/2)*(1 - x*sqrt(1/x**2))
2128 
2129     def inverse(self, argindex=1):
2130         """
2131         Returns the inverse of this function.
2132         """
2133         return cos
2134 
2135     def _eval_rewrite_as_acot(self, arg):
2136         return S.Pi/2 - 2*acot((1 + sqrt(1 - arg**2))/arg)
2137 
2138     def _eval_rewrite_as_asec(self, arg):
2139         return asec(1/arg)
2140 
2141     def _eval_rewrite_as_acsc(self, arg):
2142         return S.Pi/2 - acsc(1/arg)
2143 
2144     def _eval_conjugate(self):
2145         z = self.args[0]
2146         r = self.func(self.args[0].conjugate())
2147         if z.is_real is False:
2148             return r
2149         elif z.is_real and (z + 1).is_nonnegative and (z - 1).is_nonpositive:
2150             return r
2151 
2152 
2153 class atan(InverseTrigonometricFunction):
2154     """
2155     The inverse tangent function.
2156 
2157     Returns the arc tangent of x (measured in radians).
2158 
2159     Notes
2160     =====
2161 
2162     atan(x) will evaluate automatically in the cases
2163     oo, -oo, 0, 1, -1.
2164 
2165     Examples
2166     ========
2167 
2168     >>> from sympy import atan, oo, pi
2169     >>> atan(0)
2170     0
2171     >>> atan(1)
2172     pi/4
2173     >>> atan(oo)
2174     pi/2
2175 
2176     See Also
2177     ========
2178 
2179     sin, csc, cos, sec, tan, cot
2180     asin, acsc, acos, asec, acot, atan2
2181 
2182     References
2183     ==========
2184 
2185     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2186     .. [2] http://dlmf.nist.gov/4.23
2187     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan
2188     """
2189 
2190     def fdiff(self, argindex=1):
2191         if argindex == 1:
2192             return 1/(1 + self.args[0]**2)
2193         else:
2194             raise ArgumentIndexError(self, argindex)
2195 
2196     def _eval_is_rational(self):
2197         s = self.func(*self.args)
2198         if s.func == self.func:
2199             if s.args[0].is_rational:
2200                 return False
2201         else:
2202             return s.is_rational
2203 
2204     def _eval_is_positive(self):
2205         return self.args[0].is_positive
2206 
2207     def _eval_is_nonnegative(self):
2208         return self.args[0].is_nonnegative
2209 
2210     @classmethod
2211     def eval(cls, arg):
2212         if arg.is_Number:
2213             if arg is S.NaN:
2214                 return S.NaN
2215             elif arg is S.Infinity:
2216                 return S.Pi / 2
2217             elif arg is S.NegativeInfinity:
2218                 return -S.Pi / 2
2219             elif arg is S.Zero:
2220                 return S.Zero
2221             elif arg is S.One:
2222                 return S.Pi / 4
2223             elif arg is S.NegativeOne:
2224                 return -S.Pi / 4
2225         if arg.could_extract_minus_sign():
2226             return -cls(-arg)
2227 
2228         if arg.is_number:
2229             cst_table = {
2230                 sqrt(3)/3: 6,
2231                 -sqrt(3)/3: -6,
2232                 1/sqrt(3): 6,
2233                 -1/sqrt(3): -6,
2234                 sqrt(3): 3,
2235                 -sqrt(3): -3,
2236                 (1 + sqrt(2)): S(8)/3,
2237                 -(1 + sqrt(2)): S(8)/3,
2238                 (sqrt(2) - 1): 8,
2239                 (1 - sqrt(2)): -8,
2240                 sqrt((5 + 2*sqrt(5))): S(5)/2,
2241                 -sqrt((5 + 2*sqrt(5))): -S(5)/2,
2242                 (2 - sqrt(3)): 12,
2243                 -(2 - sqrt(3)): -12
2244             }
2245 
2246             if arg in cst_table:
2247                 return S.Pi / cst_table[arg]
2248 
2249         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2250         if i_coeff is not None:
2251             return S.ImaginaryUnit * atanh(i_coeff)
2252 
2253     @staticmethod
2254     @cacheit
2255     def taylor_term(n, x, *previous_terms):
2256         if n < 0 or n % 2 == 0:
2257             return S.Zero
2258         else:
2259             x = sympify(x)
2260             return (-1)**((n - 1)//2) * x**n / n
2261 
2262     def _eval_as_leading_term(self, x):
2263         from sympy import Order
2264         arg = self.args[0].as_leading_term(x)
2265 
2266         if x in arg.free_symbols and Order(1, x).contains(arg):
2267             return arg
2268         else:
2269             return self.func(arg)
2270 
2271     def _eval_is_real(self):
2272         return self.args[0].is_real
2273 
2274     def _eval_rewrite_as_log(self, x):
2275         return S.ImaginaryUnit/2 * (log(S(1) - S.ImaginaryUnit * x)
2276             - log(S(1) + S.ImaginaryUnit * x))
2277 
2278     def _eval_aseries(self, n, args0, x, logx):
2279         if args0[0] == S.Infinity:
2280             return (S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2281         elif args0[0] == S.NegativeInfinity:
2282             return (-S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2283         else:
2284             return super(atan, self)._eval_aseries(n, args0, x, logx)
2285 
2286     def inverse(self, argindex=1):
2287         """
2288         Returns the inverse of this function.
2289         """
2290         return tan
2291 
2292     def _eval_rewrite_as_asin(self, arg):
2293         return sqrt(arg**2)/arg*(S.Pi/2 - asin(1/sqrt(1 + arg**2)))
2294 
2295     def _eval_rewrite_as_acos(self, arg):
2296         return sqrt(arg**2)/arg*acos(1/sqrt(1 + arg**2))
2297 
2298     def _eval_rewrite_as_acot(self, arg):
2299         return acot(1/arg)
2300 
2301     def _eval_rewrite_as_asec(self, arg):
2302         return sqrt(arg**2)/arg*asec(sqrt(1 + arg**2))
2303 
2304     def _eval_rewrite_as_acsc(self, arg):
2305         return sqrt(arg**2)/arg*(S.Pi/2 - acsc(sqrt(1 + arg**2)))
2306 
2307 
2308 class acot(InverseTrigonometricFunction):
2309     """
2310     The inverse cotangent function.
2311 
2312     Returns the arc cotangent of x (measured in radians).
2313 
2314     See Also
2315     ========
2316 
2317     sin, csc, cos, sec, tan, cot
2318     asin, acsc, acos, asec, atan, atan2
2319 
2320     References
2321     ==========
2322 
2323     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2324     .. [2] http://dlmf.nist.gov/4.23
2325     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCot
2326     """
2327 
2328     def fdiff(self, argindex=1):
2329         if argindex == 1:
2330             return -1 / (1 + self.args[0]**2)
2331         else:
2332             raise ArgumentIndexError(self, argindex)
2333 
2334     def _eval_is_rational(self):
2335         s = self.func(*self.args)
2336         if s.func == self.func:
2337             if s.args[0].is_rational:
2338                 return False
2339         else:
2340             return s.is_rational
2341 
2342     def _eval_is_positive(self):
2343         return self.args[0].is_real
2344 
2345     @classmethod
2346     def eval(cls, arg):
2347         if arg.is_Number:
2348             if arg is S.NaN:
2349                 return S.NaN
2350             elif arg is S.Infinity:
2351                 return S.Zero
2352             elif arg is S.NegativeInfinity:
2353                 return S.Zero
2354             elif arg is S.Zero:
2355                 return S.Pi/ 2
2356             elif arg is S.One:
2357                 return S.Pi / 4
2358             elif arg is S.NegativeOne:
2359                 return -S.Pi / 4
2360 
2361         if arg.could_extract_minus_sign():
2362             return -cls(-arg)
2363 
2364         if arg.is_number:
2365             cst_table = {
2366                 sqrt(3)/3: 3,
2367                 -sqrt(3)/3: -3,
2368                 1/sqrt(3): 3,
2369                 -1/sqrt(3): -3,
2370                 sqrt(3): 6,
2371                 -sqrt(3): -6,
2372                 (1 + sqrt(2)): 8,
2373                 -(1 + sqrt(2)): -8,
2374                 (1 - sqrt(2)): -S(8)/3,
2375                 (sqrt(2) - 1): S(8)/3,
2376                 sqrt(5 + 2*sqrt(5)): 10,
2377                 -sqrt(5 + 2*sqrt(5)): -10,
2378                 (2 + sqrt(3)): 12,
2379                 -(2 + sqrt(3)): -12,
2380                 (2 - sqrt(3)): S(12)/5,
2381                 -(2 - sqrt(3)): -S(12)/5,
2382             }
2383 
2384             if arg in cst_table:
2385                 return S.Pi / cst_table[arg]
2386 
2387         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2388         if i_coeff is not None:
2389             return -S.ImaginaryUnit * acoth(i_coeff)
2390 
2391     @staticmethod
2392     @cacheit
2393     def taylor_term(n, x, *previous_terms):
2394         if n == 0:
2395             return S.Pi / 2  # FIX THIS
2396         elif n < 0 or n % 2 == 0:
2397             return S.Zero
2398         else:
2399             x = sympify(x)
2400             return (-1)**((n + 1)//2) * x**n / n
2401 
2402     def _eval_as_leading_term(self, x):
2403         from sympy import Order
2404         arg = self.args[0].as_leading_term(x)
2405 
2406         if x in arg.free_symbols and Order(1, x).contains(arg):
2407             return arg
2408         else:
2409             return self.func(arg)
2410 
2411     def _eval_is_real(self):
2412         return self.args[0].is_real
2413 
2414     def _eval_aseries(self, n, args0, x, logx):
2415         if args0[0] == S.Infinity:
2416             return (S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2417         elif args0[0] == S.NegativeInfinity:
2418             return (3*S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2419         else:
2420             return super(atan, self)._eval_aseries(n, args0, x, logx)
2421 
2422     def _eval_rewrite_as_log(self, x):
2423         return S.ImaginaryUnit/2 * (log(1 - S.ImaginaryUnit/x)
2424             - log(1 + S.ImaginaryUnit/x))
2425 
2426     def inverse(self, argindex=1):
2427         """
2428         Returns the inverse of this function.
2429         """
2430         return cot
2431 
2432     def _eval_rewrite_as_asin(self, arg):
2433         return (arg*sqrt(1/arg**2)*
2434                 (S.Pi/2 - asin(sqrt(-arg**2)/sqrt(-arg**2 - 1))))
2435 
2436     def _eval_rewrite_as_acos(self, arg):
2437         return arg*sqrt(1/arg**2)*acos(sqrt(-arg**2)/sqrt(-arg**2 - 1))
2438 
2439     def _eval_rewrite_as_atan(self, arg):
2440         return atan(1/arg)
2441 
2442     def _eval_rewrite_as_asec(self, arg):
2443         return arg*sqrt(1/arg**2)*asec(sqrt((1 + arg**2)/arg**2))
2444 
2445     def _eval_rewrite_as_acsc(self, arg):
2446         return arg*sqrt(1/arg**2)*(S.Pi/2 - acsc(sqrt((1 + arg**2)/arg**2)))
2447 
2448 
2449 class asec(InverseTrigonometricFunction):
2450     r"""
2451     The inverse secant function.
2452 
2453     Returns the arc secant of x (measured in radians).
2454 
2455     Notes
2456     =====
2457 
2458     ``asec(x)`` will evaluate automatically in the cases
2459     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
2460 
2461     ``asec(x)`` has branch cut in the interval [-1, 1]. For complex arguments,
2462     it can be defined [4]_ as
2463 
2464     .. math::
2465         sec^{-1}(z) = -i*(log(\sqrt{1 - z^2} + 1) / z)
2466 
2467     At ``x = 0``, for positive branch cut, the limit evaluates to ``zoo``. For
2468     negative branch cut, the limit
2469 
2470     .. math::
2471         \lim_{z \to 0}-i*(log(-\sqrt{1 - z^2} + 1) / z)
2472 
2473     simplifies to :math:`-i*log(z/2 + O(z^3))` which ultimately evaluates to
2474     ``zoo``.
2475 
2476     As ``asex(x)`` = ``asec(1/x)``, a similar argument can be given for
2477     ``acos(x)``.
2478 
2479     Examples
2480     ========
2481 
2482     >>> from sympy import asec, oo, pi
2483     >>> asec(1)
2484     0
2485     >>> asec(-1)
2486     pi
2487 
2488     See Also
2489     ========
2490 
2491     sin, csc, cos, sec, tan, cot
2492     asin, acsc, acos, atan, acot, atan2
2493 
2494     References
2495     ==========
2496 
2497     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2498     .. [2] http://dlmf.nist.gov/4.23
2499     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSec
2500     .. [4] http://refrence.wolfram.com/language/ref/ArcSec.html
2501     """
2502 
2503     @classmethod
2504     def eval(cls, arg):
2505         if arg.is_zero:
2506             return S.ComplexInfinity
2507         if arg.is_Number:
2508             if arg is S.NaN:
2509                 return S.NaN
2510             elif arg is S.One:
2511                 return S.Zero
2512             elif arg is S.NegativeOne:
2513                 return S.Pi
2514         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2515             return S.Pi/2
2516 
2517     def fdiff(self, argindex=1):
2518         if argindex == 1:
2519             return 1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2520         else:
2521             raise ArgumentIndexError(self, argindex)
2522 
2523     def inverse(self, argindex=1):
2524         """
2525         Returns the inverse of this function.
2526         """
2527         return sec
2528 
2529     def _eval_as_leading_term(self, x):
2530         from sympy import Order
2531         arg = self.args[0].as_leading_term(x)
2532         if Order(1,x).contains(arg):
2533             return log(arg)
2534         else:
2535             return self.func(arg)
2536 
2537     def _eval_is_real(self):
2538         x = self.args[0]
2539         if x.is_real is False:
2540             return False
2541         return (x - 1).is_nonnegative or (-x - 1).is_nonnegative
2542 
2543     def _eval_rewrite_as_log(self, arg):
2544         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2545 
2546     def _eval_rewrite_as_asin(self, arg):
2547         return S.Pi/2 - asin(1/arg)
2548 
2549     def _eval_rewrite_as_acos(self, arg):
2550         return acos(1/arg)
2551 
2552     def _eval_rewrite_as_atan(self, arg):
2553         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*atan(arg + sqrt(arg**2 - 1)))
2554 
2555     def _eval_rewrite_as_acot(self, arg):
2556         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*acot(arg - sqrt(arg**2 - 1)))
2557 
2558     def _eval_rewrite_as_acsc(self, arg):
2559         return S.Pi/2 - acsc(arg)
2560 
2561 
2562 class acsc(InverseTrigonometricFunction):
2563     """
2564     The inverse cosecant function.
2565 
2566     Returns the arc cosecant of x (measured in radians).
2567 
2568     Notes
2569     =====
2570 
2571     acsc(x) will evaluate automatically in the cases
2572     oo, -oo, 0, 1, -1.
2573 
2574     Examples
2575     ========
2576 
2577     >>> from sympy import acsc, oo, pi
2578     >>> acsc(1)
2579     pi/2
2580     >>> acsc(-1)
2581     -pi/2
2582 
2583     See Also
2584     ========
2585 
2586     sin, csc, cos, sec, tan, cot
2587     asin, acos, asec, atan, acot, atan2
2588 
2589     References
2590     ==========
2591 
2592     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2593     .. [2] http://dlmf.nist.gov/4.23
2594     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsc
2595     """
2596 
2597     @classmethod
2598     def eval(cls, arg):
2599         if arg.is_Number:
2600             if arg is S.NaN:
2601                 return S.NaN
2602             elif arg is S.One:
2603                 return S.Pi/2
2604             elif arg is S.NegativeOne:
2605                 return -S.Pi/2
2606         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2607             return S.Zero
2608 
2609     def fdiff(self, argindex=1):
2610         if argindex == 1:
2611             return -1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2612         else:
2613             raise ArgumentIndexError(self, argindex)
2614 
2615     def inverse(self, argindex=1):
2616         """
2617         Returns the inverse of this function.
2618         """
2619         return csc
2620 
2621     def _eval_as_leading_term(self, x):
2622         from sympy import Order
2623         arg = self.args[0].as_leading_term(x)
2624         if Order(1,x).contains(arg):
2625             return log(arg)
2626         else:
2627             return self.func(arg)
2628 
2629     def _eval_rewrite_as_log(self, arg):
2630         return -S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2631 
2632     def _eval_rewrite_as_asin(self, arg):
2633         return asin(1/arg)
2634 
2635     def _eval_rewrite_as_acos(self, arg):
2636         return S.Pi/2 - acos(1/arg)
2637 
2638     def _eval_rewrite_as_atan(self, arg):
2639         return sqrt(arg**2)/arg*(S.Pi/2 - atan(sqrt(arg**2 - 1)))
2640 
2641     def _eval_rewrite_as_acot(self, arg):
2642         return sqrt(arg**2)/arg*(S.Pi/2 - acot(1/sqrt(arg**2 - 1)))
2643 
2644     def _eval_rewrite_as_asec(self, arg):
2645         return S.Pi/2 - asec(arg)
2646 
2647 
2648 class atan2(InverseTrigonometricFunction):
2649     r"""
2650     The function ``atan2(y, x)`` computes `\operatorname{atan}(y/x)` taking
2651     two arguments `y` and `x`.  Signs of both `y` and `x` are considered to
2652     determine the appropriate quadrant of `\operatorname{atan}(y/x)`.
2653     The range is `(-\pi, \pi]`. The complete definition reads as follows:
2654 
2655     .. math::
2656 
2657         \operatorname{atan2}(y, x) =
2658         \begin{cases}
2659           \arctan\left(\frac y x\right) & \qquad x > 0 \\
2660           \arctan\left(\frac y x\right) + \pi& \qquad y \ge 0 , x < 0 \\
2661           \arctan\left(\frac y x\right) - \pi& \qquad y < 0 , x < 0 \\
2662           +\frac{\pi}{2} & \qquad y > 0 , x = 0 \\
2663           -\frac{\pi}{2} & \qquad y < 0 , x = 0 \\
2664           \text{undefined} & \qquad y = 0, x = 0
2665         \end{cases}
2666 
2667     Attention: Note the role reversal of both arguments. The `y`-coordinate
2668     is the first argument and the `x`-coordinate the second.
2669 
2670     Examples
2671     ========
2672 
2673     Going counter-clock wise around the origin we find the
2674     following angles:
2675 
2676     >>> from sympy import atan2
2677     >>> atan2(0, 1)
2678     0
2679     >>> atan2(1, 1)
2680     pi/4
2681     >>> atan2(1, 0)
2682     pi/2
2683     >>> atan2(1, -1)
2684     3*pi/4
2685     >>> atan2(0, -1)
2686     pi
2687     >>> atan2(-1, -1)
2688     -3*pi/4
2689     >>> atan2(-1, 0)
2690     -pi/2
2691     >>> atan2(-1, 1)
2692     -pi/4
2693 
2694     which are all correct. Compare this to the results of the ordinary
2695     `\operatorname{atan}` function for the point `(x, y) = (-1, 1)`
2696 
2697     >>> from sympy import atan, S
2698     >>> atan(S(1) / -1)
2699     -pi/4
2700     >>> atan2(1, -1)
2701     3*pi/4
2702 
2703     where only the `\operatorname{atan2}` function reurns what we expect.
2704     We can differentiate the function with respect to both arguments:
2705 
2706     >>> from sympy import diff
2707     >>> from sympy.abc import x, y
2708     >>> diff(atan2(y, x), x)
2709     -y/(x**2 + y**2)
2710 
2711     >>> diff(atan2(y, x), y)
2712     x/(x**2 + y**2)
2713 
2714     We can express the `\operatorname{atan2}` function in terms of
2715     complex logarithms:
2716 
2717     >>> from sympy import log
2718     >>> atan2(y, x).rewrite(log)
2719     -I*log((x + I*y)/sqrt(x**2 + y**2))
2720 
2721     and in terms of `\operatorname(atan)`:
2722 
2723     >>> from sympy import atan
2724     >>> atan2(y, x).rewrite(atan)
2725     2*atan(y/(x + sqrt(x**2 + y**2)))
2726 
2727     but note that this form is undefined on the negative real axis.
2728 
2729     See Also
2730     ========
2731 
2732     sin, csc, cos, sec, tan, cot
2733     asin, acsc, acos, asec, atan, acot
2734 
2735     References
2736     ==========
2737 
2738     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2739     .. [2] http://en.wikipedia.org/wiki/Atan2
2740     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan2
2741     """
2742 
2743     @classmethod
2744     def eval(cls, y, x):
2745         from sympy import Heaviside, im, re
2746         if x is S.NegativeInfinity:
2747             if y.is_zero:
2748                 # Special case y = 0 because we define Heaviside(0) = 1/2
2749                 return S.Pi
2750             return 2*S.Pi*(Heaviside(re(y))) - S.Pi
2751         elif x is S.Infinity:
2752             return S.Zero
2753         elif x.is_imaginary and y.is_imaginary and x.is_number and y.is_number:
2754             x = im(x)
2755             y = im(y)
2756 
2757         if x.is_real and y.is_real:
2758             if x.is_positive:
2759                 return atan(y / x)
2760             elif x.is_negative:
2761                 if y.is_negative:
2762                     return atan(y / x) - S.Pi
2763                 elif y.is_nonnegative:
2764                     return atan(y / x) + S.Pi
2765             elif x.is_zero:
2766                 if y.is_positive:
2767                     return S.Pi/2
2768                 elif y.is_negative:
2769                     return -S.Pi/2
2770                 elif y.is_zero:
2771                     return S.NaN
2772         if y.is_zero and x.is_real and fuzzy_not(x.is_zero):
2773             return S.Pi * (S.One - Heaviside(x))
2774         if x.is_number and y.is_number:
2775             return -S.ImaginaryUnit*log(
2776                 (x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))
2777 
2778     def _eval_rewrite_as_log(self, y, x):
2779         return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y) / sqrt(x**2 + y**2))
2780 
2781     def _eval_rewrite_as_atan(self, y, x):
2782         return 2*atan(y / (sqrt(x**2 + y**2) + x))
2783 
2784     def _eval_rewrite_as_arg(self, y, x):
2785         from sympy import arg
2786         if x.is_real and y.is_real:
2787             return arg(x + y*S.ImaginaryUnit)
2788         I = S.ImaginaryUnit
2789         n = x + I*y
2790         d = x**2 + y**2
2791         return arg(n/sqrt(d)) - I*log(abs(n)/sqrt(abs(d)))
2792 
2793     def _eval_is_real(self):
2794         return self.args[0].is_real and self.args[1].is_real
2795 
2796     def _eval_conjugate(self):
2797         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
2798 
2799     def fdiff(self, argindex):
2800         y, x = self.args
2801         if argindex == 1:
2802             # Diff wrt y
2803             return x/(x**2 + y**2)
2804         elif argindex == 2:
2805             # Diff wrt x
2806             return -y/(x**2 + y**2)
2807         else:
2808             raise ArgumentIndexError(self, argindex)
2809 
2810     def _eval_evalf(self, prec):
2811         y, x = self.args
2812         if x.is_real and y.is_real:
2813             super(atan2, self)._eval_evalf(prec)

</code><intended_behavior>The evaluation and simplification logic should correctly handle complex arguments, avoiding incorrect transformations or assumptions about trigonometric and hyperbolic functions.</intended_behavior>, <file>sympy/functions/elementary/hyperbolic.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import S, sympify, cacheit
4 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
5 
6 from sympy.functions.elementary.miscellaneous import sqrt
7 
8 from sympy.functions.elementary.exponential import exp, log
9 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
10 
11 
12 def _rewrite_hyperbolics_as_exp(expr):
13     expr = sympify(expr)
14     return expr.xreplace(dict([(h, h.rewrite(exp))
15         for h in expr.atoms(HyperbolicFunction)]))
16 
17 
18 ###############################################################################
19 ########################### HYPERBOLIC FUNCTIONS ##############################
20 ###############################################################################
21 
22 
23 class HyperbolicFunction(Function):
24     """
25     Base class for hyperbolic functions.
26 
27     See Also
28     ========
29 
30     sinh, cosh, tanh, coth
31     """
32 
33     unbranched = True
34 
35 
36 class sinh(HyperbolicFunction):
37     r"""
38     The hyperbolic sine function, `\frac{e^x - e^{-x}}{2}`.
39 
40     * sinh(x) -> Returns the hyperbolic sine of x
41 
42     See Also
43     ========
44 
45     cosh, tanh, asinh
46     """
47 
48     def fdiff(self, argindex=1):
49         """
50         Returns the first derivative of this function.
51         """
52         if argindex == 1:
53             return cosh(self.args[0])
54         else:
55             raise ArgumentIndexError(self, argindex)
56 
57     def inverse(self, argindex=1):
58         """
59         Returns the inverse of this function.
60         """
61         return asinh
62 
63     @classmethod
64     def eval(cls, arg):
65         from sympy import sin
66 
67         arg = sympify(arg)
68 
69         if arg.is_Number:
70             if arg is S.NaN:
71                 return S.NaN
72             elif arg is S.Infinity:
73                 return S.Infinity
74             elif arg is S.NegativeInfinity:
75                 return S.NegativeInfinity
76             elif arg is S.Zero:
77                 return S.Zero
78             elif arg.is_negative:
79                 return -cls(-arg)
80         else:
81             if arg is S.ComplexInfinity:
82                 return S.NaN
83 
84             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
85 
86             if i_coeff is not None:
87                 return S.ImaginaryUnit * sin(i_coeff)
88             else:
89                 if _coeff_isneg(arg):
90                     return -cls(-arg)
91 
92             if arg.func == asinh:
93                 return arg.args[0]
94 
95             if arg.func == acosh:
96                 x = arg.args[0]
97                 return sqrt(x - 1) * sqrt(x + 1)
98 
99             if arg.func == atanh:
100                 x = arg.args[0]
101                 return x/sqrt(1 - x**2)
102 
103             if arg.func == acoth:
104                 x = arg.args[0]
105                 return 1/(sqrt(x - 1) * sqrt(x + 1))
106 
107     @staticmethod
108     @cacheit
109     def taylor_term(n, x, *previous_terms):
110         """
111         Returns the next term in the Taylor series expansion.
112         """
113         if n < 0 or n % 2 == 0:
114             return S.Zero
115         else:
116             x = sympify(x)
117 
118             if len(previous_terms) > 2:
119                 p = previous_terms[-2]
120                 return p * x**2 / (n*(n - 1))
121             else:
122                 return x**(n) / factorial(n)
123 
124     def _eval_conjugate(self):
125         return self.func(self.args[0].conjugate())
126 
127     def as_real_imag(self, deep=True, **hints):
128         """
129         Returns this function as a complex coordinate.
130         """
131         from sympy import cos, sin
132         if self.args[0].is_real:
133             if deep:
134                 hints['complex'] = False
135                 return (self.expand(deep, **hints), S.Zero)
136             else:
137                 return (self, S.Zero)
138         if deep:
139             re, im = self.args[0].expand(deep, **hints).as_real_imag()
140         else:
141             re, im = self.args[0].as_real_imag()
142         return (sinh(re)*cos(im), cosh(re)*sin(im))
143 
144     def _eval_expand_complex(self, deep=True, **hints):
145         re_part, im_part = self.as_real_imag(deep=deep, **hints)
146         return re_part + im_part*S.ImaginaryUnit
147 
148     def _eval_expand_trig(self, deep=True, **hints):
149         if deep:
150             arg = self.args[0].expand(deep, **hints)
151         else:
152             arg = self.args[0]
153         x = None
154         if arg.is_Add: # TODO, implement more if deep stuff here
155             x, y = arg.as_two_terms()
156         else:
157             coeff, terms = arg.as_coeff_Mul(rational=True)
158             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
159                 x = terms
160                 y = (coeff - 1)*x
161         if x is not None:
162             return (sinh(x)*cosh(y) + sinh(y)*cosh(x)).expand(trig=True)
163         return sinh(arg)
164 
165     def _eval_rewrite_as_tractable(self, arg):
166         return (exp(arg) - exp(-arg)) / 2
167 
168     def _eval_rewrite_as_exp(self, arg):
169         return (exp(arg) - exp(-arg)) / 2
170 
171     def _eval_rewrite_as_cosh(self, arg):
172         return -S.ImaginaryUnit*cosh(arg + S.Pi*S.ImaginaryUnit/2)
173 
174     def _eval_rewrite_as_tanh(self, arg):
175         tanh_half = tanh(S.Half*arg)
176         return 2*tanh_half/(1 - tanh_half**2)
177 
178     def _eval_rewrite_as_coth(self, arg):
179         coth_half = coth(S.Half*arg)
180         return 2*coth_half/(coth_half**2 - 1)
181 
182     def _eval_as_leading_term(self, x):
183         from sympy import Order
184         arg = self.args[0].as_leading_term(x)
185 
186         if x in arg.free_symbols and Order(1, x).contains(arg):
187             return arg
188         else:
189             return self.func(arg)
190 
191     def _eval_is_real(self):
192         return self.args[0].is_real
193 
194     def _eval_is_finite(self):
195         arg = self.args[0]
196         if arg.is_imaginary:
197             return True
198 
199 
200 class cosh(HyperbolicFunction):
201     r"""
202     The hyperbolic cosine function, `\frac{e^x + e^{-x}}{2}`.
203 
204     * cosh(x) -> Returns the hyperbolic cosine of x
205 
206     See Also
207     ========
208 
209     sinh, tanh, acosh
210     """
211 
212     def fdiff(self, argindex=1):
213         if argindex == 1:
214             return sinh(self.args[0])
215         else:
216             raise ArgumentIndexError(self, argindex)
217 
218     @classmethod
219     def eval(cls, arg):
220         from sympy import cos
221         arg = sympify(arg)
222 
223         if arg.is_Number:
224             if arg is S.NaN:
225                 return S.NaN
226             elif arg is S.Infinity:
227                 return S.Infinity
228             elif arg is S.NegativeInfinity:
229                 return S.Infinity
230             elif arg is S.Zero:
231                 return S.One
232             elif arg.is_negative:
233                 return cls(-arg)
234         else:
235             if arg is S.ComplexInfinity:
236                 return S.NaN
237 
238             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
239 
240             if i_coeff is not None:
241                 return cos(i_coeff)
242             else:
243                 if _coeff_isneg(arg):
244                     return cls(-arg)
245 
246             if arg.func == asinh:
247                 return sqrt(1 + arg.args[0]**2)
248 
249             if arg.func == acosh:
250                 return arg.args[0]
251 
252             if arg.func == atanh:
253                 return 1/sqrt(1 - arg.args[0]**2)
254 
255             if arg.func == acoth:
256                 x = arg.args[0]
257                 return x/(sqrt(x - 1) * sqrt(x + 1))
258 
259     @staticmethod
260     @cacheit
261     def taylor_term(n, x, *previous_terms):
262         if n < 0 or n % 2 == 1:
263             return S.Zero
264         else:
265             x = sympify(x)
266 
267             if len(previous_terms) > 2:
268                 p = previous_terms[-2]
269                 return p * x**2 / (n*(n - 1))
270             else:
271                 return x**(n)/factorial(n)
272 
273     def _eval_conjugate(self):
274         return self.func(self.args[0].conjugate())
275 
276     def as_real_imag(self, deep=True, **hints):
277         from sympy import cos, sin
278         if self.args[0].is_real:
279             if deep:
280                 hints['complex'] = False
281                 return (self.expand(deep, **hints), S.Zero)
282             else:
283                 return (self, S.Zero)
284         if deep:
285             re, im = self.args[0].expand(deep, **hints).as_real_imag()
286         else:
287             re, im = self.args[0].as_real_imag()
288 
289         return (cosh(re)*cos(im), sinh(re)*sin(im))
290 
291     def _eval_expand_complex(self, deep=True, **hints):
292         re_part, im_part = self.as_real_imag(deep=deep, **hints)
293         return re_part + im_part*S.ImaginaryUnit
294 
295     def _eval_expand_trig(self, deep=True, **hints):
296         if deep:
297             arg = self.args[0].expand(deep, **hints)
298         else:
299             arg = self.args[0]
300         x = None
301         if arg.is_Add: # TODO, implement more if deep stuff here
302             x, y = arg.as_two_terms()
303         else:
304             coeff, terms = arg.as_coeff_Mul(rational=True)
305             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
306                 x = terms
307                 y = (coeff - 1)*x
308         if x is not None:
309             return (cosh(x)*cosh(y) + sinh(x)*sinh(y)).expand(trig=True)
310         return cosh(arg)
311 
312     def _eval_rewrite_as_tractable(self, arg):
313         return (exp(arg) + exp(-arg)) / 2
314 
315     def _eval_rewrite_as_exp(self, arg):
316         return (exp(arg) + exp(-arg)) / 2
317 
318     def _eval_rewrite_as_sinh(self, arg):
319         return -S.ImaginaryUnit*sinh(arg + S.Pi*S.ImaginaryUnit/2)
320 
321     def _eval_rewrite_as_tanh(self, arg):
322         tanh_half = tanh(S.Half*arg)**2
323         return (1 + tanh_half)/(1 - tanh_half)
324 
325     def _eval_rewrite_as_coth(self, arg):
326         coth_half = coth(S.Half*arg)**2
327         return (coth_half + 1)/(coth_half - 1)
328 
329     def _eval_as_leading_term(self, x):
330         from sympy import Order
331         arg = self.args[0].as_leading_term(x)
332 
333         if x in arg.free_symbols and Order(1, x).contains(arg):
334             return S.One
335         else:
336             return self.func(arg)
337 
338     def _eval_is_real(self):
339         return self.args[0].is_real
340 
341     def _eval_is_finite(self):
342         arg = self.args[0]
343         if arg.is_imaginary:
344             return True
345 
346 
347 class tanh(HyperbolicFunction):
348     r"""
349     The hyperbolic tangent function, `\frac{\sinh(x)}{\cosh(x)}`.
350 
351     * tanh(x) -> Returns the hyperbolic tangent of x
352 
353     See Also
354     ========
355 
356     sinh, cosh, atanh
357     """
358 
359     def fdiff(self, argindex=1):
360         if argindex == 1:
361             return S.One - tanh(self.args[0])**2
362         else:
363             raise ArgumentIndexError(self, argindex)
364 
365     def inverse(self, argindex=1):
366         """
367         Returns the inverse of this function.
368         """
369         return atanh
370 
371     @classmethod
372     def eval(cls, arg):
373         from sympy import tan
374         arg = sympify(arg)
375 
376         if arg.is_Number:
377             if arg is S.NaN:
378                 return S.NaN
379             elif arg is S.Infinity:
380                 return S.One
381             elif arg is S.NegativeInfinity:
382                 return S.NegativeOne
383             elif arg is S.Zero:
384                 return S.Zero
385             elif arg.is_negative:
386                 return -cls(-arg)
387         else:
388             if arg is S.ComplexInfinity:
389                 return S.NaN
390 
391             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
392 
393             if i_coeff is not None:
394                 if _coeff_isneg(i_coeff):
395                     return -S.ImaginaryUnit * tan(-i_coeff)
396                 return S.ImaginaryUnit * tan(i_coeff)
397             else:
398                 if _coeff_isneg(arg):
399                     return -cls(-arg)
400 
401             if arg.func == asinh:
402                 x = arg.args[0]
403                 return x/sqrt(1 + x**2)
404 
405             if arg.func == acosh:
406                 x = arg.args[0]
407                 return sqrt(x - 1) * sqrt(x + 1) / x
408 
409             if arg.func == atanh:
410                 return arg.args[0]
411 
412             if arg.func == acoth:
413                 return 1/arg.args[0]
414 
415     @staticmethod
416     @cacheit
417     def taylor_term(n, x, *previous_terms):
418         from sympy import bernoulli
419         if n < 0 or n % 2 == 0:
420             return S.Zero
421         else:
422             x = sympify(x)
423 
424             a = 2**(n + 1)
425 
426             B = bernoulli(n + 1)
427             F = factorial(n + 1)
428 
429             return a*(a - 1) * B/F * x**n
430 
431     def _eval_conjugate(self):
432         return self.func(self.args[0].conjugate())
433 
434     def as_real_imag(self, deep=True, **hints):
435         from sympy import cos, sin
436         if self.args[0].is_real:
437             if deep:
438                 hints['complex'] = False
439                 return (self.expand(deep, **hints), S.Zero)
440             else:
441                 return (self, S.Zero)
442         if deep:
443             re, im = self.args[0].expand(deep, **hints).as_real_imag()
444         else:
445             re, im = self.args[0].as_real_imag()
446         denom = sinh(re)**2 + cos(im)**2
447         return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)
448 
449     def _eval_rewrite_as_tractable(self, arg):
450         neg_exp, pos_exp = exp(-arg), exp(arg)
451         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
452 
453     def _eval_rewrite_as_exp(self, arg):
454         neg_exp, pos_exp = exp(-arg), exp(arg)
455         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
456 
457     def _eval_rewrite_as_sinh(self, arg):
458         return S.ImaginaryUnit*sinh(arg)/sinh(S.Pi*S.ImaginaryUnit/2 - arg)
459 
460     def _eval_rewrite_as_cosh(self, arg):
461         return S.ImaginaryUnit*cosh(S.Pi*S.ImaginaryUnit/2 - arg)/cosh(arg)
462 
463     def _eval_rewrite_as_coth(self, arg):
464         return 1/coth(arg)
465 
466     def _eval_as_leading_term(self, x):
467         from sympy import Order
468         arg = self.args[0].as_leading_term(x)
469 
470         if x in arg.free_symbols and Order(1, x).contains(arg):
471             return arg
472         else:
473             return self.func(arg)
474 
475     def _eval_is_real(self):
476         return self.args[0].is_real
477 
478     def _eval_is_finite(self):
479         arg = self.args[0]
480         if arg.is_real:
481             return True
482 
483 
484 class coth(HyperbolicFunction):
485     r"""
486     The hyperbolic cotangent function, `\frac{\cosh(x)}{\sinh(x)}`.
487 
488     * coth(x) -> Returns the hyperbolic cotangent of x
489     """
490 
491     def fdiff(self, argindex=1):
492         if argindex == 1:
493             return -1/sinh(self.args[0])**2
494         else:
495             raise ArgumentIndexError(self, argindex)
496 
497     def inverse(self, argindex=1):
498         """
499         Returns the inverse of this function.
500         """
501         return acoth
502 
503     @classmethod
504     def eval(cls, arg):
505         from sympy import cot
506         arg = sympify(arg)
507 
508         if arg.is_Number:
509             if arg is S.NaN:
510                 return S.NaN
511             elif arg is S.Infinity:
512                 return S.One
513             elif arg is S.NegativeInfinity:
514                 return S.NegativeOne
515             elif arg is S.Zero:
516                 return S.ComplexInfinity
517             elif arg.is_negative:
518                 return -cls(-arg)
519         else:
520             if arg is S.ComplexInfinity:
521                 return S.NaN
522 
523             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
524 
525             if i_coeff is not None:
526                 if _coeff_isneg(i_coeff):
527                     return S.ImaginaryUnit * cot(-i_coeff)
528                 return -S.ImaginaryUnit * cot(i_coeff)
529             else:
530                 if _coeff_isneg(arg):
531                     return -cls(-arg)
532 
533             if arg.func == asinh:
534                 x = arg.args[0]
535                 return sqrt(1 + x**2)/x
536 
537             if arg.func == acosh:
538                 x = arg.args[0]
539                 return x/(sqrt(x - 1) * sqrt(x + 1))
540 
541             if arg.func == atanh:
542                 return 1/arg.args[0]
543 
544             if arg.func == acoth:
545                 return arg.args[0]
546 
547     @staticmethod
548     @cacheit
549     def taylor_term(n, x, *previous_terms):
550         from sympy import bernoulli
551         if n == 0:
552             return 1 / sympify(x)
553         elif n < 0 or n % 2 == 0:
554             return S.Zero
555         else:
556             x = sympify(x)
557 
558             B = bernoulli(n + 1)
559             F = factorial(n + 1)
560 
561             return 2**(n + 1) * B/F * x**n
562 
563     def _eval_conjugate(self):
564         return self.func(self.args[0].conjugate())
565 
566     def as_real_imag(self, deep=True, **hints):
567         from sympy import cos, sin
568         if self.args[0].is_real:
569             if deep:
570                 hints['complex'] = False
571                 return (self.expand(deep, **hints), S.Zero)
572             else:
573                 return (self, S.Zero)
574         if deep:
575             re, im = self.args[0].expand(deep, **hints).as_real_imag()
576         else:
577             re, im = self.args[0].as_real_imag()
578         denom = sinh(re)**2 + sin(im)**2
579         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)
580 
581     def _eval_rewrite_as_tractable(self, arg):
582         neg_exp, pos_exp = exp(-arg), exp(arg)
583         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
584 
585     def _eval_rewrite_as_exp(self, arg):
586         neg_exp, pos_exp = exp(-arg), exp(arg)
587         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
588 
589     def _eval_rewrite_as_sinh(self, arg):
590         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)
591 
592     def _eval_rewrite_as_cosh(self, arg):
593         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)
594 
595     def _eval_rewrite_as_tanh(self, arg):
596         return 1/tanh(arg)
597 
598     def _eval_as_leading_term(self, x):
599         from sympy import Order
600         arg = self.args[0].as_leading_term(x)
601 
602         if x in arg.free_symbols and Order(1, x).contains(arg):
603             return 1/arg
604         else:
605             return self.func(arg)
606 
607 
608 class ReciprocalHyperbolicFunction(HyperbolicFunction):
609     """Base class for reciprocal functions of hyperbolic functions. """
610 
611     #To be defined in class
612     _reciprocal_of = None
613     _is_even = None
614     _is_odd = None
615 
616     @classmethod
617     def eval(cls, arg):
618         if arg.could_extract_minus_sign():
619             if cls._is_even:
620                 return cls(-arg)
621             if cls._is_odd:
622                 return -cls(-arg)
623 
624         t = cls._reciprocal_of.eval(arg)
625         if hasattr(arg, 'inverse') and arg.inverse() == cls:
626             return arg.args[0]
627         return 1/t if t != None else t
628 
629     def _call_reciprocal(self, method_name, *args, **kwargs):
630         # Calls method_name on _reciprocal_of
631         o = self._reciprocal_of(self.args[0])
632         return getattr(o, method_name)(*args, **kwargs)
633 
634     def _calculate_reciprocal(self, method_name, *args, **kwargs):
635         # If calling method_name on _reciprocal_of returns a value != None
636         # then return the reciprocal of that value
637         t = self._call_reciprocal(method_name, *args, **kwargs)
638         return 1/t if t != None else t
639 
640     def _rewrite_reciprocal(self, method_name, arg):
641         # Special handling for rewrite functions. If reciprocal rewrite returns
642         # unmodified expression, then return None
643         t = self._call_reciprocal(method_name, arg)
644         if t != None and t != self._reciprocal_of(arg):
645             return 1/t
646 
647     def _eval_rewrite_as_exp(self, arg):
648         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
649 
650     def _eval_rewrite_as_tractable(self, arg):
651         return self._rewrite_reciprocal("_eval_rewrite_as_tractable", arg)
652 
653     def _eval_rewrite_as_tanh(self, arg):
654         return self._rewrite_reciprocal("_eval_rewrite_as_tanh", arg)
655 
656     def _eval_rewrite_as_coth(self, arg):
657         return self._rewrite_reciprocal("_eval_rewrite_as_coth", arg)
658 
659     def as_real_imag(self, deep = True, **hints):
660         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)
661 
662     def _eval_conjugate(self):
663         return self.func(self.args[0].conjugate())
664 
665     def _eval_expand_complex(self, deep=True, **hints):
666         re_part, im_part = self.as_real_imag(deep=True, **hints)
667         return re_part + S.ImaginaryUnit*im_part
668 
669     def _eval_as_leading_term(self, x):
670         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
671 
672     def _eval_is_real(self):
673         return self._reciprocal_of(self.args[0]).is_real
674 
675     def _eval_is_finite(self):
676         return (1/self._reciprocal_of(self.args[0])).is_finite
677 
678 
679 class csch(ReciprocalHyperbolicFunction):
680     r"""
681     The hyperbolic cosecant function, `\frac{2}{e^x - e^{-x}}`
682 
683     * csch(x) -> Returns the hyperbolic cosecant of x
684 
685     See Also
686     ========
687 
688     sinh, cosh, tanh, sech, asinh, acosh
689     """
690 
691     _reciprocal_of = sinh
692     _is_odd = True
693 
694     def fdiff(self, argindex=1):
695         """
696         Returns the first derivative of this function
697         """
698         if argindex == 1:
699             return -coth(self.args[0]) * csch(self.args[0])
700         else:
701             raise ArgumentIndexError(self, argindex)
702 
703     @staticmethod
704     @cacheit
705     def taylor_term(n, x, *previous_terms):
706         """
707         Returns the next term in the Taylor series expansion
708         """
709         from sympy import bernoulli
710         if n == 0:
711             return 1/sympify(x)
712         elif n < 0 or n % 2 == 0:
713             return S.Zero
714         else:
715             x = sympify(x)
716 
717             B = bernoulli(n + 1)
718             F = factorial(n + 1)
719 
720             return 2 * (1 - 2**n) * B/F * x**n
721 
722     def _eval_rewrite_as_cosh(self, arg):
723         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)
724 
725     def _sage_(self):
726         import sage.all as sage
727         return sage.csch(self.args[0]._sage_())
728 
729 
730 class sech(ReciprocalHyperbolicFunction):
731     r"""
732     The hyperbolic secant function, `\frac{2}{e^x + e^{-x}}`
733 
734     * sech(x) -> Returns the hyperbolic secant of x
735 
736     See Also
737     ========
738 
739     sinh, cosh, tanh, coth, csch, asinh, acosh
740     """
741 
742     _reciprocal_of = cosh
743     _is_even = True
744 
745     def fdiff(self, argindex=1):
746         if argindex == 1:
747             return - tanh(self.args[0])*sech(self.args[0])
748         else:
749             raise ArgumentIndexError(self, argindex)
750 
751     @staticmethod
752     @cacheit
753     def taylor_term(n, x, *previous_terms):
754         from sympy.functions.combinatorial.numbers import euler
755         if n < 0 or n % 2 == 1:
756             return S.Zero
757         else:
758             x = sympify(x)
759             return euler(n) / factorial(n) * x**(n)
760 
761     def _eval_rewrite_as_sinh(self, arg):
762         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)
763 
764     def _sage_(self):
765         import sage.all as sage
766         return sage.sech(self.args[0]._sage_())
767 
768 
769 
770 ###############################################################################
771 ############################# HYPERBOLIC INVERSES #############################
772 ###############################################################################
773 
774 class InverseHyperbolicFunction(Function):
775     """Base class for inverse hyperbolic functions."""
776 
777     pass
778 
779 
780 class asinh(InverseHyperbolicFunction):
781     """
782     The inverse hyperbolic sine function.
783 
784     * asinh(x) -> Returns the inverse hyperbolic sine of x
785 
786     See Also
787     ========
788 
789     acosh, atanh, sinh
790     """
791 
792     def fdiff(self, argindex=1):
793         if argindex == 1:
794             return 1/sqrt(self.args[0]**2 + 1)
795         else:
796             raise ArgumentIndexError(self, argindex)
797 
798     @classmethod
799     def eval(cls, arg):
800         from sympy import asin
801         arg = sympify(arg)
802 
803         if arg.is_Number:
804             if arg is S.NaN:
805                 return S.NaN
806             elif arg is S.Infinity:
807                 return S.Infinity
808             elif arg is S.NegativeInfinity:
809                 return S.NegativeInfinity
810             elif arg is S.Zero:
811                 return S.Zero
812             elif arg is S.One:
813                 return log(sqrt(2) + 1)
814             elif arg is S.NegativeOne:
815                 return log(sqrt(2) - 1)
816             elif arg.is_negative:
817                 return -cls(-arg)
818         else:
819             if arg is S.ComplexInfinity:
820                 return S.ComplexInfinity
821 
822             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
823 
824             if i_coeff is not None:
825                 return S.ImaginaryUnit * asin(i_coeff)
826             else:
827                 if _coeff_isneg(arg):
828                     return -cls(-arg)
829 
830     @staticmethod
831     @cacheit
832     def taylor_term(n, x, *previous_terms):
833         if n < 0 or n % 2 == 0:
834             return S.Zero
835         else:
836             x = sympify(x)
837             if len(previous_terms) >= 2 and n > 2:
838                 p = previous_terms[-2]
839                 return -p * (n - 2)**2/(n*(n - 1)) * x**2
840             else:
841                 k = (n - 1) // 2
842                 R = RisingFactorial(S.Half, k)
843                 F = factorial(k)
844                 return (-1)**k * R / F * x**n / n
845 
846     def _eval_as_leading_term(self, x):
847         from sympy import Order
848         arg = self.args[0].as_leading_term(x)
849 
850         if x in arg.free_symbols and Order(1, x).contains(arg):
851             return arg
852         else:
853             return self.func(arg)
854 
855     def _eval_rewrite_as_log(self, x):
856         return log(x + sqrt(x**2 + 1))
857 
858     def inverse(self, argindex=1):
859         """
860         Returns the inverse of this function.
861         """
862         return sinh
863 
864 
865 class acosh(InverseHyperbolicFunction):
866     """
867     The inverse hyperbolic cosine function.
868 
869     * acosh(x) -> Returns the inverse hyperbolic cosine of x
870 
871     See Also
872     ========
873 
874     asinh, atanh, cosh
875     """
876 
877     def fdiff(self, argindex=1):
878         if argindex == 1:
879             return 1/sqrt(self.args[0]**2 - 1)
880         else:
881             raise ArgumentIndexError(self, argindex)
882 
883     @classmethod
884     def eval(cls, arg):
885         arg = sympify(arg)
886 
887         if arg.is_Number:
888             if arg is S.NaN:
889                 return S.NaN
890             elif arg is S.Infinity:
891                 return S.Infinity
892             elif arg is S.NegativeInfinity:
893                 return S.Infinity
894             elif arg is S.Zero:
895                 return S.Pi*S.ImaginaryUnit / 2
896             elif arg is S.One:
897                 return S.Zero
898             elif arg is S.NegativeOne:
899                 return S.Pi*S.ImaginaryUnit
900 
901         if arg.is_number:
902             cst_table = {
903                 S.ImaginaryUnit: log(S.ImaginaryUnit*(1 + sqrt(2))),
904                 -S.ImaginaryUnit: log(-S.ImaginaryUnit*(1 + sqrt(2))),
905                 S.Half: S.Pi/3,
906                 -S.Half: 2*S.Pi/3,
907                 sqrt(2)/2: S.Pi/4,
908                 -sqrt(2)/2: 3*S.Pi/4,
909                 1/sqrt(2): S.Pi/4,
910                 -1/sqrt(2): 3*S.Pi/4,
911                 sqrt(3)/2: S.Pi/6,
912                 -sqrt(3)/2: 5*S.Pi/6,
913                 (sqrt(3) - 1)/sqrt(2**3): 5*S.Pi/12,
914                 -(sqrt(3) - 1)/sqrt(2**3): 7*S.Pi/12,
915                 sqrt(2 + sqrt(2))/2: S.Pi/8,
916                 -sqrt(2 + sqrt(2))/2: 7*S.Pi/8,
917                 sqrt(2 - sqrt(2))/2: 3*S.Pi/8,
918                 -sqrt(2 - sqrt(2))/2: 5*S.Pi/8,
919                 (1 + sqrt(3))/(2*sqrt(2)): S.Pi/12,
920                 -(1 + sqrt(3))/(2*sqrt(2)): 11*S.Pi/12,
921                 (sqrt(5) + 1)/4: S.Pi/5,
922                 -(sqrt(5) + 1)/4: 4*S.Pi/5
923             }
924 
925             if arg in cst_table:
926                 if arg.is_real:
927                     return cst_table[arg]*S.ImaginaryUnit
928                 return cst_table[arg]
929 
930         if arg.is_infinite:
931             return S.Infinity
932 
933     @staticmethod
934     @cacheit
935     def taylor_term(n, x, *previous_terms):
936         if n == 0:
937             return S.Pi*S.ImaginaryUnit / 2
938         elif n < 0 or n % 2 == 0:
939             return S.Zero
940         else:
941             x = sympify(x)
942             if len(previous_terms) >= 2 and n > 2:
943                 p = previous_terms[-2]
944                 return p * (n - 2)**2/(n*(n - 1)) * x**2
945             else:
946                 k = (n - 1) // 2
947                 R = RisingFactorial(S.Half, k)
948                 F = factorial(k)
949                 return -R / F * S.ImaginaryUnit * x**n / n
950 
951     def _eval_as_leading_term(self, x):
952         from sympy import Order
953         arg = self.args[0].as_leading_term(x)
954 
955         if x in arg.free_symbols and Order(1, x).contains(arg):
956             return S.ImaginaryUnit*S.Pi/2
957         else:
958             return self.func(arg)
959 
960     def _eval_rewrite_as_log(self, x):
961         return log(x + sqrt(x + 1) * sqrt(x - 1))
962 
963     def inverse(self, argindex=1):
964         """
965         Returns the inverse of this function.
966         """
967         return cosh
968 
969 
970 class atanh(InverseHyperbolicFunction):
971     """
972     The inverse hyperbolic tangent function.
973 
974     * atanh(x) -> Returns the inverse hyperbolic tangent of x
975 
976     See Also
977     ========
978 
979     asinh, acosh, tanh
980     """
981 
982     def fdiff(self, argindex=1):
983         if argindex == 1:
984             return 1/(1 - self.args[0]**2)
985         else:
986             raise ArgumentIndexError(self, argindex)
987 
988     @classmethod
989     def eval(cls, arg):
990         from sympy import atan
991         arg = sympify(arg)
992 
993         if arg.is_Number:
994             if arg is S.NaN:
995                 return S.NaN
996             elif arg is S.Zero:
997                 return S.Zero
998             elif arg is S.One:
999                 return S.Infinity
1000             elif arg is S.NegativeOne:
1001                 return S.NegativeInfinity
1002             elif arg is S.Infinity:
1003                 return -S.ImaginaryUnit * atan(arg)
1004             elif arg is S.NegativeInfinity:
1005                 return S.ImaginaryUnit * atan(-arg)
1006             elif arg.is_negative:
1007                 return -cls(-arg)
1008         else:
1009             if arg is S.ComplexInfinity:
1010                 return S.NaN
1011 
1012             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1013 
1014             if i_coeff is not None:
1015                 return S.ImaginaryUnit * atan(i_coeff)
1016             else:
1017                 if _coeff_isneg(arg):
1018                     return -cls(-arg)
1019 
1020     @staticmethod
1021     @cacheit
1022     def taylor_term(n, x, *previous_terms):
1023         if n < 0 or n % 2 == 0:
1024             return S.Zero
1025         else:
1026             x = sympify(x)
1027             return x**n / n
1028 
1029     def _eval_as_leading_term(self, x):
1030         from sympy import Order
1031         arg = self.args[0].as_leading_term(x)
1032 
1033         if x in arg.free_symbols and Order(1, x).contains(arg):
1034             return arg
1035         else:
1036             return self.func(arg)
1037 
1038     def _eval_rewrite_as_log(self, x):
1039         return (log(1 + x) - log(1 - x)) / 2
1040 
1041     def inverse(self, argindex=1):
1042         """
1043         Returns the inverse of this function.
1044         """
1045         return tanh
1046 
1047 
1048 class acoth(InverseHyperbolicFunction):
1049     """
1050     The inverse hyperbolic cotangent function.
1051 
1052     * acoth(x) -> Returns the inverse hyperbolic cotangent of x
1053     """
1054 
1055     def fdiff(self, argindex=1):
1056         if argindex == 1:
1057             return 1/(1 - self.args[0]**2)
1058         else:
1059             raise ArgumentIndexError(self, argindex)
1060 
1061     @classmethod
1062     def eval(cls, arg):
1063         from sympy import acot
1064         arg = sympify(arg)
1065 
1066         if arg.is_Number:
1067             if arg is S.NaN:
1068                 return S.NaN
1069             elif arg is S.Infinity:
1070                 return S.Zero
1071             elif arg is S.NegativeInfinity:
1072                 return S.Zero
1073             elif arg is S.Zero:
1074                 return S.Pi*S.ImaginaryUnit / 2
1075             elif arg is S.One:
1076                 return S.Infinity
1077             elif arg is S.NegativeOne:
1078                 return S.NegativeInfinity
1079             elif arg.is_negative:
1080                 return -cls(-arg)
1081         else:
1082             if arg is S.ComplexInfinity:
1083                 return 0
1084 
1085             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1086 
1087             if i_coeff is not None:
1088                 return -S.ImaginaryUnit * acot(i_coeff)
1089             else:
1090                 if _coeff_isneg(arg):
1091                     return -cls(-arg)
1092 
1093     @staticmethod
1094     @cacheit
1095     def taylor_term(n, x, *previous_terms):
1096         if n == 0:
1097             return S.Pi*S.ImaginaryUnit / 2
1098         elif n < 0 or n % 2 == 0:
1099             return S.Zero
1100         else:
1101             x = sympify(x)
1102             return x**n / n
1103 
1104     def _eval_as_leading_term(self, x):
1105         from sympy import Order
1106         arg = self.args[0].as_leading_term(x)
1107 
1108         if x in arg.free_symbols and Order(1, x).contains(arg):
1109             return S.ImaginaryUnit*S.Pi/2
1110         else:
1111             return self.func(arg)
1112 
1113     def _eval_rewrite_as_log(self, x):
1114         return (log(1 + 1/x) - log(1 - 1/x)) / 2
1115 
1116     def inverse(self, argindex=1):
1117         """
1118         Returns the inverse of this function.
1119         """
1120         return coth
1121 
1122 
1123 class asech(InverseHyperbolicFunction):
1124     """
1125     The inverse hyperbolic secant function.
1126 
1127     * asech(x) -> Returns the inverse hyperbolic secant of x
1128 
1129     Examples
1130     ========
1131 
1132     >>> from sympy import asech, sqrt, S
1133     >>> from sympy.abc import x
1134     >>> asech(x).diff(x)
1135     -1/(x*sqrt(-x**2 + 1))
1136     >>> asech(1).diff(x)
1137     0
1138     >>> asech(1)
1139     0
1140     >>> asech(S(2))
1141     I*pi/3
1142     >>> asech(-sqrt(2))
1143     3*I*pi/4
1144     >>> asech((sqrt(6) - sqrt(2)))
1145     I*pi/12
1146 
1147     See Also
1148     ========
1149 
1150     asinh, atanh, cosh, acoth
1151 
1152     References
1153     ==========
1154 
1155     .. [1] http://en.wikipedia.org/wiki/Hyperbolic_function
1156     .. [2] http://dlmf.nist.gov/4.37
1157     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSech/
1158 
1159     """
1160 
1161     def fdiff(self, argindex=1):
1162         if argindex == 1:
1163             z = self.args[0]
1164             return -1/(z*sqrt(1 - z**2))
1165         else:
1166             raise ArgumentIndexError(self, argindex)
1167 
1168     @classmethod
1169     def eval(cls, arg):
1170         arg = sympify(arg)
1171 
1172         if arg.is_Number:
1173             if arg is S.NaN:
1174                 return S.NaN
1175             elif arg is S.Infinity:
1176                 return S.Pi*S.ImaginaryUnit / 2
1177             elif arg is S.NegativeInfinity:
1178                 return S.Pi*S.ImaginaryUnit / 2
1179             elif arg is S.Zero:
1180                 return S.Infinity
1181             elif arg is S.One:
1182                 return S.Zero
1183             elif arg is S.NegativeOne:
1184                 return S.Pi*S.ImaginaryUnit
1185 
1186         if arg.is_number:
1187             cst_table = {
1188                 S.ImaginaryUnit: - (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1189                 -S.ImaginaryUnit: (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1190                 (sqrt(6) - sqrt(2)): S.Pi / 12,
1191                 (sqrt(2) - sqrt(6)): 11*S.Pi / 12,
1192                 sqrt(2 - 2/sqrt(5)): S.Pi / 10,
1193                 -sqrt(2 - 2/sqrt(5)): 9*S.Pi / 10,
1194                 2 / sqrt(2 + sqrt(2)): S.Pi / 8,
1195                 -2 / sqrt(2 + sqrt(2)): 7*S.Pi / 8,
1196                 2 / sqrt(3): S.Pi / 6,
1197                 -2 / sqrt(3): 5*S.Pi / 6,
1198                 (sqrt(5) - 1): S.Pi / 5,
1199                 (1 - sqrt(5)): 4*S.Pi / 5,
1200                 sqrt(2): S.Pi / 4,
1201                 -sqrt(2): 3*S.Pi / 4,
1202                 sqrt(2 + 2/sqrt(5)): 3*S.Pi / 10,
1203                 -sqrt(2 + 2/sqrt(5)): 7*S.Pi / 10,
1204                 S(2): S.Pi / 3,
1205                 -S(2): 2*S.Pi / 3,
1206                 sqrt(2*(2 + sqrt(2))): 3*S.Pi / 8,
1207                 -sqrt(2*(2 + sqrt(2))): 5*S.Pi / 8,
1208                 (1 + sqrt(5)): 2*S.Pi / 5,
1209                 (-1 - sqrt(5)): 3*S.Pi / 5,
1210                 (sqrt(6) + sqrt(2)): 5*S.Pi / 12,
1211                 (-sqrt(6) - sqrt(2)): 7*S.Pi / 12,
1212             }
1213 
1214             if arg in cst_table:
1215                 if arg.is_real:
1216                     return cst_table[arg]*S.ImaginaryUnit
1217                 return cst_table[arg]
1218 
1219         if arg is S.ComplexInfinity:
1220             return S.NaN
1221 
1222     @staticmethod
1223     @cacheit
1224     def expansion_term(n, x, *previous_terms):
1225         if n == 0:
1226             return log(2 / x)
1227         elif n < 0 or n % 2 == 1:
1228             return S.Zero
1229         else:
1230             x = sympify(x)
1231             if len(previous_terms) > 2 and n > 2:
1232                 p = previous_terms[-2]
1233                 return p * (n - 1)**2 // (n // 2)**2 * x**2 / 4
1234             else:
1235                 k = n // 2
1236                 R = RisingFactorial(S.Half , k) *  n
1237                 F = factorial(k) * n // 2 * n // 2
1238                 return -1 * R / F * x**n / 4
1239 
1240     def inverse(self, argindex=1):
1241         """
1242         Returns the inverse of this function.
1243         """
1244         return sech
1245 
1246     def _eval_rewrite_as_log(self, arg):
1247         return log(1/arg + sqrt(1/arg - 1) * sqrt(1/arg + 1))
1248 
1249 
1250 class acsch(InverseHyperbolicFunction):
1251     """
1252     The inverse hyperbolic cosecant function.
1253 
1254     * acsch(x) -> Returns the inverse hyperbolic cosecant of x
1255 
1256     Examples
1257     ========
1258 
1259     >>> from sympy import acsch, sqrt, S
1260     >>> from sympy.abc import x
1261     >>> acsch(x).diff(x)
1262     -1/(x**2*sqrt(1 + x**(-2)))
1263     >>> acsch(1).diff(x)
1264     0
1265     >>> acsch(1)
1266     log(1 + sqrt(2))
1267     >>> acsch(S.ImaginaryUnit)
1268     -I*pi/2
1269     >>> acsch(-2*S.ImaginaryUnit)
1270     I*pi/6
1271     >>> acsch(S.ImaginaryUnit*(sqrt(6) - sqrt(2)))
1272     -5*I*pi/12
1273 
1274     References
1275     ==========
1276 
1277     .. [1] http://en.wikipedia.org/wiki/Hyperbolic_function
1278     .. [2] http://dlmf.nist.gov/4.37
1279     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsch/
1280 
1281     """
1282 
1283     def fdiff(self, argindex=1):
1284         if argindex == 1:
1285             z = self.args[0]
1286             return -1/(z**2*sqrt(1 + 1/z**2))
1287         else:
1288             raise ArgumentIndexError(self, argindex)
1289 
1290     @classmethod
1291     def eval(cls, arg):
1292         arg = sympify(arg)
1293 
1294         if arg.is_Number:
1295             if arg is S.NaN:
1296                 return S.NaN
1297             elif arg is S.Infinity:
1298                 return S.Zero
1299             elif arg is S.NegativeInfinity:
1300                 return S.Zero
1301             elif arg is S.Zero:
1302                 return S.ComplexInfinity
1303             elif arg is S.One:
1304                 return log(1 + sqrt(2))
1305             elif arg is S.NegativeOne:
1306                 return - log(1 + sqrt(2))
1307 
1308         if arg.is_number:
1309             cst_table = {
1310                 S.ImaginaryUnit: -S.Pi / 2,
1311                 S.ImaginaryUnit*(sqrt(2) + sqrt(6)): -S.Pi / 12,
1312                 S.ImaginaryUnit*(1 + sqrt(5)): -S.Pi / 10,
1313                 S.ImaginaryUnit*2 / sqrt(2 - sqrt(2)): -S.Pi / 8,
1314                 S.ImaginaryUnit*2: -S.Pi / 6,
1315                 S.ImaginaryUnit*sqrt(2 + 2/sqrt(5)): -S.Pi / 5,
1316                 S.ImaginaryUnit*sqrt(2): -S.Pi / 4,
1317                 S.ImaginaryUnit*(sqrt(5)-1): -3*S.Pi / 10,
1318                 S.ImaginaryUnit*2 / sqrt(3): -S.Pi / 3,
1319                 S.ImaginaryUnit*2 / sqrt(2 + sqrt(2)): -3*S.Pi / 8,
1320                 S.ImaginaryUnit*sqrt(2 - 2/sqrt(5)): -2*S.Pi / 5,
1321                 S.ImaginaryUnit*(sqrt(6) - sqrt(2)): -5*S.Pi / 12,
1322                 S(2): -S.ImaginaryUnit*log((1+sqrt(5))/2),
1323             }
1324 
1325             if arg in cst_table:
1326                 return cst_table[arg]*S.ImaginaryUnit
1327 
1328         if arg is S.ComplexInfinity:
1329             return S.Zero
1330 
1331         if _coeff_isneg(arg):
1332             return -cls(-arg)
1333 
1334     def inverse(self, argindex=1):
1335         """
1336         Returns the inverse of this function.
1337         """
1338         return csch
1339 
1340     def _eval_rewrite_as_log(self, arg):
1341         return log(1/arg + sqrt(1/arg**2 + 1))

</code><intended_behavior>Review and potentially enhance the logic dealing with the interplay between trigonometric functions and complex arguments to ensure correct application of mathematical principles.</intended_behavior>]
2025-10-15 13:13:04.999 | INFO     | Search completed. Bug locations: [<file>sympy/simplify/trigsimp.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core.cache import cacheit
6 from sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,
7     Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)
8 from sympy.core.compatibility import reduce, iterable
9 from sympy.core.numbers import I, Integer
10 from sympy.core.function import count_ops, _mexpand
11 from sympy.functions.elementary.trigonometric import TrigonometricFunction
12 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
13 from sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth
14 
15 from sympy.strategies.core import identity
16 from sympy.strategies.tree import greedy
17 
18 from sympy.polys import Poly
19 from sympy.polys.polyerrors import PolificationFailed
20 from sympy.polys.polytools import groebner
21 from sympy.polys.domains import ZZ
22 from sympy.polys import factor, cancel, parallel_poly_from_expr
23 
24 from sympy.utilities.misc import debug
25 
26 
27 
28 def trigsimp_groebner(expr, hints=[], quick=False, order="grlex",
29                       polynomial=False):
30     """
31     Simplify trigonometric expressions using a groebner basis algorithm.
32 
33     This routine takes a fraction involving trigonometric or hyperbolic
34     expressions, and tries to simplify it. The primary metric is the
35     total degree. Some attempts are made to choose the simplest possible
36     expression of the minimal degree, but this is non-rigorous, and also
37     very slow (see the ``quick=True`` option).
38 
39     If ``polynomial`` is set to True, instead of simplifying numerator and
40     denominator together, this function just brings numerator and denominator
41     into a canonical form. This is much faster, but has potentially worse
42     results. However, if the input is a polynomial, then the result is
43     guaranteed to be an equivalent polynomial of minimal degree.
44 
45     The most important option is hints. Its entries can be any of the
46     following:
47 
48     - a natural number
49     - a function
50     - an iterable of the form (func, var1, var2, ...)
51     - anything else, interpreted as a generator
52 
53     A number is used to indicate that the search space should be increased.
54     A function is used to indicate that said function is likely to occur in a
55     simplified expression.
56     An iterable is used indicate that func(var1 + var2 + ...) is likely to
57     occur in a simplified .
58     An additional generator also indicates that it is likely to occur.
59     (See examples below).
60 
61     This routine carries out various computationally intensive algorithms.
62     The option ``quick=True`` can be used to suppress one particularly slow
63     step (at the expense of potentially more complicated results, but never at
64     the expense of increased total degree).
65 
66     Examples
67     ========
68 
69     >>> from sympy.abc import x, y
70     >>> from sympy import sin, tan, cos, sinh, cosh, tanh
71     >>> from sympy.simplify.trigsimp import trigsimp_groebner
72 
73     Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:
74 
75     >>> ex = sin(x)*cos(x)
76     >>> trigsimp_groebner(ex)
77     sin(x)*cos(x)
78 
79     This is because ``trigsimp_groebner`` only looks for a simplification
80     involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try
81     ``2*x`` by passing ``hints=[2]``:
82 
83     >>> trigsimp_groebner(ex, hints=[2])
84     sin(2*x)/2
85     >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])
86     -cos(2*x)
87 
88     Increasing the search space this way can quickly become expensive. A much
89     faster way is to give a specific expression that is likely to occur:
90 
91     >>> trigsimp_groebner(ex, hints=[sin(2*x)])
92     sin(2*x)/2
93 
94     Hyperbolic expressions are similarly supported:
95 
96     >>> trigsimp_groebner(sinh(2*x)/sinh(x))
97     2*cosh(x)
98 
99     Note how no hints had to be passed, since the expression already involved
100     ``2*x``.
101 
102     The tangent function is also supported. You can either pass ``tan`` in the
103     hints, to indicate that than should be tried whenever cosine or sine are,
104     or you can pass a specific generator:
105 
106     >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])
107     tan(x)
108     >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])
109     tanh(x)
110 
111     Finally, you can use the iterable form to suggest that angle sum formulae
112     should be tried:
113 
114     >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))
115     >>> trigsimp_groebner(ex, hints=[(tan, x, y)])
116     tan(x + y)
117     """
118     # TODO
119     #  - preprocess by replacing everything by funcs we can handle
120     # - optionally use cot instead of tan
121     # - more intelligent hinting.
122     #     For example, if the ideal is small, and we have sin(x), sin(y),
123     #     add sin(x + y) automatically... ?
124     # - algebraic numbers ...
125     # - expressions of lowest degree are not distinguished properly
126     #   e.g. 1 - sin(x)**2
127     # - we could try to order the generators intelligently, so as to influence
128     #   which monomials appear in the quotient basis
129 
130     # THEORY
131     # ------
132     # Ratsimpmodprime above can be used to "simplify" a rational function
133     # modulo a prime ideal. "Simplify" mainly means finding an equivalent
134     # expression of lower total degree.
135     #
136     # We intend to use this to simplify trigonometric functions. To do that,
137     # we need to decide (a) which ring to use, and (b) modulo which ideal to
138     # simplify. In practice, (a) means settling on a list of "generators"
139     # a, b, c, ..., such that the fraction we want to simplify is a rational
140     # function in a, b, c, ..., with coefficients in ZZ (integers).
141     # (2) means that we have to decide what relations to impose on the
142     # generators. There are two practical problems:
143     #   (1) The ideal has to be *prime* (a technical term).
144     #   (2) The relations have to be polynomials in the generators.
145     #
146     # We typically have two kinds of generators:
147     # - trigonometric expressions, like sin(x), cos(5*x), etc
148     # - "everything else", like gamma(x), pi, etc.
149     #
150     # Since this function is trigsimp, we will concentrate on what to do with
151     # trigonometric expressions. We can also simplify hyperbolic expressions,
152     # but the extensions should be clear.
153     #
154     # One crucial point is that all *other* generators really should behave
155     # like indeterminates. In particular if (say) "I" is one of them, then
156     # in fact I**2 + 1 = 0 and we may and will compute non-sensical
157     # expressions. However, we can work with a dummy and add the relation
158     # I**2 + 1 = 0 to our ideal, then substitute back in the end.
159     #
160     # Now regarding trigonometric generators. We split them into groups,
161     # according to the argument of the trigonometric functions. We want to
162     # organise this in such a way that most trigonometric identities apply in
163     # the same group. For example, given sin(x), cos(2*x) and cos(y), we would
164     # group as [sin(x), cos(2*x)] and [cos(y)].
165     #
166     # Our prime ideal will be built in three steps:
167     # (1) For each group, compute a "geometrically prime" ideal of relations.
168     #     Geometrically prime means that it generates a prime ideal in
169     #     CC[gens], not just ZZ[gens].
170     # (2) Take the union of all the generators of the ideals for all groups.
171     #     By the geometric primality condition, this is still prime.
172     # (3) Add further inter-group relations which preserve primality.
173     #
174     # Step (1) works as follows. We will isolate common factors in the
175     # argument, so that all our generators are of the form sin(n*x), cos(n*x)
176     # or tan(n*x), with n an integer. Suppose first there are no tan terms.
177     # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since
178     # X**2 + Y**2 - 1 is irreducible over CC.
179     # Now, if we have a generator sin(n*x), than we can, using trig identities,
180     # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this
181     # relation to the ideal, preserving geometric primality, since the quotient
182     # ring is unchanged.
183     # Thus we have treated all sin and cos terms.
184     # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.
185     # (This requires of course that we already have relations for cos(n*x) and
186     # sin(n*x).) It is not obvious, but it seems that this preserves geometric
187     # primality.
188     # XXX A real proof would be nice. HELP!
189     #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of
190     #     CC[S, C, T]:
191     #     - it suffices to show that the projective closure in CP**3 is
192     #       irreducible
193     #     - using the half-angle substitutions, we can express sin(x), tan(x),
194     #       cos(x) as rational functions in tan(x/2)
195     #     - from this, we get a rational map from CP**1 to our curve
196     #     - this is a morphism, hence the curve is prime
197     #
198     # Step (2) is trivial.
199     #
200     # Step (3) works by adding selected relations of the form
201     # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is
202     # preserved by the same argument as before.
203 
204     def parse_hints(hints):
205         """Split hints into (n, funcs, iterables, gens)."""
206         n = 1
207         funcs, iterables, gens = [], [], []
208         for e in hints:
209             if isinstance(e, (int, Integer)):
210                 n = e
211             elif isinstance(e, FunctionClass):
212                 funcs.append(e)
213             elif iterable(e):
214                 iterables.append((e[0], e[1:]))
215                 # XXX sin(x+2y)?
216                 # Note: we go through polys so e.g.
217                 # sin(-x) -> -sin(x) -> sin(x)
218                 gens.extend(parallel_poly_from_expr(
219                     [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)
220             else:
221                 gens.append(e)
222         return n, funcs, iterables, gens
223 
224     def build_ideal(x, terms):
225         """
226         Build generators for our ideal. Terms is an iterable with elements of
227         the form (fn, coeff), indicating that we have a generator fn(coeff*x).
228 
229         If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed
230         to appear in terms. Similarly for hyperbolic functions. For tan(n*x),
231         sin(n*x) and cos(n*x) are guaranteed.
232         """
233         gens = []
234         I = []
235         y = Dummy('y')
236         for fn, coeff in terms:
237             for c, s, t, rel in (
238                     [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],
239                     [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):
240                 if coeff == 1 and fn in [c, s]:
241                     I.append(rel)
242                 elif fn == t:
243                     I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))
244                 elif fn in [c, s]:
245                     cn = fn(coeff*y).expand(trig=True).subs(y, x)
246                     I.append(fn(coeff*x) - cn)
247         return list(set(I))
248 
249     def analyse_gens(gens, hints):
250         """
251         Analyse the generators ``gens``, using the hints ``hints``.
252 
253         The meaning of ``hints`` is described in the main docstring.
254         Return a new list of generators, and also the ideal we should
255         work with.
256         """
257         # First parse the hints
258         n, funcs, iterables, extragens = parse_hints(hints)
259         debug('n=%s' % n, 'funcs:', funcs, 'iterables:',
260               iterables, 'extragens:', extragens)
261 
262         # We just add the extragens to gens and analyse them as before
263         gens = list(gens)
264         gens.extend(extragens)
265 
266         # remove duplicates
267         funcs = list(set(funcs))
268         iterables = list(set(iterables))
269         gens = list(set(gens))
270 
271         # all the functions we can do anything with
272         allfuncs = {sin, cos, tan, sinh, cosh, tanh}
273         # sin(3*x) -> ((3, x), sin)
274         trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens
275                      if g.func in allfuncs]
276         # Our list of new generators - start with anything that we cannot
277         # work with (i.e. is not a trigonometric term)
278         freegens = [g for g in gens if g.func not in allfuncs]
279         newgens = []
280         trigdict = {}
281         for (coeff, var), fn in trigterms:
282             trigdict.setdefault(var, []).append((coeff, fn))
283         res = [] # the ideal
284 
285         for key, val in trigdict.items():
286             # We have now assembeled a dictionary. Its keys are common
287             # arguments in trigonometric expressions, and values are lists of
288             # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we
289             # need to deal with fn(coeff*x0). We take the rational gcd of the
290             # coeffs, call it ``gcd``. We then use x = x0/gcd as "base symbol",
291             # all other arguments are integral multiples thereof.
292             # We will build an ideal which works with sin(x), cos(x).
293             # If hint tan is provided, also work with tan(x). Moreover, if
294             # n > 1, also work with sin(k*x) for k <= n, and similarly for cos
295             # (and tan if the hint is provided). Finally, any generators which
296             # the ideal does not work with but we need to accomodate (either
297             # because it was in expr or because it was provided as a hint)
298             # we also build into the ideal.
299             # This selection process is expressed in the list ``terms``.
300             # build_ideal then generates the actual relations in our ideal,
301             # from this list.
302             fns = [x[1] for x in val]
303             val = [x[0] for x in val]
304             gcd = reduce(igcd, val)
305             terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]
306             fs = set(funcs + fns)
307             for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):
308                 if any(x in fs for x in (c, s, t)):
309                     fs.add(c)
310                     fs.add(s)
311             for fn in fs:
312                 for k in range(1, n + 1):
313                     terms.append((fn, k))
314             extra = []
315             for fn, v in terms:
316                 if fn == tan:
317                     extra.append((sin, v))
318                     extra.append((cos, v))
319                 if fn in [sin, cos] and tan in fs:
320                     extra.append((tan, v))
321                 if fn == tanh:
322                     extra.append((sinh, v))
323                     extra.append((cosh, v))
324                 if fn in [sinh, cosh] and tanh in fs:
325                     extra.append((tanh, v))
326             terms.extend(extra)
327             x = gcd*Mul(*key)
328             r = build_ideal(x, terms)
329             res.extend(r)
330             newgens.extend(set(fn(v*x) for fn, v in terms))
331 
332         # Add generators for compound expressions from iterables
333         for fn, args in iterables:
334             if fn == tan:
335                 # Tan expressions are recovered from sin and cos.
336                 iterables.extend([(sin, args), (cos, args)])
337             elif fn == tanh:
338                 # Tanh expressions are recovered from sihn and cosh.
339                 iterables.extend([(sinh, args), (cosh, args)])
340             else:
341                 dummys = symbols('d:%i' % len(args), cls=Dummy)
342                 expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))
343                 res.append(fn(Add(*args)) - expr)
344 
345         if myI in gens:
346             res.append(myI**2 + 1)
347             freegens.remove(myI)
348             newgens.append(myI)
349 
350         return res, freegens, newgens
351 
352     myI = Dummy('I')
353     expr = expr.subs(S.ImaginaryUnit, myI)
354     subs = [(myI, S.ImaginaryUnit)]
355 
356     num, denom = cancel(expr).as_numer_denom()
357     try:
358         (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])
359     except PolificationFailed:
360         return expr
361     debug('initial gens:', opt.gens)
362     ideal, freegens, gens = analyse_gens(opt.gens, hints)
363     debug('ideal:', ideal)
364     debug('new gens:', gens, " -- len", len(gens))
365     debug('free gens:', freegens, " -- len", len(gens))
366     # NOTE we force the domain to be ZZ to stop polys from injecting generators
367     #      (which is usually a sign of a bug in the way we build the ideal)
368     if not gens:
369         return expr
370     G = groebner(ideal, order=order, gens=gens, domain=ZZ)
371     debug('groebner basis:', list(G), " -- len", len(G))
372 
373     # If our fraction is a polynomial in the free generators, simplify all
374     # coefficients separately:
375 
376     from sympy.simplify.ratsimp import ratsimpmodprime
377 
378     if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):
379         num = Poly(num, gens=gens+freegens).eject(*gens)
380         res = []
381         for monom, coeff in num.terms():
382             ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)
383             # We compute the transitive closure of all generators that can
384             # be reached from our generators through relations in the ideal.
385             changed = True
386             while changed:
387                 changed = False
388                 for p in ideal:
389                     p = Poly(p)
390                     if not ourgens.issuperset(p.gens) and \
391                        not p.has_only_gens(*set(p.gens).difference(ourgens)):
392                         changed = True
393                         ourgens.update(p.exclude().gens)
394             # NOTE preserve order!
395             realgens = [x for x in gens if x in ourgens]
396             # The generators of the ideal have now been (implicitely) split
397             # into two groups: those involving ourgens and those that don't.
398             # Since we took the transitive closure above, these two groups
399             # live in subgrings generated by a *disjoint* set of variables.
400             # Any sensible groebner basis algorithm will preserve this disjoint
401             # structure (i.e. the elements of the groebner basis can be split
402             # similarly), and and the two subsets of the groebner basis then
403             # form groebner bases by themselves. (For the smaller generating
404             # sets, of course.)
405             ourG = [g.as_expr() for g in G.polys if
406                     g.has_only_gens(*ourgens.intersection(g.gens))]
407             res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \
408                        ratsimpmodprime(coeff/denom, ourG, order=order,
409                                        gens=realgens, quick=quick, domain=ZZ,
410                                        polynomial=polynomial).subs(subs))
411         return Add(*res)
412         # NOTE The following is simpler and has less assumptions on the
413         #      groebner basis algorithm. If the above turns out to be broken,
414         #      use this.
415         return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \
416                      ratsimpmodprime(coeff/denom, list(G), order=order,
417                                      gens=gens, quick=quick, domain=ZZ)
418                      for monom, coeff in num.terms()])
419     else:
420         return ratsimpmodprime(
421             expr, list(G), order=order, gens=freegens+gens,
422             quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)
423 
424 
425 _trigs = (TrigonometricFunction, HyperbolicFunction)
426 
427 
428 def trigsimp(expr, **opts):
429     """
430     reduces expression by using known trig identities
431 
432     Notes
433     =====
434 
435     method:
436     - Determine the method to use. Valid choices are 'matching' (default),
437     'groebner', 'combined', and 'fu'. If 'matching', simplify the
438     expression recursively by targeting common patterns. If 'groebner', apply
439     an experimental groebner basis algorithm. In this case further options
440     are forwarded to ``trigsimp_groebner``, please refer to its docstring.
441     If 'combined', first run the groebner basis algorithm with small
442     default parameters, then run the 'matching' algorithm. 'fu' runs the
443     collection of trigonometric transformations described by Fu, et al.
444     (see the `fu` docstring).
445 
446 
447     Examples
448     ========
449 
450     >>> from sympy import trigsimp, sin, cos, log
451     >>> from sympy.abc import x, y
452     >>> e = 2*sin(x)**2 + 2*cos(x)**2
453     >>> trigsimp(e)
454     2
455 
456     Simplification occurs wherever trigonometric functions are located.
457 
458     >>> trigsimp(log(e))
459     log(2)
460 
461     Using `method="groebner"` (or `"combined"`) might lead to greater
462     simplification.
463 
464     The old trigsimp routine can be accessed as with method 'old'.
465 
466     >>> from sympy import coth, tanh
467     >>> t = 3*tanh(x)**7 - 2/coth(x)**7
468     >>> trigsimp(t, method='old') == t
469     True
470     >>> trigsimp(t)
471     tanh(x)**7
472 
473     """
474     from sympy.simplify.fu import fu
475 
476     expr = sympify(expr)
477 
478     try:
479         return expr._eval_trigsimp(**opts)
480     except AttributeError:
481         pass
482 
483     old = opts.pop('old', False)
484     if not old:
485         opts.pop('deep', None)
486         recursive = opts.pop('recursive', None)
487         method = opts.pop('method', 'matching')
488     else:
489         method = 'old'
490 
491     def groebnersimp(ex, **opts):
492         def traverse(e):
493             if e.is_Atom:
494                 return e
495             args = [traverse(x) for x in e.args]
496             if e.is_Function or e.is_Pow:
497                 args = [trigsimp_groebner(x, **opts) for x in args]
498             return e.func(*args)
499         new = traverse(ex)
500         if not isinstance(new, Expr):
501             return new
502         return trigsimp_groebner(new, **opts)
503 
504     trigsimpfunc = {
505         'fu': (lambda x: fu(x, **opts)),
506         'matching': (lambda x: futrig(x)),
507         'groebner': (lambda x: groebnersimp(x, **opts)),
508         'combined': (lambda x: futrig(groebnersimp(x,
509                                polynomial=True, hints=[2, tan]))),
510         'old': lambda x: trigsimp_old(x, **opts),
511                    }[method]
512 
513     return trigsimpfunc(expr)
514 
515 
516 def exptrigsimp(expr):
517     """
518     Simplifies exponential / trigonometric / hyperbolic functions.
519 
520     Examples
521     ========
522 
523     >>> from sympy import exptrigsimp, exp, cosh, sinh
524     >>> from sympy.abc import z
525 
526     >>> exptrigsimp(exp(z) + exp(-z))
527     2*cosh(z)
528     >>> exptrigsimp(cosh(z) - sinh(z))
529     exp(-z)
530     """
531     from sympy.simplify.fu import hyper_as_trig, TR2i
532     from sympy.simplify.simplify import bottom_up
533 
534     def exp_trig(e):
535         # select the better of e, and e rewritten in terms of exp or trig
536         # functions
537         choices = [e]
538         if e.has(*_trigs):
539             choices.append(e.rewrite(exp))
540         choices.append(e.rewrite(cos))
541         return min(*choices, key=count_ops)
542     newexpr = bottom_up(expr, exp_trig)
543 
544     def f(rv):
545         if not rv.is_Mul:
546             return rv
547         rvd = rv.as_powers_dict()
548         newd = rvd.copy()
549 
550         def signlog(expr, sign=1):
551             if expr is S.Exp1:
552                 return sign, 1
553             elif isinstance(expr, exp):
554                 return sign, expr.args[0]
555             elif sign == 1:
556                 return signlog(-expr, sign=-1)
557             else:
558                 return None, None
559 
560         ee = rvd[S.Exp1]
561         for k in rvd:
562             if k.is_Add and len(k.args) == 2:
563                 # k == c*(1 + sign*E**x)
564                 c = k.args[0]
565                 sign, x = signlog(k.args[1]/c)
566                 if not x:
567                     continue
568                 m = rvd[k]
569                 newd[k] -= m
570                 if ee == -x*m/2:
571                     # sinh and cosh
572                     newd[S.Exp1] -= ee
573                     ee = 0
574                     if sign == 1:
575                         newd[2*c*cosh(x/2)] += m
576                     else:
577                         newd[-2*c*sinh(x/2)] += m
578                 elif newd[1 - sign*S.Exp1**x] == -m:
579                     # tanh
580                     del newd[1 - sign*S.Exp1**x]
581                     if sign == 1:
582                         newd[-c/tanh(x/2)] += m
583                     else:
584                         newd[-c*tanh(x/2)] += m
585                 else:
586                     newd[1 + sign*S.Exp1**x] += m
587                     newd[c] += m
588 
589         return Mul(*[k**newd[k] for k in newd])
590     newexpr = bottom_up(newexpr, f)
591 
592     # sin/cos and sinh/cosh ratios to tan and tanh, respectively
593     if newexpr.has(HyperbolicFunction):
594         e, f = hyper_as_trig(newexpr)
595         newexpr = f(TR2i(e))
596     if newexpr.has(TrigonometricFunction):
597         newexpr = TR2i(newexpr)
598 
599     # can we ever generate an I where there was none previously?
600     if not (newexpr.has(I) and not expr.has(I)):
601         expr = newexpr
602     return expr
603 
604 #-------------------- the old trigsimp routines ---------------------
605 
606 def trigsimp_old(expr, **opts):
607     """
608     reduces expression by using known trig identities
609 
610     Notes
611     =====
612 
613     deep:
614     - Apply trigsimp inside all objects with arguments
615 
616     recursive:
617     - Use common subexpression elimination (cse()) and apply
618     trigsimp recursively (this is quite expensive if the
619     expression is large)
620 
621     method:
622     - Determine the method to use. Valid choices are 'matching' (default),
623     'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the
624     expression recursively by pattern matching. If 'groebner', apply an
625     experimental groebner basis algorithm. In this case further options
626     are forwarded to ``trigsimp_groebner``, please refer to its docstring.
627     If 'combined', first run the groebner basis algorithm with small
628     default parameters, then run the 'matching' algorithm. 'fu' runs the
629     collection of trigonometric transformations described by Fu, et al.
630     (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms
631     that mimic the behavior of `trigsimp`.
632 
633     compare:
634     - show input and output from `trigsimp` and `futrig` when different,
635     but returns the `trigsimp` value.
636 
637     Examples
638     ========
639 
640     >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot
641     >>> from sympy.abc import x, y
642     >>> e = 2*sin(x)**2 + 2*cos(x)**2
643     >>> trigsimp(e, old=True)
644     2
645     >>> trigsimp(log(e), old=True)
646     log(2*sin(x)**2 + 2*cos(x)**2)
647     >>> trigsimp(log(e), deep=True, old=True)
648     log(2)
649 
650     Using `method="groebner"` (or `"combined"`) can sometimes lead to a lot
651     more simplification:
652 
653     >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)
654     >>> trigsimp(e, old=True)
655     (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)
656     >>> trigsimp(e, method="groebner", old=True)
657     2/cos(x)
658 
659     >>> trigsimp(1/cot(x)**2, compare=True, old=True)
660           futrig: tan(x)**2
661     cot(x)**(-2)
662 
663     """
664     old = expr
665     first = opts.pop('first', True)
666     if first:
667         if not expr.has(*_trigs):
668             return expr
669 
670         trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])
671         if len(trigsyms) > 1:
672             d = separatevars(expr)
673             if d.is_Mul:
674                 d = separatevars(d, dict=True) or d
675             if isinstance(d, dict):
676                 expr = 1
677                 for k, v in d.items():
678                     # remove hollow factoring
679                     was = v
680                     v = expand_mul(v)
681                     opts['first'] = False
682                     vnew = trigsimp(v, **opts)
683                     if vnew == v:
684                         vnew = was
685                     expr *= vnew
686                 old = expr
687             else:
688                 if d.is_Add:
689                     for s in trigsyms:
690                         r, e = expr.as_independent(s)
691                         if r:
692                             opts['first'] = False
693                             expr = r + trigsimp(e, **opts)
694                             if not expr.is_Add:
695                                 break
696                     old = expr
697 
698     recursive = opts.pop('recursive', False)
699     deep = opts.pop('deep', False)
700     method = opts.pop('method', 'matching')
701 
702     def groebnersimp(ex, deep, **opts):
703         def traverse(e):
704             if e.is_Atom:
705                 return e
706             args = [traverse(x) for x in e.args]
707             if e.is_Function or e.is_Pow:
708                 args = [trigsimp_groebner(x, **opts) for x in args]
709             return e.func(*args)
710         if deep:
711             ex = traverse(ex)
712         return trigsimp_groebner(ex, **opts)
713 
714     trigsimpfunc = {
715         'matching': (lambda x, d: _trigsimp(x, d)),
716         'groebner': (lambda x, d: groebnersimp(x, d, **opts)),
717         'combined': (lambda x, d: _trigsimp(groebnersimp(x,
718                                        d, polynomial=True, hints=[2, tan]),
719                                    d))
720                    }[method]
721 
722     if recursive:
723         w, g = cse(expr)
724         g = trigsimpfunc(g[0], deep)
725 
726         for sub in reversed(w):
727             g = g.subs(sub[0], sub[1])
728             g = trigsimpfunc(g, deep)
729         result = g
730     else:
731         result = trigsimpfunc(expr, deep)
732 
733     if opts.get('compare', False):
734         f = futrig(old)
735         if f != result:
736             print('\tfutrig:', f)
737 
738     return result
739 
740 
741 def _dotrig(a, b):
742     """Helper to tell whether ``a`` and ``b`` have the same sorts
743     of symbols in them -- no need to test hyperbolic patterns against
744     expressions that have no hyperbolics in them."""
745     return a.func == b.func and (
746         a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or
747         a.has(HyperbolicFunction) and b.has(HyperbolicFunction))
748 
749 
750 _trigpat = None
751 def _trigpats():
752     global _trigpat
753     a, b, c = symbols('a b c', cls=Wild)
754     d = Wild('d', commutative=False)
755 
756     # for the simplifications like sinh/cosh -> tanh:
757     # DO NOT REORDER THE FIRST 14 since these are assumed to be in this
758     # order in _match_div_rewrite.
759     matchers_division = (
760         (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),
761         (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),
762         (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),
763         (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),
764         (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),
765         (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),
766         (a*(cos(b) + 1)**c*(cos(b) - 1)**c,
767             a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),
768         (a*(sin(b) + 1)**c*(sin(b) - 1)**c,
769             a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),
770 
771         (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),
772         (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),
773         (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),
774         (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),
775         (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),
776         (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),
777 
778         (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),
779             tanh(a + b)*c, S.One, S.One),
780     )
781 
782     matchers_add = (
783         (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),
784         (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),
785         (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),
786         (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),
787         (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),
788         (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),
789     )
790 
791     # for cos(x)**2 + sin(x)**2 -> 1
792     matchers_identity = (
793         (a*sin(b)**2, a - a*cos(b)**2),
794         (a*tan(b)**2, a*(1/cos(b))**2 - a),
795         (a*cot(b)**2, a*(1/sin(b))**2 - a),
796         (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),
797         (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),
798         (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),
799 
800         (a*sinh(b)**2, a*cosh(b)**2 - a),
801         (a*tanh(b)**2, a - a*(1/cosh(b))**2),
802         (a*coth(b)**2, a + a*(1/sinh(b))**2),
803         (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),
804         (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),
805         (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),
806 
807     )
808 
809     # Reduce any lingering artifacts, such as sin(x)**2 changing
810     # to 1-cos(x)**2 when sin(x)**2 was "simpler"
811     artifacts = (
812         (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),
813         (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),
814         (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),
815 
816         (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),
817         (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),
818         (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),
819 
820         # same as above but with noncommutative prefactor
821         (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),
822         (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),
823         (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),
824 
825         (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),
826         (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),
827         (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),
828     )
829 
830     _trigpat = (a, b, c, d, matchers_division, matchers_add,
831         matchers_identity, artifacts)
832     return _trigpat
833 
834 
835 def _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):
836     """Helper for _match_div_rewrite.
837 
838     Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)
839     and g(b_) are both positive or if c_ is an integer.
840     """
841     # assert expr.is_Mul and expr.is_commutative and f != g
842     fargs = defaultdict(int)
843     gargs = defaultdict(int)
844     args = []
845     for x in expr.args:
846         if x.is_Pow or x.func in (f, g):
847             b, e = x.as_base_exp()
848             if b.is_positive or e.is_integer:
849                 if b.func == f:
850                     fargs[b.args[0]] += e
851                     continue
852                 elif b.func == g:
853                     gargs[b.args[0]] += e
854                     continue
855         args.append(x)
856     common = set(fargs) & set(gargs)
857     hit = False
858     while common:
859         key = common.pop()
860         fe = fargs.pop(key)
861         ge = gargs.pop(key)
862         if fe == rexp(ge):
863             args.append(h(key)**rexph(fe))
864             hit = True
865         else:
866             fargs[key] = fe
867             gargs[key] = ge
868     if not hit:
869         return expr
870     while fargs:
871         key, e = fargs.popitem()
872         args.append(f(key)**e)
873     while gargs:
874         key, e = gargs.popitem()
875         args.append(g(key)**e)
876     return Mul(*args)
877 
878 
879 _idn = lambda x: x
880 _midn = lambda x: -x
881 _one = lambda x: S.One
882 
883 def _match_div_rewrite(expr, i):
884     """helper for __trigsimp"""
885     if i == 0:
886         expr = _replace_mul_fpowxgpow(expr, sin, cos,
887             _midn, tan, _idn)
888     elif i == 1:
889         expr = _replace_mul_fpowxgpow(expr, tan, cos,
890             _idn, sin, _idn)
891     elif i == 2:
892         expr = _replace_mul_fpowxgpow(expr, cot, sin,
893             _idn, cos, _idn)
894     elif i == 3:
895         expr = _replace_mul_fpowxgpow(expr, tan, sin,
896             _midn, cos, _midn)
897     elif i == 4:
898         expr = _replace_mul_fpowxgpow(expr, cot, cos,
899             _midn, sin, _midn)
900     elif i == 5:
901         expr = _replace_mul_fpowxgpow(expr, cot, tan,
902             _idn, _one, _idn)
903     # i in (6, 7) is skipped
904     elif i == 8:
905         expr = _replace_mul_fpowxgpow(expr, sinh, cosh,
906             _midn, tanh, _idn)
907     elif i == 9:
908         expr = _replace_mul_fpowxgpow(expr, tanh, cosh,
909             _idn, sinh, _idn)
910     elif i == 10:
911         expr = _replace_mul_fpowxgpow(expr, coth, sinh,
912             _idn, cosh, _idn)
913     elif i == 11:
914         expr = _replace_mul_fpowxgpow(expr, tanh, sinh,
915             _midn, cosh, _midn)
916     elif i == 12:
917         expr = _replace_mul_fpowxgpow(expr, coth, cosh,
918             _midn, sinh, _midn)
919     elif i == 13:
920         expr = _replace_mul_fpowxgpow(expr, coth, tanh,
921             _idn, _one, _idn)
922     else:
923         return None
924     return expr
925 
926 
927 def _trigsimp(expr, deep=False):
928     # protect the cache from non-trig patterns; we only allow
929     # trig patterns to enter the cache
930     if expr.has(*_trigs):
931         return __trigsimp(expr, deep)
932     return expr
933 
934 
935 @cacheit
936 def __trigsimp(expr, deep=False):
937     """recursive helper for trigsimp"""
938     from sympy.simplify.fu import TR10i
939 
940     if _trigpat is None:
941         _trigpats()
942     a, b, c, d, matchers_division, matchers_add, \
943     matchers_identity, artifacts = _trigpat
944 
945     if expr.is_Mul:
946         # do some simplifications like sin/cos -> tan:
947         if not expr.is_commutative:
948             com, nc = expr.args_cnc()
949             expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)
950         else:
951             for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):
952                 if not _dotrig(expr, pattern):
953                     continue
954 
955                 newexpr = _match_div_rewrite(expr, i)
956                 if newexpr is not None:
957                     if newexpr != expr:
958                         expr = newexpr
959                         break
960                     else:
961                         continue
962 
963                 # use SymPy matching instead
964                 res = expr.match(pattern)
965                 if res and res.get(c, 0):
966                     if not res[c].is_integer:
967                         ok = ok1.subs(res)
968                         if not ok.is_positive:
969                             continue
970                         ok = ok2.subs(res)
971                         if not ok.is_positive:
972                             continue
973                     # if "a" contains any of trig or hyperbolic funcs with
974                     # argument "b" then skip the simplification
975                     if any(w.args[0] == res[b] for w in res[a].atoms(
976                             TrigonometricFunction, HyperbolicFunction)):
977                         continue
978                     # simplify and finish:
979                     expr = simp.subs(res)
980                     break  # process below
981 
982     if expr.is_Add:
983         args = []
984         for term in expr.args:
985             if not term.is_commutative:
986                 com, nc = term.args_cnc()
987                 nc = Mul._from_args(nc)
988                 term = Mul._from_args(com)
989             else:
990                 nc = S.One
991             term = _trigsimp(term, deep)
992             for pattern, result in matchers_identity:
993                 res = term.match(pattern)
994                 if res is not None:
995                     term = result.subs(res)
996                     break
997             args.append(term*nc)
998         if args != expr.args:
999             expr = Add(*args)
1000             expr = min(expr, expand(expr), key=count_ops)
1001         if expr.is_Add:
1002             for pattern, result in matchers_add:
1003                 if not _dotrig(expr, pattern):
1004                     continue
1005                 expr = TR10i(expr)
1006                 if expr.has(HyperbolicFunction):
1007                     res = expr.match(pattern)
1008                     # if "d" contains any trig or hyperbolic funcs with
1009                     # argument "a" or "b" then skip the simplification;
1010                     # this isn't perfect -- see tests
1011                     if res is None or not (a in res and b in res) or any(
1012                         w.args[0] in (res[a], res[b]) for w in res[d].atoms(
1013                             TrigonometricFunction, HyperbolicFunction)):
1014                         continue
1015                     expr = result.subs(res)
1016                     break
1017 
1018         # Reduce any lingering artifacts, such as sin(x)**2 changing
1019         # to 1 - cos(x)**2 when sin(x)**2 was "simpler"
1020         for pattern, result, ex in artifacts:
1021             if not _dotrig(expr, pattern):
1022                 continue
1023             # Substitute a new wild that excludes some function(s)
1024             # to help influence a better match. This is because
1025             # sometimes, for example, 'a' would match sec(x)**2
1026             a_t = Wild('a', exclude=[ex])
1027             pattern = pattern.subs(a, a_t)
1028             result = result.subs(a, a_t)
1029 
1030             m = expr.match(pattern)
1031             was = None
1032             while m and was != expr:
1033                 was = expr
1034                 if m[a_t] == 0 or \
1035                         -m[a_t] in m[c].args or m[a_t] + m[c] == 0:
1036                     break
1037                 if d in m and m[a_t]*m[d] + m[c] == 0:
1038                     break
1039                 expr = result.subs(m)
1040                 m = expr.match(pattern)
1041                 m.setdefault(c, S.Zero)
1042 
1043     elif expr.is_Mul or expr.is_Pow or deep and expr.args:
1044         expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])
1045 
1046     try:
1047         if not expr.has(*_trigs):
1048             raise TypeError
1049         e = expr.atoms(exp)
1050         new = expr.rewrite(exp, deep=deep)
1051         if new == e:
1052             raise TypeError
1053         fnew = factor(new)
1054         if fnew != new:
1055             new = sorted([new, factor(new)], key=count_ops)[0]
1056         # if all exp that were introduced disappeared then accept it
1057         if not (new.atoms(exp) - e):
1058             expr = new
1059     except TypeError:
1060         pass
1061 
1062     return expr
1063 #------------------- end of old trigsimp routines --------------------
1064 
1065 
1066 def futrig(e, **kwargs):
1067     """Return simplified ``e`` using Fu-like transformations.
1068     This is not the "Fu" algorithm. This is called by default
1069     from ``trigsimp``. By default, hyperbolics subexpressions
1070     will be simplified, but this can be disabled by setting
1071     ``hyper=False``.
1072 
1073     Examples
1074     ========
1075 
1076     >>> from sympy import trigsimp, tan, sinh, tanh
1077     >>> from sympy.simplify.trigsimp import futrig
1078     >>> from sympy.abc import x
1079     >>> trigsimp(1/tan(x)**2)
1080     tan(x)**(-2)
1081 
1082     >>> futrig(sinh(x)/tanh(x))
1083     cosh(x)
1084 
1085     """
1086     from sympy.simplify.fu import hyper_as_trig
1087     from sympy.simplify.simplify import bottom_up
1088 
1089     e = sympify(e)
1090 
1091     if not isinstance(e, Basic):
1092         return e
1093 
1094     if not e.args:
1095         return e
1096 
1097     old = e
1098     e = bottom_up(e, lambda x: _futrig(x, **kwargs))
1099 
1100     if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):
1101         e, f = hyper_as_trig(e)
1102         e = f(_futrig(e))
1103 
1104     if e != old and e.is_Mul and e.args[0].is_Rational:
1105         # redistribute leading coeff on 2-arg Add
1106         e = Mul(*e.as_coeff_Mul())
1107     return e
1108 
1109 
1110 def _futrig(e, **kwargs):
1111     """Helper for futrig."""
1112     from sympy.simplify.fu import (
1113         TR1, TR2, TR3, TR2i, TR10, L, TR10i,
1114         TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,
1115         TR12)
1116     from sympy.core.compatibility import _nodes
1117 
1118     if not e.has(TrigonometricFunction):
1119         return e
1120 
1121     if e.is_Mul:
1122         coeff, e = e.as_independent(TrigonometricFunction)
1123     else:
1124         coeff = S.One
1125 
1126     Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)
1127     trigs = lambda x: x.has(TrigonometricFunction)
1128 
1129     tree = [identity,
1130         (
1131         TR3,  # canonical angles
1132         TR1,  # sec-csc -> cos-sin
1133         TR12,  # expand tan of sum
1134         lambda x: _eapply(factor, x, trigs),
1135         TR2,  # tan-cot -> sin-cos
1136         [identity, lambda x: _eapply(_mexpand, x, trigs)],
1137         TR2i,  # sin-cos ratio -> tan
1138         lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),
1139         TR14,  # factored identities
1140         TR5,  # sin-pow -> cos_pow
1141         TR10,  # sin-cos of sums -> sin-cos prod
1142         TR11, TR6, # reduce double angles and rewrite cos pows
1143         lambda x: _eapply(factor, x, trigs),
1144         TR14,  # factored powers of identities
1145         [identity, lambda x: _eapply(_mexpand, x, trigs)],
1146         TRmorrie,
1147         TR10i,  # sin-cos products > sin-cos of sums
1148         [identity, TR8],  # sin-cos products -> sin-cos of sums
1149         [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan
1150         [
1151             lambda x: _eapply(expand_mul, TR5(x), trigs),
1152             lambda x: _eapply(
1153                 expand_mul, TR15(x), trigs)], # pos/neg powers of sin
1154         [
1155             lambda x:  _eapply(expand_mul, TR6(x), trigs),
1156             lambda x:  _eapply(
1157                 expand_mul, TR16(x), trigs)], # pos/neg powers of cos
1158         TR111,  # tan, sin, cos to neg power -> cot, csc, sec
1159         [identity, TR2i],  # sin-cos ratio to tan
1160         [identity, lambda x: _eapply(
1161             expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc
1162         TR1, TR2, TR2i,
1163         [identity, lambda x: _eapply(
1164             factor_terms, TR12(x), trigs)],  # expand tan of sum
1165         )]
1166     e = greedy(tree, objective=Lops)(e)
1167 
1168     return coeff*e
1169 
1170 
1171 def _is_Expr(e):
1172     """_eapply helper to tell whether ``e`` and all its args
1173     are Exprs."""
1174     if not isinstance(e, Expr):
1175         return False
1176     return all(_is_Expr(i) for i in e.args)
1177 
1178 
1179 def _eapply(func, e, cond=None):
1180     """Apply ``func`` to ``e`` if all args are Exprs else only
1181     apply it to those args that *are* Exprs."""
1182     if not isinstance(e, Expr):
1183         return e
1184     if _is_Expr(e) or not e.args:
1185         return func(e)
1186     return e.func(*[
1187         _eapply(func, ei) if (cond is None or cond(ei)) else ei
1188         for ei in e.args])

</code><intended_behavior>Ensure the simplification logic correctly identifies and processes trigonometric functions with complex arguments, particularly avoiding incorrect transformations into cosh functions unless mathematically valid.</intended_behavior>, <file>sympy/functions/elementary/trigonometric.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core.add import Add
4 from sympy.core.basic import sympify, cacheit
5 from sympy.core.function import Function, ArgumentIndexError
6 from sympy.core.numbers import igcdex, Rational, pi
7 from sympy.core.singleton import S
8 from sympy.core.symbol import Symbol, Wild
9 from sympy.core.logic import fuzzy_not
10 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
11 from sympy.functions.elementary.miscellaneous import sqrt, Min, Max
12 from sympy.functions.elementary.exponential import log, exp
13 from sympy.functions.elementary.integers import floor
14 from sympy.functions.elementary.hyperbolic import (acoth, asinh, atanh, cosh,
15     coth, HyperbolicFunction, sinh, tanh)
16 from sympy.sets.sets import FiniteSet
17 from sympy.utilities.iterables import numbered_symbols
18 from sympy.core.compatibility import range
19 
20 ###############################################################################
21 ########################## TRIGONOMETRIC FUNCTIONS ############################
22 ###############################################################################
23 
24 
25 class TrigonometricFunction(Function):
26     """Base class for trigonometric functions. """
27 
28     unbranched = True
29 
30     def _eval_is_rational(self):
31         s = self.func(*self.args)
32         if s.func == self.func:
33             if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):
34                 return False
35         else:
36             return s.is_rational
37 
38     def _eval_is_algebraic(self):
39         s = self.func(*self.args)
40         if s.func == self.func:
41             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
42                 return False
43             pi_coeff = _pi_coeff(self.args[0])
44             if pi_coeff is not None and pi_coeff.is_rational:
45                 return True
46         else:
47             return s.is_algebraic
48 
49     def _eval_expand_complex(self, deep=True, **hints):
50         re_part, im_part = self.as_real_imag(deep=deep, **hints)
51         return re_part + im_part*S.ImaginaryUnit
52 
53     def _as_real_imag(self, deep=True, **hints):
54         if self.args[0].is_real:
55             if deep:
56                 hints['complex'] = False
57                 return (self.args[0].expand(deep, **hints), S.Zero)
58             else:
59                 return (self.args[0], S.Zero)
60         if deep:
61             re, im = self.args[0].expand(deep, **hints).as_real_imag()
62         else:
63             re, im = self.args[0].as_real_imag()
64         return (re, im)
65 
66     def _period(self, general_period, symbol=None):
67         f = self.args[0]
68         if symbol is None:
69             symbol = tuple(f.free_symbols)[0]
70 
71         if not f.has(symbol):
72             return S.Zero
73 
74         if f == symbol:
75             return general_period
76 
77         if symbol in f.free_symbols:
78             p, q = Wild('p'), Wild('q')
79             if f.is_Mul:
80                 g, h = f.as_independent(symbol)
81                 if h == symbol:
82                     return general_period/abs(g)
83 
84             if f.is_Add:
85                 a, h = f.as_independent(symbol)
86                 g, h = h.as_independent(symbol, as_Add=False)
87                 if h == symbol:
88                     return general_period/abs(g)
89 
90         raise NotImplementedError("Use the periodicity function instead.")
91 
92 
93 def _peeloff_pi(arg):
94     """
95     Split ARG into two parts, a "rest" and a multiple of pi/2.
96     This assumes ARG to be an Add.
97     The multiple of pi returned in the second position is always a Rational.
98 
99     Examples
100     ========
101 
102     >>> from sympy.functions.elementary.trigonometric import _peeloff_pi as peel
103     >>> from sympy import pi
104     >>> from sympy.abc import x, y
105     >>> peel(x + pi/2)
106     (x, pi/2)
107     >>> peel(x + 2*pi/3 + pi*y)
108     (x + pi*y + pi/6, pi/2)
109     """
110     for a in Add.make_args(arg):
111         if a is S.Pi:
112             K = S.One
113             break
114         elif a.is_Mul:
115             K, p = a.as_two_terms()
116             if p is S.Pi and K.is_Rational:
117                 break
118     else:
119         return arg, S.Zero
120 
121     m1 = (K % S.Half) * S.Pi
122     m2 = K*S.Pi - m1
123     return arg - m2, m2
124 
125 
126 def _pi_coeff(arg, cycles=1):
127     """
128     When arg is a Number times pi (e.g. 3*pi/2) then return the Number
129     normalized to be in the range [0, 2], else None.
130 
131     When an even multiple of pi is encountered, if it is multiplying
132     something with known parity then the multiple is returned as 0 otherwise
133     as 2.
134 
135     Examples
136     ========
137 
138     >>> from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
139     >>> from sympy import pi, Dummy
140     >>> from sympy.abc import x, y
141     >>> coeff(3*x*pi)
142     3*x
143     >>> coeff(11*pi/7)
144     11/7
145     >>> coeff(-11*pi/7)
146     3/7
147     >>> coeff(4*pi)
148     0
149     >>> coeff(5*pi)
150     1
151     >>> coeff(5.0*pi)
152     1
153     >>> coeff(5.5*pi)
154     3/2
155     >>> coeff(2 + pi)
156 
157     >>> coeff(2*Dummy(integer=True)*pi)
158     2
159     >>> coeff(2*Dummy(even=True)*pi)
160     0
161     """
162     arg = sympify(arg)
163     if arg is S.Pi:
164         return S.One
165     elif not arg:
166         return S.Zero
167     elif arg.is_Mul:
168         cx = arg.coeff(S.Pi)
169         if cx:
170             c, x = cx.as_coeff_Mul()  # pi is not included as coeff
171             if c.is_Float:
172                 # recast exact binary fractions to Rationals
173                 f = abs(c) % 1
174                 if f != 0:
175                     p = -int(round(log(f, 2).evalf()))
176                     m = 2**p
177                     cm = c*m
178                     i = int(cm)
179                     if i == cm:
180                         c = Rational(i, m)
181                         cx = c*x
182                 else:
183                     c = Rational(int(c))
184                     cx = c*x
185             if x.is_integer:
186                 c2 = c % 2
187                 if c2 == 1:
188                     return x
189                 elif not c2:
190                     if x.is_even is not None:  # known parity
191                         return S.Zero
192                     return S(2)
193                 else:
194                     return c2*x
195             return cx
196 
197 
198 class sin(TrigonometricFunction):
199     """
200     The sine function.
201 
202     Returns the sine of x (measured in radians).
203 
204     Notes
205     =====
206 
207     This function will evaluate automatically in the
208     case x/pi is some rational number [4]_.  For example,
209     if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.
210 
211     Examples
212     ========
213 
214     >>> from sympy import sin, pi
215     >>> from sympy.abc import x
216     >>> sin(x**2).diff(x)
217     2*x*cos(x**2)
218     >>> sin(1).diff(x)
219     0
220     >>> sin(pi)
221     0
222     >>> sin(pi/2)
223     1
224     >>> sin(pi/6)
225     1/2
226     >>> sin(pi/12)
227     -sqrt(2)/4 + sqrt(6)/4
228 
229 
230     See Also
231     ========
232 
233     csc, cos, sec, tan, cot
234     asin, acsc, acos, asec, atan, acot, atan2
235 
236     References
237     ==========
238 
239     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
240     .. [2] http://dlmf.nist.gov/4.14
241     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin
242     .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html
243     """
244 
245     def period(self, symbol=None):
246         return self._period(2*pi, symbol)
247 
248     def fdiff(self, argindex=1):
249         if argindex == 1:
250             return cos(self.args[0])
251         else:
252             raise ArgumentIndexError(self, argindex)
253 
254     @classmethod
255     def eval(cls, arg):
256         from sympy.calculus import AccumBounds
257         if arg.is_Number:
258             if arg is S.NaN:
259                 return S.NaN
260             elif arg is S.Zero:
261                 return S.Zero
262             elif arg is S.Infinity or arg is S.NegativeInfinity:
263                 return AccumBounds(-1, 1)
264 
265         if isinstance(arg, AccumBounds):
266             min, max = arg.min, arg.max
267             d = floor(min/(2*S.Pi))
268             if min is not S.NegativeInfinity:
269                 min = min - d*2*S.Pi
270             if max is not S.Infinity:
271                 max = max - d*2*S.Pi
272             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
273                     is not S.EmptySet and \
274                     AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,
275                         7*S.Pi/2)) is not S.EmptySet:
276                 return AccumBounds(-1, 1)
277             elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
278                     is not S.EmptySet:
279                 return AccumBounds(Min(sin(min), sin(max)), 1)
280             elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \
281                         is not S.EmptySet:
282                 return AccumBounds(-1, Max(sin(min), sin(max)))
283             else:
284                 return AccumBounds(Min(sin(min), sin(max)),
285                                 Max(sin(min), sin(max)))
286 
287         if arg.could_extract_minus_sign():
288             return -cls(-arg)
289 
290         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
291         if i_coeff is not None:
292             return S.ImaginaryUnit * sinh(i_coeff)
293 
294         pi_coeff = _pi_coeff(arg)
295         if pi_coeff is not None:
296             if pi_coeff.is_integer:
297                 return S.Zero
298 
299             if (2*pi_coeff).is_integer:
300                 if pi_coeff.is_even:
301                     return S.Zero
302                 elif pi_coeff.is_even is False:
303                     return S.NegativeOne**(pi_coeff - S.Half)
304 
305             if not pi_coeff.is_Rational:
306                 narg = pi_coeff*S.Pi
307                 if narg != arg:
308                     return cls(narg)
309                 return None
310 
311             # https://github.com/sympy/sympy/issues/6048
312             # transform a sine to a cosine, to avoid redundant code
313             if pi_coeff.is_Rational:
314                 x = pi_coeff % 2
315                 if x > 1:
316                     return -cls((x % 1)*S.Pi)
317                 if 2*x > 1:
318                     return cls((1 - x)*S.Pi)
319                 narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi
320                 result = cos(narg)
321                 if not isinstance(result, cos):
322                     return result
323                 if pi_coeff*S.Pi != arg:
324                     return cls(pi_coeff*S.Pi)
325                 return None
326 
327         if arg.is_Add:
328             x, m = _peeloff_pi(arg)
329             if m:
330                 return sin(m)*cos(x) + cos(m)*sin(x)
331 
332         if arg.func is asin:
333             return arg.args[0]
334 
335         if arg.func is atan:
336             x = arg.args[0]
337             return x / sqrt(1 + x**2)
338 
339         if arg.func is atan2:
340             y, x = arg.args
341             return y / sqrt(x**2 + y**2)
342 
343         if arg.func is acos:
344             x = arg.args[0]
345             return sqrt(1 - x**2)
346 
347         if arg.func is acot:
348             x = arg.args[0]
349             return 1 / (sqrt(1 + 1 / x**2) * x)
350 
351         if arg.func is acsc:
352             x = arg.args[0]
353             return 1 / x
354 
355         if arg.func is asec:
356             x = arg.args[0]
357             return sqrt(1 - 1 / x**2)
358 
359     @staticmethod
360     @cacheit
361     def taylor_term(n, x, *previous_terms):
362         if n < 0 or n % 2 == 0:
363             return S.Zero
364         else:
365             x = sympify(x)
366 
367             if len(previous_terms) > 2:
368                 p = previous_terms[-2]
369                 return -p * x**2 / (n*(n - 1))
370             else:
371                 return (-1)**(n//2) * x**(n)/factorial(n)
372 
373     def _eval_rewrite_as_exp(self, arg):
374         I = S.ImaginaryUnit
375         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
376             arg = arg.func(arg.args[0]).rewrite(exp)
377         return (exp(arg*I) - exp(-arg*I)) / (2*I)
378 
379     def _eval_rewrite_as_Pow(self, arg):
380         if arg.func is log:
381             I = S.ImaginaryUnit
382             x = arg.args[0]
383             return I*x**-I / 2 - I*x**I /2
384 
385     def _eval_rewrite_as_cos(self, arg):
386         return cos(arg - S.Pi / 2, evaluate=False)
387 
388     def _eval_rewrite_as_tan(self, arg):
389         tan_half = tan(S.Half*arg)
390         return 2*tan_half/(1 + tan_half**2)
391 
392     def _eval_rewrite_as_sincos(self, arg):
393         return sin(arg)*cos(arg)/cos(arg)
394 
395     def _eval_rewrite_as_cot(self, arg):
396         cot_half = cot(S.Half*arg)
397         return 2*cot_half/(1 + cot_half**2)
398 
399     def _eval_rewrite_as_pow(self, arg):
400         return self.rewrite(cos).rewrite(pow)
401 
402     def _eval_rewrite_as_sqrt(self, arg):
403         return self.rewrite(cos).rewrite(sqrt)
404 
405     def _eval_rewrite_as_csc(self, arg):
406         return 1/csc(arg)
407 
408     def _eval_rewrite_as_sec(self, arg):
409         return 1 / sec(arg - S.Pi / 2, evaluate=False)
410 
411     def _eval_conjugate(self):
412         return self.func(self.args[0].conjugate())
413 
414     def as_real_imag(self, deep=True, **hints):
415         re, im = self._as_real_imag(deep=deep, **hints)
416         return (sin(re)*cosh(im), cos(re)*sinh(im))
417 
418     def _eval_expand_trig(self, **hints):
419         from sympy import expand_mul
420         from sympy.functions.special.polynomials import chebyshevt, chebyshevu
421         arg = self.args[0]
422         x = None
423         if arg.is_Add:  # TODO, implement more if deep stuff here
424             # TODO: Do this more efficiently for more than two terms
425             x, y = arg.as_two_terms()
426             sx = sin(x, evaluate=False)._eval_expand_trig()
427             sy = sin(y, evaluate=False)._eval_expand_trig()
428             cx = cos(x, evaluate=False)._eval_expand_trig()
429             cy = cos(y, evaluate=False)._eval_expand_trig()
430             return sx*cy + sy*cx
431         else:
432             n, x = arg.as_coeff_Mul(rational=True)
433             if n.is_Integer:  # n will be positive because of .eval
434                 # canonicalization
435 
436                 # See http://mathworld.wolfram.com/Multiple-AngleFormulas.html
437                 if n.is_odd:
438                     return (-1)**((n - 1)/2)*chebyshevt(n, sin(x))
439                 else:
440                     return expand_mul((-1)**(n/2 - 1)*cos(x)*chebyshevu(n -
441                         1, sin(x)), deep=False)
442             pi_coeff = _pi_coeff(arg)
443             if pi_coeff is not None:
444                 if pi_coeff.is_Rational:
445                     return self.rewrite(sqrt)
446         return sin(arg)
447 
448     def _eval_as_leading_term(self, x):
449         from sympy import Order
450         arg = self.args[0].as_leading_term(x)
451 
452         if x in arg.free_symbols and Order(1, x).contains(arg):
453             return arg
454         else:
455             return self.func(arg)
456 
457     def _eval_is_real(self):
458         return self.args[0].is_real
459 
460     def _eval_is_finite(self):
461         arg = self.args[0]
462         if arg.is_real:
463             return True
464 
465 
466 class cos(TrigonometricFunction):
467     """
468     The cosine function.
469 
470     Returns the cosine of x (measured in radians).
471 
472     Notes
473     =====
474 
475     See :func:`sin` for notes about automatic evaluation.
476 
477     Examples
478     ========
479 
480     >>> from sympy import cos, pi
481     >>> from sympy.abc import x
482     >>> cos(x**2).diff(x)
483     -2*x*sin(x**2)
484     >>> cos(1).diff(x)
485     0
486     >>> cos(pi)
487     -1
488     >>> cos(pi/2)
489     0
490     >>> cos(2*pi/3)
491     -1/2
492     >>> cos(pi/12)
493     sqrt(2)/4 + sqrt(6)/4
494 
495     See Also
496     ========
497 
498     sin, csc, sec, tan, cot
499     asin, acsc, acos, asec, atan, acot, atan2
500 
501     References
502     ==========
503 
504     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
505     .. [2] http://dlmf.nist.gov/4.14
506     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos
507     """
508 
509     def period(self, symbol=None):
510         return self._period(2*pi, symbol)
511 
512     def fdiff(self, argindex=1):
513         if argindex == 1:
514             return -sin(self.args[0])
515         else:
516             raise ArgumentIndexError(self, argindex)
517 
518     @classmethod
519     def eval(cls, arg):
520         from sympy.functions.special.polynomials import chebyshevt
521         from sympy.calculus.util import AccumBounds
522         if arg.is_Number:
523             if arg is S.NaN:
524                 return S.NaN
525             elif arg is S.Zero:
526                 return S.One
527             elif arg is S.Infinity or arg is S.NegativeInfinity:
528                 # In this case it is better to return AccumBounds(-1, 1)
529                 # rather than returning S.NaN, since AccumBounds(-1, 1)
530                 # preserves the information that sin(oo) is between
531                 # -1 and 1, where S.NaN does not do that.
532                 return AccumBounds(-1, 1)
533 
534         if isinstance(arg, AccumBounds):
535             return sin(arg + S.Pi/2)
536 
537         if arg.could_extract_minus_sign():
538             return cls(-arg)
539 
540         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
541         if i_coeff is not None:
542             return cosh(i_coeff)
543 
544         pi_coeff = _pi_coeff(arg)
545         if pi_coeff is not None:
546             if pi_coeff.is_integer:
547                 return (S.NegativeOne)**pi_coeff
548 
549             if (2*pi_coeff).is_integer:
550                 if pi_coeff.is_even:
551                     return (S.NegativeOne)**(pi_coeff/2)
552                 elif pi_coeff.is_even is False:
553                     return S.Zero
554 
555             if not pi_coeff.is_Rational:
556                 narg = pi_coeff*S.Pi
557                 if narg != arg:
558                     return cls(narg)
559                 return None
560 
561             # cosine formula #####################
562             # https://github.com/sympy/sympy/issues/6048
563             # explicit calculations are preformed for
564             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120
565             # Some other exact values like cos(k pi/240) can be
566             # calculated using a partial-fraction decomposition
567             # by calling cos( X ).rewrite(sqrt)
568             cst_table_some = {
569                 3: S.Half,
570                 5: (sqrt(5) + 1)/4,
571             }
572             if pi_coeff.is_Rational:
573                 q = pi_coeff.q
574                 p = pi_coeff.p % (2*q)
575                 if p > q:
576                     narg = (pi_coeff - 1)*S.Pi
577                     return -cls(narg)
578                 if 2*p > q:
579                     narg = (1 - pi_coeff)*S.Pi
580                     return -cls(narg)
581 
582                 # If nested sqrt's are worse than un-evaluation
583                 # you can require q to be in (1, 2, 3, 4, 6, 12)
584                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return
585                 # expressions with 2 or fewer sqrt nestings.
586                 table2 = {
587                     12: (3, 4),
588                     20: (4, 5),
589                     30: (5, 6),
590                     15: (6, 10),
591                     24: (6, 8),
592                     40: (8, 10),
593                     60: (20, 30),
594                     120: (40, 60)
595                     }
596                 if q in table2:
597                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]
598                     nvala, nvalb = cls(a), cls(b)
599                     if None == nvala or None == nvalb:
600                         return None
601                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)
602 
603                 if q > 12:
604                     return None
605 
606                 if q in cst_table_some:
607                     cts = cst_table_some[pi_coeff.q]
608                     return chebyshevt(pi_coeff.p, cts).expand()
609 
610                 if 0 == q % 2:
611                     narg = (pi_coeff*2)*S.Pi
612                     nval = cls(narg)
613                     if None == nval:
614                         return None
615                     x = (2*pi_coeff + 1)/2
616                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))
617                     return sign_cos*sqrt( (1 + nval)/2 )
618             return None
619 
620         if arg.is_Add:
621             x, m = _peeloff_pi(arg)
622             if m:
623                 return cos(m)*cos(x) - sin(m)*sin(x)
624 
625         if arg.func is acos:
626             return arg.args[0]
627 
628         if arg.func is atan:
629             x = arg.args[0]
630             return 1 / sqrt(1 + x**2)
631 
632         if arg.func is atan2:
633             y, x = arg.args
634             return x / sqrt(x**2 + y**2)
635 
636         if arg.func is asin:
637             x = arg.args[0]
638             return sqrt(1 - x ** 2)
639 
640         if arg.func is acot:
641             x = arg.args[0]
642             return 1 / sqrt(1 + 1 / x**2)
643 
644         if arg.func is acsc:
645             x = arg.args[0]
646             return sqrt(1 - 1 / x**2)
647 
648         if arg.func is asec:
649             x = arg.args[0]
650             return 1 / x
651 
652     @staticmethod
653     @cacheit
654     def taylor_term(n, x, *previous_terms):
655         if n < 0 or n % 2 == 1:
656             return S.Zero
657         else:
658             x = sympify(x)
659 
660             if len(previous_terms) > 2:
661                 p = previous_terms[-2]
662                 return -p * x**2 / (n*(n - 1))
663             else:
664                 return (-1)**(n//2)*x**(n)/factorial(n)
665 
666     def _eval_rewrite_as_exp(self, arg):
667         I = S.ImaginaryUnit
668         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
669             arg = arg.func(arg.args[0]).rewrite(exp)
670         return (exp(arg*I) + exp(-arg*I)) / 2
671 
672     def _eval_rewrite_as_Pow(self, arg):
673         if arg.func is log:
674             I = S.ImaginaryUnit
675             x = arg.args[0]
676             return x**I/2 + x**-I/2
677 
678     def _eval_rewrite_as_sin(self, arg):
679         return sin(arg + S.Pi / 2, evaluate=False)
680 
681     def _eval_rewrite_as_tan(self, arg):
682         tan_half = tan(S.Half*arg)**2
683         return (1 - tan_half)/(1 + tan_half)
684 
685     def _eval_rewrite_as_sincos(self, arg):
686         return sin(arg)*cos(arg)/sin(arg)
687 
688     def _eval_rewrite_as_cot(self, arg):
689         cot_half = cot(S.Half*arg)**2
690         return (cot_half - 1)/(cot_half + 1)
691 
692     def _eval_rewrite_as_pow(self, arg):
693         return self._eval_rewrite_as_sqrt(arg)
694 
695     def _eval_rewrite_as_sqrt(self, arg):
696         from sympy.functions.special.polynomials import chebyshevt
697 
698         def migcdex(x):
699             # recursive calcuation of gcd and linear combination
700             # for a sequence of integers.
701             # Given  (x1, x2, x3)
702             # Returns (y1, y1, y3, g)
703             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0
704             # Note, that this is only one such linear combination.
705             if len(x) == 1:
706                 return (1, x[0])
707             if len(x) == 2:
708                 return igcdex(x[0], x[-1])
709             g = migcdex(x[1:])
710             u, v, h = igcdex(x[0], g[-1])
711             return tuple([u] + [v*i for i in g[0:-1] ] + [h])
712 
713         def ipartfrac(r, factors=None):
714             from sympy.ntheory import factorint
715             if isinstance(r, int):
716                 return r
717             if not isinstance(r, Rational):
718                 raise TypeError("r is not rational")
719             n = r.q
720             if 2 > r.q*r.q:
721                 return r.q
722 
723             if None == factors:
724                 a = [n//x**y for x, y in factorint(r.q).items()]
725             else:
726                 a = [n//x for x in factors]
727             if len(a) == 1:
728                 return [ r ]
729             h = migcdex(a)
730             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]
731             assert r == sum(ans)
732             return ans
733         pi_coeff = _pi_coeff(arg)
734         if pi_coeff is None:
735             return None
736 
737         if pi_coeff.is_integer:
738             # it was unevaluated
739             return self.func(pi_coeff*S.Pi)
740 
741         if not pi_coeff.is_Rational:
742             return None
743 
744         def _cospi257():
745             """ Express cos(pi/257) explicitly as a function of radicals
746                 Based upon the equations in
747                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals
748                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt
749             """
750             def f1(a, b):
751                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2
752 
753             def f2(a, b):
754                 return (a - sqrt(a**2 + b))/2
755 
756             t1, t2 = f1(-1, 256)
757             z1, z3 = f1(t1, 64)
758             z2, z4 = f1(t2, 64)
759             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))
760             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))
761             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))
762             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))
763             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))
764             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))
765             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))
766             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))
767             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))
768             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))
769             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))
770             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))
771             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))
772             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))
773             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))
774             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))
775             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))
776             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))
777             u1 = -f2(-v1, -4*(v2 + v3))
778             u2 = -f2(-v4, -4*(v5 + v6))
779             w1 = -2*f2(-u1, -4*u2)
780             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)
781 
782         cst_table_some = {
783             3: S.Half,
784             5: (sqrt(5) + 1)/4,
785             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +
786                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))
787                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),
788             257: _cospi257()
789             # 65537 is the only other known Fermat prime and the very
790             # large expression is intentionally omitted from SymPy; see
791             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt
792         }
793 
794         def _fermatCoords(n):
795             # if n can be factored in terms of Fermat primes with
796             # multiplicity of each being 1, return those primes, else
797             # False
798             primes = []
799             for p_i in cst_table_some:
800                 quotient, remainder = divmod(n, p_i)
801                 if remainder == 0:
802                     n = quotient
803                     primes.append(p_i)
804                     if n == 1:
805                         return tuple(primes)
806             return False
807 
808         if pi_coeff.q in cst_table_some:
809             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])
810             if pi_coeff.q < 257:
811                 rv = rv.expand()
812             return rv
813 
814         if not pi_coeff.q % 2:  # recursively remove factors of 2
815             pico2 = pi_coeff*2
816             nval = cos(pico2*S.Pi).rewrite(sqrt)
817             x = (pico2 + 1)/2
818             sign_cos = -1 if int(x) % 2 else 1
819             return sign_cos*sqrt( (1 + nval)/2 )
820 
821         FC = _fermatCoords(pi_coeff.q)
822         if FC:
823             decomp = ipartfrac(pi_coeff, FC)
824             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
825             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
826             return pcls.rewrite(sqrt)
827         else:
828             decomp = ipartfrac(pi_coeff)
829             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
830             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
831             return pcls
832 
833     def _eval_rewrite_as_sec(self, arg):
834         return 1/sec(arg)
835 
836     def _eval_rewrite_as_csc(self, arg):
837         return 1 / sec(arg)._eval_rewrite_as_csc(arg)
838 
839     def _eval_conjugate(self):
840         return self.func(self.args[0].conjugate())
841 
842     def as_real_imag(self, deep=True, **hints):
843         re, im = self._as_real_imag(deep=deep, **hints)
844         return (cos(re)*cosh(im), -sin(re)*sinh(im))
845 
846     def _eval_expand_trig(self, **hints):
847         from sympy.functions.special.polynomials import chebyshevt
848         arg = self.args[0]
849         x = None
850         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms
851             x, y = arg.as_two_terms()
852             sx = sin(x, evaluate=False)._eval_expand_trig()
853             sy = sin(y, evaluate=False)._eval_expand_trig()
854             cx = cos(x, evaluate=False)._eval_expand_trig()
855             cy = cos(y, evaluate=False)._eval_expand_trig()
856             return cx*cy - sx*sy
857         else:
858             coeff, terms = arg.as_coeff_Mul(rational=True)
859             if coeff.is_Integer:
860                 return chebyshevt(coeff, cos(terms))
861             pi_coeff = _pi_coeff(arg)
862             if pi_coeff is not None:
863                 if pi_coeff.is_Rational:
864                     return self.rewrite(sqrt)
865         return cos(arg)
866 
867     def _eval_as_leading_term(self, x):
868         from sympy import Order
869         arg = self.args[0].as_leading_term(x)
870 
871         if x in arg.free_symbols and Order(1, x).contains(arg):
872             return S.One
873         else:
874             return self.func(arg)
875 
876     def _eval_is_real(self):
877         return self.args[0].is_real
878 
879     def _eval_is_finite(self):
880         arg = self.args[0]
881 
882         if arg.is_real:
883             return True
884 
885 
886 class tan(TrigonometricFunction):
887     """
888     The tangent function.
889 
890     Returns the tangent of x (measured in radians).
891 
892     Notes
893     =====
894 
895     See :func:`sin` for notes about automatic evaluation.
896 
897     Examples
898     ========
899 
900     >>> from sympy import tan, pi
901     >>> from sympy.abc import x
902     >>> tan(x**2).diff(x)
903     2*x*(tan(x**2)**2 + 1)
904     >>> tan(1).diff(x)
905     0
906     >>> tan(pi/8).expand()
907     -1 + sqrt(2)
908 
909     See Also
910     ========
911 
912     sin, csc, cos, sec, cot
913     asin, acsc, acos, asec, atan, acot, atan2
914 
915     References
916     ==========
917 
918     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
919     .. [2] http://dlmf.nist.gov/4.14
920     .. [3] http://functions.wolfram.com/ElementaryFunctions/Tan
921     """
922 
923     def period(self, symbol=None):
924         return self._period(pi, symbol)
925 
926     def fdiff(self, argindex=1):
927         if argindex == 1:
928             return S.One + self**2
929         else:
930             raise ArgumentIndexError(self, argindex)
931 
932     def inverse(self, argindex=1):
933         """
934         Returns the inverse of this function.
935         """
936         return atan
937 
938     @classmethod
939     def eval(cls, arg):
940         from sympy.calculus.util import AccumBounds
941         if arg.is_Number:
942             if arg is S.NaN:
943                 return S.NaN
944             elif arg is S.Zero:
945                 return S.Zero
946             elif arg is S.Infinity or arg is S.NegativeInfinity:
947                 return AccumBounds(S.NegativeInfinity, S.Infinity)
948 
949         if isinstance(arg, AccumBounds):
950             min, max = arg.min, arg.max
951             d = floor(min/S.Pi)
952             if min is not S.NegativeInfinity:
953                 min = min - d*S.Pi
954             if max is not S.Infinity:
955                 max = max - d*S.Pi
956             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 3*S.Pi/2)):
957                 return AccumBounds(S.NegativeInfinity, S.Infinity)
958             else:
959                 return AccumBounds(tan(min), tan(max))
960 
961         if arg.could_extract_minus_sign():
962             return -cls(-arg)
963 
964         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
965         if i_coeff is not None:
966             return S.ImaginaryUnit * tanh(i_coeff)
967 
968         pi_coeff = _pi_coeff(arg, 2)
969         if pi_coeff is not None:
970             if pi_coeff.is_integer:
971                 return S.Zero
972 
973             if not pi_coeff.is_Rational:
974                 narg = pi_coeff*S.Pi
975                 if narg != arg:
976                     return cls(narg)
977                 return None
978 
979             if pi_coeff.is_Rational:
980                 if not pi_coeff.q % 2:
981                     narg = pi_coeff*S.Pi*2
982                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
983                     if not isinstance(cresult, cos) \
984                             and not isinstance(sresult, cos):
985                         if sresult == 0:
986                             return S.ComplexInfinity
987                         return (1 - cresult)/sresult
988                 table2 = {
989                     12: (3, 4),
990                     20: (4, 5),
991                     30: (5, 6),
992                     15: (6, 10),
993                     24: (6, 8),
994                     40: (8, 10),
995                     60: (20, 30),
996                     120: (40, 60)
997                     }
998                 q = pi_coeff.q
999                 p = pi_coeff.p % q
1000                 if q in table2:
1001                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
1002                     if None == nvala or None == nvalb:
1003                         return None
1004                     return (nvala - nvalb)/(1 + nvala*nvalb)
1005                 narg = ((pi_coeff + S.Half) % 1 - S.Half)*S.Pi
1006                 # see cos() to specify which expressions should  be
1007                 # expanded automatically in terms of radicals
1008                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1009                 if not isinstance(cresult, cos) \
1010                         and not isinstance(sresult, cos):
1011                     if cresult == 0:
1012                         return S.ComplexInfinity
1013                     return (sresult/cresult)
1014                 if narg != arg:
1015                     return cls(narg)
1016 
1017         if arg.is_Add:
1018             x, m = _peeloff_pi(arg)
1019             if m:
1020                 tanm = tan(m)
1021                 tanx = tan(x)
1022                 if tanm is S.ComplexInfinity:
1023                     return -cot(x)
1024                 return (tanm + tanx)/(1 - tanm*tanx)
1025 
1026         if arg.func is atan:
1027             return arg.args[0]
1028 
1029         if arg.func is atan2:
1030             y, x = arg.args
1031             return y/x
1032 
1033         if arg.func is asin:
1034             x = arg.args[0]
1035             return x / sqrt(1 - x**2)
1036 
1037         if arg.func is acos:
1038             x = arg.args[0]
1039             return sqrt(1 - x**2) / x
1040 
1041         if arg.func is acot:
1042             x = arg.args[0]
1043             return 1 / x
1044 
1045         if arg.func is acsc:
1046             x = arg.args[0]
1047             return 1 / (sqrt(1 - 1 / x**2) * x)
1048 
1049         if arg.func is asec:
1050             x = arg.args[0]
1051             return sqrt(1 - 1 / x**2) * x
1052 
1053     @staticmethod
1054     @cacheit
1055     def taylor_term(n, x, *previous_terms):
1056         from sympy import bernoulli
1057         if n < 0 or n % 2 == 0:
1058             return S.Zero
1059         else:
1060             x = sympify(x)
1061 
1062             a, b = ((n - 1)//2), 2**(n + 1)
1063 
1064             B = bernoulli(n + 1)
1065             F = factorial(n + 1)
1066 
1067             return (-1)**a * b*(b - 1) * B/F * x**n
1068 
1069     def _eval_nseries(self, x, n, logx):
1070         i = self.args[0].limit(x, 0)*2/S.Pi
1071         if i and i.is_Integer:
1072             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1073         return Function._eval_nseries(self, x, n=n, logx=logx)
1074 
1075     def _eval_rewrite_as_Pow(self, arg):
1076         if arg.func is log:
1077             I = S.ImaginaryUnit
1078             x = arg.args[0]
1079             return I*(x**-I - x**I)/(x**-I + x**I)
1080 
1081     def _eval_conjugate(self):
1082         return self.func(self.args[0].conjugate())
1083 
1084     def as_real_imag(self, deep=True, **hints):
1085         re, im = self._as_real_imag(deep=deep, **hints)
1086         if im:
1087             denom = cos(2*re) + cosh(2*im)
1088             return (sin(2*re)/denom, sinh(2*im)/denom)
1089         else:
1090             return (self.func(re), S.Zero)
1091 
1092     def _eval_expand_trig(self, **hints):
1093         from sympy import im, re
1094         arg = self.args[0]
1095         x = None
1096         if arg.is_Add:
1097             from sympy import symmetric_poly
1098             n = len(arg.args)
1099             TX = []
1100             for x in arg.args:
1101                 tx = tan(x, evaluate=False)._eval_expand_trig()
1102                 TX.append(tx)
1103 
1104             Yg = numbered_symbols('Y')
1105             Y = [ next(Yg) for i in range(n) ]
1106 
1107             p = [0, 0]
1108             for i in range(n + 1):
1109                 p[1 - i % 2] += symmetric_poly(i, Y)*(-1)**((i % 4)//2)
1110             return (p[0]/p[1]).subs(list(zip(Y, TX)))
1111 
1112         else:
1113             coeff, terms = arg.as_coeff_Mul(rational=True)
1114             if coeff.is_Integer and coeff > 1:
1115                 I = S.ImaginaryUnit
1116                 z = Symbol('dummy', real=True)
1117                 P = ((1 + I*z)**coeff).expand()
1118                 return (im(P)/re(P)).subs([(z, tan(terms))])
1119         return tan(arg)
1120 
1121     def _eval_rewrite_as_exp(self, arg):
1122         I = S.ImaginaryUnit
1123         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1124             arg = arg.func(arg.args[0]).rewrite(exp)
1125         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1126         return I*(neg_exp - pos_exp)/(neg_exp + pos_exp)
1127 
1128     def _eval_rewrite_as_sin(self, x):
1129         return 2*sin(x)**2/sin(2*x)
1130 
1131     def _eval_rewrite_as_cos(self, x):
1132         return cos(x - S.Pi / 2, evaluate=False) / cos(x)
1133 
1134     def _eval_rewrite_as_sincos(self, arg):
1135         return sin(arg)/cos(arg)
1136 
1137     def _eval_rewrite_as_cot(self, arg):
1138         return 1/cot(arg)
1139 
1140     def _eval_rewrite_as_sec(self, arg):
1141         sin_in_sec_form = sin(arg)._eval_rewrite_as_sec(arg)
1142         cos_in_sec_form = cos(arg)._eval_rewrite_as_sec(arg)
1143         return sin_in_sec_form / cos_in_sec_form
1144 
1145     def _eval_rewrite_as_csc(self, arg):
1146         sin_in_csc_form = sin(arg)._eval_rewrite_as_csc(arg)
1147         cos_in_csc_form = cos(arg)._eval_rewrite_as_csc(arg)
1148         return sin_in_csc_form / cos_in_csc_form
1149 
1150     def _eval_rewrite_as_pow(self, arg):
1151         y = self.rewrite(cos).rewrite(pow)
1152         if y.has(cos):
1153             return None
1154         return y
1155 
1156     def _eval_rewrite_as_sqrt(self, arg):
1157         y = self.rewrite(cos).rewrite(sqrt)
1158         if y.has(cos):
1159             return None
1160         return y
1161 
1162     def _eval_as_leading_term(self, x):
1163         from sympy import Order
1164         arg = self.args[0].as_leading_term(x)
1165 
1166         if x in arg.free_symbols and Order(1, x).contains(arg):
1167             return arg
1168         else:
1169             return self.func(arg)
1170 
1171     def _eval_is_real(self):
1172         return self.args[0].is_real
1173 
1174     def _eval_is_finite(self):
1175         arg = self.args[0]
1176 
1177         if arg.is_imaginary:
1178             return True
1179 
1180 
1181 class cot(TrigonometricFunction):
1182     """
1183     The cotangent function.
1184 
1185     Returns the cotangent of x (measured in radians).
1186 
1187     Notes
1188     =====
1189 
1190     See :func:`sin` for notes about automatic evaluation.
1191 
1192     Examples
1193     ========
1194 
1195     >>> from sympy import cot, pi
1196     >>> from sympy.abc import x
1197     >>> cot(x**2).diff(x)
1198     2*x*(-cot(x**2)**2 - 1)
1199     >>> cot(1).diff(x)
1200     0
1201     >>> cot(pi/12)
1202     sqrt(3) + 2
1203 
1204     See Also
1205     ========
1206 
1207     sin, csc, cos, sec, tan
1208     asin, acsc, acos, asec, atan, acot, atan2
1209 
1210     References
1211     ==========
1212 
1213     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1214     .. [2] http://dlmf.nist.gov/4.14
1215     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cot
1216     """
1217 
1218     def period(self, symbol=None):
1219         return self._period(pi, symbol)
1220 
1221     def fdiff(self, argindex=1):
1222         if argindex == 1:
1223             return S.NegativeOne - self**2
1224         else:
1225             raise ArgumentIndexError(self, argindex)
1226 
1227     def inverse(self, argindex=1):
1228         """
1229         Returns the inverse of this function.
1230         """
1231         return acot
1232 
1233     @classmethod
1234     def eval(cls, arg):
1235         from sympy.calculus.util import AccumBounds
1236         if arg.is_Number:
1237             if arg is S.NaN:
1238                 return S.NaN
1239             if arg is S.Zero:
1240                 return S.ComplexInfinity
1241 
1242         if isinstance(arg, AccumBounds):
1243             return -tan(arg + S.Pi/2)
1244 
1245         if arg.could_extract_minus_sign():
1246             return -cls(-arg)
1247 
1248         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1249         if i_coeff is not None:
1250             return -S.ImaginaryUnit * coth(i_coeff)
1251 
1252         pi_coeff = _pi_coeff(arg, 2)
1253         if pi_coeff is not None:
1254             if pi_coeff.is_integer:
1255                 return S.ComplexInfinity
1256 
1257             if not pi_coeff.is_Rational:
1258                 narg = pi_coeff*S.Pi
1259                 if narg != arg:
1260                     return cls(narg)
1261                 return None
1262 
1263             if pi_coeff.is_Rational:
1264                 if pi_coeff.q > 2 and not pi_coeff.q % 2:
1265                     narg = pi_coeff*S.Pi*2
1266                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1267                     if not isinstance(cresult, cos) \
1268                             and not isinstance(sresult, cos):
1269                         return (1 + cresult)/sresult
1270                 table2 = {
1271                     12: (3, 4),
1272                     20: (4, 5),
1273                     30: (5, 6),
1274                     15: (6, 10),
1275                     24: (6, 8),
1276                     40: (8, 10),
1277                     60: (20, 30),
1278                     120: (40, 60)
1279                     }
1280                 q = pi_coeff.q
1281                 p = pi_coeff.p % q
1282                 if q in table2:
1283                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
1284                     if None == nvala or None == nvalb:
1285                         return None
1286                     return (1 + nvala*nvalb)/(nvalb - nvala)
1287                 narg = (((pi_coeff + S.Half) % 1) - S.Half)*S.Pi
1288                 # see cos() to specify which expressions should be
1289                 # expanded automatically in terms of radicals
1290                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1291                 if not isinstance(cresult, cos) \
1292                         and not isinstance(sresult, cos):
1293                     if sresult == 0:
1294                         return S.ComplexInfinity
1295                     return cresult / sresult
1296                 if narg != arg:
1297                     return cls(narg)
1298 
1299         if arg.is_Add:
1300             x, m = _peeloff_pi(arg)
1301             if m:
1302                 cotm = cot(m)
1303                 if cotm == 0:
1304                     return -tan(x)
1305                 cotx = cot(x)
1306                 if cotm is S.ComplexInfinity:
1307                     return cotx
1308                 if cotm.is_Rational:
1309                     return (cotm*cotx - 1) / (cotm + cotx)
1310             return None
1311 
1312         if arg.func is acot:
1313             return arg.args[0]
1314 
1315         if arg.func is atan:
1316             x = arg.args[0]
1317             return 1 / x
1318 
1319         if arg.func is atan2:
1320             y, x = arg.args
1321             return x/y
1322 
1323         if arg.func is asin:
1324             x = arg.args[0]
1325             return sqrt(1 - x**2) / x
1326 
1327         if arg.func is acos:
1328             x = arg.args[0]
1329             return x / sqrt(1 - x**2)
1330 
1331         if arg.func is acsc:
1332             x = arg.args[0]
1333             return sqrt(1 - 1 / x**2) * x
1334 
1335         if arg.func is asec:
1336             x = arg.args[0]
1337             return 1 / (sqrt(1 - 1 / x**2) * x)
1338 
1339     @staticmethod
1340     @cacheit
1341     def taylor_term(n, x, *previous_terms):
1342         from sympy import bernoulli
1343         if n == 0:
1344             return 1 / sympify(x)
1345         elif n < 0 or n % 2 == 0:
1346             return S.Zero
1347         else:
1348             x = sympify(x)
1349 
1350             B = bernoulli(n + 1)
1351             F = factorial(n + 1)
1352 
1353             return (-1)**((n + 1)//2) * 2**(n + 1) * B/F * x**n
1354 
1355     def _eval_nseries(self, x, n, logx):
1356         i = self.args[0].limit(x, 0)/S.Pi
1357         if i and i.is_Integer:
1358             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1359         return self.rewrite(tan)._eval_nseries(x, n=n, logx=logx)
1360 
1361     def _eval_conjugate(self):
1362         return self.func(self.args[0].conjugate())
1363 
1364     def as_real_imag(self, deep=True, **hints):
1365         re, im = self._as_real_imag(deep=deep, **hints)
1366         if im:
1367             denom = cos(2*re) - cosh(2*im)
1368             return (-sin(2*re)/denom, -sinh(2*im)/denom)
1369         else:
1370             return (self.func(re), S.Zero)
1371 
1372     def _eval_rewrite_as_exp(self, arg):
1373         I = S.ImaginaryUnit
1374         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1375             arg = arg.func(arg.args[0]).rewrite(exp)
1376         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1377         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)
1378 
1379     def _eval_rewrite_as_Pow(self, arg):
1380         if arg.func is log:
1381             I = S.ImaginaryUnit
1382             x = arg.args[0]
1383             return -I*(x**-I + x**I)/(x**-I - x**I)
1384 
1385     def _eval_rewrite_as_sin(self, x):
1386         return 2*sin(2*x)/sin(x)**2
1387 
1388     def _eval_rewrite_as_cos(self, x):
1389         return cos(x) / cos(x - S.Pi / 2, evaluate=False)
1390 
1391     def _eval_rewrite_as_sincos(self, arg):
1392         return cos(arg)/sin(arg)
1393 
1394     def _eval_rewrite_as_tan(self, arg):
1395         return 1/tan(arg)
1396 
1397     def _eval_rewrite_as_sec(self, arg):
1398         cos_in_sec_form = cos(arg)._eval_rewrite_as_sec(arg)
1399         sin_in_sec_form = sin(arg)._eval_rewrite_as_sec(arg)
1400         return cos_in_sec_form / sin_in_sec_form
1401 
1402     def _eval_rewrite_as_csc(self, arg):
1403         cos_in_csc_form = cos(arg)._eval_rewrite_as_csc(arg)
1404         sin_in_csc_form = sin(arg)._eval_rewrite_as_csc(arg)
1405         return cos_in_csc_form / sin_in_csc_form
1406 
1407     def _eval_rewrite_as_pow(self, arg):
1408         y = self.rewrite(cos).rewrite(pow)
1409         if y.has(cos):
1410             return None
1411         return y
1412 
1413     def _eval_rewrite_as_sqrt(self, arg):
1414         y = self.rewrite(cos).rewrite(sqrt)
1415         if y.has(cos):
1416             return None
1417         return y
1418 
1419     def _eval_as_leading_term(self, x):
1420         from sympy import Order
1421         arg = self.args[0].as_leading_term(x)
1422 
1423         if x in arg.free_symbols and Order(1, x).contains(arg):
1424             return 1/arg
1425         else:
1426             return self.func(arg)
1427 
1428     def _eval_is_real(self):
1429         return self.args[0].is_real
1430 
1431     def _eval_expand_trig(self, **hints):
1432         from sympy import im, re
1433         arg = self.args[0]
1434         x = None
1435         if arg.is_Add:
1436             from sympy import symmetric_poly
1437             n = len(arg.args)
1438             CX = []
1439             for x in arg.args:
1440                 cx = cot(x, evaluate=False)._eval_expand_trig()
1441                 CX.append(cx)
1442 
1443             Yg = numbered_symbols('Y')
1444             Y = [ next(Yg) for i in range(n) ]
1445 
1446             p = [0, 0]
1447             for i in range(n, -1, -1):
1448                 p[(n - i) % 2] += symmetric_poly(i, Y)*(-1)**(((n - i) % 4)//2)
1449             return (p[0]/p[1]).subs(list(zip(Y, CX)))
1450         else:
1451             coeff, terms = arg.as_coeff_Mul(rational=True)
1452             if coeff.is_Integer and coeff > 1:
1453                 I = S.ImaginaryUnit
1454                 z = Symbol('dummy', real=True)
1455                 P = ((z + I)**coeff).expand()
1456                 return (re(P)/im(P)).subs([(z, cot(terms))])
1457         return cot(arg)
1458 
1459     def _eval_is_finite(self):
1460         arg = self.args[0]
1461         if arg.is_imaginary:
1462             return True
1463 
1464     def _eval_subs(self, old, new):
1465         if self == old:
1466             return new
1467         arg = self.args[0]
1468         argnew = arg.subs(old, new)
1469         if arg != argnew and (argnew/S.Pi).is_integer:
1470             return S.ComplexInfinity
1471         return cot(argnew)
1472 
1473 
1474 class ReciprocalTrigonometricFunction(TrigonometricFunction):
1475     """Base class for reciprocal functions of trigonometric functions. """
1476 
1477     _reciprocal_of = None       # mandatory, to be defined in subclass
1478 
1479     # _is_even and _is_odd are used for correct evaluation of csc(-x), sec(-x)
1480     # TODO refactor into TrigonometricFunction common parts of
1481     # trigonometric functions eval() like even/odd, func(x+2*k*pi), etc.
1482     _is_even = None  # optional, to be defined in subclass
1483     _is_odd = None   # optional, to be defined in subclass
1484 
1485     @classmethod
1486     def eval(cls, arg):
1487         if arg.could_extract_minus_sign():
1488             if cls._is_even:
1489                 return cls(-arg)
1490             if cls._is_odd:
1491                 return -cls(-arg)
1492 
1493         pi_coeff = _pi_coeff(arg)
1494         if (pi_coeff is not None
1495             and not (2*pi_coeff).is_integer
1496             and pi_coeff.is_Rational):
1497                 q = pi_coeff.q
1498                 p = pi_coeff.p % (2*q)
1499                 if p > q:
1500                     narg = (pi_coeff - 1)*S.Pi
1501                     return -cls(narg)
1502                 if 2*p > q:
1503                     narg = (1 - pi_coeff)*S.Pi
1504                     if cls._is_odd:
1505                         return cls(narg)
1506                     elif cls._is_even:
1507                         return -cls(narg)
1508 
1509         t = cls._reciprocal_of.eval(arg)
1510         if hasattr(arg, 'inverse') and arg.inverse() == cls:
1511             return arg.args[0]
1512         return 1/t if t != None else t
1513 
1514     def _call_reciprocal(self, method_name, *args, **kwargs):
1515         # Calls method_name on _reciprocal_of
1516         o = self._reciprocal_of(self.args[0])
1517         return getattr(o, method_name)(*args, **kwargs)
1518 
1519     def _calculate_reciprocal(self, method_name, *args, **kwargs):
1520         # If calling method_name on _reciprocal_of returns a value != None
1521         # then return the reciprocal of that value
1522         t = self._call_reciprocal(method_name, *args, **kwargs)
1523         return 1/t if t != None else t
1524 
1525     def _rewrite_reciprocal(self, method_name, arg):
1526         # Special handling for rewrite functions. If reciprocal rewrite returns
1527         # unmodified expression, then return None
1528         t = self._call_reciprocal(method_name, arg)
1529         if t != None and t != self._reciprocal_of(arg):
1530             return 1/t
1531 
1532     def _period(self, symbol):
1533         f = self.args[0]
1534         return self._reciprocal_of(f).period(symbol)
1535 
1536     def fdiff(self, argindex=1):
1537         return -self._calculate_reciprocal("fdiff", argindex)/self**2
1538 
1539     def _eval_rewrite_as_exp(self, arg):
1540         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
1541 
1542     def _eval_rewrite_as_Pow(self, arg):
1543         return self._rewrite_reciprocal("_eval_rewrite_as_Pow", arg)
1544 
1545     def _eval_rewrite_as_sin(self, arg):
1546         return self._rewrite_reciprocal("_eval_rewrite_as_sin", arg)
1547 
1548     def _eval_rewrite_as_cos(self, arg):
1549         return self._rewrite_reciprocal("_eval_rewrite_as_cos", arg)
1550 
1551     def _eval_rewrite_as_tan(self, arg):
1552         return self._rewrite_reciprocal("_eval_rewrite_as_tan", arg)
1553 
1554     def _eval_rewrite_as_pow(self, arg):
1555         return self._rewrite_reciprocal("_eval_rewrite_as_pow", arg)
1556 
1557     def _eval_rewrite_as_sqrt(self, arg):
1558         return self._rewrite_reciprocal("_eval_rewrite_as_sqrt", arg)
1559 
1560     def _eval_conjugate(self):
1561         return self.func(self.args[0].conjugate())
1562 
1563     def as_real_imag(self, deep=True, **hints):
1564         return (1/self._reciprocal_of(self.args[0])).as_real_imag(deep,
1565                                                                   **hints)
1566 
1567     def _eval_expand_trig(self, **hints):
1568         return self._calculate_reciprocal("_eval_expand_trig", **hints)
1569 
1570     def _eval_is_real(self):
1571         return self._reciprocal_of(self.args[0])._eval_is_real()
1572 
1573     def _eval_as_leading_term(self, x):
1574         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
1575 
1576     def _eval_is_finite(self):
1577         return (1/self._reciprocal_of(self.args[0])).is_finite
1578 
1579     def _eval_nseries(self, x, n, logx):
1580         return (1/self._reciprocal_of(self.args[0]))._eval_nseries(x, n, logx)
1581 
1582 
1583 class sec(ReciprocalTrigonometricFunction):
1584     """
1585     The secant function.
1586 
1587     Returns the secant of x (measured in radians).
1588 
1589     Notes
1590     =====
1591 
1592     See :func:`sin` for notes about automatic evaluation.
1593 
1594     Examples
1595     ========
1596 
1597     >>> from sympy import sec
1598     >>> from sympy.abc import x
1599     >>> sec(x**2).diff(x)
1600     2*x*tan(x**2)*sec(x**2)
1601     >>> sec(1).diff(x)
1602     0
1603 
1604     See Also
1605     ========
1606 
1607     sin, csc, cos, tan, cot
1608     asin, acsc, acos, asec, atan, acot, atan2
1609 
1610     References
1611     ==========
1612 
1613     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1614     .. [2] http://dlmf.nist.gov/4.14
1615     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sec
1616     """
1617 
1618     _reciprocal_of = cos
1619     _is_even = True
1620 
1621     def period(self, symbol=None):
1622         return self._period(symbol)
1623 
1624     def _eval_rewrite_as_cot(self, arg):
1625         cot_half_sq = cot(arg/2)**2
1626         return (cot_half_sq + 1)/(cot_half_sq - 1)
1627 
1628     def _eval_rewrite_as_cos(self, arg):
1629         return (1/cos(arg))
1630 
1631     def _eval_rewrite_as_sincos(self, arg):
1632         return sin(arg)/(cos(arg)*sin(arg))
1633 
1634     def _eval_rewrite_as_sin(self, arg):
1635         return (1 / cos(arg)._eval_rewrite_as_sin(arg))
1636 
1637     def _eval_rewrite_as_tan(self, arg):
1638         return (1 / cos(arg)._eval_rewrite_as_tan(arg))
1639 
1640     def _eval_rewrite_as_csc(self, arg):
1641         return csc(pi / 2 - arg, evaluate=False)
1642 
1643     def fdiff(self, argindex=1):
1644         if argindex == 1:
1645             return tan(self.args[0])*sec(self.args[0])
1646         else:
1647             raise ArgumentIndexError(self, argindex)
1648 
1649     @staticmethod
1650     @cacheit
1651     def taylor_term(n, x, *previous_terms):
1652         # Reference Formula:
1653         # http://functions.wolfram.com/ElementaryFunctions/Sec/06/01/02/01/
1654         from sympy.functions.combinatorial.numbers import euler
1655         if n < 0 or n % 2 == 1:
1656             return S.Zero
1657         else:
1658             x = sympify(x)
1659             k = n//2
1660             return (-1)**k*euler(2*k)/factorial(2*k)*x**(2*k)
1661 
1662 
1663 class csc(ReciprocalTrigonometricFunction):
1664     """
1665     The cosecant function.
1666 
1667     Returns the cosecant of x (measured in radians).
1668 
1669     Notes
1670     =====
1671 
1672     See :func:`sin` for notes about automatic evaluation.
1673 
1674     Examples
1675     ========
1676 
1677     >>> from sympy import csc
1678     >>> from sympy.abc import x
1679     >>> csc(x**2).diff(x)
1680     -2*x*cot(x**2)*csc(x**2)
1681     >>> csc(1).diff(x)
1682     0
1683 
1684     See Also
1685     ========
1686 
1687     sin, cos, sec, tan, cot
1688     asin, acsc, acos, asec, atan, acot, atan2
1689 
1690     References
1691     ==========
1692 
1693     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1694     .. [2] http://dlmf.nist.gov/4.14
1695     .. [3] http://functions.wolfram.com/ElementaryFunctions/Csc
1696     """
1697 
1698     _reciprocal_of = sin
1699     _is_odd = True
1700 
1701     def period(self, symbol=None):
1702         return self._period(symbol)
1703 
1704     def _eval_rewrite_as_sin(self, arg):
1705         return (1/sin(arg))
1706 
1707     def _eval_rewrite_as_sincos(self, arg):
1708         return cos(arg)/(sin(arg)*cos(arg))
1709 
1710     def _eval_rewrite_as_cot(self, arg):
1711         cot_half = cot(arg/2)
1712         return (1 + cot_half**2)/(2*cot_half)
1713 
1714     def _eval_rewrite_as_cos(self, arg):
1715         return (1 / sin(arg)._eval_rewrite_as_cos(arg))
1716 
1717     def _eval_rewrite_as_sec(self, arg):
1718         return sec(pi / 2 - arg, evaluate=False)
1719 
1720     def _eval_rewrite_as_tan(self, arg):
1721         return (1 / sin(arg)._eval_rewrite_as_tan(arg))
1722 
1723     def fdiff(self, argindex=1):
1724         if argindex == 1:
1725             return -cot(self.args[0])*csc(self.args[0])
1726         else:
1727             raise ArgumentIndexError(self, argindex)
1728 
1729     @staticmethod
1730     @cacheit
1731     def taylor_term(n, x, *previous_terms):
1732         from sympy import bernoulli
1733         if n == 0:
1734             return 1/sympify(x)
1735         elif n < 0 or n % 2 == 0:
1736             return S.Zero
1737         else:
1738             x = sympify(x)
1739             k = n//2 + 1
1740             return ((-1)**(k - 1)*2*(2**(2*k - 1) - 1)*
1741                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))
1742 
1743 
1744 class sinc(TrigonometricFunction):
1745     r"""Represents unnormalized sinc function
1746 
1747     Examples
1748     ========
1749 
1750     >>> from sympy import sinc, oo, jn, Product, Symbol
1751     >>> from sympy.abc import x
1752     >>> sinc(x)
1753     sinc(x)
1754 
1755     * Automated Evaluation
1756 
1757     >>> sinc(0)
1758     1
1759     >>> sinc(oo)
1760     0
1761 
1762     * Differentiation
1763 
1764     >>> sinc(x).diff()
1765     (x*cos(x) - sin(x))/x**2
1766 
1767     * Series Expansion
1768 
1769     >>> sinc(x).series()
1770     1 - x**2/6 + x**4/120 + O(x**6)
1771 
1772     * As zero'th order spherical Bessel Function
1773 
1774     >>> sinc(x).rewrite(jn)
1775     jn(0, x)
1776 
1777     References
1778     ==========
1779 
1780     .. [1] http://en.wikipedia.org/wiki/Sinc_function
1781 
1782     """
1783 
1784     def fdiff(self, argindex=1):
1785         x = self.args[0]
1786         if argindex == 1:
1787             return (x*cos(x) - sin(x)) / x**2
1788         else:
1789             raise ArgumentIndexError(self, argindex)
1790 
1791     @classmethod
1792     def eval(cls, arg):
1793         if arg.is_zero:
1794             return S.One
1795         if arg.is_Number:
1796             if arg in [S.Infinity, -S.Infinity]:
1797                 return S.Zero
1798             elif arg is S.NaN:
1799                 return S.NaN
1800 
1801         if arg is S.ComplexInfinity:
1802             return S.NaN
1803 
1804         if arg.could_extract_minus_sign():
1805             return cls(-arg)
1806 
1807         pi_coeff = _pi_coeff(arg)
1808         if pi_coeff is not None:
1809             if pi_coeff.is_integer:
1810                 if fuzzy_not(arg.is_zero):
1811                     return S.Zero
1812             elif (2*pi_coeff).is_integer:
1813                 return S.NegativeOne**(pi_coeff - S.Half) / arg
1814 
1815     def _eval_nseries(self, x, n, logx):
1816         x = self.args[0]
1817         return (sin(x)/x)._eval_nseries(x, n, logx)
1818 
1819     def _eval_rewrite_as_jn(self, arg):
1820         from sympy.functions.special.bessel import jn
1821         return jn(0, arg)
1822 
1823     def _eval_rewrite_as_sin(self, arg):
1824         return sin(arg) / arg
1825 
1826 
1827 ###############################################################################
1828 ########################### TRIGONOMETRIC INVERSES ############################
1829 ###############################################################################
1830 
1831 
1832 class InverseTrigonometricFunction(Function):
1833     """Base class for inverse trigonometric functions."""
1834 
1835     pass
1836 
1837 
1838 class asin(InverseTrigonometricFunction):
1839     """
1840     The inverse sine function.
1841 
1842     Returns the arcsine of x in radians.
1843 
1844     Notes
1845     =====
1846 
1847     asin(x) will evaluate automatically in the cases oo, -oo, 0, 1,
1848     -1 and for some instances when the result is a rational multiple
1849     of pi (see the eval class method).
1850 
1851     Examples
1852     ========
1853 
1854     >>> from sympy import asin, oo, pi
1855     >>> asin(1)
1856     pi/2
1857     >>> asin(-1)
1858     -pi/2
1859 
1860     See Also
1861     ========
1862 
1863     sin, csc, cos, sec, tan, cot
1864     acsc, acos, asec, atan, acot, atan2
1865 
1866     References
1867     ==========
1868 
1869     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
1870     .. [2] http://dlmf.nist.gov/4.23
1871     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSin
1872     """
1873 
1874     def fdiff(self, argindex=1):
1875         if argindex == 1:
1876             return 1/sqrt(1 - self.args[0]**2)
1877         else:
1878             raise ArgumentIndexError(self, argindex)
1879 
1880     def _eval_is_rational(self):
1881         s = self.func(*self.args)
1882         if s.func == self.func:
1883             if s.args[0].is_rational:
1884                 return False
1885         else:
1886             return s.is_rational
1887 
1888     def _eval_is_positive(self):
1889         if self.args[0].is_positive:
1890             return (self.args[0] - 1).is_negative
1891         if self.args[0].is_negative:
1892             return not (self.args[0] + 1).is_positive
1893 
1894     @classmethod
1895     def eval(cls, arg):
1896         if arg.is_Number:
1897             if arg is S.NaN:
1898                 return S.NaN
1899             elif arg is S.Infinity:
1900                 return S.NegativeInfinity * S.ImaginaryUnit
1901             elif arg is S.NegativeInfinity:
1902                 return S.Infinity * S.ImaginaryUnit
1903             elif arg is S.Zero:
1904                 return S.Zero
1905             elif arg is S.One:
1906                 return S.Pi / 2
1907             elif arg is S.NegativeOne:
1908                 return -S.Pi / 2
1909 
1910         if arg.could_extract_minus_sign():
1911             return -cls(-arg)
1912 
1913         if arg.is_number:
1914             cst_table = {
1915                 sqrt(3)/2: 3,
1916                 -sqrt(3)/2: -3,
1917                 sqrt(2)/2: 4,
1918                 -sqrt(2)/2: -4,
1919                 1/sqrt(2): 4,
1920                 -1/sqrt(2): -4,
1921                 sqrt((5 - sqrt(5))/8): 5,
1922                 -sqrt((5 - sqrt(5))/8): -5,
1923                 S.Half: 6,
1924                 -S.Half: -6,
1925                 sqrt(2 - sqrt(2))/2: 8,
1926                 -sqrt(2 - sqrt(2))/2: -8,
1927                 (sqrt(5) - 1)/4: 10,
1928                 (1 - sqrt(5))/4: -10,
1929                 (sqrt(3) - 1)/sqrt(2**3): 12,
1930                 (1 - sqrt(3))/sqrt(2**3): -12,
1931                 (sqrt(5) + 1)/4: S(10)/3,
1932                 -(sqrt(5) + 1)/4: -S(10)/3
1933             }
1934 
1935             if arg in cst_table:
1936                 return S.Pi / cst_table[arg]
1937 
1938         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1939         if i_coeff is not None:
1940             return S.ImaginaryUnit * asinh(i_coeff)
1941 
1942     @staticmethod
1943     @cacheit
1944     def taylor_term(n, x, *previous_terms):
1945         if n < 0 or n % 2 == 0:
1946             return S.Zero
1947         else:
1948             x = sympify(x)
1949             if len(previous_terms) >= 2 and n > 2:
1950                 p = previous_terms[-2]
1951                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1952             else:
1953                 k = (n - 1) // 2
1954                 R = RisingFactorial(S.Half, k)
1955                 F = factorial(k)
1956                 return R / F * x**n / n
1957 
1958     def _eval_as_leading_term(self, x):
1959         from sympy import Order
1960         arg = self.args[0].as_leading_term(x)
1961 
1962         if x in arg.free_symbols and Order(1, x).contains(arg):
1963             return arg
1964         else:
1965             return self.func(arg)
1966 
1967     def _eval_rewrite_as_acos(self, x):
1968         return S.Pi/2 - acos(x)
1969 
1970     def _eval_rewrite_as_atan(self, x):
1971         return 2*atan(x/(1 + sqrt(1 - x**2)))
1972 
1973     def _eval_rewrite_as_log(self, x):
1974         return -S.ImaginaryUnit*log(S.ImaginaryUnit*x + sqrt(1 - x**2))
1975 
1976     def _eval_rewrite_as_acot(self, arg):
1977         return 2*acot((1 + sqrt(1 - arg**2))/arg)
1978 
1979     def _eval_rewrite_as_asec(self, arg):
1980         return S.Pi/2 - asec(1/arg)
1981 
1982     def _eval_rewrite_as_acsc(self, arg):
1983         return acsc(1/arg)
1984 
1985     def _eval_is_real(self):
1986         x = self.args[0]
1987         return x.is_real and (1 - abs(x)).is_nonnegative
1988 
1989     def inverse(self, argindex=1):
1990         """
1991         Returns the inverse of this function.
1992         """
1993         return sin
1994 
1995 
1996 class acos(InverseTrigonometricFunction):
1997     """
1998     The inverse cosine function.
1999 
2000     Returns the arc cosine of x (measured in radians).
2001 
2002     Notes
2003     =====
2004 
2005     ``acos(x)`` will evaluate automatically in the cases
2006     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
2007 
2008     ``acos(zoo)`` evaluates to ``zoo``
2009     (see note in :py:class`sympy.functions.elementary.trigonometric.asec`)
2010 
2011     Examples
2012     ========
2013 
2014     >>> from sympy import acos, oo, pi
2015     >>> acos(1)
2016     0
2017     >>> acos(0)
2018     pi/2
2019     >>> acos(oo)
2020     oo*I
2021 
2022     See Also
2023     ========
2024 
2025     sin, csc, cos, sec, tan, cot
2026     asin, acsc, asec, atan, acot, atan2
2027 
2028     References
2029     ==========
2030 
2031     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2032     .. [2] http://dlmf.nist.gov/4.23
2033     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCos
2034     """
2035 
2036     def fdiff(self, argindex=1):
2037         if argindex == 1:
2038             return -1/sqrt(1 - self.args[0]**2)
2039         else:
2040             raise ArgumentIndexError(self, argindex)
2041 
2042     def _eval_is_rational(self):
2043         s = self.func(*self.args)
2044         if s.func == self.func:
2045             if s.args[0].is_rational:
2046                 return False
2047         else:
2048             return s.is_rational
2049 
2050     def _eval_is_positive(self):
2051         x = self.args[0]
2052         return (1 - abs(x)).is_nonnegative
2053 
2054     @classmethod
2055     def eval(cls, arg):
2056         if arg.is_Number:
2057             if arg is S.NaN:
2058                 return S.NaN
2059             elif arg is S.Infinity:
2060                 return S.Infinity * S.ImaginaryUnit
2061             elif arg is S.NegativeInfinity:
2062                 return S.NegativeInfinity * S.ImaginaryUnit
2063             elif arg is S.Zero:
2064                 return S.Pi / 2
2065             elif arg is S.One:
2066                 return S.Zero
2067             elif arg is S.NegativeOne:
2068                 return S.Pi
2069 
2070         if arg is S.ComplexInfinity:
2071             return S.ComplexInfinity
2072 
2073         if arg.is_number:
2074             cst_table = {
2075                 S.Half: S.Pi/3,
2076                 -S.Half: 2*S.Pi/3,
2077                 sqrt(2)/2: S.Pi/4,
2078                 -sqrt(2)/2: 3*S.Pi/4,
2079                 1/sqrt(2): S.Pi/4,
2080                 -1/sqrt(2): 3*S.Pi/4,
2081                 sqrt(3)/2: S.Pi/6,
2082                 -sqrt(3)/2: 5*S.Pi/6,
2083             }
2084 
2085             if arg in cst_table:
2086                 return cst_table[arg]
2087 
2088     @staticmethod
2089     @cacheit
2090     def taylor_term(n, x, *previous_terms):
2091         if n == 0:
2092             return S.Pi / 2
2093         elif n < 0 or n % 2 == 0:
2094             return S.Zero
2095         else:
2096             x = sympify(x)
2097             if len(previous_terms) >= 2 and n > 2:
2098                 p = previous_terms[-2]
2099                 return p * (n - 2)**2/(n*(n - 1)) * x**2
2100             else:
2101                 k = (n - 1) // 2
2102                 R = RisingFactorial(S.Half, k)
2103                 F = factorial(k)
2104                 return -R / F * x**n / n
2105 
2106     def _eval_as_leading_term(self, x):
2107         from sympy import Order
2108         arg = self.args[0].as_leading_term(x)
2109 
2110         if x in arg.free_symbols and Order(1, x).contains(arg):
2111             return arg
2112         else:
2113             return self.func(arg)
2114 
2115     def _eval_is_real(self):
2116         x = self.args[0]
2117         return x.is_real and (1 - abs(x)).is_nonnegative
2118 
2119     def _eval_rewrite_as_log(self, x):
2120         return S.Pi/2 + S.ImaginaryUnit * \
2121             log(S.ImaginaryUnit * x + sqrt(1 - x**2))
2122 
2123     def _eval_rewrite_as_asin(self, x):
2124         return S.Pi/2 - asin(x)
2125 
2126     def _eval_rewrite_as_atan(self, x):
2127         return atan(sqrt(1 - x**2)/x) + (S.Pi/2)*(1 - x*sqrt(1/x**2))
2128 
2129     def inverse(self, argindex=1):
2130         """
2131         Returns the inverse of this function.
2132         """
2133         return cos
2134 
2135     def _eval_rewrite_as_acot(self, arg):
2136         return S.Pi/2 - 2*acot((1 + sqrt(1 - arg**2))/arg)
2137 
2138     def _eval_rewrite_as_asec(self, arg):
2139         return asec(1/arg)
2140 
2141     def _eval_rewrite_as_acsc(self, arg):
2142         return S.Pi/2 - acsc(1/arg)
2143 
2144     def _eval_conjugate(self):
2145         z = self.args[0]
2146         r = self.func(self.args[0].conjugate())
2147         if z.is_real is False:
2148             return r
2149         elif z.is_real and (z + 1).is_nonnegative and (z - 1).is_nonpositive:
2150             return r
2151 
2152 
2153 class atan(InverseTrigonometricFunction):
2154     """
2155     The inverse tangent function.
2156 
2157     Returns the arc tangent of x (measured in radians).
2158 
2159     Notes
2160     =====
2161 
2162     atan(x) will evaluate automatically in the cases
2163     oo, -oo, 0, 1, -1.
2164 
2165     Examples
2166     ========
2167 
2168     >>> from sympy import atan, oo, pi
2169     >>> atan(0)
2170     0
2171     >>> atan(1)
2172     pi/4
2173     >>> atan(oo)
2174     pi/2
2175 
2176     See Also
2177     ========
2178 
2179     sin, csc, cos, sec, tan, cot
2180     asin, acsc, acos, asec, acot, atan2
2181 
2182     References
2183     ==========
2184 
2185     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2186     .. [2] http://dlmf.nist.gov/4.23
2187     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan
2188     """
2189 
2190     def fdiff(self, argindex=1):
2191         if argindex == 1:
2192             return 1/(1 + self.args[0]**2)
2193         else:
2194             raise ArgumentIndexError(self, argindex)
2195 
2196     def _eval_is_rational(self):
2197         s = self.func(*self.args)
2198         if s.func == self.func:
2199             if s.args[0].is_rational:
2200                 return False
2201         else:
2202             return s.is_rational
2203 
2204     def _eval_is_positive(self):
2205         return self.args[0].is_positive
2206 
2207     def _eval_is_nonnegative(self):
2208         return self.args[0].is_nonnegative
2209 
2210     @classmethod
2211     def eval(cls, arg):
2212         if arg.is_Number:
2213             if arg is S.NaN:
2214                 return S.NaN
2215             elif arg is S.Infinity:
2216                 return S.Pi / 2
2217             elif arg is S.NegativeInfinity:
2218                 return -S.Pi / 2
2219             elif arg is S.Zero:
2220                 return S.Zero
2221             elif arg is S.One:
2222                 return S.Pi / 4
2223             elif arg is S.NegativeOne:
2224                 return -S.Pi / 4
2225         if arg.could_extract_minus_sign():
2226             return -cls(-arg)
2227 
2228         if arg.is_number:
2229             cst_table = {
2230                 sqrt(3)/3: 6,
2231                 -sqrt(3)/3: -6,
2232                 1/sqrt(3): 6,
2233                 -1/sqrt(3): -6,
2234                 sqrt(3): 3,
2235                 -sqrt(3): -3,
2236                 (1 + sqrt(2)): S(8)/3,
2237                 -(1 + sqrt(2)): S(8)/3,
2238                 (sqrt(2) - 1): 8,
2239                 (1 - sqrt(2)): -8,
2240                 sqrt((5 + 2*sqrt(5))): S(5)/2,
2241                 -sqrt((5 + 2*sqrt(5))): -S(5)/2,
2242                 (2 - sqrt(3)): 12,
2243                 -(2 - sqrt(3)): -12
2244             }
2245 
2246             if arg in cst_table:
2247                 return S.Pi / cst_table[arg]
2248 
2249         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2250         if i_coeff is not None:
2251             return S.ImaginaryUnit * atanh(i_coeff)
2252 
2253     @staticmethod
2254     @cacheit
2255     def taylor_term(n, x, *previous_terms):
2256         if n < 0 or n % 2 == 0:
2257             return S.Zero
2258         else:
2259             x = sympify(x)
2260             return (-1)**((n - 1)//2) * x**n / n
2261 
2262     def _eval_as_leading_term(self, x):
2263         from sympy import Order
2264         arg = self.args[0].as_leading_term(x)
2265 
2266         if x in arg.free_symbols and Order(1, x).contains(arg):
2267             return arg
2268         else:
2269             return self.func(arg)
2270 
2271     def _eval_is_real(self):
2272         return self.args[0].is_real
2273 
2274     def _eval_rewrite_as_log(self, x):
2275         return S.ImaginaryUnit/2 * (log(S(1) - S.ImaginaryUnit * x)
2276             - log(S(1) + S.ImaginaryUnit * x))
2277 
2278     def _eval_aseries(self, n, args0, x, logx):
2279         if args0[0] == S.Infinity:
2280             return (S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2281         elif args0[0] == S.NegativeInfinity:
2282             return (-S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2283         else:
2284             return super(atan, self)._eval_aseries(n, args0, x, logx)
2285 
2286     def inverse(self, argindex=1):
2287         """
2288         Returns the inverse of this function.
2289         """
2290         return tan
2291 
2292     def _eval_rewrite_as_asin(self, arg):
2293         return sqrt(arg**2)/arg*(S.Pi/2 - asin(1/sqrt(1 + arg**2)))
2294 
2295     def _eval_rewrite_as_acos(self, arg):
2296         return sqrt(arg**2)/arg*acos(1/sqrt(1 + arg**2))
2297 
2298     def _eval_rewrite_as_acot(self, arg):
2299         return acot(1/arg)
2300 
2301     def _eval_rewrite_as_asec(self, arg):
2302         return sqrt(arg**2)/arg*asec(sqrt(1 + arg**2))
2303 
2304     def _eval_rewrite_as_acsc(self, arg):
2305         return sqrt(arg**2)/arg*(S.Pi/2 - acsc(sqrt(1 + arg**2)))
2306 
2307 
2308 class acot(InverseTrigonometricFunction):
2309     """
2310     The inverse cotangent function.
2311 
2312     Returns the arc cotangent of x (measured in radians).
2313 
2314     See Also
2315     ========
2316 
2317     sin, csc, cos, sec, tan, cot
2318     asin, acsc, acos, asec, atan, atan2
2319 
2320     References
2321     ==========
2322 
2323     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2324     .. [2] http://dlmf.nist.gov/4.23
2325     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCot
2326     """
2327 
2328     def fdiff(self, argindex=1):
2329         if argindex == 1:
2330             return -1 / (1 + self.args[0]**2)
2331         else:
2332             raise ArgumentIndexError(self, argindex)
2333 
2334     def _eval_is_rational(self):
2335         s = self.func(*self.args)
2336         if s.func == self.func:
2337             if s.args[0].is_rational:
2338                 return False
2339         else:
2340             return s.is_rational
2341 
2342     def _eval_is_positive(self):
2343         return self.args[0].is_real
2344 
2345     @classmethod
2346     def eval(cls, arg):
2347         if arg.is_Number:
2348             if arg is S.NaN:
2349                 return S.NaN
2350             elif arg is S.Infinity:
2351                 return S.Zero
2352             elif arg is S.NegativeInfinity:
2353                 return S.Zero
2354             elif arg is S.Zero:
2355                 return S.Pi/ 2
2356             elif arg is S.One:
2357                 return S.Pi / 4
2358             elif arg is S.NegativeOne:
2359                 return -S.Pi / 4
2360 
2361         if arg.could_extract_minus_sign():
2362             return -cls(-arg)
2363 
2364         if arg.is_number:
2365             cst_table = {
2366                 sqrt(3)/3: 3,
2367                 -sqrt(3)/3: -3,
2368                 1/sqrt(3): 3,
2369                 -1/sqrt(3): -3,
2370                 sqrt(3): 6,
2371                 -sqrt(3): -6,
2372                 (1 + sqrt(2)): 8,
2373                 -(1 + sqrt(2)): -8,
2374                 (1 - sqrt(2)): -S(8)/3,
2375                 (sqrt(2) - 1): S(8)/3,
2376                 sqrt(5 + 2*sqrt(5)): 10,
2377                 -sqrt(5 + 2*sqrt(5)): -10,
2378                 (2 + sqrt(3)): 12,
2379                 -(2 + sqrt(3)): -12,
2380                 (2 - sqrt(3)): S(12)/5,
2381                 -(2 - sqrt(3)): -S(12)/5,
2382             }
2383 
2384             if arg in cst_table:
2385                 return S.Pi / cst_table[arg]
2386 
2387         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2388         if i_coeff is not None:
2389             return -S.ImaginaryUnit * acoth(i_coeff)
2390 
2391     @staticmethod
2392     @cacheit
2393     def taylor_term(n, x, *previous_terms):
2394         if n == 0:
2395             return S.Pi / 2  # FIX THIS
2396         elif n < 0 or n % 2 == 0:
2397             return S.Zero
2398         else:
2399             x = sympify(x)
2400             return (-1)**((n + 1)//2) * x**n / n
2401 
2402     def _eval_as_leading_term(self, x):
2403         from sympy import Order
2404         arg = self.args[0].as_leading_term(x)
2405 
2406         if x in arg.free_symbols and Order(1, x).contains(arg):
2407             return arg
2408         else:
2409             return self.func(arg)
2410 
2411     def _eval_is_real(self):
2412         return self.args[0].is_real
2413 
2414     def _eval_aseries(self, n, args0, x, logx):
2415         if args0[0] == S.Infinity:
2416             return (S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2417         elif args0[0] == S.NegativeInfinity:
2418             return (3*S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2419         else:
2420             return super(atan, self)._eval_aseries(n, args0, x, logx)
2421 
2422     def _eval_rewrite_as_log(self, x):
2423         return S.ImaginaryUnit/2 * (log(1 - S.ImaginaryUnit/x)
2424             - log(1 + S.ImaginaryUnit/x))
2425 
2426     def inverse(self, argindex=1):
2427         """
2428         Returns the inverse of this function.
2429         """
2430         return cot
2431 
2432     def _eval_rewrite_as_asin(self, arg):
2433         return (arg*sqrt(1/arg**2)*
2434                 (S.Pi/2 - asin(sqrt(-arg**2)/sqrt(-arg**2 - 1))))
2435 
2436     def _eval_rewrite_as_acos(self, arg):
2437         return arg*sqrt(1/arg**2)*acos(sqrt(-arg**2)/sqrt(-arg**2 - 1))
2438 
2439     def _eval_rewrite_as_atan(self, arg):
2440         return atan(1/arg)
2441 
2442     def _eval_rewrite_as_asec(self, arg):
2443         return arg*sqrt(1/arg**2)*asec(sqrt((1 + arg**2)/arg**2))
2444 
2445     def _eval_rewrite_as_acsc(self, arg):
2446         return arg*sqrt(1/arg**2)*(S.Pi/2 - acsc(sqrt((1 + arg**2)/arg**2)))
2447 
2448 
2449 class asec(InverseTrigonometricFunction):
2450     r"""
2451     The inverse secant function.
2452 
2453     Returns the arc secant of x (measured in radians).
2454 
2455     Notes
2456     =====
2457 
2458     ``asec(x)`` will evaluate automatically in the cases
2459     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
2460 
2461     ``asec(x)`` has branch cut in the interval [-1, 1]. For complex arguments,
2462     it can be defined [4]_ as
2463 
2464     .. math::
2465         sec^{-1}(z) = -i*(log(\sqrt{1 - z^2} + 1) / z)
2466 
2467     At ``x = 0``, for positive branch cut, the limit evaluates to ``zoo``. For
2468     negative branch cut, the limit
2469 
2470     .. math::
2471         \lim_{z \to 0}-i*(log(-\sqrt{1 - z^2} + 1) / z)
2472 
2473     simplifies to :math:`-i*log(z/2 + O(z^3))` which ultimately evaluates to
2474     ``zoo``.
2475 
2476     As ``asex(x)`` = ``asec(1/x)``, a similar argument can be given for
2477     ``acos(x)``.
2478 
2479     Examples
2480     ========
2481 
2482     >>> from sympy import asec, oo, pi
2483     >>> asec(1)
2484     0
2485     >>> asec(-1)
2486     pi
2487 
2488     See Also
2489     ========
2490 
2491     sin, csc, cos, sec, tan, cot
2492     asin, acsc, acos, atan, acot, atan2
2493 
2494     References
2495     ==========
2496 
2497     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2498     .. [2] http://dlmf.nist.gov/4.23
2499     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSec
2500     .. [4] http://refrence.wolfram.com/language/ref/ArcSec.html
2501     """
2502 
2503     @classmethod
2504     def eval(cls, arg):
2505         if arg.is_zero:
2506             return S.ComplexInfinity
2507         if arg.is_Number:
2508             if arg is S.NaN:
2509                 return S.NaN
2510             elif arg is S.One:
2511                 return S.Zero
2512             elif arg is S.NegativeOne:
2513                 return S.Pi
2514         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2515             return S.Pi/2
2516 
2517     def fdiff(self, argindex=1):
2518         if argindex == 1:
2519             return 1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2520         else:
2521             raise ArgumentIndexError(self, argindex)
2522 
2523     def inverse(self, argindex=1):
2524         """
2525         Returns the inverse of this function.
2526         """
2527         return sec
2528 
2529     def _eval_as_leading_term(self, x):
2530         from sympy import Order
2531         arg = self.args[0].as_leading_term(x)
2532         if Order(1,x).contains(arg):
2533             return log(arg)
2534         else:
2535             return self.func(arg)
2536 
2537     def _eval_is_real(self):
2538         x = self.args[0]
2539         if x.is_real is False:
2540             return False
2541         return (x - 1).is_nonnegative or (-x - 1).is_nonnegative
2542 
2543     def _eval_rewrite_as_log(self, arg):
2544         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2545 
2546     def _eval_rewrite_as_asin(self, arg):
2547         return S.Pi/2 - asin(1/arg)
2548 
2549     def _eval_rewrite_as_acos(self, arg):
2550         return acos(1/arg)
2551 
2552     def _eval_rewrite_as_atan(self, arg):
2553         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*atan(arg + sqrt(arg**2 - 1)))
2554 
2555     def _eval_rewrite_as_acot(self, arg):
2556         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*acot(arg - sqrt(arg**2 - 1)))
2557 
2558     def _eval_rewrite_as_acsc(self, arg):
2559         return S.Pi/2 - acsc(arg)
2560 
2561 
2562 class acsc(InverseTrigonometricFunction):
2563     """
2564     The inverse cosecant function.
2565 
2566     Returns the arc cosecant of x (measured in radians).
2567 
2568     Notes
2569     =====
2570 
2571     acsc(x) will evaluate automatically in the cases
2572     oo, -oo, 0, 1, -1.
2573 
2574     Examples
2575     ========
2576 
2577     >>> from sympy import acsc, oo, pi
2578     >>> acsc(1)
2579     pi/2
2580     >>> acsc(-1)
2581     -pi/2
2582 
2583     See Also
2584     ========
2585 
2586     sin, csc, cos, sec, tan, cot
2587     asin, acos, asec, atan, acot, atan2
2588 
2589     References
2590     ==========
2591 
2592     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2593     .. [2] http://dlmf.nist.gov/4.23
2594     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsc
2595     """
2596 
2597     @classmethod
2598     def eval(cls, arg):
2599         if arg.is_Number:
2600             if arg is S.NaN:
2601                 return S.NaN
2602             elif arg is S.One:
2603                 return S.Pi/2
2604             elif arg is S.NegativeOne:
2605                 return -S.Pi/2
2606         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2607             return S.Zero
2608 
2609     def fdiff(self, argindex=1):
2610         if argindex == 1:
2611             return -1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2612         else:
2613             raise ArgumentIndexError(self, argindex)
2614 
2615     def inverse(self, argindex=1):
2616         """
2617         Returns the inverse of this function.
2618         """
2619         return csc
2620 
2621     def _eval_as_leading_term(self, x):
2622         from sympy import Order
2623         arg = self.args[0].as_leading_term(x)
2624         if Order(1,x).contains(arg):
2625             return log(arg)
2626         else:
2627             return self.func(arg)
2628 
2629     def _eval_rewrite_as_log(self, arg):
2630         return -S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2631 
2632     def _eval_rewrite_as_asin(self, arg):
2633         return asin(1/arg)
2634 
2635     def _eval_rewrite_as_acos(self, arg):
2636         return S.Pi/2 - acos(1/arg)
2637 
2638     def _eval_rewrite_as_atan(self, arg):
2639         return sqrt(arg**2)/arg*(S.Pi/2 - atan(sqrt(arg**2 - 1)))
2640 
2641     def _eval_rewrite_as_acot(self, arg):
2642         return sqrt(arg**2)/arg*(S.Pi/2 - acot(1/sqrt(arg**2 - 1)))
2643 
2644     def _eval_rewrite_as_asec(self, arg):
2645         return S.Pi/2 - asec(arg)
2646 
2647 
2648 class atan2(InverseTrigonometricFunction):
2649     r"""
2650     The function ``atan2(y, x)`` computes `\operatorname{atan}(y/x)` taking
2651     two arguments `y` and `x`.  Signs of both `y` and `x` are considered to
2652     determine the appropriate quadrant of `\operatorname{atan}(y/x)`.
2653     The range is `(-\pi, \pi]`. The complete definition reads as follows:
2654 
2655     .. math::
2656 
2657         \operatorname{atan2}(y, x) =
2658         \begin{cases}
2659           \arctan\left(\frac y x\right) & \qquad x > 0 \\
2660           \arctan\left(\frac y x\right) + \pi& \qquad y \ge 0 , x < 0 \\
2661           \arctan\left(\frac y x\right) - \pi& \qquad y < 0 , x < 0 \\
2662           +\frac{\pi}{2} & \qquad y > 0 , x = 0 \\
2663           -\frac{\pi}{2} & \qquad y < 0 , x = 0 \\
2664           \text{undefined} & \qquad y = 0, x = 0
2665         \end{cases}
2666 
2667     Attention: Note the role reversal of both arguments. The `y`-coordinate
2668     is the first argument and the `x`-coordinate the second.
2669 
2670     Examples
2671     ========
2672 
2673     Going counter-clock wise around the origin we find the
2674     following angles:
2675 
2676     >>> from sympy import atan2
2677     >>> atan2(0, 1)
2678     0
2679     >>> atan2(1, 1)
2680     pi/4
2681     >>> atan2(1, 0)
2682     pi/2
2683     >>> atan2(1, -1)
2684     3*pi/4
2685     >>> atan2(0, -1)
2686     pi
2687     >>> atan2(-1, -1)
2688     -3*pi/4
2689     >>> atan2(-1, 0)
2690     -pi/2
2691     >>> atan2(-1, 1)
2692     -pi/4
2693 
2694     which are all correct. Compare this to the results of the ordinary
2695     `\operatorname{atan}` function for the point `(x, y) = (-1, 1)`
2696 
2697     >>> from sympy import atan, S
2698     >>> atan(S(1) / -1)
2699     -pi/4
2700     >>> atan2(1, -1)
2701     3*pi/4
2702 
2703     where only the `\operatorname{atan2}` function reurns what we expect.
2704     We can differentiate the function with respect to both arguments:
2705 
2706     >>> from sympy import diff
2707     >>> from sympy.abc import x, y
2708     >>> diff(atan2(y, x), x)
2709     -y/(x**2 + y**2)
2710 
2711     >>> diff(atan2(y, x), y)
2712     x/(x**2 + y**2)
2713 
2714     We can express the `\operatorname{atan2}` function in terms of
2715     complex logarithms:
2716 
2717     >>> from sympy import log
2718     >>> atan2(y, x).rewrite(log)
2719     -I*log((x + I*y)/sqrt(x**2 + y**2))
2720 
2721     and in terms of `\operatorname(atan)`:
2722 
2723     >>> from sympy import atan
2724     >>> atan2(y, x).rewrite(atan)
2725     2*atan(y/(x + sqrt(x**2 + y**2)))
2726 
2727     but note that this form is undefined on the negative real axis.
2728 
2729     See Also
2730     ========
2731 
2732     sin, csc, cos, sec, tan, cot
2733     asin, acsc, acos, asec, atan, acot
2734 
2735     References
2736     ==========
2737 
2738     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2739     .. [2] http://en.wikipedia.org/wiki/Atan2
2740     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan2
2741     """
2742 
2743     @classmethod
2744     def eval(cls, y, x):
2745         from sympy import Heaviside, im, re
2746         if x is S.NegativeInfinity:
2747             if y.is_zero:
2748                 # Special case y = 0 because we define Heaviside(0) = 1/2
2749                 return S.Pi
2750             return 2*S.Pi*(Heaviside(re(y))) - S.Pi
2751         elif x is S.Infinity:
2752             return S.Zero
2753         elif x.is_imaginary and y.is_imaginary and x.is_number and y.is_number:
2754             x = im(x)
2755             y = im(y)
2756 
2757         if x.is_real and y.is_real:
2758             if x.is_positive:
2759                 return atan(y / x)
2760             elif x.is_negative:
2761                 if y.is_negative:
2762                     return atan(y / x) - S.Pi
2763                 elif y.is_nonnegative:
2764                     return atan(y / x) + S.Pi
2765             elif x.is_zero:
2766                 if y.is_positive:
2767                     return S.Pi/2
2768                 elif y.is_negative:
2769                     return -S.Pi/2
2770                 elif y.is_zero:
2771                     return S.NaN
2772         if y.is_zero and x.is_real and fuzzy_not(x.is_zero):
2773             return S.Pi * (S.One - Heaviside(x))
2774         if x.is_number and y.is_number:
2775             return -S.ImaginaryUnit*log(
2776                 (x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))
2777 
2778     def _eval_rewrite_as_log(self, y, x):
2779         return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y) / sqrt(x**2 + y**2))
2780 
2781     def _eval_rewrite_as_atan(self, y, x):
2782         return 2*atan(y / (sqrt(x**2 + y**2) + x))
2783 
2784     def _eval_rewrite_as_arg(self, y, x):
2785         from sympy import arg
2786         if x.is_real and y.is_real:
2787             return arg(x + y*S.ImaginaryUnit)
2788         I = S.ImaginaryUnit
2789         n = x + I*y
2790         d = x**2 + y**2
2791         return arg(n/sqrt(d)) - I*log(abs(n)/sqrt(abs(d)))
2792 
2793     def _eval_is_real(self):
2794         return self.args[0].is_real and self.args[1].is_real
2795 
2796     def _eval_conjugate(self):
2797         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
2798 
2799     def fdiff(self, argindex):
2800         y, x = self.args
2801         if argindex == 1:
2802             # Diff wrt y
2803             return x/(x**2 + y**2)
2804         elif argindex == 2:
2805             # Diff wrt x
2806             return -y/(x**2 + y**2)
2807         else:
2808             raise ArgumentIndexError(self, argindex)
2809 
2810     def _eval_evalf(self, prec):
2811         y, x = self.args
2812         if x.is_real and y.is_real:
2813             super(atan2, self)._eval_evalf(prec)

</code><intended_behavior>The evaluation and simplification logic should correctly handle complex arguments, avoiding incorrect transformations or assumptions about trigonometric and hyperbolic functions.</intended_behavior>, <file>sympy/functions/elementary/hyperbolic.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import S, sympify, cacheit
4 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
5 
6 from sympy.functions.elementary.miscellaneous import sqrt
7 
8 from sympy.functions.elementary.exponential import exp, log
9 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
10 
11 
12 def _rewrite_hyperbolics_as_exp(expr):
13     expr = sympify(expr)
14     return expr.xreplace(dict([(h, h.rewrite(exp))
15         for h in expr.atoms(HyperbolicFunction)]))
16 
17 
18 ###############################################################################
19 ########################### HYPERBOLIC FUNCTIONS ##############################
20 ###############################################################################
21 
22 
23 class HyperbolicFunction(Function):
24     """
25     Base class for hyperbolic functions.
26 
27     See Also
28     ========
29 
30     sinh, cosh, tanh, coth
31     """
32 
33     unbranched = True
34 
35 
36 class sinh(HyperbolicFunction):
37     r"""
38     The hyperbolic sine function, `\frac{e^x - e^{-x}}{2}`.
39 
40     * sinh(x) -> Returns the hyperbolic sine of x
41 
42     See Also
43     ========
44 
45     cosh, tanh, asinh
46     """
47 
48     def fdiff(self, argindex=1):
49         """
50         Returns the first derivative of this function.
51         """
52         if argindex == 1:
53             return cosh(self.args[0])
54         else:
55             raise ArgumentIndexError(self, argindex)
56 
57     def inverse(self, argindex=1):
58         """
59         Returns the inverse of this function.
60         """
61         return asinh
62 
63     @classmethod
64     def eval(cls, arg):
65         from sympy import sin
66 
67         arg = sympify(arg)
68 
69         if arg.is_Number:
70             if arg is S.NaN:
71                 return S.NaN
72             elif arg is S.Infinity:
73                 return S.Infinity
74             elif arg is S.NegativeInfinity:
75                 return S.NegativeInfinity
76             elif arg is S.Zero:
77                 return S.Zero
78             elif arg.is_negative:
79                 return -cls(-arg)
80         else:
81             if arg is S.ComplexInfinity:
82                 return S.NaN
83 
84             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
85 
86             if i_coeff is not None:
87                 return S.ImaginaryUnit * sin(i_coeff)
88             else:
89                 if _coeff_isneg(arg):
90                     return -cls(-arg)
91 
92             if arg.func == asinh:
93                 return arg.args[0]
94 
95             if arg.func == acosh:
96                 x = arg.args[0]
97                 return sqrt(x - 1) * sqrt(x + 1)
98 
99             if arg.func == atanh:
100                 x = arg.args[0]
101                 return x/sqrt(1 - x**2)
102 
103             if arg.func == acoth:
104                 x = arg.args[0]
105                 return 1/(sqrt(x - 1) * sqrt(x + 1))
106 
107     @staticmethod
108     @cacheit
109     def taylor_term(n, x, *previous_terms):
110         """
111         Returns the next term in the Taylor series expansion.
112         """
113         if n < 0 or n % 2 == 0:
114             return S.Zero
115         else:
116             x = sympify(x)
117 
118             if len(previous_terms) > 2:
119                 p = previous_terms[-2]
120                 return p * x**2 / (n*(n - 1))
121             else:
122                 return x**(n) / factorial(n)
123 
124     def _eval_conjugate(self):
125         return self.func(self.args[0].conjugate())
126 
127     def as_real_imag(self, deep=True, **hints):
128         """
129         Returns this function as a complex coordinate.
130         """
131         from sympy import cos, sin
132         if self.args[0].is_real:
133             if deep:
134                 hints['complex'] = False
135                 return (self.expand(deep, **hints), S.Zero)
136             else:
137                 return (self, S.Zero)
138         if deep:
139             re, im = self.args[0].expand(deep, **hints).as_real_imag()
140         else:
141             re, im = self.args[0].as_real_imag()
142         return (sinh(re)*cos(im), cosh(re)*sin(im))
143 
144     def _eval_expand_complex(self, deep=True, **hints):
145         re_part, im_part = self.as_real_imag(deep=deep, **hints)
146         return re_part + im_part*S.ImaginaryUnit
147 
148     def _eval_expand_trig(self, deep=True, **hints):
149         if deep:
150             arg = self.args[0].expand(deep, **hints)
151         else:
152             arg = self.args[0]
153         x = None
154         if arg.is_Add: # TODO, implement more if deep stuff here
155             x, y = arg.as_two_terms()
156         else:
157             coeff, terms = arg.as_coeff_Mul(rational=True)
158             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
159                 x = terms
160                 y = (coeff - 1)*x
161         if x is not None:
162             return (sinh(x)*cosh(y) + sinh(y)*cosh(x)).expand(trig=True)
163         return sinh(arg)
164 
165     def _eval_rewrite_as_tractable(self, arg):
166         return (exp(arg) - exp(-arg)) / 2
167 
168     def _eval_rewrite_as_exp(self, arg):
169         return (exp(arg) - exp(-arg)) / 2
170 
171     def _eval_rewrite_as_cosh(self, arg):
172         return -S.ImaginaryUnit*cosh(arg + S.Pi*S.ImaginaryUnit/2)
173 
174     def _eval_rewrite_as_tanh(self, arg):
175         tanh_half = tanh(S.Half*arg)
176         return 2*tanh_half/(1 - tanh_half**2)
177 
178     def _eval_rewrite_as_coth(self, arg):
179         coth_half = coth(S.Half*arg)
180         return 2*coth_half/(coth_half**2 - 1)
181 
182     def _eval_as_leading_term(self, x):
183         from sympy import Order
184         arg = self.args[0].as_leading_term(x)
185 
186         if x in arg.free_symbols and Order(1, x).contains(arg):
187             return arg
188         else:
189             return self.func(arg)
190 
191     def _eval_is_real(self):
192         return self.args[0].is_real
193 
194     def _eval_is_finite(self):
195         arg = self.args[0]
196         if arg.is_imaginary:
197             return True
198 
199 
200 class cosh(HyperbolicFunction):
201     r"""
202     The hyperbolic cosine function, `\frac{e^x + e^{-x}}{2}`.
203 
204     * cosh(x) -> Returns the hyperbolic cosine of x
205 
206     See Also
207     ========
208 
209     sinh, tanh, acosh
210     """
211 
212     def fdiff(self, argindex=1):
213         if argindex == 1:
214             return sinh(self.args[0])
215         else:
216             raise ArgumentIndexError(self, argindex)
217 
218     @classmethod
219     def eval(cls, arg):
220         from sympy import cos
221         arg = sympify(arg)
222 
223         if arg.is_Number:
224             if arg is S.NaN:
225                 return S.NaN
226             elif arg is S.Infinity:
227                 return S.Infinity
228             elif arg is S.NegativeInfinity:
229                 return S.Infinity
230             elif arg is S.Zero:
231                 return S.One
232             elif arg.is_negative:
233                 return cls(-arg)
234         else:
235             if arg is S.ComplexInfinity:
236                 return S.NaN
237 
238             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
239 
240             if i_coeff is not None:
241                 return cos(i_coeff)
242             else:
243                 if _coeff_isneg(arg):
244                     return cls(-arg)
245 
246             if arg.func == asinh:
247                 return sqrt(1 + arg.args[0]**2)
248 
249             if arg.func == acosh:
250                 return arg.args[0]
251 
252             if arg.func == atanh:
253                 return 1/sqrt(1 - arg.args[0]**2)
254 
255             if arg.func == acoth:
256                 x = arg.args[0]
257                 return x/(sqrt(x - 1) * sqrt(x + 1))
258 
259     @staticmethod
260     @cacheit
261     def taylor_term(n, x, *previous_terms):
262         if n < 0 or n % 2 == 1:
263             return S.Zero
264         else:
265             x = sympify(x)
266 
267             if len(previous_terms) > 2:
268                 p = previous_terms[-2]
269                 return p * x**2 / (n*(n - 1))
270             else:
271                 return x**(n)/factorial(n)
272 
273     def _eval_conjugate(self):
274         return self.func(self.args[0].conjugate())
275 
276     def as_real_imag(self, deep=True, **hints):
277         from sympy import cos, sin
278         if self.args[0].is_real:
279             if deep:
280                 hints['complex'] = False
281                 return (self.expand(deep, **hints), S.Zero)
282             else:
283                 return (self, S.Zero)
284         if deep:
285             re, im = self.args[0].expand(deep, **hints).as_real_imag()
286         else:
287             re, im = self.args[0].as_real_imag()
288 
289         return (cosh(re)*cos(im), sinh(re)*sin(im))
290 
291     def _eval_expand_complex(self, deep=True, **hints):
292         re_part, im_part = self.as_real_imag(deep=deep, **hints)
293         return re_part + im_part*S.ImaginaryUnit
294 
295     def _eval_expand_trig(self, deep=True, **hints):
296         if deep:
297             arg = self.args[0].expand(deep, **hints)
298         else:
299             arg = self.args[0]
300         x = None
301         if arg.is_Add: # TODO, implement more if deep stuff here
302             x, y = arg.as_two_terms()
303         else:
304             coeff, terms = arg.as_coeff_Mul(rational=True)
305             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
306                 x = terms
307                 y = (coeff - 1)*x
308         if x is not None:
309             return (cosh(x)*cosh(y) + sinh(x)*sinh(y)).expand(trig=True)
310         return cosh(arg)
311 
312     def _eval_rewrite_as_tractable(self, arg):
313         return (exp(arg) + exp(-arg)) / 2
314 
315     def _eval_rewrite_as_exp(self, arg):
316         return (exp(arg) + exp(-arg)) / 2
317 
318     def _eval_rewrite_as_sinh(self, arg):
319         return -S.ImaginaryUnit*sinh(arg + S.Pi*S.ImaginaryUnit/2)
320 
321     def _eval_rewrite_as_tanh(self, arg):
322         tanh_half = tanh(S.Half*arg)**2
323         return (1 + tanh_half)/(1 - tanh_half)
324 
325     def _eval_rewrite_as_coth(self, arg):
326         coth_half = coth(S.Half*arg)**2
327         return (coth_half + 1)/(coth_half - 1)
328 
329     def _eval_as_leading_term(self, x):
330         from sympy import Order
331         arg = self.args[0].as_leading_term(x)
332 
333         if x in arg.free_symbols and Order(1, x).contains(arg):
334             return S.One
335         else:
336             return self.func(arg)
337 
338     def _eval_is_real(self):
339         return self.args[0].is_real
340 
341     def _eval_is_finite(self):
342         arg = self.args[0]
343         if arg.is_imaginary:
344             return True
345 
346 
347 class tanh(HyperbolicFunction):
348     r"""
349     The hyperbolic tangent function, `\frac{\sinh(x)}{\cosh(x)}`.
350 
351     * tanh(x) -> Returns the hyperbolic tangent of x
352 
353     See Also
354     ========
355 
356     sinh, cosh, atanh
357     """
358 
359     def fdiff(self, argindex=1):
360         if argindex == 1:
361             return S.One - tanh(self.args[0])**2
362         else:
363             raise ArgumentIndexError(self, argindex)
364 
365     def inverse(self, argindex=1):
366         """
367         Returns the inverse of this function.
368         """
369         return atanh
370 
371     @classmethod
372     def eval(cls, arg):
373         from sympy import tan
374         arg = sympify(arg)
375 
376         if arg.is_Number:
377             if arg is S.NaN:
378                 return S.NaN
379             elif arg is S.Infinity:
380                 return S.One
381             elif arg is S.NegativeInfinity:
382                 return S.NegativeOne
383             elif arg is S.Zero:
384                 return S.Zero
385             elif arg.is_negative:
386                 return -cls(-arg)
387         else:
388             if arg is S.ComplexInfinity:
389                 return S.NaN
390 
391             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
392 
393             if i_coeff is not None:
394                 if _coeff_isneg(i_coeff):
395                     return -S.ImaginaryUnit * tan(-i_coeff)
396                 return S.ImaginaryUnit * tan(i_coeff)
397             else:
398                 if _coeff_isneg(arg):
399                     return -cls(-arg)
400 
401             if arg.func == asinh:
402                 x = arg.args[0]
403                 return x/sqrt(1 + x**2)
404 
405             if arg.func == acosh:
406                 x = arg.args[0]
407                 return sqrt(x - 1) * sqrt(x + 1) / x
408 
409             if arg.func == atanh:
410                 return arg.args[0]
411 
412             if arg.func == acoth:
413                 return 1/arg.args[0]
414 
415     @staticmethod
416     @cacheit
417     def taylor_term(n, x, *previous_terms):
418         from sympy import bernoulli
419         if n < 0 or n % 2 == 0:
420             return S.Zero
421         else:
422             x = sympify(x)
423 
424             a = 2**(n + 1)
425 
426             B = bernoulli(n + 1)
427             F = factorial(n + 1)
428 
429             return a*(a - 1) * B/F * x**n
430 
431     def _eval_conjugate(self):
432         return self.func(self.args[0].conjugate())
433 
434     def as_real_imag(self, deep=True, **hints):
435         from sympy import cos, sin
436         if self.args[0].is_real:
437             if deep:
438                 hints['complex'] = False
439                 return (self.expand(deep, **hints), S.Zero)
440             else:
441                 return (self, S.Zero)
442         if deep:
443             re, im = self.args[0].expand(deep, **hints).as_real_imag()
444         else:
445             re, im = self.args[0].as_real_imag()
446         denom = sinh(re)**2 + cos(im)**2
447         return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)
448 
449     def _eval_rewrite_as_tractable(self, arg):
450         neg_exp, pos_exp = exp(-arg), exp(arg)
451         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
452 
453     def _eval_rewrite_as_exp(self, arg):
454         neg_exp, pos_exp = exp(-arg), exp(arg)
455         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
456 
457     def _eval_rewrite_as_sinh(self, arg):
458         return S.ImaginaryUnit*sinh(arg)/sinh(S.Pi*S.ImaginaryUnit/2 - arg)
459 
460     def _eval_rewrite_as_cosh(self, arg):
461         return S.ImaginaryUnit*cosh(S.Pi*S.ImaginaryUnit/2 - arg)/cosh(arg)
462 
463     def _eval_rewrite_as_coth(self, arg):
464         return 1/coth(arg)
465 
466     def _eval_as_leading_term(self, x):
467         from sympy import Order
468         arg = self.args[0].as_leading_term(x)
469 
470         if x in arg.free_symbols and Order(1, x).contains(arg):
471             return arg
472         else:
473             return self.func(arg)
474 
475     def _eval_is_real(self):
476         return self.args[0].is_real
477 
478     def _eval_is_finite(self):
479         arg = self.args[0]
480         if arg.is_real:
481             return True
482 
483 
484 class coth(HyperbolicFunction):
485     r"""
486     The hyperbolic cotangent function, `\frac{\cosh(x)}{\sinh(x)}`.
487 
488     * coth(x) -> Returns the hyperbolic cotangent of x
489     """
490 
491     def fdiff(self, argindex=1):
492         if argindex == 1:
493             return -1/sinh(self.args[0])**2
494         else:
495             raise ArgumentIndexError(self, argindex)
496 
497     def inverse(self, argindex=1):
498         """
499         Returns the inverse of this function.
500         """
501         return acoth
502 
503     @classmethod
504     def eval(cls, arg):
505         from sympy import cot
506         arg = sympify(arg)
507 
508         if arg.is_Number:
509             if arg is S.NaN:
510                 return S.NaN
511             elif arg is S.Infinity:
512                 return S.One
513             elif arg is S.NegativeInfinity:
514                 return S.NegativeOne
515             elif arg is S.Zero:
516                 return S.ComplexInfinity
517             elif arg.is_negative:
518                 return -cls(-arg)
519         else:
520             if arg is S.ComplexInfinity:
521                 return S.NaN
522 
523             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
524 
525             if i_coeff is not None:
526                 if _coeff_isneg(i_coeff):
527                     return S.ImaginaryUnit * cot(-i_coeff)
528                 return -S.ImaginaryUnit * cot(i_coeff)
529             else:
530                 if _coeff_isneg(arg):
531                     return -cls(-arg)
532 
533             if arg.func == asinh:
534                 x = arg.args[0]
535                 return sqrt(1 + x**2)/x
536 
537             if arg.func == acosh:
538                 x = arg.args[0]
539                 return x/(sqrt(x - 1) * sqrt(x + 1))
540 
541             if arg.func == atanh:
542                 return 1/arg.args[0]
543 
544             if arg.func == acoth:
545                 return arg.args[0]
546 
547     @staticmethod
548     @cacheit
549     def taylor_term(n, x, *previous_terms):
550         from sympy import bernoulli
551         if n == 0:
552             return 1 / sympify(x)
553         elif n < 0 or n % 2 == 0:
554             return S.Zero
555         else:
556             x = sympify(x)
557 
558             B = bernoulli(n + 1)
559             F = factorial(n + 1)
560 
561             return 2**(n + 1) * B/F * x**n
562 
563     def _eval_conjugate(self):
564         return self.func(self.args[0].conjugate())
565 
566     def as_real_imag(self, deep=True, **hints):
567         from sympy import cos, sin
568         if self.args[0].is_real:
569             if deep:
570                 hints['complex'] = False
571                 return (self.expand(deep, **hints), S.Zero)
572             else:
573                 return (self, S.Zero)
574         if deep:
575             re, im = self.args[0].expand(deep, **hints).as_real_imag()
576         else:
577             re, im = self.args[0].as_real_imag()
578         denom = sinh(re)**2 + sin(im)**2
579         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)
580 
581     def _eval_rewrite_as_tractable(self, arg):
582         neg_exp, pos_exp = exp(-arg), exp(arg)
583         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
584 
585     def _eval_rewrite_as_exp(self, arg):
586         neg_exp, pos_exp = exp(-arg), exp(arg)
587         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
588 
589     def _eval_rewrite_as_sinh(self, arg):
590         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)
591 
592     def _eval_rewrite_as_cosh(self, arg):
593         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)
594 
595     def _eval_rewrite_as_tanh(self, arg):
596         return 1/tanh(arg)
597 
598     def _eval_as_leading_term(self, x):
599         from sympy import Order
600         arg = self.args[0].as_leading_term(x)
601 
602         if x in arg.free_symbols and Order(1, x).contains(arg):
603             return 1/arg
604         else:
605             return self.func(arg)
606 
607 
608 class ReciprocalHyperbolicFunction(HyperbolicFunction):
609     """Base class for reciprocal functions of hyperbolic functions. """
610 
611     #To be defined in class
612     _reciprocal_of = None
613     _is_even = None
614     _is_odd = None
615 
616     @classmethod
617     def eval(cls, arg):
618         if arg.could_extract_minus_sign():
619             if cls._is_even:
620                 return cls(-arg)
621             if cls._is_odd:
622                 return -cls(-arg)
623 
624         t = cls._reciprocal_of.eval(arg)
625         if hasattr(arg, 'inverse') and arg.inverse() == cls:
626             return arg.args[0]
627         return 1/t if t != None else t
628 
629     def _call_reciprocal(self, method_name, *args, **kwargs):
630         # Calls method_name on _reciprocal_of
631         o = self._reciprocal_of(self.args[0])
632         return getattr(o, method_name)(*args, **kwargs)
633 
634     def _calculate_reciprocal(self, method_name, *args, **kwargs):
635         # If calling method_name on _reciprocal_of returns a value != None
636         # then return the reciprocal of that value
637         t = self._call_reciprocal(method_name, *args, **kwargs)
638         return 1/t if t != None else t
639 
640     def _rewrite_reciprocal(self, method_name, arg):
641         # Special handling for rewrite functions. If reciprocal rewrite returns
642         # unmodified expression, then return None
643         t = self._call_reciprocal(method_name, arg)
644         if t != None and t != self._reciprocal_of(arg):
645             return 1/t
646 
647     def _eval_rewrite_as_exp(self, arg):
648         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
649 
650     def _eval_rewrite_as_tractable(self, arg):
651         return self._rewrite_reciprocal("_eval_rewrite_as_tractable", arg)
652 
653     def _eval_rewrite_as_tanh(self, arg):
654         return self._rewrite_reciprocal("_eval_rewrite_as_tanh", arg)
655 
656     def _eval_rewrite_as_coth(self, arg):
657         return self._rewrite_reciprocal("_eval_rewrite_as_coth", arg)
658 
659     def as_real_imag(self, deep = True, **hints):
660         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)
661 
662     def _eval_conjugate(self):
663         return self.func(self.args[0].conjugate())
664 
665     def _eval_expand_complex(self, deep=True, **hints):
666         re_part, im_part = self.as_real_imag(deep=True, **hints)
667         return re_part + S.ImaginaryUnit*im_part
668 
669     def _eval_as_leading_term(self, x):
670         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
671 
672     def _eval_is_real(self):
673         return self._reciprocal_of(self.args[0]).is_real
674 
675     def _eval_is_finite(self):
676         return (1/self._reciprocal_of(self.args[0])).is_finite
677 
678 
679 class csch(ReciprocalHyperbolicFunction):
680     r"""
681     The hyperbolic cosecant function, `\frac{2}{e^x - e^{-x}}`
682 
683     * csch(x) -> Returns the hyperbolic cosecant of x
684 
685     See Also
686     ========
687 
688     sinh, cosh, tanh, sech, asinh, acosh
689     """
690 
691     _reciprocal_of = sinh
692     _is_odd = True
693 
694     def fdiff(self, argindex=1):
695         """
696         Returns the first derivative of this function
697         """
698         if argindex == 1:
699             return -coth(self.args[0]) * csch(self.args[0])
700         else:
701             raise ArgumentIndexError(self, argindex)
702 
703     @staticmethod
704     @cacheit
705     def taylor_term(n, x, *previous_terms):
706         """
707         Returns the next term in the Taylor series expansion
708         """
709         from sympy import bernoulli
710         if n == 0:
711             return 1/sympify(x)
712         elif n < 0 or n % 2 == 0:
713             return S.Zero
714         else:
715             x = sympify(x)
716 
717             B = bernoulli(n + 1)
718             F = factorial(n + 1)
719 
720             return 2 * (1 - 2**n) * B/F * x**n
721 
722     def _eval_rewrite_as_cosh(self, arg):
723         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)
724 
725     def _sage_(self):
726         import sage.all as sage
727         return sage.csch(self.args[0]._sage_())
728 
729 
730 class sech(ReciprocalHyperbolicFunction):
731     r"""
732     The hyperbolic secant function, `\frac{2}{e^x + e^{-x}}`
733 
734     * sech(x) -> Returns the hyperbolic secant of x
735 
736     See Also
737     ========
738 
739     sinh, cosh, tanh, coth, csch, asinh, acosh
740     """
741 
742     _reciprocal_of = cosh
743     _is_even = True
744 
745     def fdiff(self, argindex=1):
746         if argindex == 1:
747             return - tanh(self.args[0])*sech(self.args[0])
748         else:
749             raise ArgumentIndexError(self, argindex)
750 
751     @staticmethod
752     @cacheit
753     def taylor_term(n, x, *previous_terms):
754         from sympy.functions.combinatorial.numbers import euler
755         if n < 0 or n % 2 == 1:
756             return S.Zero
757         else:
758             x = sympify(x)
759             return euler(n) / factorial(n) * x**(n)
760 
761     def _eval_rewrite_as_sinh(self, arg):
762         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)
763 
764     def _sage_(self):
765         import sage.all as sage
766         return sage.sech(self.args[0]._sage_())
767 
768 
769 
770 ###############################################################################
771 ############################# HYPERBOLIC INVERSES #############################
772 ###############################################################################
773 
774 class InverseHyperbolicFunction(Function):
775     """Base class for inverse hyperbolic functions."""
776 
777     pass
778 
779 
780 class asinh(InverseHyperbolicFunction):
781     """
782     The inverse hyperbolic sine function.
783 
784     * asinh(x) -> Returns the inverse hyperbolic sine of x
785 
786     See Also
787     ========
788 
789     acosh, atanh, sinh
790     """
791 
792     def fdiff(self, argindex=1):
793         if argindex == 1:
794             return 1/sqrt(self.args[0]**2 + 1)
795         else:
796             raise ArgumentIndexError(self, argindex)
797 
798     @classmethod
799     def eval(cls, arg):
800         from sympy import asin
801         arg = sympify(arg)
802 
803         if arg.is_Number:
804             if arg is S.NaN:
805                 return S.NaN
806             elif arg is S.Infinity:
807                 return S.Infinity
808             elif arg is S.NegativeInfinity:
809                 return S.NegativeInfinity
810             elif arg is S.Zero:
811                 return S.Zero
812             elif arg is S.One:
813                 return log(sqrt(2) + 1)
814             elif arg is S.NegativeOne:
815                 return log(sqrt(2) - 1)
816             elif arg.is_negative:
817                 return -cls(-arg)
818         else:
819             if arg is S.ComplexInfinity:
820                 return S.ComplexInfinity
821 
822             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
823 
824             if i_coeff is not None:
825                 return S.ImaginaryUnit * asin(i_coeff)
826             else:
827                 if _coeff_isneg(arg):
828                     return -cls(-arg)
829 
830     @staticmethod
831     @cacheit
832     def taylor_term(n, x, *previous_terms):
833         if n < 0 or n % 2 == 0:
834             return S.Zero
835         else:
836             x = sympify(x)
837             if len(previous_terms) >= 2 and n > 2:
838                 p = previous_terms[-2]
839                 return -p * (n - 2)**2/(n*(n - 1)) * x**2
840             else:
841                 k = (n - 1) // 2
842                 R = RisingFactorial(S.Half, k)
843                 F = factorial(k)
844                 return (-1)**k * R / F * x**n / n
845 
846     def _eval_as_leading_term(self, x):
847         from sympy import Order
848         arg = self.args[0].as_leading_term(x)
849 
850         if x in arg.free_symbols and Order(1, x).contains(arg):
851             return arg
852         else:
853             return self.func(arg)
854 
855     def _eval_rewrite_as_log(self, x):
856         return log(x + sqrt(x**2 + 1))
857 
858     def inverse(self, argindex=1):
859         """
860         Returns the inverse of this function.
861         """
862         return sinh
863 
864 
865 class acosh(InverseHyperbolicFunction):
866     """
867     The inverse hyperbolic cosine function.
868 
869     * acosh(x) -> Returns the inverse hyperbolic cosine of x
870 
871     See Also
872     ========
873 
874     asinh, atanh, cosh
875     """
876 
877     def fdiff(self, argindex=1):
878         if argindex == 1:
879             return 1/sqrt(self.args[0]**2 - 1)
880         else:
881             raise ArgumentIndexError(self, argindex)
882 
883     @classmethod
884     def eval(cls, arg):
885         arg = sympify(arg)
886 
887         if arg.is_Number:
888             if arg is S.NaN:
889                 return S.NaN
890             elif arg is S.Infinity:
891                 return S.Infinity
892             elif arg is S.NegativeInfinity:
893                 return S.Infinity
894             elif arg is S.Zero:
895                 return S.Pi*S.ImaginaryUnit / 2
896             elif arg is S.One:
897                 return S.Zero
898             elif arg is S.NegativeOne:
899                 return S.Pi*S.ImaginaryUnit
900 
901         if arg.is_number:
902             cst_table = {
903                 S.ImaginaryUnit: log(S.ImaginaryUnit*(1 + sqrt(2))),
904                 -S.ImaginaryUnit: log(-S.ImaginaryUnit*(1 + sqrt(2))),
905                 S.Half: S.Pi/3,
906                 -S.Half: 2*S.Pi/3,
907                 sqrt(2)/2: S.Pi/4,
908                 -sqrt(2)/2: 3*S.Pi/4,
909                 1/sqrt(2): S.Pi/4,
910                 -1/sqrt(2): 3*S.Pi/4,
911                 sqrt(3)/2: S.Pi/6,
912                 -sqrt(3)/2: 5*S.Pi/6,
913                 (sqrt(3) - 1)/sqrt(2**3): 5*S.Pi/12,
914                 -(sqrt(3) - 1)/sqrt(2**3): 7*S.Pi/12,
915                 sqrt(2 + sqrt(2))/2: S.Pi/8,
916                 -sqrt(2 + sqrt(2))/2: 7*S.Pi/8,
917                 sqrt(2 - sqrt(2))/2: 3*S.Pi/8,
918                 -sqrt(2 - sqrt(2))/2: 5*S.Pi/8,
919                 (1 + sqrt(3))/(2*sqrt(2)): S.Pi/12,
920                 -(1 + sqrt(3))/(2*sqrt(2)): 11*S.Pi/12,
921                 (sqrt(5) + 1)/4: S.Pi/5,
922                 -(sqrt(5) + 1)/4: 4*S.Pi/5
923             }
924 
925             if arg in cst_table:
926                 if arg.is_real:
927                     return cst_table[arg]*S.ImaginaryUnit
928                 return cst_table[arg]
929 
930         if arg.is_infinite:
931             return S.Infinity
932 
933     @staticmethod
934     @cacheit
935     def taylor_term(n, x, *previous_terms):
936         if n == 0:
937             return S.Pi*S.ImaginaryUnit / 2
938         elif n < 0 or n % 2 == 0:
939             return S.Zero
940         else:
941             x = sympify(x)
942             if len(previous_terms) >= 2 and n > 2:
943                 p = previous_terms[-2]
944                 return p * (n - 2)**2/(n*(n - 1)) * x**2
945             else:
946                 k = (n - 1) // 2
947                 R = RisingFactorial(S.Half, k)
948                 F = factorial(k)
949                 return -R / F * S.ImaginaryUnit * x**n / n
950 
951     def _eval_as_leading_term(self, x):
952         from sympy import Order
953         arg = self.args[0].as_leading_term(x)
954 
955         if x in arg.free_symbols and Order(1, x).contains(arg):
956             return S.ImaginaryUnit*S.Pi/2
957         else:
958             return self.func(arg)
959 
960     def _eval_rewrite_as_log(self, x):
961         return log(x + sqrt(x + 1) * sqrt(x - 1))
962 
963     def inverse(self, argindex=1):
964         """
965         Returns the inverse of this function.
966         """
967         return cosh
968 
969 
970 class atanh(InverseHyperbolicFunction):
971     """
972     The inverse hyperbolic tangent function.
973 
974     * atanh(x) -> Returns the inverse hyperbolic tangent of x
975 
976     See Also
977     ========
978 
979     asinh, acosh, tanh
980     """
981 
982     def fdiff(self, argindex=1):
983         if argindex == 1:
984             return 1/(1 - self.args[0]**2)
985         else:
986             raise ArgumentIndexError(self, argindex)
987 
988     @classmethod
989     def eval(cls, arg):
990         from sympy import atan
991         arg = sympify(arg)
992 
993         if arg.is_Number:
994             if arg is S.NaN:
995                 return S.NaN
996             elif arg is S.Zero:
997                 return S.Zero
998             elif arg is S.One:
999                 return S.Infinity
1000             elif arg is S.NegativeOne:
1001                 return S.NegativeInfinity
1002             elif arg is S.Infinity:
1003                 return -S.ImaginaryUnit * atan(arg)
1004             elif arg is S.NegativeInfinity:
1005                 return S.ImaginaryUnit * atan(-arg)
1006             elif arg.is_negative:
1007                 return -cls(-arg)
1008         else:
1009             if arg is S.ComplexInfinity:
1010                 return S.NaN
1011 
1012             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1013 
1014             if i_coeff is not None:
1015                 return S.ImaginaryUnit * atan(i_coeff)
1016             else:
1017                 if _coeff_isneg(arg):
1018                     return -cls(-arg)
1019 
1020     @staticmethod
1021     @cacheit
1022     def taylor_term(n, x, *previous_terms):
1023         if n < 0 or n % 2 == 0:
1024             return S.Zero
1025         else:
1026             x = sympify(x)
1027             return x**n / n
1028 
1029     def _eval_as_leading_term(self, x):
1030         from sympy import Order
1031         arg = self.args[0].as_leading_term(x)
1032 
1033         if x in arg.free_symbols and Order(1, x).contains(arg):
1034             return arg
1035         else:
1036             return self.func(arg)
1037 
1038     def _eval_rewrite_as_log(self, x):
1039         return (log(1 + x) - log(1 - x)) / 2
1040 
1041     def inverse(self, argindex=1):
1042         """
1043         Returns the inverse of this function.
1044         """
1045         return tanh
1046 
1047 
1048 class acoth(InverseHyperbolicFunction):
1049     """
1050     The inverse hyperbolic cotangent function.
1051 
1052     * acoth(x) -> Returns the inverse hyperbolic cotangent of x
1053     """
1054 
1055     def fdiff(self, argindex=1):
1056         if argindex == 1:
1057             return 1/(1 - self.args[0]**2)
1058         else:
1059             raise ArgumentIndexError(self, argindex)
1060 
1061     @classmethod
1062     def eval(cls, arg):
1063         from sympy import acot
1064         arg = sympify(arg)
1065 
1066         if arg.is_Number:
1067             if arg is S.NaN:
1068                 return S.NaN
1069             elif arg is S.Infinity:
1070                 return S.Zero
1071             elif arg is S.NegativeInfinity:
1072                 return S.Zero
1073             elif arg is S.Zero:
1074                 return S.Pi*S.ImaginaryUnit / 2
1075             elif arg is S.One:
1076                 return S.Infinity
1077             elif arg is S.NegativeOne:
1078                 return S.NegativeInfinity
1079             elif arg.is_negative:
1080                 return -cls(-arg)
1081         else:
1082             if arg is S.ComplexInfinity:
1083                 return 0
1084 
1085             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1086 
1087             if i_coeff is not None:
1088                 return -S.ImaginaryUnit * acot(i_coeff)
1089             else:
1090                 if _coeff_isneg(arg):
1091                     return -cls(-arg)
1092 
1093     @staticmethod
1094     @cacheit
1095     def taylor_term(n, x, *previous_terms):
1096         if n == 0:
1097             return S.Pi*S.ImaginaryUnit / 2
1098         elif n < 0 or n % 2 == 0:
1099             return S.Zero
1100         else:
1101             x = sympify(x)
1102             return x**n / n
1103 
1104     def _eval_as_leading_term(self, x):
1105         from sympy import Order
1106         arg = self.args[0].as_leading_term(x)
1107 
1108         if x in arg.free_symbols and Order(1, x).contains(arg):
1109             return S.ImaginaryUnit*S.Pi/2
1110         else:
1111             return self.func(arg)
1112 
1113     def _eval_rewrite_as_log(self, x):
1114         return (log(1 + 1/x) - log(1 - 1/x)) / 2
1115 
1116     def inverse(self, argindex=1):
1117         """
1118         Returns the inverse of this function.
1119         """
1120         return coth
1121 
1122 
1123 class asech(InverseHyperbolicFunction):
1124     """
1125     The inverse hyperbolic secant function.
1126 
1127     * asech(x) -> Returns the inverse hyperbolic secant of x
1128 
1129     Examples
1130     ========
1131 
1132     >>> from sympy import asech, sqrt, S
1133     >>> from sympy.abc import x
1134     >>> asech(x).diff(x)
1135     -1/(x*sqrt(-x**2 + 1))
1136     >>> asech(1).diff(x)
1137     0
1138     >>> asech(1)
1139     0
1140     >>> asech(S(2))
1141     I*pi/3
1142     >>> asech(-sqrt(2))
1143     3*I*pi/4
1144     >>> asech((sqrt(6) - sqrt(2)))
1145     I*pi/12
1146 
1147     See Also
1148     ========
1149 
1150     asinh, atanh, cosh, acoth
1151 
1152     References
1153     ==========
1154 
1155     .. [1] http://en.wikipedia.org/wiki/Hyperbolic_function
1156     .. [2] http://dlmf.nist.gov/4.37
1157     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSech/
1158 
1159     """
1160 
1161     def fdiff(self, argindex=1):
1162         if argindex == 1:
1163             z = self.args[0]
1164             return -1/(z*sqrt(1 - z**2))
1165         else:
1166             raise ArgumentIndexError(self, argindex)
1167 
1168     @classmethod
1169     def eval(cls, arg):
1170         arg = sympify(arg)
1171 
1172         if arg.is_Number:
1173             if arg is S.NaN:
1174                 return S.NaN
1175             elif arg is S.Infinity:
1176                 return S.Pi*S.ImaginaryUnit / 2
1177             elif arg is S.NegativeInfinity:
1178                 return S.Pi*S.ImaginaryUnit / 2
1179             elif arg is S.Zero:
1180                 return S.Infinity
1181             elif arg is S.One:
1182                 return S.Zero
1183             elif arg is S.NegativeOne:
1184                 return S.Pi*S.ImaginaryUnit
1185 
1186         if arg.is_number:
1187             cst_table = {
1188                 S.ImaginaryUnit: - (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1189                 -S.ImaginaryUnit: (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1190                 (sqrt(6) - sqrt(2)): S.Pi / 12,
1191                 (sqrt(2) - sqrt(6)): 11*S.Pi / 12,
1192                 sqrt(2 - 2/sqrt(5)): S.Pi / 10,
1193                 -sqrt(2 - 2/sqrt(5)): 9*S.Pi / 10,
1194                 2 / sqrt(2 + sqrt(2)): S.Pi / 8,
1195                 -2 / sqrt(2 + sqrt(2)): 7*S.Pi / 8,
1196                 2 / sqrt(3): S.Pi / 6,
1197                 -2 / sqrt(3): 5*S.Pi / 6,
1198                 (sqrt(5) - 1): S.Pi / 5,
1199                 (1 - sqrt(5)): 4*S.Pi / 5,
1200                 sqrt(2): S.Pi / 4,
1201                 -sqrt(2): 3*S.Pi / 4,
1202                 sqrt(2 + 2/sqrt(5)): 3*S.Pi / 10,
1203                 -sqrt(2 + 2/sqrt(5)): 7*S.Pi / 10,
1204                 S(2): S.Pi / 3,
1205                 -S(2): 2*S.Pi / 3,
1206                 sqrt(2*(2 + sqrt(2))): 3*S.Pi / 8,
1207                 -sqrt(2*(2 + sqrt(2))): 5*S.Pi / 8,
1208                 (1 + sqrt(5)): 2*S.Pi / 5,
1209                 (-1 - sqrt(5)): 3*S.Pi / 5,
1210                 (sqrt(6) + sqrt(2)): 5*S.Pi / 12,
1211                 (-sqrt(6) - sqrt(2)): 7*S.Pi / 12,
1212             }
1213 
1214             if arg in cst_table:
1215                 if arg.is_real:
1216                     return cst_table[arg]*S.ImaginaryUnit
1217                 return cst_table[arg]
1218 
1219         if arg is S.ComplexInfinity:
1220             return S.NaN
1221 
1222     @staticmethod
1223     @cacheit
1224     def expansion_term(n, x, *previous_terms):
1225         if n == 0:
1226             return log(2 / x)
1227         elif n < 0 or n % 2 == 1:
1228             return S.Zero
1229         else:
1230             x = sympify(x)
1231             if len(previous_terms) > 2 and n > 2:
1232                 p = previous_terms[-2]
1233                 return p * (n - 1)**2 // (n // 2)**2 * x**2 / 4
1234             else:
1235                 k = n // 2
1236                 R = RisingFactorial(S.Half , k) *  n
1237                 F = factorial(k) * n // 2 * n // 2
1238                 return -1 * R / F * x**n / 4
1239 
1240     def inverse(self, argindex=1):
1241         """
1242         Returns the inverse of this function.
1243         """
1244         return sech
1245 
1246     def _eval_rewrite_as_log(self, arg):
1247         return log(1/arg + sqrt(1/arg - 1) * sqrt(1/arg + 1))
1248 
1249 
1250 class acsch(InverseHyperbolicFunction):
1251     """
1252     The inverse hyperbolic cosecant function.
1253 
1254     * acsch(x) -> Returns the inverse hyperbolic cosecant of x
1255 
1256     Examples
1257     ========
1258 
1259     >>> from sympy import acsch, sqrt, S
1260     >>> from sympy.abc import x
1261     >>> acsch(x).diff(x)
1262     -1/(x**2*sqrt(1 + x**(-2)))
1263     >>> acsch(1).diff(x)
1264     0
1265     >>> acsch(1)
1266     log(1 + sqrt(2))
1267     >>> acsch(S.ImaginaryUnit)
1268     -I*pi/2
1269     >>> acsch(-2*S.ImaginaryUnit)
1270     I*pi/6
1271     >>> acsch(S.ImaginaryUnit*(sqrt(6) - sqrt(2)))
1272     -5*I*pi/12
1273 
1274     References
1275     ==========
1276 
1277     .. [1] http://en.wikipedia.org/wiki/Hyperbolic_function
1278     .. [2] http://dlmf.nist.gov/4.37
1279     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsch/
1280 
1281     """
1282 
1283     def fdiff(self, argindex=1):
1284         if argindex == 1:
1285             z = self.args[0]
1286             return -1/(z**2*sqrt(1 + 1/z**2))
1287         else:
1288             raise ArgumentIndexError(self, argindex)
1289 
1290     @classmethod
1291     def eval(cls, arg):
1292         arg = sympify(arg)
1293 
1294         if arg.is_Number:
1295             if arg is S.NaN:
1296                 return S.NaN
1297             elif arg is S.Infinity:
1298                 return S.Zero
1299             elif arg is S.NegativeInfinity:
1300                 return S.Zero
1301             elif arg is S.Zero:
1302                 return S.ComplexInfinity
1303             elif arg is S.One:
1304                 return log(1 + sqrt(2))
1305             elif arg is S.NegativeOne:
1306                 return - log(1 + sqrt(2))
1307 
1308         if arg.is_number:
1309             cst_table = {
1310                 S.ImaginaryUnit: -S.Pi / 2,
1311                 S.ImaginaryUnit*(sqrt(2) + sqrt(6)): -S.Pi / 12,
1312                 S.ImaginaryUnit*(1 + sqrt(5)): -S.Pi / 10,
1313                 S.ImaginaryUnit*2 / sqrt(2 - sqrt(2)): -S.Pi / 8,
1314                 S.ImaginaryUnit*2: -S.Pi / 6,
1315                 S.ImaginaryUnit*sqrt(2 + 2/sqrt(5)): -S.Pi / 5,
1316                 S.ImaginaryUnit*sqrt(2): -S.Pi / 4,
1317                 S.ImaginaryUnit*(sqrt(5)-1): -3*S.Pi / 10,
1318                 S.ImaginaryUnit*2 / sqrt(3): -S.Pi / 3,
1319                 S.ImaginaryUnit*2 / sqrt(2 + sqrt(2)): -3*S.Pi / 8,
1320                 S.ImaginaryUnit*sqrt(2 - 2/sqrt(5)): -2*S.Pi / 5,
1321                 S.ImaginaryUnit*(sqrt(6) - sqrt(2)): -5*S.Pi / 12,
1322                 S(2): -S.ImaginaryUnit*log((1+sqrt(5))/2),
1323             }
1324 
1325             if arg in cst_table:
1326                 return cst_table[arg]*S.ImaginaryUnit
1327 
1328         if arg is S.ComplexInfinity:
1329             return S.Zero
1330 
1331         if _coeff_isneg(arg):
1332             return -cls(-arg)
1333 
1334     def inverse(self, argindex=1):
1335         """
1336         Returns the inverse of this function.
1337         """
1338         return csch
1339 
1340     def _eval_rewrite_as_log(self, arg):
1341         return log(1/arg + sqrt(1/arg**2 + 1))

</code><intended_behavior>Review and potentially enhance the logic dealing with the interplay between trigonometric functions and complex arguments to ensure correct application of mathematical principles.</intended_behavior>]
2025-10-15 13:13:05.000 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 13:13:05.000 | INFO     | Search-only: skipping patch selection
2025-10-15 13:13:05.119 | INFO     | Task sympy__sympy-13259 completed successfully.
2025-10-15 13:13:05.120 | INFO     | No patch generated. You can try running ACR again.
