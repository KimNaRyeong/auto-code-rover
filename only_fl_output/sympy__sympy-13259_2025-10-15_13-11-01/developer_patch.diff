diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py
--- a/sympy/functions/elementary/hyperbolic.py
+++ b/sympy/functions/elementary/hyperbolic.py
@@ -1,6 +1,7 @@
 from __future__ import print_function, division
 
 from sympy.core import S, sympify, cacheit
+from sympy.core.add import Add
 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
 
 from sympy.functions.elementary.miscellaneous import sqrt
@@ -33,6 +34,39 @@ class HyperbolicFunction(Function):
     unbranched = True
 
 
+def _peeloff_ipi(arg):
+    """
+    Split ARG into two parts, a "rest" and a multiple of I*pi/2.
+    This assumes ARG to be an Add.
+    The multiple of I*pi returned in the second position is always a Rational.
+
+    Examples
+    ========
+
+    >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel
+    >>> from sympy import pi, I
+    >>> from sympy.abc import x, y
+    >>> peel(x + I*pi/2)
+    (x, I*pi/2)
+    >>> peel(x + I*2*pi/3 + I*pi*y)
+    (x + I*pi*y + I*pi/6, I*pi/2)
+    """
+    for a in Add.make_args(arg):
+        if a == S.Pi*S.ImaginaryUnit:
+            K = S.One
+            break
+        elif a.is_Mul:
+            K, p = a.as_two_terms()
+            if p == S.Pi*S.ImaginaryUnit and K.is_Rational:
+                break
+    else:
+        return arg, S.Zero
+
+    m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit
+    m2 = K*S.Pi*S.ImaginaryUnit - m1
+    return arg - m2, m2
+
+
 class sinh(HyperbolicFunction):
     r"""
     The hyperbolic sine function, `\frac{e^x - e^{-x}}{2}`.
@@ -89,6 +123,11 @@ def eval(cls, arg):
                 if _coeff_isneg(arg):
                     return -cls(-arg)
 
+            if arg.is_Add:
+                x, m = _peeloff_ipi(arg)
+                if m:
+                    return sinh(m)*cosh(x) + cosh(m)*sinh(x)
+
             if arg.func == asinh:
                 return arg.args[0]
 
@@ -243,6 +282,11 @@ def eval(cls, arg):
                 if _coeff_isneg(arg):
                     return cls(-arg)
 
+            if arg.is_Add:
+                x, m = _peeloff_ipi(arg)
+                if m:
+                    return cosh(m)*cosh(x) + sinh(m)*sinh(x)
+
             if arg.func == asinh:
                 return sqrt(1 + arg.args[0]**2)
 
@@ -398,6 +442,15 @@ def eval(cls, arg):
                 if _coeff_isneg(arg):
                     return -cls(-arg)
 
+            if arg.is_Add:
+                x, m = _peeloff_ipi(arg)
+                if m:
+                    tanhm = tanh(m)
+                    if tanhm is S.ComplexInfinity:
+                        return coth(x)
+                    else: # tanhm == 0
+                        return tanh(x)
+
             if arg.func == asinh:
                 x = arg.args[0]
                 return x/sqrt(1 + x**2)
@@ -530,6 +583,15 @@ def eval(cls, arg):
                 if _coeff_isneg(arg):
                     return -cls(-arg)
 
+            if arg.is_Add:
+                x, m = _peeloff_ipi(arg)
+                if m:
+                    cothm = coth(m)
+                    if cotm is S.ComplexInfinity:
+                        return coth(x)
+                    else: # cothm == 0
+                        return tanh(x)
+
             if arg.func == asinh:
                 x = arg.args[0]
                 return sqrt(1 + x**2)/x
diff --git a/sympy/functions/elementary/trigonometric.py b/sympy/functions/elementary/trigonometric.py
--- a/sympy/functions/elementary/trigonometric.py
+++ b/sympy/functions/elementary/trigonometric.py
@@ -1018,10 +1018,10 @@ def eval(cls, arg):
             x, m = _peeloff_pi(arg)
             if m:
                 tanm = tan(m)
-                tanx = tan(x)
                 if tanm is S.ComplexInfinity:
                     return -cot(x)
-                return (tanm + tanx)/(1 - tanm*tanx)
+                else: # tanm == 0
+                    return tan(x)
 
         if arg.func is atan:
             return arg.args[0]
@@ -1300,14 +1300,10 @@ def eval(cls, arg):
             x, m = _peeloff_pi(arg)
             if m:
                 cotm = cot(m)
-                if cotm == 0:
-                    return -tan(x)
-                cotx = cot(x)
                 if cotm is S.ComplexInfinity:
-                    return cotx
-                if cotm.is_Rational:
-                    return (cotm*cotx - 1) / (cotm + cotx)
-            return None
+                    return cot(x)
+                else: # cotm == 0
+                    return -tan(x)
 
         if arg.func is acot:
             return arg.args[0]
diff --git a/sympy/simplify/fu.py b/sympy/simplify/fu.py
--- a/sympy/simplify/fu.py
+++ b/sympy/simplify/fu.py
@@ -195,7 +195,7 @@
 from sympy.functions.elementary.trigonometric import (
     cos, sin, tan, cot, sec, csc, sqrt, TrigonometricFunction)
 from sympy.functions.elementary.hyperbolic import (
-    cosh, sinh, tanh, coth, HyperbolicFunction)
+    cosh, sinh, tanh, coth, sech, csch, HyperbolicFunction)
 from sympy.core.compatibility import ordered, range
 from sympy.core.expr import Expr
 from sympy.core.mul import Mul
@@ -2049,6 +2049,10 @@ def f(rv):
             return I*tan(a)
         elif rv.func is coth:
             return cot(a)/I
+        elif rv.func is sech:
+            return sec(a)
+        elif rv.func is csch:
+            return csc(a)/I
         else:
             raise NotImplementedError('unhandled %s' % rv.func)
 
@@ -2074,7 +2078,8 @@ def _osbornei(e, d):
     def f(rv):
         if not isinstance(rv, TrigonometricFunction):
             return rv
-        a = rv.args[0].xreplace({d: S.One})
+        const, x = rv.args[0].as_independent(d, as_Add=True)
+        a = x.xreplace({d: S.One}) + const*I
         if rv.func is sin:
             return sinh(a)/I
         elif rv.func is cos:
@@ -2084,9 +2089,9 @@ def f(rv):
         elif rv.func is cot:
             return coth(a)*I
         elif rv.func is sec:
-            return 1/cosh(a)
+            return sech(a)
         elif rv.func is csc:
-            return I/sinh(a)
+            return csch(a)*I
         else:
             raise NotImplementedError('unhandled %s' % rv.func)
 
